var gp = Object.defineProperty;
var hp = (r, n, t) => n in r ? gp(r, n, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[n] = t;
var Tt = (r, n, t) => (hp(r, typeof n != "symbol" ? n + "" : n, t), t);
import * as Er from "react";
import $t, { useCallback as Vt, useEffect as yt, Suspense as Ki, useRef as Cn, useState as ut, createContext as Rg, useContext as pp, useMemo as Zr } from "react";
import bg from "katex";
import * as ml from "react-dom";
import Ag, { createPortal as Bo } from "react-dom";
var Oa = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Dg(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Vc = { exports: {} }, il = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Wu;
function mp() {
  if (Wu)
    return il;
  Wu = 1;
  var r = $t, n = Symbol.for("react.element"), t = Symbol.for("react.fragment"), o = Object.prototype.hasOwnProperty, u = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: !0, ref: !0, __self: !0, __source: !0 };
  function m(f, O, S) {
    var E, R = {}, y = null, g = null;
    S !== void 0 && (y = "" + S), O.key !== void 0 && (y = "" + O.key), O.ref !== void 0 && (g = O.ref);
    for (E in O)
      o.call(O, E) && !p.hasOwnProperty(E) && (R[E] = O[E]);
    if (f && f.defaultProps)
      for (E in O = f.defaultProps, O)
        R[E] === void 0 && (R[E] = O[E]);
    return { $$typeof: n, type: f, key: y, ref: g, props: R, _owner: u.current };
  }
  return il.Fragment = t, il.jsx = m, il.jsxs = m, il;
}
var sl = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Uu;
function _p() {
  return Uu || (Uu = 1, process.env.NODE_ENV !== "production" && function() {
    var r = $t, n = Symbol.for("react.element"), t = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), u = Symbol.for("react.strict_mode"), p = Symbol.for("react.profiler"), m = Symbol.for("react.provider"), f = Symbol.for("react.context"), O = Symbol.for("react.forward_ref"), S = Symbol.for("react.suspense"), E = Symbol.for("react.suspense_list"), R = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), _ = Symbol.iterator, N = "@@iterator";
    function w(_e) {
      if (_e === null || typeof _e != "object")
        return null;
      var Ue = _ && _e[_] || _e[N];
      return typeof Ue == "function" ? Ue : null;
    }
    var T = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function D(_e) {
      {
        for (var Ue = arguments.length, at = new Array(Ue > 1 ? Ue - 1 : 0), Rt = 1; Rt < Ue; Rt++)
          at[Rt - 1] = arguments[Rt];
        C("error", _e, at);
      }
    }
    function C(_e, Ue, at) {
      {
        var Rt = T.ReactDebugCurrentFrame, Xt = Rt.getStackAddendum();
        Xt !== "" && (Ue += "%s", at = at.concat([Xt]));
        var Zt = at.map(function(Wt) {
          return String(Wt);
        });
        Zt.unshift("Warning: " + Ue), Function.prototype.apply.call(console[_e], console, Zt);
      }
    }
    var x = !1, I = !1, W = !1, $ = !1, B = !1, L;
    L = Symbol.for("react.module.reference");
    function P(_e) {
      return !!(typeof _e == "string" || typeof _e == "function" || _e === o || _e === p || B || _e === u || _e === S || _e === E || $ || _e === g || x || I || W || typeof _e == "object" && _e !== null && (_e.$$typeof === y || _e.$$typeof === R || _e.$$typeof === m || _e.$$typeof === f || _e.$$typeof === O || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      _e.$$typeof === L || _e.getModuleId !== void 0));
    }
    function F(_e, Ue, at) {
      var Rt = _e.displayName;
      if (Rt)
        return Rt;
      var Xt = Ue.displayName || Ue.name || "";
      return Xt !== "" ? at + "(" + Xt + ")" : at;
    }
    function Z(_e) {
      return _e.displayName || "Context";
    }
    function oe(_e) {
      if (_e == null)
        return null;
      if (typeof _e.tag == "number" && D("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof _e == "function")
        return _e.displayName || _e.name || null;
      if (typeof _e == "string")
        return _e;
      switch (_e) {
        case o:
          return "Fragment";
        case t:
          return "Portal";
        case p:
          return "Profiler";
        case u:
          return "StrictMode";
        case S:
          return "Suspense";
        case E:
          return "SuspenseList";
      }
      if (typeof _e == "object")
        switch (_e.$$typeof) {
          case f:
            var Ue = _e;
            return Z(Ue) + ".Consumer";
          case m:
            var at = _e;
            return Z(at._context) + ".Provider";
          case O:
            return F(_e, _e.render, "ForwardRef");
          case R:
            var Rt = _e.displayName || null;
            return Rt !== null ? Rt : oe(_e.type) || "Memo";
          case y: {
            var Xt = _e, Zt = Xt._payload, Wt = Xt._init;
            try {
              return oe(Wt(Zt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ne = Object.assign, te = 0, K, A, z, ie, q, Y, se;
    function j() {
    }
    j.__reactDisabledLog = !0;
    function Q() {
      {
        if (te === 0) {
          K = console.log, A = console.info, z = console.warn, ie = console.error, q = console.group, Y = console.groupCollapsed, se = console.groupEnd;
          var _e = {
            configurable: !0,
            enumerable: !0,
            value: j,
            writable: !0
          };
          Object.defineProperties(console, {
            info: _e,
            log: _e,
            warn: _e,
            error: _e,
            group: _e,
            groupCollapsed: _e,
            groupEnd: _e
          });
        }
        te++;
      }
    }
    function ae() {
      {
        if (te--, te === 0) {
          var _e = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: ne({}, _e, {
              value: K
            }),
            info: ne({}, _e, {
              value: A
            }),
            warn: ne({}, _e, {
              value: z
            }),
            error: ne({}, _e, {
              value: ie
            }),
            group: ne({}, _e, {
              value: q
            }),
            groupCollapsed: ne({}, _e, {
              value: Y
            }),
            groupEnd: ne({}, _e, {
              value: se
            })
          });
        }
        te < 0 && D("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var de = T.ReactCurrentDispatcher, Ne;
    function De(_e, Ue, at) {
      {
        if (Ne === void 0)
          try {
            throw Error();
          } catch (Xt) {
            var Rt = Xt.stack.trim().match(/\n( *(at )?)/);
            Ne = Rt && Rt[1] || "";
          }
        return `
` + Ne + _e;
      }
    }
    var Pe = !1, Le;
    {
      var ke = typeof WeakMap == "function" ? WeakMap : Map;
      Le = new ke();
    }
    function J(_e, Ue) {
      if (!_e || Pe)
        return "";
      {
        var at = Le.get(_e);
        if (at !== void 0)
          return at;
      }
      var Rt;
      Pe = !0;
      var Xt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Zt;
      Zt = de.current, de.current = null, Q();
      try {
        if (Ue) {
          var Wt = function() {
            throw Error();
          };
          if (Object.defineProperty(Wt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Wt, []);
            } catch (Fn) {
              Rt = Fn;
            }
            Reflect.construct(_e, [], Wt);
          } else {
            try {
              Wt.call();
            } catch (Fn) {
              Rt = Fn;
            }
            _e.call(Wt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Fn) {
            Rt = Fn;
          }
          _e();
        }
      } catch (Fn) {
        if (Fn && Rt && typeof Fn.stack == "string") {
          for (var Ht = Fn.stack.split(`
`), yn = Rt.stack.split(`
`), cn = Ht.length - 1, un = yn.length - 1; cn >= 1 && un >= 0 && Ht[cn] !== yn[un]; )
            un--;
          for (; cn >= 1 && un >= 0; cn--, un--)
            if (Ht[cn] !== yn[un]) {
              if (cn !== 1 || un !== 1)
                do
                  if (cn--, un--, un < 0 || Ht[cn] !== yn[un]) {
                    var On = `
` + Ht[cn].replace(" at new ", " at ");
                    return _e.displayName && On.includes("<anonymous>") && (On = On.replace("<anonymous>", _e.displayName)), typeof _e == "function" && Le.set(_e, On), On;
                  }
                while (cn >= 1 && un >= 0);
              break;
            }
        }
      } finally {
        Pe = !1, de.current = Zt, ae(), Error.prepareStackTrace = Xt;
      }
      var Qn = _e ? _e.displayName || _e.name : "", fn = Qn ? De(Qn) : "";
      return typeof _e == "function" && Le.set(_e, fn), fn;
    }
    function G(_e, Ue, at) {
      return J(_e, !1);
    }
    function H(_e) {
      var Ue = _e.prototype;
      return !!(Ue && Ue.isReactComponent);
    }
    function re(_e, Ue, at) {
      if (_e == null)
        return "";
      if (typeof _e == "function")
        return J(_e, H(_e));
      if (typeof _e == "string")
        return De(_e);
      switch (_e) {
        case S:
          return De("Suspense");
        case E:
          return De("SuspenseList");
      }
      if (typeof _e == "object")
        switch (_e.$$typeof) {
          case O:
            return G(_e.render);
          case R:
            return re(_e.type, Ue, at);
          case y: {
            var Rt = _e, Xt = Rt._payload, Zt = Rt._init;
            try {
              return re(Zt(Xt), Ue, at);
            } catch {
            }
          }
        }
      return "";
    }
    var le = Object.prototype.hasOwnProperty, me = {}, ge = T.ReactDebugCurrentFrame;
    function Me(_e) {
      if (_e) {
        var Ue = _e._owner, at = re(_e.type, _e._source, Ue ? Ue.type : null);
        ge.setExtraStackFrame(at);
      } else
        ge.setExtraStackFrame(null);
    }
    function Ie(_e, Ue, at, Rt, Xt) {
      {
        var Zt = Function.call.bind(le);
        for (var Wt in _e)
          if (Zt(_e, Wt)) {
            var Ht = void 0;
            try {
              if (typeof _e[Wt] != "function") {
                var yn = Error((Rt || "React class") + ": " + at + " type `" + Wt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof _e[Wt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw yn.name = "Invariant Violation", yn;
              }
              Ht = _e[Wt](Ue, Wt, Rt, at, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (cn) {
              Ht = cn;
            }
            Ht && !(Ht instanceof Error) && (Me(Xt), D("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Rt || "React class", at, Wt, typeof Ht), Me(null)), Ht instanceof Error && !(Ht.message in me) && (me[Ht.message] = !0, Me(Xt), D("Failed %s type: %s", at, Ht.message), Me(null));
          }
      }
    }
    var je = Array.isArray;
    function Oe(_e) {
      return je(_e);
    }
    function be(_e) {
      {
        var Ue = typeof Symbol == "function" && Symbol.toStringTag, at = Ue && _e[Symbol.toStringTag] || _e.constructor.name || "Object";
        return at;
      }
    }
    function He(_e) {
      try {
        return Ge(_e), !1;
      } catch {
        return !0;
      }
    }
    function Ge(_e) {
      return "" + _e;
    }
    function dt(_e) {
      if (He(_e))
        return D("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", be(_e)), Ge(_e);
    }
    var nt = T.ReactCurrentOwner, At = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, an, Gt, Ot;
    Ot = {};
    function Te(_e) {
      if (le.call(_e, "ref")) {
        var Ue = Object.getOwnPropertyDescriptor(_e, "ref").get;
        if (Ue && Ue.isReactWarning)
          return !1;
      }
      return _e.ref !== void 0;
    }
    function ue(_e) {
      if (le.call(_e, "key")) {
        var Ue = Object.getOwnPropertyDescriptor(_e, "key").get;
        if (Ue && Ue.isReactWarning)
          return !1;
      }
      return _e.key !== void 0;
    }
    function he(_e, Ue) {
      if (typeof _e.ref == "string" && nt.current && Ue && nt.current.stateNode !== Ue) {
        var at = oe(nt.current.type);
        Ot[at] || (D('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', oe(nt.current.type), _e.ref), Ot[at] = !0);
      }
    }
    function Se(_e, Ue) {
      {
        var at = function() {
          an || (an = !0, D("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ue));
        };
        at.isReactWarning = !0, Object.defineProperty(_e, "key", {
          get: at,
          configurable: !0
        });
      }
    }
    function $e(_e, Ue) {
      {
        var at = function() {
          Gt || (Gt = !0, D("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ue));
        };
        at.isReactWarning = !0, Object.defineProperty(_e, "ref", {
          get: at,
          configurable: !0
        });
      }
    }
    var Re = function(_e, Ue, at, Rt, Xt, Zt, Wt) {
      var Ht = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: n,
        // Built-in properties that belong on the element
        type: _e,
        key: Ue,
        ref: at,
        props: Wt,
        // Record the component responsible for creating this element.
        _owner: Zt
      };
      return Ht._store = {}, Object.defineProperty(Ht._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ht, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Rt
      }), Object.defineProperty(Ht, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Xt
      }), Object.freeze && (Object.freeze(Ht.props), Object.freeze(Ht)), Ht;
    };
    function We(_e, Ue, at, Rt, Xt) {
      {
        var Zt, Wt = {}, Ht = null, yn = null;
        at !== void 0 && (dt(at), Ht = "" + at), ue(Ue) && (dt(Ue.key), Ht = "" + Ue.key), Te(Ue) && (yn = Ue.ref, he(Ue, Xt));
        for (Zt in Ue)
          le.call(Ue, Zt) && !At.hasOwnProperty(Zt) && (Wt[Zt] = Ue[Zt]);
        if (_e && _e.defaultProps) {
          var cn = _e.defaultProps;
          for (Zt in cn)
            Wt[Zt] === void 0 && (Wt[Zt] = cn[Zt]);
        }
        if (Ht || yn) {
          var un = typeof _e == "function" ? _e.displayName || _e.name || "Unknown" : _e;
          Ht && Se(Wt, un), yn && $e(Wt, un);
        }
        return Re(_e, Ht, yn, Xt, Rt, nt.current, Wt);
      }
    }
    var rt = T.ReactCurrentOwner, lt = T.ReactDebugCurrentFrame;
    function tt(_e) {
      if (_e) {
        var Ue = _e._owner, at = re(_e.type, _e._source, Ue ? Ue.type : null);
        lt.setExtraStackFrame(at);
      } else
        lt.setExtraStackFrame(null);
    }
    var Nt;
    Nt = !1;
    function Be(_e) {
      return typeof _e == "object" && _e !== null && _e.$$typeof === n;
    }
    function Ke() {
      {
        if (rt.current) {
          var _e = oe(rt.current.type);
          if (_e)
            return `

Check the render method of \`` + _e + "`.";
        }
        return "";
      }
    }
    function Ye(_e) {
      {
        if (_e !== void 0) {
          var Ue = _e.fileName.replace(/^.*[\\\/]/, ""), at = _e.lineNumber;
          return `

Check your code at ` + Ue + ":" + at + ".";
        }
        return "";
      }
    }
    var ft = {};
    function ct(_e) {
      {
        var Ue = Ke();
        if (!Ue) {
          var at = typeof _e == "string" ? _e : _e.displayName || _e.name;
          at && (Ue = `

Check the top-level render call using <` + at + ">.");
        }
        return Ue;
      }
    }
    function gt(_e, Ue) {
      {
        if (!_e._store || _e._store.validated || _e.key != null)
          return;
        _e._store.validated = !0;
        var at = ct(Ue);
        if (ft[at])
          return;
        ft[at] = !0;
        var Rt = "";
        _e && _e._owner && _e._owner !== rt.current && (Rt = " It was passed a child from " + oe(_e._owner.type) + "."), tt(_e), D('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', at, Rt), tt(null);
      }
    }
    function wt(_e, Ue) {
      {
        if (typeof _e != "object")
          return;
        if (Oe(_e))
          for (var at = 0; at < _e.length; at++) {
            var Rt = _e[at];
            Be(Rt) && gt(Rt, Ue);
          }
        else if (Be(_e))
          _e._store && (_e._store.validated = !0);
        else if (_e) {
          var Xt = w(_e);
          if (typeof Xt == "function" && Xt !== _e.entries)
            for (var Zt = Xt.call(_e), Wt; !(Wt = Zt.next()).done; )
              Be(Wt.value) && gt(Wt.value, Ue);
        }
      }
    }
    function Mt(_e) {
      {
        var Ue = _e.type;
        if (Ue == null || typeof Ue == "string")
          return;
        var at;
        if (typeof Ue == "function")
          at = Ue.propTypes;
        else if (typeof Ue == "object" && (Ue.$$typeof === O || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Ue.$$typeof === R))
          at = Ue.propTypes;
        else
          return;
        if (at) {
          var Rt = oe(Ue);
          Ie(at, _e.props, "prop", Rt, _e);
        } else if (Ue.PropTypes !== void 0 && !Nt) {
          Nt = !0;
          var Xt = oe(Ue);
          D("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Xt || "Unknown");
        }
        typeof Ue.getDefaultProps == "function" && !Ue.getDefaultProps.isReactClassApproved && D("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function It(_e) {
      {
        for (var Ue = Object.keys(_e.props), at = 0; at < Ue.length; at++) {
          var Rt = Ue[at];
          if (Rt !== "children" && Rt !== "key") {
            tt(_e), D("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Rt), tt(null);
            break;
          }
        }
        _e.ref !== null && (tt(_e), D("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    function on(_e, Ue, at, Rt, Xt, Zt) {
      {
        var Wt = P(_e);
        if (!Wt) {
          var Ht = "";
          (_e === void 0 || typeof _e == "object" && _e !== null && Object.keys(_e).length === 0) && (Ht += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var yn = Ye(Xt);
          yn ? Ht += yn : Ht += Ke();
          var cn;
          _e === null ? cn = "null" : Oe(_e) ? cn = "array" : _e !== void 0 && _e.$$typeof === n ? (cn = "<" + (oe(_e.type) || "Unknown") + " />", Ht = " Did you accidentally export a JSX literal instead of a component?") : cn = typeof _e, D("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", cn, Ht);
        }
        var un = We(_e, Ue, at, Xt, Zt);
        if (un == null)
          return un;
        if (Wt) {
          var On = Ue.children;
          if (On !== void 0)
            if (Rt)
              if (Oe(On)) {
                for (var Qn = 0; Qn < On.length; Qn++)
                  wt(On[Qn], _e);
                Object.freeze && Object.freeze(On);
              } else
                D("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              wt(On, _e);
        }
        return _e === o ? It(un) : Mt(un), un;
      }
    }
    function Dt(_e, Ue, at) {
      return on(_e, Ue, at, !0);
    }
    function en(_e, Ue, at) {
      return on(_e, Ue, at, !1);
    }
    var jt = en, qt = Dt;
    sl.Fragment = o, sl.jsx = jt, sl.jsxs = qt;
  }()), sl;
}
process.env.NODE_ENV === "production" ? Vc.exports = mp() : Vc.exports = _p();
var U = Vc.exports, Xa = {}, ll = {}, Yu;
function Np() {
  if (Yu)
    return ll;
  Yu = 1;
  var r = $t;
  const n = /* @__PURE__ */ r.createContext(null);
  function t(u, p) {
    let m = null;
    u != null && (m = u[1]);
    function f() {
      return p ?? (m != null ? m.getTheme() : null);
    }
    return {
      getTheme: f
    };
  }
  function o() {
    const u = r.useContext(n);
    if (u == null)
      throw Error("LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext");
    return u;
  }
  return ll.LexicalComposerContext = n, ll.createLexicalComposerContext = t, ll.useLexicalComposerContext = o, ll;
}
var al = {}, zu;
function Cp() {
  if (zu)
    return al;
  zu = 1;
  var r = $t;
  function n(o) {
    let u = new URLSearchParams();
    u.append("code", o);
    for (let p = 1; p < arguments.length; p++)
      u.append("v", arguments[p]);
    throw Error(`Minified Lexical error #${o}; visit https://lexical.dev/docs/error?${u} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  let t = r.createContext(null);
  return al.LexicalComposerContext = t, al.createLexicalComposerContext = function(o, u) {
    let p = null;
    return o != null && (p = o[1]), { getTheme: function() {
      return u ?? (p != null ? p.getTheme() : null);
    } };
  }, al.useLexicalComposerContext = function() {
    let o = r.useContext(t);
    return o == null && n(8), o;
  }, al;
}
var Za, qu;
function zt() {
  return qu || (qu = 1, Za = process.env.NODE_ENV === "development" ? Np() : Cp()), Za;
}
var ze = {}, Gu;
function xp() {
  if (Gu)
    return ze;
  Gu = 1;
  function r(c) {
    return {
      type: c
    };
  }
  const n = r("SELECTION_CHANGE_COMMAND"), t = r("SELECTION_INSERT_CLIPBOARD_NODES_COMMAND"), o = r("CLICK_COMMAND"), u = r("DELETE_CHARACTER_COMMAND"), p = r("INSERT_LINE_BREAK_COMMAND"), m = r("INSERT_PARAGRAPH_COMMAND"), f = r("CONTROLLED_TEXT_INSERTION_COMMAND"), O = r("PASTE_COMMAND"), S = r("REMOVE_TEXT_COMMAND"), E = r("DELETE_WORD_COMMAND"), R = r("DELETE_LINE_COMMAND"), y = r("FORMAT_TEXT_COMMAND"), g = r("UNDO_COMMAND"), _ = r("REDO_COMMAND"), N = r("KEYDOWN_COMMAND"), w = r("KEY_ARROW_RIGHT_COMMAND"), T = r("MOVE_TO_END"), D = r("KEY_ARROW_LEFT_COMMAND"), C = r("MOVE_TO_START"), x = r("KEY_ARROW_UP_COMMAND"), I = r("KEY_ARROW_DOWN_COMMAND"), W = r("KEY_ENTER_COMMAND"), $ = r("KEY_SPACE_COMMAND"), B = r("KEY_BACKSPACE_COMMAND"), L = r("KEY_ESCAPE_COMMAND"), P = r("KEY_DELETE_COMMAND"), F = r("KEY_TAB_COMMAND"), Z = r("INSERT_TAB_COMMAND"), oe = r("INDENT_CONTENT_COMMAND"), ne = r("OUTDENT_CONTENT_COMMAND"), te = r("DROP_COMMAND"), K = r("FORMAT_ELEMENT_COMMAND"), A = r("DRAGSTART_COMMAND"), z = r("DRAGOVER_COMMAND"), ie = r("DRAGEND_COMMAND"), q = r("COPY_COMMAND"), Y = r("CUT_COMMAND"), se = r("SELECT_ALL_COMMAND"), j = r("CLEAR_EDITOR_COMMAND"), Q = r("CLEAR_HISTORY_COMMAND"), ae = r("CAN_REDO_COMMAND"), de = r("CAN_UNDO_COMMAND"), Ne = r("FOCUS_COMMAND"), De = r("BLUR_COMMAND"), Pe = r("KEY_MODIFIER_COMMAND"), Le = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", ke = Le && "documentMode" in document ? document.documentMode : null, J = Le && /Mac|iPod|iPhone|iPad/.test(navigator.platform), G = Le && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), H = Le && "InputEvent" in window && !ke ? "getTargetRanges" in new window.InputEvent("input") : !1, re = Le && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), le = Le && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, me = Le && /Android/.test(navigator.userAgent), ge = Le && /^(?=.*Chrome).*/i.test(navigator.userAgent), Me = Le && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !ge, Ie = 1, je = 3, Oe = 0, be = 1, He = 2, Ge = 0, dt = 1, nt = 2, At = 1, an = 2, Gt = 4, Ot = 8, Te = 16, ue = 32, he = 64, Se = 128, $e = At | an | Gt | Ot | Te | ue | he | Se, Re = 1, We = 2, rt = 1, lt = 2, tt = 3, Nt = 4, Be = 5, Ke = 6, Ye = " ", ct = re || le || Me ? Ye : "​", gt = `

`, wt = G ? Ye : ct, Mt = "֑-߿יִ-﷽ﹰ-ﻼ", It = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", on = new RegExp("^[^" + It + "]*[" + Mt + "]"), Dt = new RegExp("^[^" + Mt + "]*[" + It + "]"), en = {
    bold: At,
    code: Te,
    highlight: Se,
    italic: an,
    strikethrough: Gt,
    subscript: ue,
    superscript: he,
    underline: Ot
  }, jt = {
    directionless: Re,
    unmergeable: We
  }, qt = {
    center: lt,
    end: Ke,
    justify: Nt,
    left: rt,
    right: tt,
    start: Be
  }, _e = {
    [lt]: "center",
    [Ke]: "end",
    [Nt]: "justify",
    [rt]: "left",
    [tt]: "right",
    [Be]: "start"
  }, Ue = {
    normal: Ge,
    segmented: nt,
    token: dt
  }, at = {
    [Ge]: "normal",
    [nt]: "segmented",
    [dt]: "token"
  }, Rt = 100;
  let Xt = !1, Zt = 0;
  function Wt() {
    return Xt;
  }
  function Ht(c) {
    Zt = c.timeStamp;
  }
  function yn(c) {
    Zt === 0 && es(c).addEventListener("textInput", Ht, !0);
  }
  function cn(c, i, a) {
    return (
      // @ts-expect-error: internal field
      i.__lexicalLineBreak === c || // @ts-ignore We intentionally add this to the Node.
      c[`__lexicalKey_${a._key}`] !== void 0
    );
  }
  function un(c) {
    return c.getEditorState().read(() => {
      const i = Nn();
      return i !== null ? i.clone() : null;
    });
  }
  function On(c, i, a) {
    const d = Nr(a._window);
    let v = null, M = null;
    d !== null && d.anchorNode === c && (v = d.anchorOffset, M = d.focusOffset);
    const X = c.nodeValue;
    X !== null && pi(i, X, v, M, !1);
  }
  function Qn(c, i, a) {
    if (Kt(c)) {
      const d = c.anchor.getNode();
      if (d.is(a) && c.format !== d.getFormat())
        return !1;
    }
    return i.nodeType === je && a.isAttached();
  }
  function fn(c, i, a) {
    Xt = !0;
    const d = performance.now() - Zt > Rt;
    try {
      Ar(c, () => {
        const v = Nn() || un(c), M = /* @__PURE__ */ new Map(), X = c.getRootElement(), ee = c._editorState, pe = c._blockCursorElement;
        let Ce = !1, Ee = "";
        for (let we = 0; we < i.length; we++) {
          const ye = i[we], Ze = ye.type, Je = ye.target;
          let Xe = eo(Je, ee);
          if (!(Xe === null && Je !== X || Ln(Xe))) {
            if (Ze === "characterData")
              d && Ct(Xe) && Qn(v, Je, Xe) && On(
                // nodeType === DOM_TEXT_TYPE is a Text DOM node
                Je,
                Xe,
                c
              );
            else if (Ze === "childList") {
              Ce = !0;
              const xt = ye.addedNodes;
              for (let Qt = 0; Qt < xt.length; Qt++) {
                const Yt = xt[Qt], bt = Uo(Yt), rn = Yt.parentNode;
                if (rn != null && Yt !== pe && bt === null && (Yt.nodeName !== "BR" || !cn(Yt, rn, c))) {
                  if (G) {
                    const Kn = Yt.innerText || Yt.nodeValue;
                    Kn && (Ee += Kn);
                  }
                  rn.removeChild(Yt);
                }
              }
              const et = ye.removedNodes, mt = et.length;
              if (mt > 0) {
                let Qt = 0;
                for (let Yt = 0; Yt < mt; Yt++) {
                  const bt = et[Yt];
                  (bt.nodeName === "BR" && cn(bt, Je, c) || pe === bt) && (Je.appendChild(bt), Qt++);
                }
                mt !== Qt && (Je === X && (Xe = hi(ee)), M.set(Je, Xe));
              }
            }
          }
        }
        if (M.size > 0)
          for (const [we, ye] of M)
            if (ot(ye)) {
              const Ze = ye.getChildrenKeys();
              let Je = we.firstChild;
              for (let Xe = 0; Xe < Ze.length; Xe++) {
                const xt = Ze[Xe], et = c.getElementByKey(xt);
                et !== null && (Je == null ? (we.appendChild(et), Je = et) : Je !== et && we.replaceChild(et, Je), Je = Je.nextSibling);
              }
            } else
              Ct(ye) && ye.markDirty();
        const ve = a.takeRecords();
        if (ve.length > 0) {
          for (let we = 0; we < ve.length; we++) {
            const ye = ve[we], Ze = ye.addedNodes, Je = ye.target;
            for (let Xe = 0; Xe < Ze.length; Xe++) {
              const xt = Ze[Xe], et = xt.parentNode;
              et != null && xt.nodeName === "BR" && !cn(xt, Je, c) && et.removeChild(xt);
            }
          }
          a.takeRecords();
        }
        v !== null && (Ce && (v.dirty = !0, mr(v)), G && Us(c) && v.insertRawText(Ee));
      });
    } finally {
      Xt = !1;
    }
  }
  function Fn(c) {
    const i = c._observer;
    if (i !== null) {
      const a = i.takeRecords();
      fn(c, a, i);
    }
  }
  function jo(c) {
    yn(c), c._observer = new MutationObserver((i, a) => {
      fn(c, i, a);
    });
  }
  function yr(c, i) {
    const a = c.__mode, d = c.__format, v = c.__style, M = i.__mode, X = i.__format, ee = i.__style;
    return (a === null || a === M) && (d === null || d === X) && (v === null || v === ee);
  }
  function fi(c, i) {
    const a = c.mergeWithSibling(i), d = Tn()._normalizedNodes;
    return d.add(c.__key), d.add(i.__key), a;
  }
  function Wr(c) {
    let i = c;
    if (i.__text === "" && i.isSimpleText() && !i.isUnmergeable()) {
      i.remove();
      return;
    }
    let a;
    for (; (a = i.getPreviousSibling()) !== null && Ct(a) && a.isSimpleText() && !a.isUnmergeable(); )
      if (a.__text === "")
        a.remove();
      else if (yr(a, i)) {
        i = fi(a, i);
        break;
      } else
        break;
    let d;
    for (; (d = i.getNextSibling()) !== null && Ct(d) && d.isSimpleText() && !d.isUnmergeable(); )
      if (d.__text === "")
        d.remove();
      else if (yr(i, d)) {
        i = fi(i, d);
        break;
      } else
        break;
  }
  function Lr(c) {
    return Sr(c.anchor), Sr(c.focus), c;
  }
  function Sr(c) {
    for (; c.type === "element"; ) {
      const i = c.getNode(), a = c.offset;
      let d, v;
      if (a === i.getChildrenSize() ? (d = i.getChildAtIndex(a - 1), v = !0) : (d = i.getChildAtIndex(a), v = !1), Ct(d)) {
        c.set(d.__key, v ? d.getTextContentSize() : 0, "text");
        break;
      } else if (!ot(d))
        break;
      c.set(d.__key, v ? d.getChildrenSize() : 0, "element");
    }
  }
  let Ho = 1;
  function pr() {
    return "" + Ho++;
  }
  function Or(c, i) {
    const a = c._nodes.get(i);
    if (a === void 0)
      throw Error(`registeredNode: Type ${i} not found`);
    return a;
  }
  const mo = typeof queueMicrotask == "function" ? queueMicrotask : (c) => {
    Promise.resolve().then(c);
  };
  function ks(c) {
    return Ln(eo(c));
  }
  function ji(c) {
    const i = document.activeElement;
    if (i === null)
      return !1;
    const a = i.nodeName;
    return Ln(eo(c)) && (a === "INPUT" || a === "TEXTAREA" || i.contentEditable === "true" && // @ts-ignore iternal field
    i.__lexicalEditor == null);
  }
  function gi(c, i, a) {
    const d = c.getRootElement();
    try {
      return d !== null && d.contains(i) && d.contains(a) && // Ignore if selection is within nested editor
      i !== null && !ji(i) && vn(i) === c;
    } catch {
      return !1;
    }
  }
  function vn(c) {
    let i = c;
    for (; i != null; ) {
      const a = i.__lexicalEditor;
      if (a != null)
        return a;
      i = Qi(i);
    }
    return null;
  }
  function er(c) {
    return on.test(c) ? "rtl" : Dt.test(c) ? "ltr" : null;
  }
  function vr(c) {
    return c.isToken() || c.isSegmented();
  }
  function Qr(c) {
    return c.nodeType === je;
  }
  function In(c) {
    let i = c;
    for (; i != null; ) {
      if (Qr(i))
        return i;
      i = i.firstChild;
    }
    return null;
  }
  function _o(c, i, a) {
    const d = en[i];
    if (a !== null && (c & d) === (a & d))
      return c;
    let v = c ^ d;
    return i === "subscript" ? v &= ~en.superscript : i === "superscript" && (v &= ~en.subscript), v;
  }
  function Ol(c) {
    return Ct(c) || io(c) || Ln(c);
  }
  function Hi(c, i) {
    if (i != null) {
      c.__key = i;
      return;
    }
    ar(), Du();
    const a = Tn(), d = co(), v = pr();
    d._nodeMap.set(v, c), ot(c) ? a._dirtyElements.set(v, !0) : a._dirtyLeaves.add(v), a._cloneNotNeeded.add(v), a._dirtyType = be, c.__key = v;
  }
  function Wi(c, i, a) {
    let d = c;
    for (; d !== null; ) {
      if (a.has(d))
        return;
      const v = i.get(d);
      if (v === void 0)
        break;
      a.set(d, !1), d = v.__parent;
    }
  }
  function Ir(c) {
    const i = c.getParent();
    if (i !== null) {
      const a = c.getWritable(), d = i.getWritable(), v = c.getPreviousSibling(), M = c.getNextSibling();
      if (v === null)
        if (M !== null) {
          const X = M.getWritable();
          d.__first = M.__key, X.__prev = null;
        } else
          d.__first = null;
      else {
        const X = v.getWritable();
        if (M !== null) {
          const ee = M.getWritable();
          ee.__prev = X.__key, X.__next = ee.__key;
        } else
          X.__next = null;
        a.__prev = null;
      }
      if (M === null)
        if (v !== null) {
          const X = v.getWritable();
          d.__last = v.__key, X.__next = null;
        } else
          d.__last = null;
      else {
        const X = M.getWritable();
        if (v !== null) {
          const ee = v.getWritable();
          ee.__next = X.__key, X.__prev = ee.__key;
        } else
          X.__prev = null;
        a.__next = null;
      }
      d.__size--, a.__parent = null;
    }
  }
  function Wo(c) {
    Du();
    const i = c.getLatest(), a = i.__parent, d = co(), v = Tn(), M = d._nodeMap, X = v._dirtyElements;
    a !== null && Wi(a, M, X);
    const ee = i.__key;
    v._dirtyType = be, ot(c) ? X.set(ee, !0) : v._dirtyLeaves.add(ee);
  }
  function Ps(c) {
    const i = c.getPreviousSibling(), a = c.getNextSibling();
    i !== null && Wo(i), a !== null && Wo(a);
  }
  function pn(c) {
    ar();
    const i = Tn(), a = i._compositionKey;
    if (c !== a) {
      if (i._compositionKey = c, a !== null) {
        const d = Bn(a);
        d !== null && d.getWritable();
      }
      if (c !== null) {
        const d = Bn(c);
        d !== null && d.getWritable();
      }
    }
  }
  function tr() {
    return ms() ? null : Tn()._compositionKey;
  }
  function Bn(c, i) {
    const d = (i || co())._nodeMap.get(c);
    return d === void 0 ? null : d;
  }
  function Uo(c, i) {
    const a = Tn(), d = c[`__lexicalKey_${a._key}`];
    return d !== void 0 ? Bn(d, i) : null;
  }
  function eo(c, i) {
    let a = c;
    for (; a != null; ) {
      const d = Uo(a, i);
      if (d !== null)
        return d;
      a = Qi(a);
    }
    return null;
  }
  function Ui(c) {
    const i = c._decorators, a = Object.assign({}, i);
    return c._pendingDecorators = a, a;
  }
  function to(c) {
    return c.read(() => lr().getTextContent());
  }
  function vl(c, i) {
    Ar(c, () => {
      const a = co();
      if (a.isEmpty())
        return;
      if (i === "root") {
        lr().markDirty();
        return;
      }
      const d = a._nodeMap;
      for (const [, v] of d)
        v.markDirty();
    }, c._pendingEditorState === null ? {
      tag: "history-merge"
    } : void 0);
  }
  function lr() {
    return hi(co());
  }
  function hi(c) {
    return c._nodeMap.get("root");
  }
  function mr(c) {
    ar();
    const i = co();
    if (c !== null) {
      if (Object.isFrozen(c))
        throw Error("$setSelection called on frozen selection object. Ensure selection is cloned before passing in.");
      c.dirty = !0, c.setCachedNodes(null);
    }
    i._selection = c;
  }
  function wl() {
    ar();
    const c = Tn();
    Fn(c);
  }
  function No(c) {
    const i = Tn(), a = Yi(c, i);
    if (a === null) {
      const d = i.getRootElement();
      return c === d ? Bn("root") : null;
    }
    return Bn(a);
  }
  function Fs(c, i) {
    return i ? c.getTextContentSize() : 0;
  }
  function Yi(c, i) {
    let a = c;
    for (; a != null; ) {
      const d = a[`__lexicalKey_${i._key}`];
      if (d !== void 0)
        return d;
      a = Qi(a);
    }
    return null;
  }
  function Yo(c) {
    return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(c);
  }
  function zi(c) {
    const i = [];
    let a = c;
    for (; a !== null; )
      i.push(a), a = a._parentEditor;
    return i;
  }
  function qi() {
    return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
  }
  function Gi(c) {
    return c.nodeType === je ? c.nodeValue : null;
  }
  function wr(c, i, a) {
    const d = Nr(i._window);
    if (d === null)
      return;
    const v = d.anchorNode;
    let {
      anchorOffset: M,
      focusOffset: X
    } = d;
    if (v !== null) {
      let ee = Gi(v);
      const pe = eo(v);
      if (ee !== null && Ct(pe)) {
        if (ee === ct && a) {
          const Ce = a.length;
          ee = a, M = Ce, X = Ce;
        }
        ee !== null && pi(pe, ee, M, X, c);
      }
    }
  }
  function pi(c, i, a, d, v) {
    let M = c;
    if (M.isAttached() && (v || !M.isDirty())) {
      const X = M.isComposing();
      let ee = i;
      (X || v) && i[i.length - 1] === ct && (ee = i.slice(0, -1));
      const pe = M.getTextContent();
      if (v || ee !== pe) {
        if (ee === "") {
          if (pn(null), !re && !le && !Me) {
            const Je = Tn();
            setTimeout(() => {
              Je.update(() => {
                M.isAttached() && M.remove();
              });
            }, 20);
          } else
            M.remove();
          return;
        }
        const Ce = M.getParent(), Ee = ps(), ve = M.getTextContentSize(), we = tr(), ye = M.getKey();
        if (M.isToken() || we !== null && ye === we && !X || // Check if character was added at the start or boundaries when not insertable, and we need
        // to clear this input from occurring as that action wasn't permitted.
        Kt(Ee) && (Ce !== null && !Ce.canInsertTextBefore() && Ee.anchor.offset === 0 || Ee.anchor.key === c.__key && Ee.anchor.offset === 0 && !M.canInsertTextBefore() && !X || Ee.focus.key === c.__key && Ee.focus.offset === ve && !M.canInsertTextAfter() && !X)) {
          M.markDirty();
          return;
        }
        const Ze = Nn();
        if (!Kt(Ze) || a === null || d === null) {
          M.setTextContent(ee);
          return;
        }
        if (Ze.setTextNodeRange(M, a, M, d), M.isSegmented()) {
          const Je = M.getTextContent(), Xe = hn(Je);
          M.replace(Xe), M = Xe;
        }
        M.setTextContent(ee);
      }
    }
  }
  function mi(c) {
    const i = c.getPreviousSibling();
    return (Ct(i) || ot(i) && i.isInline()) && !i.canInsertTextAfter();
  }
  function Ml(c, i) {
    if (i.isSegmented())
      return !0;
    if (!c.isCollapsed())
      return !1;
    const a = c.anchor.offset, d = i.getParentOrThrow(), v = i.isToken();
    return a === 0 ? !i.canInsertTextBefore() || !d.canInsertTextBefore() || v || mi(i) : a === i.getTextContentSize() ? !i.canInsertTextAfter() || !d.canInsertTextAfter() || v : !1;
  }
  function Rl(c, i, a, d) {
    return c === 9 && !i && !a && !d;
  }
  function zo(c, i, a, d) {
    return c === 66 && !i && xi(a, d);
  }
  function _i(c, i, a, d) {
    return c === 73 && !i && xi(a, d);
  }
  function Bs(c, i, a, d) {
    return c === 85 && !i && xi(a, d);
  }
  function Ks(c, i) {
    return Co(c) && !i;
  }
  function Ni(c, i) {
    return Co(c) && i;
  }
  function Ci(c, i) {
    return J && i && c === 79;
  }
  function bl(c, i, a) {
    return Mr(c) && (J ? i : a);
  }
  function Al(c, i, a) {
    return xo(c) && (J ? i : a);
  }
  function Dl(c, i) {
    return J && i && Mr(c);
  }
  function Ll(c, i) {
    return J && i && xo(c);
  }
  function Aa(c, i, a, d) {
    return J ? i || a ? !1 : Mr(c) || c === 72 && d : d || i || a ? !1 : Mr(c);
  }
  function Da(c, i, a, d, v) {
    return J ? a || d || v ? !1 : xo(c) || c === 68 && i : i || d || v ? !1 : xo(c);
  }
  function Il(c, i, a, d) {
    return c === 90 && !i && xi(a, d);
  }
  function La(c, i, a, d) {
    return J ? c === 90 && a && i : c === 89 && d || c === 90 && d && i;
  }
  function Ia(c, i, a, d) {
    return i ? !1 : c === 67 ? J ? a : d : !1;
  }
  function $a(c, i, a, d) {
    return i ? !1 : c === 88 ? J ? a : d : !1;
  }
  function $l(c) {
    return c === 37;
  }
  function Vi(c) {
    return c === 39;
  }
  function ka(c) {
    return c === 38;
  }
  function Pa(c) {
    return c === 40;
  }
  function kl(c, i, a, d) {
    return $l(c) && !i && !d && !a;
  }
  function qo(c, i, a, d, v) {
    return $l(c) && !d && !a && (i || v);
  }
  function Pl(c, i, a, d) {
    return Vi(c) && !i && !d && !a;
  }
  function Fa(c, i, a, d, v) {
    return Vi(c) && !d && !a && (i || v);
  }
  function js(c, i, a) {
    return ka(c) && !i && !a;
  }
  function Ji(c, i, a) {
    return Pa(c) && !i && !a;
  }
  function Ba(c, i, a, d) {
    return c || i || a || d;
  }
  function Go(c) {
    return c === 32;
  }
  function xi(c, i) {
    return J ? c : i;
  }
  function Co(c) {
    return c === 13;
  }
  function Mr(c) {
    return c === 8;
  }
  function Fl(c) {
    return c === 27;
  }
  function xo(c) {
    return c === 46;
  }
  function Xi(c, i, a) {
    return c === 65 && xi(i, a);
  }
  function Hs() {
    const c = lr(), i = c.select(0, c.getChildrenSize());
    mr(Lr(i));
  }
  function Eo(c, i) {
    c.__lexicalClassNameCache === void 0 && (c.__lexicalClassNameCache = {});
    const a = c.__lexicalClassNameCache, d = a[i];
    if (d !== void 0)
      return d;
    const v = c[i];
    if (typeof v == "string") {
      const M = v.split(" ");
      return a[i] = M, M;
    }
    return v;
  }
  function Vo(c, i, a, d, v) {
    if (a.size === 0)
      return;
    const M = d.__type, X = d.__key, ee = i.get(M);
    if (ee === void 0)
      throw Error(`Type ${M} not in registeredNodes`);
    const pe = ee.klass;
    let Ce = c.get(pe);
    Ce === void 0 && (Ce = /* @__PURE__ */ new Map(), c.set(pe, Ce));
    const Ee = Ce.get(X), ve = Ee === "destroyed" && v === "created";
    (Ee === void 0 || ve) && Ce.set(X, ve ? "updated" : v);
  }
  function To(c) {
    const i = co(), a = i._readOnly, d = c.getType(), v = i._nodeMap, M = [];
    for (const [, X] of v)
      X instanceof c && X.__type === d && (a || X.isAttached()) && M.push(X);
    return M;
  }
  function Bl(c, i, a) {
    const d = c.getParent();
    let v = a, M = c;
    return d !== null && (i && a === 0 ? (v = M.getIndexWithinParent(), M = d) : !i && a === M.getChildrenSize() && (v = M.getIndexWithinParent() + 1, M = d)), M.getChildAtIndex(i ? v - 1 : v);
  }
  function Ws(c, i) {
    const a = c.offset;
    if (c.type === "element") {
      const d = c.getNode();
      return Bl(d, i, a);
    } else {
      const d = c.getNode();
      if (i && a === 0 || !i && a === d.getTextContentSize()) {
        const v = i ? d.getPreviousSibling() : d.getNextSibling();
        return v === null ? Bl(d.getParentOrThrow(), i, d.getIndexWithinParent() + (i ? 0 : 1)) : v;
      }
    }
    return null;
  }
  function Us(c) {
    const i = es(c).event, a = i && i.inputType;
    return a === "insertFromPaste" || a === "insertFromPasteAsQuotation";
  }
  function _t(c, i, a) {
    return Pu(c, i, a);
  }
  function Zi(c) {
    return !Dr(c) && !c.isLastChild() && !c.isInline();
  }
  function Ei(c, i) {
    const a = c._keyToDOMMap.get(i);
    if (a === void 0)
      throw Error(`Reconciliation: could not find DOM element for node key ${i}`);
    return a;
  }
  function Qi(c) {
    const i = c.assignedSlot || c.parentElement;
    return i !== null && i.nodeType === 11 ? i.host : i;
  }
  function no(c, i, a) {
    const d = a.ownerDocument, v = d.defaultView;
    if (v === null)
      return;
    let {
      top: M,
      bottom: X
    } = i, ee = 0, pe = 0, Ce = a;
    for (; Ce !== null; ) {
      const Ee = Ce === d.body;
      if (Ee)
        ee = 0, pe = es(c).innerHeight;
      else {
        const we = Ce.getBoundingClientRect();
        ee = we.top, pe = we.bottom;
      }
      let ve = 0;
      if (M < ee ? ve = -(ee - M) : X > pe && (ve = X - pe), ve !== 0)
        if (Ee)
          v.scrollBy(0, ve);
        else {
          const we = Ce.scrollTop;
          Ce.scrollTop += ve;
          const ye = Ce.scrollTop - we;
          M -= ye, X -= ye;
        }
      if (Ee)
        break;
      Ce = Qi(Ce);
    }
  }
  function Hn(c) {
    return Tn()._updateTags.has(c);
  }
  function Et(c) {
    ar(), Tn()._updateTags.add(c);
  }
  function Jo(c) {
    const i = Nn();
    if (!Kt(i) || !ot(c))
      return i;
    const {
      anchor: a,
      focus: d
    } = i, v = a.getNode(), M = d.getNode();
    return yo(v, c) && a.set(c.__key, 0, "element"), yo(M, c) && d.set(c.__key, 0, "element"), i;
  }
  function yo(c, i) {
    let a = c.getParent();
    for (; a !== null; ) {
      if (a.is(i))
        return !0;
      a = a.getParent();
    }
    return !1;
  }
  function Kl(c) {
    const i = c.ownerDocument;
    return i && i.defaultView || null;
  }
  function es(c) {
    const i = c._window;
    if (i === null)
      throw Error("window object not found");
    return i;
  }
  function Rr(c) {
    return ot(c) && c.isInline() || Ln(c) && c.isInline();
  }
  function ts(c) {
    let i = c.getParentOrThrow();
    for (; i !== null; ) {
      if (Ur(i))
        return i;
      i = i.getParentOrThrow();
    }
    return i;
  }
  function Ur(c) {
    return Dr(c) || ot(c) && c.isShadowRoot();
  }
  function Ys(c) {
    const i = c.constructor.clone(c);
    return Hi(i, null), i;
  }
  function _r(c) {
    const i = Tn(), a = c.constructor.getType(), d = i._nodes.get(a);
    if (d === void 0)
      throw Error('$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the "nodes" array in the editor config.');
    const v = d.replace;
    if (v !== null) {
      const M = v(c);
      if (!(M instanceof c.constructor))
        throw Error("$initializeNode failed. Ensure replacement node is a subclass of the original node.");
      return M;
    }
    return c;
  }
  function Xo(c, i) {
    const a = c.getParent();
    if (Dr(a) && !ot(i) && !Ln(i))
      throw Error("Only element or decorator nodes can be inserted in to the root node");
  }
  function Pt(c) {
    const i = c.theme, a = document.createElement("div");
    a.contentEditable = "false", a.setAttribute("data-lexical-cursor", "true");
    let d = i.blockCursor;
    if (d !== void 0) {
      if (typeof d == "string") {
        const v = d.split(" ");
        d = i.blockCursor = v;
      }
      d !== void 0 && a.classList.add(...d);
    }
    return a;
  }
  function $r(c) {
    return (Ln(c) || ot(c) && !c.canBeEmpty()) && !c.isInline();
  }
  function So(c, i, a) {
    a.style.removeProperty("caret-color"), i._blockCursorElement = null;
    const d = c.parentElement;
    d !== null && d.removeChild(c);
  }
  function jl(c, i, a) {
    let d = c._blockCursorElement;
    if (Kt(a) && a.isCollapsed() && a.anchor.type === "element" && i.contains(document.activeElement)) {
      const v = a.anchor, M = v.getNode(), X = v.offset, ee = M.getChildrenSize();
      let pe = !1, Ce = null;
      if (X === ee) {
        const Ee = M.getChildAtIndex(X - 1);
        $r(Ee) && (pe = !0);
      } else {
        const Ee = M.getChildAtIndex(X);
        if ($r(Ee)) {
          const ve = Ee.getPreviousSibling();
          (ve === null || $r(ve)) && (pe = !0, Ce = c.getElementByKey(Ee.__key));
        }
      }
      if (pe) {
        const Ee = c.getElementByKey(M.__key);
        d === null && (c._blockCursorElement = d = Pt(c._config)), i.style.caretColor = "transparent", Ce === null ? Ee.appendChild(d) : Ee.insertBefore(d, Ce);
        return;
      }
    }
    d !== null && So(d, c, i);
  }
  function Nr(c) {
    return Le ? (c || window).getSelection() : null;
  }
  function Hl(c, i) {
    let a = c.getChildAtIndex(i);
    if (a == null && (a = c), Ur(c))
      throw Error("Can not call $splitNode() on root element");
    const d = (X) => {
      const ee = X.getParentOrThrow(), pe = Ur(ee), Ce = X === a && !pe ? X : Ys(X);
      if (pe) {
        if (!(ot(X) && ot(Ce)))
          throw Error("Children of a root must be ElementNode");
        return X.insertAfter(Ce), [X, Ce, Ce];
      } else {
        const [Ee, ve, we] = d(ee), ye = X.getNextSiblings();
        return we.append(Ce, ...ye), [Ee, ve, Ce];
      }
    }, [v, M] = d(a);
    return [v, M];
  }
  function Wl(c) {
    return Ti(c) && c.tagName === "A";
  }
  function Ti(c) {
    return c.nodeType === 1;
  }
  function Oo(c) {
    if (Ln(c) && !c.isInline())
      return !0;
    if (!ot(c) || Ur(c))
      return !1;
    const i = c.getFirstChild(), a = i === null || io(i) || Ct(i) || i.isInline();
    return !c.isInline() && c.canBeEmpty() !== !1 && a;
  }
  function ns(c, i) {
    let a = c;
    for (; a !== null && a.getParent() !== null && !i(a); )
      a = a.getParentOrThrow();
    return i(a) ? a : null;
  }
  function Ul() {
    return Tn();
  }
  function zs(c, i) {
    const a = c._decorators;
    let v = c._pendingDecorators || a;
    const M = i._nodeMap;
    let X;
    for (X in v)
      M.has(X) || (v === a && (v = Ui(c)), delete v[X]);
  }
  function Yl(c, i, a, d, v, M) {
    let X = c.getFirstChild();
    for (; X !== null; ) {
      const ee = X.__key;
      X.__parent === i && (ot(X) && Yl(X, ee, a, d, v, M), a.has(ee) || M.delete(ee), v.push(ee)), X = X.getNextSibling();
    }
  }
  function qs(c, i, a, d) {
    const v = c._nodeMap, M = i._nodeMap, X = [];
    for (const [ee] of d) {
      const pe = M.get(ee);
      pe !== void 0 && (pe.isAttached() || (ot(pe) && Yl(pe, ee, v, M, X, d), v.has(ee) || d.delete(ee), X.push(ee)));
    }
    for (const ee of X)
      M.delete(ee);
    for (const ee of a) {
      const pe = M.get(ee);
      pe !== void 0 && !pe.isAttached() && (v.has(ee) || a.delete(ee), M.delete(ee));
    }
  }
  let Bt = "", Rn = "", Cr = "", Yr, nr, ro, Gs = !1, yi = !1, rs, os = null, bn, An, Dn, kr, vo, Zo;
  function zr(c, i) {
    const a = Dn.get(c);
    if (i !== null) {
      const d = Xs(c);
      d.parentNode === i && i.removeChild(d);
    }
    if (kr.has(c) || nr._keyToDOMMap.delete(c), ot(a)) {
      const d = Si(a, Dn);
      Wn(d, 0, d.length - 1, null);
    }
    a !== void 0 && Vo(Zo, ro, rs, a, "destroyed");
  }
  function Wn(c, i, a, d) {
    let v = i;
    for (; v <= a; ++v) {
      const M = c[v];
      M !== void 0 && zr(M, d);
    }
  }
  function Jn(c, i) {
    c.setProperty("text-align", i);
  }
  const mn = "40px";
  function Vs(c, i) {
    const a = Yr.theme.indent;
    if (typeof a == "string") {
      const v = c.classList.contains(a);
      i > 0 && !v ? c.classList.add(a) : i < 1 && v && c.classList.remove(a);
    }
    const d = getComputedStyle(c).getPropertyValue("--lexical-indent-base-value") || mn;
    c.style.setProperty("padding-inline-start", i === 0 ? "" : `calc(${i} * ${d})`);
  }
  function zl(c, i) {
    const a = c.style;
    i === 0 ? Jn(a, "") : i === rt ? Jn(a, "left") : i === lt ? Jn(a, "center") : i === tt ? Jn(a, "right") : i === Nt ? Jn(a, "justify") : i === Be ? Jn(a, "start") : i === Ke && Jn(a, "end");
  }
  function is(c, i, a) {
    const d = kr.get(c);
    if (d === void 0)
      throw Error("createNode: node does not exist in nodeMap");
    const v = d.createDOM(Yr, nr);
    if (gr(c, v, nr), Ct(d) ? v.setAttribute("data-lexical-text", "true") : Ln(d) && v.setAttribute("data-lexical-decorator", "true"), ot(d)) {
      const M = d.__indent, X = d.__size;
      if (M !== 0 && Vs(v, M), X !== 0) {
        const pe = X - 1, Ce = Si(d, kr);
        Js(Ce, pe, d, v);
      }
      const ee = d.__format;
      ee !== 0 && zl(v, ee), d.isInline() || Qo(null, d, v), Zi(d) && (Bt += gt, Cr += gt);
    } else {
      const M = d.getTextContent();
      if (Ln(d)) {
        const X = d.decorate(nr, Yr);
        X !== null && xn(c, X), v.contentEditable = "false";
      } else
        Ct(d) && (d.isDirectionless() || (Rn += M));
      Bt += M, Cr += M;
    }
    if (i !== null)
      if (a != null)
        i.insertBefore(v, a);
      else {
        const M = i.__lexicalLineBreak;
        M != null ? i.insertBefore(v, M) : i.appendChild(v);
      }
    return Object.freeze(d), Vo(Zo, ro, rs, d, "created"), v;
  }
  function Js(c, i, a, d) {
    const v = Rn;
    Rn = "", ss(c, a, 0, i, d, null), ht(a, d), Rn = v;
  }
  function ss(c, i, a, d, v, M) {
    const X = Bt;
    Bt = "";
    let ee = a;
    for (; ee <= d; ++ee)
      is(c[ee], v, M);
    Zi(i) && (Bt += gt), v.__lexicalTextContent = Bt, Bt = X + Bt;
  }
  function oo(c, i) {
    const a = i.get(c);
    return io(a) || Ln(a) && a.isInline();
  }
  function Qo(c, i, a) {
    const d = c !== null && (c.__size === 0 || oo(c.__last, Dn)), v = i.__size === 0 || oo(i.__last, kr);
    if (d) {
      if (!v) {
        const M = a.__lexicalLineBreak;
        M != null && a.removeChild(M), a.__lexicalLineBreak = null;
      }
    } else if (v) {
      const M = document.createElement("br");
      a.__lexicalLineBreak = M, a.appendChild(M);
    }
  }
  function ht(c, i) {
    const a = (
      // @ts-expect-error: internal field
      i.__lexicalDirTextContent
    ), d = i.__lexicalDir;
    if (a !== Rn || d !== os) {
      const v = Rn === "", M = v ? os : er(Rn);
      if (M !== d) {
        const X = i.classList, ee = Yr.theme;
        let pe = d !== null ? ee[d] : void 0, Ce = M !== null ? ee[M] : void 0;
        if (pe !== void 0) {
          if (typeof pe == "string") {
            const Ee = pe.split(" ");
            pe = ee[d] = Ee;
          }
          X.remove(...pe);
        }
        if (M === null || v && M === "ltr")
          i.removeAttribute("dir");
        else {
          if (Ce !== void 0) {
            if (typeof Ce == "string") {
              const Ee = Ce.split(" ");
              Ce = ee[M] = Ee;
            }
            Ce !== void 0 && X.add(...Ce);
          }
          i.dir = M;
        }
        if (!yi) {
          const Ee = c.getWritable();
          Ee.__dir = M;
        }
      }
      os = M, i.__lexicalDirTextContent = Rn, i.__lexicalDir = M;
    }
  }
  function ql(c, i, a) {
    const d = Rn;
    Rn = "", fr(c, i, a), ht(i, a), Rn = d;
  }
  function Si(c, i) {
    const a = [];
    let d = c.__first;
    for (; d !== null; ) {
      const v = i.get(d);
      if (v === void 0)
        throw Error("createChildrenArray: node does not exist in nodeMap");
      a.push(d), d = v.__next;
    }
    return a;
  }
  function fr(c, i, a) {
    const d = Bt, v = c.__size, M = i.__size;
    if (Bt = "", v === 1 && M === 1) {
      const X = c.__first, ee = i.__first;
      if (X === ee)
        ei(X, a);
      else {
        const pe = Xs(X), Ce = is(ee, null, null);
        a.replaceChild(Ce, pe), zr(X, null);
      }
    } else {
      const X = Si(c, Dn), ee = Si(i, kr);
      if (v === 0)
        M !== 0 && ss(ee, i, 0, M - 1, a, null);
      else if (M === 0) {
        if (v !== 0) {
          const Ce = a.__lexicalLineBreak == null;
          Wn(X, 0, v - 1, Ce ? null : a), Ce && (a.textContent = "");
        }
      } else
        Gl(i, X, ee, v, M, a);
    }
    Zi(i) && (Bt += gt), a.__lexicalTextContent = Bt, Bt = d + Bt;
  }
  function ei(c, i) {
    const a = Dn.get(c);
    let d = kr.get(c);
    if (a === void 0 || d === void 0)
      throw Error("reconcileNode: prevNode or nextNode does not exist in nodeMap");
    const v = Gs || An.has(c) || bn.has(c), M = Ei(nr, c);
    if (a === d && !v) {
      if (ot(a)) {
        const X = M.__lexicalTextContent;
        X !== void 0 && (Bt += X, Cr += X);
        const ee = M.__lexicalDirTextContent;
        ee !== void 0 && (Rn += ee);
      } else {
        const X = a.getTextContent();
        Ct(a) && !a.isDirectionless() && (Rn += X), Cr += X, Bt += X;
      }
      return M;
    }
    if (a !== d && v && Vo(Zo, ro, rs, d, "updated"), d.updateDOM(a, M, Yr)) {
      const X = is(c, null, null);
      if (i === null)
        throw Error("reconcileNode: parentDOM is null");
      return i.replaceChild(X, M), zr(c, null), X;
    }
    if (ot(a) && ot(d)) {
      const X = d.__indent;
      X !== a.__indent && Vs(M, X);
      const ee = d.__format;
      ee !== a.__format && zl(M, ee), v && (ql(a, d, M), !Dr(d) && !d.isInline() && Qo(a, d, M)), Zi(d) && (Bt += gt, Cr += gt);
    } else {
      const X = d.getTextContent();
      if (Ln(d)) {
        const ee = d.decorate(nr, Yr);
        ee !== null && xn(c, ee);
      } else
        Ct(d) && !d.isDirectionless() && (Rn += X);
      Bt += X, Cr += X;
    }
    if (!yi && Dr(d) && d.__cachedText !== Cr) {
      const X = d.getWritable();
      X.__cachedText = Cr, d = X;
    }
    return Object.freeze(d), M;
  }
  function xn(c, i) {
    let a = nr._pendingDecorators;
    const d = nr._decorators;
    if (a === null) {
      if (d[c] === i)
        return;
      a = Ui(nr);
    }
    a[c] = i;
  }
  function ls(c) {
    return c.firstChild;
  }
  function Qe(c) {
    let i = c.nextSibling;
    return i !== null && i === nr._blockCursorElement && (i = i.nextSibling), i;
  }
  function Gl(c, i, a, d, v, M) {
    const X = d - 1, ee = v - 1;
    let pe, Ce, Ee = ls(M), ve = 0, we = 0;
    for (; ve <= X && we <= ee; ) {
      const Je = i[ve], Xe = a[we];
      if (Je === Xe)
        Ee = Qe(ei(Xe, M)), ve++, we++;
      else {
        pe === void 0 && (pe = new Set(i)), Ce === void 0 && (Ce = new Set(a));
        const xt = Ce.has(Je), et = pe.has(Xe);
        if (!xt)
          Ee = Qe(Xs(Je)), zr(Je, M), ve++;
        else if (!et)
          is(Xe, M, Ee), we++;
        else {
          const mt = Ei(nr, Xe);
          mt === Ee ? Ee = Qe(ei(Xe, M)) : (Ee != null ? M.insertBefore(mt, Ee) : M.appendChild(mt), ei(Xe, M)), ve++, we++;
        }
      }
    }
    const ye = ve > X, Ze = we > ee;
    if (ye && !Ze) {
      const Je = a[ee + 1], Xe = Je === void 0 ? null : nr.getElementByKey(Je);
      ss(a, c, we, ee, M, Xe);
    } else
      Ze && !ye && Wn(i, ve, X, M);
  }
  function ti(c, i, a, d, v, M) {
    Bt = "", Cr = "", Rn = "", Gs = d === He, os = null, nr = a, Yr = a._config, ro = a._nodes, rs = nr._listeners.mutation, bn = v, An = M, Dn = c._nodeMap, kr = i._nodeMap, yi = i._readOnly, vo = new Map(a._keyToDOMMap);
    const X = /* @__PURE__ */ new Map();
    return Zo = X, ei("root", null), nr = void 0, ro = void 0, bn = void 0, An = void 0, Dn = void 0, kr = void 0, Yr = void 0, vo = void 0, Zo = void 0, X;
  }
  function gr(c, i, a) {
    const d = a._keyToDOMMap;
    i["__lexicalKey_" + a._key] = c, d.set(c, i);
  }
  function Xs(c) {
    const i = vo.get(c);
    if (i === void 0)
      throw Error(`Reconciliation: could not find DOM element for node key ${c}`);
    return i;
  }
  const br = Object.freeze({}), as = 30, ni = [["keydown", Ft], ["pointerdown", xe], ["compositionstart", pt], ["compositionend", Ut], ["input", Fe], ["click", ce], ["cut", br], ["copy", br], ["dragstart", br], ["dragover", br], ["dragend", br], ["paste", br], ["focus", br], ["blur", br], ["drop", br]];
  H && ni.push(["beforeinput", (c, i) => Ve(c, i)]);
  let Pr = 0, Vl = 0, Fr = 0, wo = null, Oi = 0, Zs = !1, l = !1, e = !1, s = !1, h = [0, "", 0, "root", 0];
  function b(c, i, a, d, v) {
    const M = c.anchor, X = c.focus, ee = M.getNode(), pe = Tn(), Ce = Nr(pe._window), Ee = Ce !== null ? Ce.anchorNode : null, ve = M.key, we = pe.getElementByKey(ve), ye = a.length;
    return ve !== X.key || // If we're working with a non-text node.
    !Ct(ee) || // If we are replacing a range with a single character or grapheme, and not composing.
    (!v && (!H || // We check to see if there has been
    // a recent beforeinput event for "textInput". If there has been one in the last
    // 50ms then we proceed as normal. However, if there is not, then this is likely
    // a dangling `input` event caused by execCommand('insertText').
    Fr < d + 50) || ee.isDirty() && ye < 2 || Yo(a)) && M.offset !== X.offset && !ee.isComposing() || // Any non standard text node.
    vr(ee) || // If the text length is more than a single character and we're either
    // dealing with this in "beforeinput" or where the node has already recently
    // been changed (thus is dirty).
    ee.isDirty() && ye > 1 || // If the DOM selection element is not the same as the backing node during beforeinput.
    (v || !H) && we !== null && !ee.isComposing() && Ee !== In(we) || // If TargetRange is not the same as the DOM selection; browser trying to edit random parts
    // of the editor.
    Ce !== null && i !== null && (!i.collapsed || i.startContainer !== Ce.anchorNode || i.startOffset !== Ce.anchorOffset) || // Check if we're changing from bold to italics, or some other format.
    ee.getFormat() !== c.format || ee.getStyle() !== c.style || // One last set of heuristics to check against.
    Ml(c, ee);
  }
  function k(c, i) {
    return c !== null && c.nodeValue !== null && c.nodeType === je && i !== 0 && i !== c.nodeValue.length;
  }
  function V(c, i, a) {
    const {
      anchorNode: d,
      anchorOffset: v,
      focusNode: M,
      focusOffset: X
    } = c;
    Zs && (Zs = !1, k(d, v) && k(M, X)) || Ar(i, () => {
      if (!a) {
        mr(null);
        return;
      }
      if (!gi(i, d, M))
        return;
      const ee = Nn();
      if (Kt(ee)) {
        const pe = ee.anchor, Ce = pe.getNode();
        if (ee.isCollapsed()) {
          c.type === "Range" && c.anchorNode === c.focusNode && (ee.dirty = !0);
          const Ee = es(i).event, ve = Ee ? Ee.timeStamp : performance.now(), [we, ye, Ze, Je, Xe] = h, xt = lr(), et = i.isComposing() === !1 && xt.getTextContent() === "";
          if (ve < Xe + 200 && pe.offset === Ze && pe.key === Je)
            ee.format = we, ee.style = ye;
          else if (pe.type === "text") {
            if (!Ct(Ce))
              throw Error("Point.getNode() must return TextNode when type is text");
            ee.format = Ce.getFormat(), ee.style = Ce.getStyle();
          } else
            pe.type === "element" && !et && (ee.format = 0, ee.style = "");
        } else {
          const Ee = pe.key, we = ee.focus.key, ye = ee.getNodes(), Ze = ye.length, Je = ee.isBackward(), Xe = Je ? X : v, xt = Je ? v : X, et = Je ? we : Ee, mt = Je ? Ee : we;
          let Qt = $e, Yt = !1;
          for (let bt = 0; bt < Ze; bt++) {
            const rn = ye[bt], Kn = rn.getTextContentSize();
            if (Ct(rn) && Kn !== 0 && // Exclude empty text nodes at boundaries resulting from user's selection
            !(bt === 0 && rn.__key === et && Xe === Kn || bt === Ze - 1 && rn.__key === mt && xt === 0) && (Yt = !0, Qt &= rn.getFormat(), Qt === 0))
              break;
          }
          ee.format = Yt ? Qt : 0;
        }
      }
      _t(i, n, void 0);
    });
  }
  function ce(c, i) {
    Ar(i, () => {
      const a = Nn(), d = Nr(i._window), v = ps();
      if (d) {
        if (Kt(a)) {
          const M = a.anchor, X = M.getNode();
          if (M.type === "element" && M.offset === 0 && a.isCollapsed() && !Dr(X) && lr().getChildrenSize() === 1 && X.getTopLevelElementOrThrow().isEmpty() && v !== null && a.is(v))
            d.removeAllRanges(), a.dirty = !0;
          else if (c.detail === 3 && !a.isCollapsed()) {
            const pe = a.focus.getNode();
            X !== pe && (ot(X) ? X.select(0) : X.getParentOrThrow().select(0));
          }
        } else if (c.pointerType === "touch") {
          const M = d.anchorNode;
          if (M !== null) {
            const X = M.nodeType;
            if (X === Ie || X === je) {
              const ee = Ya(v, d, i, c);
              mr(ee);
            }
          }
        }
      }
      _t(i, o, c);
    });
  }
  function xe(c, i) {
    const a = c.target, d = c.pointerType;
    a instanceof Node && d !== "touch" && Ar(i, () => {
      ks(a) || (l = !0);
    });
  }
  function Ae(c) {
    if (!c.getTargetRanges)
      return null;
    const i = c.getTargetRanges();
    return i.length === 0 ? null : i[0];
  }
  function it(c, i) {
    return c !== i || ot(c) || ot(i) || !c.isToken() || !i.isToken();
  }
  function st(c) {
    return Vl === 229 && c < Pr + as;
  }
  function Ve(c, i) {
    const a = c.inputType, d = Ae(c);
    a === "deleteCompositionText" || // If we're pasting in FF, we shouldn't get this event
    // as the `paste` event should have triggered, unless the
    // user has dom.event.clipboardevents.enabled disabled in
    // about:config. In that case, we need to process the
    // pasted content in the DOM mutation phase.
    G && Us(i) || a !== "insertCompositionText" && Ar(i, () => {
      const v = Nn();
      if (a === "deleteContentBackward") {
        if (v === null) {
          const Ee = ps();
          if (!Kt(Ee))
            return;
          mr(Ee.clone());
        }
        if (Kt(v)) {
          if (me && pn(v.anchor.key), st(c.timeStamp) && i.isComposing() && v.anchor.key === v.focus.key) {
            if (pn(null), Pr = 0, setTimeout(() => {
              Ar(i, () => {
                pn(null);
              });
            }, as), Kt(v)) {
              const ve = v.anchor.getNode();
              if (ve.markDirty(), v.format = ve.getFormat(), !Ct(ve))
                throw Error("Anchor node must be a TextNode");
              v.style = ve.getStyle();
            }
            v.anchor.getNode().getTextContent().length <= 1 && (c.preventDefault(), _t(i, u, !0));
          } else
            pn(null), c.preventDefault(), _t(i, u, !0);
          return;
        }
      }
      if (!Kt(v))
        return;
      const M = c.data;
      wo !== null && wr(!1, i, wo), (!v.dirty || wo !== null) && v.isCollapsed() && !Dr(v.anchor.getNode()) && d !== null && v.applyDOMRange(d), wo = null;
      const X = v.anchor, ee = v.focus, pe = X.getNode(), Ce = ee.getNode();
      if (a === "insertText" || a === "insertTranspose") {
        if (M === `
`)
          c.preventDefault(), _t(i, p, !1);
        else if (M === gt)
          c.preventDefault(), _t(i, m, void 0);
        else if (M == null && c.dataTransfer) {
          const Ee = c.dataTransfer.getData("text/plain");
          c.preventDefault(), v.insertRawText(Ee);
        } else
          M != null && b(v, d, M, c.timeStamp, !0) ? (c.preventDefault(), _t(i, f, M)) : wo = M;
        Fr = c.timeStamp;
        return;
      }
      switch (c.preventDefault(), a) {
        case "insertFromYank":
        case "insertFromDrop":
        case "insertReplacementText": {
          _t(i, f, c);
          break;
        }
        case "insertFromComposition": {
          pn(null), _t(i, f, c);
          break;
        }
        case "insertLineBreak": {
          pn(null), _t(i, p, !1);
          break;
        }
        case "insertParagraph": {
          pn(null), e && !le ? (e = !1, _t(i, p, !1)) : _t(i, m, void 0);
          break;
        }
        case "insertFromPaste":
        case "insertFromPasteAsQuotation": {
          _t(i, O, c);
          break;
        }
        case "deleteByComposition": {
          it(pe, Ce) && _t(i, S, c);
          break;
        }
        case "deleteByDrag":
        case "deleteByCut": {
          _t(i, S, c);
          break;
        }
        case "deleteContent": {
          _t(i, u, !1);
          break;
        }
        case "deleteWordBackward": {
          _t(i, E, !0);
          break;
        }
        case "deleteWordForward": {
          _t(i, E, !1);
          break;
        }
        case "deleteHardLineBackward":
        case "deleteSoftLineBackward": {
          _t(i, R, !0);
          break;
        }
        case "deleteContentForward":
        case "deleteHardLineForward":
        case "deleteSoftLineForward": {
          _t(i, R, !1);
          break;
        }
        case "formatStrikeThrough": {
          _t(i, y, "strikethrough");
          break;
        }
        case "formatBold": {
          _t(i, y, "bold");
          break;
        }
        case "formatItalic": {
          _t(i, y, "italic");
          break;
        }
        case "formatUnderline": {
          _t(i, y, "underline");
          break;
        }
        case "historyUndo": {
          _t(i, g, void 0);
          break;
        }
        case "historyRedo": {
          _t(i, _, void 0);
          break;
        }
      }
    });
  }
  function Fe(c, i) {
    c.stopPropagation(), Ar(i, () => {
      const a = Nn(), d = c.data, v = Ae(c);
      if (d != null && Kt(a) && b(a, v, d, c.timeStamp, !1)) {
        s && (Lt(i, d), s = !1);
        const M = a.anchor, X = M.getNode(), ee = Nr(i._window);
        if (ee === null)
          return;
        const pe = M.offset;
        (!H || a.isCollapsed() || !Ct(X) || ee.anchorNode === null || X.getTextContent().slice(0, pe) + d + X.getTextContent().slice(pe + a.focus.offset) !== Gi(ee.anchorNode)) && _t(i, f, d);
        const Ce = d.length;
        G && Ce > 1 && c.inputType === "insertCompositionText" && !i.isComposing() && (a.anchor.offset -= Ce), !re && !le && !Me && i.isComposing() && (Pr = 0, pn(null));
      } else
        wr(!1, i, d !== null ? d : void 0), s && (Lt(i, d || void 0), s = !1);
      wl();
    }), wo = null;
  }
  function pt(c, i) {
    Ar(i, () => {
      const a = Nn();
      if (Kt(a) && !i.isComposing()) {
        const d = a.anchor, v = a.anchor.getNode();
        pn(d.key), // If it has been 30ms since the last keydown, then we should
        // apply the empty space heuristic. We can't do this for Safari,
        // as the keydown fires after composition start.
        (c.timeStamp < Pr + as || // FF has issues around composing multibyte characters, so we also
        // need to invoke the empty space heuristic below.
        d.type === "element" || !a.isCollapsed() || v.getFormat() !== a.format || Ct(v) && v.getStyle() !== a.style) && _t(i, f, wt);
      }
    });
  }
  function Lt(c, i) {
    const a = c._compositionKey;
    if (pn(null), a !== null && i != null) {
      if (i === "") {
        const d = Bn(a), v = In(c.getElementByKey(a));
        v !== null && v.nodeValue !== null && Ct(d) && pi(d, v.nodeValue, null, null, !0);
        return;
      }
      if (i[i.length - 1] === `
`) {
        const d = Nn();
        if (Kt(d)) {
          const v = d.focus;
          d.anchor.set(v.key, v.offset, v.type), _t(c, W, null);
          return;
        }
      }
    }
    wr(!0, c, i);
  }
  function Ut(c, i) {
    G ? s = !0 : Ar(i, () => {
      Lt(i, c.data);
    });
  }
  function Ft(c, i) {
    if (Pr = c.timeStamp, Vl = c.keyCode, i.isComposing())
      return;
    const {
      keyCode: a,
      shiftKey: d,
      ctrlKey: v,
      metaKey: M,
      altKey: X
    } = c;
    if (!_t(i, N, c)) {
      if (Pl(a, v, X, M))
        _t(i, w, c);
      else if (Fa(a, v, d, X, M))
        _t(i, T, c);
      else if (kl(a, v, X, M))
        _t(i, D, c);
      else if (qo(a, v, d, X, M))
        _t(i, C, c);
      else if (js(a, v, M))
        _t(i, x, c);
      else if (Ji(a, v, M))
        _t(i, I, c);
      else if (Ni(a, d))
        e = !0, _t(i, W, c);
      else if (Go(a))
        _t(i, $, c);
      else if (Ci(a, v))
        c.preventDefault(), e = !0, _t(i, p, !0);
      else if (Ks(a, d))
        e = !1, _t(i, W, c);
      else if (Aa(a, X, M, v))
        Mr(a) ? _t(i, B, c) : (c.preventDefault(), _t(i, u, !0));
      else if (Fl(a))
        _t(i, L, c);
      else if (Da(a, v, d, X, M))
        xo(a) ? _t(i, P, c) : (c.preventDefault(), _t(i, u, !1));
      else if (bl(a, X, v))
        c.preventDefault(), _t(i, E, !0);
      else if (Al(a, X, v))
        c.preventDefault(), _t(i, E, !1);
      else if (Dl(a, M))
        c.preventDefault(), _t(i, R, !0);
      else if (Ll(a, M))
        c.preventDefault(), _t(i, R, !1);
      else if (zo(a, X, M, v))
        c.preventDefault(), _t(i, y, "bold");
      else if (Bs(a, X, M, v))
        c.preventDefault(), _t(i, y, "underline");
      else if (_i(a, X, M, v))
        c.preventDefault(), _t(i, y, "italic");
      else if (Rl(a, X, v, M))
        _t(i, F, c);
      else if (Il(a, d, M, v))
        c.preventDefault(), _t(i, g, void 0);
      else if (La(a, d, M, v))
        c.preventDefault(), _t(i, _, void 0);
      else {
        const ee = i._editorState._selection;
        rl(ee) ? Ia(a, d, M, v) ? (c.preventDefault(), _t(i, q, c)) : $a(a, d, M, v) ? (c.preventDefault(), _t(i, Y, c)) : Xi(a, M, v) && (c.preventDefault(), _t(i, se, c)) : !G && Xi(a, M, v) && (c.preventDefault(), _t(i, se, c));
      }
      Ba(v, d, X, M) && _t(i, Pe, c);
    }
  }
  function En(c) {
    let i = c.__lexicalEventHandles;
    return i === void 0 && (i = [], c.__lexicalEventHandles = i), i;
  }
  const Un = /* @__PURE__ */ new Map();
  function ri(c) {
    const i = c.target, a = i == null ? null : i.nodeType === 9 ? i.defaultView : i.ownerDocument.defaultView, d = Nr(a);
    if (d === null)
      return;
    const v = vn(d.anchorNode);
    if (v === null)
      return;
    l && (l = !1, Ar(v, () => {
      const Ee = ps(), ve = d.anchorNode;
      if (ve === null)
        return;
      const we = ve.nodeType;
      if (we !== Ie && we !== je)
        return;
      const ye = Ya(Ee, d, v, c);
      mr(ye);
    }));
    const M = zi(v), X = M[M.length - 1], ee = X._key, pe = Un.get(ee), Ce = pe || X;
    Ce !== v && V(d, Ce, !1), V(d, v, !0), v !== X ? Un.set(ee, v) : pe && Un.delete(ee);
  }
  function Br(c) {
    c._lexicalHandled = !0;
  }
  function cs(c) {
    return c._lexicalHandled === !0;
  }
  function Jl(c, i) {
    Oi === 0 && c.ownerDocument.addEventListener("selectionchange", ri), Oi++, c.__lexicalEditor = i;
    const a = En(c);
    for (let d = 0; d < ni.length; d++) {
      const [v, M] = ni[d], X = typeof M == "function" ? (ee) => {
        cs(ee) || (Br(ee), i.isEditable() && M(ee, i));
      } : (ee) => {
        if (!cs(ee) && (Br(ee), i.isEditable()))
          switch (v) {
            case "cut":
              return _t(i, Y, ee);
            case "copy":
              return _t(i, q, ee);
            case "paste":
              return _t(i, O, ee);
            case "dragstart":
              return _t(i, A, ee);
            case "dragover":
              return _t(i, z, ee);
            case "dragend":
              return _t(i, ie, ee);
            case "focus":
              return _t(i, Ne, ee);
            case "blur":
              return _t(i, De, ee);
            case "drop":
              return _t(i, te, ee);
          }
      };
      c.addEventListener(v, X), a.push(() => {
        c.removeEventListener(v, X);
      });
    }
  }
  function us(c) {
    Oi !== 0 && (Oi--, Oi === 0 && c.ownerDocument.removeEventListener("selectionchange", ri));
    const i = c.__lexicalEditor;
    i != null && (Ka(i), c.__lexicalEditor = null);
    const a = En(c);
    for (let d = 0; d < a.length; d++)
      a[d]();
    c.__lexicalEventHandles = [];
  }
  function Ka(c) {
    if (c._parentEditor !== null) {
      const i = zi(c), d = i[i.length - 1]._key;
      Un.get(d) === c && Un.delete(d);
    } else
      Un.delete(c._key);
  }
  function Qs() {
    Zs = !0;
  }
  function Kr(c, i, a, d, v) {
    h = [c, i, a, d, v];
  }
  function Mo(c, i, a) {
    ar();
    const d = c.__key, v = c.getParent();
    if (v === null)
      return;
    const M = Jo(c);
    let X = !1;
    if (Kt(M) && i) {
      const ee = M.anchor, pe = M.focus;
      ee.key === d && (ia(ee, c, v, c.getPreviousSibling(), c.getNextSibling()), X = !0), pe.key === d && (ia(pe, c, v, c.getPreviousSibling(), c.getNextSibling()), X = !0);
    } else
      rl(M) && i && c.isSelected() && c.selectPrevious();
    if (Kt(M) && i && !X) {
      const ee = c.getIndexWithinParent();
      Ir(c), oa(M, v, ee, -1);
    } else
      Ir(c);
    !a && !Ur(v) && !v.canBeEmpty() && v.isEmpty() && Mo(v, i), i && Dr(v) && v.isEmpty() && v.selectEnd();
  }
  class oi {
    // Allow us to look up the type including static props
    /** @internal */
    /** @internal */
    //@ts-ignore We set the key in the constructor.
    /** @internal */
    /** @internal */
    /** @internal */
    // Flow doesn't support abstract classes unfortunately, so we can't _force_
    // subclasses of Node to implement statics. All subclasses of Node should have
    // a static getType and clone method though. We define getType and clone here so we can call it
    // on any  Node, and we throw this error by default since the subclass should provide
    // their own implementation.
    /**
     * Returns the string type of this node. Every node must
     * implement this and it MUST BE UNIQUE amongst nodes registered
     * on the editor.
     *
     */
    static getType() {
      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);
    }
    /**
     * Clones this node, creating a new node with a different key
     * and adding it to the EditorState (but not attaching it anywhere!). All nodes must
     * implement this method.
     *
     */
    static clone(i) {
      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(i) {
      this.__type = this.constructor.getType(), this.__parent = null, this.__prev = null, this.__next = null, Hi(this, i), this.__type !== "root" && (ar(), Xl(this.__type, this.constructor));
    }
    // Getters and Traversers
    /**
     * Returns the string type of this node.
     */
    getType() {
      return this.__type;
    }
    isInline() {
      throw Error(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);
    }
    /**
     * Returns true if there is a path between this node and the RootNode, false otherwise.
     * This is a way of determining if the node is "attached" EditorState. Unattached nodes
     * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.
     */
    isAttached() {
      let i = this.__key;
      for (; i !== null; ) {
        if (i === "root")
          return !0;
        const a = Bn(i);
        if (a === null)
          break;
        i = a.__parent;
      }
      return !1;
    }
    /**
     * Returns true if this node is contained within the provided Selection., false otherwise.
     * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine
     * what's included.
     *
     * @param selection - The selection that we want to determine if the node is in.
     */
    isSelected(i) {
      const a = i || Nn();
      if (a == null)
        return !1;
      const d = a.getNodes().some((v) => v.__key === this.__key);
      return Ct(this) ? d : Kt(a) && a.anchor.type === "element" && a.focus.type === "element" && a.anchor.key === a.focus.key && a.anchor.offset === a.focus.offset ? !1 : d;
    }
    /**
     * Returns this nodes key.
     */
    getKey() {
      return this.__key;
    }
    /**
     * Returns the zero-based index of this node within the parent.
     */
    getIndexWithinParent() {
      const i = this.getParent();
      if (i === null)
        return -1;
      let a = i.getFirstChild(), d = 0;
      for (; a !== null; ) {
        if (this.is(a))
          return d;
        d++, a = a.getNextSibling();
      }
      return -1;
    }
    /**
     * Returns the parent of this node, or null if none is found.
     */
    getParent() {
      const i = this.getLatest().__parent;
      return i === null ? null : Bn(i);
    }
    /**
     * Returns the parent of this node, or throws if none is found.
     */
    getParentOrThrow() {
      const i = this.getParent();
      if (i === null)
        throw Error(`Expected node ${this.__key} to have a parent.`);
      return i;
    }
    /**
     * Returns the highest (in the EditorState tree)
     * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}
     * for more information on which Elements comprise "roots".
     */
    getTopLevelElement() {
      let i = this;
      for (; i !== null; ) {
        const a = i.getParent();
        if (Ur(a)) {
          if (!ot(i))
            throw Error("Children of root nodes must be elements");
          return i;
        }
        i = a;
      }
      return null;
    }
    /**
     * Returns the highest (in the EditorState tree)
     * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}
     * for more information on which Elements comprise "roots".
     */
    getTopLevelElementOrThrow() {
      const i = this.getTopLevelElement();
      if (i === null)
        throw Error(`Expected node ${this.__key} to have a top parent element.`);
      return i;
    }
    /**
     * Returns a list of the every ancestor of this node,
     * all the way up to the RootNode.
     *
     */
    getParents() {
      const i = [];
      let a = this.getParent();
      for (; a !== null; )
        i.push(a), a = a.getParent();
      return i;
    }
    /**
     * Returns a list of the keys of every ancestor of this node,
     * all the way up to the RootNode.
     *
     */
    getParentKeys() {
      const i = [];
      let a = this.getParent();
      for (; a !== null; )
        i.push(a.__key), a = a.getParent();
      return i;
    }
    /**
     * Returns the "previous" siblings - that is, the node that comes
     * before this one in the same parent.
     *
     */
    getPreviousSibling() {
      const a = this.getLatest().__prev;
      return a === null ? null : Bn(a);
    }
    /**
     * Returns the "previous" siblings - that is, the nodes that come between
     * this one and the first child of it's parent, inclusive.
     *
     */
    getPreviousSiblings() {
      const i = [], a = this.getParent();
      if (a === null)
        return i;
      let d = a.getFirstChild();
      for (; d !== null && !d.is(this); )
        i.push(d), d = d.getNextSibling();
      return i;
    }
    /**
     * Returns the "next" siblings - that is, the node that comes
     * after this one in the same parent
     *
     */
    getNextSibling() {
      const a = this.getLatest().__next;
      return a === null ? null : Bn(a);
    }
    /**
     * Returns all "next" siblings - that is, the nodes that come between this
     * one and the last child of it's parent, inclusive.
     *
     */
    getNextSiblings() {
      const i = [];
      let a = this.getNextSibling();
      for (; a !== null; )
        i.push(a), a = a.getNextSibling();
      return i;
    }
    /**
     * Returns the closest common ancestor of this node and the provided one or null
     * if one cannot be found.
     *
     * @param node - the other node to find the common ancestor of.
     */
    getCommonAncestor(i) {
      const a = this.getParents(), d = i.getParents();
      ot(this) && a.unshift(this), ot(i) && d.unshift(i);
      const v = a.length, M = d.length;
      if (v === 0 || M === 0 || a[v - 1] !== d[M - 1])
        return null;
      const X = new Set(d);
      for (let ee = 0; ee < v; ee++) {
        const pe = a[ee];
        if (X.has(pe))
          return pe;
      }
      return null;
    }
    /**
     * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.
     * Always use this instead of referential equality.
     *
     * @param object - the node to perform the equality comparison on.
     */
    is(i) {
      return i == null ? !1 : this.__key === i.__key;
    }
    /**
     * Returns true if this node logical precedes the target node in the editor state.
     *
     * @param targetNode - the node we're testing to see if it's after this one.
     */
    isBefore(i) {
      if (this === i)
        return !1;
      if (i.isParentOf(this))
        return !0;
      if (this.isParentOf(i))
        return !1;
      const a = this.getCommonAncestor(i);
      let d = 0, v = 0, M = this;
      for (; ; ) {
        const X = M.getParentOrThrow();
        if (X === a) {
          d = M.getIndexWithinParent();
          break;
        }
        M = X;
      }
      for (M = i; ; ) {
        const X = M.getParentOrThrow();
        if (X === a) {
          v = M.getIndexWithinParent();
          break;
        }
        M = X;
      }
      return d < v;
    }
    /**
     * Returns true if this node is the parent of the target node, false otherwise.
     *
     * @param targetNode - the would-be child node.
     */
    isParentOf(i) {
      const a = this.__key;
      if (a === i.__key)
        return !1;
      let d = i;
      for (; d !== null; ) {
        if (d.__key === a)
          return !0;
        d = d.getParent();
      }
      return !1;
    }
    // TO-DO: this function can be simplified a lot
    /**
     * Returns a list of nodes that are between this node and
     * the target node in the EditorState.
     *
     * @param targetNode - the node that marks the other end of the range of nodes to be returned.
     */
    getNodesBetween(i) {
      const a = this.isBefore(i), d = [], v = /* @__PURE__ */ new Set();
      let M = this;
      for (; ; ) {
        const X = M.__key;
        if (v.has(X) || (v.add(X), d.push(M)), M === i)
          break;
        const ee = ot(M) ? a ? M.getFirstChild() : M.getLastChild() : null;
        if (ee !== null) {
          M = ee;
          continue;
        }
        const pe = a ? M.getNextSibling() : M.getPreviousSibling();
        if (pe !== null) {
          M = pe;
          continue;
        }
        const Ce = M.getParentOrThrow();
        if (v.has(Ce.__key) || d.push(Ce), Ce === i)
          break;
        let Ee = null, ve = Ce;
        do {
          if (ve === null)
            throw Error("getNodesBetween: ancestor is null");
          Ee = a ? ve.getNextSibling() : ve.getPreviousSibling(), ve = ve.getParent(), ve !== null && Ee === null && !v.has(ve.__key) && d.push(ve);
        } while (Ee === null);
        M = Ee;
      }
      return a || d.reverse(), d;
    }
    /**
     * Returns true if this node has been marked dirty during this update cycle.
     *
     */
    isDirty() {
      const a = Tn()._dirtyLeaves;
      return a !== null && a.has(this.__key);
    }
    /**
     * Returns the latest version of the node from the active EditorState.
     * This is used to avoid getting values from stale node references.
     *
     */
    getLatest() {
      const i = Bn(this.__key);
      if (i === null)
        throw Error("Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.");
      return i;
    }
    /**
     * Returns a mutable version of the node. Will throw an error if
     * called outside of a Lexical Editor {@link LexicalEditor.update} callback.
     *
     */
    getWritable() {
      ar();
      const i = co(), a = Tn(), d = i._nodeMap, v = this.__key, M = this.getLatest(), X = M.__parent, ee = a._cloneNotNeeded, pe = Nn();
      if (pe !== null && pe.setCachedNodes(null), ee.has(v))
        return Wo(M), M;
      const Ee = M.constructor.clone(M);
      return Ee.__parent = X, Ee.__next = M.__next, Ee.__prev = M.__prev, ot(M) && ot(Ee) ? (Ee.__first = M.__first, Ee.__last = M.__last, Ee.__size = M.__size, Ee.__indent = M.__indent, Ee.__format = M.__format, Ee.__dir = M.__dir) : Ct(M) && Ct(Ee) && (Ee.__format = M.__format, Ee.__style = M.__style, Ee.__mode = M.__mode, Ee.__detail = M.__detail), ee.add(v), Ee.__key = v, Wo(Ee), d.set(v, Ee), Ee;
    }
    /**
     * Returns the text content of the node. Override this for
     * custom nodes that should have a representation in plain text
     * format (for copy + paste, for example)
     *
     */
    getTextContent() {
      return "";
    }
    /**
     * Returns the length of the string produced by calling getTextContent on this node.
     *
     */
    getTextContentSize() {
      return this.getTextContent().length;
    }
    // View
    /**
     * Called during the reconciliation process to determine which nodes
     * to insert into the DOM for this Lexical Node.
     *
     * This method must return exactly one HTMLElement. Nested elements are not supported.
     *
     * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.
     *
     * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.
     * @param _editor - allows access to the editor for context during reconciliation.
     *
     * */
    createDOM(i, a) {
      throw Error("createDOM: base method not extended");
    }
    /**
     * Called when a node changes and should update the DOM
     * in whatever way is necessary to make it align with any changes that might
     * have happened during the update.
     *
     * Returning "true" here will cause lexical to unmount and recreate the DOM node
     * (by calling createDOM). You would need to do this if the element tag changes,
     * for instance.
     *
     * */
    updateDOM(i, a, d) {
      throw Error("updateDOM: base method not extended");
    }
    /**
     * Controls how the this node is serialized to HTML. This is important for
     * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,
     * in which case the primary transfer format is HTML. It's also important if you're serializing
     * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could
     * also use this method to build your own HTML renderer.
     *
     * */
    exportDOM(i) {
      return {
        element: this.createDOM(i._config, i)
      };
    }
    /**
     * Controls how the this node is serialized to JSON. This is important for
     * copy and paste between Lexical editors sharing the same namespace. It's also important
     * if you're serializing to JSON for persistent storage somewhere.
     * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
     *
     * */
    exportJSON() {
      throw Error("exportJSON: base method not extended");
    }
    /**
     * Controls how the this node is deserialized from JSON. This is usually boilerplate,
     * but provides an abstraction between the node implementation and serialized interface that can
     * be important if you ever make breaking changes to a node schema (by adding or removing properties).
     * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
     *
     * */
    static importJSON(i) {
      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);
    }
    /**
     * @experimental
     *
     * Registers the returned function as a transform on the node during
     * Editor initialization. Most such use cases should be addressed via
     * the {@link LexicalEditor.registerNodeTransform} API.
     *
     * Experimental - use at your own risk.
     */
    static transform() {
      return null;
    }
    // Setters and mutators
    /**
     * Removes this LexicalNode from the EditorState. If the node isn't re-inserted
     * somewhere, the Lexical garbage collector will eventually clean it up.
     *
     * @param preserveEmptyParent - If falsy, the node's parent will be removed if
     * it's empty after the removal operation. This is the default behavior, subject to
     * other node heuristics such as {@link ElementNode#canBeEmpty}
     * */
    remove(i) {
      Mo(this, !0, i);
    }
    /**
     * Replaces this LexicalNode with the provided node, optionally transferring the children
     * of the replaced node to the replacing node.
     *
     * @param replaceWith - The node to replace this one with.
     * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.
     * */
    replace(i, a) {
      ar();
      let d = Nn();
      d !== null && (d = d.clone()), Xo(this, i);
      const v = this.getLatest(), M = this.__key, X = i.__key, ee = i.getWritable(), pe = this.getParentOrThrow().getWritable(), Ce = pe.__size;
      Ir(ee);
      const Ee = v.getPreviousSibling(), ve = v.getNextSibling(), we = v.__prev, ye = v.__next, Ze = v.__parent;
      if (Mo(v, !1, !0), Ee === null)
        pe.__first = X;
      else {
        const Je = Ee.getWritable();
        Je.__next = X;
      }
      if (ee.__prev = we, ve === null)
        pe.__last = X;
      else {
        const Je = ve.getWritable();
        Je.__prev = X;
      }
      if (ee.__next = ye, ee.__parent = Ze, pe.__size = Ce, a) {
        if (!(ot(this) && ot(ee)))
          throw Error("includeChildren should only be true for ElementNodes");
        this.getChildren().forEach((Je) => {
          ee.append(Je);
        });
      }
      if (Kt(d)) {
        mr(d);
        const Je = d.anchor, Xe = d.focus;
        Je.key === M && ao(Je, ee), Xe.key === M && ao(Xe, ee);
      }
      return tr() === M && pn(X), ee;
    }
    /**
     * Inserts a node after this LexicalNode (as the next sibling).
     *
     * @param nodeToInsert - The node to insert after this one.
     * @param restoreSelection - Whether or not to attempt to resolve the
     * selection to the appropriate place after the operation is complete.
     * */
    insertAfter(i, a = !0) {
      ar(), Xo(this, i);
      const d = this.getWritable(), v = i.getWritable(), M = v.getParent(), X = Nn();
      let ee = !1, pe = !1;
      if (M !== null) {
        const ye = i.getIndexWithinParent();
        if (Ir(v), Kt(X)) {
          const Ze = M.__key, Je = X.anchor, Xe = X.focus;
          ee = Je.type === "element" && Je.key === Ze && Je.offset === ye + 1, pe = Xe.type === "element" && Xe.key === Ze && Xe.offset === ye + 1;
        }
      }
      const Ce = this.getNextSibling(), Ee = this.getParentOrThrow().getWritable(), ve = v.__key, we = d.__next;
      if (Ce === null)
        Ee.__last = ve;
      else {
        const ye = Ce.getWritable();
        ye.__prev = ve;
      }
      if (Ee.__size++, d.__next = ve, v.__next = we, v.__prev = d.__key, v.__parent = d.__parent, a && Kt(X)) {
        const ye = this.getIndexWithinParent();
        oa(X, Ee, ye + 1);
        const Ze = Ee.__key;
        ee && X.anchor.set(Ze, ye + 2, "element"), pe && X.focus.set(Ze, ye + 2, "element");
      }
      return i;
    }
    /**
     * Inserts a node before this LexicalNode (as the previous sibling).
     *
     * @param nodeToInsert - The node to insert before this one.
     * @param restoreSelection - Whether or not to attempt to resolve the
     * selection to the appropriate place after the operation is complete.
     * */
    insertBefore(i, a = !0) {
      ar(), Xo(this, i);
      const d = this.getWritable(), v = i.getWritable(), M = v.__key;
      Ir(v);
      const X = this.getPreviousSibling(), ee = this.getParentOrThrow().getWritable(), pe = d.__prev, Ce = this.getIndexWithinParent();
      if (X === null)
        ee.__first = M;
      else {
        const ve = X.getWritable();
        ve.__next = M;
      }
      ee.__size++, d.__prev = M, v.__prev = pe, v.__next = d.__key, v.__parent = d.__parent;
      const Ee = Nn();
      if (a && Kt(Ee)) {
        const ve = this.getParentOrThrow();
        oa(Ee, ve, Ce);
      }
      return i;
    }
    /**
     * Whether or not this node has a required parent. Used during copy + paste operations
     * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without
     * a ListNode parent or TextNodes with a ParagraphNode parent.
     *
     * */
    isParentRequired() {
      return !1;
    }
    /**
     * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.
     *
     * */
    createParentElementNode() {
      return Ao();
    }
    selectStart() {
      return this.selectPrevious();
    }
    selectEnd() {
      return this.selectNext(0, 0);
    }
    /**
     * Moves selection to the previous sibling of this node, at the specified offsets.
     *
     * @param anchorOffset - The anchor offset for selection.
     * @param focusOffset -  The focus offset for selection
     * */
    selectPrevious(i, a) {
      ar();
      const d = this.getPreviousSibling(), v = this.getParentOrThrow();
      if (d === null)
        return v.select(0, 0);
      if (ot(d))
        return d.select();
      if (!Ct(d)) {
        const M = d.getIndexWithinParent() + 1;
        return v.select(M, M);
      }
      return d.select(i, a);
    }
    /**
     * Moves selection to the next sibling of this node, at the specified offsets.
     *
     * @param anchorOffset - The anchor offset for selection.
     * @param focusOffset -  The focus offset for selection
     * */
    selectNext(i, a) {
      ar();
      const d = this.getNextSibling(), v = this.getParentOrThrow();
      if (d === null)
        return v.select();
      if (ot(d))
        return d.select(0, 0);
      if (!Ct(d)) {
        const M = d.getIndexWithinParent();
        return v.select(M, M);
      }
      return d.select(i, a);
    }
    /**
     * Marks a node dirty, triggering transforms and
     * forcing it to be reconciled during the update cycle.
     *
     * */
    markDirty() {
      this.getWritable();
    }
  }
  function Xl(c, i) {
    const a = Tn()._nodes.get(c);
    if (a === void 0)
      throw Error(`Create node: Attempted to create node ${i.name} that was not configured to be used on the editor.`);
    const d = a.klass;
    if (d !== i)
      throw Error(`Create node: Type ${c} in node ${i.name} does not match registered node ${d.name} with the same type`);
  }
  function ja(c, i, a) {
    const d = a || i.getParentOrThrow().getLastChild();
    let v = i;
    const M = [i];
    for (; v !== d; ) {
      if (!v.getNextSibling())
        throw Error("insertRangeAfter: lastToInsert must be a later sibling of firstToInsert");
      v = v.getNextSibling(), M.push(v);
    }
    let X = c;
    for (const ee of M)
      X = X.insertAfter(ee);
  }
  class Ro extends oi {
    static getType() {
      return "linebreak";
    }
    static clone(i) {
      return new Ro(i.__key);
    }
    constructor(i) {
      super(i);
    }
    getTextContent() {
      return `
`;
    }
    createDOM() {
      return document.createElement("br");
    }
    updateDOM() {
      return !1;
    }
    static importDOM() {
      return {
        br: (i) => el(i) ? null : {
          conversion: Zl,
          priority: 0
        }
      };
    }
    static importJSON(i) {
      return qr();
    }
    exportJSON() {
      return {
        type: "linebreak",
        version: 1
      };
    }
  }
  function Zl(c) {
    return {
      node: qr()
    };
  }
  function qr() {
    return _r(new Ro());
  }
  function io(c) {
    return c instanceof Ro;
  }
  function el(c) {
    const i = c.parentElement;
    if (i !== null) {
      const a = i.firstChild;
      if (a === c || a.nextSibling === c && ds(a)) {
        const d = i.lastChild;
        if (d === c || d.previousSibling === c && ds(d))
          return !0;
      }
    }
    return !1;
  }
  function ds(c) {
    return c.nodeType === je && /^( |\t|\r?\n)+$/.test(c.textContent || "");
  }
  function fs(c, i) {
    return i & Te ? "code" : i & Se ? "mark" : i & ue ? "sub" : i & he ? "sup" : null;
  }
  function bo(c, i) {
    return i & At ? "strong" : i & an ? "em" : "span";
  }
  function vi(c, i, a, d, v) {
    const M = d.classList;
    let X = Eo(v, "base");
    X !== void 0 && M.add(...X), X = Eo(v, "underlineStrikethrough");
    let ee = !1;
    const pe = i & Ot && i & Gt, Ce = a & Ot && a & Gt;
    X !== void 0 && (Ce ? (ee = !0, pe || M.add(...X)) : pe && M.remove(...X));
    for (const Ee in en) {
      const we = en[Ee];
      if (X = Eo(v, Ee), X !== void 0)
        if (a & we) {
          if (ee && (Ee === "underline" || Ee === "strikethrough")) {
            i & we && M.remove(...X);
            continue;
          }
          (!(i & we) || pe && Ee === "underline" || Ee === "strikethrough") && M.add(...X);
        } else
          i & we && M.remove(...X);
    }
  }
  function tl(c, i) {
    const a = c.length, d = i.length;
    let v = 0, M = 0;
    for (; v < a && v < d && c[v] === i[v]; )
      v++;
    for (; M + v < a && M + v < d && c[a - M - 1] === i[d - M - 1]; )
      M++;
    return [v, a - v - M, i.slice(v, d - M)];
  }
  function Ql(c, i, a) {
    const d = i.firstChild, v = a.isComposing(), X = c + (v ? ct : "");
    if (d == null)
      i.textContent = X;
    else {
      const ee = d.nodeValue;
      if (ee !== X)
        if (v || G) {
          const [pe, Ce, Ee] = tl(ee, X);
          Ce !== 0 && d.deleteData(pe, Ce), d.insertData(pe, Ee);
        } else
          d.nodeValue = X;
    }
  }
  function gs(c, i, a, d, v, M) {
    Ql(v, c, i);
    const ee = M.theme.text;
    ee !== void 0 && vi(a, 0, d, c, ee);
  }
  function ii(c, i) {
    const a = document.createElement(i);
    return a.appendChild(c), a;
  }
  class jr extends oi {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "text";
    }
    static clone(i) {
      return new jr(i.__text, i.__key);
    }
    constructor(i, a) {
      super(a), this.__text = i, this.__format = 0, this.__style = "", this.__mode = 0, this.__detail = 0;
    }
    /**
     * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the
     * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.
     *
     * @returns a number representing the format of the text node.
     */
    getFormat() {
      return this.getLatest().__format;
    }
    /**
     * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the
     * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless
     * or TextNode.isUnmergeable instead.
     *
     * @returns a number representing the detail of the text node.
     */
    getDetail() {
      return this.getLatest().__detail;
    }
    /**
     * Returns the mode (TextModeType) of the TextNode, which may be "normal", "token", or "segmented"
     *
     * @returns TextModeType.
     */
    getMode() {
      const i = this.getLatest();
      return at[i.__mode];
    }
    /**
     * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.
     *
     * @returns CSSText-like string of styles applied to the underlying DOM node.
     */
    getStyle() {
      return this.getLatest().__style;
    }
    /**
     * Returns whether or not the node is in "token" mode. TextNodes in token mode can be navigated through character-by-character
     * with a RangeSelection, but are deleted as a single entity (not invdividually by character).
     *
     * @returns true if the node is in token mode, false otherwise.
     */
    isToken() {
      return this.getLatest().__mode === dt;
    }
    /**
     *
     * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to
     * mutate the TextNode, false otherwise.
     */
    isComposing() {
      return this.__key === tr();
    }
    /**
     * Returns whether or not the node is in "segemented" mode. TextNodes in segemented mode can be navigated through character-by-character
     * with a RangeSelection, but are deleted in space-delimited "segments".
     *
     * @returns true if the node is in segmented mode, false otherwise.
     */
    isSegmented() {
      return this.getLatest().__mode === nt;
    }
    /**
     * Returns whether or not the node is "directionless". Directionless nodes don't respect changes between RTL and LTR modes.
     *
     * @returns true if the node is directionless, false otherwise.
     */
    isDirectionless() {
      return (this.getLatest().__detail & Re) !== 0;
    }
    /**
     * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge
     * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.
     *
     * @returns true if the node is unmergeable, false otherwise.
     */
    isUnmergeable() {
      return (this.getLatest().__detail & We) !== 0;
    }
    /**
     * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType
     * string values to get the format of a TextNode.
     *
     * @param type - the TextFormatType to check for.
     *
     * @returns true if the node has the provided format, false otherwise.
     */
    hasFormat(i) {
      const a = en[i];
      return (this.getFormat() & a) !== 0;
    }
    /**
     * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type "text"
     * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).
     *
     * @returns true if the node is simple text, false otherwise.
     */
    isSimpleText() {
      return this.__type === "text" && this.__mode === 0;
    }
    /**
     * Returns the text content of the node as a string.
     *
     * @returns a string representing the text content of the node.
     */
    getTextContent() {
      return this.getLatest().__text;
    }
    /**
     * Returns the format flags applied to the node as a 32-bit integer.
     *
     * @returns a number representing the TextFormatTypes applied to the node.
     */
    getFormatFlags(i, a) {
      const v = this.getLatest().__format;
      return _o(v, i, a);
    }
    /**
     *
     * @returns true if the text node supports font styling, false otherwise.
     */
    canHaveFormat() {
      return !0;
    }
    // View
    createDOM(i, a) {
      const d = this.__format, v = fs(this, d), M = bo(this, d), X = v === null ? M : v, ee = document.createElement(X);
      let pe = ee;
      this.hasFormat("code") && ee.setAttribute("spellcheck", "false"), v !== null && (pe = document.createElement(M), ee.appendChild(pe));
      const Ce = this.__text;
      gs(pe, this, M, d, Ce, i);
      const Ee = this.__style;
      return Ee !== "" && (ee.style.cssText = Ee), ee;
    }
    updateDOM(i, a, d) {
      const v = this.__text, M = i.__format, X = this.__format, ee = fs(this, M), pe = fs(this, X), Ce = bo(this, M), Ee = bo(this, X);
      if ((ee === null ? Ce : ee) !== (pe === null ? Ee : pe))
        return !0;
      if (ee === pe && Ce !== Ee) {
        const et = a.firstChild;
        if (et == null)
          throw Error("updateDOM: prevInnerDOM is null or undefined");
        const mt = document.createElement(Ee);
        return gs(mt, this, Ee, X, v, d), a.replaceChild(mt, et), !1;
      }
      let ye = a;
      if (pe !== null && ee !== null && (ye = a.firstChild, ye == null))
        throw Error("updateDOM: innerDOM is null or undefined");
      Ql(v, ye, this);
      const Je = d.theme.text;
      Je !== void 0 && M !== X && vi(Ee, M, X, ye, Je);
      const Xe = i.__style, xt = this.__style;
      return Xe !== xt && (a.style.cssText = xt), !1;
    }
    static importDOM() {
      return {
        "#text": () => ({
          conversion: ta,
          priority: 0
        }),
        b: () => ({
          conversion: so,
          priority: 0
        }),
        code: () => ({
          conversion: Sn,
          priority: 0
        }),
        em: () => ({
          conversion: Sn,
          priority: 0
        }),
        i: () => ({
          conversion: Sn,
          priority: 0
        }),
        s: () => ({
          conversion: Sn,
          priority: 0
        }),
        span: () => ({
          conversion: hs,
          priority: 0
        }),
        strong: () => ({
          conversion: Sn,
          priority: 0
        }),
        sub: () => ({
          conversion: Sn,
          priority: 0
        }),
        sup: () => ({
          conversion: Sn,
          priority: 0
        }),
        u: () => ({
          conversion: Sn,
          priority: 0
        })
      };
    }
    static importJSON(i) {
      const a = hn(i.text);
      return a.setFormat(i.format), a.setDetail(i.detail), a.setMode(i.mode), a.setStyle(i.style), a;
    }
    // This improves Lexical's basic text output in copy+paste plus
    // for headless mode where people might use Lexical to generate
    // HTML content and not have the ability to use CSS classes.
    exportDOM(i) {
      let {
        element: a
      } = super.exportDOM(i);
      if (!(a !== null && Ti(a)))
        throw Error("Expected TextNode createDOM to always return a HTMLElement");
      return a.style.whiteSpace = "pre-wrap", this.hasFormat("bold") && (a = ii(a, "b")), this.hasFormat("italic") && (a = ii(a, "i")), this.hasFormat("strikethrough") && (a = ii(a, "s")), this.hasFormat("underline") && (a = ii(a, "u")), {
        element: a
      };
    }
    exportJSON() {
      return {
        detail: this.getDetail(),
        format: this.getFormat(),
        mode: this.getMode(),
        style: this.getStyle(),
        text: this.getTextContent(),
        type: "text",
        version: 1
      };
    }
    // Mutators
    selectionTransform(i, a) {
    }
    /**
     * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType
     * version of the argument can only specify one format and doing so will remove all other formats that
     * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}
     *
     * @param format - TextFormatType or 32-bit integer representing the node format.
     *
     * @returns this TextNode.
     * // TODO 0.12 This should just be a `string`.
     */
    setFormat(i) {
      const a = this.getWritable();
      return a.__format = typeof i == "string" ? en[i] : i, a;
    }
    /**
     * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType
     * version of the argument can only specify one detail value and doing so will remove all other detail values that
     * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}
     * or {@link TextNode.togglerUnmergeable}
     *
     * @param detail - TextDetailType or 32-bit integer representing the node detail.
     *
     * @returns this TextNode.
     * // TODO 0.12 This should just be a `string`.
     */
    setDetail(i) {
      const a = this.getWritable();
      return a.__detail = typeof i == "string" ? jt[i] : i, a;
    }
    /**
     * Sets the node style to the provided CSSText-like string. Set this property as you
     * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.
     *
     * @param style - CSSText to be applied to the underlying HTMLElement.
     *
     * @returns this TextNode.
     */
    setStyle(i) {
      const a = this.getWritable();
      return a.__style = i, a;
    }
    /**
     * Applies the provided format to this TextNode if it's not present. Removes it if it's present.
     * The subscript and superscript formats are mutually exclusive.
     * Prefer using this method to turn specific formats on and off.
     *
     * @param type - TextFormatType to toggle.
     *
     * @returns this TextNode.
     */
    toggleFormat(i) {
      const a = this.getFormat(), d = _o(a, i, null);
      return this.setFormat(d);
    }
    /**
     * Toggles the directionless detail value of the node. Prefer using this method over setDetail.
     *
     * @returns this TextNode.
     */
    toggleDirectionless() {
      const i = this.getWritable();
      return i.__detail ^= Re, i;
    }
    /**
     * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.
     *
     * @returns this TextNode.
     */
    toggleUnmergeable() {
      const i = this.getWritable();
      return i.__detail ^= We, i;
    }
    /**
     * Sets the mode of the node.
     *
     * @returns this TextNode.
     */
    setMode(i) {
      const a = Ue[i];
      if (this.__mode === a)
        return this;
      const d = this.getWritable();
      return d.__mode = a, d;
    }
    /**
     * Sets the text content of the node.
     *
     * @param text - the string to set as the text value of the node.
     *
     * @returns this TextNode.
     */
    setTextContent(i) {
      if (this.__text === i)
        return this;
      const a = this.getWritable();
      return a.__text = i, a;
    }
    /**
     * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.
     *
     * @param _anchorOffset - the offset at which the Selection anchor will be placed.
     * @param _focusOffset - the offset at which the Selection focus will be placed.
     *
     * @returns the new RangeSelection.
     */
    select(i, a) {
      ar();
      let d = i, v = a;
      const M = Nn(), X = this.getTextContent(), ee = this.__key;
      if (typeof X == "string") {
        const pe = X.length;
        d === void 0 && (d = pe), v === void 0 && (v = pe);
      } else
        d = 0, v = 0;
      if (Kt(M)) {
        const pe = tr();
        (pe === M.anchor.key || pe === M.focus.key) && pn(ee), M.setTextNodeRange(this, d, this, v);
      } else
        return Mu(ee, d, ee, v, "text", "text");
      return M;
    }
    selectStart() {
      return this.select(0, 0);
    }
    selectEnd() {
      const i = this.getTextContentSize();
      return this.select(i, i);
    }
    /**
     * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters
     * specified. Can optionally calculate a new selection after the operation is complete.
     *
     * @param offset - the offset at which the splice operation should begin.
     * @param delCount - the number of characters to delete, starting from the offset.
     * @param newText - the text to insert into the TextNode at the offset.
     * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.
     *
     * @returns this TextNode.
     */
    spliceText(i, a, d, v) {
      const M = this.getWritable(), X = M.__text, ee = d.length;
      let pe = i;
      pe < 0 && (pe = ee + pe, pe < 0 && (pe = 0));
      const Ce = Nn();
      if (v && Kt(Ce)) {
        const ve = i + ee;
        Ce.setTextNodeRange(M, ve, M, ve);
      }
      const Ee = X.slice(0, pe) + d + X.slice(pe + a);
      return M.__text = Ee, M;
    }
    /**
     * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
     * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt
     * to insert text into this node. If false, it will insert the text in a new sibling node.
     *
     * @returns true if text can be inserted before the node, false otherwise.
     */
    canInsertTextBefore() {
      return !0;
    }
    /**
     * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
     * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt
     * to insert text into this node. If false, it will insert the text in a new sibling node.
     *
     * @returns true if text can be inserted after the node, false otherwise.
     */
    canInsertTextAfter() {
      return !0;
    }
    /**
     * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings
     * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.
     *
     * @param splitOffsets - rest param of the text content character offsets at which this node should be split.
     *
     * @returns an Array containing the newly-created TextNodes.
     */
    splitText(...i) {
      ar();
      const a = this.getLatest(), d = a.getTextContent(), v = a.__key, M = tr(), X = new Set(i), ee = [], pe = d.length;
      let Ce = "";
      for (let rn = 0; rn < pe; rn++)
        Ce !== "" && X.has(rn) && (ee.push(Ce), Ce = ""), Ce += d[rn];
      Ce !== "" && ee.push(Ce);
      const Ee = ee.length;
      if (Ee === 0)
        return [];
      if (ee[0] === d)
        return [a];
      const ve = ee[0], we = a.getParentOrThrow();
      let ye;
      const Ze = a.getFormat(), Je = a.getStyle(), Xe = a.__detail;
      let xt = !1;
      a.isSegmented() ? (ye = hn(ve), ye.__format = Ze, ye.__style = Je, ye.__detail = Xe, xt = !0) : (ye = a.getWritable(), ye.__text = ve);
      const et = Nn(), mt = [ye];
      let Qt = ve.length;
      for (let rn = 1; rn < Ee; rn++) {
        const Kn = ee[rn], li = Kn.length, cr = hn(Kn).getWritable();
        cr.__format = Ze, cr.__style = Je, cr.__detail = Xe;
        const ln = cr.__key, $n = Qt + li;
        if (Kt(et)) {
          const Vr = et.anchor, Do = et.focus;
          Vr.key === v && Vr.type === "text" && Vr.offset > Qt && Vr.offset <= $n && (Vr.key = ln, Vr.offset -= Qt, et.dirty = !0), Do.key === v && Do.type === "text" && Do.offset > Qt && Do.offset <= $n && (Do.key = ln, Do.offset -= Qt, et.dirty = !0);
        }
        M === v && pn(ln), Qt = $n, mt.push(cr);
      }
      Ps(this);
      const Yt = we.getWritable(), bt = this.getIndexWithinParent();
      return xt ? (Yt.splice(bt, 0, mt), this.remove()) : Yt.splice(bt, 1, mt), Kt(et) && oa(et, we, bt, Ee - 1), mt;
    }
    /**
     * Merges the target TextNode into this TextNode, removing the target node.
     *
     * @param target - the TextNode to merge into this one.
     *
     * @returns this TextNode.
     */
    mergeWithSibling(i) {
      const a = i === this.getPreviousSibling();
      if (!a && i !== this.getNextSibling())
        throw Error("mergeWithSibling: sibling must be a previous or next sibling");
      const d = this.__key, v = i.__key, M = this.__text, X = M.length;
      tr() === v && pn(d);
      const pe = Nn();
      if (Kt(pe)) {
        const we = pe.anchor, ye = pe.focus;
        we !== null && we.key === v && (bu(we, a, d, i, X), pe.dirty = !0), ye !== null && ye.key === v && (bu(ye, a, d, i, X), pe.dirty = !0);
      }
      const Ce = i.__text, Ee = a ? Ce + M : M + Ce;
      this.setTextContent(Ee);
      const ve = this.getWritable();
      return i.remove(), ve;
    }
    /**
     * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
     * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the
     * node class that you create and replace matched text with should return true from this method.
     *
     * @returns true if the node is to be treated as a "text entity", false otherwise.
     */
    isTextEntity() {
      return !1;
    }
  }
  function hs(c) {
    const i = c, a = i.style.fontWeight === "700", d = i.style.textDecoration === "line-through", v = i.style.fontStyle === "italic", M = i.style.textDecoration === "underline", X = i.style.verticalAlign;
    return {
      forChild: (ee) => (Ct(ee) && (a && ee.toggleFormat("bold"), d && ee.toggleFormat("strikethrough"), v && ee.toggleFormat("italic"), M && ee.toggleFormat("underline"), X === "sub" && ee.toggleFormat("subscript"), X === "super" && ee.toggleFormat("superscript")), ee),
      node: null
    };
  }
  function so(c) {
    const a = c.style.fontWeight === "normal";
    return {
      forChild: (d) => (Ct(d) && !a && d.toggleFormat("bold"), d),
      node: null
    };
  }
  const ea = /* @__PURE__ */ new WeakMap();
  function nl(c) {
    return c.nodeName === "PRE" || c.nodeType === Ie && c.style !== void 0 && c.style.whiteSpace !== void 0 && c.style.whiteSpace.startsWith("pre");
  }
  function Ha(c) {
    let i, a = c.parentNode;
    const d = [c];
    for (; a !== null && (i = ea.get(a)) === void 0 && !nl(a); )
      d.push(a), a = a.parentNode;
    const v = i === void 0 ? a : i;
    for (let M = 0; M < d.length; M++)
      ea.set(d[M], v);
    return v;
  }
  function ta(c) {
    const i = c;
    if (c.parentElement === null)
      throw Error("Expected parentElement of Text not to be null");
    let d = i.textContent || "";
    if (Ha(i) !== null) {
      const v = d.split(/(\r?\n|\t)/), M = [], X = v.length;
      for (let ee = 0; ee < X; ee++) {
        const pe = v[ee];
        pe === `
` || pe === `\r
` ? M.push(qr()) : pe === "	" ? M.push(or()) : pe !== "" && M.push(hn(pe));
      }
      return {
        node: M
      };
    }
    if (d = d.replace(/\r/g, "").replace(/[ \t\n]+/g, " "), d === "")
      return {
        node: null
      };
    if (d[0] === " ") {
      let v = i, M = !0;
      for (; v !== null && (v = _n(v, !1)) !== null; ) {
        const X = v.textContent || "";
        if (X.length > 0) {
          /[ \t\n]$/.test(X) && (d = d.slice(1)), M = !1;
          break;
        }
      }
      M && (d = d.slice(1));
    }
    if (d[d.length - 1] === " ") {
      let v = i, M = !0;
      for (; v !== null && (v = _n(v, !0)) !== null; )
        if ((v.textContent || "").replace(/^( |\t|\r?\n)+/, "").length > 0) {
          M = !1;
          break;
        }
      M && (d = d.slice(0, d.length - 1));
    }
    return d === "" ? {
      node: null
    } : {
      node: hn(d)
    };
  }
  const na = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, "i");
  function _n(c, i) {
    let a = c;
    for (; ; ) {
      let d;
      for (; (d = i ? a.nextSibling : a.previousSibling) === null; ) {
        const M = a.parentElement;
        if (M === null)
          return null;
        a = M;
      }
      if (a = d, a.nodeType === Ie) {
        const M = a.style.display;
        if (M === "" && a.nodeName.match(na) === null || M !== "" && !M.startsWith("inline"))
          return null;
      }
      let v = a;
      for (; (v = i ? a.firstChild : a.lastChild) !== null; )
        a = v;
      if (a.nodeType === je)
        return a;
      if (a.nodeName === "BR")
        return null;
    }
  }
  const rr = {
    code: "code",
    em: "italic",
    i: "italic",
    s: "strikethrough",
    strong: "bold",
    sub: "subscript",
    sup: "superscript",
    u: "underline"
  };
  function Sn(c) {
    const i = rr[c.nodeName.toLowerCase()];
    return i === void 0 ? {
      node: null
    } : {
      forChild: (a) => (Ct(a) && !a.hasFormat(i) && a.toggleFormat(i), a),
      node: null
    };
  }
  function hn(c = "") {
    return _r(new jr(c));
  }
  function Ct(c) {
    return c instanceof jr;
  }
  class Yn extends jr {
    static getType() {
      return "tab";
    }
    static clone(i) {
      const a = new Yn(i.__key);
      return a.__text = i.__text, a.__format = i.__format, a.__style = i.__style, a;
    }
    constructor(i) {
      super("	", i), this.__detail = We;
    }
    static importDOM() {
      return null;
    }
    static importJSON(i) {
      const a = or();
      return a.setFormat(i.format), a.setStyle(i.style), a;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "tab",
        version: 1
      };
    }
    setTextContent(i) {
      throw Error("TabNode does not support setTextContent");
    }
    setDetail(i) {
      throw Error("TabNode does not support setDetail");
    }
    setMode(i) {
      throw Error("TabNode does not support setMode");
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
  }
  function or() {
    return _r(new Yn());
  }
  function hr(c) {
    return c instanceof Yn;
  }
  class lo {
    constructor(i, a, d) {
      this._selection = null, this.key = i, this.offset = a, this.type = d;
    }
    is(i) {
      return this.key === i.key && this.offset === i.offset && this.type === i.type;
    }
    isBefore(i) {
      let a = this.getNode(), d = i.getNode();
      const v = this.offset, M = i.offset;
      if (ot(a)) {
        const X = a.getDescendantByIndex(v);
        a = X ?? a;
      }
      if (ot(d)) {
        const X = d.getDescendantByIndex(M);
        d = X ?? d;
      }
      return a === d ? v < M : a.isBefore(d);
    }
    getNode() {
      const i = this.key, a = Bn(i);
      if (a === null)
        throw Error("Point.getNode: node not found");
      return a;
    }
    set(i, a, d) {
      const v = this._selection, M = this.key;
      this.key = i, this.offset = a, this.type = d, ms() || (tr() === M && pn(i), v !== null && (v.setCachedNodes(null), v.dirty = !0));
    }
  }
  function zn(c, i, a) {
    return new lo(c, i, a);
  }
  function ir(c, i) {
    let a = i.__key, d = c.offset, v = "element";
    if (Ct(i)) {
      v = "text";
      const M = i.getTextContentSize();
      d > M && (d = M);
    } else if (!ot(i)) {
      const M = i.getNextSibling();
      if (Ct(M))
        a = M.__key, d = 0, v = "text";
      else {
        const X = i.getParent();
        X && (a = X.__key, d = i.getIndexWithinParent() + 1);
      }
    }
    c.set(a, d, v);
  }
  function ao(c, i) {
    if (ot(i)) {
      const a = i.getLastDescendant();
      ot(a) || Ct(a) ? ir(c, a) : ir(c, i);
    } else
      ir(c, i);
  }
  function wi(c, i, a, d) {
    const v = c.getNode(), M = v.getChildAtIndex(c.offset), X = hn(), ee = Dr(v) ? Ao().append(X) : X;
    X.setFormat(a), X.setStyle(d), M === null ? v.append(ee) : M.insertBefore(ee), c.is(i) && i.set(X.__key, 0, "text"), c.set(X.__key, 0, "text");
  }
  function Gr(c, i, a, d) {
    c.key = i, c.offset = a, c.type = d;
  }
  class ra {
    constructor(i) {
      this._cachedNodes = null, this._nodes = i, this.dirty = !1;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(i) {
      this._cachedNodes = i;
    }
    is(i) {
      if (!rl(i))
        return !1;
      const a = this._nodes, d = i._nodes;
      return a.size === d.size && Array.from(a).every((v) => d.has(v));
    }
    isCollapsed() {
      return !1;
    }
    isBackward() {
      return !1;
    }
    getStartEndPoints() {
      return null;
    }
    add(i) {
      this.dirty = !0, this._nodes.add(i), this._cachedNodes = null;
    }
    delete(i) {
      this.dirty = !0, this._nodes.delete(i), this._cachedNodes = null;
    }
    clear() {
      this.dirty = !0, this._nodes.clear(), this._cachedNodes = null;
    }
    has(i) {
      return this._nodes.has(i);
    }
    clone() {
      return new ra(new Set(this._nodes));
    }
    extract() {
      return this.getNodes();
    }
    insertRawText(i) {
    }
    insertText() {
    }
    insertNodes(i) {
      const a = this.getNodes(), d = a.length, v = a[d - 1];
      let M;
      if (Ct(v))
        M = v.select();
      else {
        const X = v.getIndexWithinParent() + 1;
        M = v.getParentOrThrow().select(X, X);
      }
      M.insertNodes(i);
      for (let X = 0; X < d; X++)
        a[X].remove();
    }
    getNodes() {
      const i = this._cachedNodes;
      if (i !== null)
        return i;
      const a = this._nodes, d = [];
      for (const v of a) {
        const M = Bn(v);
        M !== null && d.push(M);
      }
      return ms() || (this._cachedNodes = d), d;
    }
    getTextContent() {
      const i = this.getNodes();
      let a = "";
      for (let d = 0; d < i.length; d++)
        a += i[d].getTextContent();
      return a;
    }
  }
  function Kt(c) {
    return c instanceof si;
  }
  class si {
    constructor(i, a, d, v) {
      this.anchor = i, this.focus = a, i._selection = this, a._selection = this, this._cachedNodes = null, this.format = d, this.style = v, this.dirty = !1;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(i) {
      this._cachedNodes = i;
    }
    /**
     * Used to check if the provided selections is equal to this one by value,
     * inluding anchor, focus, format, and style properties.
     * @param selection - the Selection to compare this one to.
     * @returns true if the Selections are equal, false otherwise.
     */
    is(i) {
      return Kt(i) ? this.anchor.is(i.anchor) && this.focus.is(i.focus) && this.format === i.format && this.style === i.style : !1;
    }
    /**
     * Returns whether the Selection is "collapsed", meaning the anchor and focus are
     * the same node and have the same offset.
     *
     * @returns true if the Selection is collapsed, false otherwise.
     */
    isCollapsed() {
      return this.anchor.is(this.focus);
    }
    /**
     * Gets all the nodes in the Selection. Uses caching to make it generally suitable
     * for use in hot paths.
     *
     * @returns an Array containing all the nodes in the Selection
     */
    getNodes() {
      const i = this._cachedNodes;
      if (i !== null)
        return i;
      const a = this.anchor, d = this.focus, v = a.isBefore(d), M = v ? a : d, X = v ? d : a;
      let ee = M.getNode(), pe = X.getNode();
      const Ce = M.offset, Ee = X.offset;
      if (ot(ee)) {
        const we = ee.getDescendantByIndex(Ce);
        ee = we ?? ee;
      }
      if (ot(pe)) {
        let we = pe.getDescendantByIndex(Ee);
        we !== null && we !== ee && pe.getChildAtIndex(Ee) === we && (we = we.getPreviousSibling()), pe = we ?? pe;
      }
      let ve;
      return ee.is(pe) ? ot(ee) && ee.getChildrenSize() > 0 ? ve = [] : ve = [ee] : ve = ee.getNodesBetween(pe), ms() || (this._cachedNodes = ve), ve;
    }
    /**
     * Sets this Selection to be of type "text" at the provided anchor and focus values.
     *
     * @param anchorNode - the anchor node to set on the Selection
     * @param anchorOffset - the offset to set on the Selection
     * @param focusNode - the focus node to set on the Selection
     * @param focusOffset - the focus offset to set on the Selection
     */
    setTextNodeRange(i, a, d, v) {
      Gr(this.anchor, i.__key, a, "text"), Gr(this.focus, d.__key, v, "text"), this._cachedNodes = null, this.dirty = !0;
    }
    /**
     * Gets the (plain) text content of all the nodes in the selection.
     *
     * @returns a string representing the text content of all the nodes in the Selection
     */
    getTextContent() {
      const i = this.getNodes();
      if (i.length === 0)
        return "";
      const a = i[0], d = i[i.length - 1], v = this.anchor, M = this.focus, X = v.isBefore(M), [ee, pe] = Wa(this);
      let Ce = "", Ee = !0;
      for (let ve = 0; ve < i.length; ve++) {
        const we = i[ve];
        if (ot(we) && !we.isInline())
          Ee || (Ce += `
`), we.isEmpty() ? Ee = !1 : Ee = !0;
        else if (Ee = !1, Ct(we)) {
          let ye = we.getTextContent();
          we === a ? we === d ? (v.type !== "element" || M.type !== "element" || M.offset === v.offset) && (ye = ee < pe ? ye.slice(ee, pe) : ye.slice(pe, ee)) : ye = X ? ye.slice(ee) : ye.slice(pe) : we === d && (ye = X ? ye.slice(0, pe) : ye.slice(0, ee)), Ce += ye;
        } else
          (Ln(we) || io(we)) && (we !== d || !this.isCollapsed()) && (Ce += we.getTextContent());
      }
      return Ce;
    }
    /**
     * Attempts to map a DOM selection range onto this Lexical Selection,
     * setting the anchor, focus, and type accordingly
     *
     * @param range a DOM Selection range conforming to the StaticRange interface.
     */
    applyDOMRange(i) {
      const a = Tn(), v = a.getEditorState()._selection, M = wu(i.startContainer, i.startOffset, i.endContainer, i.endOffset, a, v);
      if (M === null)
        return;
      const [X, ee] = M;
      Gr(this.anchor, X.key, X.offset, X.type), Gr(this.focus, ee.key, ee.offset, ee.type), this._cachedNodes = null;
    }
    /**
     * Creates a new RangeSelection, copying over all the property values from this one.
     *
     * @returns a new RangeSelection with the same property values as this one.
     */
    clone() {
      const i = this.anchor, a = this.focus;
      return new si(zn(i.key, i.offset, i.type), zn(a.key, a.offset, a.type), this.format, this.style);
    }
    /**
     * Toggles the provided format on all the TextNodes in the Selection.
     *
     * @param format a string TextFormatType to toggle on the TextNodes in the selection
     */
    toggleFormat(i) {
      this.format = _o(this.format, i, null), this.dirty = !0;
    }
    /**
     * Sets the value of the style property on the Selection
     *
     * @param style - the style to set at the value of the style property.
     */
    setStyle(i) {
      this.style = i, this.dirty = !0;
    }
    /**
     * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection
     * has the specified format.
     *
     * @param type the TextFormatType to check for.
     * @returns true if the provided format is currently toggled on on the Selection, false otherwise.
     */
    hasFormat(i) {
      const a = en[i];
      return (this.format & a) !== 0;
    }
    /**
     * Attempts to insert the provided text into the EditorState at the current Selection.
     * converts tabs, newlines, and carriage returns into LexicalNodes.
     *
     * @param text the text to insert into the Selection
     */
    insertRawText(i) {
      const a = i.split(/(\r?\n|\t)/), d = [], v = a.length;
      for (let M = 0; M < v; M++) {
        const X = a[M];
        X === `
` || X === `\r
` ? d.push(qr()) : X === "	" ? d.push(or()) : d.push(hn(X));
      }
      this.insertNodes(d);
    }
    /**
     * Attempts to insert the provided text into the EditorState at the current Selection as a new
     * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.
     *
     * @param text the text to insert into the Selection
     */
    insertText(i) {
      const a = this.anchor, d = this.focus, v = this.isCollapsed() || a.isBefore(d), M = this.format, X = this.style;
      v && a.type === "element" ? wi(a, d, M, X) : !v && d.type === "element" && wi(d, a, M, X);
      const ee = this.getNodes(), pe = ee.length, Ce = v ? a : d, Ee = v ? d : a, ve = Ce.offset, we = Ee.offset;
      let ye = ee[0];
      if (!Ct(ye))
        throw Error("insertText: first node is not a text node");
      const Je = ye.getTextContent().length, Xe = ye.getParentOrThrow(), xt = pe - 1;
      let et = ee[xt];
      if (this.isCollapsed() && ve === Je && (ye.isSegmented() || ye.isToken() || !ye.canInsertTextAfter() || !Xe.canInsertTextAfter() && ye.getNextSibling() === null)) {
        let mt = ye.getNextSibling();
        if ((!Ct(mt) || !mt.canInsertTextBefore() || vr(mt)) && (mt = hn(), mt.setFormat(M), Xe.canInsertTextAfter() ? ye.insertAfter(mt) : Xe.insertAfter(mt)), mt.select(0, 0), ye = mt, i !== "") {
          this.insertText(i);
          return;
        }
      } else if (this.isCollapsed() && ve === 0 && (ye.isSegmented() || ye.isToken() || !ye.canInsertTextBefore() || !Xe.canInsertTextBefore() && ye.getPreviousSibling() === null)) {
        let mt = ye.getPreviousSibling();
        if ((!Ct(mt) || vr(mt)) && (mt = hn(), mt.setFormat(M), Xe.canInsertTextBefore() ? ye.insertBefore(mt) : Xe.insertBefore(mt)), mt.select(), ye = mt, i !== "") {
          this.insertText(i);
          return;
        }
      } else if (ye.isSegmented() && ve !== Je) {
        const mt = hn(ye.getTextContent());
        mt.setFormat(M), ye.replace(mt), ye = mt;
      } else if (!this.isCollapsed() && i !== "") {
        const mt = et.getParent();
        if (!Xe.canInsertTextBefore() || !Xe.canInsertTextAfter() || ot(mt) && (!mt.canInsertTextBefore() || !mt.canInsertTextAfter())) {
          this.insertText(""), vu(this.anchor, this.focus, null), this.insertText(i);
          return;
        }
      }
      if (pe === 1) {
        if (ye.isToken()) {
          const bt = hn(i);
          bt.select(), ye.replace(bt);
          return;
        }
        const mt = ye.getFormat(), Qt = ye.getStyle();
        if (ve === we && (mt !== M || Qt !== X))
          if (ye.getTextContent() === "")
            ye.setFormat(M), ye.setStyle(X);
          else {
            const bt = hn(i);
            if (bt.setFormat(M), bt.setStyle(X), bt.select(), ve === 0)
              ye.insertBefore(bt, !1);
            else {
              const [rn] = ye.splitText(ve);
              rn.insertAfter(bt, !1);
            }
            bt.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= i.length);
            return;
          }
        else if (hr(ye)) {
          const bt = hn(i);
          bt.setFormat(M), bt.setStyle(X), bt.select(), ye.replace(bt);
          return;
        }
        const Yt = we - ve;
        ye = ye.spliceText(ve, Yt, i, !0), ye.getTextContent() === "" ? ye.remove() : this.anchor.type === "text" && (ye.isComposing() ? this.anchor.offset -= i.length : (this.format = mt, this.style = Qt));
      } else {
        const mt = /* @__PURE__ */ new Set([...ye.getParentKeys(), ...et.getParentKeys()]), Qt = ot(ye) ? ye : ye.getParentOrThrow();
        let Yt = ot(et) ? et : et.getParentOrThrow(), bt = et;
        if (!Qt.is(Yt) && Yt.isInline())
          do
            bt = Yt, Yt = Yt.getParentOrThrow();
          while (Yt.isInline());
        if (Ee.type === "text" && (we !== 0 || et.getTextContent() === "") || Ee.type === "element" && et.getIndexWithinParent() < we)
          if (Ct(et) && !et.isToken() && we !== et.getTextContentSize()) {
            if (et.isSegmented()) {
              const ln = hn(et.getTextContent());
              et.replace(ln), et = ln;
            }
            !Dr(Ee.getNode()) && Ee.type === "text" && (et = et.spliceText(0, we, "")), mt.add(et.__key);
          } else {
            const ln = et.getParentOrThrow();
            !ln.canBeEmpty() && ln.getChildrenSize() === 1 ? ln.remove() : et.remove();
          }
        else
          mt.add(et.__key);
        const rn = Yt.getChildren(), Kn = new Set(ee), li = Qt.is(Yt), cr = Qt.isInline() && ye.getNextSibling() === null ? Qt : ye;
        for (let ln = rn.length - 1; ln >= 0; ln--) {
          const $n = rn[ln];
          if ($n.is(ye) || ot($n) && $n.isParentOf(ye))
            break;
          $n.isAttached() && (!Kn.has($n) || $n.is(bt) ? li || cr.insertAfter($n, !1) : $n.remove());
        }
        if (!li) {
          let ln = Yt, $n = null;
          for (; ln !== null; ) {
            const Vr = ln.getChildren(), Do = Vr.length;
            (Do === 0 || Vr[Do - 1].is($n)) && (mt.delete(ln.__key), $n = ln), ln = ln.getParent();
          }
        }
        if (!ye.isToken())
          ye = ye.spliceText(ve, Je - ve, i, !0), ye.getTextContent() === "" ? ye.remove() : ye.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= i.length);
        else if (ve === Je)
          ye.select();
        else {
          const ln = hn(i);
          ln.select(), ye.replace(ln);
        }
        for (let ln = 1; ln < pe; ln++) {
          const $n = ee[ln], Vr = $n.__key;
          mt.has(Vr) || $n.remove();
        }
      }
    }
    /**
     * Removes the text in the Selection, adjusting the EditorState accordingly.
     */
    removeText() {
      this.insertText("");
    }
    /**
     * Applies the provided format to the TextNodes in the Selection, splitting or
     * merging nodes as necessary.
     *
     * @param formatType the format type to apply to the nodes in the Selection.
     */
    formatText(i) {
      if (this.isCollapsed()) {
        this.toggleFormat(i), pn(null);
        return;
      }
      const a = this.getNodes(), d = [];
      for (const et of a)
        Ct(et) && d.push(et);
      const v = d.length;
      if (v === 0) {
        this.toggleFormat(i), pn(null);
        return;
      }
      const M = this.anchor, X = this.focus, ee = this.isBackward(), pe = ee ? X : M, Ce = ee ? M : X;
      let Ee = 0, ve = d[0], we = pe.type === "element" ? 0 : pe.offset;
      if (pe.type === "text" && we === ve.getTextContentSize() && (Ee = 1, ve = d[1], we = 0), ve == null)
        return;
      const ye = ve.getFormatFlags(i, null), Ze = v - 1;
      let Je = d[Ze];
      const Xe = Ce.type === "text" ? Ce.offset : Je.getTextContentSize();
      if (ve.is(Je)) {
        if (we === Xe)
          return;
        if (we === 0 && Xe === ve.getTextContentSize())
          ve.setFormat(ye);
        else {
          const et = ve.splitText(we, Xe), mt = we === 0 ? et[0] : et[1];
          mt.setFormat(ye), pe.type === "text" && pe.set(mt.__key, 0, "text"), Ce.type === "text" && Ce.set(mt.__key, Xe - we, "text");
        }
        this.format = ye;
        return;
      }
      we !== 0 && ([, ve] = ve.splitText(we), we = 0), ve.setFormat(ye);
      const xt = Je.getFormatFlags(i, ye);
      Xe > 0 && (Xe !== Je.getTextContentSize() && ([Je] = Je.splitText(Xe)), Je.setFormat(xt));
      for (let et = Ee + 1; et < Ze; et++) {
        const mt = d[et];
        if (!mt.isToken()) {
          const Qt = mt.getFormatFlags(i, xt);
          mt.setFormat(Qt);
        }
      }
      pe.type === "text" && pe.set(ve.__key, we, "text"), Ce.type === "text" && Ce.set(Je.__key, Xe, "text"), this.format = ye | xt;
    }
    /**
     * Attempts to "intelligently" insert an arbitrary list of Lexical nodes into the EditorState at the
     * current Selection according to a set of heuristics that determine how surrounding nodes
     * should be changed, replaced, or moved to accomodate the incoming ones.
     *
     * @param nodes - the nodes to insert
     */
    insertNodes(i) {
      if (i.length === 0)
        return;
      if (this.anchor.key === "root") {
        this.insertParagraph();
        const xt = Nn();
        if (!Kt(xt))
          throw Error("Expected RangeSelection after insertParagraph");
        return xt.insertNodes(i);
      }
      const a = this.isBackward() ? this.focus : this.anchor, d = ns(a.getNode(), Oo), v = i[i.length - 1];
      if ("__language" in d && ot(d)) {
        if ("__language" in i[0])
          this.insertText(i[0].getTextContent());
        else {
          const xt = za(this);
          d.splice(xt, 0, i), v.selectEnd();
        }
        return;
      }
      const M = (xt) => (ot(xt) || Ln(xt)) && !xt.isInline();
      if (!i.some(M)) {
        if (!ot(d))
          throw Error("Expected 'firstBlock' to be an ElementNode");
        const xt = za(this);
        d.splice(xt, 0, i), v.selectEnd();
        return;
      }
      const X = Uh(i), ee = X.getLastDescendant(), pe = X.getChildren(), Ce = (xt) => "__value" in xt && "__checked" in xt, Ee = (xt) => ot(xt) && Oo(xt) && !xt.isEmpty() && ot(d) && (!d.isEmpty() || Ce(d)), we = !ot(d) || !d.isEmpty() ? this.insertParagraph() : null, ye = pe[pe.length - 1];
      let Ze = pe[0];
      if (Ee(Ze)) {
        if (!ot(d))
          throw Error("Expected 'firstBlock' to be an ElementNode");
        d.append(...Ze.getChildren()), Ze = pe[1];
      }
      Ze && ja(d, Ze);
      const Je = ns(ee, Oo);
      we && ot(Je) && (Ce(we) || Oo(ye)) && (Je.append(...we.getChildren()), we.remove()), ot(d) && d.isEmpty() && d.remove(), ee.selectEnd();
      const Xe = ot(d) ? d.getLastChild() : null;
      io(Xe) && Je !== d && Xe.remove();
    }
    /**
     * Inserts a new ParagraphNode into the EditorState at the current Selection
     *
     * @returns the newly inserted node.
     */
    insertParagraph() {
      if (this.anchor.key === "root") {
        const X = Ao();
        return lr().splice(this.anchor.offset, 0, [X]), X.select(), X;
      }
      const i = za(this), a = ns(this.anchor.getNode(), Oo);
      if (!ot(a))
        throw Error("Expected ancestor to be an ElementNode");
      const d = a.getChildAtIndex(i), v = d ? [d, ...d.getNextSiblings()] : [], M = a.insertNewAfter(this, !1);
      return M ? (M.append(...v), M.selectStart(), M) : null;
    }
    /**
     * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the
     * current Selection.
     */
    insertLineBreak(i) {
      const a = qr();
      if (this.insertNodes([a]), i) {
        const d = a.getParentOrThrow(), v = a.getIndexWithinParent();
        d.select(v, v);
      }
    }
    /**
     * Extracts the nodes in the Selection, splitting nodes where necessary
     * to get offset-level precision.
     *
     * @returns The nodes in the Selection
     */
    extract() {
      const i = this.getNodes(), a = i.length, d = a - 1, v = this.anchor, M = this.focus;
      let X = i[0], ee = i[d];
      const [pe, Ce] = Wa(this);
      if (a === 0)
        return [];
      if (a === 1) {
        if (Ct(X) && !this.isCollapsed()) {
          const ve = pe > Ce ? Ce : pe, we = pe > Ce ? pe : Ce, ye = X.splitText(ve, we), Ze = ve === 0 ? ye[0] : ye[1];
          return Ze != null ? [Ze] : [];
        }
        return [X];
      }
      const Ee = v.isBefore(M);
      if (Ct(X)) {
        const ve = Ee ? pe : Ce;
        ve === X.getTextContentSize() ? i.shift() : ve !== 0 && ([, X] = X.splitText(ve), i[0] = X);
      }
      if (Ct(ee)) {
        const we = ee.getTextContent().length, ye = Ee ? Ce : pe;
        ye === 0 ? i.pop() : ye !== we && ([ee] = ee.splitText(ye), i[d] = ee);
      }
      return i;
    }
    /**
     * Modifies the Selection according to the parameters and a set of heuristics that account for
     * various node types. Can be used to safely move or extend selection by one logical "unit" without
     * dealing explicitly with all the possible node types.
     *
     * @param alter the type of modification to perform
     * @param isBackward whether or not selection is backwards
     * @param granularity the granularity at which to apply the modification
     */
    modify(i, a, d) {
      const v = this.focus, M = this.anchor, X = i === "move", ee = Ws(v, a);
      if (Ln(ee) && !ee.isIsolated()) {
        if (X && ee.isKeyboardSelectable()) {
          const ye = Ua();
          ye.add(ee.__key), mr(ye);
          return;
        }
        const we = a ? ee.getPreviousSibling() : ee.getNextSibling();
        if (Ct(we)) {
          const ye = we.__key, Ze = a ? we.getTextContent().length : 0;
          v.set(ye, Ze, "text"), X && M.set(ye, Ze, "text");
          return;
        } else {
          const ye = ee.getParentOrThrow();
          let Ze, Je;
          ot(we) ? (Je = we.__key, Ze = a ? we.getChildrenSize() : 0) : (Ze = ee.getIndexWithinParent(), Je = ye.__key, a || Ze++), v.set(Je, Ze, "element"), X && M.set(Je, Ze, "element");
          return;
        }
      }
      const pe = Tn(), Ce = Nr(pe._window);
      if (!Ce)
        return;
      const Ee = pe._blockCursorElement, ve = pe._rootElement;
      if (ve !== null && Ee !== null && ot(ee) && !ee.isInline() && !ee.canBeEmpty() && So(Ee, pe, ve), Lh(Ce, i, a ? "backward" : "forward", d), Ce.rangeCount > 0) {
        const we = Ce.getRangeAt(0), ye = this.anchor.getNode(), Ze = Dr(ye) ? ye : ts(ye);
        if (this.applyDOMRange(we), this.dirty = !0, !X) {
          const Je = this.getNodes(), Xe = [];
          let xt = !1;
          for (let et = 0; et < Je.length; et++) {
            const mt = Je[et];
            yo(mt, Ze) ? Xe.push(mt) : xt = !0;
          }
          if (xt && Xe.length > 0)
            if (a) {
              const et = Xe[0];
              ot(et) ? et.selectStart() : et.getParentOrThrow().selectStart();
            } else {
              const et = Xe[Xe.length - 1];
              ot(et) ? et.selectEnd() : et.getParentOrThrow().selectEnd();
            }
          (Ce.anchorNode !== we.startContainer || Ce.anchorOffset !== we.startOffset) && Dh(this);
        }
      }
    }
    /**
     * Performs one logical character deletion operation on the EditorState based on the current Selection.
     * Handles different node types.
     *
     * @param isBackward whether or not the selection is backwards.
     */
    deleteCharacter(i) {
      const a = this.isCollapsed();
      if (this.isCollapsed()) {
        const d = this.anchor, v = this.focus;
        let M = d.getNode();
        if (!i && // Delete forward handle case
        (d.type === "element" && ot(M) && d.offset === M.getChildrenSize() || d.type === "text" && d.offset === M.getTextContentSize())) {
          const ee = M.getParent(), pe = M.getNextSibling() || (ee === null ? null : ee.getNextSibling());
          if (ot(pe) && pe.isShadowRoot())
            return;
        }
        const X = Ws(v, i);
        if (Ln(X) && !X.isIsolated()) {
          if (X.isKeyboardSelectable() && ot(M) && M.getChildrenSize() === 0) {
            M.remove();
            const ee = Ua();
            ee.add(X.__key), mr(ee);
          } else
            X.remove(), Tn().dispatchCommand(n, void 0);
          return;
        } else if (!i && ot(X) && ot(M) && M.isEmpty()) {
          M.remove(), X.selectStart();
          return;
        }
        if (this.modify("extend", i, "character"), this.isCollapsed()) {
          if (i && d.offset === 0 && (d.type === "element" ? d.getNode() : d.getNode().getParentOrThrow()).collapseAtStart(this))
            return;
        } else {
          const ee = v.type === "text" ? v.getNode() : null;
          if (M = d.type === "text" ? d.getNode() : null, ee !== null && ee.isSegmented()) {
            const pe = v.offset, Ce = ee.getTextContentSize();
            if (ee.is(M) || i && pe !== Ce || !i && pe !== 0) {
              yu(ee, i, pe);
              return;
            }
          } else if (M !== null && M.isSegmented()) {
            const pe = d.offset, Ce = M.getTextContentSize();
            if (M.is(ee) || i && pe !== 0 || !i && pe !== Ce) {
              yu(M, i, pe);
              return;
            }
          }
          Ih(this, i);
        }
      }
      if (this.removeText(), i && !a && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0) {
        const d = this.anchor.getNode();
        d.isEmpty() && Dr(d.getParent()) && d.getIndexWithinParent() === 0 && d.collapseAtStart(this);
      }
    }
    /**
     * Performs one logical line deletion operation on the EditorState based on the current Selection.
     * Handles different node types.
     *
     * @param isBackward whether or not the selection is backwards.
     */
    deleteLine(i) {
      this.isCollapsed() && (this.anchor.type === "text" && this.modify("extend", i, "lineboundary"), (i ? this.focus : this.anchor).offset === 0 && this.modify("extend", i, "character")), this.removeText();
    }
    /**
     * Performs one logical word deletion operation on the EditorState based on the current Selection.
     * Handles different node types.
     *
     * @param isBackward whether or not the selection is backwards.
     */
    deleteWord(i) {
      this.isCollapsed() && this.modify("extend", i, "word"), this.removeText();
    }
    /**
     * Returns whether the Selection is "backwards", meaning the focus
     * logically precedes the anchor in the EditorState.
     * @returns true if the Selection is backwards, false otherwise.
     */
    isBackward() {
      return this.focus.isBefore(this.anchor);
    }
    getStartEndPoints() {
      return [this.anchor, this.focus];
    }
  }
  function rl(c) {
    return c instanceof ra;
  }
  function Tu(c) {
    const i = c.offset;
    if (c.type === "text")
      return i;
    const a = c.getNode();
    return i === a.getChildrenSize() ? a.getTextContent().length : 0;
  }
  function Wa(c) {
    const i = c.getStartEndPoints();
    if (i === null)
      return [0, 0];
    const [a, d] = i;
    return a.type === "element" && d.type === "element" && a.key === d.key && a.offset === d.offset ? [0, 0] : [Tu(a), Tu(d)];
  }
  function Dh(c) {
    const i = c.focus, a = c.anchor, d = a.key, v = a.offset, M = a.type;
    Gr(a, i.key, i.offset, i.type), Gr(i, d, v, M), c._cachedNodes = null;
  }
  function Lh(c, i, a, d) {
    c.modify(i, a, d);
  }
  function Ih(c, i) {
    const a = c.anchor, d = c.focus, v = a.getNode(), M = d.getNode();
    if (v === M && a.type === "text" && d.type === "text") {
      const X = a.offset, ee = d.offset, pe = X < ee, Ce = pe ? X : ee, Ee = pe ? ee : X, ve = Ee - 1;
      if (Ce !== ve) {
        const we = v.getTextContent().slice(Ce, Ee);
        Yo(we) || (i ? d.offset = ve : a.offset = ve);
      }
    }
  }
  function yu(c, i, a) {
    const d = c, M = d.getTextContent().split(/(?=\s)/g), X = M.length;
    let ee = 0, pe = 0;
    for (let Ee = 0; Ee < X; Ee++) {
      const ve = M[Ee], we = Ee === X - 1;
      if (pe = ee, ee += ve.length, i && ee === a || ee > a || we) {
        M.splice(Ee, 1), we && (pe = void 0);
        break;
      }
    }
    const Ce = M.join("").trim();
    Ce === "" ? d.remove() : (d.setTextContent(Ce), d.select(pe, pe));
  }
  function $h(c, i, a) {
    const d = c.getParent();
    return a === null || d === null || !d.canBeEmpty() || d !== a.getNode();
  }
  function Su(c, i, a, d) {
    let v = i, M;
    if (c.nodeType === Ie) {
      let X = !1;
      const ee = c.childNodes, pe = ee.length;
      v === pe && (X = !0, v = pe - 1);
      let Ce = ee[v], Ee = !1;
      if (Ce === d._blockCursorElement ? (Ce = ee[v + 1], Ee = !0) : d._blockCursorElement !== null && v--, M = No(Ce), Ct(M))
        v = Fs(M, X);
      else {
        let ve = No(c);
        if (ve === null)
          return null;
        if (ot(ve)) {
          let we = ve.getChildAtIndex(v);
          if (ot(we) && $h(we, v, a)) {
            const ye = X ? we.getLastDescendant() : we.getFirstDescendant();
            ye === null ? (ve = we, v = 0) : (we = ye, ve = ot(we) ? we : we.getParentOrThrow());
          }
          Ct(we) ? (M = we, ve = null, v = Fs(we, X)) : we !== ve && X && !Ee && v++;
        } else {
          const we = ve.getIndexWithinParent();
          i === 0 && Ln(ve) && No(c) === ve ? v = we : v = we + 1, ve = ve.getParentOrThrow();
        }
        if (ot(ve))
          return zn(ve.__key, v, "element");
      }
    } else
      M = No(c);
    return Ct(M) ? zn(M.__key, v, "text") : null;
  }
  function Ou(c, i, a) {
    const d = c.offset, v = c.getNode();
    if (d === 0) {
      const M = v.getPreviousSibling(), X = v.getParent();
      if (!i)
        ot(M) && !a && M.isInline() ? (c.key = M.__key, c.offset = M.getChildrenSize(), c.type = "element") : Ct(M) && (c.key = M.__key, c.offset = M.getTextContent().length);
      else if ((a || !i) && M === null && ot(X) && X.isInline()) {
        const ee = X.getPreviousSibling();
        Ct(ee) && (c.key = ee.__key, c.offset = ee.getTextContent().length);
      }
    } else if (d === v.getTextContent().length) {
      const M = v.getNextSibling(), X = v.getParent();
      if (i && ot(M) && M.isInline())
        c.key = M.__key, c.offset = 0, c.type = "element";
      else if ((a || i) && M === null && ot(X) && X.isInline() && !X.canInsertTextAfter()) {
        const ee = X.getNextSibling();
        Ct(ee) && (c.key = ee.__key, c.offset = 0);
      }
    }
  }
  function vu(c, i, a) {
    if (c.type === "text" && i.type === "text") {
      const d = c.isBefore(i), v = c.is(i);
      Ou(c, d, v), Ou(i, !d, v), v && (i.key = c.key, i.offset = c.offset, i.type = c.type);
      const M = Tn();
      if (M.isComposing() && M._compositionKey !== c.key && Kt(a)) {
        const X = a.anchor, ee = a.focus;
        Gr(c, X.key, X.offset, X.type), Gr(i, ee.key, ee.offset, ee.type);
      }
    }
  }
  function wu(c, i, a, d, v, M) {
    if (c === null || a === null || !gi(v, c, a))
      return null;
    const X = Su(c, i, Kt(M) ? M.anchor : null, v);
    if (X === null)
      return null;
    const ee = Su(a, d, Kt(M) ? M.focus : null, v);
    if (ee === null)
      return null;
    if (X.type === "element" && ee.type === "element") {
      const pe = No(c), Ce = No(a);
      if (Ln(pe) && Ln(Ce))
        return null;
    }
    return vu(X, ee, M), [X, ee];
  }
  function kh(c) {
    return ot(c) && !c.isInline();
  }
  function Mu(c, i, a, d, v, M) {
    const X = co(), ee = new si(zn(c, i, v), zn(a, d, M), 0, "");
    return ee.dirty = !0, X._selection = ee, ee;
  }
  function Ph() {
    const c = zn("root", 0, "element"), i = zn("root", 0, "element");
    return new si(c, i, 0, "");
  }
  function Ua() {
    return new ra(/* @__PURE__ */ new Set());
  }
  function Fh(c) {
    const a = c.getEditorState()._selection, d = Nr(c._window);
    return Kt(a) || a == null ? Ya(a, d, c, null) : a.clone();
  }
  function Ya(c, i, a, d) {
    const v = a._window;
    if (v === null)
      return null;
    const M = d || v.event, X = M ? M.type : void 0, ee = X === "selectionchange", pe = !Wt() && (ee || X === "beforeinput" || X === "compositionstart" || X === "compositionend" || X === "click" && M && M.detail === 3 || X === "drop" || X === void 0);
    let Ce, Ee, ve, we;
    if (!Kt(c) || pe) {
      if (i === null)
        return null;
      if (Ce = i.anchorNode, Ee = i.focusNode, ve = i.anchorOffset, we = i.focusOffset, ee && Kt(c) && !gi(a, Ce, Ee))
        return c.clone();
    } else
      return c.clone();
    const ye = wu(Ce, ve, Ee, we, a, c);
    if (ye === null)
      return null;
    const [Ze, Je] = ye;
    return new si(Ze, Je, Kt(c) ? c.format : 0, Kt(c) ? c.style : "");
  }
  function Nn() {
    return co()._selection;
  }
  function ps() {
    return Tn()._editorState._selection;
  }
  function oa(c, i, a, d = 1) {
    const v = c.anchor, M = c.focus, X = v.getNode(), ee = M.getNode();
    if (!i.is(X) && !i.is(ee))
      return;
    const pe = i.__key;
    if (c.isCollapsed()) {
      const Ce = v.offset;
      if (a <= Ce && d > 0 || a < Ce && d < 0) {
        const Ee = Math.max(0, Ce + d);
        v.set(pe, Ee, "element"), M.set(pe, Ee, "element"), Ru(c);
      }
    } else {
      const Ce = c.isBackward(), Ee = Ce ? M : v, ve = Ee.getNode(), we = Ce ? v : M, ye = we.getNode();
      if (i.is(ve)) {
        const Ze = Ee.offset;
        (a <= Ze && d > 0 || a < Ze && d < 0) && Ee.set(pe, Math.max(0, Ze + d), "element");
      }
      if (i.is(ye)) {
        const Ze = we.offset;
        (a <= Ze && d > 0 || a < Ze && d < 0) && we.set(pe, Math.max(0, Ze + d), "element");
      }
    }
    Ru(c);
  }
  function Ru(c) {
    const i = c.anchor, a = i.offset, d = c.focus, v = d.offset, M = i.getNode(), X = d.getNode();
    if (c.isCollapsed()) {
      if (!ot(M))
        return;
      const ee = M.getChildrenSize(), pe = a >= ee, Ce = pe ? M.getChildAtIndex(ee - 1) : M.getChildAtIndex(a);
      if (Ct(Ce)) {
        let Ee = 0;
        pe && (Ee = Ce.getTextContentSize()), i.set(Ce.__key, Ee, "text"), d.set(Ce.__key, Ee, "text");
      }
      return;
    }
    if (ot(M)) {
      const ee = M.getChildrenSize(), pe = a >= ee, Ce = pe ? M.getChildAtIndex(ee - 1) : M.getChildAtIndex(a);
      if (Ct(Ce)) {
        let Ee = 0;
        pe && (Ee = Ce.getTextContentSize()), i.set(Ce.__key, Ee, "text");
      }
    }
    if (ot(X)) {
      const ee = X.getChildrenSize(), pe = v >= ee, Ce = pe ? X.getChildAtIndex(ee - 1) : X.getChildAtIndex(v);
      if (Ct(Ce)) {
        let Ee = 0;
        pe && (Ee = Ce.getTextContentSize()), d.set(Ce.__key, Ee, "text");
      }
    }
  }
  function Bh(c, i) {
    const d = i.getEditorState()._selection, v = c._selection;
    if (Kt(v)) {
      const M = v.anchor, X = v.focus;
      let ee;
      if (M.type === "text" && (ee = M.getNode(), ee.selectionTransform(d, v)), X.type === "text") {
        const pe = X.getNode();
        ee !== pe && pe.selectionTransform(d, v);
      }
    }
  }
  function ia(c, i, a, d, v) {
    let M = null, X = 0, ee = null;
    d !== null ? (M = d.__key, Ct(d) ? (X = d.getTextContentSize(), ee = "text") : ot(d) && (X = d.getChildrenSize(), ee = "element")) : v !== null && (M = v.__key, Ct(v) ? ee = "text" : ot(v) && (ee = "element")), M !== null && ee !== null ? c.set(M, X, ee) : (X = i.getIndexWithinParent(), X === -1 && (X = a.getChildrenSize()), c.set(a.__key, X, "element"));
  }
  function bu(c, i, a, d, v) {
    c.type === "text" ? (c.key = a, i || (c.offset += v)) : c.offset > d.getIndexWithinParent() && (c.offset -= 1);
  }
  function Kh(c, i, a, d, v, M, X) {
    const ee = d.anchorNode, pe = d.focusNode, Ce = d.anchorOffset, Ee = d.focusOffset, ve = document.activeElement;
    if (v.has("collaboration") && ve !== M || ve !== null && ji(ve))
      return;
    if (!Kt(i)) {
      c !== null && gi(a, ee, pe) && d.removeAllRanges();
      return;
    }
    const we = i.anchor, ye = i.focus, Ze = we.key, Je = ye.key, Xe = Ei(a, Ze), xt = Ei(a, Je), et = we.offset, mt = ye.offset, Qt = i.format, Yt = i.style, bt = i.isCollapsed();
    let rn = Xe, Kn = xt, li = !1;
    if (we.type === "text") {
      rn = In(Xe);
      const cr = we.getNode();
      li = cr.getFormat() !== Qt || cr.getStyle() !== Yt;
    } else
      Kt(c) && c.anchor.type === "text" && (li = !0);
    if (ye.type === "text" && (Kn = In(xt)), !(rn === null || Kn === null) && (bt && (c === null || li || Kt(c) && (c.format !== Qt || c.style !== Yt)) && Kr(Qt, Yt, et, Ze, performance.now()), !(Ce === et && Ee === mt && ee === rn && pe === Kn && // Badly interpreted range selection when collapsed - #1482
    !(d.type === "Range" && bt) && ((ve === null || !M.contains(ve)) && M.focus({
      preventScroll: !0
    }), we.type !== "element")))) {
      try {
        d.setBaseAndExtent(rn, et, Kn, mt);
      } catch {
      }
      if (!v.has("skip-scroll-into-view") && i.isCollapsed() && M !== null && M === document.activeElement) {
        const cr = i instanceof si && i.anchor.type === "element" ? rn.childNodes[et] || null : d.rangeCount > 0 ? d.getRangeAt(0) : null;
        if (cr !== null) {
          let ln;
          if (cr instanceof Text) {
            const $n = document.createRange();
            $n.selectNode(cr), ln = $n.getBoundingClientRect();
          } else
            ln = cr.getBoundingClientRect();
          no(a, ln, M);
        }
      }
      Qs();
    }
  }
  function jh(c) {
    let i = Nn() || ps();
    i === null && (i = lr().selectEnd()), i.insertNodes(c);
  }
  function Hh() {
    const c = Nn();
    return c === null ? "" : c.getTextContent();
  }
  function za(c) {
    c.isCollapsed() || c.removeText();
    const i = c.anchor;
    let a = i.getNode(), d = i.offset;
    for (; !Oo(a); )
      [a, d] = Wh(a, d);
    return d;
  }
  function Wh(c, i) {
    const a = c.getParent();
    if (!a) {
      const v = Ao();
      return lr().append(v), v.select(), [lr(), 0];
    }
    if (Ct(c)) {
      const v = c.splitText(i);
      if (v.length === 0)
        return [a, c.getIndexWithinParent()];
      const M = i === 0 ? 0 : 1, X = v[0].getIndexWithinParent() + M;
      return [a, X];
    }
    if (!ot(c) || i === 0)
      return [a, c.getIndexWithinParent()];
    const d = c.getChildAtIndex(i);
    if (d) {
      const v = new si(zn(c.__key, i, "element"), zn(c.__key, i, "element"), 0, ""), M = c.insertNewAfter(v);
      M && M.append(d, ...d.getNextSiblings());
    }
    return [a, c.getIndexWithinParent() + 1];
  }
  function Uh(c) {
    const i = Ao();
    let a = null;
    for (let d = 0; d < c.length; d++) {
      const v = c[d], M = io(v);
      if (M || Ln(v) && v.isInline() || ot(v) && v.isInline() || Ct(v) || v.isParentRequired()) {
        if (a === null && (a = v.createParentElementNode(), i.append(a), M))
          continue;
        a !== null && a.append(v);
      } else
        i.append(v), a = null;
    }
    return i;
  }
  let Xn = null, Zn = null, xr = !1, qa = !1, sa = 0;
  const Au = {
    characterData: !0,
    childList: !0,
    subtree: !0
  };
  function ms() {
    return xr || Xn !== null && Xn._readOnly;
  }
  function ar() {
    if (xr)
      throw Error("Cannot use method in read-only mode.");
  }
  function Du() {
    if (sa > 99)
      throw Error("One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.");
  }
  function co() {
    if (Xn === null)
      throw Error("Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().");
    return Xn;
  }
  function Tn() {
    if (Zn === null)
      throw Error("Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().");
    return Zn;
  }
  function Yh() {
    return Zn;
  }
  function Lu(c, i, a) {
    const d = i.__type, v = Or(c, d);
    let M = a.get(d);
    M === void 0 && (M = Array.from(v.transforms), a.set(d, M));
    const X = M.length;
    for (let ee = 0; ee < X && (M[ee](i), !!i.isAttached()); ee++)
      ;
  }
  function Iu(c, i) {
    return c !== void 0 && // We don't want to transform nodes being composed
    c.__key !== i && c.isAttached();
  }
  function zh(c, i) {
    const a = i._dirtyLeaves, d = c._nodeMap;
    for (const v of a) {
      const M = d.get(v);
      Ct(M) && M.isAttached() && M.isSimpleText() && !M.isUnmergeable() && Wr(M);
    }
  }
  function qh(c, i) {
    const a = i._dirtyLeaves, d = i._dirtyElements, v = c._nodeMap, M = tr(), X = /* @__PURE__ */ new Map();
    let ee = a, pe = ee.size, Ce = d, Ee = Ce.size;
    for (; pe > 0 || Ee > 0; ) {
      if (pe > 0) {
        i._dirtyLeaves = /* @__PURE__ */ new Set();
        for (const ve of ee) {
          const we = v.get(ve);
          Ct(we) && we.isAttached() && we.isSimpleText() && !we.isUnmergeable() && Wr(we), we !== void 0 && Iu(we, M) && Lu(i, we, X), a.add(ve);
        }
        if (ee = i._dirtyLeaves, pe = ee.size, pe > 0) {
          sa++;
          continue;
        }
      }
      i._dirtyLeaves = /* @__PURE__ */ new Set(), i._dirtyElements = /* @__PURE__ */ new Map();
      for (const ve of Ce) {
        const we = ve[0], ye = ve[1];
        if (we !== "root" && !ye)
          continue;
        const Ze = v.get(we);
        Ze !== void 0 && Iu(Ze, M) && Lu(i, Ze, X), d.set(we, ye);
      }
      ee = i._dirtyLeaves, pe = ee.size, Ce = i._dirtyElements, Ee = Ce.size, sa++;
    }
    i._dirtyLeaves = a, i._dirtyElements = d;
  }
  function Gh(c) {
    return Ga(c, Tn()._nodes);
  }
  function Ga(c, i) {
    const a = c.type, d = i.get(a);
    if (d === void 0)
      throw Error(`parseEditorState: type "${a}" + not found`);
    const v = d.klass;
    if (c.type !== v.getType())
      throw Error(`LexicalNode: Node ${v.name} does not implement .importJSON().`);
    const M = v.importJSON(c), X = c.children;
    if (ot(M) && Array.isArray(X))
      for (let ee = 0; ee < X.length; ee++) {
        const pe = X[ee], Ce = Ga(pe, i);
        M.append(Ce);
      }
    return M;
  }
  function Vh(c, i, a) {
    const d = Ja(), v = Xn, M = xr, X = Zn, ee = i._dirtyElements, pe = i._dirtyLeaves, Ce = i._cloneNotNeeded, Ee = i._dirtyType;
    i._dirtyElements = /* @__PURE__ */ new Map(), i._dirtyLeaves = /* @__PURE__ */ new Set(), i._cloneNotNeeded = /* @__PURE__ */ new Set(), i._dirtyType = 0, Xn = d, xr = !1, Zn = i;
    try {
      const ve = i._nodes, we = c.root;
      Ga(we, ve), a && a(), d._readOnly = !0, ku(d);
    } catch (ve) {
      ve instanceof Error && i._onError(ve);
    } finally {
      i._dirtyElements = ee, i._dirtyLeaves = pe, i._cloneNotNeeded = Ce, i._dirtyType = Ee, Xn = v, xr = M, Zn = X;
    }
    return d;
  }
  function $u(c, i) {
    const a = Xn, d = xr, v = Zn;
    Xn = c, xr = !0, Zn = null;
    try {
      return i();
    } finally {
      Xn = a, xr = d, Zn = v;
    }
  }
  function ku(c) {
    const i = c._nodeMap;
    i.set = () => {
      throw new Error("Cannot call set() on a frozen Lexical node map");
    }, i.clear = () => {
      throw new Error("Cannot call clear() on a frozen Lexical node map");
    }, i.delete = () => {
      throw new Error("Cannot call delete() on a frozen Lexical node map");
    };
  }
  function Mi(c, i) {
    const a = c._pendingEditorState, d = c._rootElement, v = c._headless || d === null;
    if (a === null)
      return;
    const M = c._editorState, X = M._selection, ee = a._selection, pe = c._dirtyType !== Oe, Ce = Xn, Ee = xr, ve = Zn, we = c._updating, ye = c._observer;
    let Ze = null;
    if (c._pendingEditorState = null, c._editorState = a, !v && pe && ye !== null) {
      Zn = c, Xn = a, xr = !1, c._updating = !0;
      try {
        const bt = c._dirtyType, rn = c._dirtyElements, Kn = c._dirtyLeaves;
        ye.disconnect(), Ze = ti(M, a, c, bt, rn, Kn);
      } catch (bt) {
        if (bt instanceof Error && c._onError(bt), !qa)
          Hu(c, null, d, a), jo(c), c._dirtyType = He, qa = !0, Mi(c, M), qa = !1;
        else
          throw bt;
        return;
      } finally {
        ye.observe(d, Au), c._updating = we, Xn = Ce, xr = Ee, Zn = ve;
      }
    }
    a._readOnly || (a._readOnly = !0, ku(a), Kt(ee) && (Object.freeze(ee.anchor), Object.freeze(ee.focus)), Object.freeze(ee));
    const Je = c._dirtyLeaves, Xe = c._dirtyElements, xt = c._normalizedNodes, et = c._updateTags, mt = c._deferred;
    pe && (c._dirtyType = Oe, c._cloneNotNeeded.clear(), c._dirtyLeaves = /* @__PURE__ */ new Set(), c._dirtyElements = /* @__PURE__ */ new Map(), c._normalizedNodes = /* @__PURE__ */ new Set(), c._updateTags = /* @__PURE__ */ new Set()), zs(c, a);
    const Qt = v ? null : Nr(c._window);
    if (c._editable && // domSelection will be null in headless
    Qt !== null && (pe || ee === null || ee.dirty)) {
      Zn = c, Xn = a;
      try {
        if (ye !== null && ye.disconnect(), pe || ee === null || ee.dirty) {
          const bt = c._blockCursorElement;
          bt !== null && So(bt, c, d), Kh(X, ee, c, Qt, et, d);
        }
        jl(c, d, ee), ye !== null && ye.observe(d, Au);
      } finally {
        Zn = ve, Xn = Ce;
      }
    }
    Ze !== null && Xh(c, Ze, et, Je, M), !Kt(ee) && ee !== null && (X === null || !X.is(ee)) && c.dispatchCommand(n, void 0);
    const Yt = c._pendingDecorators;
    Yt !== null && (c._decorators = Yt, c._pendingDecorators = null, ol("decorator", c, !0, Yt)), Jh(c, i || M, a), ol("update", c, !0, {
      dirtyElements: Xe,
      dirtyLeaves: Je,
      editorState: a,
      normalizedNodes: xt,
      prevEditorState: i || M,
      tags: et
    }), Qh(c, mt), Zh(c);
  }
  function Jh(c, i, a) {
    const d = to(i), v = to(a);
    d !== v && ol("textcontent", c, !0, v);
  }
  function Xh(c, i, a, d, v) {
    const M = Array.from(c._listeners.mutation), X = M.length;
    for (let ee = 0; ee < X; ee++) {
      const [pe, Ce] = M[ee], Ee = i.get(Ce);
      Ee !== void 0 && pe(Ee, {
        dirtyLeaves: d,
        prevEditorState: v,
        updateTags: a
      });
    }
  }
  function ol(c, i, a, ...d) {
    const v = i._updating;
    i._updating = a;
    try {
      const M = Array.from(i._listeners[c]);
      for (let X = 0; X < M.length; X++)
        M[X].apply(null, d);
    } finally {
      i._updating = v;
    }
  }
  function Pu(c, i, a) {
    if (c._updating === !1 || Zn !== c) {
      let v = !1;
      return c.update(() => {
        v = Pu(c, i, a);
      }), v;
    }
    const d = zi(c);
    for (let v = 4; v >= 0; v--)
      for (let M = 0; M < d.length; M++) {
        const pe = d[M]._commands.get(i);
        if (pe !== void 0) {
          const Ce = pe[v];
          if (Ce !== void 0) {
            const Ee = Array.from(Ce), ve = Ee.length;
            for (let we = 0; we < ve; we++)
              if (Ee[we](a, c) === !0)
                return !0;
          }
        }
      }
    return !1;
  }
  function Zh(c) {
    const i = c._updates;
    if (i.length !== 0) {
      const a = i.shift();
      if (a) {
        const [d, v] = a;
        Bu(c, d, v);
      }
    }
  }
  function Qh(c, i) {
    if (c._deferred = [], i.length !== 0) {
      const a = c._updating;
      c._updating = !0;
      try {
        for (let d = 0; d < i.length; d++)
          i[d]();
      } finally {
        c._updating = a;
      }
    }
  }
  function Fu(c, i) {
    const a = c._updates;
    let d = i || !1;
    for (; a.length !== 0; ) {
      const v = a.shift();
      if (v) {
        const [M, X] = v;
        let ee, pe;
        X !== void 0 && (ee = X.onUpdate, pe = X.tag, X.skipTransforms && (d = !0), ee && c._deferred.push(ee), pe && c._updateTags.add(pe)), M();
      }
    }
    return d;
  }
  function Bu(c, i, a) {
    const d = c._updateTags;
    let v, M, X = !1, ee = !1;
    a !== void 0 && (v = a.onUpdate, M = a.tag, M != null && d.add(M), X = a.skipTransforms || !1, ee = a.discrete || !1), v && c._deferred.push(v);
    const pe = c._editorState;
    let Ce = c._pendingEditorState, Ee = !1;
    (Ce === null || Ce._readOnly) && (Ce = c._pendingEditorState = np(Ce || pe), Ee = !0), Ce._flushSync = ee;
    const ve = Xn, we = xr, ye = Zn, Ze = c._updating;
    Xn = Ce, xr = !1, c._updating = !0, Zn = c;
    try {
      Ee && (c._headless ? pe._selection !== null && (Ce._selection = pe._selection.clone()) : Ce._selection = Fh(c));
      const Xe = c._compositionKey;
      i(), X = Fu(c, X), Bh(Ce, c), c._dirtyType !== Oe && (X ? zh(Ce, c) : qh(Ce, c), Fu(c), qs(pe, Ce, c._dirtyLeaves, c._dirtyElements));
      const xt = c._compositionKey;
      Xe !== xt && (Ce._flushSync = !0);
      const et = Ce._selection;
      if (Kt(et)) {
        const mt = Ce._nodeMap, Qt = et.anchor.key, Yt = et.focus.key;
        if (mt.get(Qt) === void 0 || mt.get(Yt) === void 0)
          throw Error("updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.");
      } else
        rl(et) && et._nodes.size === 0 && (Ce._selection = null);
    } catch (Xe) {
      Xe instanceof Error && c._onError(Xe), c._pendingEditorState = pe, c._dirtyType = He, c._cloneNotNeeded.clear(), c._dirtyLeaves = /* @__PURE__ */ new Set(), c._dirtyElements.clear(), Mi(c);
      return;
    } finally {
      Xn = ve, xr = we, Zn = ye, c._updating = Ze, sa = 0;
    }
    c._dirtyType !== Oe || tp(Ce, c) ? Ce._flushSync ? (Ce._flushSync = !1, Mi(c)) : Ee && mo(() => {
      Mi(c);
    }) : (Ce._flushSync = !1, Ee && (d.clear(), c._deferred = [], c._pendingEditorState = null));
  }
  function Ar(c, i, a) {
    c._updating ? c._updates.push([i, a]) : Bu(c, i, a);
  }
  class Va extends oi {
    constructor(i) {
      super(i);
    }
    /**
     * The returned value is added to the LexicalEditor._decorators
     */
    decorate(i, a) {
      throw Error("decorate: base method not extended");
    }
    isIsolated() {
      return !1;
    }
    isInline() {
      return !0;
    }
    isKeyboardSelectable() {
      return !0;
    }
  }
  function Ln(c) {
    return c instanceof Va;
  }
  class la extends oi {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    constructor(i) {
      super(i), this.__first = null, this.__last = null, this.__size = 0, this.__format = 0, this.__indent = 0, this.__dir = null;
    }
    getFormat() {
      return this.getLatest().__format;
    }
    getFormatType() {
      const i = this.getFormat();
      return _e[i] || "";
    }
    getIndent() {
      return this.getLatest().__indent;
    }
    getChildren() {
      const i = [];
      let a = this.getFirstChild();
      for (; a !== null; )
        i.push(a), a = a.getNextSibling();
      return i;
    }
    getChildrenKeys() {
      const i = [];
      let a = this.getFirstChild();
      for (; a !== null; )
        i.push(a.__key), a = a.getNextSibling();
      return i;
    }
    getChildrenSize() {
      return this.getLatest().__size;
    }
    isEmpty() {
      return this.getChildrenSize() === 0;
    }
    isDirty() {
      const a = Tn()._dirtyElements;
      return a !== null && a.has(this.__key);
    }
    isLastChild() {
      const i = this.getLatest(), a = this.getParentOrThrow().getLastChild();
      return a !== null && a.is(i);
    }
    getAllTextNodes() {
      const i = [];
      let a = this.getFirstChild();
      for (; a !== null; ) {
        if (Ct(a) && i.push(a), ot(a)) {
          const d = a.getAllTextNodes();
          i.push(...d);
        }
        a = a.getNextSibling();
      }
      return i;
    }
    getFirstDescendant() {
      let i = this.getFirstChild();
      for (; i !== null; ) {
        if (ot(i)) {
          const a = i.getFirstChild();
          if (a !== null) {
            i = a;
            continue;
          }
        }
        break;
      }
      return i;
    }
    getLastDescendant() {
      let i = this.getLastChild();
      for (; i !== null; ) {
        if (ot(i)) {
          const a = i.getLastChild();
          if (a !== null) {
            i = a;
            continue;
          }
        }
        break;
      }
      return i;
    }
    getDescendantByIndex(i) {
      const a = this.getChildren(), d = a.length;
      if (i >= d) {
        const M = a[d - 1];
        return ot(M) && M.getLastDescendant() || M || null;
      }
      const v = a[i];
      return ot(v) && v.getFirstDescendant() || v || null;
    }
    getFirstChild() {
      const a = this.getLatest().__first;
      return a === null ? null : Bn(a);
    }
    getFirstChildOrThrow() {
      const i = this.getFirstChild();
      if (i === null)
        throw Error(`Expected node ${this.__key} to have a first child.`);
      return i;
    }
    getLastChild() {
      const a = this.getLatest().__last;
      return a === null ? null : Bn(a);
    }
    getLastChildOrThrow() {
      const i = this.getLastChild();
      if (i === null)
        throw Error(`Expected node ${this.__key} to have a last child.`);
      return i;
    }
    getChildAtIndex(i) {
      const a = this.getChildrenSize();
      let d, v;
      if (i < a / 2) {
        for (d = this.getFirstChild(), v = 0; d !== null && v <= i; ) {
          if (v === i)
            return d;
          d = d.getNextSibling(), v++;
        }
        return null;
      }
      for (d = this.getLastChild(), v = a - 1; d !== null && v >= i; ) {
        if (v === i)
          return d;
        d = d.getPreviousSibling(), v--;
      }
      return null;
    }
    getTextContent() {
      let i = "";
      const a = this.getChildren(), d = a.length;
      for (let v = 0; v < d; v++) {
        const M = a[v];
        i += M.getTextContent(), ot(M) && v !== d - 1 && !M.isInline() && (i += gt);
      }
      return i;
    }
    getTextContentSize() {
      let i = 0;
      const a = this.getChildren(), d = a.length;
      for (let v = 0; v < d; v++) {
        const M = a[v];
        i += M.getTextContentSize(), ot(M) && v !== d - 1 && !M.isInline() && (i += gt.length);
      }
      return i;
    }
    getDirection() {
      return this.getLatest().__dir;
    }
    hasFormat(i) {
      if (i !== "") {
        const a = qt[i];
        return (this.getFormat() & a) !== 0;
      }
      return !1;
    }
    // Mutators
    select(i, a) {
      ar();
      const d = Nn();
      let v = i, M = a;
      const X = this.getChildrenSize();
      if (!this.canBeEmpty()) {
        if (i === 0 && a === 0) {
          const pe = this.getFirstChild();
          if (Ct(pe) || ot(pe))
            return pe.select(0, 0);
        } else if ((i === void 0 || i === X) && (a === void 0 || a === X)) {
          const pe = this.getLastChild();
          if (Ct(pe) || ot(pe))
            return pe.select();
        }
      }
      v === void 0 && (v = X), M === void 0 && (M = X);
      const ee = this.__key;
      if (Kt(d))
        d.anchor.set(ee, v, "element"), d.focus.set(ee, M, "element"), d.dirty = !0;
      else
        return Mu(ee, v, ee, M, "element", "element");
      return d;
    }
    selectStart() {
      const i = this.getFirstDescendant();
      return i ? i.selectStart() : this.select();
    }
    selectEnd() {
      const i = this.getLastDescendant();
      return i ? i.selectEnd() : this.select();
    }
    clear() {
      const i = this.getWritable();
      return this.getChildren().forEach((d) => d.remove()), i;
    }
    append(...i) {
      return this.splice(this.getChildrenSize(), 0, i);
    }
    setDirection(i) {
      const a = this.getWritable();
      return a.__dir = i, a;
    }
    setFormat(i) {
      const a = this.getWritable();
      return a.__format = i !== "" ? qt[i] : 0, this;
    }
    setIndent(i) {
      const a = this.getWritable();
      return a.__indent = i, this;
    }
    splice(i, a, d) {
      const v = d.length, M = this.getChildrenSize(), X = this.getWritable(), ee = X.__key, pe = [], Ce = [], Ee = this.getChildAtIndex(i + a);
      let ve = null, we = M - a + v;
      if (i !== 0)
        if (i === M)
          ve = this.getLastChild();
        else {
          const Ze = this.getChildAtIndex(i);
          Ze !== null && (ve = Ze.getPreviousSibling());
        }
      if (a > 0) {
        let Ze = ve === null ? this.getFirstChild() : ve.getNextSibling();
        for (let Je = 0; Je < a; Je++) {
          if (Ze === null)
            throw Error("splice: sibling not found");
          const Xe = Ze.getNextSibling(), xt = Ze.__key, et = Ze.getWritable();
          Ir(et), Ce.push(xt), Ze = Xe;
        }
      }
      let ye = ve;
      for (let Ze = 0; Ze < v; Ze++) {
        const Je = d[Ze];
        ye !== null && Je.is(ye) && (ve = ye = ye.getPreviousSibling());
        const Xe = Je.getWritable();
        Xe.__parent === ee && we--, Ir(Xe);
        const xt = Je.__key;
        if (ye === null)
          X.__first = xt, Xe.__prev = null;
        else {
          const et = ye.getWritable();
          et.__next = xt, Xe.__prev = et.__key;
        }
        if (Je.__key === ee)
          throw Error("append: attempting to append self");
        Xe.__parent = ee, pe.push(xt), ye = Je;
      }
      if (i + a === M) {
        if (ye !== null) {
          const Ze = ye.getWritable();
          Ze.__next = null, X.__last = ye.__key;
        }
      } else if (Ee !== null) {
        const Ze = Ee.getWritable();
        if (ye !== null) {
          const Je = ye.getWritable();
          Ze.__prev = ye.__key, Je.__next = Ee.__key;
        } else
          Ze.__prev = null;
      }
      if (X.__size = we, Ce.length) {
        const Ze = Nn();
        if (Kt(Ze)) {
          const Je = new Set(Ce), Xe = new Set(pe), {
            anchor: xt,
            focus: et
          } = Ze;
          Ku(xt, Je, Xe) && ia(xt, xt.getNode(), this, ve, Ee), Ku(et, Je, Xe) && ia(et, et.getNode(), this, ve, Ee), we === 0 && !this.canBeEmpty() && !Ur(this) && this.remove();
        }
      }
      return X;
    }
    // JSON serialization
    exportJSON() {
      return {
        children: [],
        direction: this.getDirection(),
        format: this.getFormatType(),
        indent: this.getIndent(),
        type: "element",
        version: 1
      };
    }
    // These are intended to be extends for specific element heuristics.
    insertNewAfter(i, a) {
      return null;
    }
    canIndent() {
      return !0;
    }
    /*
     * This method controls the behavior of a the node during backwards
     * deletion (i.e., backspace) when selection is at the beginning of
     * the node (offset 0)
     */
    collapseAtStart(i) {
      return !1;
    }
    excludeFromCopy(i) {
      return !1;
    }
    // TODO 0.10 deprecate
    canExtractContents() {
      return !0;
    }
    canReplaceWith(i) {
      return !0;
    }
    canInsertAfter(i) {
      return !0;
    }
    canBeEmpty() {
      return !0;
    }
    canInsertTextBefore() {
      return !0;
    }
    canInsertTextAfter() {
      return !0;
    }
    isInline() {
      return !1;
    }
    // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the
    // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)
    // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode
    // will return the immediate first child underneath TableCellNode instead of RootNode.
    isShadowRoot() {
      return !1;
    }
    canMergeWith(i) {
      return !1;
    }
    extractWithChild(i, a, d) {
      return !1;
    }
  }
  function ot(c) {
    return c instanceof la;
  }
  function Ku(c, i, a) {
    let d = c.getNode();
    for (; d; ) {
      const v = d.__key;
      if (i.has(v) && !a.has(v))
        return !0;
      d = d.getParent();
    }
    return !1;
  }
  class _s extends la {
    /** @internal */
    static getType() {
      return "root";
    }
    static clone() {
      return new _s();
    }
    constructor() {
      super("root"), this.__cachedText = null;
    }
    getTopLevelElementOrThrow() {
      throw Error("getTopLevelElementOrThrow: root nodes are not top level elements");
    }
    getTextContent() {
      const i = this.__cachedText;
      return (ms() || Tn()._dirtyType === Oe) && i !== null ? i : super.getTextContent();
    }
    remove() {
      throw Error("remove: cannot be called on root nodes");
    }
    replace(i) {
      throw Error("replace: cannot be called on root nodes");
    }
    insertBefore(i) {
      throw Error("insertBefore: cannot be called on root nodes");
    }
    insertAfter(i) {
      throw Error("insertAfter: cannot be called on root nodes");
    }
    // View
    updateDOM(i, a) {
      return !1;
    }
    // Mutate
    append(...i) {
      for (let a = 0; a < i.length; a++) {
        const d = i[a];
        if (!ot(d) && !Ln(d))
          throw Error("rootNode.append: Only element or decorator nodes can be appended to the root node");
      }
      return super.append(...i);
    }
    static importJSON(i) {
      const a = lr();
      return a.setFormat(i.format), a.setIndent(i.indent), a.setDirection(i.direction), a;
    }
    exportJSON() {
      return {
        children: [],
        direction: this.getDirection(),
        format: this.getFormatType(),
        indent: this.getIndent(),
        type: "root",
        version: 1
      };
    }
    collapseAtStart() {
      return !0;
    }
  }
  function ep() {
    return new _s();
  }
  function Dr(c) {
    return c instanceof _s;
  }
  function tp(c, i) {
    const a = i.getEditorState()._selection, d = c._selection;
    if (d !== null) {
      if (d.dirty || !d.is(a))
        return !0;
    } else if (a !== null)
      return !0;
    return !1;
  }
  function np(c) {
    return new aa(new Map(c._nodeMap));
  }
  function Ja() {
    return new aa(/* @__PURE__ */ new Map([["root", ep()]]));
  }
  function ju(c) {
    const i = c.exportJSON(), a = c.constructor;
    if (i.type !== a.getType())
      throw Error(`LexicalNode: Node ${a.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);
    if (ot(c)) {
      const d = i.children;
      if (!Array.isArray(d))
        throw Error(`LexicalNode: Node ${a.name} is an element but .exportJSON() does not have a children array.`);
      const v = c.getChildren();
      for (let M = 0; M < v.length; M++) {
        const X = v[M], ee = ju(X);
        d.push(ee);
      }
    }
    return i;
  }
  class aa {
    constructor(i, a) {
      this._nodeMap = i, this._selection = a || null, this._flushSync = !1, this._readOnly = !1;
    }
    isEmpty() {
      return this._nodeMap.size === 1 && this._selection === null;
    }
    read(i) {
      return $u(this, i);
    }
    clone(i) {
      const a = new aa(this._nodeMap, i === void 0 ? this._selection : i);
      return a._readOnly = !0, a;
    }
    toJSON() {
      return $u(this, () => ({
        root: ju(lr())
      }));
    }
  }
  class Ns extends la {
    static getType() {
      return "paragraph";
    }
    static clone(i) {
      return new Ns(i.__key);
    }
    // View
    createDOM(i) {
      const a = document.createElement("p"), d = Eo(i.theme, "paragraph");
      return d !== void 0 && a.classList.add(...d), a;
    }
    updateDOM(i, a, d) {
      return !1;
    }
    static importDOM() {
      return {
        p: (i) => ({
          conversion: rp,
          priority: 0
        })
      };
    }
    exportDOM(i) {
      const {
        element: a
      } = super.exportDOM(i);
      if (a && Ti(a)) {
        this.isEmpty() && a.append(document.createElement("br"));
        const d = this.getFormatType();
        a.style.textAlign = d;
        const v = this.getDirection();
        v && (a.dir = v);
        const M = this.getIndent();
        M > 0 && (a.style.textIndent = `${M * 20}px`);
      }
      return {
        element: a
      };
    }
    static importJSON(i) {
      const a = Ao();
      return a.setFormat(i.format), a.setIndent(i.indent), a.setDirection(i.direction), a;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "paragraph",
        version: 1
      };
    }
    // Mutation
    insertNewAfter(i, a) {
      const d = Ao(), v = this.getDirection();
      return d.setDirection(v), this.insertAfter(d, a), d;
    }
    collapseAtStart() {
      const i = this.getChildren();
      if (i.length === 0 || Ct(i[0]) && i[0].getTextContent().trim() === "") {
        if (this.getNextSibling() !== null)
          return this.selectNext(), this.remove(), !0;
        if (this.getPreviousSibling() !== null)
          return this.selectPrevious(), this.remove(), !0;
      }
      return !1;
    }
  }
  function rp(c) {
    const i = Ao();
    if (c.style) {
      i.setFormat(c.style.textAlign);
      const a = parseInt(c.style.textIndent, 10) / 20;
      a > 0 && i.setIndent(a);
    }
    return {
      node: i
    };
  }
  function Ao() {
    return _r(new Ns());
  }
  function op(c) {
    return c instanceof Ns;
  }
  const ip = 0, sp = 1, lp = 2, ap = 3, cp = 4;
  function Hu(c, i, a, d) {
    const v = c._keyToDOMMap;
    v.clear(), c._editorState = Ja(), c._pendingEditorState = d, c._compositionKey = null, c._dirtyType = Oe, c._cloneNotNeeded.clear(), c._dirtyLeaves = /* @__PURE__ */ new Set(), c._dirtyElements.clear(), c._normalizedNodes = /* @__PURE__ */ new Set(), c._updateTags = /* @__PURE__ */ new Set(), c._updates = [], c._blockCursorElement = null;
    const M = c._observer;
    M !== null && (M.disconnect(), c._observer = null), i !== null && (i.textContent = ""), a !== null && (a.textContent = "", v.set("root", a));
  }
  function up(c, i) {
    const a = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Set(), v = (M) => {
      Object.keys(M).forEach((X) => {
        let ee = a.get(X);
        ee === void 0 && (ee = [], a.set(X, ee)), ee.push(M[X]);
      });
    };
    return c.forEach((M) => {
      const X = M.klass.importDOM != null ? M.klass.importDOM.bind(M.klass) : null;
      if (X == null || d.has(X))
        return;
      d.add(X);
      const ee = X();
      ee !== null && v(ee);
    }), i && v(i), a;
  }
  function dp(c) {
    const i = c || {}, a = Yh(), d = i.theme || {}, v = c === void 0 ? a : i.parentEditor || null, M = i.disableEvents || !1, X = Ja(), ee = i.namespace || (v !== null ? v._config.namespace : qi()), pe = i.editorState, Ce = [_s, jr, Ro, Yn, Ns, ...i.nodes || []], {
      onError: Ee,
      html: ve
    } = i, we = i.editable !== void 0 ? i.editable : !0;
    let ye;
    if (c === void 0 && a !== null)
      ye = a._nodes;
    else {
      ye = /* @__PURE__ */ new Map();
      for (let Je = 0; Je < Ce.length; Je++) {
        let Xe = Ce[Je], xt = null, et = null;
        if (typeof Xe != "function") {
          const bt = Xe;
          Xe = bt.replace, xt = bt.with, et = bt.withKlass || null;
        }
        {
          const bt = Xe.name;
          if (bt !== "RootNode") {
            const rn = Xe.prototype;
            ["getType", "clone"].forEach((Kn) => {
              Xe.hasOwnProperty(Kn) || console.warn(`${bt} must implement static "${Kn}" method`);
            }), // eslint-disable-next-line no-prototype-builtins
            !Xe.hasOwnProperty("importDOM") && // eslint-disable-next-line no-prototype-builtins
            Xe.hasOwnProperty("exportDOM") && console.warn(`${bt} should implement "importDOM" if using a custom "exportDOM" method to ensure HTML serialization (important for copy & paste) works as expected`), rn instanceof Va && (rn.hasOwnProperty("decorate") || console.warn(`${rn.constructor.name} must implement "decorate" method`)), Xe.hasOwnProperty("importJSON") || console.warn(`${bt} should implement "importJSON" method to ensure JSON and default HTML serialization works as expected`), rn.hasOwnProperty("exportJSON") || console.warn(`${bt} should implement "exportJSON" method to ensure JSON and default HTML serialization works as expected`);
          }
        }
        const mt = Xe.getType(), Qt = Xe.transform(), Yt = /* @__PURE__ */ new Set();
        Qt !== null && Yt.add(Qt), ye.set(mt, {
          exportDOM: ve && ve.export ? ve.export.get(Xe) : void 0,
          klass: Xe,
          replace: xt,
          replaceWithKlass: et,
          transforms: Yt
        });
      }
    }
    const Ze = new fp(X, v, ye, {
      disableEvents: M,
      namespace: ee,
      theme: d
    }, Ee || console.error, up(ye, ve ? ve.import : void 0), we);
    return pe !== void 0 && (Ze._pendingEditorState = pe, Ze._dirtyType = He), Ze;
  }
  class fp {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    constructor(i, a, d, v, M, X, ee) {
      this._parentEditor = a, this._rootElement = null, this._editorState = i, this._pendingEditorState = null, this._compositionKey = null, this._deferred = [], this._keyToDOMMap = /* @__PURE__ */ new Map(), this._updates = [], this._updating = !1, this._listeners = {
        decorator: /* @__PURE__ */ new Set(),
        editable: /* @__PURE__ */ new Set(),
        mutation: /* @__PURE__ */ new Map(),
        root: /* @__PURE__ */ new Set(),
        textcontent: /* @__PURE__ */ new Set(),
        update: /* @__PURE__ */ new Set()
      }, this._commands = /* @__PURE__ */ new Map(), this._config = v, this._nodes = d, this._decorators = {}, this._pendingDecorators = null, this._dirtyType = Oe, this._cloneNotNeeded = /* @__PURE__ */ new Set(), this._dirtyLeaves = /* @__PURE__ */ new Set(), this._dirtyElements = /* @__PURE__ */ new Map(), this._normalizedNodes = /* @__PURE__ */ new Set(), this._updateTags = /* @__PURE__ */ new Set(), this._observer = null, this._key = qi(), this._onError = M, this._htmlConversions = X, this._editable = ee, this._headless = a !== null && a._headless, this._window = null, this._blockCursorElement = null;
    }
    /**
     *
     * @returns true if the editor is currently in "composition" mode due to receiving input
     * through an IME, or 3P extension, for example. Returns false otherwise.
     */
    isComposing() {
      return this._compositionKey != null;
    }
    /**
     * Registers a listener for Editor update event. Will trigger the provided callback
     * each time the editor goes through an update (via {@link LexicalEditor.update}) until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerUpdateListener(i) {
      const a = this._listeners.update;
      return a.add(i), () => {
        a.delete(i);
      };
    }
    /**
     * Registers a listener for for when the editor changes between editable and non-editable states.
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerEditableListener(i) {
      const a = this._listeners.editable;
      return a.add(i), () => {
        a.delete(i);
      };
    }
    /**
     * Registers a listener for when the editor's decorator object changes. The decorator object contains
     * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.
     *
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerDecoratorListener(i) {
      const a = this._listeners.decorator;
      return a.add(i), () => {
        a.delete(i);
      };
    }
    /**
     * Registers a listener for when Lexical commits an update to the DOM and the text content of
     * the editor changes from the previous state of the editor. If the text content is the
     * same between updates, no notifications to the listeners will happen.
     *
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerTextContentListener(i) {
      const a = this._listeners.textcontent;
      return a.add(i), () => {
        a.delete(i);
      };
    }
    /**
     * Registers a listener for when the editor's root DOM element (the content editable
     * Lexical attaches to) changes. This is primarily used to attach event listeners to the root
     *  element. The root listener function is executed directly upon registration and then on
     * any subsequent update.
     *
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerRootListener(i) {
      const a = this._listeners.root;
      return i(this._rootElement, null), a.add(i), () => {
        i(null, this._rootElement), a.delete(i);
      };
    }
    /**
     * Registers a listener that will trigger anytime the provided command
     * is dispatched, subject to priority. Listeners that run at a higher priority can "intercept"
     * commands and prevent them from propagating to other handlers by returning true.
     *
     * Listeners registered at the same priority level will run deterministically in the order of registration.
     *
     * @param command - the command that will trigger the callback.
     * @param listener - the function that will execute when the command is dispatched.
     * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerCommand(i, a, d) {
      if (d === void 0)
        throw Error('Listener for type "command" requires a "priority".');
      const v = this._commands;
      v.has(i) || v.set(i, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
      const M = v.get(i);
      if (M === void 0)
        throw Error(`registerCommand: Command ${String(i)} not found in command map`);
      const X = M[d];
      return X.add(a), () => {
        X.delete(a), M.every((ee) => ee.size === 0) && v.delete(i);
      };
    }
    /**
     * Registers a listener that will run when a Lexical node of the provided class is
     * mutated. The listener will receive a list of nodes along with the type of mutation
     * that was performed on each: created, destroyed, or updated.
     *
     * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.
     * {@link LexicalEditor.getElementByKey} can be used for this.
     *
     * @param klass - The class of the node that you want to listen to mutations on.
     * @param listener - The logic you want to run when the node is mutated.
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerMutationListener(i, a) {
      if (this._nodes.get(i.getType()) === void 0)
        throw Error(`Node ${i.name} has not been registered. Ensure node has been passed to createEditor.`);
      const v = this._listeners.mutation;
      return v.set(a, i), () => {
        v.delete(a);
      };
    }
    /** @internal */
    registerNodeTransformToKlass(i, a) {
      const d = i.getType(), v = this._nodes.get(d);
      if (v === void 0)
        throw Error(`Node ${i.name} has not been registered. Ensure node has been passed to createEditor.`);
      return v.transforms.add(a), v;
    }
    /**
     * Registers a listener that will run when a Lexical node of the provided class is
     * marked dirty during an update. The listener will continue to run as long as the node
     * is marked dirty. There are no guarantees around the order of transform execution!
     *
     * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)
     * @param klass - The class of the node that you want to run transforms on.
     * @param listener - The logic you want to run when the node is updated.
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerNodeTransform(i, a) {
      const d = this.registerNodeTransformToKlass(i, a), v = [d], M = d.replaceWithKlass;
      if (M != null) {
        const X = this.registerNodeTransformToKlass(M, a);
        v.push(X);
      }
      return vl(this, i.getType()), () => {
        v.forEach((X) => X.transforms.delete(a));
      };
    }
    /**
     * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they
     * depend on have been registered.
     * @returns True if the editor has registered the provided node type, false otherwise.
     */
    hasNode(i) {
      return this._nodes.has(i.getType());
    }
    /**
     * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they
     * depend on have been registered.
     * @returns True if the editor has registered all of the provided node types, false otherwise.
     */
    hasNodes(i) {
      return i.every(this.hasNode.bind(this));
    }
    /**
     * Dispatches a command of the specified type with the specified payload.
     * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})
     * for this type, passing them the provided payload.
     * @param type - the type of command listeners to trigger.
     * @param payload - the data to pass as an argument to the command listeners.
     */
    dispatchCommand(i, a) {
      return _t(this, i, a);
    }
    /**
     * Gets a map of all decorators in the editor.
     * @returns A mapping of call decorator keys to their decorated content
     */
    getDecorators() {
      return this._decorators;
    }
    /**
     *
     * @returns the current root element of the editor. If you want to register
     * an event listener, do it via {@link LexicalEditor.registerRootListener}, since
     * this reference may not be stable.
     */
    getRootElement() {
      return this._rootElement;
    }
    /**
     * Gets the key of the editor
     * @returns The editor key
     */
    getKey() {
      return this._key;
    }
    /**
     * Imperatively set the root contenteditable element that Lexical listens
     * for events on.
     */
    setRootElement(i) {
      const a = this._rootElement;
      if (i !== a) {
        const d = Eo(this._config.theme, "root"), v = this._pendingEditorState || this._editorState;
        if (this._rootElement = i, Hu(this, a, i, v), a !== null && (this._config.disableEvents || us(a), d != null && a.classList.remove(...d)), i !== null) {
          const M = Kl(i), X = i.style;
          X.userSelect = "text", X.whiteSpace = "pre-wrap", X.wordBreak = "break-word", i.setAttribute("data-lexical-editor", "true"), this._window = M, this._dirtyType = He, jo(this), this._updateTags.add("history-merge"), Mi(this), this._config.disableEvents || Jl(i, this), d != null && i.classList.add(...d);
        } else
          this._editorState = v, this._pendingEditorState = null, this._window = null;
        ol("root", this, !1, i, a);
      }
    }
    /**
     * Gets the underlying HTMLElement associated with the LexicalNode for the given key.
     * @returns the HTMLElement rendered by the LexicalNode associated with the key.
     * @param key - the key of the LexicalNode.
     */
    getElementByKey(i) {
      return this._keyToDOMMap.get(i) || null;
    }
    /**
     * Gets the active editor state.
     * @returns The editor state
     */
    getEditorState() {
      return this._editorState;
    }
    /**
     * Imperatively set the EditorState. Triggers reconciliation like an update.
     * @param editorState - the state to set the editor
     * @param options - options for the update.
     */
    setEditorState(i, a) {
      if (i.isEmpty())
        throw Error("setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.");
      Fn(this);
      const d = this._pendingEditorState, v = this._updateTags, M = a !== void 0 ? a.tag : null;
      d !== null && !d.isEmpty() && (M != null && v.add(M), Mi(this)), this._pendingEditorState = i, this._dirtyType = He, this._dirtyElements.set("root", !1), this._compositionKey = null, M != null && v.add(M), Mi(this);
    }
    /**
     * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns
     * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,
     * deserliazation from JSON stored in a database uses this method.
     * @param maybeStringifiedEditorState
     * @param updateFn
     * @returns
     */
    parseEditorState(i, a) {
      const d = typeof i == "string" ? JSON.parse(i) : i;
      return Vh(d, this, a);
    }
    /**
     * Executes an update to the editor state. The updateFn callback is the ONLY place
     * where Lexical editor state can be safely mutated.
     * @param updateFn - A function that has access to writable editor state.
     * @param options - A bag of options to control the behavior of the update.
     * @param options.onUpdate - A function to run once the update is complete.
     * Useful for synchronizing updates in some cases.
     * @param options.skipTransforms - Setting this to true will suppress all node
     * transforms for this update cycle.
     * @param options.tag - A tag to identify this update, in an update listener, for instance.
     * Some tags are reserved by the core and control update behavior in different ways.
     * @param options.discrete - If true, prevents this update from being batched, forcing it to
     * run synchronously.
     */
    update(i, a) {
      Ar(this, i, a);
    }
    /**
     * Focuses the editor
     * @param callbackFn - A function to run after the editor is focused.
     * @param options - A bag of options
     * @param options.defaultSelection - Where to move selection when the editor is
     * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.
     */
    focus(i, a = {}) {
      const d = this._rootElement;
      d !== null && (d.setAttribute("autocapitalize", "off"), Ar(this, () => {
        const v = Nn(), M = lr();
        v !== null ? v.dirty = !0 : M.getChildrenSize() !== 0 && (a.defaultSelection === "rootStart" ? M.selectStart() : M.selectEnd());
      }, {
        onUpdate: () => {
          d.removeAttribute("autocapitalize"), i && i();
        },
        tag: "focus"
      }), this._pendingEditorState === null && d.removeAttribute("autocapitalize"));
    }
    /**
     * Removes focus from the editor.
     */
    blur() {
      const i = this._rootElement;
      i !== null && i.blur();
      const a = Nr(this._window);
      a !== null && a.removeAllRanges();
    }
    /**
     * Returns true if the editor is editable, false otherwise.
     * @returns True if the editor is editable, false otherwise.
     */
    isEditable() {
      return this._editable;
    }
    /**
     * Sets the editable property of the editor. When false, the
     * editor will not listen for user events on the underling contenteditable.
     * @param editable - the value to set the editable mode to.
     */
    setEditable(i) {
      this._editable !== i && (this._editable = i, ol("editable", this, !0, i));
    }
    /**
     * Returns a JSON-serializable javascript object NOT a JSON string.
     * You still must call JSON.stringify (or something else) to turn the
     * state into a string you can transfer over the wire and store in a database.
     *
     * See {@link LexicalNode.exportJSON}
     *
     * @returns A JSON-serializable javascript object
     */
    toJSON() {
      return {
        editorState: this._editorState.toJSON()
      };
    }
  }
  return ze.$addUpdateTag = Et, ze.$applyNodeReplacement = _r, ze.$copyNode = Ys, ze.$createLineBreakNode = qr, ze.$createNodeSelection = Ua, ze.$createParagraphNode = Ao, ze.$createPoint = zn, ze.$createRangeSelection = Ph, ze.$createTabNode = or, ze.$createTextNode = hn, ze.$getAdjacentNode = Ws, ze.$getCharacterOffsets = Wa, ze.$getEditor = Ul, ze.$getNearestNodeFromDOMNode = eo, ze.$getNearestRootOrShadowRoot = ts, ze.$getNodeByKey = Bn, ze.$getPreviousSelection = ps, ze.$getRoot = lr, ze.$getSelection = Nn, ze.$getTextContent = Hh, ze.$hasAncestor = yo, ze.$hasUpdateTag = Hn, ze.$insertNodes = jh, ze.$isBlockElementNode = kh, ze.$isDecoratorNode = Ln, ze.$isElementNode = ot, ze.$isInlineElementOrDecoratorNode = Rr, ze.$isLeafNode = Ol, ze.$isLineBreakNode = io, ze.$isNodeSelection = rl, ze.$isParagraphNode = op, ze.$isRangeSelection = Kt, ze.$isRootNode = Dr, ze.$isRootOrShadowRoot = Ur, ze.$isTabNode = hr, ze.$isTextNode = Ct, ze.$nodesOfType = To, ze.$normalizeSelection__EXPERIMENTAL = Lr, ze.$parseSerializedNode = Gh, ze.$selectAll = Hs, ze.$setCompositionKey = pn, ze.$setSelection = mr, ze.$splitNode = Hl, ze.BLUR_COMMAND = De, ze.CAN_REDO_COMMAND = ae, ze.CAN_UNDO_COMMAND = de, ze.CLEAR_EDITOR_COMMAND = j, ze.CLEAR_HISTORY_COMMAND = Q, ze.CLICK_COMMAND = o, ze.COMMAND_PRIORITY_CRITICAL = cp, ze.COMMAND_PRIORITY_EDITOR = ip, ze.COMMAND_PRIORITY_HIGH = ap, ze.COMMAND_PRIORITY_LOW = sp, ze.COMMAND_PRIORITY_NORMAL = lp, ze.CONTROLLED_TEXT_INSERTION_COMMAND = f, ze.COPY_COMMAND = q, ze.CUT_COMMAND = Y, ze.DELETE_CHARACTER_COMMAND = u, ze.DELETE_LINE_COMMAND = R, ze.DELETE_WORD_COMMAND = E, ze.DRAGEND_COMMAND = ie, ze.DRAGOVER_COMMAND = z, ze.DRAGSTART_COMMAND = A, ze.DROP_COMMAND = te, ze.DecoratorNode = Va, ze.ElementNode = la, ze.FOCUS_COMMAND = Ne, ze.FORMAT_ELEMENT_COMMAND = K, ze.FORMAT_TEXT_COMMAND = y, ze.INDENT_CONTENT_COMMAND = oe, ze.INSERT_LINE_BREAK_COMMAND = p, ze.INSERT_PARAGRAPH_COMMAND = m, ze.INSERT_TAB_COMMAND = Z, ze.KEY_ARROW_DOWN_COMMAND = I, ze.KEY_ARROW_LEFT_COMMAND = D, ze.KEY_ARROW_RIGHT_COMMAND = w, ze.KEY_ARROW_UP_COMMAND = x, ze.KEY_BACKSPACE_COMMAND = B, ze.KEY_DELETE_COMMAND = P, ze.KEY_DOWN_COMMAND = N, ze.KEY_ENTER_COMMAND = W, ze.KEY_ESCAPE_COMMAND = L, ze.KEY_MODIFIER_COMMAND = Pe, ze.KEY_SPACE_COMMAND = $, ze.KEY_TAB_COMMAND = F, ze.LineBreakNode = Ro, ze.MOVE_TO_END = T, ze.MOVE_TO_START = C, ze.OUTDENT_CONTENT_COMMAND = ne, ze.PASTE_COMMAND = O, ze.ParagraphNode = Ns, ze.REDO_COMMAND = _, ze.REMOVE_TEXT_COMMAND = S, ze.RootNode = _s, ze.SELECTION_CHANGE_COMMAND = n, ze.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = t, ze.SELECT_ALL_COMMAND = se, ze.TabNode = Yn, ze.TextNode = jr, ze.UNDO_COMMAND = g, ze.createCommand = r, ze.createEditor = dp, ze.getNearestEditorFromDOMNode = vn, ze.isCurrentlyReadOnlyMode = ms, ze.isHTMLAnchorElement = Wl, ze.isHTMLElement = Ti, ze.isSelectionCapturedInDecoratorInput = ji, ze.isSelectionWithinEditor = gi, ze;
}
var qe = {}, Vu;
function Ep() {
  if (Vu)
    return qe;
  Vu = 1;
  let r = {}, n = {}, t = {}, o = {}, u = {}, p = {}, m = {}, f = {}, O = {}, S = {}, E = {}, R = {}, y = {}, g = {}, _ = {}, N = {}, w = {}, T = {}, D = {}, C = {}, x = {}, I = {}, W = {}, $ = {}, B = {}, L = {}, P = {}, F = {}, Z = {}, oe = {}, ne = {}, te = {}, K = {}, A = {}, z = {}, ie = {};
  function q(l) {
    let e = new URLSearchParams();
    e.append("code", l);
    for (let s = 1; s < arguments.length; s++)
      e.append("v", arguments[s]);
    throw Error(`Minified Lexical error #${l}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  let Y = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", se = Y && "documentMode" in document ? document.documentMode : null, j = Y && /Mac|iPod|iPhone|iPad/.test(navigator.platform), Q = Y && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), ae = Y && "InputEvent" in window && !se ? "getTargetRanges" in new window.InputEvent("input") : !1, de = Y && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), Ne = Y && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, De = Y && /Android/.test(navigator.userAgent), Pe = Y && /^(?=.*Chrome).*/i.test(navigator.userAgent), Le = Y && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !Pe, ke = de || Ne || Le ? " " : "​", J = Q ? " " : ke, G = /^[^A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0800-\u1fff\u200e\u2c00-\ufb1c\ufe00-\ufe6f\ufefd-\uffff]*[\u0591-\u07ff\ufb1d-\ufdfd\ufe70-\ufefc]/, H = /^[^\u0591-\u07ff\ufb1d-\ufdfd\ufe70-\ufefc]*[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0800-\u1fff\u200e\u2c00-\ufb1c\ufe00-\ufe6f\ufefd-\uffff]/, re = { bold: 1, code: 16, highlight: 128, italic: 2, strikethrough: 4, subscript: 32, superscript: 64, underline: 8 }, le = { directionless: 1, unmergeable: 2 }, me = { center: 2, end: 6, justify: 4, left: 1, right: 3, start: 5 }, ge = { 2: "center", 6: "end", 4: "justify", 1: "left", 3: "right", 5: "start" }, Me = { normal: 0, segmented: 2, token: 1 }, Ie = { 0: "normal", 2: "segmented", 1: "token" }, je = !1, Oe = 0;
  function be(l) {
    Oe = l.timeStamp;
  }
  function He(l, e, s) {
    return e.__lexicalLineBreak === l || l[`__lexicalKey_${s._key}`] !== void 0;
  }
  function Ge(l) {
    return l.getEditorState().read(() => {
      let e = Bt();
      return e !== null ? e.clone() : null;
    });
  }
  function dt(l, e, s) {
    je = !0;
    let h = 100 < performance.now() - Oe;
    try {
      fr(l, () => {
        let b = Bt() || Ge(l);
        var k = /* @__PURE__ */ new Map(), V = l.getRootElement(), ce = l._editorState, xe = l._blockCursorElement;
        let Ae = !1, it = "";
        for (var st = 0; st < e.length; st++) {
          var Ve = e[st], Fe = Ve.type, pt = Ve.target, Lt = wt(pt, ce);
          if (!(Lt === null && pt !== V || xn(Lt))) {
            if (Fe === "characterData") {
              if (Ve = h && Et(Lt))
                e: {
                  Ve = b, Fe = pt;
                  var Ut = Lt;
                  if (Pt(Ve)) {
                    var Ft = Ve.anchor.getNode();
                    if (Ft.is(Ut) && Ve.format !== Ft.getFormat()) {
                      Ve = !1;
                      break e;
                    }
                  }
                  Ve = Fe.nodeType === 3 && Ut.isAttached();
                }
              Ve && (Ut = pr(l._window), Fe = Ve = null, Ut !== null && Ut.anchorNode === pt && (Ve = Ut.anchorOffset, Fe = Ut.focusOffset), pt = pt.nodeValue, pt !== null && Rt(Lt, pt, Ve, Fe, !1));
            } else if (Fe === "childList") {
              for (Ae = !0, Fe = Ve.addedNodes, Ut = 0; Ut < Fe.length; Ut++) {
                Ft = Fe[Ut];
                var En = gt(Ft), Un = Ft.parentNode;
                Un == null || Ft === xe || En !== null || Ft.nodeName === "BR" && He(Ft, Un, l) || (Q && (En = Ft.innerText || Ft.nodeValue) && (it += En), Un.removeChild(Ft));
              }
              if (Ve = Ve.removedNodes, Fe = Ve.length, 0 < Fe) {
                for (Ut = 0, Ft = 0; Ft < Fe; Ft++)
                  Un = Ve[Ft], (Un.nodeName === "BR" && He(Un, pt, l) || xe === Un) && (pt.appendChild(Un), Ut++);
                Fe !== Ut && (pt === V && (Lt = ce._nodeMap.get("root")), k.set(pt, Lt));
              }
            }
          }
        }
        if (0 < k.size)
          for (let [
            ri,
            Br
          ] of k)
            if (Qe(Br))
              for (k = Br.getChildrenKeys(), V = ri.firstChild, ce = 0; ce < k.length; ce++)
                xe = l.getElementByKey(k[ce]), xe !== null && (V == null ? (ri.appendChild(xe), V = xe) : V !== xe && ri.replaceChild(xe, V), V = V.nextSibling);
            else
              Et(Br) && Br.markDirty();
        if (k = s.takeRecords(), 0 < k.length) {
          for (V = 0; V < k.length; V++)
            for (xe = k[V], ce = xe.addedNodes, xe = xe.target, st = 0; st < ce.length; st++)
              Lt = ce[st], pt = Lt.parentNode, pt == null || Lt.nodeName !== "BR" || He(Lt, xe, l) || pt.removeChild(Lt);
          s.takeRecords();
        }
        b !== null && (Ae && (b.dirty = !0, en(b)), Q && cn(l) && b.insertRawText(it));
      });
    } finally {
      je = !1;
    }
  }
  function nt(l) {
    let e = l._observer;
    if (e !== null) {
      let s = e.takeRecords();
      dt(l, s, e);
    }
  }
  function At(l) {
    Oe === 0 && Fn(l).addEventListener("textInput", be, !0), l._observer = new MutationObserver((e, s) => {
      dt(l, e, s);
    });
  }
  function an(l, e) {
    let s = l.__mode, h = l.__format;
    l = l.__style;
    let b = e.__mode, k = e.__format;
    return e = e.__style, (s === null || s === b) && (h === null || h === k) && (l === null || l === e);
  }
  function Gt(l, e) {
    let s = l.mergeWithSibling(e), h = mn()._normalizedNodes;
    return h.add(l.__key), h.add(e.__key), s;
  }
  function Ot(l) {
    if (l.__text === "" && l.isSimpleText() && !l.isUnmergeable())
      l.remove();
    else {
      for (var e; (e = l.getPreviousSibling()) !== null && Et(e) && e.isSimpleText() && !e.isUnmergeable(); )
        if (e.__text === "")
          e.remove();
        else {
          an(e, l) && (l = Gt(e, l));
          break;
        }
      for (var s; (s = l.getNextSibling()) !== null && Et(s) && s.isSimpleText() && !s.isUnmergeable(); )
        if (s.__text === "")
          s.remove();
        else {
          an(l, s) && Gt(l, s);
          break;
        }
    }
  }
  function Te(l) {
    return ue(l.anchor), ue(l.focus), l;
  }
  function ue(l) {
    for (; l.type === "element"; ) {
      var e = l.getNode(), s = l.offset;
      if (s === e.getChildrenSize() ? (e = e.getChildAtIndex(s - 1), s = !0) : (e = e.getChildAtIndex(s), s = !1), Et(e)) {
        l.set(e.__key, s ? e.getTextContentSize() : 0, "text");
        break;
      } else if (!Qe(e))
        break;
      l.set(e.__key, s ? e.getChildrenSize() : 0, "element");
    }
  }
  let he = 1, Se = typeof queueMicrotask == "function" ? queueMicrotask : (l) => {
    Promise.resolve().then(l);
  };
  function $e(l) {
    let e = document.activeElement;
    if (e === null)
      return !1;
    let s = e.nodeName;
    return xn(wt(l)) && (s === "INPUT" || s === "TEXTAREA" || e.contentEditable === "true" && e.__lexicalEditor == null);
  }
  function Re(l, e, s) {
    let h = l.getRootElement();
    try {
      return h !== null && h.contains(e) && h.contains(s) && e !== null && !$e(e) && We(e) === l;
    } catch {
      return !1;
    }
  }
  function We(l) {
    for (; l != null; ) {
      let e = l.__lexicalEditor;
      if (e != null)
        return e;
      l = Qn(l);
    }
    return null;
  }
  function rt(l) {
    return l.isToken() || l.isSegmented();
  }
  function lt(l) {
    for (; l != null; ) {
      if (l.nodeType === 3)
        return l;
      l = l.firstChild;
    }
    return null;
  }
  function tt(l, e, s) {
    let h = re[e];
    return s !== null && (l & h) === (s & h) || (l ^= h, e === "subscript" ? l &= ~re.superscript : e === "superscript" && (l &= ~re.subscript)), l;
  }
  function Nt(l, e) {
    if (e != null)
      l.__key = e;
    else {
      Wn(), 99 < vo && q(14), e = mn();
      var s = Jn(), h = "" + he++;
      s._nodeMap.set(h, l), Qe(l) ? e._dirtyElements.set(h, !0) : e._dirtyLeaves.add(h), e._cloneNotNeeded.add(h), e._dirtyType = 1, l.__key = h;
    }
  }
  function Be(l) {
    var e = l.getParent();
    if (e !== null) {
      let b = l.getWritable();
      e = e.getWritable();
      var s = l.getPreviousSibling();
      if (l = l.getNextSibling(), s === null)
        if (l !== null) {
          var h = l.getWritable();
          e.__first = l.__key, h.__prev = null;
        } else
          e.__first = null;
      else {
        if (h = s.getWritable(), l !== null) {
          let k = l.getWritable();
          k.__prev = h.__key, h.__next = k.__key;
        } else
          h.__next = null;
        b.__prev = null;
      }
      l === null ? s !== null ? (l = s.getWritable(), e.__last = s.__key, l.__next = null) : e.__last = null : (l = l.getWritable(), s !== null ? (s = s.getWritable(), s.__next = l.__key, l.__prev = s.__key) : l.__prev = null, b.__next = null), e.__size--, b.__parent = null;
    }
  }
  function Ke(l) {
    99 < vo && q(14);
    var e = l.getLatest(), s = e.__parent, h = Jn();
    let b = mn(), k = h._nodeMap;
    if (h = b._dirtyElements, s !== null)
      e:
        for (; s !== null; ) {
          if (h.has(s))
            break e;
          let V = k.get(s);
          if (V === void 0)
            break;
          h.set(s, !1), s = V.__parent;
        }
    e = e.__key, b._dirtyType = 1, Qe(l) ? h.set(e, !0) : b._dirtyLeaves.add(e);
  }
  function Ye(l) {
    Wn();
    var e = mn();
    let s = e._compositionKey;
    l !== s && (e._compositionKey = l, s !== null && (e = ct(s), e !== null && e.getWritable()), l !== null && (l = ct(l), l !== null && l.getWritable()));
  }
  function ft() {
    return zr() ? null : mn()._compositionKey;
  }
  function ct(l, e) {
    return l = (e || Jn())._nodeMap.get(l), l === void 0 ? null : l;
  }
  function gt(l, e) {
    let s = mn();
    return l = l[`__lexicalKey_${s._key}`], l !== void 0 ? ct(l, e) : null;
  }
  function wt(l, e) {
    for (; l != null; ) {
      let s = gt(l, e);
      if (s !== null)
        return s;
      l = Qn(l);
    }
    return null;
  }
  function Mt(l) {
    let e = Object.assign({}, l._decorators);
    return l._pendingDecorators = e;
  }
  function It(l) {
    return l.read(() => Dt().getTextContent());
  }
  function on(l, e) {
    fr(l, () => {
      var s = Jn();
      if (!s.isEmpty())
        if (e === "root")
          Dt().markDirty();
        else {
          s = s._nodeMap;
          for (let [, h] of s)
            h.markDirty();
        }
    }, l._pendingEditorState === null ? { tag: "history-merge" } : void 0);
  }
  function Dt() {
    return Jn()._nodeMap.get("root");
  }
  function en(l) {
    Wn();
    let e = Jn();
    l !== null && (l.dirty = !0, l.setCachedNodes(null)), e._selection = l;
  }
  function jt(l) {
    var e = mn(), s;
    e: {
      for (s = l; s != null; ) {
        let h = s[`__lexicalKey_${e._key}`];
        if (h !== void 0) {
          s = h;
          break e;
        }
        s = Qn(s);
      }
      s = null;
    }
    return s === null ? (e = e.getRootElement(), l === e ? ct("root") : null) : ct(s);
  }
  function qt(l) {
    return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(l);
  }
  function _e(l) {
    let e = [];
    for (; l !== null; )
      e.push(l), l = l._parentEditor;
    return e;
  }
  function Ue() {
    return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
  }
  function at(l, e, s) {
    if (e = pr(e._window), e !== null) {
      var h = e.anchorNode, { anchorOffset: b, focusOffset: k } = e;
      if (h !== null && (e = h.nodeType === 3 ? h.nodeValue : null, h = wt(h), e !== null && Et(h))) {
        if (e === ke && s) {
          let V = s.length;
          e = s, k = b = V;
        }
        e !== null && Rt(h, e, b, k, l);
      }
    }
  }
  function Rt(l, e, s, h, b) {
    let k = l;
    if (k.isAttached() && (b || !k.isDirty())) {
      let Ae = k.isComposing(), it = e;
      if ((Ae || b) && e[e.length - 1] === ke && (it = e.slice(0, -1)), e = k.getTextContent(), b || it !== e)
        if (it === "")
          if (Ye(null), de || Ne || Le)
            k.remove();
          else {
            let st = mn();
            setTimeout(() => {
              st.update(() => {
                k.isAttached() && k.remove();
              });
            }, 20);
          }
        else {
          b = k.getParent(), e = Rn();
          var V = k.getTextContentSize(), ce = ft(), xe = k.getKey();
          k.isToken() || ce !== null && xe === ce && !Ae || Pt(e) && (b !== null && !b.canInsertTextBefore() && e.anchor.offset === 0 || e.anchor.key === l.__key && e.anchor.offset === 0 && !k.canInsertTextBefore() && !Ae || e.focus.key === l.__key && e.focus.offset === V && !k.canInsertTextAfter() && !Ae) ? k.markDirty() : (l = Bt(), Pt(l) && s !== null && h !== null && (l.setTextNodeRange(k, s, k, h), k.isSegmented() && (s = k.getTextContent(), s = Hn(s), k.replace(s), k = s)), k.setTextContent(it));
        }
    }
  }
  function Xt(l, e) {
    if (e.isSegmented())
      return !0;
    if (!l.isCollapsed())
      return !1;
    l = l.anchor.offset;
    let s = e.getParentOrThrow(), h = e.isToken();
    return l === 0 ? ((l = !e.canInsertTextBefore() || !s.canInsertTextBefore() || h) || (e = e.getPreviousSibling(), l = (Et(e) || Qe(e) && e.isInline()) && !e.canInsertTextAfter()), l) : l === e.getTextContentSize() ? !e.canInsertTextAfter() || !s.canInsertTextAfter() || h : !1;
  }
  function Zt(l, e) {
    l.__lexicalClassNameCache === void 0 && (l.__lexicalClassNameCache = {});
    let s = l.__lexicalClassNameCache, h = s[e];
    return h !== void 0 ? h : (l = l[e], typeof l == "string" ? (l = l.split(" "), s[e] = l) : l);
  }
  function Wt(l, e, s, h, b) {
    s.size !== 0 && (s = h.__type, h = h.__key, e = e.get(s), e === void 0 && q(33, s), s = e.klass, e = l.get(s), e === void 0 && (e = /* @__PURE__ */ new Map(), l.set(s, e)), l = e.get(h), s = l === "destroyed" && b === "created", (l === void 0 || s) && e.set(h, s ? "updated" : b));
  }
  function Ht(l, e, s) {
    let h = l.getParent(), b = s;
    return h !== null && (e && s === 0 ? (b = l.getIndexWithinParent(), l = h) : e || s !== l.getChildrenSize() || (b = l.getIndexWithinParent() + 1, l = h)), l.getChildAtIndex(e ? b - 1 : b);
  }
  function yn(l, e) {
    var s = l.offset;
    return l.type === "element" ? (l = l.getNode(), Ht(l, e, s)) : (l = l.getNode(), e && s === 0 || !e && s === l.getTextContentSize() ? (s = e ? l.getPreviousSibling() : l.getNextSibling(), s === null ? Ht(l.getParentOrThrow(), e, l.getIndexWithinParent() + (e ? 0 : 1)) : s) : null);
  }
  function cn(l) {
    return l = (l = Fn(l).event) && l.inputType, l === "insertFromPaste" || l === "insertFromPasteAsQuotation";
  }
  function un(l) {
    return !gr(l) && !l.isLastChild() && !l.isInline();
  }
  function On(l, e) {
    return l = l._keyToDOMMap.get(e), l === void 0 && q(75, e), l;
  }
  function Qn(l) {
    return l = l.assignedSlot || l.parentElement, l !== null && l.nodeType === 11 ? l.host : l;
  }
  function fn(l, e) {
    for (l = l.getParent(); l !== null; ) {
      if (l.is(e))
        return !0;
      l = l.getParent();
    }
    return !1;
  }
  function Fn(l) {
    return l = l._window, l === null && q(78), l;
  }
  function jo(l) {
    for (l = l.getParentOrThrow(); l !== null && !yr(l); )
      l = l.getParentOrThrow();
    return l;
  }
  function yr(l) {
    return gr(l) || Qe(l) && l.isShadowRoot();
  }
  function fi(l) {
    return l = l.constructor.clone(l), Nt(l, null), l;
  }
  function Wr(l) {
    var e = mn();
    let s = l.constructor.getType();
    return e = e._nodes.get(s), e === void 0 && q(97), e = e.replace, e !== null ? (e = e(l), e instanceof l.constructor || q(98), e) : l;
  }
  function Lr(l, e) {
    l = l.getParent(), !gr(l) || Qe(e) || xn(e) || q(99);
  }
  function Sr(l) {
    return (xn(l) || Qe(l) && !l.canBeEmpty()) && !l.isInline();
  }
  function Ho(l, e, s) {
    s.style.removeProperty("caret-color"), e._blockCursorElement = null, e = l.parentElement, e !== null && e.removeChild(l);
  }
  function pr(l) {
    return Y ? (l || window).getSelection() : null;
  }
  function Or(l) {
    return l.nodeType === 1;
  }
  function mo(l) {
    if (xn(l) && !l.isInline())
      return !0;
    if (!Qe(l) || yr(l))
      return !1;
    var e = l.getFirstChild();
    return e = e === null || Mr(e) || Et(e) || e.isInline(), !l.isInline() && l.canBeEmpty() !== !1 && e;
  }
  function ks(l, e) {
    for (; l !== null && l.getParent() !== null && !e(l); )
      l = l.getParentOrThrow();
    return e(l) ? l : null;
  }
  function ji(l, e, s, h, b, k) {
    for (l = l.getFirstChild(); l !== null; ) {
      let V = l.__key;
      l.__parent === e && (Qe(l) && ji(l, V, s, h, b, k), s.has(V) || k.delete(V), b.push(V)), l = l.getNextSibling();
    }
  }
  function gi(l, e, s, h) {
    l = l._nodeMap, e = e._nodeMap;
    let b = [];
    for (let [k] of h) {
      let V = e.get(k);
      V === void 0 || V.isAttached() || (Qe(V) && ji(V, k, l, e, b, h), l.has(k) || h.delete(k), b.push(k));
    }
    for (let k of b)
      e.delete(k);
    for (let k of s)
      h = e.get(k), h === void 0 || h.isAttached() || (l.has(k) || s.delete(k), e.delete(k));
  }
  let vn = "", er = "", vr = "", Qr, In, _o, Ol = !1, Hi = !1, Wi, Ir = null, Wo, Ps, pn, tr, Bn, Uo;
  function eo(l, e) {
    let s = pn.get(l);
    if (e !== null) {
      let h = Gi(l);
      h.parentNode === e && e.removeChild(h);
    }
    tr.has(l) || In._keyToDOMMap.delete(l), Qe(s) && (l = Yi(s, pn), Ui(l, 0, l.length - 1, null)), s !== void 0 && Wt(Uo, _o, Wi, s, "destroyed");
  }
  function Ui(l, e, s, h) {
    for (; e <= s; ++e) {
      let b = l[e];
      b !== void 0 && eo(b, h);
    }
  }
  function to(l, e) {
    l.setProperty("text-align", e);
  }
  function vl(l, e) {
    var s = Qr.theme.indent;
    if (typeof s == "string") {
      let h = l.classList.contains(s);
      0 < e && !h ? l.classList.add(s) : 1 > e && h && l.classList.remove(s);
    }
    s = getComputedStyle(l).getPropertyValue("--lexical-indent-base-value") || "40px", l.style.setProperty("padding-inline-start", e === 0 ? "" : `calc(${e} * ${s})`);
  }
  function lr(l, e) {
    l = l.style, e === 0 ? to(l, "") : e === 1 ? to(l, "left") : e === 2 ? to(l, "center") : e === 3 ? to(l, "right") : e === 4 ? to(l, "justify") : e === 5 ? to(l, "start") : e === 6 && to(l, "end");
  }
  function hi(l, e, s) {
    let h = tr.get(l);
    h === void 0 && q(60);
    let b = h.createDOM(Qr, In);
    var k = In._keyToDOMMap;
    if (b["__lexicalKey_" + In._key] = l, k.set(l, b), Et(h) ? b.setAttribute("data-lexical-text", "true") : xn(h) && b.setAttribute("data-lexical-decorator", "true"), Qe(h)) {
      if (l = h.__indent, k = h.__size, l !== 0 && vl(b, l), k !== 0) {
        --k, l = Yi(h, tr);
        var V = er;
        er = "", mr(l, h, 0, k, b, null), Fs(h, b), er = V;
      }
      l = h.__format, l !== 0 && lr(b, l), h.isInline() || No(null, h, b), un(h) && (vn += `

`, vr += `

`);
    } else
      k = h.getTextContent(), xn(h) ? (V = h.decorate(In, Qr), V !== null && zi(l, V), b.contentEditable = "false") : Et(h) && (h.isDirectionless() || (er += k)), vn += k, vr += k;
    return e !== null && (s != null ? e.insertBefore(b, s) : (s = e.__lexicalLineBreak, s != null ? e.insertBefore(b, s) : e.appendChild(b))), Wt(Uo, _o, Wi, h, "created"), b;
  }
  function mr(l, e, s, h, b, k) {
    let V = vn;
    for (vn = ""; s <= h; ++s)
      hi(l[s], b, k);
    un(e) && (vn += `

`), b.__lexicalTextContent = vn, vn = V + vn;
  }
  function wl(l, e) {
    return l = e.get(l), Mr(l) || xn(l) && l.isInline();
  }
  function No(l, e, s) {
    l = l !== null && (l.__size === 0 || wl(l.__last, pn)), e = e.__size === 0 || wl(e.__last, tr), l ? e || (e = s.__lexicalLineBreak, e != null && s.removeChild(e), s.__lexicalLineBreak = null) : e && (e = document.createElement("br"), s.__lexicalLineBreak = e, s.appendChild(e));
  }
  function Fs(l, e) {
    var s = e.__lexicalDir;
    if (e.__lexicalDirTextContent !== er || s !== Ir) {
      let k = er === "";
      if (k)
        var h = Ir;
      else
        h = er, h = G.test(h) ? "rtl" : H.test(h) ? "ltr" : null;
      if (h !== s) {
        let V = e.classList, ce = Qr.theme;
        var b = s !== null ? ce[s] : void 0;
        let xe = h !== null ? ce[h] : void 0;
        b !== void 0 && (typeof b == "string" && (b = b.split(" "), b = ce[s] = b), V.remove(...b)), h === null || k && h === "ltr" ? e.removeAttribute("dir") : (xe !== void 0 && (typeof xe == "string" && (s = xe.split(" "), xe = ce[h] = s), xe !== void 0 && V.add(...xe)), e.dir = h), Hi || (l.getWritable().__dir = h);
      }
      Ir = h, e.__lexicalDirTextContent = er, e.__lexicalDir = h;
    }
  }
  function Yi(l, e) {
    let s = [];
    for (l = l.__first; l !== null; ) {
      let h = e.get(l);
      h === void 0 && q(101), s.push(l), l = h.__next;
    }
    return s;
  }
  function Yo(l, e) {
    var s = pn.get(l), h = tr.get(l);
    s !== void 0 && h !== void 0 || q(61);
    var b = Ol || Ps.has(l) || Wo.has(l);
    let k = On(In, l);
    if (s === h && !b)
      return Qe(s) ? (h = k.__lexicalTextContent, h !== void 0 && (vn += h, vr += h), h = k.__lexicalDirTextContent, h !== void 0 && (er += h)) : (h = s.getTextContent(), Et(s) && !s.isDirectionless() && (er += h), vr += h, vn += h), k;
    if (s !== h && b && Wt(Uo, _o, Wi, h, "updated"), h.updateDOM(s, k, Qr))
      return h = hi(l, null, null), e === null && q(62), e.replaceChild(h, k), eo(l, null), h;
    if (Qe(s) && Qe(h)) {
      if (l = h.__indent, l !== s.__indent && vl(k, l), l = h.__format, l !== s.__format && lr(k, l), b) {
        l = er, er = "", b = vn;
        var V = s.__size, ce = h.__size;
        if (vn = "", V === 1 && ce === 1) {
          var xe = s.__first;
          if (e = h.__first, xe === e)
            Yo(xe, k);
          else {
            var Ae = Gi(xe);
            e = hi(e, null, null), k.replaceChild(e, Ae), eo(xe, null);
          }
        } else {
          e = Yi(s, pn);
          var it = Yi(h, tr);
          if (V === 0)
            ce !== 0 && mr(it, h, 0, ce - 1, k, null);
          else if (ce === 0)
            V !== 0 && (xe = k.__lexicalLineBreak == null, Ui(e, 0, V - 1, xe ? null : k), xe && (k.textContent = ""));
          else {
            var st = e;
            e = it, it = V - 1, V = ce - 1;
            let Fe = k.firstChild, pt = 0;
            for (ce = 0; pt <= it && ce <= V; ) {
              var Ve = st[pt];
              let Lt = e[ce];
              if (Ve === Lt)
                Fe = qi(Yo(Lt, k)), pt++, ce++;
              else {
                xe === void 0 && (xe = new Set(st)), Ae === void 0 && (Ae = new Set(e));
                let Ut = Ae.has(Ve), Ft = xe.has(Lt);
                Ut ? (Ft ? (Ve = On(In, Lt), Ve === Fe ? Fe = qi(Yo(Lt, k)) : (Fe != null ? k.insertBefore(Ve, Fe) : k.appendChild(Ve), Yo(Lt, k)), pt++) : hi(Lt, k, Fe), ce++) : (Fe = qi(Gi(Ve)), eo(Ve, k), pt++);
              }
            }
            xe = pt > it, Ae = ce > V, xe && !Ae ? (xe = e[V + 1], xe = xe === void 0 ? null : In.getElementByKey(xe), mr(e, h, ce, V, k, xe)) : Ae && !xe && Ui(st, pt, it, k);
          }
        }
        un(h) && (vn += `

`), k.__lexicalTextContent = vn, vn = b + vn, Fs(h, k), er = l, gr(h) || h.isInline() || No(s, h, k);
      }
      un(h) && (vn += `

`, vr += `

`);
    } else
      s = h.getTextContent(), xn(h) ? (b = h.decorate(In, Qr), b !== null && zi(l, b)) : Et(h) && !h.isDirectionless() && (er += s), vn += s, vr += s;
    return !Hi && gr(h) && h.__cachedText !== vr && (h.getWritable().__cachedText = vr), k;
  }
  function zi(l, e) {
    let s = In._pendingDecorators, h = In._decorators;
    if (s === null) {
      if (h[l] === e)
        return;
      s = Mt(In);
    }
    s[l] = e;
  }
  function qi(l) {
    return l = l.nextSibling, l !== null && l === In._blockCursorElement && (l = l.nextSibling), l;
  }
  function Gi(l) {
    let e = Bn.get(l);
    return e === void 0 && q(75, l), e;
  }
  let wr = Object.freeze({}), pi = [["keydown", Pa], ["pointerdown", Da], ["compositionstart", $l], ["compositionend", ka], ["input", $a], ["click", Aa], ["cut", wr], ["copy", wr], ["dragstart", wr], ["dragover", wr], ["dragend", wr], ["paste", wr], ["focus", wr], ["blur", wr], ["drop", wr]];
  ae && pi.push(["beforeinput", (l, e) => Ia(l, e)]);
  let mi = 0, Ml = 0, Rl = 0, zo = null, _i = 0, Bs = !1, Ks = !1, Ni = !1, Ci = !1, bl = [0, "", 0, "root", 0];
  function Al(l, e, s, h, b) {
    let k = l.anchor, V = l.focus, ce = k.getNode();
    var xe = mn();
    let Ae = pr(xe._window), it = Ae !== null ? Ae.anchorNode : null, st = k.key;
    xe = xe.getElementByKey(st);
    let Ve = s.length;
    return st !== V.key || !Et(ce) || (!b && (!ae || Rl < h + 50) || ce.isDirty() && 2 > Ve || qt(s)) && k.offset !== V.offset && !ce.isComposing() || rt(ce) || ce.isDirty() && 1 < Ve || (b || !ae) && xe !== null && !ce.isComposing() && it !== lt(xe) || Ae !== null && e !== null && (!e.collapsed || e.startContainer !== Ae.anchorNode || e.startOffset !== Ae.anchorOffset) || ce.getFormat() !== l.format || ce.getStyle() !== l.style || Xt(l, ce);
  }
  function Dl(l, e) {
    return l !== null && l.nodeValue !== null && l.nodeType === 3 && e !== 0 && e !== l.nodeValue.length;
  }
  function Ll(l, e, s) {
    let { anchorNode: h, anchorOffset: b, focusNode: k, focusOffset: V } = l;
    Bs && (Bs = !1, Dl(h, b) && Dl(k, V)) || fr(e, () => {
      if (!s)
        en(null);
      else if (Re(e, h, k)) {
        var ce = Bt();
        if (Pt(ce)) {
          var xe = ce.anchor, Ae = xe.getNode();
          if (ce.isCollapsed()) {
            l.type === "Range" && l.anchorNode === l.focusNode && (ce.dirty = !0);
            var it = Fn(e).event;
            it = it ? it.timeStamp : performance.now();
            let [Lt, Ut, Ft, En, Un] = bl;
            var st = Dt();
            st = e.isComposing() === !1 && st.getTextContent() === "", it < Un + 200 && xe.offset === Ft && xe.key === En ? (ce.format = Lt, ce.style = Ut) : xe.type === "text" ? (Et(Ae) || q(141), ce.format = Ae.getFormat(), ce.style = Ae.getStyle()) : xe.type !== "element" || st || (ce.format = 0, ce.style = "");
          } else {
            var Ve = xe.key, Fe = ce.focus.key;
            xe = ce.getNodes(), Ae = xe.length;
            var pt = ce.isBackward();
            it = pt ? V : b, st = pt ? b : V;
            let Lt = pt ? Fe : Ve;
            Ve = pt ? Ve : Fe, Fe = 255, pt = !1;
            for (let Ut = 0; Ut < Ae; Ut++) {
              let Ft = xe[Ut], En = Ft.getTextContentSize();
              if (Et(Ft) && En !== 0 && !(Ut === 0 && Ft.__key === Lt && it === En || Ut === Ae - 1 && Ft.__key === Ve && st === 0) && (pt = !0, Fe &= Ft.getFormat(), Fe === 0))
                break;
            }
            ce.format = pt ? Fe : 0;
          }
        }
        ht(e, r, void 0);
      }
    });
  }
  function Aa(l, e) {
    fr(e, () => {
      let s = Bt();
      var h = pr(e._window);
      let b = Rn();
      if (h)
        if (Pt(s)) {
          let V = s.anchor;
          var k = V.getNode();
          V.type === "element" && V.offset === 0 && s.isCollapsed() && !gr(k) && Dt().getChildrenSize() === 1 && k.getTopLevelElementOrThrow().isEmpty() && b !== null && s.is(b) ? (h.removeAllRanges(), s.dirty = !0) : l.detail !== 3 || s.isCollapsed() || (h = s.focus.getNode(), k !== h && (Qe(k) ? k.select(0) : k.getParentOrThrow().select(0)));
        } else
          l.pointerType === "touch" && (k = h.anchorNode, k !== null && (k = k.nodeType, k === 1 || k === 3)) && (h = qs(b, h, e, l), en(h));
      ht(e, n, l);
    });
  }
  function Da(l, e) {
    let s = l.target;
    l = l.pointerType, s instanceof Node && l !== "touch" && fr(e, () => {
      xn(wt(s)) || (Ks = !0);
    });
  }
  function Il(l) {
    return l.getTargetRanges ? (l = l.getTargetRanges(), l.length === 0 ? null : l[0]) : null;
  }
  function La(l, e) {
    return l !== e || Qe(l) || Qe(e) || !l.isToken() || !e.isToken();
  }
  function Ia(l, e) {
    let s = l.inputType, h = Il(l);
    s === "deleteCompositionText" || Q && cn(e) || s !== "insertCompositionText" && fr(e, () => {
      let b = Bt();
      if (s === "deleteContentBackward") {
        if (b === null) {
          var k = Rn();
          if (!Pt(k))
            return;
          en(k.clone());
        }
        if (Pt(b)) {
          De && Ye(b.anchor.key), Ml === 229 && l.timeStamp < mi + 30 && e.isComposing() && b.anchor.key === b.focus.key ? (Ye(null), mi = 0, setTimeout(() => {
            fr(e, () => {
              Ye(null);
            });
          }, 30), Pt(b) && (k = b.anchor.getNode(), k.markDirty(), b.format = k.getFormat(), Et(k) || q(142), b.style = k.getStyle()), 1 >= b.anchor.getNode().getTextContent().length && (l.preventDefault(), ht(e, t, !0))) : (Ye(null), l.preventDefault(), ht(e, t, !0));
          return;
        }
      }
      if (Pt(b)) {
        k = l.data, zo !== null && at(!1, e, zo), b.dirty && zo === null || !b.isCollapsed() || gr(b.anchor.getNode()) || h === null || b.applyDOMRange(h), zo = null;
        var V = b.focus, ce = b.anchor.getNode();
        if (V = V.getNode(), s === "insertText" || s === "insertTranspose")
          k === `
` ? (l.preventDefault(), ht(e, o, !1)) : k === `

` ? (l.preventDefault(), ht(e, u, void 0)) : k == null && l.dataTransfer ? (k = l.dataTransfer.getData("text/plain"), l.preventDefault(), b.insertRawText(k)) : k != null && Al(b, h, k, l.timeStamp, !0) ? (l.preventDefault(), ht(e, p, k)) : zo = k, Rl = l.timeStamp;
        else
          switch (l.preventDefault(), s) {
            case "insertFromYank":
            case "insertFromDrop":
            case "insertReplacementText":
              ht(e, p, l);
              break;
            case "insertFromComposition":
              Ye(null), ht(e, p, l);
              break;
            case "insertLineBreak":
              Ye(null), ht(e, o, !1);
              break;
            case "insertParagraph":
              Ye(null), Ni && !Ne ? (Ni = !1, ht(e, o, !1)) : ht(e, u, void 0);
              break;
            case "insertFromPaste":
            case "insertFromPasteAsQuotation":
              ht(e, m, l);
              break;
            case "deleteByComposition":
              La(ce, V) && ht(
                e,
                f,
                l
              );
              break;
            case "deleteByDrag":
            case "deleteByCut":
              ht(e, f, l);
              break;
            case "deleteContent":
              ht(e, t, !1);
              break;
            case "deleteWordBackward":
              ht(e, O, !0);
              break;
            case "deleteWordForward":
              ht(e, O, !1);
              break;
            case "deleteHardLineBackward":
            case "deleteSoftLineBackward":
              ht(e, S, !0);
              break;
            case "deleteContentForward":
            case "deleteHardLineForward":
            case "deleteSoftLineForward":
              ht(e, S, !1);
              break;
            case "formatStrikeThrough":
              ht(e, E, "strikethrough");
              break;
            case "formatBold":
              ht(e, E, "bold");
              break;
            case "formatItalic":
              ht(e, E, "italic");
              break;
            case "formatUnderline":
              ht(e, E, "underline");
              break;
            case "historyUndo":
              ht(e, R, void 0);
              break;
            case "historyRedo":
              ht(e, y, void 0);
          }
      }
    });
  }
  function $a(l, e) {
    l.stopPropagation(), fr(e, () => {
      var s = Bt(), h = l.data, b = Il(l);
      if (h != null && Pt(s) && Al(s, b, h, l.timeStamp, !1)) {
        Ci && (Vi(e, h), Ci = !1);
        var k = s.anchor, V = k.getNode();
        if (b = pr(e._window), b === null)
          return;
        let ce = k.offset;
        (k = ae && !s.isCollapsed() && Et(V) && b.anchorNode !== null) && (V = V.getTextContent().slice(0, ce) + h + V.getTextContent().slice(ce + s.focus.offset), b = b.anchorNode, k = V === (b.nodeType === 3 ? b.nodeValue : null)), k || ht(e, p, h), h = h.length, Q && 1 < h && l.inputType === "insertCompositionText" && !e.isComposing() && (s.anchor.offset -= h), de || Ne || Le || !e.isComposing() || (mi = 0, Ye(null));
      } else
        at(!1, e, h !== null ? h : void 0), Ci && (Vi(e, h || void 0), Ci = !1);
      Wn(), s = mn(), nt(s);
    }), zo = null;
  }
  function $l(l, e) {
    fr(e, () => {
      let s = Bt();
      if (Pt(s) && !e.isComposing()) {
        let h = s.anchor, b = s.anchor.getNode();
        Ye(h.key), (l.timeStamp < mi + 30 || h.type === "element" || !s.isCollapsed() || b.getFormat() !== s.format || Et(b) && b.getStyle() !== s.style) && ht(e, p, J);
      }
    });
  }
  function Vi(l, e) {
    var s = l._compositionKey;
    if (Ye(null), s !== null && e != null) {
      if (e === "") {
        e = ct(s), l = lt(l.getElementByKey(s)), l !== null && l.nodeValue !== null && Et(e) && Rt(e, l.nodeValue, null, null, !0);
        return;
      }
      if (e[e.length - 1] === `
` && (s = Bt(), Pt(s))) {
        e = s.focus, s.anchor.set(e.key, e.offset, e.type), ht(l, x, null);
        return;
      }
    }
    at(!0, l, e);
  }
  function ka(l, e) {
    Q ? Ci = !0 : fr(e, () => {
      Vi(e, l.data);
    });
  }
  function Pa(l, e) {
    if (mi = l.timeStamp, Ml = l.keyCode, !e.isComposing()) {
      var { keyCode: s, shiftKey: h, ctrlKey: b, metaKey: k, altKey: V } = l;
      if (!ht(e, g, l)) {
        if (s !== 39 || b || k || V)
          if (s !== 39 || V || h || !b && !k)
            if (s !== 37 || b || k || V)
              if (s !== 37 || V || h || !b && !k)
                if (s !== 38 || b || k)
                  if (s !== 40 || b || k)
                    if (s === 13 && h)
                      Ni = !0, ht(e, x, l);
                    else if (s === 32)
                      ht(e, I, l);
                    else if (j && b && s === 79)
                      l.preventDefault(), Ni = !0, ht(e, o, !0);
                    else if (s !== 13 || h) {
                      var ce = j ? V || k ? !1 : s === 8 || s === 72 && b : b || V || k ? !1 : s === 8;
                      ce ? s === 8 ? ht(e, W, l) : (l.preventDefault(), ht(e, t, !0)) : s === 27 ? ht(
                        e,
                        $,
                        l
                      ) : (ce = j ? h || V || k ? !1 : s === 46 || s === 68 && b : b || V || k ? !1 : s === 46, ce ? s === 46 ? ht(e, B, l) : (l.preventDefault(), ht(e, t, !1)) : s === 8 && (j ? V : b) ? (l.preventDefault(), ht(e, O, !0)) : s === 46 && (j ? V : b) ? (l.preventDefault(), ht(e, O, !1)) : j && k && s === 8 ? (l.preventDefault(), ht(e, S, !0)) : j && k && s === 46 ? (l.preventDefault(), ht(e, S, !1)) : s === 66 && !V && (j ? k : b) ? (l.preventDefault(), ht(e, E, "bold")) : s === 85 && !V && (j ? k : b) ? (l.preventDefault(), ht(e, E, "underline")) : s === 73 && !V && (j ? k : b) ? (l.preventDefault(), ht(e, E, "italic")) : s !== 9 || V || b || k ? s === 90 && !h && (j ? k : b) ? (l.preventDefault(), ht(e, R, void 0)) : (ce = j ? s === 90 && k && h : s === 89 && b || s === 90 && b && h, ce ? (l.preventDefault(), ht(e, y, void 0)) : So(e._editorState._selection) ? (ce = h ? !1 : s === 67 ? j ? k : b : !1, ce ? (l.preventDefault(), ht(e, ne, l)) : (ce = h ? !1 : s === 88 ? j ? k : b : !1, ce ? (l.preventDefault(), ht(e, te, l)) : s === 65 && (j ? k : b) && (l.preventDefault(), ht(e, K, l)))) : !Q && s === 65 && (j ? k : b) && (l.preventDefault(), ht(e, K, l))) : ht(e, L, l));
                    } else
                      Ni = !1, ht(e, x, l);
                  else
                    ht(e, C, l);
                else
                  ht(e, D, l);
              else
                ht(e, T, l);
            else
              ht(e, w, l);
          else
            ht(e, N, l);
        else
          ht(e, _, l);
        (b || h || V || k) && ht(e, ie, l);
      }
    }
  }
  function kl(l) {
    let e = l.__lexicalEventHandles;
    return e === void 0 && (e = [], l.__lexicalEventHandles = e), e;
  }
  let qo = /* @__PURE__ */ new Map();
  function Pl(l) {
    var e = l.target;
    let s = pr(e == null ? null : e.nodeType === 9 ? e.defaultView : e.ownerDocument.defaultView);
    if (s !== null) {
      var h = We(s.anchorNode);
      if (h !== null) {
        Ks && (Ks = !1, fr(h, () => {
          var ce = Rn(), xe = s.anchorNode;
          xe !== null && (xe = xe.nodeType, xe === 1 || xe === 3) && (ce = qs(ce, s, h, l), en(ce));
        })), e = _e(h), e = e[e.length - 1];
        var b = e._key, k = qo.get(b), V = k || e;
        V !== h && Ll(s, V, !1), Ll(s, h, !0), h !== e ? qo.set(b, h) : k && qo.delete(b);
      }
    }
  }
  function Fa(l, e) {
    _i === 0 && l.ownerDocument.addEventListener("selectionchange", Pl), _i++, l.__lexicalEditor = e;
    let s = kl(l);
    for (let h = 0; h < pi.length; h++) {
      let [b, k] = pi[h], V = typeof k == "function" ? (ce) => {
        ce._lexicalHandled !== !0 && (ce._lexicalHandled = !0, e.isEditable() && k(ce, e));
      } : (ce) => {
        if (ce._lexicalHandled !== !0 && (ce._lexicalHandled = !0, e.isEditable()))
          switch (b) {
            case "cut":
              return ht(e, te, ce);
            case "copy":
              return ht(e, ne, ce);
            case "paste":
              return ht(e, m, ce);
            case "dragstart":
              return ht(e, F, ce);
            case "dragover":
              return ht(e, Z, ce);
            case "dragend":
              return ht(
                e,
                oe,
                ce
              );
            case "focus":
              return ht(e, A, ce);
            case "blur":
              return ht(e, z, ce);
            case "drop":
              return ht(e, P, ce);
          }
      };
      l.addEventListener(b, V), s.push(() => {
        l.removeEventListener(b, V);
      });
    }
  }
  function js(l, e, s) {
    Wn();
    var h = l.__key;
    let b = l.getParent();
    if (b !== null) {
      var k = Bt();
      if (Pt(k) && Qe(l)) {
        var { anchor: V, focus: ce } = k, xe = V.getNode(), Ae = ce.getNode();
        fn(xe, l) && V.set(l.__key, 0, "element"), fn(Ae, l) && ce.set(l.__key, 0, "element");
      }
      if (xe = k, Ae = !1, Pt(xe) && e) {
        k = xe.anchor;
        let it = xe.focus;
        k.key === h && (ro(k, l, b, l.getPreviousSibling(), l.getNextSibling()), Ae = !0), it.key === h && (ro(it, l, b, l.getPreviousSibling(), l.getNextSibling()), Ae = !0);
      } else
        So(xe) && e && l.isSelected() && l.selectPrevious();
      Pt(xe) && e && !Ae ? (h = l.getIndexWithinParent(), Be(l), Cr(xe, b, h, -1)) : Be(l), s || yr(b) || b.canBeEmpty() || !b.isEmpty() || js(b, e), e && gr(b) && b.isEmpty() && b.selectEnd();
    }
  }
  class Ji {
    static getType() {
      q(64, this.name);
    }
    static clone() {
      q(65, this.name);
    }
    constructor(e) {
      this.__type = this.constructor.getType(), this.__next = this.__prev = this.__parent = null, Nt(this, e);
    }
    getType() {
      return this.__type;
    }
    isInline() {
      q(137, this.constructor.name);
    }
    isAttached() {
      for (var e = this.__key; e !== null; ) {
        if (e === "root")
          return !0;
        if (e = ct(e), e === null)
          break;
        e = e.__parent;
      }
      return !1;
    }
    isSelected(e) {
      if (e = e || Bt(), e == null)
        return !1;
      let s = e.getNodes().some((h) => h.__key === this.__key);
      return Et(this) ? s : Pt(e) && e.anchor.type === "element" && e.focus.type === "element" && e.anchor.key === e.focus.key && e.anchor.offset === e.focus.offset ? !1 : s;
    }
    getKey() {
      return this.__key;
    }
    getIndexWithinParent() {
      var e = this.getParent();
      if (e === null)
        return -1;
      e = e.getFirstChild();
      let s = 0;
      for (; e !== null; ) {
        if (this.is(e))
          return s;
        s++, e = e.getNextSibling();
      }
      return -1;
    }
    getParent() {
      let e = this.getLatest().__parent;
      return e === null ? null : ct(e);
    }
    getParentOrThrow() {
      let e = this.getParent();
      return e === null && q(66, this.__key), e;
    }
    getTopLevelElement() {
      let e = this;
      for (; e !== null; ) {
        let s = e.getParent();
        if (yr(s))
          return Qe(e) || q(138), e;
        e = s;
      }
      return null;
    }
    getTopLevelElementOrThrow() {
      let e = this.getTopLevelElement();
      return e === null && q(67, this.__key), e;
    }
    getParents() {
      let e = [], s = this.getParent();
      for (; s !== null; )
        e.push(s), s = s.getParent();
      return e;
    }
    getParentKeys() {
      let e = [], s = this.getParent();
      for (; s !== null; )
        e.push(s.__key), s = s.getParent();
      return e;
    }
    getPreviousSibling() {
      let e = this.getLatest().__prev;
      return e === null ? null : ct(e);
    }
    getPreviousSiblings() {
      let e = [];
      var s = this.getParent();
      if (s === null)
        return e;
      for (s = s.getFirstChild(); s !== null && !s.is(this); )
        e.push(s), s = s.getNextSibling();
      return e;
    }
    getNextSibling() {
      let e = this.getLatest().__next;
      return e === null ? null : ct(e);
    }
    getNextSiblings() {
      let e = [], s = this.getNextSibling();
      for (; s !== null; )
        e.push(s), s = s.getNextSibling();
      return e;
    }
    getCommonAncestor(e) {
      let s = this.getParents();
      var h = e.getParents();
      Qe(this) && s.unshift(this), Qe(e) && h.unshift(e), e = s.length;
      var b = h.length;
      if (e === 0 || b === 0 || s[e - 1] !== h[b - 1])
        return null;
      for (h = new Set(h), b = 0; b < e; b++) {
        let k = s[b];
        if (h.has(k))
          return k;
      }
      return null;
    }
    is(e) {
      return e == null ? !1 : this.__key === e.__key;
    }
    isBefore(e) {
      if (this === e)
        return !1;
      if (e.isParentOf(this))
        return !0;
      if (this.isParentOf(e))
        return !1;
      var s = this.getCommonAncestor(e);
      let h = this;
      for (; ; ) {
        var b = h.getParentOrThrow();
        if (b === s) {
          b = h.getIndexWithinParent();
          break;
        }
        h = b;
      }
      for (h = e; ; ) {
        if (e = h.getParentOrThrow(), e === s) {
          s = h.getIndexWithinParent();
          break;
        }
        h = e;
      }
      return b < s;
    }
    isParentOf(e) {
      let s = this.__key;
      if (s === e.__key)
        return !1;
      for (; e !== null; ) {
        if (e.__key === s)
          return !0;
        e = e.getParent();
      }
      return !1;
    }
    getNodesBetween(e) {
      let s = this.isBefore(e), h = [], b = /* @__PURE__ */ new Set();
      for (var k = this; ; ) {
        var V = k.__key;
        if (b.has(V) || (b.add(V), h.push(k)), k === e)
          break;
        if (V = Qe(k) ? s ? k.getFirstChild() : k.getLastChild() : null, V !== null)
          k = V;
        else if (V = s ? k.getNextSibling() : k.getPreviousSibling(), V !== null)
          k = V;
        else {
          if (k = k.getParentOrThrow(), b.has(k.__key) || h.push(k), k === e)
            break;
          V = k;
          do
            V === null && q(68), k = s ? V.getNextSibling() : V.getPreviousSibling(), V = V.getParent(), V !== null && (k !== null || b.has(V.__key) || h.push(V));
          while (k === null);
        }
      }
      return s || h.reverse(), h;
    }
    isDirty() {
      let e = mn()._dirtyLeaves;
      return e !== null && e.has(this.__key);
    }
    getLatest() {
      let e = ct(this.__key);
      return e === null && q(113), e;
    }
    getWritable() {
      Wn();
      var e = Jn(), s = mn();
      e = e._nodeMap;
      let h = this.__key, b = this.getLatest(), k = b.__parent;
      s = s._cloneNotNeeded;
      var V = Bt();
      return V !== null && V.setCachedNodes(null), s.has(h) ? (Ke(b), b) : (V = b.constructor.clone(b), V.__parent = k, V.__next = b.__next, V.__prev = b.__prev, Qe(b) && Qe(V) ? (V.__first = b.__first, V.__last = b.__last, V.__size = b.__size, V.__indent = b.__indent, V.__format = b.__format, V.__dir = b.__dir) : Et(b) && Et(V) && (V.__format = b.__format, V.__style = b.__style, V.__mode = b.__mode, V.__detail = b.__detail), s.add(h), V.__key = h, Ke(V), e.set(h, V), V);
    }
    getTextContent() {
      return "";
    }
    getTextContentSize() {
      return this.getTextContent().length;
    }
    createDOM() {
      q(70);
    }
    updateDOM() {
      q(71);
    }
    exportDOM(e) {
      return { element: this.createDOM(e._config, e) };
    }
    exportJSON() {
      q(72);
    }
    static importJSON() {
      q(18, this.name);
    }
    static transform() {
      return null;
    }
    remove(e) {
      js(this, !0, e);
    }
    replace(e, s) {
      Wn();
      var h = Bt();
      h !== null && (h = h.clone()), Lr(this, e);
      let b = this.getLatest(), k = this.__key, V = e.__key, ce = e.getWritable();
      e = this.getParentOrThrow().getWritable();
      let xe = e.__size;
      Be(ce);
      let Ae = b.getPreviousSibling(), it = b.getNextSibling(), st = b.__prev, Ve = b.__next, Fe = b.__parent;
      return js(b, !1, !0), Ae === null ? e.__first = V : Ae.getWritable().__next = V, ce.__prev = st, it === null ? e.__last = V : it.getWritable().__prev = V, ce.__next = Ve, ce.__parent = Fe, e.__size = xe, s && (Qe(this) && Qe(ce) || q(139), this.getChildren().forEach((pt) => {
        ce.append(pt);
      })), Pt(h) && (en(h), s = h.anchor, h = h.focus, s.key === k && Ur(s, ce), h.key === k && Ur(h, ce)), ft() === k && Ye(V), ce;
    }
    insertAfter(e, s = !0) {
      Wn(), Lr(this, e);
      var h = this.getWritable();
      let b = e.getWritable();
      var k = b.getParent();
      let V = Bt();
      var ce = !1, xe = !1;
      if (k !== null) {
        var Ae = e.getIndexWithinParent();
        Be(b), Pt(V) && (xe = k.__key, ce = V.anchor, k = V.focus, ce = ce.type === "element" && ce.key === xe && ce.offset === Ae + 1, xe = k.type === "element" && k.key === xe && k.offset === Ae + 1);
      }
      k = this.getNextSibling(), Ae = this.getParentOrThrow().getWritable();
      let it = b.__key, st = h.__next;
      return k === null ? Ae.__last = it : k.getWritable().__prev = it, Ae.__size++, h.__next = it, b.__next = st, b.__prev = h.__key, b.__parent = h.__parent, s && Pt(V) && (s = this.getIndexWithinParent(), Cr(V, Ae, s + 1), h = Ae.__key, ce && V.anchor.set(h, s + 2, "element"), xe && V.focus.set(h, s + 2, "element")), e;
    }
    insertBefore(e, s = !0) {
      Wn(), Lr(this, e);
      var h = this.getWritable();
      let b = e.getWritable(), k = b.__key;
      Be(b);
      let V = this.getPreviousSibling(), ce = this.getParentOrThrow().getWritable(), xe = h.__prev, Ae = this.getIndexWithinParent();
      return V === null ? ce.__first = k : V.getWritable().__next = k, ce.__size++, h.__prev = k, b.__prev = xe, b.__next = h.__key, b.__parent = h.__parent, h = Bt(), s && Pt(h) && (s = this.getParentOrThrow(), Cr(
        h,
        s,
        Ae
      )), e;
    }
    isParentRequired() {
      return !1;
    }
    createParentElementNode() {
      return Fr();
    }
    selectStart() {
      return this.selectPrevious();
    }
    selectEnd() {
      return this.selectNext(0, 0);
    }
    selectPrevious(e, s) {
      Wn();
      let h = this.getPreviousSibling(), b = this.getParentOrThrow();
      return h === null ? b.select(0, 0) : Qe(h) ? h.select() : Et(h) ? h.select(e, s) : (e = h.getIndexWithinParent() + 1, b.select(e, e));
    }
    selectNext(e, s) {
      Wn();
      let h = this.getNextSibling(), b = this.getParentOrThrow();
      return h === null ? b.select() : Qe(h) ? h.select(0, 0) : Et(h) ? h.select(e, s) : (e = h.getIndexWithinParent(), b.select(e, e));
    }
    markDirty() {
      this.getWritable();
    }
  }
  function Ba(l, e, s) {
    s = s || e.getParentOrThrow().getLastChild();
    let h = e;
    for (e = [e]; h !== s; )
      h.getNextSibling() || q(140), h = h.getNextSibling(), e.push(h);
    for (let b of e)
      l = l.insertAfter(b);
  }
  class Go extends Ji {
    static getType() {
      return "linebreak";
    }
    static clone(e) {
      return new Go(e.__key);
    }
    constructor(e) {
      super(e);
    }
    getTextContent() {
      return `
`;
    }
    createDOM() {
      return document.createElement("br");
    }
    updateDOM() {
      return !1;
    }
    static importDOM() {
      return { br: (e) => {
        e: {
          var s = e.parentElement;
          if (s !== null) {
            let h = s.firstChild;
            if ((h === e || h.nextSibling === e && Fl(h)) && (s = s.lastChild, s === e || s.previousSibling === e && Fl(s))) {
              e = !0;
              break e;
            }
          }
          e = !1;
        }
        return e ? null : { conversion: xi, priority: 0 };
      } };
    }
    static importJSON() {
      return Co();
    }
    exportJSON() {
      return {
        type: "linebreak",
        version: 1
      };
    }
  }
  function xi() {
    return { node: Co() };
  }
  function Co() {
    return Wr(new Go());
  }
  function Mr(l) {
    return l instanceof Go;
  }
  function Fl(l) {
    return l.nodeType === 3 && /^( |\t|\r?\n)+$/.test(l.textContent || "");
  }
  function xo(l, e) {
    return e & 16 ? "code" : e & 128 ? "mark" : e & 32 ? "sub" : e & 64 ? "sup" : null;
  }
  function Xi(l, e) {
    return e & 1 ? "strong" : e & 2 ? "em" : "span";
  }
  function Hs(l, e, s, h, b) {
    l = h.classList, h = Zt(b, "base"), h !== void 0 && l.add(...h), h = Zt(b, "underlineStrikethrough");
    let k = !1, V = e & 8 && e & 4;
    var ce = s & 8 && s & 4;
    h !== void 0 && (ce ? (k = !0, V || l.add(...h)) : V && l.remove(...h));
    for (let xe in re)
      ce = re[xe], h = Zt(b, xe), h !== void 0 && (s & ce ? !k || xe !== "underline" && xe !== "strikethrough" ? (!(e & ce) || V && xe === "underline" || xe === "strikethrough") && l.add(...h) : e & ce && l.remove(...h) : e & ce && l.remove(...h));
  }
  function Eo(l, e, s) {
    let h = e.firstChild;
    if (s = s.isComposing(), l += s ? ke : "", h == null)
      e.textContent = l;
    else if (e = h.nodeValue, e !== l)
      if (s || Q) {
        s = e.length;
        let b = l.length, k = 0, V = 0;
        for (; k < s && k < b && e[k] === l[k]; )
          k++;
        for (; V + k < s && V + k < b && e[s - V - 1] === l[b - V - 1]; )
          V++;
        l = [k, s - k - V, l.slice(k, b - V)];
        let [ce, xe, Ae] = l;
        xe !== 0 && h.deleteData(ce, xe), h.insertData(ce, Ae);
      } else
        h.nodeValue = l;
  }
  function Vo(l, e) {
    return e = document.createElement(e), e.appendChild(l), e;
  }
  class To extends Ji {
    static getType() {
      return "text";
    }
    static clone(e) {
      return new To(e.__text, e.__key);
    }
    constructor(e, s) {
      super(s), this.__text = e, this.__format = 0, this.__style = "", this.__detail = this.__mode = 0;
    }
    getFormat() {
      return this.getLatest().__format;
    }
    getDetail() {
      return this.getLatest().__detail;
    }
    getMode() {
      let e = this.getLatest();
      return Ie[e.__mode];
    }
    getStyle() {
      return this.getLatest().__style;
    }
    isToken() {
      return this.getLatest().__mode === 1;
    }
    isComposing() {
      return this.__key === ft();
    }
    isSegmented() {
      return this.getLatest().__mode === 2;
    }
    isDirectionless() {
      return (this.getLatest().__detail & 1) !== 0;
    }
    isUnmergeable() {
      return (this.getLatest().__detail & 2) !== 0;
    }
    hasFormat(e) {
      return e = re[e], (this.getFormat() & e) !== 0;
    }
    isSimpleText() {
      return this.__type === "text" && this.__mode === 0;
    }
    getTextContent() {
      return this.getLatest().__text;
    }
    getFormatFlags(e, s) {
      let h = this.getLatest().__format;
      return tt(h, e, s);
    }
    canHaveFormat() {
      return !0;
    }
    createDOM(e) {
      var s = this.__format, h = xo(this, s);
      let b = Xi(this, s), k = document.createElement(h === null ? b : h), V = k;
      return this.hasFormat("code") && k.setAttribute("spellcheck", "false"), h !== null && (V = document.createElement(b), k.appendChild(V)), h = V, Eo(this.__text, h, this), e = e.theme.text, e !== void 0 && Hs(b, 0, s, h, e), s = this.__style, s !== "" && (k.style.cssText = s), k;
    }
    updateDOM(e, s, h) {
      let b = this.__text;
      var k = e.__format, V = this.__format, ce = xo(this, k);
      let xe = xo(this, V);
      var Ae = Xi(this, k);
      let it = Xi(this, V);
      return (ce === null ? Ae : ce) !== (xe === null ? it : xe) ? !0 : ce === xe && Ae !== it ? (k = s.firstChild, k == null && q(48), e = ce = document.createElement(it), Eo(b, e, this), h = h.theme.text, h !== void 0 && Hs(it, 0, V, e, h), s.replaceChild(
        ce,
        k
      ), !1) : (Ae = s, xe !== null && ce !== null && (Ae = s.firstChild, Ae == null && q(49)), Eo(b, Ae, this), h = h.theme.text, h !== void 0 && k !== V && Hs(it, k, V, Ae, h), V = this.__style, e.__style !== V && (s.style.cssText = V), !1);
    }
    static importDOM() {
      return {
        "#text": () => ({ conversion: _t, priority: 0 }),
        b: () => ({ conversion: Ws, priority: 0 }),
        code: () => ({ conversion: no, priority: 0 }),
        em: () => ({ conversion: no, priority: 0 }),
        i: () => ({ conversion: no, priority: 0 }),
        s: () => ({ conversion: no, priority: 0 }),
        span: () => ({ conversion: Bl, priority: 0 }),
        strong: () => ({ conversion: no, priority: 0 }),
        sub: () => ({ conversion: no, priority: 0 }),
        sup: () => ({ conversion: no, priority: 0 }),
        u: () => ({ conversion: no, priority: 0 })
      };
    }
    static importJSON(e) {
      let s = Hn(e.text);
      return s.setFormat(e.format), s.setDetail(e.detail), s.setMode(e.mode), s.setStyle(e.style), s;
    }
    exportDOM(e) {
      return { element: e } = super.exportDOM(e), e !== null && Or(e) || q(132), e.style.whiteSpace = "pre-wrap", this.hasFormat("bold") && (e = Vo(e, "b")), this.hasFormat("italic") && (e = Vo(e, "i")), this.hasFormat("strikethrough") && (e = Vo(e, "s")), this.hasFormat("underline") && (e = Vo(e, "u")), { element: e };
    }
    exportJSON() {
      return { detail: this.getDetail(), format: this.getFormat(), mode: this.getMode(), style: this.getStyle(), text: this.getTextContent(), type: "text", version: 1 };
    }
    selectionTransform() {
    }
    setFormat(e) {
      let s = this.getWritable();
      return s.__format = typeof e == "string" ? re[e] : e, s;
    }
    setDetail(e) {
      let s = this.getWritable();
      return s.__detail = typeof e == "string" ? le[e] : e, s;
    }
    setStyle(e) {
      let s = this.getWritable();
      return s.__style = e, s;
    }
    toggleFormat(e) {
      let s = this.getFormat();
      return e = tt(s, e, null), this.setFormat(e);
    }
    toggleDirectionless() {
      let e = this.getWritable();
      return e.__detail ^= 1, e;
    }
    toggleUnmergeable() {
      let e = this.getWritable();
      return e.__detail ^= 2, e;
    }
    setMode(e) {
      if (e = Me[e], this.__mode === e)
        return this;
      let s = this.getWritable();
      return s.__mode = e, s;
    }
    setTextContent(e) {
      if (this.__text === e)
        return this;
      let s = this.getWritable();
      return s.__text = e, s;
    }
    select(e, s) {
      Wn();
      let h = Bt();
      var b = this.getTextContent();
      let k = this.__key;
      if (typeof b == "string" ? (b = b.length, e === void 0 && (e = b), s === void 0 && (s = b)) : s = e = 0, Pt(h))
        b = ft(), b !== h.anchor.key && b !== h.focus.key || Ye(k), h.setTextNodeRange(
          this,
          e,
          this,
          s
        );
      else
        return Ul(k, e, k, s, "text", "text");
      return h;
    }
    selectStart() {
      return this.select(0, 0);
    }
    selectEnd() {
      let e = this.getTextContentSize();
      return this.select(e, e);
    }
    spliceText(e, s, h, b) {
      let k = this.getWritable(), V = k.__text, ce = h.length, xe = e;
      0 > xe && (xe = ce + xe, 0 > xe && (xe = 0));
      let Ae = Bt();
      return b && Pt(Ae) && (e += ce, Ae.setTextNodeRange(k, e, k, e)), s = V.slice(0, xe) + h + V.slice(xe + s), k.__text = s, k;
    }
    canInsertTextBefore() {
      return !0;
    }
    canInsertTextAfter() {
      return !0;
    }
    splitText(...e) {
      Wn();
      var s = this.getLatest(), h = s.getTextContent(), b = s.__key, k = ft(), V = new Set(e);
      e = [];
      for (var ce = h.length, xe = "", Ae = 0; Ae < ce; Ae++)
        xe !== "" && V.has(Ae) && (e.push(xe), xe = ""), xe += h[Ae];
      if (xe !== "" && e.push(xe), V = e.length, V === 0)
        return [];
      if (e[0] === h)
        return [s];
      var it = e[0];
      h = s.getParentOrThrow(), Ae = s.getFormat();
      let st = s.getStyle(), Ve = s.__detail;
      ce = !1, s.isSegmented() ? (xe = Hn(it), xe.__format = Ae, xe.__style = st, xe.__detail = Ve, ce = !0) : (xe = s.getWritable(), xe.__text = it), s = Bt(), xe = [xe], it = it.length;
      for (let Lt = 1; Lt < V; Lt++) {
        var Fe = e[Lt], pt = Fe.length;
        Fe = Hn(Fe).getWritable(), Fe.__format = Ae, Fe.__style = st, Fe.__detail = Ve;
        let Ut = Fe.__key;
        if (pt = it + pt, Pt(s)) {
          let Ft = s.anchor, En = s.focus;
          Ft.key === b && Ft.type === "text" && Ft.offset > it && Ft.offset <= pt && (Ft.key = Ut, Ft.offset -= it, s.dirty = !0), En.key === b && En.type === "text" && En.offset > it && En.offset <= pt && (En.key = Ut, En.offset -= it, s.dirty = !0);
        }
        k === b && Ye(Ut), it = pt, xe.push(Fe);
      }
      return b = this.getPreviousSibling(), k = this.getNextSibling(), b !== null && Ke(b), k !== null && Ke(k), b = h.getWritable(), k = this.getIndexWithinParent(), ce ? (b.splice(k, 0, xe), this.remove()) : b.splice(k, 1, xe), Pt(s) && Cr(s, h, k, V - 1), xe;
    }
    mergeWithSibling(e) {
      var s = e === this.getPreviousSibling();
      s || e === this.getNextSibling() || q(50);
      var h = this.__key;
      let b = e.__key, k = this.__text, V = k.length;
      ft() === b && Ye(h);
      let ce = Bt();
      if (Pt(ce)) {
        let xe = ce.anchor, Ae = ce.focus;
        xe !== null && xe.key === b && (Gs(xe, s, h, e, V), ce.dirty = !0), Ae !== null && Ae.key === b && (Gs(Ae, s, h, e, V), ce.dirty = !0);
      }
      return h = e.__text, this.setTextContent(s ? h + k : k + h), s = this.getWritable(), e.remove(), s;
    }
    isTextEntity() {
      return !1;
    }
  }
  function Bl(l) {
    let e = l.style.fontWeight === "700", s = l.style.textDecoration === "line-through", h = l.style.fontStyle === "italic", b = l.style.textDecoration === "underline", k = l.style.verticalAlign;
    return { forChild: (V) => (Et(V) && (e && V.toggleFormat("bold"), s && V.toggleFormat("strikethrough"), h && V.toggleFormat("italic"), b && V.toggleFormat("underline"), k === "sub" && V.toggleFormat("subscript"), k === "super" && V.toggleFormat("superscript")), V), node: null };
  }
  function Ws(l) {
    let e = l.style.fontWeight === "normal";
    return { forChild: (s) => (Et(s) && !e && s.toggleFormat("bold"), s), node: null };
  }
  let Us = /* @__PURE__ */ new WeakMap();
  function _t(l) {
    l.parentElement === null && q(129);
    for (var e = l.textContent || "", s, h = l.parentNode, b = [l]; h !== null && (s = Us.get(h)) === void 0 && !(h.nodeName === "PRE" || h.nodeType === 1 && h.style !== void 0 && h.style.whiteSpace !== void 0 && h.style.whiteSpace.startsWith("pre")); )
      b.push(h), h = h.parentNode;
    for (s = s === void 0 ? h : s, h = 0; h < b.length; h++)
      Us.set(b[h], s);
    if (s !== null) {
      for (e = e.split(/(\r?\n|\t)/), l = [], b = e.length, s = 0; s < b; s++)
        h = e[s], h === `
` || h === `\r
` ? l.push(Co()) : h === "	" ? l.push(yo()) : h !== "" && l.push(Hn(h));
      return { node: l };
    }
    if (e = e.replace(/\r/g, "").replace(/[ \t\n]+/g, " "), e === "")
      return { node: null };
    if (e[0] === " ") {
      for (b = l, s = !0; b !== null && (b = Ei(b, !1)) !== null; )
        if (h = b.textContent || "", 0 < h.length) {
          /[ \t\n]$/.test(h) && (e = e.slice(1)), s = !1;
          break;
        }
      s && (e = e.slice(1));
    }
    if (e[e.length - 1] === " ") {
      for (b = !0; l !== null && (l = Ei(l, !0)) !== null; )
        if (0 < (l.textContent || "").replace(/^( |\t|\r?\n)+/, "").length) {
          b = !1;
          break;
        }
      b && (e = e.slice(0, e.length - 1));
    }
    return e === "" ? { node: null } : { node: Hn(e) };
  }
  let Zi = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, "i");
  function Ei(l, e) {
    for (; ; ) {
      for (var s = void 0; (s = e ? l.nextSibling : l.previousSibling) === null; )
        if (l = l.parentElement, l === null)
          return null;
      if (l = s, l.nodeType === 1 && (s = l.style.display, s === "" && l.nodeName.match(Zi) === null || s !== "" && !s.startsWith("inline")))
        return null;
      for (; (s = e ? l.firstChild : l.lastChild) !== null; )
        l = s;
      if (l.nodeType === 3)
        return l;
      if (l.nodeName === "BR")
        return null;
    }
  }
  let Qi = { code: "code", em: "italic", i: "italic", s: "strikethrough", strong: "bold", sub: "subscript", sup: "superscript", u: "underline" };
  function no(l) {
    let e = Qi[l.nodeName.toLowerCase()];
    return e === void 0 ? { node: null } : { forChild: (s) => (Et(s) && !s.hasFormat(e) && s.toggleFormat(e), s), node: null };
  }
  function Hn(l = "") {
    return Wr(new To(l));
  }
  function Et(l) {
    return l instanceof To;
  }
  class Jo extends To {
    static getType() {
      return "tab";
    }
    static clone(e) {
      let s = new Jo(e.__key);
      return s.__text = e.__text, s.__format = e.__format, s.__style = e.__style, s;
    }
    constructor(e) {
      super("	", e), this.__detail = 2;
    }
    static importDOM() {
      return null;
    }
    static importJSON(e) {
      let s = yo();
      return s.setFormat(e.format), s.setStyle(e.style), s;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "tab", version: 1 };
    }
    setTextContent() {
      q(126);
    }
    setDetail() {
      q(127);
    }
    setMode() {
      q(128);
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
  }
  function yo() {
    return Wr(new Jo());
  }
  function Kl(l) {
    return l instanceof Jo;
  }
  class es {
    constructor(e, s, h) {
      this._selection = null, this.key = e, this.offset = s, this.type = h;
    }
    is(e) {
      return this.key === e.key && this.offset === e.offset && this.type === e.type;
    }
    isBefore(e) {
      let s = this.getNode(), h = e.getNode(), b = this.offset;
      if (e = e.offset, Qe(s)) {
        var k = s.getDescendantByIndex(b);
        s = k ?? s;
      }
      return Qe(h) && (k = h.getDescendantByIndex(e), h = k ?? h), s === h ? b < e : s.isBefore(h);
    }
    getNode() {
      let e = ct(this.key);
      return e === null && q(20), e;
    }
    set(e, s, h) {
      let b = this._selection, k = this.key;
      this.key = e, this.offset = s, this.type = h, zr() || (ft() === k && Ye(e), b !== null && (b.setCachedNodes(null), b.dirty = !0));
    }
  }
  function Rr(l, e, s) {
    return new es(l, e, s);
  }
  function ts(l, e) {
    let s = e.__key, h = l.offset, b = "element";
    if (Et(e))
      b = "text", e = e.getTextContentSize(), h > e && (h = e);
    else if (!Qe(e)) {
      var k = e.getNextSibling();
      Et(k) ? (s = k.__key, h = 0, b = "text") : (k = e.getParent()) && (s = k.__key, h = e.getIndexWithinParent() + 1);
    }
    l.set(s, h, b);
  }
  function Ur(l, e) {
    if (Qe(e)) {
      let s = e.getLastDescendant();
      Qe(s) || Et(s) ? ts(l, s) : ts(l, e);
    } else
      ts(l, e);
  }
  function Ys(l, e, s, h) {
    let b = l.getNode(), k = b.getChildAtIndex(l.offset), V = Hn(), ce = gr(b) ? Fr().append(V) : V;
    V.setFormat(s), V.setStyle(h), k === null ? b.append(ce) : k.insertBefore(ce), l.is(e) && e.set(V.__key, 0, "text"), l.set(V.__key, 0, "text");
  }
  function _r(l, e, s, h) {
    l.key = e, l.offset = s, l.type = h;
  }
  class Xo {
    constructor(e) {
      this._cachedNodes = null, this._nodes = e, this.dirty = !1;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(e) {
      this._cachedNodes = e;
    }
    is(e) {
      if (!So(e))
        return !1;
      let s = this._nodes, h = e._nodes;
      return s.size === h.size && Array.from(s).every((b) => h.has(b));
    }
    isCollapsed() {
      return !1;
    }
    isBackward() {
      return !1;
    }
    getStartEndPoints() {
      return null;
    }
    add(e) {
      this.dirty = !0, this._nodes.add(e), this._cachedNodes = null;
    }
    delete(e) {
      this.dirty = !0, this._nodes.delete(e), this._cachedNodes = null;
    }
    clear() {
      this.dirty = !0, this._nodes.clear(), this._cachedNodes = null;
    }
    has(e) {
      return this._nodes.has(e);
    }
    clone() {
      return new Xo(new Set(this._nodes));
    }
    extract() {
      return this.getNodes();
    }
    insertRawText() {
    }
    insertText() {
    }
    insertNodes(e) {
      let s = this.getNodes(), h = s.length;
      var b = s[h - 1];
      if (Et(b))
        b = b.select();
      else {
        let k = b.getIndexWithinParent() + 1;
        b = b.getParentOrThrow().select(k, k);
      }
      for (b.insertNodes(e), e = 0; e < h; e++)
        s[e].remove();
    }
    getNodes() {
      var e = this._cachedNodes;
      if (e !== null)
        return e;
      var s = this._nodes;
      e = [];
      for (let h of s)
        s = ct(h), s !== null && e.push(s);
      return zr() || (this._cachedNodes = e), e;
    }
    getTextContent() {
      let e = this.getNodes(), s = "";
      for (let h = 0; h < e.length; h++)
        s += e[h].getTextContent();
      return s;
    }
  }
  function Pt(l) {
    return l instanceof $r;
  }
  class $r {
    constructor(e, s, h, b) {
      this.anchor = e, this.focus = s, e._selection = this, s._selection = this, this._cachedNodes = null, this.format = h, this.style = b, this.dirty = !1;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(e) {
      this._cachedNodes = e;
    }
    is(e) {
      return Pt(e) ? this.anchor.is(e.anchor) && this.focus.is(e.focus) && this.format === e.format && this.style === e.style : !1;
    }
    isCollapsed() {
      return this.anchor.is(this.focus);
    }
    getNodes() {
      var e = this._cachedNodes;
      if (e !== null)
        return e;
      e = this.anchor;
      var s = this.focus, h = e.isBefore(s), b = h ? e : s;
      h = h ? s : e, e = b.getNode(), s = h.getNode();
      let k = b.offset;
      return b = h.offset, Qe(e) && (h = e.getDescendantByIndex(k), e = h ?? e), Qe(s) && (h = s.getDescendantByIndex(b), h !== null && h !== e && s.getChildAtIndex(b) === h && (h = h.getPreviousSibling()), s = h ?? s), e = e.is(s) ? Qe(e) && 0 < e.getChildrenSize() ? [] : [e] : e.getNodesBetween(s), zr() || (this._cachedNodes = e), e;
    }
    setTextNodeRange(e, s, h, b) {
      _r(this.anchor, e.__key, s, "text"), _r(this.focus, h.__key, b, "text"), this._cachedNodes = null, this.dirty = !0;
    }
    getTextContent() {
      let e = this.getNodes();
      if (e.length === 0)
        return "";
      let s = e[0], h = e[e.length - 1], b = this.anchor, k = this.focus, V = b.isBefore(k), [ce, xe] = Nr(this), Ae = "", it = !0;
      for (let st = 0; st < e.length; st++) {
        let Ve = e[st];
        if (Qe(Ve) && !Ve.isInline())
          it || (Ae += `
`), it = !Ve.isEmpty();
        else if (it = !1, Et(Ve)) {
          let Fe = Ve.getTextContent();
          Ve === s ? Ve === h ? (b.type !== "element" || k.type !== "element" || k.offset === b.offset) && (Fe = ce < xe ? Fe.slice(ce, xe) : Fe.slice(xe, ce)) : Fe = V ? Fe.slice(ce) : Fe.slice(xe) : Ve === h && (Fe = V ? Fe.slice(0, xe) : Fe.slice(0, ce)), Ae += Fe;
        } else
          !xn(Ve) && !Mr(Ve) || Ve === h && this.isCollapsed() || (Ae += Ve.getTextContent());
      }
      return Ae;
    }
    applyDOMRange(e) {
      let s = mn(), h = s.getEditorState()._selection;
      if (e = ns(e.startContainer, e.startOffset, e.endContainer, e.endOffset, s, h), e !== null) {
        var [b, k] = e;
        _r(this.anchor, b.key, b.offset, b.type), _r(this.focus, k.key, k.offset, k.type), this._cachedNodes = null;
      }
    }
    clone() {
      let e = this.anchor, s = this.focus;
      return new $r(Rr(e.key, e.offset, e.type), Rr(s.key, s.offset, s.type), this.format, this.style);
    }
    toggleFormat(e) {
      this.format = tt(this.format, e, null), this.dirty = !0;
    }
    setStyle(e) {
      this.style = e, this.dirty = !0;
    }
    hasFormat(e) {
      return (this.format & re[e]) !== 0;
    }
    insertRawText(e) {
      e = e.split(/(\r?\n|\t)/);
      let s = [], h = e.length;
      for (let b = 0; b < h; b++) {
        let k = e[b];
        k === `
` || k === `\r
` ? s.push(Co()) : k === "	" ? s.push(yo()) : s.push(Hn(k));
      }
      this.insertNodes(s);
    }
    insertText(e) {
      var s = this.anchor, h = this.focus, b = this.isCollapsed() || s.isBefore(h), k = this.format, V = this.style;
      b && s.type === "element" ? Ys(s, h, k, V) : b || h.type !== "element" || Ys(h, s, k, V);
      var ce = this.getNodes(), xe = ce.length, Ae = b ? h : s;
      h = (b ? s : h).offset;
      var it = Ae.offset;
      s = ce[0], Et(s) || q(26), b = s.getTextContent().length;
      var st = s.getParentOrThrow(), Ve = ce[xe - 1];
      if (this.isCollapsed() && h === b && (s.isSegmented() || s.isToken() || !s.canInsertTextAfter() || !st.canInsertTextAfter() && s.getNextSibling() === null)) {
        var Fe = s.getNextSibling();
        if (Et(Fe) && Fe.canInsertTextBefore() && !rt(Fe) || (Fe = Hn(), Fe.setFormat(k), st.canInsertTextAfter() ? s.insertAfter(Fe) : st.insertAfter(Fe)), Fe.select(0, 0), s = Fe, e !== "") {
          this.insertText(e);
          return;
        }
      } else if (this.isCollapsed() && h === 0 && (s.isSegmented() || s.isToken() || !s.canInsertTextBefore() || !st.canInsertTextBefore() && s.getPreviousSibling() === null)) {
        if (Fe = s.getPreviousSibling(), (!Et(Fe) || rt(Fe)) && (Fe = Hn(), Fe.setFormat(k), st.canInsertTextBefore() ? s.insertBefore(Fe) : st.insertBefore(Fe)), Fe.select(), s = Fe, e !== "") {
          this.insertText(e);
          return;
        }
      } else if (s.isSegmented() && h !== b)
        st = Hn(s.getTextContent()), st.setFormat(k), s.replace(st), s = st;
      else if (!(this.isCollapsed() || e === "" || (Fe = Ve.getParent(), st.canInsertTextBefore() && st.canInsertTextAfter() && (!Qe(Fe) || Fe.canInsertTextBefore() && Fe.canInsertTextAfter())))) {
        this.insertText(""), Oo(this.anchor, this.focus, null), this.insertText(e);
        return;
      }
      if (xe === 1)
        if (s.isToken())
          e = Hn(e), e.select(), s.replace(e);
        else {
          if (ce = s.getFormat(), xe = s.getStyle(), h === it && (ce !== k || xe !== V))
            if (s.getTextContent() === "")
              s.setFormat(k), s.setStyle(V);
            else {
              ce = Hn(e), ce.setFormat(k), ce.setStyle(V), ce.select(), h === 0 ? s.insertBefore(ce, !1) : ([xe] = s.splitText(h), xe.insertAfter(ce, !1)), ce.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= e.length);
              return;
            }
          else if (Kl(s)) {
            e = Hn(e), e.setFormat(k), e.setStyle(V), e.select(), s.replace(e);
            return;
          }
          s = s.spliceText(h, it - h, e, !0), s.getTextContent() === "" ? s.remove() : this.anchor.type === "text" && (s.isComposing() ? this.anchor.offset -= e.length : (this.format = ce, this.style = xe));
        }
      else {
        if (k = /* @__PURE__ */ new Set([...s.getParentKeys(), ...Ve.getParentKeys()]), Fe = Qe(s) ? s : s.getParentOrThrow(), V = Qe(Ve) ? Ve : Ve.getParentOrThrow(), st = Ve, !Fe.is(V) && V.isInline())
          do
            st = V, V = V.getParentOrThrow();
          while (V.isInline());
        if (Ae.type === "text" && (it !== 0 || Ve.getTextContent() === "") || Ae.type === "element" && Ve.getIndexWithinParent() < it)
          if (Et(Ve) && !Ve.isToken() && it !== Ve.getTextContentSize()) {
            if (Ve.isSegmented()) {
              var pt = Hn(Ve.getTextContent());
              Ve.replace(pt), Ve = pt;
            }
            gr(Ae.getNode()) || Ae.type !== "text" || (Ve = Ve.spliceText(0, it, "")), k.add(Ve.__key);
          } else
            Ae = Ve.getParentOrThrow(), Ae.canBeEmpty() || Ae.getChildrenSize() !== 1 ? Ve.remove() : Ae.remove();
        else
          k.add(Ve.__key);
        for (Ae = V.getChildren(), it = new Set(ce), Ve = Fe.is(V), Fe = Fe.isInline() && s.getNextSibling() === null ? Fe : s, pt = Ae.length - 1; 0 <= pt; pt--) {
          let Lt = Ae[pt];
          if (Lt.is(s) || Qe(Lt) && Lt.isParentOf(s))
            break;
          Lt.isAttached() && (!it.has(Lt) || Lt.is(st) ? Ve || Fe.insertAfter(Lt, !1) : Lt.remove());
        }
        if (!Ve)
          for (Ae = V, V = null; Ae !== null; )
            it = Ae.getChildren(), Ve = it.length, (Ve === 0 || it[Ve - 1].is(V)) && (k.delete(Ae.__key), V = Ae), Ae = Ae.getParent();
        for (s.isToken() ? h === b ? s.select() : (e = Hn(e), e.select(), s.replace(e)) : (s = s.spliceText(h, b - h, e, !0), s.getTextContent() === "" ? s.remove() : s.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= e.length)), e = 1; e < xe; e++)
          s = ce[e], k.has(s.__key) || s.remove();
      }
    }
    removeText() {
      this.insertText("");
    }
    formatText(e) {
      if (this.isCollapsed())
        this.toggleFormat(e), Ye(null);
      else {
        var s = this.getNodes(), h = [];
        for (var b of s)
          Et(b) && h.push(b);
        var k = h.length;
        if (k === 0)
          this.toggleFormat(e), Ye(null);
        else {
          b = this.anchor;
          var V = this.focus, ce = this.isBackward();
          s = ce ? V : b, b = ce ? b : V;
          var xe = 0, Ae = h[0];
          if (V = s.type === "element" ? 0 : s.offset, s.type === "text" && V === Ae.getTextContentSize() && (xe = 1, Ae = h[1], V = 0), Ae != null) {
            ce = Ae.getFormatFlags(e, null);
            var it = k - 1, st = h[it];
            if (k = b.type === "text" ? b.offset : st.getTextContentSize(), Ae.is(st))
              V !== k && (V === 0 && k === Ae.getTextContentSize() ? Ae.setFormat(ce) : (e = Ae.splitText(V, k), e = V === 0 ? e[0] : e[1], e.setFormat(ce), s.type === "text" && s.set(e.__key, 0, "text"), b.type === "text" && b.set(e.__key, k - V, "text")), this.format = ce);
            else {
              V !== 0 && ([, Ae] = Ae.splitText(V), V = 0), Ae.setFormat(ce);
              var Ve = st.getFormatFlags(e, ce);
              for (0 < k && (k !== st.getTextContentSize() && ([st] = st.splitText(k)), st.setFormat(Ve)), xe += 1; xe < it; xe++) {
                let Fe = h[xe];
                if (!Fe.isToken()) {
                  let pt = Fe.getFormatFlags(e, Ve);
                  Fe.setFormat(pt);
                }
              }
              s.type === "text" && s.set(Ae.__key, V, "text"), b.type === "text" && b.set(st.__key, k, "text"), this.format = ce | Ve;
            }
          }
        }
      }
    }
    insertNodes(e) {
      if (e.length !== 0) {
        if (this.anchor.key === "root") {
          this.insertParagraph();
          var s = Bt();
          return Pt(s) || q(134), s.insertNodes(e);
        }
        s = this.isBackward() ? this.focus : this.anchor;
        var h = ks(s.getNode(), mo);
        if (s = e[e.length - 1], "__language" in h && Qe(h))
          if ("__language" in e[0])
            this.insertText(e[0].getTextContent());
          else {
            var b = yi(this);
            h.splice(b, 0, e), s.selectEnd();
          }
        else if (e.some((ce) => (Qe(ce) || xn(ce)) && !ce.isInline())) {
          s = os(e), e = s.getLastDescendant();
          var k = s.getChildren();
          s = Qe(h) && h.isEmpty() ? null : this.insertParagraph(), b = k[k.length - 1];
          var V = k[0];
          ((ce) => Qe(ce) && mo(ce) && !ce.isEmpty() && Qe(h) && (!h.isEmpty() || "__value" in h && "__checked" in h))(V) && (Qe(h) || q(135), h.append(...V.getChildren()), V = k[1]), V && Ba(h, V), k = ks(e, mo), s && Qe(k) && ("__value" in s && "__checked" in s || mo(b)) && (k.append(...s.getChildren()), s.remove()), Qe(h) && h.isEmpty() && h.remove(), e.selectEnd(), e = Qe(h) ? h.getLastChild() : null, Mr(e) && k !== h && e.remove();
        } else
          Qe(h) || q(135), b = yi(this), h.splice(b, 0, e), s.selectEnd();
      }
    }
    insertParagraph() {
      if (this.anchor.key === "root") {
        var e = Fr();
        return Dt().splice(this.anchor.offset, 0, [e]), e.select(), e;
      }
      var s = yi(this);
      return e = ks(this.anchor.getNode(), mo), Qe(e) || q(136), s = (s = e.getChildAtIndex(s)) ? [s, ...s.getNextSiblings()] : [], (e = e.insertNewAfter(this, !1)) ? (e.append(...s), e.selectStart(), e) : null;
    }
    insertLineBreak(e) {
      var s = Co();
      this.insertNodes([s]), e && (e = s.getParentOrThrow(), s = s.getIndexWithinParent(), e.select(s, s));
    }
    extract() {
      var e = this.getNodes(), s = e.length, h = s - 1, b = this.anchor;
      let k = this.focus;
      var V = e[0];
      let ce = e[h], [xe, Ae] = Nr(this);
      return s === 0 ? [] : s === 1 ? Et(V) && !this.isCollapsed() ? (e = xe > Ae ? Ae : xe, h = V.splitText(e, xe > Ae ? xe : Ae), e = e === 0 ? h[0] : h[1], e != null ? [e] : []) : [V] : (s = b.isBefore(k), Et(V) && (b = s ? xe : Ae, b === V.getTextContentSize() ? e.shift() : b !== 0 && ([, V] = V.splitText(b), e[0] = V)), Et(ce) && (V = ce.getTextContent().length, s = s ? Ae : xe, s === 0 ? e.pop() : s !== V && ([ce] = ce.splitText(s), e[h] = ce)), e);
    }
    modify(e, s, h) {
      var b = this.focus, k = this.anchor, V = e === "move", ce = yn(b, s);
      if (xn(ce) && !ce.isIsolated())
        V && ce.isKeyboardSelectable() ? (s = zs(), s.add(ce.__key), en(s)) : (e = s ? ce.getPreviousSibling() : ce.getNextSibling(), Et(e) ? (ce = e.__key, s = s ? e.getTextContent().length : 0, b.set(ce, s, "text"), V && k.set(ce, s, "text")) : (h = ce.getParentOrThrow(), Qe(e) ? (h = e.__key, ce = s ? e.getChildrenSize() : 0) : (ce = ce.getIndexWithinParent(), h = h.__key, s || ce++), b.set(h, ce, "element"), V && k.set(h, ce, "element")));
      else if (k = mn(), b = pr(k._window)) {
        var xe = k._blockCursorElement, Ae = k._rootElement;
        if (Ae === null || xe === null || !Qe(ce) || ce.isInline() || ce.canBeEmpty() || Ho(xe, k, Ae), b.modify(e, s ? "backward" : "forward", h), 0 < b.rangeCount && (ce = b.getRangeAt(0), k = this.anchor.getNode(), k = gr(k) ? k : jo(k), this.applyDOMRange(ce), this.dirty = !0, !V)) {
          for (V = this.getNodes(), e = [], h = !1, xe = 0; xe < V.length; xe++)
            Ae = V[xe], fn(Ae, k) ? e.push(Ae) : h = !0;
          h && 0 < e.length && (s ? (s = e[0], Qe(s) ? s.selectStart() : s.getParentOrThrow().selectStart()) : (s = e[e.length - 1], Qe(s) ? s.selectEnd() : s.getParentOrThrow().selectEnd())), (b.anchorNode !== ce.startContainer || b.anchorOffset !== ce.startOffset) && (s = this.focus, V = this.anchor, b = V.key, ce = V.offset, k = V.type, _r(V, s.key, s.offset, s.type), _r(s, b, ce, k), this._cachedNodes = null);
        }
      }
    }
    deleteCharacter(e) {
      let s = this.isCollapsed();
      if (this.isCollapsed()) {
        var h = this.anchor, b = this.focus, k = h.getNode();
        if (!e && (h.type === "element" && Qe(k) && h.offset === k.getChildrenSize() || h.type === "text" && h.offset === k.getTextContentSize())) {
          var V = k.getParent();
          if (V = k.getNextSibling() || (V === null ? null : V.getNextSibling()), Qe(V) && V.isShadowRoot())
            return;
        }
        if (V = yn(b, e), xn(V) && !V.isIsolated()) {
          V.isKeyboardSelectable() && Qe(k) && k.getChildrenSize() === 0 ? (k.remove(), e = zs(), e.add(V.__key), en(e)) : (V.remove(), mn().dispatchCommand(r, void 0));
          return;
        }
        if (!e && Qe(V) && Qe(k) && k.isEmpty()) {
          k.remove(), V.selectStart();
          return;
        }
        if (this.modify("extend", e, "character"), this.isCollapsed()) {
          if (e && h.offset === 0 && (h.type === "element" ? h.getNode() : h.getNode().getParentOrThrow()).collapseAtStart(this))
            return;
        } else {
          if (V = b.type === "text" ? b.getNode() : null, k = h.type === "text" ? h.getNode() : null, V !== null && V.isSegmented()) {
            if (h = b.offset, b = V.getTextContentSize(), V.is(k) || e && h !== b || !e && h !== 0) {
              Hl(V, e, h);
              return;
            }
          } else if (k !== null && k.isSegmented() && (h = h.offset, b = k.getTextContentSize(), k.is(V) || e && h !== 0 || !e && h !== b)) {
            Hl(k, e, h);
            return;
          }
          if (k = this.anchor, V = this.focus, h = k.getNode(), b = V.getNode(), h === b && k.type === "text" && V.type === "text") {
            var ce = k.offset, xe = V.offset;
            let Ae = ce < xe;
            b = Ae ? ce : xe, xe = Ae ? xe : ce, ce = xe - 1, b !== ce && (h = h.getTextContent().slice(b, xe), qt(h) || (e ? V.offset = ce : k.offset = ce));
          }
        }
      }
      this.removeText(), e && !s && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0 && (e = this.anchor.getNode(), e.isEmpty() && gr(e.getParent()) && e.getIndexWithinParent() === 0 && e.collapseAtStart(this));
    }
    deleteLine(e) {
      this.isCollapsed() && (this.anchor.type === "text" && this.modify("extend", e, "lineboundary"), (e ? this.focus : this.anchor).offset === 0 && this.modify("extend", e, "character")), this.removeText();
    }
    deleteWord(e) {
      this.isCollapsed() && this.modify("extend", e, "word"), this.removeText();
    }
    isBackward() {
      return this.focus.isBefore(this.anchor);
    }
    getStartEndPoints() {
      return [this.anchor, this.focus];
    }
  }
  function So(l) {
    return l instanceof Xo;
  }
  function jl(l) {
    let e = l.offset;
    return l.type === "text" ? e : (l = l.getNode(), e === l.getChildrenSize() ? l.getTextContent().length : 0);
  }
  function Nr(l) {
    if (l = l.getStartEndPoints(), l === null)
      return [0, 0];
    let [e, s] = l;
    return e.type === "element" && s.type === "element" && e.key === s.key && e.offset === s.offset ? [0, 0] : [jl(e), jl(s)];
  }
  function Hl(l, e, s) {
    let h = l.getTextContent().split(/(?=\s)/g), b = h.length, k = 0, V = 0;
    for (let ce = 0; ce < b; ce++) {
      let xe = h[ce], Ae = ce === b - 1;
      if (V = k, k += xe.length, e && k === s || k > s || Ae) {
        h.splice(ce, 1), Ae && (V = void 0);
        break;
      }
    }
    e = h.join("").trim(), e === "" ? l.remove() : (l.setTextContent(e), l.select(V, V));
  }
  function Wl(l, e, s, h) {
    var b = e;
    if (l.nodeType === 1) {
      let ce = !1;
      var k = l.childNodes, V = k.length;
      b === V && (ce = !0, b = V - 1);
      let xe = k[b];
      if (V = !1, xe === h._blockCursorElement ? (xe = k[b + 1], V = !0) : h._blockCursorElement !== null && b--, h = jt(xe), Et(h))
        b = ce ? h.getTextContentSize() : 0;
      else {
        if (k = jt(l), k === null)
          return null;
        if (Qe(k) ? (l = k.getChildAtIndex(b), (e = Qe(l)) && (e = l.getParent(), e = s === null || e === null || !e.canBeEmpty() || e !== s.getNode()), e && (s = ce ? l.getLastDescendant() : l.getFirstDescendant(), s === null ? (k = l, b = 0) : (l = s, k = Qe(l) ? l : l.getParentOrThrow())), Et(l) ? (h = l, k = null, b = ce ? l.getTextContentSize() : 0) : l !== k && ce && !V && b++) : (b = k.getIndexWithinParent(), b = e === 0 && xn(k) && jt(l) === k ? b : b + 1, k = k.getParentOrThrow()), Qe(k))
          return Rr(k.__key, b, "element");
      }
    } else
      h = jt(l);
    return Et(h) ? Rr(h.__key, b, "text") : null;
  }
  function Ti(l, e, s) {
    var h = l.offset, b = l.getNode();
    h === 0 ? (h = b.getPreviousSibling(), b = b.getParent(), e ? (s || !e) && h === null && Qe(b) && b.isInline() && (e = b.getPreviousSibling(), Et(e) && (l.key = e.__key, l.offset = e.getTextContent().length)) : Qe(h) && !s && h.isInline() ? (l.key = h.__key, l.offset = h.getChildrenSize(), l.type = "element") : Et(h) && (l.key = h.__key, l.offset = h.getTextContent().length)) : h === b.getTextContent().length && (h = b.getNextSibling(), b = b.getParent(), e && Qe(h) && h.isInline() ? (l.key = h.__key, l.offset = 0, l.type = "element") : (s || e) && h === null && Qe(b) && b.isInline() && !b.canInsertTextAfter() && (e = b.getNextSibling(), Et(e) && (l.key = e.__key, l.offset = 0)));
  }
  function Oo(l, e, s) {
    if (l.type === "text" && e.type === "text") {
      var h = l.isBefore(e);
      let b = l.is(e);
      Ti(l, h, b), Ti(e, !h, b), b && (e.key = l.key, e.offset = l.offset, e.type = l.type), h = mn(), h.isComposing() && h._compositionKey !== l.key && Pt(s) && (h = s.anchor, s = s.focus, _r(l, h.key, h.offset, h.type), _r(e, s.key, s.offset, s.type));
    }
  }
  function ns(l, e, s, h, b, k) {
    return l === null || s === null || !Re(b, l, s) || (e = Wl(l, e, Pt(k) ? k.anchor : null, b), e === null) || (h = Wl(s, h, Pt(k) ? k.focus : null, b), h === null || e.type === "element" && h.type === "element" && (l = jt(l), s = jt(s), xn(l) && xn(s))) ? null : (Oo(e, h, k), [e, h]);
  }
  function Ul(l, e, s, h, b, k) {
    let V = Jn();
    return l = new $r(Rr(l, e, b), Rr(s, h, k), 0, ""), l.dirty = !0, V._selection = l;
  }
  function zs() {
    return new Xo(/* @__PURE__ */ new Set());
  }
  function Yl(l) {
    let e = l.getEditorState()._selection, s = pr(l._window);
    return Pt(e) || e == null ? qs(e, s, l, null) : e.clone();
  }
  function qs(l, e, s, h) {
    var b = s._window;
    if (b === null)
      return null;
    var k = (b = h || b.event) ? b.type : void 0;
    h = k === "selectionchange", b = !je && (h || k === "beforeinput" || k === "compositionstart" || k === "compositionend" || k === "click" && b && b.detail === 3 || k === "drop" || k === void 0);
    let V;
    if (!Pt(l) || b) {
      if (e === null)
        return null;
      if (b = e.anchorNode, k = e.focusNode, V = e.anchorOffset, e = e.focusOffset, h && Pt(l) && !Re(s, b, k))
        return l.clone();
    } else
      return l.clone();
    if (s = ns(b, V, k, e, s, l), s === null)
      return null;
    let [ce, xe] = s;
    return new $r(ce, xe, Pt(l) ? l.format : 0, Pt(l) ? l.style : "");
  }
  function Bt() {
    return Jn()._selection;
  }
  function Rn() {
    return mn()._editorState._selection;
  }
  function Cr(l, e, s, h = 1) {
    var b = l.anchor, k = l.focus, V = b.getNode(), ce = k.getNode();
    if (e.is(V) || e.is(ce)) {
      if (V = e.__key, l.isCollapsed())
        e = b.offset, (s <= e && 0 < h || s < e && 0 > h) && (s = Math.max(0, e + h), b.set(V, s, "element"), k.set(V, s, "element"), Yr(l));
      else {
        let Ae = l.isBackward();
        ce = Ae ? k : b;
        var xe = ce.getNode();
        b = Ae ? b : k, k = b.getNode(), e.is(xe) && (xe = ce.offset, (s <= xe && 0 < h || s < xe && 0 > h) && ce.set(V, Math.max(0, xe + h), "element")), e.is(k) && (e = b.offset, (s <= e && 0 < h || s < e && 0 > h) && b.set(V, Math.max(0, e + h), "element"));
      }
      Yr(l);
    }
  }
  function Yr(l) {
    var e = l.anchor, s = e.offset;
    let h = l.focus;
    var b = h.offset, k = e.getNode(), V = h.getNode();
    if (l.isCollapsed())
      Qe(k) && (V = k.getChildrenSize(), V = (b = s >= V) ? k.getChildAtIndex(V - 1) : k.getChildAtIndex(s), Et(V) && (s = 0, b && (s = V.getTextContentSize()), e.set(V.__key, s, "text"), h.set(V.__key, s, "text")));
    else {
      if (Qe(k)) {
        let ce = k.getChildrenSize();
        s = (l = s >= ce) ? k.getChildAtIndex(ce - 1) : k.getChildAtIndex(s), Et(s) && (k = 0, l && (k = s.getTextContentSize()), e.set(s.__key, k, "text"));
      }
      Qe(V) && (s = V.getChildrenSize(), b = (e = b >= s) ? V.getChildAtIndex(s - 1) : V.getChildAtIndex(b), Et(b) && (V = 0, e && (V = b.getTextContentSize()), h.set(b.__key, V, "text")));
    }
  }
  function nr(l, e) {
    if (e = e.getEditorState()._selection, l = l._selection, Pt(l)) {
      var s = l.anchor;
      let h = l.focus, b;
      s.type === "text" && (b = s.getNode(), b.selectionTransform(e, l)), h.type === "text" && (s = h.getNode(), b !== s && s.selectionTransform(e, l));
    }
  }
  function ro(l, e, s, h, b) {
    let k = null, V = 0, ce = null;
    h !== null ? (k = h.__key, Et(h) ? (V = h.getTextContentSize(), ce = "text") : Qe(h) && (V = h.getChildrenSize(), ce = "element")) : b !== null && (k = b.__key, Et(b) ? ce = "text" : Qe(b) && (ce = "element")), k !== null && ce !== null ? l.set(k, V, ce) : (V = e.getIndexWithinParent(), V === -1 && (V = s.getChildrenSize()), l.set(s.__key, V, "element"));
  }
  function Gs(l, e, s, h, b) {
    l.type === "text" ? (l.key = s, e || (l.offset += b)) : l.offset > h.getIndexWithinParent() && --l.offset;
  }
  function yi(l) {
    l.isCollapsed() || l.removeText();
    var e = l.anchor;
    for (l = e.getNode(), e = e.offset; !mo(l); )
      [l, e] = rs(l, e);
    return e;
  }
  function rs(l, e) {
    var s = l.getParent();
    if (!s)
      return s = Fr(), Dt().append(s), s.select(), [Dt(), 0];
    if (Et(l)) {
      var h = l.splitText(e);
      return h.length === 0 ? [s, l.getIndexWithinParent()] : (l = e === 0 ? 0 : 1, l = h[0].getIndexWithinParent() + l, [s, l]);
    }
    return !Qe(l) || e === 0 ? [s, l.getIndexWithinParent()] : ((h = l.getChildAtIndex(e)) && (e = new $r(Rr(l.__key, e, "element"), Rr(l.__key, e, "element"), 0, ""), (e = l.insertNewAfter(e)) && e.append(h, ...h.getNextSiblings())), [s, l.getIndexWithinParent() + 1]);
  }
  function os(l) {
    let e = Fr(), s = null;
    for (let h = 0; h < l.length; h++) {
      let b = l[h], k = Mr(b);
      if (k || xn(b) && b.isInline() || Qe(b) && b.isInline() || Et(b) || b.isParentRequired()) {
        if (s === null && (s = b.createParentElementNode(), e.append(s), k))
          continue;
        s !== null && s.append(b);
      } else
        e.append(b), s = null;
    }
    return e;
  }
  let bn = null, An = null, Dn = !1, kr = !1, vo = 0, Zo = { characterData: !0, childList: !0, subtree: !0 };
  function zr() {
    return Dn || bn !== null && bn._readOnly;
  }
  function Wn() {
    Dn && q(13);
  }
  function Jn() {
    return bn === null && q(15), bn;
  }
  function mn() {
    return An === null && q(16), An;
  }
  function Vs(l, e, s) {
    var h = e.__type;
    let b = l._nodes.get(h);
    for (b === void 0 && q(30, h), l = s.get(h), l === void 0 && (l = Array.from(b.transforms), s.set(h, l)), s = l.length, h = 0; h < s && (l[h](e), e.isAttached()); h++)
      ;
  }
  function zl(l, e) {
    e = e._dirtyLeaves, l = l._nodeMap;
    for (let s of e)
      e = l.get(s), Et(e) && e.isAttached() && e.isSimpleText() && !e.isUnmergeable() && Ot(e);
  }
  function is(l, e) {
    let s = e._dirtyLeaves, h = e._dirtyElements;
    l = l._nodeMap;
    let b = ft(), k = /* @__PURE__ */ new Map();
    var V = s;
    let ce = V.size;
    for (var xe = h, Ae = xe.size; 0 < ce || 0 < Ae; ) {
      if (0 < ce) {
        e._dirtyLeaves = /* @__PURE__ */ new Set();
        for (let it of V)
          V = l.get(it), Et(V) && V.isAttached() && V.isSimpleText() && !V.isUnmergeable() && Ot(V), V !== void 0 && V !== void 0 && V.__key !== b && V.isAttached() && Vs(e, V, k), s.add(it);
        if (V = e._dirtyLeaves, ce = V.size, 0 < ce) {
          vo++;
          continue;
        }
      }
      e._dirtyLeaves = /* @__PURE__ */ new Set(), e._dirtyElements = /* @__PURE__ */ new Map();
      for (let it of xe)
        xe = it[0], Ae = it[1], (xe === "root" || Ae) && (V = l.get(xe), V !== void 0 && V !== void 0 && V.__key !== b && V.isAttached() && Vs(e, V, k), h.set(xe, Ae));
      V = e._dirtyLeaves, ce = V.size, xe = e._dirtyElements, Ae = xe.size, vo++;
    }
    e._dirtyLeaves = s, e._dirtyElements = h;
  }
  function Js(l, e) {
    var s = l.type, h = e.get(s);
    if (h === void 0 && q(17, s), s = h.klass, l.type !== s.getType() && q(18, s.name), s = s.importJSON(l), l = l.children, Qe(s) && Array.isArray(l))
      for (h = 0; h < l.length; h++) {
        let b = Js(l[h], e);
        s.append(b);
      }
    return s;
  }
  function ss(l, e) {
    let s = bn, h = Dn, b = An;
    bn = l, Dn = !0, An = null;
    try {
      return e();
    } finally {
      bn = s, Dn = h, An = b;
    }
  }
  function oo(l, e) {
    let s = l._pendingEditorState, h = l._rootElement, b = l._headless || h === null;
    if (s !== null) {
      var k = l._editorState, V = k._selection, ce = s._selection, xe = l._dirtyType !== 0, Ae = bn, it = Dn, st = An, Ve = l._updating, Fe = l._observer, pt = null;
      if (l._pendingEditorState = null, l._editorState = s, !b && xe && Fe !== null) {
        An = l, bn = s, Dn = !1, l._updating = !0;
        try {
          let _n = l._dirtyType, rr = l._dirtyElements, Sn = l._dirtyLeaves;
          Fe.disconnect();
          var Lt = _n, Ut = rr, Ft = Sn;
          er = vr = vn = "", Ol = Lt === 2, Ir = null, In = l, Qr = l._config, _o = l._nodes, Wi = In._listeners.mutation, Wo = Ut, Ps = Ft, pn = k._nodeMap, tr = s._nodeMap, Hi = s._readOnly, Bn = new Map(l._keyToDOMMap);
          let hn = /* @__PURE__ */ new Map();
          Uo = hn, Yo("root", null), Uo = Bn = Qr = tr = pn = Ps = Wo = _o = In = void 0, pt = hn;
        } catch (_n) {
          if (_n instanceof Error && l._onError(_n), kr)
            throw _n;
          wo(l, null, h, s), At(l), l._dirtyType = 2, kr = !0, oo(l, k), kr = !1;
          return;
        } finally {
          Fe.observe(h, Zo), l._updating = Ve, bn = Ae, Dn = it, An = st;
        }
      }
      s._readOnly || (s._readOnly = !0);
      var En = l._dirtyLeaves, Un = l._dirtyElements, ri = l._normalizedNodes, Br = l._updateTags, cs = l._deferred;
      xe && (l._dirtyType = 0, l._cloneNotNeeded.clear(), l._dirtyLeaves = /* @__PURE__ */ new Set(), l._dirtyElements = /* @__PURE__ */ new Map(), l._normalizedNodes = /* @__PURE__ */ new Set(), l._updateTags = /* @__PURE__ */ new Set());
      var Jl = l._decorators, us = l._pendingDecorators || Jl, Ka = s._nodeMap, Qs;
      for (Qs in us)
        Ka.has(Qs) || (us === Jl && (us = Mt(l)), delete us[Qs]);
      var Kr = b ? null : pr(l._window);
      if (l._editable && Kr !== null && (xe || ce === null || ce.dirty)) {
        An = l, bn = s;
        try {
          if (Fe !== null && Fe.disconnect(), xe || ce === null || ce.dirty) {
            let _n = l._blockCursorElement;
            _n !== null && Ho(_n, l, h);
            e: {
              let rr = Kr.anchorNode, Sn = Kr.focusNode, hn = Kr.anchorOffset, Ct = Kr.focusOffset, Yn = document.activeElement;
              if (!(Br.has("collaboration") && Yn !== h || Yn !== null && $e(Yn)))
                if (Pt(ce)) {
                  var Mo = ce.anchor, oi = ce.focus, Xl = Mo.key, ja = oi.key, Ro = On(l, Xl), Zl = On(l, ja), qr = Mo.offset, io = oi.offset, el = ce.format, ds = ce.style, fs = ce.isCollapsed(), bo = Ro, vi = Zl, tl = !1;
                  if (Mo.type === "text") {
                    bo = lt(Ro);
                    let or = Mo.getNode();
                    tl = or.getFormat() !== el || or.getStyle() !== ds;
                  } else
                    Pt(V) && V.anchor.type === "text" && (tl = !0);
                  if (oi.type === "text" && (vi = lt(Zl)), bo !== null && vi !== null) {
                    if (fs && (V === null || tl || Pt(V) && (V.format !== el || V.style !== ds))) {
                      var Ql = performance.now();
                      bl = [el, ds, qr, Xl, Ql];
                    }
                    if (hn === qr && Ct === io && rr === bo && Sn === vi && (Kr.type !== "Range" || !fs) && (Yn !== null && h.contains(Yn) || h.focus({ preventScroll: !0 }), Mo.type !== "element"))
                      break e;
                    try {
                      Kr.setBaseAndExtent(bo, qr, vi, io);
                    } catch {
                    }
                    if (!Br.has("skip-scroll-into-view") && ce.isCollapsed() && h !== null && h === document.activeElement) {
                      let or = ce instanceof $r && ce.anchor.type === "element" ? bo.childNodes[qr] || null : 0 < Kr.rangeCount ? Kr.getRangeAt(0) : null;
                      if (or !== null) {
                        let hr;
                        if (or instanceof Text) {
                          let ir = document.createRange();
                          ir.selectNode(or), hr = ir.getBoundingClientRect();
                        } else
                          hr = or.getBoundingClientRect();
                        let lo = h.ownerDocument, zn = lo.defaultView;
                        if (zn !== null)
                          for (var { top: gs, bottom: ii } = hr, jr, hs, so = h; so !== null; ) {
                            let ir = so === lo.body;
                            if (ir)
                              jr = 0, hs = Fn(l).innerHeight;
                            else {
                              let wi = so.getBoundingClientRect();
                              jr = wi.top, hs = wi.bottom;
                            }
                            let ao = 0;
                            if (gs < jr ? ao = -(jr - gs) : ii > hs && (ao = ii - hs), ao !== 0)
                              if (ir)
                                zn.scrollBy(0, ao);
                              else {
                                let wi = so.scrollTop;
                                so.scrollTop += ao;
                                let Gr = so.scrollTop - wi;
                                gs -= Gr, ii -= Gr;
                              }
                            if (ir)
                              break;
                            so = Qn(so);
                          }
                      }
                    }
                    Bs = !0;
                  }
                } else
                  V !== null && Re(l, rr, Sn) && Kr.removeAllRanges();
            }
          }
          e: {
            let _n = l._blockCursorElement;
            if (Pt(ce) && ce.isCollapsed() && ce.anchor.type === "element" && h.contains(document.activeElement)) {
              let rr = ce.anchor, Sn = rr.getNode(), hn = rr.offset, Ct = Sn.getChildrenSize(), Yn = !1, or = null;
              if (hn === Ct) {
                let hr = Sn.getChildAtIndex(hn - 1);
                Sr(hr) && (Yn = !0);
              } else {
                let hr = Sn.getChildAtIndex(hn);
                if (Sr(hr)) {
                  let lo = hr.getPreviousSibling();
                  (lo === null || Sr(lo)) && (Yn = !0, or = l.getElementByKey(hr.__key));
                }
              }
              if (Yn) {
                let hr = l.getElementByKey(Sn.__key);
                if (_n === null) {
                  let lo = l._config.theme, zn = document.createElement("div");
                  zn.contentEditable = "false", zn.setAttribute("data-lexical-cursor", "true");
                  let ir = lo.blockCursor;
                  if (ir !== void 0) {
                    if (typeof ir == "string") {
                      let ao = ir.split(" ");
                      ir = lo.blockCursor = ao;
                    }
                    ir !== void 0 && zn.classList.add(...ir);
                  }
                  l._blockCursorElement = _n = zn;
                }
                h.style.caretColor = "transparent", or === null ? hr.appendChild(_n) : hr.insertBefore(_n, or);
                break e;
              }
            }
            _n !== null && Ho(_n, l, h);
          }
          Fe !== null && Fe.observe(h, Zo);
        } finally {
          An = st, bn = Ae;
        }
      }
      if (pt !== null) {
        var ea = pt;
        let _n = Array.from(l._listeners.mutation), rr = _n.length;
        for (let Sn = 0; Sn < rr; Sn++) {
          let [hn, Ct] = _n[Sn], Yn = ea.get(Ct);
          Yn !== void 0 && hn(Yn, { dirtyLeaves: En, prevEditorState: k, updateTags: Br });
        }
      }
      Pt(ce) || ce === null || V !== null && V.is(ce) || l.dispatchCommand(r, void 0);
      var nl = l._pendingDecorators;
      nl !== null && (l._decorators = nl, l._pendingDecorators = null, Qo("decorator", l, !0, nl));
      var Ha = It(e || k), ta = It(s);
      if (Ha !== ta && Qo("textcontent", l, !0, ta), Qo("update", l, !0, { dirtyElements: Un, dirtyLeaves: En, editorState: s, normalizedNodes: ri, prevEditorState: e || k, tags: Br }), l._deferred = [], cs.length !== 0) {
        let _n = l._updating;
        l._updating = !0;
        try {
          for (let rr = 0; rr < cs.length; rr++)
            cs[rr]();
        } finally {
          l._updating = _n;
        }
      }
      var na = l._updates;
      if (na.length !== 0) {
        let _n = na.shift();
        if (_n) {
          let [rr, Sn] = _n;
          Si(l, rr, Sn);
        }
      }
    }
  }
  function Qo(l, e, s, ...h) {
    let b = e._updating;
    e._updating = s;
    try {
      let k = Array.from(e._listeners[l]);
      for (l = 0; l < k.length; l++)
        k[l].apply(null, h);
    } finally {
      e._updating = b;
    }
  }
  function ht(l, e, s) {
    if (l._updating === !1 || An !== l) {
      let k = !1;
      return l.update(() => {
        k = ht(l, e, s);
      }), k;
    }
    let h = _e(l);
    for (let k = 4; 0 <= k; k--)
      for (let V = 0; V < h.length; V++) {
        var b = h[V]._commands.get(e);
        if (b !== void 0 && (b = b[k], b !== void 0)) {
          b = Array.from(b);
          let ce = b.length;
          for (let xe = 0; xe < ce; xe++)
            if (b[xe](s, l) === !0)
              return !0;
        }
      }
    return !1;
  }
  function ql(l, e) {
    let s = l._updates;
    for (e = e || !1; s.length !== 0; ) {
      var h = s.shift();
      if (h) {
        let [b, k] = h, V;
        k !== void 0 && (h = k.onUpdate, V = k.tag, k.skipTransforms && (e = !0), h && l._deferred.push(h), V && l._updateTags.add(V)), b();
      }
    }
    return e;
  }
  function Si(l, e, s) {
    let h = l._updateTags;
    var b, k = b = !1;
    if (s !== void 0) {
      var V = s.onUpdate;
      b = s.tag, b != null && h.add(b), b = s.skipTransforms || !1, k = s.discrete || !1;
    }
    V && l._deferred.push(V), s = l._editorState, V = l._pendingEditorState;
    let ce = !1;
    (V === null || V._readOnly) && (V = l._pendingEditorState = new ni(new Map((V || s)._nodeMap)), ce = !0), V._flushSync = k, k = bn;
    let xe = Dn, Ae = An, it = l._updating;
    bn = V, Dn = !1, l._updating = !0, An = l;
    try {
      ce && (l._headless ? s._selection !== null && (V._selection = s._selection.clone()) : V._selection = Yl(l));
      let st = l._compositionKey;
      e(), b = ql(l, b), nr(V, l), l._dirtyType !== 0 && (b ? zl(V, l) : is(V, l), ql(l), gi(s, V, l._dirtyLeaves, l._dirtyElements)), st !== l._compositionKey && (V._flushSync = !0);
      let Ve = V._selection;
      if (Pt(Ve)) {
        let Fe = V._nodeMap, pt = Ve.focus.key;
        Fe.get(Ve.anchor.key) !== void 0 && Fe.get(pt) !== void 0 || q(19);
      } else
        So(Ve) && Ve._nodes.size === 0 && (V._selection = null);
    } catch (st) {
      st instanceof Error && l._onError(st), l._pendingEditorState = s, l._dirtyType = 2, l._cloneNotNeeded.clear(), l._dirtyLeaves = /* @__PURE__ */ new Set(), l._dirtyElements.clear(), oo(l);
      return;
    } finally {
      bn = k, Dn = xe, An = Ae, l._updating = it, vo = 0;
    }
    l._dirtyType !== 0 || Xs(V, l) ? V._flushSync ? (V._flushSync = !1, oo(l)) : ce && Se(() => {
      oo(l);
    }) : (V._flushSync = !1, ce && (h.clear(), l._deferred = [], l._pendingEditorState = null));
  }
  function fr(l, e, s) {
    l._updating ? l._updates.push([e, s]) : Si(l, e, s);
  }
  class ei extends Ji {
    constructor(e) {
      super(e);
    }
    decorate() {
      q(47);
    }
    isIsolated() {
      return !1;
    }
    isInline() {
      return !0;
    }
    isKeyboardSelectable() {
      return !0;
    }
  }
  function xn(l) {
    return l instanceof ei;
  }
  class ls extends Ji {
    constructor(e) {
      super(e), this.__last = this.__first = null, this.__indent = this.__format = this.__size = 0, this.__dir = null;
    }
    getFormat() {
      return this.getLatest().__format;
    }
    getFormatType() {
      let e = this.getFormat();
      return ge[e] || "";
    }
    getIndent() {
      return this.getLatest().__indent;
    }
    getChildren() {
      let e = [], s = this.getFirstChild();
      for (; s !== null; )
        e.push(s), s = s.getNextSibling();
      return e;
    }
    getChildrenKeys() {
      let e = [], s = this.getFirstChild();
      for (; s !== null; )
        e.push(s.__key), s = s.getNextSibling();
      return e;
    }
    getChildrenSize() {
      return this.getLatest().__size;
    }
    isEmpty() {
      return this.getChildrenSize() === 0;
    }
    isDirty() {
      let e = mn()._dirtyElements;
      return e !== null && e.has(this.__key);
    }
    isLastChild() {
      let e = this.getLatest(), s = this.getParentOrThrow().getLastChild();
      return s !== null && s.is(e);
    }
    getAllTextNodes() {
      let e = [], s = this.getFirstChild();
      for (; s !== null; ) {
        if (Et(s) && e.push(s), Qe(s)) {
          let h = s.getAllTextNodes();
          e.push(...h);
        }
        s = s.getNextSibling();
      }
      return e;
    }
    getFirstDescendant() {
      let e = this.getFirstChild();
      for (; e !== null; ) {
        if (Qe(e)) {
          let s = e.getFirstChild();
          if (s !== null) {
            e = s;
            continue;
          }
        }
        break;
      }
      return e;
    }
    getLastDescendant() {
      let e = this.getLastChild();
      for (; e !== null; ) {
        if (Qe(e)) {
          let s = e.getLastChild();
          if (s !== null) {
            e = s;
            continue;
          }
        }
        break;
      }
      return e;
    }
    getDescendantByIndex(e) {
      let s = this.getChildren(), h = s.length;
      return e >= h ? (e = s[h - 1], Qe(e) && e.getLastDescendant() || e || null) : (e = s[e], Qe(e) && e.getFirstDescendant() || e || null);
    }
    getFirstChild() {
      let e = this.getLatest().__first;
      return e === null ? null : ct(e);
    }
    getFirstChildOrThrow() {
      let e = this.getFirstChild();
      return e === null && q(45, this.__key), e;
    }
    getLastChild() {
      let e = this.getLatest().__last;
      return e === null ? null : ct(e);
    }
    getLastChildOrThrow() {
      let e = this.getLastChild();
      return e === null && q(96, this.__key), e;
    }
    getChildAtIndex(e) {
      var s = this.getChildrenSize();
      let h;
      if (e < s / 2) {
        for (h = this.getFirstChild(), s = 0; h !== null && s <= e; ) {
          if (s === e)
            return h;
          h = h.getNextSibling(), s++;
        }
        return null;
      }
      for (h = this.getLastChild(), --s; h !== null && s >= e; ) {
        if (s === e)
          return h;
        h = h.getPreviousSibling(), s--;
      }
      return null;
    }
    getTextContent() {
      let e = "", s = this.getChildren(), h = s.length;
      for (let b = 0; b < h; b++) {
        let k = s[b];
        e += k.getTextContent(), Qe(k) && b !== h - 1 && !k.isInline() && (e += `

`);
      }
      return e;
    }
    getTextContentSize() {
      let e = 0, s = this.getChildren(), h = s.length;
      for (let b = 0; b < h; b++) {
        let k = s[b];
        e += k.getTextContentSize(), Qe(k) && b !== h - 1 && !k.isInline() && (e += 2);
      }
      return e;
    }
    getDirection() {
      return this.getLatest().__dir;
    }
    hasFormat(e) {
      return e !== "" ? (e = me[e], (this.getFormat() & e) !== 0) : !1;
    }
    select(e, s) {
      Wn();
      let h = Bt(), b = e, k = s;
      var V = this.getChildrenSize();
      if (!this.canBeEmpty()) {
        if (e === 0 && s === 0) {
          if (e = this.getFirstChild(), Et(e) || Qe(e))
            return e.select(0, 0);
        } else if (!(e !== void 0 && e !== V || s !== void 0 && s !== V) && (e = this.getLastChild(), Et(e) || Qe(e)))
          return e.select();
      }
      if (b === void 0 && (b = V), k === void 0 && (k = V), V = this.__key, Pt(h))
        h.anchor.set(V, b, "element"), h.focus.set(V, k, "element"), h.dirty = !0;
      else
        return Ul(V, b, V, k, "element", "element");
      return h;
    }
    selectStart() {
      let e = this.getFirstDescendant();
      return e ? e.selectStart() : this.select();
    }
    selectEnd() {
      let e = this.getLastDescendant();
      return e ? e.selectEnd() : this.select();
    }
    clear() {
      let e = this.getWritable();
      return this.getChildren().forEach((s) => s.remove()), e;
    }
    append(...e) {
      return this.splice(
        this.getChildrenSize(),
        0,
        e
      );
    }
    setDirection(e) {
      let s = this.getWritable();
      return s.__dir = e, s;
    }
    setFormat(e) {
      return this.getWritable().__format = e !== "" ? me[e] : 0, this;
    }
    setIndent(e) {
      return this.getWritable().__indent = e, this;
    }
    splice(e, s, h) {
      let b = h.length, k = this.getChildrenSize(), V = this.getWritable(), ce = V.__key;
      var xe = [], Ae = [];
      let it = this.getChildAtIndex(e + s), st = null, Ve = k - s + b;
      if (e !== 0)
        if (e === k)
          st = this.getLastChild();
        else {
          var Fe = this.getChildAtIndex(e);
          Fe !== null && (st = Fe.getPreviousSibling());
        }
      if (0 < s) {
        var pt = st === null ? this.getFirstChild() : st.getNextSibling();
        for (Fe = 0; Fe < s; Fe++) {
          pt === null && q(100);
          var Lt = pt.getNextSibling(), Ut = pt.__key;
          pt = pt.getWritable(), Be(pt), Ae.push(Ut), pt = Lt;
        }
      }
      for (Fe = st, Lt = 0; Lt < b; Lt++) {
        Ut = h[Lt], Fe !== null && Ut.is(Fe) && (st = Fe = Fe.getPreviousSibling()), pt = Ut.getWritable(), pt.__parent === ce && Ve--, Be(pt);
        let Ft = Ut.__key;
        Fe === null ? (V.__first = Ft, pt.__prev = null) : (Fe = Fe.getWritable(), Fe.__next = Ft, pt.__prev = Fe.__key), Ut.__key === ce && q(76), pt.__parent = ce, xe.push(Ft), Fe = Ut;
      }
      if (e + s === k ? Fe !== null && (Fe.getWritable().__next = null, V.__last = Fe.__key) : it !== null && (e = it.getWritable(), Fe !== null ? (s = Fe.getWritable(), e.__prev = Fe.__key, s.__next = it.__key) : e.__prev = null), V.__size = Ve, Ae.length && (e = Bt(), Pt(e))) {
        Ae = new Set(Ae), xe = new Set(xe);
        let { anchor: Ft, focus: En } = e;
        Gl(Ft, Ae, xe) && ro(Ft, Ft.getNode(), this, st, it), Gl(En, Ae, xe) && ro(En, En.getNode(), this, st, it), Ve !== 0 || this.canBeEmpty() || yr(this) || this.remove();
      }
      return V;
    }
    exportJSON() {
      return { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), type: "element", version: 1 };
    }
    insertNewAfter() {
      return null;
    }
    canIndent() {
      return !0;
    }
    collapseAtStart() {
      return !1;
    }
    excludeFromCopy() {
      return !1;
    }
    canExtractContents() {
      return !0;
    }
    canReplaceWith() {
      return !0;
    }
    canInsertAfter() {
      return !0;
    }
    canBeEmpty() {
      return !0;
    }
    canInsertTextBefore() {
      return !0;
    }
    canInsertTextAfter() {
      return !0;
    }
    isInline() {
      return !1;
    }
    isShadowRoot() {
      return !1;
    }
    canMergeWith() {
      return !1;
    }
    extractWithChild() {
      return !1;
    }
  }
  function Qe(l) {
    return l instanceof ls;
  }
  function Gl(l, e, s) {
    for (l = l.getNode(); l; ) {
      let h = l.__key;
      if (e.has(h) && !s.has(h))
        return !0;
      l = l.getParent();
    }
    return !1;
  }
  class ti extends ls {
    static getType() {
      return "root";
    }
    static clone() {
      return new ti();
    }
    constructor() {
      super("root"), this.__cachedText = null;
    }
    getTopLevelElementOrThrow() {
      q(51);
    }
    getTextContent() {
      let e = this.__cachedText;
      return !zr() && mn()._dirtyType !== 0 || e === null ? super.getTextContent() : e;
    }
    remove() {
      q(52);
    }
    replace() {
      q(53);
    }
    insertBefore() {
      q(54);
    }
    insertAfter() {
      q(55);
    }
    updateDOM() {
      return !1;
    }
    append(...e) {
      for (let s = 0; s < e.length; s++) {
        let h = e[s];
        Qe(h) || xn(h) || q(56);
      }
      return super.append(...e);
    }
    static importJSON(e) {
      let s = Dt();
      return s.setFormat(e.format), s.setIndent(e.indent), s.setDirection(e.direction), s;
    }
    exportJSON() {
      return { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), type: "root", version: 1 };
    }
    collapseAtStart() {
      return !0;
    }
  }
  function gr(l) {
    return l instanceof ti;
  }
  function Xs(l, e) {
    if (e = e.getEditorState()._selection, l = l._selection, l !== null) {
      if (l.dirty || !l.is(e))
        return !0;
    } else if (e !== null)
      return !0;
    return !1;
  }
  function br() {
    return new ni(/* @__PURE__ */ new Map([["root", new ti()]]));
  }
  function as(l) {
    let e = l.exportJSON();
    var s = l.constructor;
    if (e.type !== s.getType() && q(130, s.name), Qe(l)) {
      let h = e.children;
      for (Array.isArray(h) || q(59, s.name), l = l.getChildren(), s = 0; s < l.length; s++) {
        let b = as(l[s]);
        h.push(b);
      }
    }
    return e;
  }
  class ni {
    constructor(e, s) {
      this._nodeMap = e, this._selection = s || null, this._readOnly = this._flushSync = !1;
    }
    isEmpty() {
      return this._nodeMap.size === 1 && this._selection === null;
    }
    read(e) {
      return ss(this, e);
    }
    clone(e) {
      return e = new ni(this._nodeMap, e === void 0 ? this._selection : e), e._readOnly = !0, e;
    }
    toJSON() {
      return ss(this, () => ({ root: as(Dt()) }));
    }
  }
  class Pr extends ls {
    static getType() {
      return "paragraph";
    }
    static clone(e) {
      return new Pr(e.__key);
    }
    createDOM(e) {
      let s = document.createElement("p");
      return e = Zt(e.theme, "paragraph"), e !== void 0 && s.classList.add(...e), s;
    }
    updateDOM() {
      return !1;
    }
    static importDOM() {
      return { p: () => ({ conversion: Vl, priority: 0 }) };
    }
    exportDOM(e) {
      if ({ element: e } = super.exportDOM(e), e && Or(e)) {
        this.isEmpty() && e.append(document.createElement("br"));
        var s = this.getFormatType();
        e.style.textAlign = s, (s = this.getDirection()) && (e.dir = s), s = this.getIndent(), 0 < s && (e.style.textIndent = `${20 * s}px`);
      }
      return { element: e };
    }
    static importJSON(e) {
      let s = Fr();
      return s.setFormat(e.format), s.setIndent(e.indent), s.setDirection(e.direction), s;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "paragraph", version: 1 };
    }
    insertNewAfter(e, s) {
      e = Fr();
      let h = this.getDirection();
      return e.setDirection(h), this.insertAfter(e, s), e;
    }
    collapseAtStart() {
      let e = this.getChildren();
      if (e.length === 0 || Et(e[0]) && e[0].getTextContent().trim() === "") {
        if (this.getNextSibling() !== null)
          return this.selectNext(), this.remove(), !0;
        if (this.getPreviousSibling() !== null)
          return this.selectPrevious(), this.remove(), !0;
      }
      return !1;
    }
  }
  function Vl(l) {
    let e = Fr();
    return l.style && (e.setFormat(l.style.textAlign), l = parseInt(l.style.textIndent, 10) / 20, 0 < l && e.setIndent(l)), { node: e };
  }
  function Fr() {
    return Wr(new Pr());
  }
  function wo(l, e, s, h) {
    let b = l._keyToDOMMap;
    b.clear(), l._editorState = br(), l._pendingEditorState = h, l._compositionKey = null, l._dirtyType = 0, l._cloneNotNeeded.clear(), l._dirtyLeaves = /* @__PURE__ */ new Set(), l._dirtyElements.clear(), l._normalizedNodes = /* @__PURE__ */ new Set(), l._updateTags = /* @__PURE__ */ new Set(), l._updates = [], l._blockCursorElement = null, h = l._observer, h !== null && (h.disconnect(), l._observer = null), e !== null && (e.textContent = ""), s !== null && (s.textContent = "", b.set("root", s));
  }
  function Oi(l, e) {
    let s = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Set(), b = (k) => {
      Object.keys(k).forEach((V) => {
        let ce = s.get(V);
        ce === void 0 && (ce = [], s.set(V, ce)), ce.push(k[V]);
      });
    };
    return l.forEach((k) => {
      k = k.klass.importDOM != null ? k.klass.importDOM.bind(k.klass) : null, k == null || h.has(k) || (h.add(k), k = k(), k !== null && b(k));
    }), e && b(e), s;
  }
  class Zs {
    constructor(e, s, h, b, k, V, ce) {
      this._parentEditor = s, this._rootElement = null, this._editorState = e, this._compositionKey = this._pendingEditorState = null, this._deferred = [], this._keyToDOMMap = /* @__PURE__ */ new Map(), this._updates = [], this._updating = !1, this._listeners = { decorator: /* @__PURE__ */ new Set(), editable: /* @__PURE__ */ new Set(), mutation: /* @__PURE__ */ new Map(), root: /* @__PURE__ */ new Set(), textcontent: /* @__PURE__ */ new Set(), update: /* @__PURE__ */ new Set() }, this._commands = /* @__PURE__ */ new Map(), this._config = b, this._nodes = h, this._decorators = {}, this._pendingDecorators = null, this._dirtyType = 0, this._cloneNotNeeded = /* @__PURE__ */ new Set(), this._dirtyLeaves = /* @__PURE__ */ new Set(), this._dirtyElements = /* @__PURE__ */ new Map(), this._normalizedNodes = /* @__PURE__ */ new Set(), this._updateTags = /* @__PURE__ */ new Set(), this._observer = null, this._key = Ue(), this._onError = k, this._htmlConversions = V, this._editable = ce, this._headless = s !== null && s._headless, this._blockCursorElement = this._window = null;
    }
    isComposing() {
      return this._compositionKey != null;
    }
    registerUpdateListener(e) {
      let s = this._listeners.update;
      return s.add(e), () => {
        s.delete(e);
      };
    }
    registerEditableListener(e) {
      let s = this._listeners.editable;
      return s.add(e), () => {
        s.delete(e);
      };
    }
    registerDecoratorListener(e) {
      let s = this._listeners.decorator;
      return s.add(e), () => {
        s.delete(e);
      };
    }
    registerTextContentListener(e) {
      let s = this._listeners.textcontent;
      return s.add(e), () => {
        s.delete(e);
      };
    }
    registerRootListener(e) {
      let s = this._listeners.root;
      return e(this._rootElement, null), s.add(e), () => {
        e(null, this._rootElement), s.delete(e);
      };
    }
    registerCommand(e, s, h) {
      h === void 0 && q(35);
      let b = this._commands;
      b.has(e) || b.set(e, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
      let k = b.get(e);
      k === void 0 && q(36, String(e));
      let V = k[h];
      return V.add(s), () => {
        V.delete(s), k.every((ce) => ce.size === 0) && b.delete(e);
      };
    }
    registerMutationListener(e, s) {
      this._nodes.get(e.getType()) === void 0 && q(37, e.name);
      let h = this._listeners.mutation;
      return h.set(s, e), () => {
        h.delete(s);
      };
    }
    registerNodeTransformToKlass(e, s) {
      var h = e.getType();
      return h = this._nodes.get(h), h === void 0 && q(37, e.name), h.transforms.add(s), h;
    }
    registerNodeTransform(e, s) {
      var h = this.registerNodeTransformToKlass(e, s);
      let b = [h];
      return h = h.replaceWithKlass, h != null && (h = this.registerNodeTransformToKlass(h, s), b.push(h)), on(this, e.getType()), () => {
        b.forEach((k) => k.transforms.delete(s));
      };
    }
    hasNode(e) {
      return this._nodes.has(e.getType());
    }
    hasNodes(e) {
      return e.every(this.hasNode.bind(this));
    }
    dispatchCommand(e, s) {
      return ht(this, e, s);
    }
    getDecorators() {
      return this._decorators;
    }
    getRootElement() {
      return this._rootElement;
    }
    getKey() {
      return this._key;
    }
    setRootElement(e) {
      let s = this._rootElement;
      if (e !== s) {
        let V = Zt(this._config.theme, "root");
        var h = this._pendingEditorState || this._editorState;
        if (this._rootElement = e, wo(this, s, e, h), s !== null) {
          if (!this._config.disableEvents) {
            _i !== 0 && (_i--, _i === 0 && s.ownerDocument.removeEventListener("selectionchange", Pl));
            var b = s.__lexicalEditor;
            if (b != null) {
              if (b._parentEditor !== null) {
                var k = _e(b);
                k = k[k.length - 1]._key, qo.get(k) === b && qo.delete(k);
              } else
                qo.delete(b._key);
              s.__lexicalEditor = null;
            }
            for (b = kl(s), k = 0; k < b.length; k++)
              b[k]();
            s.__lexicalEventHandles = [];
          }
          V != null && s.classList.remove(...V);
        }
        e !== null ? (h = (h = e.ownerDocument) && h.defaultView || null, b = e.style, b.userSelect = "text", b.whiteSpace = "pre-wrap", b.wordBreak = "break-word", e.setAttribute(
          "data-lexical-editor",
          "true"
        ), this._window = h, this._dirtyType = 2, At(this), this._updateTags.add("history-merge"), oo(this), this._config.disableEvents || Fa(e, this), V != null && e.classList.add(...V)) : (this._editorState = h, this._window = this._pendingEditorState = null), Qo("root", this, !1, e, s);
      }
    }
    getElementByKey(e) {
      return this._keyToDOMMap.get(e) || null;
    }
    getEditorState() {
      return this._editorState;
    }
    setEditorState(e, s) {
      e.isEmpty() && q(38), nt(this);
      let h = this._pendingEditorState, b = this._updateTags;
      s = s !== void 0 ? s.tag : null, h === null || h.isEmpty() || (s != null && b.add(s), oo(this)), this._pendingEditorState = e, this._dirtyType = 2, this._dirtyElements.set("root", !1), this._compositionKey = null, s != null && b.add(s), oo(this);
    }
    parseEditorState(e, s) {
      e = typeof e == "string" ? JSON.parse(e) : e;
      let h = br(), b = bn, k = Dn, V = An, ce = this._dirtyElements, xe = this._dirtyLeaves, Ae = this._cloneNotNeeded, it = this._dirtyType;
      this._dirtyElements = /* @__PURE__ */ new Map(), this._dirtyLeaves = /* @__PURE__ */ new Set(), this._cloneNotNeeded = /* @__PURE__ */ new Set(), this._dirtyType = 0, bn = h, Dn = !1, An = this;
      try {
        Js(e.root, this._nodes), s && s(), h._readOnly = !0;
      } catch (st) {
        st instanceof Error && this._onError(st);
      } finally {
        this._dirtyElements = ce, this._dirtyLeaves = xe, this._cloneNotNeeded = Ae, this._dirtyType = it, bn = b, Dn = k, An = V;
      }
      return h;
    }
    update(e, s) {
      fr(this, e, s);
    }
    focus(e, s = {}) {
      let h = this._rootElement;
      h !== null && (h.setAttribute("autocapitalize", "off"), fr(this, () => {
        let b = Bt(), k = Dt();
        b !== null ? b.dirty = !0 : k.getChildrenSize() !== 0 && (s.defaultSelection === "rootStart" ? k.selectStart() : k.selectEnd());
      }, { onUpdate: () => {
        h.removeAttribute("autocapitalize"), e && e();
      }, tag: "focus" }), this._pendingEditorState === null && h.removeAttribute("autocapitalize"));
    }
    blur() {
      var e = this._rootElement;
      e !== null && e.blur(), e = pr(this._window), e !== null && e.removeAllRanges();
    }
    isEditable() {
      return this._editable;
    }
    setEditable(e) {
      this._editable !== e && (this._editable = e, Qo("editable", this, !0, e));
    }
    toJSON() {
      return { editorState: this._editorState.toJSON() };
    }
  }
  return qe.$addUpdateTag = function(l) {
    Wn(), mn()._updateTags.add(l);
  }, qe.$applyNodeReplacement = Wr, qe.$copyNode = fi, qe.$createLineBreakNode = Co, qe.$createNodeSelection = zs, qe.$createParagraphNode = Fr, qe.$createPoint = Rr, qe.$createRangeSelection = function() {
    let l = Rr("root", 0, "element"), e = Rr("root", 0, "element");
    return new $r(l, e, 0, "");
  }, qe.$createTabNode = yo, qe.$createTextNode = Hn, qe.$getAdjacentNode = yn, qe.$getCharacterOffsets = Nr, qe.$getEditor = function() {
    return mn();
  }, qe.$getNearestNodeFromDOMNode = wt, qe.$getNearestRootOrShadowRoot = jo, qe.$getNodeByKey = ct, qe.$getPreviousSelection = Rn, qe.$getRoot = Dt, qe.$getSelection = Bt, qe.$getTextContent = function() {
    let l = Bt();
    return l === null ? "" : l.getTextContent();
  }, qe.$hasAncestor = fn, qe.$hasUpdateTag = function(l) {
    return mn()._updateTags.has(l);
  }, qe.$insertNodes = function(l) {
    let e = Bt() || Rn();
    e === null && (e = Dt().selectEnd()), e.insertNodes(l);
  }, qe.$isBlockElementNode = function(l) {
    return Qe(l) && !l.isInline();
  }, qe.$isDecoratorNode = xn, qe.$isElementNode = Qe, qe.$isInlineElementOrDecoratorNode = function(l) {
    return Qe(l) && l.isInline() || xn(l) && l.isInline();
  }, qe.$isLeafNode = function(l) {
    return Et(l) || Mr(l) || xn(l);
  }, qe.$isLineBreakNode = Mr, qe.$isNodeSelection = So, qe.$isParagraphNode = function(l) {
    return l instanceof Pr;
  }, qe.$isRangeSelection = Pt, qe.$isRootNode = gr, qe.$isRootOrShadowRoot = yr, qe.$isTabNode = Kl, qe.$isTextNode = Et, qe.$nodesOfType = function(l) {
    var e = Jn();
    let s = e._readOnly, h = l.getType();
    e = e._nodeMap;
    let b = [];
    for (let [, k] of e)
      k instanceof l && k.__type === h && (s || k.isAttached()) && b.push(k);
    return b;
  }, qe.$normalizeSelection__EXPERIMENTAL = Te, qe.$parseSerializedNode = function(l) {
    return Js(l, mn()._nodes);
  }, qe.$selectAll = function() {
    var l = Dt();
    l = l.select(0, l.getChildrenSize()), en(Te(l));
  }, qe.$setCompositionKey = Ye, qe.$setSelection = en, qe.$splitNode = function(l, e) {
    let s = l.getChildAtIndex(e);
    s == null && (s = l), yr(l) && q(102);
    let h = (V) => {
      const ce = V.getParentOrThrow(), xe = yr(ce), Ae = V !== s || xe ? fi(V) : V;
      if (xe)
        return Qe(V) && Qe(Ae) || q(133), V.insertAfter(Ae), [V, Ae, Ae];
      const [it, st, Ve] = h(ce);
      return V = V.getNextSiblings(), Ve.append(Ae, ...V), [it, st, Ae];
    }, [b, k] = h(s);
    return [b, k];
  }, qe.BLUR_COMMAND = z, qe.CAN_REDO_COMMAND = {}, qe.CAN_UNDO_COMMAND = {}, qe.CLEAR_EDITOR_COMMAND = {}, qe.CLEAR_HISTORY_COMMAND = {}, qe.CLICK_COMMAND = n, qe.COMMAND_PRIORITY_CRITICAL = 4, qe.COMMAND_PRIORITY_EDITOR = 0, qe.COMMAND_PRIORITY_HIGH = 3, qe.COMMAND_PRIORITY_LOW = 1, qe.COMMAND_PRIORITY_NORMAL = 2, qe.CONTROLLED_TEXT_INSERTION_COMMAND = p, qe.COPY_COMMAND = ne, qe.CUT_COMMAND = te, qe.DELETE_CHARACTER_COMMAND = t, qe.DELETE_LINE_COMMAND = S, qe.DELETE_WORD_COMMAND = O, qe.DRAGEND_COMMAND = oe, qe.DRAGOVER_COMMAND = Z, qe.DRAGSTART_COMMAND = F, qe.DROP_COMMAND = P, qe.DecoratorNode = ei, qe.ElementNode = ls, qe.FOCUS_COMMAND = A, qe.FORMAT_ELEMENT_COMMAND = {}, qe.FORMAT_TEXT_COMMAND = E, qe.INDENT_CONTENT_COMMAND = {}, qe.INSERT_LINE_BREAK_COMMAND = o, qe.INSERT_PARAGRAPH_COMMAND = u, qe.INSERT_TAB_COMMAND = {}, qe.KEY_ARROW_DOWN_COMMAND = C, qe.KEY_ARROW_LEFT_COMMAND = w, qe.KEY_ARROW_RIGHT_COMMAND = _, qe.KEY_ARROW_UP_COMMAND = D, qe.KEY_BACKSPACE_COMMAND = W, qe.KEY_DELETE_COMMAND = B, qe.KEY_DOWN_COMMAND = g, qe.KEY_ENTER_COMMAND = x, qe.KEY_ESCAPE_COMMAND = $, qe.KEY_MODIFIER_COMMAND = ie, qe.KEY_SPACE_COMMAND = I, qe.KEY_TAB_COMMAND = L, qe.LineBreakNode = Go, qe.MOVE_TO_END = N, qe.MOVE_TO_START = T, qe.OUTDENT_CONTENT_COMMAND = {}, qe.PASTE_COMMAND = m, qe.ParagraphNode = Pr, qe.REDO_COMMAND = y, qe.REMOVE_TEXT_COMMAND = f, qe.RootNode = ti, qe.SELECTION_CHANGE_COMMAND = r, qe.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = {}, qe.SELECT_ALL_COMMAND = K, qe.TabNode = Jo, qe.TextNode = To, qe.UNDO_COMMAND = R, qe.createCommand = function() {
    return {};
  }, qe.createEditor = function(l) {
    var e = l || {}, s = An, h = e.theme || {};
    let b = l === void 0 ? s : e.parentEditor || null, k = e.disableEvents || !1, V = br(), ce = e.namespace || (b !== null ? b._config.namespace : Ue()), xe = e.editorState, Ae = [ti, To, Go, Jo, Pr, ...e.nodes || []], { onError: it, html: st } = e;
    if (e = e.editable !== void 0 ? e.editable : !0, l === void 0 && s !== null)
      l = s._nodes;
    else
      for (l = /* @__PURE__ */ new Map(), s = 0; s < Ae.length; s++) {
        let Fe = Ae[s], pt = null;
        var Ve = null;
        typeof Fe != "function" && (Ve = Fe, Fe = Ve.replace, pt = Ve.with, Ve = Ve.withKlass || null);
        let Lt = Fe.getType(), Ut = Fe.transform(), Ft = /* @__PURE__ */ new Set();
        Ut !== null && Ft.add(Ut), l.set(Lt, { exportDOM: st && st.export ? st.export.get(Fe) : void 0, klass: Fe, replace: pt, replaceWithKlass: Ve, transforms: Ft });
      }
    return h = new Zs(V, b, l, { disableEvents: k, namespace: ce, theme: h }, it || console.error, Oi(l, st ? st.import : void 0), e), xe !== void 0 && (h._pendingEditorState = xe, h._dirtyType = 2), h;
  }, qe.getNearestEditorFromDOMNode = We, qe.isCurrentlyReadOnlyMode = zr, qe.isHTMLAnchorElement = function(l) {
    return Or(l) && l.tagName === "A";
  }, qe.isHTMLElement = Or, qe.isSelectionCapturedInDecoratorInput = $e, qe.isSelectionWithinEditor = Re, qe;
}
var Qa, Ju;
function St() {
  return Ju || (Ju = 1, Qa = process.env.NODE_ENV === "development" ? xp() : Ep()), Qa;
}
var Xu;
function Tp() {
  if (Xu)
    return Xa;
  Xu = 1;
  var r = zt(), n = St(), t = $t;
  const o = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  var p = o ? t.useLayoutEffect : t.useEffect;
  const m = {
    tag: "history-merge"
  };
  function f({
    initialConfig: S,
    children: E
  }) {
    const R = t.useMemo(
      () => {
        const {
          theme: y,
          namespace: g,
          editor__DEPRECATED: _,
          nodes: N,
          onError: w,
          editorState: T,
          html: D
        } = S, C = r.createLexicalComposerContext(null, y);
        let x = _ || null;
        if (x === null) {
          const I = n.createEditor({
            editable: S.editable,
            html: D,
            namespace: g,
            nodes: N,
            onError: (W) => w(W, I),
            theme: y
          });
          O(I, T), x = I;
        }
        return [x, C];
      },
      // We only do this for init
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    );
    return p(() => {
      const y = S.editable, [g] = R;
      g.setEditable(y !== void 0 ? y : !0);
    }, []), /* @__PURE__ */ t.createElement(r.LexicalComposerContext.Provider, {
      value: R
    }, E);
  }
  function O(S, E) {
    if (E !== null) {
      if (E === void 0)
        S.update(() => {
          const R = n.$getRoot();
          if (R.isEmpty()) {
            const y = n.$createParagraphNode();
            R.append(y);
            const g = o ? document.activeElement : null;
            (n.$getSelection() !== null || g !== null && g === S.getRootElement()) && y.select();
          }
        }, m);
      else if (E !== null)
        switch (typeof E) {
          case "string": {
            const R = S.parseEditorState(E);
            S.setEditorState(R, m);
            break;
          }
          case "object": {
            S.setEditorState(E, m);
            break;
          }
          case "function": {
            S.update(() => {
              n.$getRoot().isEmpty() && E(S);
            }, m);
            break;
          }
        }
    }
  }
  return Xa.LexicalComposer = f, Xa;
}
var ec = {}, Zu;
function yp() {
  if (Zu)
    return ec;
  Zu = 1;
  var r = zt(), n = St(), t = $t;
  let o = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  var u = o ? t.useLayoutEffect : t.useEffect;
  let p = { tag: "history-merge" };
  function m(f, O) {
    if (O !== null) {
      if (O === void 0)
        f.update(() => {
          var S = n.$getRoot();
          if (S.isEmpty()) {
            let E = n.$createParagraphNode();
            S.append(E), S = o ? document.activeElement : null, (n.$getSelection() !== null || S !== null && S === f.getRootElement()) && E.select();
          }
        }, p);
      else if (O !== null)
        switch (typeof O) {
          case "string":
            let S = f.parseEditorState(O);
            f.setEditorState(S, p);
            break;
          case "object":
            f.setEditorState(O, p);
            break;
          case "function":
            f.update(() => {
              n.$getRoot().isEmpty() && O(f);
            }, p);
        }
    }
  }
  return ec.LexicalComposer = function({ initialConfig: f, children: O }) {
    let S = t.useMemo(() => {
      const { theme: E, namespace: R, editor__DEPRECATED: y, nodes: g, onError: _, editorState: N, html: w } = f, T = r.createLexicalComposerContext(null, E);
      let D = y || null;
      if (D === null) {
        const C = n.createEditor({ editable: f.editable, html: w, namespace: R, nodes: g, onError: (x) => _(x, C), theme: E });
        m(C, N), D = C;
      }
      return [D, T];
    }, []);
    return u(() => {
      let E = f.editable, [R] = S;
      R.setEditable(E !== void 0 ? E : !0);
    }, []), t.createElement(
      r.LexicalComposerContext.Provider,
      { value: S },
      O
    );
  }, ec;
}
const Sp = process.env.NODE_ENV === "development" ? Tp() : yp();
var Op = Sp;
const vp = {
  blockCursor: "et_block-cursor",
  code: "et_code",
  characterLimit: "character-limit",
  embedBlock: {
    base: "et_embed-block",
    focus: "et_embed-block-focus"
  },
  hashtag: "et_hashtag",
  heading: {
    h1: "et_h1",
    h2: "et_h2",
    h3: "et_h3",
    h4: "et_h4",
    h5: "et_h5",
    h6: "et_h6"
  },
  image: "editor-image",
  indent: "et_indent",
  inlineImage: "inline-editor-image",
  layoutContainer: "et_layout-container",
  layoutItem: "et_layout-item",
  link: "et_link",
  list: {
    checklist: "et_checklist",
    listitem: "et_listitem",
    listitemChecked: "et_listitem-checked",
    listitemUnchecked: "et_listitem-unchecked",
    nested: {
      listitem: "et_nested-listitem"
    },
    olDepth: [
      "et_ol1",
      "et_ol2",
      "et_ol3",
      "et_ol4",
      "et_ol5"
    ],
    ul: "et_ul"
  },
  ltr: "et_ltr",
  mark: "et_mark",
  markOverlap: "et_mark-overlap",
  paragraph: "et_paragraph",
  quote: "et_quote",
  rtl: "et_rtl",
  table: "et_table",
  tableAddColumns: "et_table-add-columns",
  tableAddRows: "et_table-add-rows",
  tableCell: "et_table-cell",
  tableCellActionButton: "et_table-cell-action-button",
  tableCellActionButtonContainer: "et_table-cell-action-button-container",
  tableCellEditing: "et_table-cell-editing",
  tableCellHeader: "et_table-cell-header",
  tableCellPrimarySelected: "et_table-cell-primary-selected",
  tableCellResizer: "et_table-cell-resizer",
  tableCellSelected: "et_table-cell-selected",
  tableCellSortedIndicator: "et_table-cell-sorted-indicator",
  tableResizeRuler: "et_table-resize-ruler",
  tableSelected: "et_table-selected",
  tableSelection: "et_table-selection",
  text: {
    bold: "et_text-bold",
    code: "et_text-code",
    italic: "et_text-italic",
    strikethrough: "et_text-strikethrough",
    subscript: "et_text-subscript",
    superscript: "et_text-superscript",
    underline: "et_text-underline",
    underlineStrikethrough: "et_text-underline-strikethrough"
  },
  dataMention: "et_data-mention"
};
var kn = {}, tc = { exports: {} }, Qu;
function Lg() {
  return Qu || (Qu = 1, function(r) {
    var n = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
    /**
     * Prism: Lightweight, robust, elegant syntax highlighting
     *
     * @license MIT <https://opensource.org/licenses/MIT>
     * @author Lea Verou <https://lea.verou.me>
     * @namespace
     * @public
     */
    var t = function(o) {
      var u = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, p = 0, m = {}, f = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: o.Prism && o.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: o.Prism && o.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function D(C) {
            return C instanceof O ? new O(C.type, D(C.content), C.alias) : Array.isArray(C) ? C.map(D) : C.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(D) {
            return Object.prototype.toString.call(D).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(D) {
            return D.__id || Object.defineProperty(D, "__id", { value: ++p }), D.__id;
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function D(C, x) {
            x = x || {};
            var I, W;
            switch (f.util.type(C)) {
              case "Object":
                if (W = f.util.objId(C), x[W])
                  return x[W];
                I = /** @type {Record<string, any>} */
                {}, x[W] = I;
                for (var $ in C)
                  C.hasOwnProperty($) && (I[$] = D(C[$], x));
                return (
                  /** @type {any} */
                  I
                );
              case "Array":
                return W = f.util.objId(C), x[W] ? x[W] : (I = [], x[W] = I, /** @type {Array} */
                /** @type {any} */
                C.forEach(function(B, L) {
                  I[L] = D(B, x);
                }), /** @type {any} */
                I);
              default:
                return C;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(D) {
            for (; D; ) {
              var C = u.exec(D.className);
              if (C)
                return C[1].toLowerCase();
              D = D.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(D, C) {
            D.className = D.className.replace(RegExp(u, "gi"), ""), D.classList.add("language-" + C);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document > "u")
              return null;
            if ("currentScript" in document && 1 < 2)
              return (
                /** @type {any} */
                document.currentScript
              );
            try {
              throw new Error();
            } catch (I) {
              var D = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(I.stack) || [])[1];
              if (D) {
                var C = document.getElementsByTagName("script");
                for (var x in C)
                  if (C[x].src == D)
                    return C[x];
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(D, C, x) {
            for (var I = "no-" + C; D; ) {
              var W = D.classList;
              if (W.contains(C))
                return !0;
              if (W.contains(I))
                return !1;
              D = D.parentElement;
            }
            return !!x;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: m,
          plaintext: m,
          text: m,
          txt: m,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(D, C) {
            var x = f.util.clone(f.languages[D]);
            for (var I in C)
              x[I] = C[I];
            return x;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(D, C, x, I) {
            I = I || /** @type {any} */
            f.languages;
            var W = I[D], $ = {};
            for (var B in W)
              if (W.hasOwnProperty(B)) {
                if (B == C)
                  for (var L in x)
                    x.hasOwnProperty(L) && ($[L] = x[L]);
                x.hasOwnProperty(B) || ($[B] = W[B]);
              }
            var P = I[D];
            return I[D] = $, f.languages.DFS(f.languages, function(F, Z) {
              Z === P && F != D && (this[F] = $);
            }), $;
          },
          // Traverse a language definition with Depth First Search
          DFS: function D(C, x, I, W) {
            W = W || {};
            var $ = f.util.objId;
            for (var B in C)
              if (C.hasOwnProperty(B)) {
                x.call(C, B, C[B], I || B);
                var L = C[B], P = f.util.type(L);
                P === "Object" && !W[$(L)] ? (W[$(L)] = !0, D(L, x, null, W)) : P === "Array" && !W[$(L)] && (W[$(L)] = !0, D(L, x, B, W));
              }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prism’s API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(D, C) {
          f.highlightAllUnder(document, D, C);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(D, C, x) {
          var I = {
            callback: x,
            container: D,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          f.hooks.run("before-highlightall", I), I.elements = Array.prototype.slice.apply(I.container.querySelectorAll(I.selector)), f.hooks.run("before-all-elements-highlight", I);
          for (var W = 0, $; $ = I.elements[W++]; )
            f.highlightElement($, C === !0, I.callback);
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(D, C, x) {
          var I = f.util.getLanguage(D), W = f.languages[I];
          f.util.setLanguage(D, I);
          var $ = D.parentElement;
          $ && $.nodeName.toLowerCase() === "pre" && f.util.setLanguage($, I);
          var B = D.textContent, L = {
            element: D,
            language: I,
            grammar: W,
            code: B
          };
          function P(Z) {
            L.highlightedCode = Z, f.hooks.run("before-insert", L), L.element.innerHTML = L.highlightedCode, f.hooks.run("after-highlight", L), f.hooks.run("complete", L), x && x.call(L.element);
          }
          if (f.hooks.run("before-sanity-check", L), $ = L.element.parentElement, $ && $.nodeName.toLowerCase() === "pre" && !$.hasAttribute("tabindex") && $.setAttribute("tabindex", "0"), !L.code) {
            f.hooks.run("complete", L), x && x.call(L.element);
            return;
          }
          if (f.hooks.run("before-highlight", L), !L.grammar) {
            P(f.util.encode(L.code));
            return;
          }
          if (C && o.Worker) {
            var F = new Worker(f.filename);
            F.onmessage = function(Z) {
              P(Z.data);
            }, F.postMessage(JSON.stringify({
              language: L.language,
              code: L.code,
              immediateClose: !0
            }));
          } else
            P(f.highlight(L.code, L.grammar, L.language));
        },
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(D, C, x) {
          var I = {
            code: D,
            grammar: C,
            language: x
          };
          if (f.hooks.run("before-tokenize", I), !I.grammar)
            throw new Error('The language "' + I.language + '" has no grammar.');
          return I.tokens = f.tokenize(I.code, I.grammar), f.hooks.run("after-tokenize", I), O.stringify(f.util.encode(I.tokens), I.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(D, C) {
          var x = C.rest;
          if (x) {
            for (var I in x)
              C[I] = x[I];
            delete C.rest;
          }
          var W = new R();
          return y(W, W.head, D), E(D, W, C, W.head, 0), _(W);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(D, C) {
            var x = f.hooks.all;
            x[D] = x[D] || [], x[D].push(C);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(D, C) {
            var x = f.hooks.all[D];
            if (!(!x || !x.length))
              for (var I = 0, W; W = x[I++]; )
                W(C);
          }
        },
        Token: O
      };
      o.Prism = f;
      function O(D, C, x, I) {
        this.type = D, this.content = C, this.alias = x, this.length = (I || "").length | 0;
      }
      O.stringify = function D(C, x) {
        if (typeof C == "string")
          return C;
        if (Array.isArray(C)) {
          var I = "";
          return C.forEach(function(P) {
            I += D(P, x);
          }), I;
        }
        var W = {
          type: C.type,
          content: D(C.content, x),
          tag: "span",
          classes: ["token", C.type],
          attributes: {},
          language: x
        }, $ = C.alias;
        $ && (Array.isArray($) ? Array.prototype.push.apply(W.classes, $) : W.classes.push($)), f.hooks.run("wrap", W);
        var B = "";
        for (var L in W.attributes)
          B += " " + L + '="' + (W.attributes[L] || "").replace(/"/g, "&quot;") + '"';
        return "<" + W.tag + ' class="' + W.classes.join(" ") + '"' + B + ">" + W.content + "</" + W.tag + ">";
      };
      function S(D, C, x, I) {
        D.lastIndex = C;
        var W = D.exec(x);
        if (W && I && W[1]) {
          var $ = W[1].length;
          W.index += $, W[0] = W[0].slice($);
        }
        return W;
      }
      function E(D, C, x, I, W, $) {
        for (var B in x)
          if (!(!x.hasOwnProperty(B) || !x[B])) {
            var L = x[B];
            L = Array.isArray(L) ? L : [L];
            for (var P = 0; P < L.length; ++P) {
              if ($ && $.cause == B + "," + P)
                return;
              var F = L[P], Z = F.inside, oe = !!F.lookbehind, ne = !!F.greedy, te = F.alias;
              if (ne && !F.pattern.global) {
                var K = F.pattern.toString().match(/[imsuy]*$/)[0];
                F.pattern = RegExp(F.pattern.source, K + "g");
              }
              for (var A = F.pattern || F, z = I.next, ie = W; z !== C.tail && !($ && ie >= $.reach); ie += z.value.length, z = z.next) {
                var q = z.value;
                if (C.length > D.length)
                  return;
                if (!(q instanceof O)) {
                  var Y = 1, se;
                  if (ne) {
                    if (se = S(A, ie, D, oe), !se || se.index >= D.length)
                      break;
                    var de = se.index, j = se.index + se[0].length, Q = ie;
                    for (Q += z.value.length; de >= Q; )
                      z = z.next, Q += z.value.length;
                    if (Q -= z.value.length, ie = Q, z.value instanceof O)
                      continue;
                    for (var ae = z; ae !== C.tail && (Q < j || typeof ae.value == "string"); ae = ae.next)
                      Y++, Q += ae.value.length;
                    Y--, q = D.slice(ie, Q), se.index -= ie;
                  } else if (se = S(A, 0, q, oe), !se)
                    continue;
                  var de = se.index, Ne = se[0], De = q.slice(0, de), Pe = q.slice(de + Ne.length), Le = ie + q.length;
                  $ && Le > $.reach && ($.reach = Le);
                  var ke = z.prev;
                  De && (ke = y(C, ke, De), ie += De.length), g(C, ke, Y);
                  var J = new O(B, Z ? f.tokenize(Ne, Z) : Ne, te, Ne);
                  if (z = y(C, ke, J), Pe && y(C, z, Pe), Y > 1) {
                    var G = {
                      cause: B + "," + P,
                      reach: Le
                    };
                    E(D, C, x, z.prev, ie, G), $ && G.reach > $.reach && ($.reach = G.reach);
                  }
                }
              }
            }
          }
      }
      function R() {
        var D = { value: null, prev: null, next: null }, C = { value: null, prev: D, next: null };
        D.next = C, this.head = D, this.tail = C, this.length = 0;
      }
      function y(D, C, x) {
        var I = C.next, W = { value: x, prev: C, next: I };
        return C.next = W, I.prev = W, D.length++, W;
      }
      function g(D, C, x) {
        for (var I = C.next, W = 0; W < x && I !== D.tail; W++)
          I = I.next;
        C.next = I, I.prev = C, D.length -= W;
      }
      function _(D) {
        for (var C = [], x = D.head.next; x !== D.tail; )
          C.push(x.value), x = x.next;
        return C;
      }
      if (!o.document)
        return o.addEventListener && (f.disableWorkerMessageHandler || o.addEventListener("message", function(D) {
          var C = JSON.parse(D.data), x = C.language, I = C.code, W = C.immediateClose;
          o.postMessage(f.highlight(I, f.languages[x], x)), W && o.close();
        }, !1)), f;
      var N = f.util.currentScript();
      N && (f.filename = N.src, N.hasAttribute("data-manual") && (f.manual = !0));
      function w() {
        f.manual || f.highlightAll();
      }
      if (!f.manual) {
        var T = document.readyState;
        T === "loading" || T === "interactive" && N && N.defer ? document.addEventListener("DOMContentLoaded", w) : window.requestAnimationFrame ? window.requestAnimationFrame(w) : window.setTimeout(w, 16);
      }
      return f;
    }(n);
    r.exports && (r.exports = t), typeof Oa < "u" && (Oa.Prism = t), t.languages.markup = {
      comment: {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: !0
      },
      prolog: {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: !0
      },
      doctype: {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: !0,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: !0,
            greedy: !0,
            inside: null
            // see below
          },
          string: {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: !0
          },
          punctuation: /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          name: /[^\s<>'"]+/
        }
      },
      cdata: {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: !0
      },
      tag: {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: !0,
        inside: {
          tag: {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              punctuation: /^<\/?/,
              namespace: /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: !0
                }
              ]
            }
          },
          punctuation: /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              namespace: /^[^\s>\/:]+:/
            }
          }
        }
      },
      entity: [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    }, t.languages.markup.tag.inside["attr-value"].inside.entity = t.languages.markup.entity, t.languages.markup.doctype.inside["internal-subset"].inside = t.languages.markup, t.hooks.add("wrap", function(o) {
      o.type === "entity" && (o.attributes.title = o.content.replace(/&amp;/, "&"));
    }), Object.defineProperty(t.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function(u, p) {
        var m = {};
        m["language-" + p] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: !0,
          inside: t.languages[p]
        }, m.cdata = /^<!\[CDATA\[|\]\]>$/i;
        var f = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: m
          }
        };
        f["language-" + p] = {
          pattern: /[\s\S]+/,
          inside: t.languages[p]
        };
        var O = {};
        O[u] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return u;
          }), "i"),
          lookbehind: !0,
          greedy: !0,
          inside: f
        }, t.languages.insertBefore("markup", "cdata", O);
      }
    }), Object.defineProperty(t.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(o, u) {
        t.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + o + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: !0,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                value: {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: !0,
                  alias: [u, "language-" + u],
                  inside: t.languages[u]
                },
                punctuation: [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    }), t.languages.html = t.languages.markup, t.languages.mathml = t.languages.markup, t.languages.svg = t.languages.markup, t.languages.xml = t.languages.extend("markup", {}), t.languages.ssml = t.languages.xml, t.languages.atom = t.languages.xml, t.languages.rss = t.languages.xml, function(o) {
      var u = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      o.languages.css = {
        comment: /\/\*[\s\S]*?\*\//,
        atrule: {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + u.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            rule: /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: !0,
              alias: "selector"
            },
            keyword: {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: !0
            }
            // See rest below
          }
        },
        url: {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + u.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: !0,
          inside: {
            function: /^url/i,
            punctuation: /^\(|\)$/,
            string: {
              pattern: RegExp("^" + u.source + "$"),
              alias: "url"
            }
          }
        },
        selector: {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + u.source + ")*(?=\\s*\\{)"),
          lookbehind: !0
        },
        string: {
          pattern: u,
          greedy: !0
        },
        property: {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: !0
        },
        important: /!important\b/i,
        function: {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: !0
        },
        punctuation: /[(){};:,]/
      }, o.languages.css.atrule.inside.rest = o.languages.css;
      var p = o.languages.markup;
      p && (p.tag.addInlined("style", "css"), p.tag.addAttribute("style", "css"));
    }(t), t.languages.clike = {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: {
          punctuation: /[.\\]/
        }
      },
      keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b\w+(?=\()/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      punctuation: /[{}[\];(),.:]/
    }, t.languages.javascript = t.languages.extend("clike", {
      "class-name": [
        t.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: !0
        }
      ],
      keyword: [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: !0
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: !0
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      number: {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: !0
      },
      operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    }), t.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, t.languages.insertBefore("javascript", "keyword", {
      regex: {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: !0,
            alias: "language-regex",
            inside: t.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      parameter: [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: !0,
          inside: t.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: !0,
          inside: t.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: !0,
          inside: t.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: !0,
          inside: t.languages.javascript
        }
      ],
      constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    }), t.languages.insertBefore("javascript", "string", {
      hashbang: {
        pattern: /^#!.*/,
        greedy: !0,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: !0,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: !0,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: t.languages.javascript
            }
          },
          string: /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      }
    }), t.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: !0,
        alias: "property"
      }
    }), t.languages.markup && (t.languages.markup.tag.addInlined("script", "javascript"), t.languages.markup.tag.addAttribute(
      /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
      "javascript"
    )), t.languages.js = t.languages.javascript, function() {
      if (typeof t > "u" || typeof document > "u")
        return;
      Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
      var o = "Loading…", u = function(N, w) {
        return "✖ Error " + N + " while fetching file: " + w;
      }, p = "✖ Error: File does not exist or is empty", m = {
        js: "javascript",
        py: "python",
        rb: "ruby",
        ps1: "powershell",
        psm1: "powershell",
        sh: "bash",
        bat: "batch",
        h: "c",
        tex: "latex"
      }, f = "data-src-status", O = "loading", S = "loaded", E = "failed", R = "pre[data-src]:not([" + f + '="' + S + '"]):not([' + f + '="' + O + '"])';
      function y(N, w, T) {
        var D = new XMLHttpRequest();
        D.open("GET", N, !0), D.onreadystatechange = function() {
          D.readyState == 4 && (D.status < 400 && D.responseText ? w(D.responseText) : D.status >= 400 ? T(u(D.status, D.statusText)) : T(p));
        }, D.send(null);
      }
      function g(N) {
        var w = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(N || "");
        if (w) {
          var T = Number(w[1]), D = w[2], C = w[3];
          return D ? C ? [T, Number(C)] : [T, void 0] : [T, T];
        }
      }
      t.hooks.add("before-highlightall", function(N) {
        N.selector += ", " + R;
      }), t.hooks.add("before-sanity-check", function(N) {
        var w = (
          /** @type {HTMLPreElement} */
          N.element
        );
        if (w.matches(R)) {
          N.code = "", w.setAttribute(f, O);
          var T = w.appendChild(document.createElement("CODE"));
          T.textContent = o;
          var D = w.getAttribute("data-src"), C = N.language;
          if (C === "none") {
            var x = (/\.(\w+)$/.exec(D) || [, "none"])[1];
            C = m[x] || x;
          }
          t.util.setLanguage(T, C), t.util.setLanguage(w, C);
          var I = t.plugins.autoloader;
          I && I.loadLanguages(C), y(
            D,
            function(W) {
              w.setAttribute(f, S);
              var $ = g(w.getAttribute("data-range"));
              if ($) {
                var B = W.split(/\r\n?|\n/g), L = $[0], P = $[1] == null ? B.length : $[1];
                L < 0 && (L += B.length), L = Math.max(0, Math.min(L - 1, B.length)), P < 0 && (P += B.length), P = Math.max(0, Math.min(P, B.length)), W = B.slice(L, P).join(`
`), w.hasAttribute("data-start") || w.setAttribute("data-start", String(L + 1));
              }
              T.textContent = W, t.highlightElement(T);
            },
            function(W) {
              w.setAttribute(f, E), T.textContent = W;
            }
          );
        }
      }), t.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function(w) {
          for (var T = (w || document).querySelectorAll(R), D = 0, C; C = T[D++]; )
            t.highlightElement(C);
        }
      };
      var _ = !1;
      t.fileHighlight = function() {
        _ || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), _ = !0), t.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    }();
  }(tc)), tc.exports;
}
var ed = {}, td;
function Ig() {
  return td || (td = 1, Prism.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: !0,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  }), ed;
}
var nd = {}, rd;
function $g() {
  return rd || (rd = 1, Prism.languages.javascript = Prism.languages.extend("clike", {
    "class-name": [
      Prism.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: !0
      }
    ],
    keyword: [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: !0
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: !0
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  }), Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, Prism.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: !0,
          alias: "language-regex",
          inside: Prism.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    parameter: [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: !0,
        inside: Prism.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: !0,
        inside: Prism.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: !0,
        inside: Prism.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: !0,
        inside: Prism.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  }), Prism.languages.insertBefore("javascript", "string", {
    hashbang: {
      pattern: /^#!.*/,
      greedy: !0,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: !0,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: Prism.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    }
  }), Prism.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: !0,
      alias: "property"
    }
  }), Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), Prism.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  )), Prism.languages.js = Prism.languages.javascript), nd;
}
var od = {}, id;
function kg() {
  return id || (id = 1, Prism.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: !0
              }
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function(r) {
    r.type === "entity" && (r.attributes.title = r.content.replace(/&amp;/, "&"));
  }), Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function(n, t) {
      var o = {};
      o["language-" + t] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: Prism.languages[t]
      }, o.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var u = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: o
        }
      };
      u["language-" + t] = {
        pattern: /[\s\S]+/,
        inside: Prism.languages[t]
      };
      var p = {};
      p[n] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return n;
        }), "i"),
        lookbehind: !0,
        greedy: !0,
        inside: u
      }, Prism.languages.insertBefore("markup", "cdata", p);
    }
  }), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(r, n) {
      Prism.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + r + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [n, "language-" + n],
                inside: Prism.languages[n]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml), od;
}
var sd = {}, ld;
function Pg() {
  return ld || (ld = 1, function(r) {
    var n = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
    function t(E) {
      return E = E.replace(/<inner>/g, function() {
        return n;
      }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + E + ")");
    }
    var o = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, u = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
      return o;
    }), p = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
    r.languages.markdown = r.languages.extend("markup", {}), r.languages.insertBefore("markdown", "prolog", {
      "front-matter-block": {
        pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          punctuation: /^---|---$/,
          "front-matter": {
            pattern: /\S+(?:\s+\S+)*/,
            alias: ["yaml", "language-yaml"],
            inside: r.languages.yaml
          }
        }
      },
      blockquote: {
        // > ...
        pattern: /^>(?:[\t ]*>)*/m,
        alias: "punctuation"
      },
      table: {
        pattern: RegExp("^" + u + p + "(?:" + u + ")*", "m"),
        inside: {
          "table-data-rows": {
            pattern: RegExp("^(" + u + p + ")(?:" + u + ")*$"),
            lookbehind: !0,
            inside: {
              "table-data": {
                pattern: RegExp(o),
                inside: r.languages.markdown
              },
              punctuation: /\|/
            }
          },
          "table-line": {
            pattern: RegExp("^(" + u + ")" + p + "$"),
            lookbehind: !0,
            inside: {
              punctuation: /\||:?-{3,}:?/
            }
          },
          "table-header-row": {
            pattern: RegExp("^" + u + "$"),
            inside: {
              "table-header": {
                pattern: RegExp(o),
                alias: "important",
                inside: r.languages.markdown
              },
              punctuation: /\|/
            }
          }
        }
      },
      code: [
        {
          // Prefixed by 4 spaces or 1 tab and preceded by an empty line
          pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
          lookbehind: !0,
          alias: "keyword"
        },
        {
          // ```optional language
          // code block
          // ```
          pattern: /^```[\s\S]*?^```$/m,
          greedy: !0,
          inside: {
            "code-block": {
              pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
              lookbehind: !0
            },
            "code-language": {
              pattern: /^(```).+/,
              lookbehind: !0
            },
            punctuation: /```/
          }
        }
      ],
      title: [
        {
          // title 1
          // =======
          // title 2
          // -------
          pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
          alias: "important",
          inside: {
            punctuation: /==+$|--+$/
          }
        },
        {
          // # title 1
          // ###### title 6
          pattern: /(^\s*)#.+/m,
          lookbehind: !0,
          alias: "important",
          inside: {
            punctuation: /^#+|#+$/
          }
        }
      ],
      hr: {
        // ***
        // ---
        // * * *
        // -----------
        pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
        lookbehind: !0,
        alias: "punctuation"
      },
      list: {
        // * item
        // + item
        // - item
        // 1. item
        pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
        lookbehind: !0,
        alias: "punctuation"
      },
      "url-reference": {
        // [id]: http://example.com "Optional title"
        // [id]: http://example.com 'Optional title'
        // [id]: http://example.com (Optional title)
        // [id]: <http://example.com> "Optional title"
        pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
        inside: {
          variable: {
            pattern: /^(!?\[)[^\]]+/,
            lookbehind: !0
          },
          string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
          punctuation: /^[\[\]!:]|[<>]/
        },
        alias: "url"
      },
      bold: {
        // **strong**
        // __strong__
        // allow one nested instance of italic text using the same delimiter
        pattern: t(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: {
            pattern: /(^..)[\s\S]+(?=..$)/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          punctuation: /\*\*|__/
        }
      },
      italic: {
        // *em*
        // _em_
        // allow one nested instance of bold text using the same delimiter
        pattern: t(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: {
            pattern: /(^.)[\s\S]+(?=.$)/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          punctuation: /[*_]/
        }
      },
      strike: {
        // ~~strike through~~
        // ~strike~
        // eslint-disable-next-line regexp/strict
        pattern: t(/(~~?)(?:(?!~)<inner>)+\2/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: {
            pattern: /(^~~?)[\s\S]+(?=\1$)/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          punctuation: /~~?/
        }
      },
      "code-snippet": {
        // `code`
        // ``code``
        pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
        lookbehind: !0,
        greedy: !0,
        alias: ["code", "keyword"]
      },
      url: {
        // [example](http://example.com "Optional title")
        // [example][id]
        // [example] [id]
        pattern: t(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          operator: /^!/,
          content: {
            pattern: /(^\[)[^\]]+(?=\])/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          variable: {
            pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
            lookbehind: !0
          },
          url: {
            pattern: /(^\]\()[^\s)]+/,
            lookbehind: !0
          },
          string: {
            pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
            lookbehind: !0
          }
        }
      }
    }), ["url", "bold", "italic", "strike"].forEach(function(E) {
      ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(R) {
        E !== R && (r.languages.markdown[E].inside.content.inside[R] = r.languages.markdown[R]);
      });
    }), r.hooks.add("after-tokenize", function(E) {
      if (E.language !== "markdown" && E.language !== "md")
        return;
      function R(y) {
        if (!(!y || typeof y == "string"))
          for (var g = 0, _ = y.length; g < _; g++) {
            var N = y[g];
            if (N.type !== "code") {
              R(N.content);
              continue;
            }
            var w = N.content[1], T = N.content[3];
            if (w && T && w.type === "code-language" && T.type === "code-block" && typeof w.content == "string") {
              var D = w.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
              D = (/[a-z][\w-]*/i.exec(D) || [""])[0].toLowerCase();
              var C = "language-" + D;
              T.alias ? typeof T.alias == "string" ? T.alias = [T.alias, C] : T.alias.push(C) : T.alias = [C];
            }
          }
      }
      R(E.tokens);
    }), r.hooks.add("wrap", function(E) {
      if (E.type === "code-block") {
        for (var R = "", y = 0, g = E.classes.length; y < g; y++) {
          var _ = E.classes[y], N = /language-(.+)/.exec(_);
          if (N) {
            R = N[1];
            break;
          }
        }
        var w = r.languages[R];
        if (w)
          E.content = r.highlight(S(E.content), w, R);
        else if (R && R !== "none" && r.plugins.autoloader) {
          var T = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
          E.attributes.id = T, r.plugins.autoloader.loadLanguages(R, function() {
            var D = document.getElementById(T);
            D && (D.innerHTML = r.highlight(D.textContent, r.languages[R], R));
          });
        }
      }
    });
    var m = RegExp(r.languages.markup.tag.pattern.source, "gi"), f = {
      amp: "&",
      lt: "<",
      gt: ">",
      quot: '"'
    }, O = String.fromCodePoint || String.fromCharCode;
    function S(E) {
      var R = E.replace(m, "");
      return R = R.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(y, g) {
        if (g = g.toLowerCase(), g[0] === "#") {
          var _;
          return g[1] === "x" ? _ = parseInt(g.slice(2), 16) : _ = Number(g.slice(1)), O(_);
        } else {
          var N = f[g];
          return N || y;
        }
      }), R;
    }
    r.languages.md = r.languages.markdown;
  }(Prism)), sd;
}
var ad = {}, cd;
function Fg() {
  return cd || (cd = 1, Prism.languages.c = Prism.languages.extend("clike", {
    comment: {
      pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: !0
    },
    string: {
      // https://en.cppreference.com/w/c/language/string_literal
      pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
      lookbehind: !0
    },
    keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
  }), Prism.languages.insertBefore("c", "string", {
    char: {
      // https://en.cppreference.com/w/c/language/character_constant
      pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
      greedy: !0
    }
  }), Prism.languages.insertBefore("c", "string", {
    macro: {
      // allow for multiline macro definitions
      // spaces after the # character compile fine with gcc
      pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
      lookbehind: !0,
      greedy: !0,
      alias: "property",
      inside: {
        string: [
          {
            // highlight the path of the include statement as a string
            pattern: /^(#\s*include\s*)<[^>]+>/,
            lookbehind: !0
          },
          Prism.languages.c.string
        ],
        char: Prism.languages.c.char,
        comment: Prism.languages.c.comment,
        "macro-name": [
          {
            pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
            lookbehind: !0
          },
          {
            pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
            lookbehind: !0,
            alias: "function"
          }
        ],
        // highlight macro directives as keywords
        directive: {
          pattern: /^(#\s*)[a-z]+/,
          lookbehind: !0,
          alias: "keyword"
        },
        "directive-hash": /^#/,
        punctuation: /##|\\(?=[\r\n])/,
        expression: {
          pattern: /\S[\s\S]*/,
          inside: Prism.languages.c
        }
      }
    }
  }), Prism.languages.insertBefore("c", "function", {
    // highlight predefined macros as constants
    constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
  }), delete Prism.languages.c.boolean), ad;
}
var ud = {}, dd;
function Bg() {
  return dd || (dd = 1, function(r) {
    var n = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    r.languages.css = {
      comment: /\/\*[\s\S]*?\*\//,
      atrule: {
        pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + n.source + ")*?" + /(?:;|(?=\s*\{))/.source),
        inside: {
          rule: /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: !0,
            alias: "selector"
          },
          keyword: {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: !0
          }
          // See rest below
        }
      },
      url: {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp("\\burl\\((?:" + n.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: !0,
        inside: {
          function: /^url/i,
          punctuation: /^\(|\)$/,
          string: {
            pattern: RegExp("^" + n.source + "$"),
            alias: "url"
          }
        }
      },
      selector: {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + n.source + ")*(?=\\s*\\{)"),
        lookbehind: !0
      },
      string: {
        pattern: n,
        greedy: !0
      },
      property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: !0
      },
      important: /!important\b/i,
      function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: !0
      },
      punctuation: /[(){};:,]/
    }, r.languages.css.atrule.inside.rest = r.languages.css;
    var t = r.languages.markup;
    t && (t.tag.addInlined("style", "css"), t.tag.addAttribute("style", "css"));
  }(Prism)), ud;
}
var fd = {}, gd;
function Kg() {
  return gd || (gd = 1, Prism.languages.objectivec = Prism.languages.extend("c", {
    string: {
      pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: !0
    },
    keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
    operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
  }), delete Prism.languages.objectivec["class-name"], Prism.languages.objc = Prism.languages.objectivec), fd;
}
var hd = {}, pd;
function jg() {
  return pd || (pd = 1, Prism.languages.sql = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
      lookbehind: !0
    },
    variable: [
      {
        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
        greedy: !0
      },
      /@[\w.$]+/
    ],
    string: {
      pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
      greedy: !0,
      lookbehind: !0
    },
    identifier: {
      pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
      greedy: !0,
      lookbehind: !0,
      inside: {
        punctuation: /^`|`$/
      }
    },
    function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    // Should we highlight user defined functions too?
    keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
    number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    punctuation: /[;[\]()`,.]/
  }), hd;
}
var md = {}, _d;
function Hg() {
  return _d || (_d = 1, Prism.languages.python = {
    comment: {
      pattern: /(^|[^\\])#.*/,
      lookbehind: !0,
      greedy: !0
    },
    "string-interpolation": {
      pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
      greedy: !0,
      inside: {
        interpolation: {
          // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
          pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
          lookbehind: !0,
          inside: {
            "format-spec": {
              pattern: /(:)[^:(){}]+(?=\}$)/,
              lookbehind: !0
            },
            "conversion-option": {
              pattern: /![sra](?=[:}]$)/,
              alias: "punctuation"
            },
            rest: null
          }
        },
        string: /[\s\S]+/
      }
    },
    "triple-quoted-string": {
      pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
      greedy: !0,
      alias: "string"
    },
    string: {
      pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
      greedy: !0
    },
    function: {
      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
      lookbehind: !0
    },
    "class-name": {
      pattern: /(\bclass\s+)\w+/i,
      lookbehind: !0
    },
    decorator: {
      pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
      lookbehind: !0,
      alias: ["annotation", "punctuation"],
      inside: {
        punctuation: /\./
      }
    },
    keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    boolean: /\b(?:False|None|True)\b/,
    number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
    operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    punctuation: /[{}[\];(),.:]/
  }, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python), md;
}
var Nd = {}, Cd;
function Wg() {
  return Cd || (Cd = 1, function(r) {
    for (var n = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, t = 0; t < 2; t++)
      n = n.replace(/<self>/g, function() {
        return n;
      });
    n = n.replace(/<self>/g, function() {
      return /[^\s\S]/.source;
    }), r.languages.rust = {
      comment: [
        {
          pattern: RegExp(/(^|[^\\])/.source + n),
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
        greedy: !0
      },
      char: {
        pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
        greedy: !0
      },
      attribute: {
        pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
        greedy: !0,
        alias: "attr-name",
        inside: {
          string: null
          // see below
        }
      },
      // Closure params should not be confused with bitwise OR |
      "closure-params": {
        pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          "closure-punctuation": {
            pattern: /^\||\|$/,
            alias: "punctuation"
          },
          rest: null
          // see below
        }
      },
      "lifetime-annotation": {
        pattern: /'\w+/,
        alias: "symbol"
      },
      "fragment-specifier": {
        pattern: /(\$\w+:)[a-z]+/,
        lookbehind: !0,
        alias: "punctuation"
      },
      variable: /\$\w+/,
      "function-definition": {
        pattern: /(\bfn\s+)\w+/,
        lookbehind: !0,
        alias: "function"
      },
      "type-definition": {
        pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
        lookbehind: !0,
        alias: "class-name"
      },
      "module-declaration": [
        {
          pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
          lookbehind: !0,
          alias: "namespace"
        },
        {
          pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
          lookbehind: !0,
          alias: "namespace",
          inside: {
            punctuation: /::/
          }
        }
      ],
      keyword: [
        // https://github.com/rust-lang/reference/blob/master/src/keywords.md
        /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
        // primitives and str
        // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
        /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
      ],
      // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
      // and Rust's naming conventions recommend snake_case anyway.
      // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
      function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
      macro: {
        pattern: /\b\w+!/,
        alias: "property"
      },
      constant: /\b[A-Z_][A-Z_\d]+\b/,
      "class-name": /\b[A-Z]\w*\b/,
      namespace: {
        pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
        inside: {
          punctuation: /::/
        }
      },
      // Hex, oct, bin, dec numbers with visual separators and type suffix
      number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
      boolean: /\b(?:false|true)\b/,
      punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
      operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
    }, r.languages.rust["closure-params"].inside.rest = r.languages.rust, r.languages.rust.attribute.inside.string = r.languages.rust.string;
  }(Prism)), Nd;
}
var xd = {}, Ed;
function Ug() {
  return Ed || (Ed = 1, Prism.languages.swift = {
    comment: {
      // Nested comments are supported up to 2 levels
      pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
      lookbehind: !0,
      greedy: !0
    },
    "string-literal": [
      // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
      {
        pattern: RegExp(
          /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\\($/,
            alias: "punctuation"
          },
          punctuation: /\\(?=[\r\n])/,
          string: /[\s\S]+/
        }
      },
      {
        pattern: RegExp(
          /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\#+\($/,
            alias: "punctuation"
          },
          string: /[\s\S]+/
        }
      }
    ],
    directive: {
      // directives with conditions
      pattern: RegExp(
        /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
      ),
      alias: "property",
      inside: {
        "directive-name": /^#\w+/,
        boolean: /\b(?:false|true)\b/,
        number: /\b\d+(?:\.\d+)*\b/,
        operator: /!|&&|\|\||[<>]=?/,
        punctuation: /[(),]/
      }
    },
    literal: {
      pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
      alias: "constant"
    },
    "other-directive": {
      pattern: /#\w+\b/,
      alias: "property"
    },
    attribute: {
      pattern: /@\w+/,
      alias: "atrule"
    },
    "function-definition": {
      pattern: /(\bfunc\s+)\w+/,
      lookbehind: !0,
      alias: "function"
    },
    label: {
      // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
      pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
      lookbehind: !0,
      alias: "important"
    },
    keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
    boolean: /\b(?:false|true)\b/,
    nil: {
      pattern: /\bnil\b/,
      alias: "constant"
    },
    "short-argument": /\$\d+\b/,
    omit: {
      pattern: /\b_\b/,
      alias: "keyword"
    },
    number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
    // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
    "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
    // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
    // This regex only supports ASCII operators.
    operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
    punctuation: /[{}[\]();,.:\\]/
  }, Prism.languages.swift["string-literal"].forEach(function(r) {
    r.inside.interpolation.inside = Prism.languages.swift;
  })), xd;
}
var Td = {}, yd;
function Yg() {
  return yd || (yd = 1, function(r) {
    r.languages.typescript = r.languages.extend("javascript", {
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
        lookbehind: !0,
        greedy: !0,
        inside: null
        // see below
      },
      builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
    }), r.languages.typescript.keyword.push(
      /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
      // keywords that have to be followed by an identifier
      /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
      // This is for `import type *, {}`
      /\btype\b(?=\s*(?:[\{*]|$))/
    ), delete r.languages.typescript.parameter, delete r.languages.typescript["literal-property"];
    var n = r.languages.extend("typescript", {});
    delete n["class-name"], r.languages.typescript["class-name"].inside = n, r.languages.insertBefore("typescript", "function", {
      decorator: {
        pattern: /@[$\w\xA0-\uFFFF]+/,
        inside: {
          at: {
            pattern: /^@/,
            alias: "operator"
          },
          function: /^[\s\S]+/
        }
      },
      "generic-function": {
        // e.g. foo<T extends "bar" | "baz">( ...
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
        greedy: !0,
        inside: {
          function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
          generic: {
            pattern: /<[\s\S]+/,
            // everything after the first <
            alias: "class-name",
            inside: n
          }
        }
      }
    }), r.languages.ts = r.languages.typescript;
  }(Prism)), Td;
}
var Sd = {}, Od;
function zg() {
  return Od || (Od = 1, function(r) {
    var n = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/, t = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, o = {
      pattern: RegExp(/(^|[^\w.])/.source + t + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
      lookbehind: !0,
      inside: {
        namespace: {
          pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
          inside: {
            punctuation: /\./
          }
        },
        punctuation: /\./
      }
    };
    r.languages.java = r.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
        lookbehind: !0,
        greedy: !0
      },
      "class-name": [
        o,
        {
          // variables, parameters, and constructor references
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(^|[^\w.])/.source + t + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
          lookbehind: !0,
          inside: o.inside
        },
        {
          // class names based on keyword
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + t + /[A-Z]\w*\b/.source),
          lookbehind: !0,
          inside: o.inside
        }
      ],
      keyword: n,
      function: [
        r.languages.clike.function,
        {
          pattern: /(::\s*)[a-z_]\w*/,
          lookbehind: !0
        }
      ],
      number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
      operator: {
        pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
        lookbehind: !0
      },
      constant: /\b[A-Z][A-Z_\d]+\b/
    }), r.languages.insertBefore("java", "string", {
      "triple-quoted-string": {
        // http://openjdk.java.net/jeps/355#Description
        pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
        greedy: !0,
        alias: "string"
      },
      char: {
        pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
        greedy: !0
      }
    }), r.languages.insertBefore("java", "class-name", {
      annotation: {
        pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
        lookbehind: !0,
        alias: "punctuation"
      },
      generics: {
        pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
        inside: {
          "class-name": o,
          keyword: n,
          punctuation: /[<>(),.:]/,
          operator: /[?&|]/
        }
      },
      import: [
        {
          pattern: RegExp(/(\bimport\s+)/.source + t + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
          lookbehind: !0,
          inside: {
            namespace: o.inside.namespace,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        },
        {
          pattern: RegExp(/(\bimport\s+static\s+)/.source + t + /(?:\w+|\*)(?=\s*;)/.source),
          lookbehind: !0,
          alias: "static",
          inside: {
            namespace: o.inside.namespace,
            static: /\b\w+$/,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        }
      ],
      namespace: {
        pattern: RegExp(
          /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
            return n.source;
          })
        ),
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      }
    });
  }(Prism)), Sd;
}
var vd = {}, wd;
function qg() {
  return wd || (wd = 1, function(r) {
    var n = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, t = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
      return n.source;
    });
    r.languages.cpp = r.languages.extend("c", {
      "class-name": [
        {
          pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
            return n.source;
          })),
          lookbehind: !0
        },
        // This is intended to capture the class name of method implementations like:
        //   void foo::bar() const {}
        // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
        // it starts with an uppercase letter. This approximation should give decent results.
        /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
        // This will capture the class name before destructors like:
        //   Foo::~Foo() {}
        /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
        // This also intends to capture the class name of method implementations but here the class has template
        // parameters, so it can't be a namespace (until C++ adds generic namespaces).
        /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
      ],
      keyword: n,
      number: {
        pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
        greedy: !0
      },
      operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
      boolean: /\b(?:false|true)\b/
    }), r.languages.insertBefore("cpp", "string", {
      module: {
        // https://en.cppreference.com/w/cpp/language/modules
        pattern: RegExp(
          /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
          /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
          /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
            return t;
          }) + ")"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          string: /^[<"][\s\S]+/,
          operator: /:/,
          punctuation: /\./
        }
      },
      "raw-string": {
        pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
        alias: "string",
        greedy: !0
      }
    }), r.languages.insertBefore("cpp", "keyword", {
      "generic-function": {
        pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
        inside: {
          function: /^\w+/,
          generic: {
            pattern: /<[\s\S]+/,
            alias: "class-name",
            inside: r.languages.cpp
          }
        }
      }
    }), r.languages.insertBefore("cpp", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    }), r.languages.insertBefore("cpp", "class-name", {
      // the base clause is an optional list of parent classes
      // https://en.cppreference.com/w/cpp/language/class
      "base-clause": {
        pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
        lookbehind: !0,
        greedy: !0,
        inside: r.languages.extend("cpp", {})
      }
    }), r.languages.insertBefore("inside", "double-colon", {
      // All untokenized words that are not namespaces should be class names
      "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
    }, r.languages.cpp["base-clause"]);
  }(Prism)), vd;
}
var wn = {}, qn = {}, Md;
function wp() {
  if (Md)
    return qn;
  Md = 1;
  var r = St();
  const n = /* @__PURE__ */ new Map();
  function t(K) {
    let A = K;
    for (; A != null; ) {
      if (A.nodeType === Node.TEXT_NODE)
        return A;
      A = A.firstChild;
    }
    return null;
  }
  function o(K) {
    const A = K.parentNode;
    if (A == null)
      throw new Error("Should never happen");
    return [A, Array.from(A.childNodes).indexOf(K)];
  }
  function u(K, A, z, ie, q) {
    const Y = A.getKey(), se = ie.getKey(), j = document.createRange();
    let Q = K.getElementByKey(Y), ae = K.getElementByKey(se), de = z, Ne = q;
    if (r.$isTextNode(A) && (Q = t(Q)), r.$isTextNode(ie) && (ae = t(ae)), A === void 0 || ie === void 0 || Q === null || ae === null)
      return null;
    Q.nodeName === "BR" && ([Q, de] = o(Q)), ae.nodeName === "BR" && ([ae, Ne] = o(ae));
    const De = Q.firstChild;
    Q === ae && De != null && De.nodeName === "BR" && de === 0 && Ne === 0 && (Ne = 1);
    try {
      j.setStart(Q, de), j.setEnd(ae, Ne);
    } catch {
      return null;
    }
    return j.collapsed && (de !== Ne || Y !== se) && (j.setStart(ae, Ne), j.setEnd(Q, de)), j;
  }
  function p(K, A) {
    const z = K.getRootElement();
    if (z === null)
      return [];
    const ie = z.getBoundingClientRect(), q = getComputedStyle(z), Y = parseFloat(q.paddingLeft) + parseFloat(q.paddingRight), se = Array.from(A.getClientRects());
    let j = se.length;
    se.sort((ae, de) => {
      const Ne = ae.top - de.top;
      return Math.abs(Ne) <= 3 ? ae.left - de.left : Ne;
    });
    let Q;
    for (let ae = 0; ae < j; ae++) {
      const de = se[ae], Ne = Q && Q.top <= de.top && Q.top + Q.height > de.top && Q.left + Q.width > de.left, De = de.width + Y === ie.width;
      if (Ne || De) {
        se.splice(ae--, 1), j--;
        continue;
      }
      Q = de;
    }
    return se;
  }
  function m(K) {
    const A = {}, z = K.split(";");
    for (const ie of z)
      if (ie !== "") {
        const [q, Y] = ie.split(/:([^]+)/);
        q && Y && (A[q.trim()] = Y.trim());
      }
    return A;
  }
  function f(K) {
    let A = n.get(K);
    return A === void 0 && (A = m(K), n.set(K, A)), Object.freeze(A), A;
  }
  function O(K) {
    let A = "";
    for (const z in K)
      z && (A += `${z}: ${K[z]};`);
    return A;
  }
  function S(K, A) {
    return K.__first = A.__first, K.__last = A.__last, K.__size = A.__size, K.__format = A.__format, K.__indent = A.__indent, K.__dir = A.__dir, K;
  }
  function E(K, A) {
    return K.__format = A.__format, K.__style = A.__style, K.__mode = A.__mode, K.__detail = A.__detail, K;
  }
  function R(K) {
    const z = K.constructor.clone(K);
    return z.__parent = K.__parent, z.__next = K.__next, z.__prev = K.__prev, r.$isElementNode(K) && r.$isElementNode(z) ? S(z, K) : r.$isTextNode(K) && r.$isTextNode(z) ? E(z, K) : z;
  }
  function y(K, A) {
    const z = K.getStartEndPoints();
    if (A.isSelected(K) && !A.isSegmented() && !A.isToken() && z !== null) {
      const [ie, q] = z, Y = K.isBackward(), se = ie.getNode(), j = q.getNode(), Q = A.is(se), ae = A.is(j);
      if (Q || ae) {
        const [de, Ne] = r.$getCharacterOffsets(K), De = se.is(j), Pe = A.is(Y ? j : se), Le = A.is(Y ? se : j);
        let ke = 0, J;
        if (De)
          ke = de > Ne ? Ne : de, J = de > Ne ? de : Ne;
        else if (Pe)
          ke = Y ? Ne : de, J = void 0;
        else if (Le) {
          const G = Y ? de : Ne;
          ke = 0, J = G;
        }
        return A.__text = A.__text.slice(ke, J), A;
      }
    }
    return A;
  }
  function g(K) {
    if (K.type === "text")
      return K.offset === K.getNode().getTextContentSize();
    const A = K.getNode();
    if (!r.$isElementNode(A))
      throw Error("isAtNodeEnd: node must be a TextNode or ElementNode");
    return K.offset === A.getChildrenSize();
  }
  function _(K, A, z) {
    let ie = A.getNode(), q = z;
    if (r.$isElementNode(ie)) {
      const Y = ie.getDescendantByIndex(A.offset);
      Y !== null && (ie = Y);
    }
    for (; q > 0 && ie !== null; ) {
      if (r.$isElementNode(ie)) {
        const ae = ie.getLastDescendant();
        ae !== null && (ie = ae);
      }
      let Y = ie.getPreviousSibling(), se = 0;
      if (Y === null) {
        let ae = ie.getParentOrThrow(), de = ae.getPreviousSibling();
        for (; de === null; ) {
          if (ae = ae.getParent(), ae === null) {
            Y = null;
            break;
          }
          de = ae.getPreviousSibling();
        }
        ae !== null && (se = ae.isInline() ? 0 : 2, Y = de);
      }
      let j = ie.getTextContent();
      j === "" && r.$isElementNode(ie) && !ie.isInline() && (j = `

`);
      const Q = j.length;
      if (!r.$isTextNode(ie) || q >= Q) {
        const ae = ie.getParent();
        ie.remove(), ae != null && ae.getChildrenSize() === 0 && !r.$isRootNode(ae) && ae.remove(), q -= Q + se, ie = Y;
      } else {
        const ae = ie.getKey(), de = K.getEditorState().read(() => {
          const Pe = r.$getNodeByKey(ae);
          return r.$isTextNode(Pe) && Pe.isSimpleText() ? Pe.getTextContent() : null;
        }), Ne = Q - q, De = j.slice(0, Ne);
        if (de !== null && de !== j) {
          const Pe = r.$getPreviousSelection();
          let Le = ie;
          if (ie.isSimpleText())
            ie.setTextContent(de);
          else {
            const ke = r.$createTextNode(de);
            ie.replace(ke), Le = ke;
          }
          if (r.$isRangeSelection(Pe) && Pe.isCollapsed()) {
            const ke = Pe.anchor.offset;
            Le.select(ke, ke);
          }
        } else if (ie.isSimpleText()) {
          const Pe = A.key === ae;
          let Le = A.offset;
          Le < q && (Le = Q);
          const ke = Pe ? Le - q : 0, J = Pe ? Le : Ne;
          if (Pe && ke === 0) {
            const [G] = ie.splitText(ke, J);
            G.remove();
          } else {
            const [, G] = ie.splitText(ke, J);
            G.remove();
          }
        } else {
          const Pe = r.$createTextNode(De);
          ie.replace(Pe);
        }
        q = 0;
      }
    }
  }
  function N(K) {
    const A = K.getStyle(), z = m(A);
    n.set(A, z);
  }
  function w(K, A) {
    const z = f("getStyle" in K ? K.getStyle() : K.style), ie = Object.entries(A).reduce((Y, [se, j]) => (j instanceof Function ? Y[se] = j(z[se]) : j === null ? delete Y[se] : Y[se] = j, Y), {
      ...z
    }), q = O(ie);
    K.setStyle(q), n.set(q, ie);
  }
  function T(K, A) {
    const z = K.getNodes(), ie = z.length, q = K.getStartEndPoints();
    if (q === null)
      return;
    const [Y, se] = q, j = ie - 1;
    let Q = z[0], ae = z[j];
    if (K.isCollapsed() && r.$isRangeSelection(K)) {
      w(K, A);
      return;
    }
    const Ne = Q.getTextContent().length, De = se.offset;
    let Pe = Y.offset;
    const Le = Y.isBefore(se);
    let ke = Le ? Pe : De, J = Le ? De : Pe;
    const G = Le ? Y.type : se.type, H = Le ? se.type : Y.type, re = Le ? se.key : Y.key;
    if (r.$isTextNode(Q) && ke === Ne) {
      const le = Q.getNextSibling();
      r.$isTextNode(le) && (Pe = 0, ke = 0, Q = le);
    }
    if (z.length === 1) {
      if (r.$isTextNode(Q) && Q.canHaveFormat()) {
        if (ke = G === "element" ? 0 : Pe > De ? De : Pe, J = H === "element" ? Ne : Pe > De ? Pe : De, ke === J)
          return;
        if (ke === 0 && J === Ne)
          w(Q, A), Q.select(ke, J);
        else {
          const le = Q.splitText(ke, J), me = ke === 0 ? le[0] : le[1];
          w(me, A), me.select(0, J - ke);
        }
      }
    } else {
      if (r.$isTextNode(Q) && ke < Q.getTextContentSize() && Q.canHaveFormat() && (ke !== 0 && (Q = Q.splitText(ke)[1], ke = 0, Y.set(Q.getKey(), ke, "text")), w(Q, A)), r.$isTextNode(ae) && ae.canHaveFormat()) {
        const me = ae.getTextContent().length;
        ae.__key !== re && J !== 0 && (J = me), J !== me && ([ae] = ae.splitText(J)), (J !== 0 || H === "element") && w(ae, A);
      }
      for (let le = 1; le < j; le++) {
        const me = z[le], ge = me.getKey();
        r.$isTextNode(me) && me.canHaveFormat() && ge !== Q.getKey() && ge !== ae.getKey() && !me.isToken() && w(me, A);
      }
    }
  }
  function D(K, A) {
    if (K === null)
      return;
    const z = K.getStartEndPoints(), ie = z ? z[0] : null;
    if (ie !== null && ie.key === "root") {
      const se = A(), j = r.$getRoot(), Q = j.getFirstChild();
      Q ? Q.replace(se, !0) : j.append(se);
      return;
    }
    const q = K.getNodes(), Y = ie !== null ? te(ie.getNode(), ne) : !1;
    Y && q.indexOf(Y) === -1 && q.push(Y);
    for (let se = 0; se < q.length; se++) {
      const j = q[se];
      if (!ne(j))
        continue;
      if (!r.$isElementNode(j))
        throw Error("Expected block node to be an ElementNode");
      const Q = A();
      Q.setFormat(j.getFormatType()), Q.setIndent(j.getIndent()), j.replace(Q, !0);
    }
  }
  function C(K) {
    return K.getNode().isAttached();
  }
  function x(K) {
    let A = K;
    for (; A !== null && !r.$isRootOrShadowRoot(A); ) {
      const z = A.getLatest(), ie = A.getParent();
      z.getChildrenSize() === 0 && A.remove(!0), A = ie;
    }
  }
  function I(K, A, z = null) {
    const ie = K.getStartEndPoints(), q = ie ? ie[0] : null, Y = K.getNodes(), se = Y.length;
    if (q !== null && (se === 0 || se === 1 && q.type === "element" && q.getNode().getChildrenSize() === 0)) {
      const ae = q.type === "text" ? q.getNode().getParentOrThrow() : q.getNode(), de = ae.getChildren();
      let Ne = A();
      Ne.setFormat(ae.getFormatType()), Ne.setIndent(ae.getIndent()), de.forEach((De) => Ne.append(De)), z && (Ne = z.append(Ne)), ae.replace(Ne);
      return;
    }
    let j = null, Q = [];
    for (let ae = 0; ae < se; ae++) {
      const de = Y[ae];
      r.$isRootOrShadowRoot(de) ? (W(K, Q, Q.length, A, z), Q = [], j = de) : j === null || j !== null && r.$hasAncestor(de, j) ? Q.push(de) : (W(K, Q, Q.length, A, z), Q = [de]);
    }
    W(K, Q, Q.length, A, z);
  }
  function W(K, A, z, ie, q = null) {
    if (A.length === 0)
      return;
    const Y = A[0], se = /* @__PURE__ */ new Map(), j = [];
    let Q = r.$isElementNode(Y) ? Y : Y.getParentOrThrow();
    Q.isInline() && (Q = Q.getParentOrThrow());
    let ae = !1;
    for (; Q !== null; ) {
      const Le = Q.getPreviousSibling();
      if (Le !== null) {
        Q = Le, ae = !0;
        break;
      }
      if (Q = Q.getParentOrThrow(), r.$isRootOrShadowRoot(Q))
        break;
    }
    const de = /* @__PURE__ */ new Set();
    for (let Le = 0; Le < z; Le++) {
      const ke = A[Le];
      r.$isElementNode(ke) && ke.getChildrenSize() === 0 && de.add(ke.getKey());
    }
    const Ne = /* @__PURE__ */ new Set();
    for (let Le = 0; Le < z; Le++) {
      const ke = A[Le];
      let J = ke.getParent();
      if (J !== null && J.isInline() && (J = J.getParent()), J !== null && r.$isLeafNode(ke) && !Ne.has(ke.getKey())) {
        const G = J.getKey();
        if (se.get(G) === void 0) {
          const H = ie();
          H.setFormat(J.getFormatType()), H.setIndent(J.getIndent()), j.push(H), se.set(G, H), J.getChildren().forEach((re) => {
            H.append(re), Ne.add(re.getKey()), r.$isElementNode(re) && re.getChildrenKeys().forEach((le) => Ne.add(le));
          }), x(J);
        }
      } else if (de.has(ke.getKey())) {
        if (!r.$isElementNode(ke))
          throw Error("Expected node in emptyElements to be an ElementNode");
        const G = ie();
        G.setFormat(ke.getFormatType()), G.setIndent(ke.getIndent()), j.push(G), ke.remove(!0);
      }
    }
    if (q !== null)
      for (let Le = 0; Le < j.length; Le++) {
        const ke = j[Le];
        q.append(ke);
      }
    let De = null;
    if (r.$isRootOrShadowRoot(Q))
      if (ae)
        if (q !== null)
          Q.insertAfter(q);
        else
          for (let Le = j.length - 1; Le >= 0; Le--) {
            const ke = j[Le];
            Q.insertAfter(ke);
          }
      else {
        const Le = Q.getFirstChild();
        if (r.$isElementNode(Le) && (Q = Le), Le === null)
          if (q)
            Q.append(q);
          else
            for (let ke = 0; ke < j.length; ke++) {
              const J = j[ke];
              Q.append(J), De = J;
            }
        else if (q !== null)
          Le.insertBefore(q);
        else
          for (let ke = 0; ke < j.length; ke++) {
            const J = j[ke];
            Le.insertBefore(J), De = J;
          }
      }
    else if (q)
      Q.insertAfter(q);
    else
      for (let Le = j.length - 1; Le >= 0; Le--) {
        const ke = j[Le];
        Q.insertAfter(ke), De = ke;
      }
    const Pe = r.$getPreviousSelection();
    r.$isRangeSelection(Pe) && C(Pe.anchor) && C(Pe.focus) ? r.$setSelection(Pe.clone()) : De !== null ? De.selectEnd() : K.dirty = !0;
  }
  function $(K, A) {
    const z = r.$getAdjacentNode(K.focus, A);
    return r.$isDecoratorNode(z) && !z.isIsolated() || r.$isElementNode(z) && !z.isInline() && !z.canBeEmpty();
  }
  function B(K, A, z, ie) {
    K.modify(A ? "extend" : "move", z, ie);
  }
  function L(K) {
    const A = K.anchor.getNode();
    return (r.$isRootNode(A) ? A : A.getParentOrThrow()).getDirection() === "rtl";
  }
  function P(K, A, z) {
    const ie = L(K);
    B(K, A, z ? !ie : ie, "character");
  }
  function F(K) {
    const A = K.anchor, z = K.focus, Y = A.getNode().getTopLevelElementOrThrow().getParentOrThrow();
    let se = Y.getFirstDescendant(), j = Y.getLastDescendant(), Q = "element", ae = "element", de = 0;
    r.$isTextNode(se) ? Q = "text" : !r.$isElementNode(se) && se !== null && (se = se.getParentOrThrow()), r.$isTextNode(j) ? (ae = "text", de = j.getTextContentSize()) : !r.$isElementNode(j) && j !== null && (j = j.getParentOrThrow()), se && j && (A.set(se.getKey(), 0, Q), z.set(j.getKey(), de, ae));
  }
  function Z(K, A, z) {
    const ie = K.getStyle(), q = f(ie);
    return q !== null && q[A] || z;
  }
  function oe(K, A, z = "") {
    let ie = null;
    const q = K.getNodes(), Y = K.anchor, se = K.focus, j = K.isBackward(), Q = j ? se.offset : Y.offset, ae = j ? se.getNode() : Y.getNode();
    if (K.isCollapsed() && K.style !== "") {
      const de = K.style, Ne = f(de);
      if (Ne !== null && A in Ne)
        return Ne[A];
    }
    for (let de = 0; de < q.length; de++) {
      const Ne = q[de];
      if (!(de !== 0 && Q === 0 && Ne.is(ae)) && r.$isTextNode(Ne)) {
        const De = Z(Ne, A, z);
        if (ie === null)
          ie = De;
        else if (ie !== De) {
          ie = "";
          break;
        }
      }
    }
    return ie === null ? z : ie;
  }
  function ne(K) {
    if (r.$isDecoratorNode(K) || !r.$isElementNode(K) || r.$isRootOrShadowRoot(K))
      return !1;
    const A = K.getFirstChild(), z = A === null || r.$isLineBreakNode(A) || r.$isTextNode(A) || A.isInline();
    return !K.isInline() && K.canBeEmpty() !== !1 && z;
  }
  function te(K, A) {
    let z = K;
    for (; z !== null && z.getParent() !== null && !A(z); )
      z = z.getParentOrThrow();
    return A(z) ? z : null;
  }
  return qn.$addNodeStyle = N, qn.$cloneWithProperties = R, qn.$getSelectionStyleValueForProperty = oe, qn.$isAtNodeEnd = g, qn.$isParentElementRTL = L, qn.$moveCaretSelection = B, qn.$moveCharacter = P, qn.$patchStyleText = T, qn.$selectAll = F, qn.$setBlocksType = D, qn.$shouldOverrideDefaultCharacterSelection = $, qn.$sliceSelectedTextNodeContent = y, qn.$wrapNodes = I, qn.createDOMRange = u, qn.createRectsFromDOMRange = p, qn.getStyleObjectFromCSS = f, qn.trimTextContentFromAnchor = _, qn;
}
var Gn = {}, Rd;
function Mp() {
  if (Rd)
    return Gn;
  Rd = 1;
  var r = St();
  let n = /* @__PURE__ */ new Map();
  function t(g) {
    for (; g != null; ) {
      if (g.nodeType === Node.TEXT_NODE)
        return g;
      g = g.firstChild;
    }
    return null;
  }
  function o(g) {
    let _ = g.parentNode;
    if (_ == null)
      throw Error("Should never happen");
    return [_, Array.from(_.childNodes).indexOf(g)];
  }
  function u(g) {
    let _ = {};
    g = g.split(";");
    for (let N of g)
      if (N !== "") {
        let [w, T] = N.split(/:([^]+)/);
        w && T && (_[w.trim()] = T.trim());
      }
    return _;
  }
  function p(g) {
    let _ = n.get(g);
    return _ === void 0 && (_ = u(g), n.set(g, _)), _;
  }
  function m(g) {
    let _ = "";
    for (let N in g)
      N && (_ += `${N}: ${g[N]};`);
    return _;
  }
  function f(g, _) {
    let N = p("getStyle" in g ? g.getStyle() : g.style);
    _ = Object.entries(_).reduce((T, [D, C]) => (C instanceof Function ? T[D] = C(N[D]) : C === null ? delete T[D] : T[D] = C, T), { ...N });
    let w = m(_);
    g.setStyle(w), n.set(w, _);
  }
  function O(g) {
    for (; g !== null && !r.$isRootOrShadowRoot(g); ) {
      let _ = g.getLatest(), N = g.getParent();
      _.getChildrenSize() === 0 && g.remove(!0), g = N;
    }
  }
  function S(g, _, N, w, T = null) {
    if (_.length !== 0) {
      var D = _[0], C = /* @__PURE__ */ new Map(), x = [];
      D = r.$isElementNode(D) ? D : D.getParentOrThrow(), D.isInline() && (D = D.getParentOrThrow());
      for (var I = !1; D !== null; ) {
        var W = D.getPreviousSibling();
        if (W !== null) {
          D = W, I = !0;
          break;
        }
        if (D = D.getParentOrThrow(), r.$isRootOrShadowRoot(D))
          break;
      }
      W = /* @__PURE__ */ new Set();
      for (var $ = 0; $ < N; $++) {
        var B = _[$];
        r.$isElementNode(B) && B.getChildrenSize() === 0 && W.add(B.getKey());
      }
      var L = /* @__PURE__ */ new Set();
      for ($ = 0; $ < N; $++) {
        B = _[$];
        var P = B.getParent();
        if (P !== null && P.isInline() && (P = P.getParent()), P !== null && r.$isLeafNode(B) && !L.has(B.getKey())) {
          if (B = P.getKey(), C.get(B) === void 0) {
            let F = w();
            F.setFormat(P.getFormatType()), F.setIndent(P.getIndent()), x.push(F), C.set(B, F), P.getChildren().forEach((Z) => {
              F.append(Z), L.add(Z.getKey()), r.$isElementNode(Z) && Z.getChildrenKeys().forEach((oe) => L.add(oe));
            }), O(P);
          }
        } else if (W.has(B.getKey())) {
          if (!r.$isElementNode(B))
            throw Error("Expected node in emptyElements to be an ElementNode");
          P = w(), P.setFormat(B.getFormatType()), P.setIndent(B.getIndent()), x.push(P), B.remove(!0);
        }
      }
      if (T !== null)
        for (_ = 0; _ < x.length; _++)
          T.append(x[_]);
      if (_ = null, r.$isRootOrShadowRoot(D))
        if (I)
          if (T !== null)
            D.insertAfter(T);
          else
            for (T = x.length - 1; 0 <= T; T--)
              D.insertAfter(x[T]);
        else if (I = D.getFirstChild(), r.$isElementNode(I) && (D = I), I === null)
          if (T)
            D.append(T);
          else
            for (T = 0; T < x.length; T++)
              I = x[T], D.append(I), _ = I;
        else if (T !== null)
          I.insertBefore(T);
        else
          for (D = 0; D < x.length; D++)
            T = x[D], I.insertBefore(T), _ = T;
      else if (T)
        D.insertAfter(T);
      else
        for (T = x.length - 1; 0 <= T; T--)
          I = x[T], D.insertAfter(I), _ = I;
      x = r.$getPreviousSelection(), r.$isRangeSelection(x) && x.anchor.getNode().isAttached() && x.focus.getNode().isAttached() ? r.$setSelection(x.clone()) : _ !== null ? _.selectEnd() : g.dirty = !0;
    }
  }
  function E(g, _, N, w) {
    g.modify(_ ? "extend" : "move", N, w);
  }
  function R(g) {
    return g = g.anchor.getNode(), (r.$isRootNode(g) ? g : g.getParentOrThrow()).getDirection() === "rtl";
  }
  function y(g) {
    if (r.$isDecoratorNode(g) || !r.$isElementNode(g) || r.$isRootOrShadowRoot(g))
      return !1;
    var _ = g.getFirstChild();
    return _ = _ === null || r.$isLineBreakNode(_) || r.$isTextNode(_) || _.isInline(), !g.isInline() && g.canBeEmpty() !== !1 && _;
  }
  return Gn.$addNodeStyle = function(g) {
    g = g.getStyle();
    let _ = u(g);
    n.set(g, _);
  }, Gn.$cloneWithProperties = function(g) {
    let _ = g.constructor.clone(g);
    return _.__parent = g.__parent, _.__next = g.__next, _.__prev = g.__prev, r.$isElementNode(g) && r.$isElementNode(_) ? (_.__first = g.__first, _.__last = g.__last, _.__size = g.__size, _.__format = g.__format, _.__indent = g.__indent, _.__dir = g.__dir, _) : (r.$isTextNode(g) && r.$isTextNode(_) && (_.__format = g.__format, _.__style = g.__style, _.__mode = g.__mode, _.__detail = g.__detail), _);
  }, Gn.$getSelectionStyleValueForProperty = function(g, _, N = "") {
    let w = null, T = g.getNodes();
    var D = g.anchor, C = g.focus, x = g.isBackward();
    let I = x ? C.offset : D.offset;
    if (D = x ? C.getNode() : D.getNode(), g.isCollapsed() && g.style !== "" && (g = p(g.style), g !== null && _ in g))
      return g[_];
    for (g = 0; g < T.length; g++) {
      var W = T[g];
      if ((g === 0 || I !== 0 || !W.is(D)) && r.$isTextNode(W)) {
        if (C = _, x = N, W = W.getStyle(), W = p(W), C = W !== null && W[C] || x, w === null)
          w = C;
        else if (w !== C) {
          w = "";
          break;
        }
      }
    }
    return w === null ? N : w;
  }, Gn.$isAtNodeEnd = function(g) {
    if (g.type === "text")
      return g.offset === g.getNode().getTextContentSize();
    let _ = g.getNode();
    if (!r.$isElementNode(_))
      throw Error("isAtNodeEnd: node must be a TextNode or ElementNode");
    return g.offset === _.getChildrenSize();
  }, Gn.$isParentElementRTL = R, Gn.$moveCaretSelection = E, Gn.$moveCharacter = function(g, _, N) {
    let w = R(g);
    E(g, _, N ? !w : w, "character");
  }, Gn.$patchStyleText = function(g, _) {
    var N = g.getNodes(), w = N.length, T = g.getStartEndPoints();
    if (T !== null) {
      var [D, C] = T;
      --w, T = N[0];
      var x = N[w];
      if (g.isCollapsed() && r.$isRangeSelection(g))
        f(g, _);
      else {
        var I = T.getTextContent().length, W = C.offset, $ = D.offset, B = D.isBefore(C), L = B ? $ : W;
        g = B ? W : $;
        var P = B ? D.type : C.type, F = B ? C.type : D.type;
        if (B = B ? C.key : D.key, r.$isTextNode(T) && L === I) {
          let Z = T.getNextSibling();
          r.$isTextNode(Z) && (L = $ = 0, T = Z);
        }
        if (N.length === 1)
          r.$isTextNode(T) && T.canHaveFormat() && (L = P === "element" ? 0 : $ > W ? W : $, g = F === "element" ? I : $ > W ? $ : W, L !== g && (L === 0 && g === I ? (f(T, _), T.select(L, g)) : (N = T.splitText(L, g), N = L === 0 ? N[0] : N[1], f(N, _), N.select(0, g - L))));
        else
          for (r.$isTextNode(T) && L < T.getTextContentSize() && T.canHaveFormat() && (L !== 0 && (T = T.splitText(L)[1], L = 0, D.set(T.getKey(), L, "text")), f(T, _)), r.$isTextNode(x) && x.canHaveFormat() && (L = x.getTextContent().length, x.__key !== B && g !== 0 && (g = L), g !== L && ([x] = x.splitText(g)), g === 0 && F !== "element" || f(x, _)), g = 1; g < w; g++)
            L = N[g], F = L.getKey(), r.$isTextNode(L) && L.canHaveFormat() && F !== T.getKey() && F !== x.getKey() && !L.isToken() && f(L, _);
      }
    }
  }, Gn.$selectAll = function(g) {
    let _ = g.anchor;
    g = g.focus;
    var N = _.getNode().getTopLevelElementOrThrow().getParentOrThrow();
    let w = N.getFirstDescendant();
    N = N.getLastDescendant();
    let T = "element", D = "element", C = 0;
    r.$isTextNode(w) ? T = "text" : r.$isElementNode(w) || w === null || (w = w.getParentOrThrow()), r.$isTextNode(N) ? (D = "text", C = N.getTextContentSize()) : r.$isElementNode(N) || N === null || (N = N.getParentOrThrow()), w && N && (_.set(w.getKey(), 0, T), g.set(N.getKey(), C, D));
  }, Gn.$setBlocksType = function(g, _) {
    if (g !== null) {
      var N = g.getStartEndPoints();
      if (N = N ? N[0] : null, N !== null && N.key === "root")
        _ = _(), g = r.$getRoot(), (N = g.getFirstChild()) ? N.replace(_, !0) : g.append(_);
      else {
        if (g = g.getNodes(), N !== null) {
          for (N = N.getNode(); N !== null && N.getParent() !== null && !y(N); )
            N = N.getParentOrThrow();
          N = y(N) ? N : null;
        } else
          N = !1;
        for (N && g.indexOf(N) === -1 && g.push(N), N = 0; N < g.length; N++) {
          let w = g[N];
          if (!y(w))
            continue;
          if (!r.$isElementNode(w))
            throw Error("Expected block node to be an ElementNode");
          let T = _();
          T.setFormat(w.getFormatType()), T.setIndent(w.getIndent()), w.replace(T, !0);
        }
      }
    }
  }, Gn.$shouldOverrideDefaultCharacterSelection = function(g, _) {
    return g = r.$getAdjacentNode(g.focus, _), r.$isDecoratorNode(g) && !g.isIsolated() || r.$isElementNode(g) && !g.isInline() && !g.canBeEmpty();
  }, Gn.$sliceSelectedTextNodeContent = function(g, _) {
    var N = g.getStartEndPoints();
    if (_.isSelected(g) && !_.isSegmented() && !_.isToken() && N !== null) {
      let [x, I] = N;
      N = g.isBackward();
      var w = x.getNode(), T = I.getNode(), D = _.is(w), C = _.is(T);
      if (D || C) {
        let [W, $] = r.$getCharacterOffsets(g);
        g = w.is(T), D = _.is(N ? T : w), T = _.is(N ? w : T), w = 0, C = void 0, g ? (w = W > $ ? $ : W, C = W > $ ? W : $) : D ? (w = N ? $ : W, C = void 0) : T && (N = N ? W : $, w = 0, C = N), _.__text = _.__text.slice(w, C);
      }
    }
    return _;
  }, Gn.$wrapNodes = function(g, _, N = null) {
    var w = g.getStartEndPoints(), T = w ? w[0] : null;
    w = g.getNodes();
    let D = w.length;
    if (T !== null && (D === 0 || D === 1 && T.type === "element" && T.getNode().getChildrenSize() === 0)) {
      g = T.type === "text" ? T.getNode().getParentOrThrow() : T.getNode(), w = g.getChildren();
      let x = _();
      x.setFormat(g.getFormatType()), x.setIndent(g.getIndent()), w.forEach((I) => x.append(I)), N && (x = N.append(x)), g.replace(x);
    } else {
      T = null;
      var C = [];
      for (let x = 0; x < D; x++) {
        let I = w[x];
        r.$isRootOrShadowRoot(I) ? (S(g, C, C.length, _, N), C = [], T = I) : T === null || T !== null && r.$hasAncestor(I, T) ? C.push(I) : (S(g, C, C.length, _, N), C = [I]);
      }
      S(g, C, C.length, _, N);
    }
  }, Gn.createDOMRange = function(g, _, N, w, T) {
    let D = _.getKey(), C = w.getKey(), x = document.createRange(), I = g.getElementByKey(D);
    if (g = g.getElementByKey(C), r.$isTextNode(_) && (I = t(I)), r.$isTextNode(w) && (g = t(g)), _ === void 0 || w === void 0 || I === null || g === null)
      return null;
    I.nodeName === "BR" && ([I, N] = o(I)), g.nodeName === "BR" && ([g, T] = o(g)), _ = I.firstChild, I === g && _ != null && _.nodeName === "BR" && N === 0 && T === 0 && (T = 1);
    try {
      x.setStart(I, N), x.setEnd(g, T);
    } catch {
      return null;
    }
    return !x.collapsed || N === T && D === C || (x.setStart(g, T), x.setEnd(
      I,
      N
    )), x;
  }, Gn.createRectsFromDOMRange = function(g, _) {
    var N = g.getRootElement();
    if (N === null)
      return [];
    g = N.getBoundingClientRect(), N = getComputedStyle(N), N = parseFloat(N.paddingLeft) + parseFloat(N.paddingRight), _ = Array.from(_.getClientRects());
    let w = _.length;
    _.sort((D, C) => {
      let x = D.top - C.top;
      return 3 >= Math.abs(x) ? D.left - C.left : x;
    });
    let T;
    for (let D = 0; D < w; D++) {
      let C = _[D], x = C.width + N === g.width;
      T && T.top <= C.top && T.top + T.height > C.top && T.left + T.width > C.left || x ? (_.splice(D--, 1), w--) : T = C;
    }
    return _;
  }, Gn.getStyleObjectFromCSS = p, Gn.trimTextContentFromAnchor = function(g, _, N) {
    let w = _.getNode();
    if (r.$isElementNode(w)) {
      var T = w.getDescendantByIndex(_.offset);
      T !== null && (w = T);
    }
    for (; 0 < N && w !== null; ) {
      r.$isElementNode(w) && (T = w.getLastDescendant(), T !== null && (w = T));
      var D = w.getPreviousSibling(), C = 0;
      if (D === null) {
        T = w.getParentOrThrow();
        for (var x = T.getPreviousSibling(); x === null; ) {
          if (T = T.getParent(), T === null) {
            D = null;
            break;
          }
          x = T.getPreviousSibling();
        }
        T !== null && (C = T.isInline() ? 0 : 2, D = x);
      }
      if (x = w.getTextContent(), x === "" && r.$isElementNode(w) && !w.isInline() && (x = `

`), T = x.length, !r.$isTextNode(w) || N >= T)
        x = w.getParent(), w.remove(), x == null || x.getChildrenSize() !== 0 || r.$isRootNode(x) || x.remove(), N -= T + C, w = D;
      else {
        let I = w.getKey();
        C = g.getEditorState().read(() => {
          const $ = r.$getNodeByKey(I);
          return r.$isTextNode($) && $.isSimpleText() ? $.getTextContent() : null;
        }), D = T - N;
        let W = x.slice(0, D);
        C !== null && C !== x ? (N = r.$getPreviousSelection(), T = w, w.isSimpleText() ? w.setTextContent(C) : (T = r.$createTextNode(C), w.replace(T)), r.$isRangeSelection(N) && N.isCollapsed() && (N = N.anchor.offset, T.select(N, N))) : w.isSimpleText() ? (C = _.key === I, x = _.offset, x < N && (x = T), N = C ? x - N : 0, T = C ? x : D, C && N === 0 ? ([N] = w.splitText(N, T), N.remove()) : ([, N] = w.splitText(N, T), N.remove())) : (N = r.$createTextNode(W), w.replace(N)), N = 0;
      }
    }
  }, Gn;
}
var nc, bd;
function Ko() {
  return bd || (bd = 1, nc = process.env.NODE_ENV === "development" ? wp() : Mp()), nc;
}
var Ad;
function Rp() {
  if (Ad)
    return wn;
  Ad = 1;
  var r = Ko(), n = St();
  function t(...$) {
    return () => {
      $.forEach((B) => B());
    };
  }
  function o($) {
    return `${$}px`;
  }
  const u = {
    attributes: !0,
    characterData: !0,
    childList: !0,
    subtree: !0
  };
  function p($, B, L) {
    let P = null, F = null, Z = null, oe = [];
    const ne = document.createElement("div");
    function te() {
      if (P === null)
        throw Error("Unexpected null rootDOMNode");
      if (F === null)
        throw Error("Unexpected null parentDOMNode");
      const {
        left: ie,
        top: q
      } = P.getBoundingClientRect(), Y = F, se = r.createRectsFromDOMRange($, B);
      ne.isConnected || Y.append(ne);
      let j = !1;
      for (let Q = 0; Q < se.length; Q++) {
        const ae = se[Q], de = oe[Q] || document.createElement("div"), Ne = de.style;
        Ne.position !== "absolute" && (Ne.position = "absolute", j = !0);
        const De = o(ae.left - ie);
        Ne.left !== De && (Ne.left = De, j = !0);
        const Pe = o(ae.top - q);
        Ne.top !== Pe && (de.style.top = Pe, j = !0);
        const Le = o(ae.width);
        Ne.width !== Le && (de.style.width = Le, j = !0);
        const ke = o(ae.height);
        Ne.height !== ke && (de.style.height = ke, j = !0), de.parentNode !== ne && (ne.append(de), j = !0), oe[Q] = de;
      }
      for (; oe.length > se.length; )
        oe.pop();
      j && L(oe);
    }
    function K() {
      F = null, P = null, Z !== null && Z.disconnect(), Z = null, ne.remove();
      for (const ie of oe)
        ie.remove();
      oe = [];
    }
    function A() {
      const ie = $.getRootElement();
      if (ie === null)
        return K();
      const q = ie.parentElement;
      if (!(q instanceof HTMLElement))
        return K();
      K(), P = ie, F = q, Z = new MutationObserver((Y) => {
        const se = $.getRootElement(), j = se && se.parentElement;
        if (se !== P || j !== F)
          return A();
        for (const Q of Y)
          if (!ne.contains(Q.target))
            return te();
      }), Z.observe(q, u), te();
    }
    const z = $.registerRootListener(A);
    return () => {
      z(), K();
    };
  }
  function m($, B) {
    let L = null, P = null, F = null, Z = null, oe = () => {
    };
    function ne(te) {
      te.read(() => {
        const K = n.$getSelection();
        if (!n.$isRangeSelection(K)) {
          L = null, P = null, F = null, Z = null, oe(), oe = () => {
          };
          return;
        }
        const {
          anchor: A,
          focus: z
        } = K, ie = A.getNode(), q = ie.getKey(), Y = A.offset, se = z.getNode(), j = se.getKey(), Q = z.offset, ae = $.getElementByKey(q), de = $.getElementByKey(j), Ne = L === null || ae === null || Y !== P || q !== L.getKey() || ie !== L && (!(L instanceof n.TextNode) || ie.updateDOM(L, ae, $._config)), De = F === null || de === null || Q !== Z || j !== F.getKey() || se !== F && (!(F instanceof n.TextNode) || se.updateDOM(F, de, $._config));
        if (Ne || De) {
          const Pe = $.getElementByKey(A.getNode().getKey()), Le = $.getElementByKey(z.getNode().getKey());
          if (Pe !== null && Le !== null && Pe.tagName === "SPAN" && Le.tagName === "SPAN") {
            const ke = document.createRange();
            let J, G, H, re;
            z.isBefore(A) ? (J = Le, G = z.offset, H = Pe, re = A.offset) : (J = Pe, G = A.offset, H = Le, re = z.offset);
            const le = J.firstChild;
            if (le === null)
              throw Error("Expected text node to be first child of span");
            const me = H.firstChild;
            if (me === null)
              throw Error("Expected text node to be first child of span");
            ke.setStart(le, G), ke.setEnd(me, re), oe(), oe = p($, ke, (ge) => {
              for (const Me of ge) {
                const Ie = Me.style;
                Ie.background !== "Highlight" && (Ie.background = "Highlight"), Ie.color !== "HighlightText" && (Ie.color = "HighlightText"), Ie.zIndex !== "-1" && (Ie.zIndex = "-1"), Ie.pointerEvents !== "none" && (Ie.pointerEvents = "none"), Ie.marginTop !== o(-1.5) && (Ie.marginTop = o(-1.5)), Ie.paddingTop !== o(4) && (Ie.paddingTop = o(4)), Ie.paddingBottom !== o(0) && (Ie.paddingBottom = o(0));
              }
              B !== void 0 && B(ge);
            });
          }
        }
        L = ie, P = Y, F = se, Z = Q;
      });
    }
    return ne($.getEditorState()), t($.registerUpdateListener(({
      editorState: te
    }) => ne(te)), oe, () => {
      oe();
    });
  }
  function f($, ...B) {
    B.forEach((L) => {
      if (typeof L == "string") {
        const P = L.split(" ").filter((F) => F !== "");
        $.classList.add(...P);
      }
    });
  }
  function O($, ...B) {
    B.forEach((L) => {
      typeof L == "string" && $.classList.remove(...L.split(" "));
    });
  }
  function S($, B) {
    for (const L of B)
      if ($.type.startsWith(L))
        return !0;
    return !1;
  }
  function E($, B) {
    const L = $[Symbol.iterator]();
    return new Promise((P, F) => {
      const Z = [], oe = () => {
        const {
          done: ne,
          value: te
        } = L.next();
        if (ne)
          return P(Z);
        const K = new FileReader();
        K.addEventListener("error", F), K.addEventListener("load", () => {
          const A = K.result;
          typeof A == "string" && Z.push({
            file: te,
            result: A
          }), oe();
        }), S(te, B) ? K.readAsDataURL(te) : oe();
      };
      oe();
    });
  }
  function R($, B) {
    const L = [], P = ($ || n.$getRoot()).getLatest(), F = B || (n.$isElementNode(P) ? P.getLastDescendant() : P);
    let Z = P, oe = y(Z);
    for (; Z !== null && !Z.is(F); )
      if (L.push({
        depth: oe,
        node: Z
      }), n.$isElementNode(Z) && Z.getChildrenSize() > 0)
        Z = Z.getFirstChild(), oe++;
      else {
        let ne = null;
        for (; ne === null && Z !== null; )
          ne = Z.getNextSibling(), ne === null ? (Z = Z.getParent(), oe--) : Z = ne;
      }
    return Z !== null && Z.is(F) && L.push({
      depth: oe,
      node: Z
    }), L;
  }
  function y($) {
    let B = $, L = 0;
    for (; (B = B.getParent()) !== null; )
      L++;
    return L;
  }
  function g($, B) {
    let L = $;
    for (; L != null; ) {
      if (L instanceof B)
        return L;
      L = L.getParent();
    }
    return null;
  }
  function _($) {
    const B = N($, (L) => n.$isElementNode(L) && !L.isInline());
    if (!n.$isElementNode(B))
      throw Error(`Expected node ${$.__key} to have closest block element node.`);
    return B;
  }
  const N = ($, B) => {
    let L = $;
    for (; L !== n.$getRoot() && L != null; ) {
      if (B(L))
        return L;
      L = L.getParent();
    }
    return null;
  };
  function w($, B, L, P) {
    const F = (ne) => ne instanceof B, Z = (ne) => {
      const te = ne.getChildren();
      for (let z = 0; z < te.length; z++) {
        const ie = te[z];
        if (F(ie))
          return null;
      }
      let K = ne, A = ne;
      for (; K !== null; )
        if (A = K, K = K.getParent(), F(K))
          return {
            child: A,
            parent: K
          };
      return null;
    }, oe = (ne) => {
      const te = Z(ne);
      if (te !== null) {
        const {
          child: K,
          parent: A
        } = te;
        if (K.is(ne)) {
          P(A, ne);
          const z = K.getNextSiblings(), ie = z.length;
          if (A.insertAfter(K), ie !== 0) {
            const q = L(A);
            K.insertAfter(q);
            for (let Y = 0; Y < ie; Y++)
              q.append(z[Y]);
          }
          !A.canBeEmpty() && A.getChildrenSize() === 0 && A.remove();
        }
      }
    };
    return $.registerNodeTransform(B, oe);
  }
  function T($, B) {
    const P = /* @__PURE__ */ new Map(), F = $._pendingEditorState;
    for (const [oe, ne] of B._nodeMap) {
      const te = r.$cloneWithProperties(ne);
      if (n.$isTextNode(te)) {
        if (!n.$isTextNode(ne))
          throw Error("Expected node be a TextNode");
        te.__text = ne.__text;
      }
      P.set(oe, te);
    }
    F && (F._nodeMap = P), $._dirtyType = 2;
    const Z = B._selection;
    n.$setSelection(Z === null ? null : Z.clone());
  }
  function D($) {
    const B = n.$getSelection() || n.$getPreviousSelection();
    if (n.$isRangeSelection(B)) {
      const {
        focus: L
      } = B, P = L.getNode(), F = L.offset;
      if (n.$isRootOrShadowRoot(P)) {
        const Z = P.getChildAtIndex(F);
        Z == null ? P.append($) : Z.insertBefore($), $.selectNext();
      } else {
        let Z, oe;
        n.$isTextNode(P) ? (Z = P.getParentOrThrow(), oe = P.getIndexWithinParent(), F > 0 && (oe += 1, P.splitText(F))) : (Z = P, oe = F);
        const [, ne] = n.$splitNode(Z, oe);
        ne.insertBefore($), ne.selectStart();
      }
    } else {
      if (B != null) {
        const P = B.getNodes();
        P[P.length - 1].getTopLevelElementOrThrow().insertAfter($);
      } else
        n.$getRoot().append($);
      const L = n.$createParagraphNode();
      $.insertAfter(L), L.select();
    }
    return $.getLatest();
  }
  function C($, B) {
    const L = B();
    return $.replace(L), L.append($), L;
  }
  function x($, B) {
    return $ !== null ? Object.getPrototypeOf($).constructor.name === B.name : !1;
  }
  function I($, B) {
    const L = [];
    for (let P = 0; P < $.length; P++) {
      const F = B($[P]);
      F !== null && L.push(F);
    }
    return L;
  }
  function W($, B) {
    const L = $.getFirstChild();
    L !== null ? L.insertBefore(B) : $.append(B);
  }
  return wn.$splitNode = n.$splitNode, wn.isHTMLAnchorElement = n.isHTMLAnchorElement, wn.isHTMLElement = n.isHTMLElement, wn.$dfs = R, wn.$filter = I, wn.$findMatchingParent = N, wn.$getNearestBlockElementAncestorOrThrow = _, wn.$getNearestNodeOfType = g, wn.$insertFirst = W, wn.$insertNodeToNearestRoot = D, wn.$restoreEditorState = T, wn.$wrapNodeInElement = C, wn.addClassNamesToElement = f, wn.isMimeType = S, wn.markSelection = m, wn.mediaFileReader = E, wn.mergeRegister = t, wn.objectKlassEquals = x, wn.positionNodeOnRange = p, wn.registerNestedElementResolver = w, wn.removeClassNamesFromElement = O, wn;
}
var Mn = {}, Dd;
function bp() {
  if (Dd)
    return Mn;
  Dd = 1;
  var r = Ko(), n = St();
  function t(O) {
    let S = new URLSearchParams();
    S.append("code", O);
    for (let E = 1; E < arguments.length; E++)
      S.append("v", arguments[E]);
    throw Error(`Minified Lexical error #${O}; visit https://lexical.dev/docs/error?${S} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  function o(...O) {
    return () => {
      O.forEach((S) => S());
    };
  }
  let u = { attributes: !0, characterData: !0, childList: !0, subtree: !0 };
  function p(O, S, E) {
    function R() {
      if (_ === null)
        throw Error("Unexpected null rootDOMNode");
      if (N === null)
        throw Error("Unexpected null parentDOMNode");
      let { left: x, top: I } = _.getBoundingClientRect();
      var W = N;
      let $ = r.createRectsFromDOMRange(O, S);
      D.isConnected || W.append(D), W = !1;
      for (let P = 0; P < $.length; P++) {
        var B = $[P];
        let F = T[P] || document.createElement("div"), Z = F.style;
        Z.position !== "absolute" && (Z.position = "absolute", W = !0);
        var L = `${B.left - x}px`;
        Z.left !== L && (Z.left = L, W = !0), L = `${B.top - I}px`, Z.top !== L && (F.style.top = L, W = !0), L = `${B.width}px`, Z.width !== L && (F.style.width = L, W = !0), B = `${B.height}px`, Z.height !== B && (F.style.height = B, W = !0), F.parentNode !== D && (D.append(F), W = !0), T[P] = F;
      }
      for (; T.length > $.length; )
        T.pop();
      W && E(T);
    }
    function y() {
      _ = N = null, w !== null && w.disconnect(), w = null, D.remove();
      for (let x of T)
        x.remove();
      T = [];
    }
    function g() {
      let x = O.getRootElement();
      if (x === null)
        return y();
      let I = x.parentElement;
      if (!(I instanceof HTMLElement))
        return y();
      y(), _ = x, N = I, w = new MutationObserver((W) => {
        let $ = O.getRootElement(), B = $ && $.parentElement;
        if ($ !== _ || B !== N)
          return g();
        for (let L of W)
          if (!D.contains(L.target))
            return R();
      }), w.observe(I, u), R();
    }
    let _ = null, N = null, w = null, T = [], D = document.createElement("div"), C = O.registerRootListener(g);
    return () => {
      C(), y();
    };
  }
  function m(O, S) {
    for (let E of S)
      if (O.type.startsWith(E))
        return !0;
    return !1;
  }
  let f = (O, S) => {
    for (; O !== n.$getRoot() && O != null; ) {
      if (S(O))
        return O;
      O = O.getParent();
    }
    return null;
  };
  return Mn.$splitNode = n.$splitNode, Mn.isHTMLAnchorElement = n.isHTMLAnchorElement, Mn.isHTMLElement = n.isHTMLElement, Mn.$dfs = function(O, S) {
    let E = [];
    O = (O || n.$getRoot()).getLatest(), S = S || (n.$isElementNode(O) ? O.getLastDescendant() : O);
    for (var R = O, y = 0; (R = R.getParent()) !== null; )
      y++;
    for (R = y; O !== null && !O.is(S); )
      if (E.push({ depth: R, node: O }), n.$isElementNode(O) && 0 < O.getChildrenSize())
        O = O.getFirstChild(), R++;
      else
        for (y = null; y === null && O !== null; )
          y = O.getNextSibling(), y === null ? (O = O.getParent(), R--) : O = y;
    return O !== null && O.is(S) && E.push({ depth: R, node: O }), E;
  }, Mn.$filter = function(O, S) {
    let E = [];
    for (let R = 0; R < O.length; R++) {
      let y = S(O[R]);
      y !== null && E.push(y);
    }
    return E;
  }, Mn.$findMatchingParent = f, Mn.$getNearestBlockElementAncestorOrThrow = function(O) {
    let S = f(O, (E) => n.$isElementNode(E) && !E.isInline());
    return n.$isElementNode(S) || t(4, O.__key), S;
  }, Mn.$getNearestNodeOfType = function(O, S) {
    for (; O != null; ) {
      if (O instanceof S)
        return O;
      O = O.getParent();
    }
    return null;
  }, Mn.$insertFirst = function(O, S) {
    let E = O.getFirstChild();
    E !== null ? E.insertBefore(S) : O.append(S);
  }, Mn.$insertNodeToNearestRoot = function(O) {
    var S = n.$getSelection() || n.$getPreviousSelection();
    if (n.$isRangeSelection(S)) {
      var { focus: E } = S;
      if (S = E.getNode(), E = E.offset, n.$isRootOrShadowRoot(S))
        E = S.getChildAtIndex(E), E == null ? S.append(O) : E.insertBefore(O), O.selectNext();
      else {
        let R, y;
        n.$isTextNode(S) ? (R = S.getParentOrThrow(), y = S.getIndexWithinParent(), 0 < E && (y += 1, S.splitText(E))) : (R = S, y = E), [, S] = n.$splitNode(R, y), S.insertBefore(O), S.selectStart();
      }
    } else
      S != null ? (S = S.getNodes(), S[S.length - 1].getTopLevelElementOrThrow().insertAfter(O)) : n.$getRoot().append(O), S = n.$createParagraphNode(), O.insertAfter(S), S.select();
    return O.getLatest();
  }, Mn.$restoreEditorState = function(O, S) {
    let E = /* @__PURE__ */ new Map(), R = O._pendingEditorState;
    for (let [y, g] of S._nodeMap) {
      let _ = r.$cloneWithProperties(g);
      if (n.$isTextNode(_)) {
        if (!n.$isTextNode(g))
          throw Error("Expected node be a TextNode");
        _.__text = g.__text;
      }
      E.set(y, _);
    }
    R && (R._nodeMap = E), O._dirtyType = 2, O = S._selection, n.$setSelection(O === null ? null : O.clone());
  }, Mn.$wrapNodeInElement = function(O, S) {
    return S = S(), O.replace(S), S.append(O), S;
  }, Mn.addClassNamesToElement = function(O, ...S) {
    S.forEach((E) => {
      typeof E == "string" && (E = E.split(" ").filter((R) => R !== ""), O.classList.add(...E));
    });
  }, Mn.isMimeType = m, Mn.markSelection = function(O, S) {
    function E(w) {
      w.read(() => {
        var T = n.$getSelection();
        if (n.$isRangeSelection(T)) {
          var { anchor: D, focus: C } = T;
          T = D.getNode();
          var x = T.getKey(), I = D.offset, W = C.getNode(), $ = W.getKey(), B = C.offset, L = O.getElementByKey(x), P = O.getElementByKey($);
          if (x = R === null || L === null || I !== y || x !== R.getKey() || T !== R && (!(R instanceof n.TextNode) || T.updateDOM(R, L, O._config)), $ = g === null || P === null || B !== _ || $ !== g.getKey() || W !== g && (!(g instanceof n.TextNode) || W.updateDOM(g, P, O._config)), x || $) {
            L = O.getElementByKey(D.getNode().getKey());
            var F = O.getElementByKey(C.getNode().getKey());
            if (L !== null && F !== null && L.tagName === "SPAN" && F.tagName === "SPAN") {
              if ($ = document.createRange(), C.isBefore(D) ? (x = F, P = C.offset, F = L, L = D.offset) : (x = L, P = D.offset, L = C.offset), x = x.firstChild, x === null || (F = F.firstChild, F === null))
                throw Error("Expected text node to be first child of span");
              $.setStart(x, P), $.setEnd(F, L), N(), N = p(O, $, (Z) => {
                for (let oe of Z) {
                  let ne = oe.style;
                  ne.background !== "Highlight" && (ne.background = "Highlight"), ne.color !== "HighlightText" && (ne.color = "HighlightText"), ne.zIndex !== "-1" && (ne.zIndex = "-1"), ne.pointerEvents !== "none" && (ne.pointerEvents = "none"), ne.marginTop !== "-1.5px" && (ne.marginTop = "-1.5px"), ne.paddingTop !== "4px" && (ne.paddingTop = "4px"), ne.paddingBottom !== "0px" && (ne.paddingBottom = "0px");
                }
                S !== void 0 && S(Z);
              });
            }
          }
          R = T, y = I, g = W, _ = B;
        } else
          _ = g = y = R = null, N(), N = () => {
          };
      });
    }
    let R = null, y = null, g = null, _ = null, N = () => {
    };
    return E(O.getEditorState()), o(O.registerUpdateListener(({ editorState: w }) => E(w)), N, () => {
      N();
    });
  }, Mn.mediaFileReader = function(O, S) {
    let E = O[Symbol.iterator]();
    return new Promise((R, y) => {
      let g = [], _ = () => {
        const { done: N, value: w } = E.next();
        if (N)
          return R(g);
        const T = new FileReader();
        T.addEventListener("error", y), T.addEventListener("load", () => {
          const D = T.result;
          typeof D == "string" && g.push({ file: w, result: D }), _();
        }), m(w, S) ? T.readAsDataURL(w) : _();
      };
      _();
    });
  }, Mn.mergeRegister = o, Mn.objectKlassEquals = function(O, S) {
    return O !== null ? Object.getPrototypeOf(O).constructor.name === S.name : !1;
  }, Mn.positionNodeOnRange = p, Mn.registerNestedElementResolver = function(O, S, E, R) {
    return O.registerNodeTransform(S, (y) => {
      e: {
        for (var g = y.getChildren(), _ = 0; _ < g.length; _++)
          if (g[_] instanceof S) {
            g = null;
            break e;
          }
        for (g = y; g !== null; )
          if (_ = g, g = g.getParent(), g instanceof S) {
            g = { child: _, parent: g };
            break e;
          }
        g = null;
      }
      if (g !== null) {
        const { child: N, parent: w } = g;
        if (N.is(y)) {
          if (R(w, y), y = N.getNextSiblings(), g = y.length, w.insertAfter(N), g !== 0) {
            _ = E(w), N.insertAfter(_);
            for (let T = 0; T < g; T++)
              _.append(y[T]);
          }
          w.canBeEmpty() || w.getChildrenSize() !== 0 || w.remove();
        }
      }
    });
  }, Mn.removeClassNamesFromElement = function(O, ...S) {
    S.forEach((E) => {
      typeof E == "string" && O.classList.remove(...E.split(" "));
    });
  }, Mn;
}
var rc, Ld;
function kt() {
  return Ld || (Ld = 1, rc = process.env.NODE_ENV === "development" ? Rp() : bp()), rc;
}
var Id;
function Ap() {
  if (Id)
    return kn;
  Id = 1;
  var r = Lg();
  Ig(), $g(), kg(), Pg(), Fg(), Bg(), Kg(), jg(), Hg(), Wg(), Ug(), Yg(), zg(), qg();
  var n = kt(), t = St();
  const o = (H) => H != null && r.languages.hasOwnProperty(H) ? H : void 0;
  function u(H, re) {
    for (const le of H.childNodes) {
      if (n.isHTMLElement(le) && le.tagName === re)
        return !0;
      u(le, re);
    }
    return !1;
  }
  const p = "data-highlight-language";
  class m extends t.ElementNode {
    /** @internal */
    static getType() {
      return "code";
    }
    static clone(re) {
      return new m(re.__language, re.__key);
    }
    constructor(re, le) {
      super(le), this.__language = o(re);
    }
    // View
    createDOM(re) {
      const le = document.createElement("code");
      n.addClassNamesToElement(le, re.theme.code), le.setAttribute("spellcheck", "false");
      const me = this.getLanguage();
      return me && le.setAttribute(p, me), le;
    }
    updateDOM(re, le, me) {
      const ge = this.__language, Me = re.__language;
      return ge ? ge !== Me && le.setAttribute(p, ge) : Me && le.removeAttribute(p), !1;
    }
    exportDOM() {
      const re = document.createElement("pre");
      re.setAttribute("spellcheck", "false");
      const le = this.getLanguage();
      return le && re.setAttribute(p, le), {
        element: re
      };
    }
    static importDOM() {
      return {
        // Typically <pre> is used for code blocks, and <code> for inline code styles
        // but if it's a multi line <code> we'll create a block. Pass through to
        // inline format handled by TextNode otherwise.
        code: (re) => re.textContent != null && (/\r?\n/.test(re.textContent) || u(re, "BR")) ? {
          conversion: S,
          priority: 1
        } : null,
        div: (re) => ({
          conversion: E,
          priority: 1
        }),
        pre: (re) => ({
          conversion: S,
          priority: 0
        }),
        table: (re) => T(re) ? {
          conversion: R,
          priority: 3
        } : null,
        td: (re) => {
          const le = re, me = le.closest("table");
          return w(le) ? {
            conversion: g,
            priority: 3
          } : me && T(me) ? {
            conversion: y,
            priority: 3
          } : null;
        },
        tr: (re) => {
          const me = re.closest("table");
          return me && T(me) ? {
            conversion: y,
            priority: 3
          } : null;
        }
      };
    }
    static importJSON(re) {
      const le = f(re.language);
      return le.setFormat(re.format), le.setIndent(re.indent), le.setDirection(re.direction), le;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        language: this.getLanguage(),
        type: "code",
        version: 1
      };
    }
    // Mutation
    insertNewAfter(re, le = !0) {
      const me = this.getChildren(), ge = me.length;
      if (ge >= 2 && me[ge - 1].getTextContent() === `
` && me[ge - 2].getTextContent() === `
` && re.isCollapsed() && re.anchor.key === this.__key && re.anchor.offset === ge) {
        me[ge - 1].remove(), me[ge - 2].remove();
        const be = t.$createParagraphNode();
        return this.insertAfter(be, le), be;
      }
      const {
        anchor: Me,
        focus: Ie
      } = re, Oe = (Me.isBefore(Ie) ? Me : Ie).getNode();
      if (t.$isTextNode(Oe)) {
        let be = oe(Oe);
        const He = [];
        for (; ; )
          if (t.$isTabNode(be))
            He.push(t.$createTabNode()), be = be.getNextSibling();
          else if (Z(be)) {
            let Ot = 0;
            const Te = be.getTextContent(), ue = be.getTextContentSize();
            for (; Ot < ue && Te[Ot] === " "; Ot++)
              ;
            if (Ot !== 0 && He.push(F(" ".repeat(Ot))), Ot !== ue)
              break;
            be = be.getNextSibling();
          } else
            break;
        const Ge = Oe.splitText(Me.offset)[0], dt = Me.offset === 0 ? 0 : 1, nt = Ge.getIndexWithinParent() + dt, At = Oe.getParentOrThrow(), an = [t.$createLineBreakNode(), ...He];
        At.splice(nt, 0, an);
        const Gt = He[He.length - 1];
        Gt ? Gt.select() : Me.offset === 0 ? Ge.selectPrevious() : Ge.getNextSibling().selectNext(0, 0);
      }
      if (O(Oe)) {
        const {
          offset: be
        } = re.anchor;
        Oe.splice(be, 0, [t.$createLineBreakNode()]), Oe.select(be + 1, be + 1);
      }
      return null;
    }
    canIndent() {
      return !1;
    }
    collapseAtStart() {
      const re = t.$createParagraphNode();
      return this.getChildren().forEach((me) => re.append(me)), this.replace(re), !0;
    }
    setLanguage(re) {
      const le = this.getWritable();
      le.__language = o(re);
    }
    getLanguage() {
      return this.getLatest().__language;
    }
  }
  function f(H) {
    return t.$applyNodeReplacement(new m(H));
  }
  function O(H) {
    return H instanceof m;
  }
  function S(H) {
    let re;
    return n.isHTMLElement(H) && (re = H.getAttribute(p)), {
      node: f(re)
    };
  }
  function E(H) {
    const re = H, le = _(re);
    return !le && !N(re) ? {
      node: null
    } : {
      after: (me) => {
        const ge = H.parentNode;
        return ge != null && H !== ge.lastChild && me.push(t.$createLineBreakNode()), me;
      },
      node: le ? f() : null
    };
  }
  function R() {
    return {
      node: f()
    };
  }
  function y() {
    return {
      node: null
    };
  }
  function g(H) {
    const re = H;
    return {
      after: (le) => (re.parentNode && re.parentNode.nextSibling && le.push(t.$createLineBreakNode()), le),
      node: null
    };
  }
  function _(H) {
    return H.style.fontFamily.match("monospace") !== null;
  }
  function N(H) {
    let re = H.parentElement;
    for (; re !== null; ) {
      if (_(re))
        return !0;
      re = re.parentElement;
    }
    return !1;
  }
  function w(H) {
    return H.classList.contains("js-file-line");
  }
  function T(H) {
    return H.classList.contains("js-file-line-container");
  }
  const D = "javascript", C = {
    c: "C",
    clike: "C-like",
    cpp: "C++",
    css: "CSS",
    html: "HTML",
    java: "Java",
    js: "JavaScript",
    markdown: "Markdown",
    objc: "Objective-C",
    plain: "Plain Text",
    py: "Python",
    rust: "Rust",
    sql: "SQL",
    swift: "Swift",
    typescript: "TypeScript",
    xml: "XML"
  }, x = {
    cpp: "cpp",
    java: "java",
    javascript: "js",
    md: "markdown",
    plaintext: "plain",
    python: "py",
    text: "plain",
    ts: "typescript"
  };
  function I(H) {
    return x[H] || H;
  }
  function W(H) {
    const re = I(H);
    return C[re] || re;
  }
  const $ = () => D, B = () => Object.keys(r.languages).filter(
    // Prism has several language helpers mixed into languages object
    // so filtering them out here to get langs list
    (H) => typeof r.languages[H] != "function"
  ).sort();
  class L extends t.TextNode {
    /** @internal */
    constructor(re, le, me) {
      super(re, me), this.__highlightType = le;
    }
    static getType() {
      return "code-highlight";
    }
    static clone(re) {
      return new L(re.__text, re.__highlightType || void 0, re.__key);
    }
    getHighlightType() {
      return this.getLatest().__highlightType;
    }
    canHaveFormat() {
      return !1;
    }
    createDOM(re) {
      const le = super.createDOM(re), me = P(re.theme, this.__highlightType);
      return n.addClassNamesToElement(le, me), le;
    }
    updateDOM(re, le, me) {
      const ge = super.updateDOM(re, le, me), Me = P(me.theme, re.__highlightType), Ie = P(me.theme, this.__highlightType);
      return Me !== Ie && (Me && n.removeClassNamesFromElement(le, Me), Ie && n.addClassNamesToElement(le, Ie)), ge;
    }
    static importJSON(re) {
      const le = F(re.text, re.highlightType);
      return le.setFormat(re.format), le.setDetail(re.detail), le.setMode(re.mode), le.setStyle(re.style), le;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        highlightType: this.getHighlightType(),
        type: "code-highlight",
        version: 1
      };
    }
    // Prevent formatting (bold, underline, etc)
    setFormat(re) {
      return this;
    }
    isParentRequired() {
      return !0;
    }
    createParentElementNode() {
      return f();
    }
  }
  function P(H, re) {
    return re && H && H.codeHighlight && H.codeHighlight[re];
  }
  function F(H, re) {
    return t.$applyNodeReplacement(new L(H, re));
  }
  function Z(H) {
    return H instanceof L;
  }
  function oe(H) {
    let re = H, le = H;
    for (; Z(le) || t.$isTabNode(le); )
      re = le, le = le.getPreviousSibling();
    return re;
  }
  function ne(H) {
    let re = H, le = H;
    for (; Z(le) || t.$isTabNode(le); )
      re = le, le = le.getNextSibling();
    return re;
  }
  const te = {
    defaultLanguage: D,
    tokenize(H, re) {
      return r.tokenize(H, r.languages[re || ""] || r.languages[this.defaultLanguage]);
    }
  };
  function K(H, re) {
    let le = null, me = null, ge = H, Me = re, Ie = H.getTextContent();
    for (; ; ) {
      if (Me === 0) {
        if (ge = ge.getPreviousSibling(), ge === null)
          break;
        if (!(Z(ge) || t.$isTabNode(ge) || t.$isLineBreakNode(ge)))
          throw Error("Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode");
        if (t.$isLineBreakNode(ge)) {
          le = {
            node: ge,
            offset: 1
          };
          break;
        }
        Me = Math.max(0, ge.getTextContentSize() - 1), Ie = ge.getTextContent();
      } else
        Me--;
      const Oe = Ie[Me];
      Z(ge) && Oe !== " " && (me = {
        node: ge,
        offset: Me
      });
    }
    if (me !== null)
      return me;
    let je = null;
    if (re < H.getTextContentSize())
      Z(H) && (je = H.getTextContent()[re]);
    else {
      const Oe = H.getNextSibling();
      Z(Oe) && (je = Oe.getTextContent()[0]);
    }
    if (je !== null && je !== " ")
      return le;
    {
      const Oe = A(H, re);
      return Oe !== null ? Oe : le;
    }
  }
  function A(H, re) {
    let le = H, me = re, ge = H.getTextContent(), Me = H.getTextContentSize();
    for (; ; ) {
      if (!Z(le) || me === Me) {
        if (le = le.getNextSibling(), le === null || t.$isLineBreakNode(le))
          return null;
        Z(le) && (me = 0, ge = le.getTextContent(), Me = le.getTextContentSize());
      }
      if (Z(le)) {
        if (ge[me] !== " ")
          return {
            node: le,
            offset: me
          };
        me++;
      }
    }
  }
  function z(H) {
    const re = ne(H);
    if (t.$isLineBreakNode(re))
      throw Error("Unexpected lineBreakNode in getEndOfCodeInLine");
    return re;
  }
  function ie(H, re, le) {
    const me = H.getParent();
    O(me) ? se(me, re, le) : Z(H) && H.replace(t.$createTextNode(H.__text));
  }
  function q(H, re) {
    const le = re.getElementByKey(H.getKey());
    if (le === null)
      return;
    const me = H.getChildren(), ge = me.length;
    if (ge === le.__cachedChildrenLength)
      return;
    le.__cachedChildrenLength = ge;
    let Me = "1", Ie = 1;
    for (let je = 0; je < ge; je++)
      t.$isLineBreakNode(me[je]) && (Me += `
` + ++Ie);
    le.setAttribute("data-gutter", Me);
  }
  const Y = /* @__PURE__ */ new Set();
  function se(H, re, le) {
    const me = H.getKey();
    Y.has(me) || (Y.add(me), H.getLanguage() === void 0 && H.setLanguage(le.defaultLanguage), re.update(() => {
      Q(me, () => {
        const ge = t.$getNodeByKey(me);
        if (!O(ge) || !ge.isAttached())
          return !1;
        const Me = ge.getTextContent(), Ie = le.tokenize(Me, ge.getLanguage() || le.defaultLanguage), je = j(Ie), Oe = ae(ge.getChildren(), je), {
          from: be,
          to: He,
          nodesForReplacement: Ge
        } = Oe;
        return be !== He || Ge.length ? (H.splice(be, He - be, Ge), !0) : !1;
      });
    }, {
      onUpdate: () => {
        Y.delete(me);
      },
      skipTransforms: !0
    }));
  }
  function j(H, re) {
    const le = [];
    for (const me of H)
      if (typeof me == "string") {
        const ge = me.split(/(\n|\t)/), Me = ge.length;
        for (let Ie = 0; Ie < Me; Ie++) {
          const je = ge[Ie];
          je === `
` || je === `\r
` ? le.push(t.$createLineBreakNode()) : je === "	" ? le.push(t.$createTabNode()) : je.length > 0 && le.push(F(je, re));
        }
      } else {
        const {
          content: ge
        } = me;
        typeof ge == "string" ? le.push(...j([ge], me.type)) : Array.isArray(ge) && le.push(...j(ge, me.type));
      }
    return le;
  }
  function Q(H, re) {
    const le = t.$getNodeByKey(H);
    if (!O(le) || !le.isAttached())
      return;
    const me = t.$getSelection();
    if (!t.$isRangeSelection(me)) {
      re();
      return;
    }
    const ge = me.anchor, Me = ge.offset, Ie = ge.type === "element" && t.$isLineBreakNode(le.getChildAtIndex(ge.offset - 1));
    let je = 0;
    if (!Ie) {
      const be = ge.getNode();
      je = Me + be.getPreviousSiblings().reduce((He, Ge) => He + Ge.getTextContentSize(), 0);
    }
    if (re()) {
      if (Ie) {
        ge.getNode().select(Me, Me);
        return;
      }
      le.getChildren().some((be) => {
        const He = t.$isTextNode(be);
        if (He || t.$isLineBreakNode(be)) {
          const Ge = be.getTextContentSize();
          if (He && Ge >= je)
            return be.select(je, je), !0;
          je -= Ge;
        }
        return !1;
      });
    }
  }
  function ae(H, re) {
    let le = 0;
    for (; le < H.length && de(H[le], re[le]); )
      le++;
    const me = H.length, ge = re.length, Me = Math.min(me, ge) - le;
    let Ie = 0;
    for (; Ie < Me; )
      if (Ie++, !de(H[me - Ie], re[ge - Ie])) {
        Ie--;
        break;
      }
    const je = le, Oe = me - Ie, be = re.slice(le, ge - Ie);
    return {
      from: je,
      nodesForReplacement: be,
      to: Oe
    };
  }
  function de(H, re) {
    return Z(H) && Z(re) && H.__text === re.__text && H.__highlightType === re.__highlightType || t.$isTabNode(H) && t.$isTabNode(re) || t.$isLineBreakNode(H) && t.$isLineBreakNode(re);
  }
  function Ne(H) {
    if (!t.$isRangeSelection(H))
      return !1;
    const re = H.anchor.getNode(), le = H.focus.getNode();
    if (re.is(le) && O(re))
      return !0;
    const me = re.getParent();
    return O(me) && me.is(le.getParent());
  }
  function De(H) {
    const re = H.getNodes(), le = [[]];
    if (re.length === 1 && O(re[0]))
      return le;
    let me = le[0];
    for (let ge = 0; ge < re.length; ge++) {
      const Me = re[ge];
      if (!(Z(Me) || t.$isTabNode(Me) || t.$isLineBreakNode(Me)))
        throw Error("Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode");
      t.$isLineBreakNode(Me) ? ge !== 0 && me.length > 0 && (me = [], le.push(me)) : me.push(Me);
    }
    return le;
  }
  function Pe(H) {
    const re = t.$getSelection();
    if (!t.$isRangeSelection(re) || !Ne(re))
      return null;
    const le = H ? t.OUTDENT_CONTENT_COMMAND : t.INDENT_CONTENT_COMMAND, me = H ? t.OUTDENT_CONTENT_COMMAND : t.INSERT_TAB_COMMAND;
    if (De(re).length > 1)
      return le;
    const Ie = re.getNodes()[0];
    if (!(O(Ie) || Z(Ie) || t.$isTabNode(Ie) || t.$isLineBreakNode(Ie)))
      throw Error("Expected selection firstNode to be CodeHighlightNode or TabNode");
    if (O(Ie))
      return le;
    const je = oe(Ie), Oe = ne(Ie), be = re.anchor, He = re.focus;
    let Ge, dt;
    return He.isBefore(be) ? (Ge = He, dt = be) : (Ge = be, dt = He), je !== null && Oe !== null && Ge.key === je.getKey() && Ge.offset === 0 && dt.key === Oe.getKey() && dt.offset === Oe.getTextContentSize() ? le : me;
  }
  function Le(H) {
    const re = t.$getSelection();
    if (!t.$isRangeSelection(re) || !Ne(re))
      return !1;
    const le = De(re), me = le.length;
    if (le.length > 1) {
      for (let je = 0; je < me; je++) {
        const Oe = le[je];
        if (Oe.length > 0) {
          let be = Oe[0];
          je === 0 && (be = oe(be)), be !== null && (H === t.INDENT_CONTENT_COMMAND ? be.insertBefore(t.$createTabNode()) : t.$isTabNode(be) && be.remove());
        }
      }
      return !0;
    }
    const Me = re.getNodes()[0];
    if (!(O(Me) || Z(Me) || t.$isTabNode(Me) || t.$isLineBreakNode(Me)))
      throw Error("Expected selection firstNode to be CodeHighlightNode or CodeTabNode");
    if (O(Me))
      return H === t.INDENT_CONTENT_COMMAND && re.insertNodes([t.$createTabNode()]), !0;
    const Ie = oe(Me);
    if (Ie === null)
      throw Error("Expected getFirstCodeNodeOfLine to return a valid Code Node");
    return H === t.INDENT_CONTENT_COMMAND ? t.$isLineBreakNode(Ie) ? Ie.insertAfter(t.$createTabNode()) : Ie.insertBefore(t.$createTabNode()) : t.$isTabNode(Ie) && Ie.remove(), !0;
  }
  function ke(H, re) {
    const le = t.$getSelection();
    if (!t.$isRangeSelection(le))
      return !1;
    const {
      anchor: me,
      focus: ge
    } = le, Me = me.offset, Ie = ge.offset, je = me.getNode(), Oe = ge.getNode(), be = H === t.KEY_ARROW_UP_COMMAND;
    if (!Ne(le) || !(Z(je) || t.$isTabNode(je)) || !(Z(Oe) || t.$isTabNode(Oe)))
      return !1;
    if (!re.altKey) {
      if (le.isCollapsed()) {
        const Ot = je.getParentOrThrow();
        if (be && Me === 0 && je.getPreviousSibling() === null) {
          if (Ot.getPreviousSibling() === null)
            return Ot.selectPrevious(), re.preventDefault(), !0;
        } else if (!be && Me === je.getTextContentSize() && je.getNextSibling() === null && Ot.getNextSibling() === null)
          return Ot.selectNext(), re.preventDefault(), !0;
      }
      return !1;
    }
    let He, Ge;
    if (je.isBefore(Oe) ? (He = oe(je), Ge = ne(Oe)) : (He = oe(Oe), Ge = ne(je)), He == null || Ge == null)
      return !1;
    const dt = He.getNodesBetween(Ge);
    for (let Ot = 0; Ot < dt.length; Ot++) {
      const Te = dt[Ot];
      if (!Z(Te) && !t.$isTabNode(Te) && !t.$isLineBreakNode(Te))
        return !1;
    }
    re.preventDefault(), re.stopPropagation();
    const nt = be ? He.getPreviousSibling() : Ge.getNextSibling();
    if (!t.$isLineBreakNode(nt))
      return !0;
    const At = be ? nt.getPreviousSibling() : nt.getNextSibling();
    if (At == null)
      return !0;
    const an = Z(At) || t.$isTabNode(At) || t.$isLineBreakNode(At) ? be ? oe(At) : ne(At) : null;
    let Gt = an ?? At;
    return nt.remove(), dt.forEach((Ot) => Ot.remove()), H === t.KEY_ARROW_UP_COMMAND ? (dt.forEach((Ot) => Gt.insertBefore(Ot)), Gt.insertBefore(nt)) : (Gt.insertAfter(nt), Gt = nt, dt.forEach((Ot) => {
      Gt.insertAfter(Ot), Gt = Ot;
    })), le.setTextNodeRange(je, Me, Oe, Ie), !0;
  }
  function J(H, re) {
    const le = t.$getSelection();
    if (!t.$isRangeSelection(le))
      return !1;
    const {
      anchor: me,
      focus: ge
    } = le, Me = me.getNode(), Ie = ge.getNode(), je = H === t.MOVE_TO_START;
    if (!(Z(Me) || t.$isTabNode(Me)) || !(Z(Ie) || t.$isTabNode(Ie)))
      return !1;
    if (je) {
      const Oe = K(Ie, ge.offset);
      if (Oe !== null) {
        const {
          node: be,
          offset: He
        } = Oe;
        t.$isLineBreakNode(be) ? be.selectNext(0, 0) : le.setTextNodeRange(be, He, be, He);
      } else
        Ie.getParentOrThrow().selectStart();
    } else
      z(Ie).select();
    return re.preventDefault(), re.stopPropagation(), !0;
  }
  function G(H, re) {
    if (!H.hasNodes([m, L]))
      throw new Error("CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor");
    return re == null && (re = te), n.mergeRegister(H.registerMutationListener(m, (le) => {
      H.update(() => {
        for (const [me, ge] of le)
          if (ge !== "destroyed") {
            const Me = t.$getNodeByKey(me);
            Me !== null && q(Me, H);
          }
      });
    }), H.registerNodeTransform(m, (le) => se(le, H, re)), H.registerNodeTransform(t.TextNode, (le) => ie(le, H, re)), H.registerNodeTransform(L, (le) => ie(le, H, re)), H.registerCommand(t.KEY_TAB_COMMAND, (le) => {
      const me = Pe(le.shiftKey);
      return me === null ? !1 : (le.preventDefault(), H.dispatchCommand(me, void 0), !0);
    }, t.COMMAND_PRIORITY_LOW), H.registerCommand(t.INSERT_TAB_COMMAND, () => {
      const le = t.$getSelection();
      return Ne(le) ? (t.$insertNodes([t.$createTabNode()]), !0) : !1;
    }, t.COMMAND_PRIORITY_LOW), H.registerCommand(t.INDENT_CONTENT_COMMAND, (le) => Le(t.INDENT_CONTENT_COMMAND), t.COMMAND_PRIORITY_LOW), H.registerCommand(t.OUTDENT_CONTENT_COMMAND, (le) => Le(t.OUTDENT_CONTENT_COMMAND), t.COMMAND_PRIORITY_LOW), H.registerCommand(t.KEY_ARROW_UP_COMMAND, (le) => ke(t.KEY_ARROW_UP_COMMAND, le), t.COMMAND_PRIORITY_LOW), H.registerCommand(t.KEY_ARROW_DOWN_COMMAND, (le) => ke(t.KEY_ARROW_DOWN_COMMAND, le), t.COMMAND_PRIORITY_LOW), H.registerCommand(t.MOVE_TO_END, (le) => J(t.MOVE_TO_END, le), t.COMMAND_PRIORITY_LOW), H.registerCommand(t.MOVE_TO_START, (le) => J(t.MOVE_TO_START, le), t.COMMAND_PRIORITY_LOW));
  }
  return kn.$createCodeHighlightNode = F, kn.$createCodeNode = f, kn.$isCodeHighlightNode = Z, kn.$isCodeNode = O, kn.CODE_LANGUAGE_FRIENDLY_NAME_MAP = C, kn.CODE_LANGUAGE_MAP = x, kn.CodeHighlightNode = L, kn.CodeNode = m, kn.DEFAULT_CODE_LANGUAGE = D, kn.PrismTokenizer = te, kn.getCodeLanguages = B, kn.getDefaultCodeLanguage = $, kn.getEndOfCodeInLine = z, kn.getFirstCodeNodeOfLine = oe, kn.getLanguageFriendlyName = W, kn.getLastCodeNodeOfLine = ne, kn.getStartOfCodeInLine = K, kn.normalizeCodeLang = I, kn.registerCodeHighlighting = G, kn;
}
var Pn = {}, $d;
function Dp() {
  if ($d)
    return Pn;
  $d = 1;
  var r = Lg();
  Ig(), $g(), kg(), Pg(), Fg(), Bg(), Kg(), jg(), Hg(), Wg(), Ug(), Yg(), zg(), qg();
  var n = kt(), t = St();
  let o = (j) => j != null && r.languages.hasOwnProperty(j) ? j : void 0;
  function u(j, Q) {
    for (let ae of j.childNodes) {
      if (n.isHTMLElement(ae) && ae.tagName === Q)
        return !0;
      u(ae, Q);
    }
    return !1;
  }
  class p extends t.ElementNode {
    static getType() {
      return "code";
    }
    static clone(Q) {
      return new p(Q.__language, Q.__key);
    }
    constructor(Q, ae) {
      super(ae), this.__language = o(Q);
    }
    createDOM(Q) {
      let ae = document.createElement("code");
      return n.addClassNamesToElement(ae, Q.theme.code), ae.setAttribute("spellcheck", "false"), (Q = this.getLanguage()) && ae.setAttribute("data-highlight-language", Q), ae;
    }
    updateDOM(Q, ae) {
      let de = this.__language;
      return Q = Q.__language, de ? de !== Q && ae.setAttribute("data-highlight-language", de) : Q && ae.removeAttribute("data-highlight-language"), !1;
    }
    exportDOM() {
      let Q = document.createElement("pre");
      Q.setAttribute("spellcheck", "false");
      let ae = this.getLanguage();
      return ae && Q.setAttribute("data-highlight-language", ae), { element: Q };
    }
    static importDOM() {
      return { code: (Q) => Q.textContent != null && (/\r?\n/.test(Q.textContent) || u(Q, "BR")) ? { conversion: O, priority: 1 } : null, div: () => ({ conversion: S, priority: 1 }), pre: () => ({ conversion: O, priority: 0 }), table: (Q) => _(Q) ? { conversion: E, priority: 3 } : null, td: (Q) => {
        let ae = Q.closest("table");
        return Q.classList.contains("js-file-line") ? { conversion: y, priority: 3 } : ae && _(ae) ? { conversion: R, priority: 3 } : null;
      }, tr: (Q) => (Q = Q.closest("table")) && _(Q) ? { conversion: R, priority: 3 } : null };
    }
    static importJSON(Q) {
      let ae = m(Q.language);
      return ae.setFormat(Q.format), ae.setIndent(Q.indent), ae.setDirection(Q.direction), ae;
    }
    exportJSON() {
      return { ...super.exportJSON(), language: this.getLanguage(), type: "code", version: 1 };
    }
    insertNewAfter(Q, ae = !0) {
      var de = this.getChildren(), Ne = de.length;
      if (2 <= Ne && de[Ne - 1].getTextContent() === `
` && de[Ne - 2].getTextContent() === `
` && Q.isCollapsed() && Q.anchor.key === this.__key && Q.anchor.offset === Ne)
        return de[Ne - 1].remove(), de[Ne - 2].remove(), Q = t.$createParagraphNode(), this.insertAfter(Q, ae), Q;
      let { anchor: De, focus: Pe } = Q;
      if (ae = (De.isBefore(Pe) ? De : Pe).getNode(), t.$isTextNode(ae)) {
        for (Ne = W(ae), de = []; ; )
          if (t.$isTabNode(Ne))
            de.push(t.$createTabNode()), Ne = Ne.getNextSibling();
          else if (I(Ne)) {
            for (var Le = 0, ke = Ne.getTextContent(), J = Ne.getTextContentSize(); Le < J && ke[Le] === " "; Le++)
              ;
            if (Le !== 0 && de.push(x(" ".repeat(Le))), Le !== J)
              break;
            Ne = Ne.getNextSibling();
          } else
            break;
        Ne = ae.splitText(De.offset)[0], Le = De.offset === 0 ? 0 : 1, Le = Ne.getIndexWithinParent() + Le, ke = ae.getParentOrThrow(), J = [t.$createLineBreakNode(), ...de], ke.splice(Le, 0, J), (de = de[de.length - 1]) ? de.select() : De.offset === 0 ? Ne.selectPrevious() : Ne.getNextSibling().selectNext(0, 0);
      }
      return f(ae) && ({ offset: Q } = Q.anchor, ae.splice(Q, 0, [t.$createLineBreakNode()]), ae.select(Q + 1, Q + 1)), null;
    }
    canIndent() {
      return !1;
    }
    collapseAtStart() {
      let Q = t.$createParagraphNode();
      return this.getChildren().forEach((ae) => Q.append(ae)), this.replace(Q), !0;
    }
    setLanguage(Q) {
      this.getWritable().__language = o(Q);
    }
    getLanguage() {
      return this.getLatest().__language;
    }
  }
  function m(j) {
    return t.$applyNodeReplacement(new p(j));
  }
  function f(j) {
    return j instanceof p;
  }
  function O(j) {
    let Q;
    return n.isHTMLElement(j) && (Q = j.getAttribute("data-highlight-language")), { node: m(Q) };
  }
  function S(j) {
    let Q = j.style.fontFamily.match("monospace") !== null;
    return Q || g(j) ? { after: (ae) => {
      let de = j.parentNode;
      return de != null && j !== de.lastChild && ae.push(t.$createLineBreakNode()), ae;
    }, node: Q ? m() : null } : { node: null };
  }
  function E() {
    return { node: m() };
  }
  function R() {
    return { node: null };
  }
  function y(j) {
    return { after: (Q) => (j.parentNode && j.parentNode.nextSibling && Q.push(t.$createLineBreakNode()), Q), node: null };
  }
  function g(j) {
    for (j = j.parentElement; j !== null; ) {
      if (j.style.fontFamily.match("monospace") !== null)
        return !0;
      j = j.parentElement;
    }
    return !1;
  }
  function _(j) {
    return j.classList.contains("js-file-line-container");
  }
  let N = { c: "C", clike: "C-like", cpp: "C++", css: "CSS", html: "HTML", java: "Java", js: "JavaScript", markdown: "Markdown", objc: "Objective-C", plain: "Plain Text", py: "Python", rust: "Rust", sql: "SQL", swift: "Swift", typescript: "TypeScript", xml: "XML" }, w = { cpp: "cpp", java: "java", javascript: "js", md: "markdown", plaintext: "plain", python: "py", text: "plain", ts: "typescript" };
  function T(j) {
    return w[j] || j;
  }
  class D extends t.TextNode {
    constructor(Q, ae, de) {
      super(Q, de), this.__highlightType = ae;
    }
    static getType() {
      return "code-highlight";
    }
    static clone(Q) {
      return new D(Q.__text, Q.__highlightType || void 0, Q.__key);
    }
    getHighlightType() {
      return this.getLatest().__highlightType;
    }
    canHaveFormat() {
      return !1;
    }
    createDOM(Q) {
      let ae = super.createDOM(Q);
      return Q = C(Q.theme, this.__highlightType), n.addClassNamesToElement(ae, Q), ae;
    }
    updateDOM(Q, ae, de) {
      let Ne = super.updateDOM(Q, ae, de);
      return Q = C(de.theme, Q.__highlightType), de = C(de.theme, this.__highlightType), Q !== de && (Q && n.removeClassNamesFromElement(ae, Q), de && n.addClassNamesToElement(ae, de)), Ne;
    }
    static importJSON(Q) {
      let ae = x(Q.text, Q.highlightType);
      return ae.setFormat(Q.format), ae.setDetail(Q.detail), ae.setMode(Q.mode), ae.setStyle(Q.style), ae;
    }
    exportJSON() {
      return { ...super.exportJSON(), highlightType: this.getHighlightType(), type: "code-highlight", version: 1 };
    }
    setFormat() {
      return this;
    }
    isParentRequired() {
      return !0;
    }
    createParentElementNode() {
      return m();
    }
  }
  function C(j, Q) {
    return Q && j && j.codeHighlight && j.codeHighlight[Q];
  }
  function x(j, Q) {
    return t.$applyNodeReplacement(new D(j, Q));
  }
  function I(j) {
    return j instanceof D;
  }
  function W(j) {
    let Q = j;
    for (; I(j) || t.$isTabNode(j); )
      Q = j, j = j.getPreviousSibling();
    return Q;
  }
  function $(j) {
    let Q = j;
    for (; I(j) || t.$isTabNode(j); )
      Q = j, j = j.getNextSibling();
    return Q;
  }
  let B = { defaultLanguage: "javascript", tokenize(j, Q) {
    return r.tokenize(j, r.languages[Q || ""] || r.languages[this.defaultLanguage]);
  } };
  function L(j, Q) {
    let ae = null;
    var de = null, Ne = j;
    let De = Q, Pe = j.getTextContent();
    for (; ; ) {
      if (De === 0) {
        if (Ne = Ne.getPreviousSibling(), Ne === null)
          break;
        if (!(I(Ne) || t.$isTabNode(Ne) || t.$isLineBreakNode(Ne)))
          throw Error("Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode");
        if (t.$isLineBreakNode(Ne)) {
          ae = { node: Ne, offset: 1 };
          break;
        }
        De = Math.max(0, Ne.getTextContentSize() - 1), Pe = Ne.getTextContent();
      } else
        De--;
      let Le = Pe[De];
      I(Ne) && Le !== " " && (de = { node: Ne, offset: De });
    }
    if (de !== null)
      return de;
    if (de = null, Q < j.getTextContentSize() ? I(j) && (de = j.getTextContent()[Q]) : (Ne = j.getNextSibling(), I(Ne) && (de = Ne.getTextContent()[0])), de !== null && de !== " ")
      return ae;
    e:
      for (de = j, Ne = j.getTextContent(), j = j.getTextContentSize(); ; ) {
        if (!I(de) || Q === j) {
          if (de = de.getNextSibling(), de === null || t.$isLineBreakNode(de)) {
            j = null;
            break e;
          }
          I(de) && (Q = 0, Ne = de.getTextContent(), j = de.getTextContentSize());
        }
        if (I(de)) {
          if (Ne[Q] !== " ") {
            j = { node: de, offset: Q };
            break e;
          }
          Q++;
        }
      }
    return j !== null ? j : ae;
  }
  function P(j) {
    if (j = $(j), t.$isLineBreakNode(j))
      throw Error("Unexpected lineBreakNode in getEndOfCodeInLine");
    return j;
  }
  function F(j, Q, ae) {
    let de = j.getParent();
    f(de) ? oe(de, Q, ae) : I(j) && j.replace(t.$createTextNode(j.__text));
  }
  let Z = /* @__PURE__ */ new Set();
  function oe(j, Q, ae) {
    let de = j.getKey();
    Z.has(de) || (Z.add(de), j.getLanguage() === void 0 && j.setLanguage(ae.defaultLanguage), Q.update(() => {
      te(de, () => {
        var Ne = t.$getNodeByKey(de);
        if (!f(Ne) || !Ne.isAttached())
          return !1;
        var De = Ne.getTextContent();
        De = ae.tokenize(De, Ne.getLanguage() || ae.defaultLanguage), De = ne(De);
        var Pe = Ne.getChildren();
        for (Ne = 0; Ne < Pe.length && K(Pe[Ne], De[Ne]); )
          Ne++;
        var Le = Pe.length;
        let ke = De.length, J = Math.min(Le, ke) - Ne, G = 0;
        for (; G < J; )
          if (G++, !K(Pe[Le - G], De[ke - G])) {
            G--;
            break;
          }
        Pe = Ne, Le -= G, De = De.slice(Ne, ke - G);
        let { from: H, to: re, nodesForReplacement: le } = { from: Pe, nodesForReplacement: De, to: Le };
        return H !== re || le.length ? (j.splice(H, re - H, le), !0) : !1;
      });
    }, { onUpdate: () => {
      Z.delete(de);
    }, skipTransforms: !0 }));
  }
  function ne(j, Q) {
    let ae = [];
    for (let de of j)
      if (typeof de == "string") {
        j = de.split(/(\n|\t)/);
        let Ne = j.length;
        for (let De = 0; De < Ne; De++) {
          let Pe = j[De];
          Pe === `
` || Pe === `\r
` ? ae.push(t.$createLineBreakNode()) : Pe === "	" ? ae.push(t.$createTabNode()) : 0 < Pe.length && ae.push(x(Pe, Q));
        }
      } else
        ({ content: j } = de), typeof j == "string" ? ae.push(...ne([j], de.type)) : Array.isArray(j) && ae.push(...ne(j, de.type));
    return ae;
  }
  function te(j, Q) {
    if (j = t.$getNodeByKey(j), f(j) && j.isAttached()) {
      var ae = t.$getSelection();
      if (t.$isRangeSelection(ae)) {
        ae = ae.anchor;
        var de = ae.offset, Ne = ae.type === "element" && t.$isLineBreakNode(j.getChildAtIndex(ae.offset - 1)), De = 0;
        if (!Ne) {
          let Pe = ae.getNode();
          De = de + Pe.getPreviousSiblings().reduce((Le, ke) => Le + ke.getTextContentSize(), 0);
        }
        Q() && (Ne ? ae.getNode().select(de, de) : j.getChildren().some((Pe) => {
          let Le = t.$isTextNode(Pe);
          if (Le || t.$isLineBreakNode(Pe)) {
            let ke = Pe.getTextContentSize();
            if (Le && ke >= De)
              return Pe.select(De, De), !0;
            De -= ke;
          }
          return !1;
        }));
      } else
        Q();
    }
  }
  function K(j, Q) {
    return I(j) && I(Q) && j.__text === Q.__text && j.__highlightType === Q.__highlightType || t.$isTabNode(j) && t.$isTabNode(Q) || t.$isLineBreakNode(j) && t.$isLineBreakNode(Q);
  }
  function A(j) {
    if (!t.$isRangeSelection(j))
      return !1;
    var Q = j.anchor.getNode();
    return j = j.focus.getNode(), Q.is(j) && f(Q) ? !0 : (Q = Q.getParent(), f(Q) && Q.is(j.getParent()));
  }
  function z(j) {
    j = j.getNodes();
    let Q = [[]];
    if (j.length === 1 && f(j[0]))
      return Q;
    let ae = Q[0];
    for (let de = 0; de < j.length; de++) {
      let Ne = j[de];
      if (!(I(Ne) || t.$isTabNode(Ne) || t.$isLineBreakNode(Ne)))
        throw Error("Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode");
      t.$isLineBreakNode(Ne) ? de !== 0 && 0 < ae.length && (ae = [], Q.push(ae)) : ae.push(Ne);
    }
    return Q;
  }
  function ie(j) {
    var Q = t.$getSelection();
    if (!t.$isRangeSelection(Q) || !A(Q))
      return null;
    let ae = j ? t.OUTDENT_CONTENT_COMMAND : t.INDENT_CONTENT_COMMAND;
    if (j = j ? t.OUTDENT_CONTENT_COMMAND : t.INSERT_TAB_COMMAND, 1 < z(Q).length)
      return ae;
    var de = Q.getNodes()[0];
    if (!(f(de) || I(de) || t.$isTabNode(de) || t.$isLineBreakNode(de)))
      throw Error("Expected selection firstNode to be CodeHighlightNode or TabNode");
    if (f(de))
      return ae;
    let Ne = W(de);
    de = $(de);
    var De = Q.anchor;
    let Pe = Q.focus;
    return Pe.isBefore(De) ? Q = Pe : (Q = De, De = Pe), Ne !== null && de !== null && Q.key === Ne.getKey() && Q.offset === 0 && De.key === de.getKey() && De.offset === de.getTextContentSize() ? ae : j;
  }
  function q(j) {
    var Q = t.$getSelection();
    if (!t.$isRangeSelection(Q) || !A(Q))
      return !1;
    var ae = z(Q);
    let de = ae.length;
    if (1 < ae.length) {
      for (Q = 0; Q < de; Q++) {
        var Ne = ae[Q];
        0 < Ne.length && (Ne = Ne[0], Q === 0 && (Ne = W(Ne)), Ne !== null && (j === t.INDENT_CONTENT_COMMAND ? Ne.insertBefore(t.$createTabNode()) : t.$isTabNode(Ne) && Ne.remove()));
      }
      return !0;
    }
    if (ae = Q.getNodes()[0], !(f(ae) || I(ae) || t.$isTabNode(ae) || t.$isLineBreakNode(ae)))
      throw Error("Expected selection firstNode to be CodeHighlightNode or CodeTabNode");
    if (f(ae))
      return j === t.INDENT_CONTENT_COMMAND && Q.insertNodes([t.$createTabNode()]), !0;
    if (ae = W(ae), ae === null)
      throw Error("Expected getFirstCodeNodeOfLine to return a valid Code Node");
    return j === t.INDENT_CONTENT_COMMAND ? t.$isLineBreakNode(ae) ? ae.insertAfter(t.$createTabNode()) : ae.insertBefore(t.$createTabNode()) : t.$isTabNode(ae) && ae.remove(), !0;
  }
  function Y(j, Q) {
    let ae = t.$getSelection();
    if (!t.$isRangeSelection(ae))
      return !1;
    let { anchor: de, focus: Ne } = ae, De = de.offset, Pe = Ne.offset, Le = de.getNode(), ke = Ne.getNode();
    var J = j === t.KEY_ARROW_UP_COMMAND;
    if (!A(ae) || !I(Le) && !t.$isTabNode(Le) || !I(ke) && !t.$isTabNode(ke))
      return !1;
    if (!Q.altKey) {
      if (ae.isCollapsed()) {
        if (j = Le.getParentOrThrow(), J && De === 0 && Le.getPreviousSibling() === null) {
          if (j.getPreviousSibling() === null)
            return j.selectPrevious(), Q.preventDefault(), !0;
        } else if (!J && De === Le.getTextContentSize() && Le.getNextSibling() === null && j.getNextSibling() === null)
          return j.selectNext(), Q.preventDefault(), !0;
      }
      return !1;
    }
    let G;
    if (Le.isBefore(ke)) {
      var H = W(Le);
      G = $(ke);
    } else
      H = W(ke), G = $(Le);
    if (H == null || G == null)
      return !1;
    let re = H.getNodesBetween(G);
    for (let me = 0; me < re.length; me++) {
      let ge = re[me];
      if (!I(ge) && !t.$isTabNode(ge) && !t.$isLineBreakNode(ge))
        return !1;
    }
    if (Q.preventDefault(), Q.stopPropagation(), Q = J ? H.getPreviousSibling() : G.getNextSibling(), !t.$isLineBreakNode(Q) || (H = J ? Q.getPreviousSibling() : Q.getNextSibling(), H == null))
      return !0;
    J = I(H) || t.$isTabNode(H) || t.$isLineBreakNode(H) ? J ? W(H) : $(H) : null;
    let le = J ?? H;
    return Q.remove(), re.forEach((me) => me.remove()), j === t.KEY_ARROW_UP_COMMAND ? (re.forEach((me) => le.insertBefore(me)), le.insertBefore(Q)) : (le.insertAfter(Q), le = Q, re.forEach((me) => {
      le.insertAfter(me), le = me;
    })), ae.setTextNodeRange(Le, De, ke, Pe), !0;
  }
  function se(j, Q) {
    let ae = t.$getSelection();
    if (!t.$isRangeSelection(ae))
      return !1;
    let { anchor: de, focus: Ne } = ae;
    var De = de.getNode();
    let Pe = Ne.getNode();
    if (j = j === t.MOVE_TO_START, !I(De) && !t.$isTabNode(De) || !I(Pe) && !t.$isTabNode(Pe))
      return !1;
    if (j)
      if (De = L(Pe, Ne.offset), De !== null) {
        let { node: Le, offset: ke } = De;
        t.$isLineBreakNode(Le) ? Le.selectNext(0, 0) : ae.setTextNodeRange(Le, ke, Le, ke);
      } else
        Pe.getParentOrThrow().selectStart();
    else
      P(Pe).select();
    return Q.preventDefault(), Q.stopPropagation(), !0;
  }
  return Pn.$createCodeHighlightNode = x, Pn.$createCodeNode = m, Pn.$isCodeHighlightNode = I, Pn.$isCodeNode = f, Pn.CODE_LANGUAGE_FRIENDLY_NAME_MAP = N, Pn.CODE_LANGUAGE_MAP = w, Pn.CodeHighlightNode = D, Pn.CodeNode = p, Pn.DEFAULT_CODE_LANGUAGE = "javascript", Pn.PrismTokenizer = B, Pn.getCodeLanguages = () => Object.keys(r.languages).filter((j) => typeof r.languages[j] != "function").sort(), Pn.getDefaultCodeLanguage = () => "javascript", Pn.getEndOfCodeInLine = P, Pn.getFirstCodeNodeOfLine = W, Pn.getLanguageFriendlyName = function(j) {
    return j = T(j), N[j] || j;
  }, Pn.getLastCodeNodeOfLine = $, Pn.getStartOfCodeInLine = L, Pn.normalizeCodeLang = T, Pn.registerCodeHighlighting = function(j, Q) {
    if (!j.hasNodes([p, D]))
      throw Error("CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor");
    return Q == null && (Q = B), n.mergeRegister(
      j.registerMutationListener(p, (ae) => {
        j.update(() => {
          for (let [De, Pe] of ae)
            if (Pe !== "destroyed") {
              var de = t.$getNodeByKey(De);
              if (de !== null)
                e: {
                  var Ne = de;
                  if (de = j.getElementByKey(Ne.getKey()), de === null)
                    break e;
                  Ne = Ne.getChildren();
                  let Le = Ne.length;
                  if (Le === de.__cachedChildrenLength)
                    break e;
                  de.__cachedChildrenLength = Le;
                  let ke = "1", J = 1;
                  for (let G = 0; G < Le; G++)
                    t.$isLineBreakNode(Ne[G]) && (ke += `
` + ++J);
                  de.setAttribute("data-gutter", ke);
                }
            }
        });
      }),
      j.registerNodeTransform(p, (ae) => oe(ae, j, Q)),
      j.registerNodeTransform(t.TextNode, (ae) => F(ae, j, Q)),
      j.registerNodeTransform(D, (ae) => F(ae, j, Q)),
      j.registerCommand(t.KEY_TAB_COMMAND, (ae) => {
        let de = ie(ae.shiftKey);
        return de === null ? !1 : (ae.preventDefault(), j.dispatchCommand(de, void 0), !0);
      }, t.COMMAND_PRIORITY_LOW),
      j.registerCommand(t.INSERT_TAB_COMMAND, () => {
        let ae = t.$getSelection();
        return A(ae) ? (t.$insertNodes([t.$createTabNode()]), !0) : !1;
      }, t.COMMAND_PRIORITY_LOW),
      j.registerCommand(t.INDENT_CONTENT_COMMAND, () => q(t.INDENT_CONTENT_COMMAND), t.COMMAND_PRIORITY_LOW),
      j.registerCommand(t.OUTDENT_CONTENT_COMMAND, () => q(t.OUTDENT_CONTENT_COMMAND), t.COMMAND_PRIORITY_LOW),
      j.registerCommand(t.KEY_ARROW_UP_COMMAND, (ae) => Y(t.KEY_ARROW_UP_COMMAND, ae), t.COMMAND_PRIORITY_LOW),
      j.registerCommand(t.KEY_ARROW_DOWN_COMMAND, (ae) => Y(t.KEY_ARROW_DOWN_COMMAND, ae), t.COMMAND_PRIORITY_LOW),
      j.registerCommand(t.MOVE_TO_END, (ae) => se(t.MOVE_TO_END, ae), t.COMMAND_PRIORITY_LOW),
      j.registerCommand(t.MOVE_TO_START, (ae) => se(t.MOVE_TO_START, ae), t.COMMAND_PRIORITY_LOW)
    );
  }, Pn;
}
const Lp = process.env.NODE_ENV === "development" ? Ap() : Dp();
var va = Lp, cl = {}, kd;
function Ip() {
  if (kd)
    return cl;
  kd = 1;
  var r = kt(), n = St();
  class t extends n.TextNode {
    static getType() {
      return "hashtag";
    }
    static clone(m) {
      return new t(m.__text, m.__key);
    }
    constructor(m, f) {
      super(m, f);
    }
    createDOM(m) {
      const f = super.createDOM(m);
      return r.addClassNamesToElement(f, m.theme.hashtag), f;
    }
    static importJSON(m) {
      const f = o(m.text);
      return f.setFormat(m.format), f.setDetail(m.detail), f.setMode(m.mode), f.setStyle(m.style), f;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "hashtag"
      };
    }
    canInsertTextBefore() {
      return !1;
    }
    isTextEntity() {
      return !0;
    }
  }
  function o(p = "") {
    return n.$applyNodeReplacement(new t(p));
  }
  function u(p) {
    return p instanceof t;
  }
  return cl.$createHashtagNode = o, cl.$isHashtagNode = u, cl.HashtagNode = t, cl;
}
var ul = {}, Pd;
function $p() {
  if (Pd)
    return ul;
  Pd = 1;
  var r = kt(), n = St();
  class t extends n.TextNode {
    static getType() {
      return "hashtag";
    }
    static clone(p) {
      return new t(p.__text, p.__key);
    }
    constructor(p, m) {
      super(p, m);
    }
    createDOM(p) {
      let m = super.createDOM(p);
      return r.addClassNamesToElement(m, p.theme.hashtag), m;
    }
    static importJSON(p) {
      let m = o(p.text);
      return m.setFormat(p.format), m.setDetail(p.detail), m.setMode(p.mode), m.setStyle(p.style), m;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "hashtag" };
    }
    canInsertTextBefore() {
      return !1;
    }
    isTextEntity() {
      return !0;
    }
  }
  function o(u = "") {
    return n.$applyNodeReplacement(new t(u));
  }
  return ul.$createHashtagNode = o, ul.$isHashtagNode = function(u) {
    return u instanceof t;
  }, ul.HashtagNode = t, ul;
}
const kp = process.env.NODE_ENV === "development" ? Ip() : $p();
var Pp = kp, uo = {}, Fd;
function Fp() {
  if (Fd)
    return uo;
  Fd = 1;
  var r = kt(), n = St();
  const t = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
  class o extends n.ElementNode {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "link";
    }
    static clone(_) {
      return new o(_.__url, {
        rel: _.__rel,
        target: _.__target,
        title: _.__title
      }, _.__key);
    }
    constructor(_, N = {}, w) {
      super(w);
      const {
        target: T = null,
        rel: D = null,
        title: C = null
      } = N;
      this.__url = _, this.__target = T, this.__rel = D, this.__title = C;
    }
    createDOM(_) {
      const N = document.createElement("a");
      return N.href = this.sanitizeUrl(this.__url), this.__target !== null && (N.target = this.__target), this.__rel !== null && (N.rel = this.__rel), this.__title !== null && (N.title = this.__title), r.addClassNamesToElement(N, _.theme.link), N;
    }
    updateDOM(_, N, w) {
      const T = this.__url, D = this.__target, C = this.__rel, x = this.__title;
      return T !== _.__url && (N.href = T), D !== _.__target && (D ? N.target = D : N.removeAttribute("target")), C !== _.__rel && (C ? N.rel = C : N.removeAttribute("rel")), x !== _.__title && (x ? N.title = x : N.removeAttribute("title")), !1;
    }
    static importDOM() {
      return {
        a: (_) => ({
          conversion: u,
          priority: 1
        })
      };
    }
    static importJSON(_) {
      const N = p(_.url, {
        rel: _.rel,
        target: _.target,
        title: _.title
      });
      return N.setFormat(_.format), N.setIndent(_.indent), N.setDirection(_.direction), N;
    }
    sanitizeUrl(_) {
      try {
        const N = new URL(_);
        if (!t.has(N.protocol))
          return "about:blank";
      } catch {
        return _;
      }
      return _;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        rel: this.getRel(),
        target: this.getTarget(),
        title: this.getTitle(),
        type: "link",
        url: this.getURL(),
        version: 1
      };
    }
    getURL() {
      return this.getLatest().__url;
    }
    setURL(_) {
      const N = this.getWritable();
      N.__url = _;
    }
    getTarget() {
      return this.getLatest().__target;
    }
    setTarget(_) {
      const N = this.getWritable();
      N.__target = _;
    }
    getRel() {
      return this.getLatest().__rel;
    }
    setRel(_) {
      const N = this.getWritable();
      N.__rel = _;
    }
    getTitle() {
      return this.getLatest().__title;
    }
    setTitle(_) {
      const N = this.getWritable();
      N.__title = _;
    }
    insertNewAfter(_, N = !0) {
      const w = p(this.__url, {
        rel: this.__rel,
        target: this.__target,
        title: this.__title
      });
      return this.insertAfter(w, N), w;
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isInline() {
      return !0;
    }
    extractWithChild(_, N, w) {
      if (!n.$isRangeSelection(N))
        return !1;
      const T = N.anchor.getNode(), D = N.focus.getNode();
      return this.isParentOf(T) && this.isParentOf(D) && N.getTextContent().length > 0;
    }
  }
  function u(g) {
    let _ = null;
    if (r.isHTMLAnchorElement(g)) {
      const N = g.textContent;
      (N !== null && N !== "" || g.children.length > 0) && (_ = p(g.getAttribute("href") || "", {
        rel: g.getAttribute("rel"),
        target: g.getAttribute("target"),
        title: g.getAttribute("title")
      }));
    }
    return {
      node: _
    };
  }
  function p(g, _) {
    return n.$applyNodeReplacement(new o(g, _));
  }
  function m(g) {
    return g instanceof o;
  }
  class f extends o {
    static getType() {
      return "autolink";
    }
    static clone(_) {
      return new f(_.__url, {
        rel: _.__rel,
        target: _.__target,
        title: _.__title
      }, _.__key);
    }
    static importJSON(_) {
      const N = O(_.url, {
        rel: _.rel,
        target: _.target,
        title: _.title
      });
      return N.setFormat(_.format), N.setIndent(_.indent), N.setDirection(_.direction), N;
    }
    static importDOM() {
      return null;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "autolink",
        version: 1
      };
    }
    insertNewAfter(_, N = !0) {
      const w = this.getParentOrThrow().insertNewAfter(_, N);
      if (n.$isElementNode(w)) {
        const T = O(this.__url, {
          rel: this.__rel,
          target: this.__target,
          title: this.__title
        });
        return w.append(T), T;
      }
      return null;
    }
  }
  function O(g, _) {
    return n.$applyNodeReplacement(new f(g, _));
  }
  function S(g) {
    return g instanceof f;
  }
  const E = n.createCommand("TOGGLE_LINK_COMMAND");
  function R(g, _ = {}) {
    const {
      target: N,
      title: w
    } = _, T = _.rel === void 0 ? "noreferrer" : _.rel, D = n.$getSelection();
    if (!n.$isRangeSelection(D))
      return;
    const C = D.extract();
    if (g === null)
      C.forEach((x) => {
        const I = x.getParent();
        if (m(I)) {
          const W = I.getChildren();
          for (let $ = 0; $ < W.length; $++)
            I.insertBefore(W[$]);
          I.remove();
        }
      });
    else {
      if (C.length === 1) {
        const W = C[0], $ = y(W, m);
        if ($ !== null) {
          $.setURL(g), N !== void 0 && $.setTarget(N), T !== null && $.setRel(T), w !== void 0 && $.setTitle(w);
          return;
        }
      }
      let x = null, I = null;
      C.forEach((W) => {
        const $ = W.getParent();
        if (!($ === I || $ === null || n.$isElementNode(W) && !W.isInline())) {
          if (m($)) {
            I = $, $.setURL(g), N !== void 0 && $.setTarget(N), T !== null && I.setRel(T), w !== void 0 && I.setTitle(w);
            return;
          }
          if ($.is(x) || (x = $, I = p(g, {
            rel: T,
            target: N,
            title: w
          }), m($) ? W.getPreviousSibling() === null ? $.insertBefore(I) : $.insertAfter(I) : W.insertBefore(I)), m(W)) {
            if (W.is(I))
              return;
            if (I !== null) {
              const B = W.getChildren();
              for (let L = 0; L < B.length; L++)
                I.append(B[L]);
            }
            W.remove();
            return;
          }
          I !== null && I.append(W);
        }
      });
    }
  }
  function y(g, _) {
    let N = g;
    for (; N !== null && N.getParent() !== null && !_(N); )
      N = N.getParentOrThrow();
    return _(N) ? N : null;
  }
  return uo.$createAutoLinkNode = O, uo.$createLinkNode = p, uo.$isAutoLinkNode = S, uo.$isLinkNode = m, uo.AutoLinkNode = f, uo.LinkNode = o, uo.TOGGLE_LINK_COMMAND = E, uo.toggleLink = R, uo;
}
var fo = {}, Bd;
function Bp() {
  if (Bd)
    return fo;
  Bd = 1;
  var r = kt(), n = St();
  let t = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
  class o extends n.ElementNode {
    static getType() {
      return "link";
    }
    static clone(y) {
      return new o(y.__url, { rel: y.__rel, target: y.__target, title: y.__title }, y.__key);
    }
    constructor(y, g = {}, _) {
      super(_);
      let { target: N = null, rel: w = null, title: T = null } = g;
      this.__url = y, this.__target = N, this.__rel = w, this.__title = T;
    }
    createDOM(y) {
      let g = document.createElement("a");
      return g.href = this.sanitizeUrl(this.__url), this.__target !== null && (g.target = this.__target), this.__rel !== null && (g.rel = this.__rel), this.__title !== null && (g.title = this.__title), r.addClassNamesToElement(
        g,
        y.theme.link
      ), g;
    }
    updateDOM(y, g) {
      let _ = this.__url, N = this.__target, w = this.__rel, T = this.__title;
      return _ !== y.__url && (g.href = _), N !== y.__target && (N ? g.target = N : g.removeAttribute("target")), w !== y.__rel && (w ? g.rel = w : g.removeAttribute("rel")), T !== y.__title && (T ? g.title = T : g.removeAttribute("title")), !1;
    }
    static importDOM() {
      return { a: () => ({ conversion: u, priority: 1 }) };
    }
    static importJSON(y) {
      let g = p(y.url, { rel: y.rel, target: y.target, title: y.title });
      return g.setFormat(y.format), g.setIndent(y.indent), g.setDirection(y.direction), g;
    }
    sanitizeUrl(y) {
      try {
        let g = new URL(y);
        if (!t.has(g.protocol))
          return "about:blank";
      } catch {
      }
      return y;
    }
    exportJSON() {
      return { ...super.exportJSON(), rel: this.getRel(), target: this.getTarget(), title: this.getTitle(), type: "link", url: this.getURL(), version: 1 };
    }
    getURL() {
      return this.getLatest().__url;
    }
    setURL(y) {
      this.getWritable().__url = y;
    }
    getTarget() {
      return this.getLatest().__target;
    }
    setTarget(y) {
      this.getWritable().__target = y;
    }
    getRel() {
      return this.getLatest().__rel;
    }
    setRel(y) {
      this.getWritable().__rel = y;
    }
    getTitle() {
      return this.getLatest().__title;
    }
    setTitle(y) {
      this.getWritable().__title = y;
    }
    insertNewAfter(y, g = !0) {
      return y = p(this.__url, { rel: this.__rel, target: this.__target, title: this.__title }), this.insertAfter(y, g), y;
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isInline() {
      return !0;
    }
    extractWithChild(y, g) {
      if (!n.$isRangeSelection(g))
        return !1;
      y = g.anchor.getNode();
      let _ = g.focus.getNode();
      return this.isParentOf(y) && this.isParentOf(_) && 0 < g.getTextContent().length;
    }
  }
  function u(R) {
    let y = null;
    if (r.isHTMLAnchorElement(R)) {
      let g = R.textContent;
      (g !== null && g !== "" || 0 < R.children.length) && (y = p(R.getAttribute("href") || "", { rel: R.getAttribute("rel"), target: R.getAttribute("target"), title: R.getAttribute("title") }));
    }
    return { node: y };
  }
  function p(R, y) {
    return n.$applyNodeReplacement(new o(R, y));
  }
  function m(R) {
    return R instanceof o;
  }
  class f extends o {
    static getType() {
      return "autolink";
    }
    static clone(y) {
      return new f(y.__url, { rel: y.__rel, target: y.__target, title: y.__title }, y.__key);
    }
    static importJSON(y) {
      let g = O(y.url, { rel: y.rel, target: y.target, title: y.title });
      return g.setFormat(y.format), g.setIndent(y.indent), g.setDirection(y.direction), g;
    }
    static importDOM() {
      return null;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "autolink", version: 1 };
    }
    insertNewAfter(y, g = !0) {
      return y = this.getParentOrThrow().insertNewAfter(y, g), n.$isElementNode(y) ? (g = O(this.__url, { rel: this.__rel, target: this.__target, title: this.__title }), y.append(g), g) : null;
    }
  }
  function O(R, y) {
    return n.$applyNodeReplacement(new f(R, y));
  }
  let S = n.createCommand("TOGGLE_LINK_COMMAND");
  function E(R, y) {
    for (; R !== null && R.getParent() !== null && !y(R); )
      R = R.getParentOrThrow();
    return y(R) ? R : null;
  }
  return fo.$createAutoLinkNode = O, fo.$createLinkNode = p, fo.$isAutoLinkNode = function(R) {
    return R instanceof f;
  }, fo.$isLinkNode = m, fo.AutoLinkNode = f, fo.LinkNode = o, fo.TOGGLE_LINK_COMMAND = S, fo.toggleLink = function(R, y = {}) {
    let { target: g, title: _ } = y, N = y.rel === void 0 ? "noreferrer" : y.rel;
    if (y = n.$getSelection(), n.$isRangeSelection(y))
      if (y = y.extract(), R === null)
        y.forEach((w) => {
          if (w = w.getParent(), m(w)) {
            let T = w.getChildren();
            for (let D = 0; D < T.length; D++)
              w.insertBefore(T[D]);
            w.remove();
          }
        });
      else {
        if (y.length === 1) {
          let D = E(y[0], m);
          if (D !== null) {
            D.setURL(R), g !== void 0 && D.setTarget(g), N !== null && D.setRel(N), _ !== void 0 && D.setTitle(_);
            return;
          }
        }
        let w = null, T = null;
        y.forEach((D) => {
          var C = D.getParent();
          if (C !== T && C !== null && (!n.$isElementNode(D) || D.isInline()))
            if (m(C))
              T = C, C.setURL(R), g !== void 0 && C.setTarget(g), N !== null && T.setRel(N), _ !== void 0 && T.setTitle(_);
            else if (C.is(w) || (w = C, T = p(R, { rel: N, target: g, title: _ }), m(C) ? D.getPreviousSibling() === null ? C.insertBefore(T) : C.insertAfter(T) : D.insertBefore(T)), m(D)) {
              if (!D.is(T)) {
                if (T !== null) {
                  C = D.getChildren();
                  for (let x = 0; x < C.length; x++)
                    T.append(C[x]);
                }
                D.remove();
              }
            } else
              T !== null && T.append(D);
        });
      }
  }, fo;
}
const Kp = process.env.NODE_ENV === "development" ? Fp() : Bp();
var dn = Kp, ur = {}, Kd;
function jp() {
  if (Kd)
    return ur;
  Kd = 1;
  var r = St(), n = kt();
  function t(q) {
    let Y = 1, se = q.getParent();
    for (; se != null; ) {
      if (B(se)) {
        const j = se.getParent();
        if (te(j)) {
          Y++, se = j.getParent();
          continue;
        }
        throw Error("A ListItemNode must have a ListNode for a parent.");
      }
      return Y;
    }
    return Y;
  }
  function o(q) {
    let Y = q.getParent();
    if (!te(Y))
      throw Error("A ListItemNode must have a ListNode for a parent.");
    let se = Y;
    for (; se !== null; )
      se = se.getParent(), te(se) && (Y = se);
    return Y;
  }
  function u(q) {
    let Y = [];
    const se = q.getChildren().filter(B);
    for (let j = 0; j < se.length; j++) {
      const Q = se[j], ae = Q.getFirstChild();
      te(ae) ? Y = Y.concat(u(ae)) : Y.push(Q);
    }
    return Y;
  }
  function p(q) {
    return B(q) && te(q.getFirstChild());
  }
  function m(q) {
    let Y = q;
    for (; Y.getNextSibling() == null && Y.getPreviousSibling() == null; ) {
      const se = Y.getParent();
      if (se == null || !(B(Y) || te(Y)))
        break;
      Y = se;
    }
    Y.remove();
  }
  function f(q) {
    return $().append(q);
  }
  function O(q, Y) {
    return B(q) && (Y.length === 0 || Y.length === 1 && q.is(Y[0]) && q.getChildrenSize() === 0);
  }
  function S(q) {
    const Y = q.getParent();
    let se = 1;
    if (Y != null)
      if (te(Y))
        se = Y.getStart();
      else
        throw Error("$getListItemValue: list node is not parent of list item node");
    const j = q.getPreviousSiblings();
    for (let Q = 0; Q < j.length; Q++) {
      const ae = j[Q];
      B(ae) && !te(ae.getFirstChild()) && se++;
    }
    return se;
  }
  function E(q, Y) {
    q.update(() => {
      const se = r.$getSelection();
      if (se !== null) {
        const j = se.getNodes(), Q = se.getStartEndPoints();
        if (Q === null)
          throw Error("insertList: anchor should be defined");
        const [ae] = Q, de = ae.getNode(), Ne = de.getParent();
        if (O(de, j)) {
          const De = ne(Y);
          if (r.$isRootOrShadowRoot(Ne)) {
            de.replace(De);
            const Pe = $();
            r.$isElementNode(de) && (Pe.setFormat(de.getFormatType()), Pe.setIndent(de.getIndent())), De.append(Pe);
          } else if (B(de)) {
            const Pe = de.getParentOrThrow();
            R(De, Pe.getChildren()), Pe.replace(De);
          }
          return;
        } else {
          const De = /* @__PURE__ */ new Set();
          for (let Pe = 0; Pe < j.length; Pe++) {
            const Le = j[Pe];
            if (r.$isElementNode(Le) && Le.isEmpty() && !B(Le) && !De.has(Le.getKey())) {
              y(Le, Y);
              continue;
            }
            if (r.$isLeafNode(Le)) {
              let ke = Le.getParent();
              for (; ke != null; ) {
                const J = ke.getKey();
                if (te(ke)) {
                  if (!De.has(J)) {
                    const G = ne(Y);
                    R(G, ke.getChildren()), ke.replace(G), N(G), De.add(J);
                  }
                  break;
                } else {
                  const G = ke.getParent();
                  if (r.$isRootOrShadowRoot(G) && !De.has(J)) {
                    De.add(J), y(ke, Y);
                    break;
                  }
                  ke = G;
                }
              }
            }
          }
        }
      }
    });
  }
  function R(q, Y) {
    q.splice(q.getChildrenSize(), 0, Y);
  }
  function y(q, Y) {
    if (te(q))
      return q;
    const se = q.getPreviousSibling(), j = q.getNextSibling(), Q = $();
    if (Q.setFormat(q.getFormatType()), Q.setIndent(q.getIndent()), R(Q, q.getChildren()), te(se) && Y === se.getListType())
      return se.append(Q), q.remove(), te(j) && Y === j.getListType() && (R(se, j.getChildren()), j.remove()), se;
    if (te(j) && Y === j.getListType())
      return j.getFirstChildOrThrow().insertBefore(Q), q.remove(), j;
    {
      const ae = ne(Y);
      return ae.append(Q), q.replace(ae), N(ae), ae;
    }
  }
  function g(q, Y) {
    const se = q.getLastChild(), j = Y.getFirstChild();
    se && j && p(se) && p(j) && (g(se.getFirstChild(), j.getFirstChild()), j.remove());
    const Q = Y.getChildren();
    Q.length > 0 && (q.append(...Q), N(q)), Y.remove();
  }
  function _(q) {
    q.update(() => {
      const Y = r.$getSelection();
      if (r.$isRangeSelection(Y)) {
        const se = /* @__PURE__ */ new Set(), j = Y.getNodes(), Q = Y.anchor.getNode();
        if (O(Q, j))
          se.add(o(Q));
        else
          for (let ae = 0; ae < j.length; ae++) {
            const de = j[ae];
            if (r.$isLeafNode(de)) {
              const Ne = n.$getNearestNodeOfType(de, C);
              Ne != null && se.add(o(Ne));
            }
          }
        for (const ae of se) {
          let de = ae;
          const Ne = u(ae);
          for (const De of Ne) {
            const Pe = r.$createParagraphNode();
            R(Pe, De.getChildren()), de.insertAfter(Pe), de = Pe, De.__key === Y.anchor.key && Y.anchor.set(Pe.getKey(), 0, "element"), De.__key === Y.focus.key && Y.focus.set(Pe.getKey(), 0, "element"), De.remove();
          }
          ae.remove();
        }
      }
    });
  }
  function N(q, Y) {
    const se = Y || q.getChildren();
    if (se !== void 0)
      for (let j = 0; j < se.length; j++) {
        const Q = se[j];
        if (B(Q)) {
          const ae = Q.getValue(), de = S(Q);
          ae !== de && Q.setValue(de);
        }
      }
  }
  function w(q) {
    const Y = /* @__PURE__ */ new Set();
    if (p(q) || Y.has(q.getKey()))
      return;
    const se = q.getParent(), j = q.getNextSibling(), Q = q.getPreviousSibling();
    if (p(j) && p(Q)) {
      const ae = Q.getFirstChild();
      if (te(ae)) {
        ae.append(q);
        const de = j.getFirstChild();
        if (te(de)) {
          const Ne = de.getChildren();
          R(ae, Ne), j.remove(), Y.add(j.getKey());
        }
        N(ae);
      }
    } else if (p(j)) {
      const ae = j.getFirstChild();
      if (te(ae)) {
        const de = ae.getFirstChild();
        de !== null && de.insertBefore(q), N(ae);
      }
    } else if (p(Q)) {
      const ae = Q.getFirstChild();
      te(ae) && (ae.append(q), N(ae));
    } else if (te(se)) {
      const ae = $(), de = ne(se.getListType());
      ae.append(de), de.append(q), Q ? Q.insertAfter(ae) : j ? j.insertBefore(ae) : se.append(ae), N(de);
    }
    te(se) && N(se);
  }
  function T(q) {
    if (p(q))
      return;
    const Y = q.getParent(), se = Y ? Y.getParent() : void 0, j = se ? se.getParent() : void 0;
    if (te(j) && B(se) && te(Y)) {
      const Q = Y ? Y.getFirstChild() : void 0, ae = Y ? Y.getLastChild() : void 0;
      if (q.is(Q))
        se.insertBefore(q), Y.isEmpty() && se.remove();
      else if (q.is(ae))
        se.insertAfter(q), Y.isEmpty() && se.remove();
      else {
        const de = Y.getListType(), Ne = $(), De = ne(de);
        Ne.append(De), q.getPreviousSiblings().forEach((ke) => De.append(ke));
        const Pe = $(), Le = ne(de);
        Pe.append(Le), R(Le, q.getNextSiblings()), se.insertBefore(Ne), se.insertAfter(Pe), se.replace(q);
      }
      N(Y), N(j);
    }
  }
  function D() {
    const q = r.$getSelection();
    if (!r.$isRangeSelection(q) || !q.isCollapsed())
      return !1;
    const Y = q.anchor.getNode();
    if (!B(Y) || Y.getChildrenSize() !== 0)
      return !1;
    const se = o(Y), j = Y.getParent();
    if (!te(j))
      throw Error("A ListItemNode must have a ListNode for a parent.");
    const Q = j.getParent();
    let ae;
    if (r.$isRootOrShadowRoot(Q))
      ae = r.$createParagraphNode(), se.insertAfter(ae);
    else if (B(Q))
      ae = $(), Q.insertAfter(ae);
    else
      return !1;
    ae.select();
    const de = Y.getNextSiblings();
    if (de.length > 0) {
      const Ne = ne(j.getListType());
      if (r.$isParagraphNode(ae))
        ae.insertAfter(Ne);
      else {
        const De = $();
        De.append(Ne), ae.insertAfter(De);
      }
      de.forEach((De) => {
        De.remove(), Ne.append(De);
      });
    }
    return m(Y), !0;
  }
  class C extends r.ElementNode {
    /** @internal */
    /** @internal */
    static getType() {
      return "listitem";
    }
    static clone(Y) {
      return new C(Y.__value, Y.__checked, Y.__key);
    }
    constructor(Y, se, j) {
      super(j), this.__value = Y === void 0 ? 1 : Y, this.__checked = se;
    }
    createDOM(Y) {
      const se = document.createElement("li"), j = this.getParent();
      return te(j) && j.getListType() === "check" && I(se, this, null), se.value = this.__value, x(se, Y.theme, this), se;
    }
    updateDOM(Y, se, j) {
      const Q = this.getParent();
      return te(Q) && Q.getListType() === "check" && I(se, this, Y), se.value = this.__value, x(se, j.theme, this), !1;
    }
    static transform() {
      return (Y) => {
        const se = Y.getParent();
        if (te(se)) {
          if (N(se), !B(Y))
            throw Error("node is not a ListItemNode");
          se.getListType() !== "check" && Y.getChecked() != null && Y.setChecked(void 0);
        }
      };
    }
    static importDOM() {
      return {
        li: (Y) => ({
          conversion: W,
          priority: 0
        })
      };
    }
    static importJSON(Y) {
      const se = $();
      return se.setChecked(Y.checked), se.setValue(Y.value), se.setFormat(Y.format), se.setDirection(Y.direction), se;
    }
    exportDOM(Y) {
      const se = this.createDOM(Y._config);
      return se.style.textAlign = this.getFormatType(), {
        element: se
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        checked: this.getChecked(),
        type: "listitem",
        value: this.getValue(),
        version: 1
      };
    }
    append(...Y) {
      for (let se = 0; se < Y.length; se++) {
        const j = Y[se];
        if (r.$isElementNode(j) && this.canMergeWith(j)) {
          const Q = j.getChildren();
          this.append(...Q), j.remove();
        } else
          super.append(j);
      }
      return this;
    }
    replace(Y, se) {
      if (B(Y))
        return super.replace(Y);
      this.setIndent(0);
      const j = this.getParentOrThrow();
      if (!te(j))
        return Y;
      if (j.__first === this.getKey())
        j.insertBefore(Y);
      else if (j.__last === this.getKey())
        j.insertAfter(Y);
      else {
        const Q = ne(j.getListType());
        let ae = this.getNextSibling();
        for (; ae; ) {
          const de = ae;
          ae = ae.getNextSibling(), Q.append(de);
        }
        j.insertAfter(Y), Y.insertAfter(Q);
      }
      if (se) {
        if (!r.$isElementNode(Y))
          throw Error("includeChildren should only be true for ElementNodes");
        this.getChildren().forEach((Q) => {
          Y.append(Q);
        });
      }
      return this.remove(), j.getChildrenSize() === 0 && j.remove(), Y;
    }
    insertAfter(Y, se = !0) {
      const j = this.getParentOrThrow();
      if (!te(j))
        throw Error("insertAfter: list node is not parent of list item node");
      const Q = this.getNextSiblings();
      if (B(Y)) {
        const ae = super.insertAfter(Y, se), de = Y.getParentOrThrow();
        return te(de) && N(de), ae;
      }
      if (te(Y)) {
        let ae = Y;
        const de = Y.getChildren();
        for (let Ne = de.length - 1; Ne >= 0; Ne--)
          ae = de[Ne], this.insertAfter(ae, se);
        return ae;
      }
      if (j.insertAfter(Y, se), Q.length !== 0) {
        const ae = ne(j.getListType());
        Q.forEach((de) => ae.append(de)), Y.insertAfter(ae, se);
      }
      return Y;
    }
    remove(Y) {
      const se = this.getPreviousSibling(), j = this.getNextSibling();
      if (super.remove(Y), se && j && p(se) && p(j))
        g(se.getFirstChild(), j.getFirstChild()), j.remove();
      else if (j) {
        const Q = j.getParent();
        te(Q) && N(Q);
      }
    }
    insertNewAfter(Y, se = !0) {
      const j = $(this.__checked == null ? void 0 : !1);
      return this.insertAfter(j, se), j;
    }
    collapseAtStart(Y) {
      const se = r.$createParagraphNode();
      this.getChildren().forEach((Ne) => se.append(Ne));
      const Q = this.getParentOrThrow(), ae = Q.getParentOrThrow(), de = B(ae);
      if (Q.getChildrenSize() === 1)
        if (de)
          Q.remove(), ae.select();
        else {
          Q.insertBefore(se), Q.remove();
          const Ne = Y.anchor, De = Y.focus, Pe = se.getKey();
          Ne.type === "element" && Ne.getNode().is(this) && Ne.set(Pe, Ne.offset, "element"), De.type === "element" && De.getNode().is(this) && De.set(Pe, De.offset, "element");
        }
      else
        Q.insertBefore(se), this.remove();
      return !0;
    }
    getValue() {
      return this.getLatest().__value;
    }
    setValue(Y) {
      const se = this.getWritable();
      se.__value = Y;
    }
    getChecked() {
      return this.getLatest().__checked;
    }
    setChecked(Y) {
      const se = this.getWritable();
      se.__checked = Y;
    }
    toggleChecked() {
      this.setChecked(!this.__checked);
    }
    getIndent() {
      const Y = this.getParent();
      if (Y === null)
        return this.getLatest().__indent;
      let se = Y.getParentOrThrow(), j = 0;
      for (; B(se); )
        se = se.getParentOrThrow().getParentOrThrow(), j++;
      return j;
    }
    setIndent(Y) {
      if (!(typeof Y == "number" && Y > -1))
        throw Error("Invalid indent value.");
      let se = this.getIndent();
      for (; se !== Y; )
        se < Y ? (w(this), se++) : (T(this), se--);
      return this;
    }
    insertBefore(Y) {
      if (B(Y)) {
        const se = this.getParentOrThrow();
        if (te(se)) {
          const j = this.getNextSiblings();
          N(se, j);
        }
      }
      return super.insertBefore(Y);
    }
    canInsertAfter(Y) {
      return B(Y);
    }
    canReplaceWith(Y) {
      return B(Y);
    }
    canMergeWith(Y) {
      return r.$isParagraphNode(Y) || B(Y);
    }
    extractWithChild(Y, se) {
      if (!r.$isRangeSelection(se))
        return !1;
      const j = se.anchor.getNode(), Q = se.focus.getNode();
      return this.isParentOf(j) && this.isParentOf(Q) && this.getTextContent().length === se.getTextContent().length;
    }
    isParentRequired() {
      return !0;
    }
    createParentElementNode() {
      return ne("bullet");
    }
  }
  function x(q, Y, se) {
    const j = [], Q = [], ae = Y.list, de = ae ? ae.listitem : void 0;
    let Ne;
    if (ae && ae.nested && (Ne = ae.nested.listitem), de !== void 0) {
      const De = de.split(" ");
      j.push(...De);
    }
    if (ae) {
      const De = se.getParent(), Pe = te(De) && De.getListType() === "check", Le = se.getChecked();
      (!Pe || Le) && Q.push(ae.listitemUnchecked), (!Pe || !Le) && Q.push(ae.listitemChecked), Pe && j.push(Le ? ae.listitemChecked : ae.listitemUnchecked);
    }
    if (Ne !== void 0) {
      const De = Ne.split(" ");
      se.getChildren().some((Pe) => te(Pe)) ? j.push(...De) : Q.push(...De);
    }
    Q.length > 0 && n.removeClassNamesFromElement(q, ...Q), j.length > 0 && n.addClassNamesToElement(q, ...j);
  }
  function I(q, Y, se, j) {
    te(Y.getFirstChild()) ? (q.removeAttribute("role"), q.removeAttribute("tabIndex"), q.removeAttribute("aria-checked")) : (q.setAttribute("role", "checkbox"), q.setAttribute("tabIndex", "-1"), (!se || Y.__checked !== se.__checked) && q.setAttribute("aria-checked", Y.getChecked() ? "true" : "false"));
  }
  function W(q) {
    const Y = n.isHTMLElement(q) && q.getAttribute("aria-checked") === "true";
    return {
      node: $(Y)
    };
  }
  function $(q) {
    return r.$applyNodeReplacement(new C(void 0, q));
  }
  function B(q) {
    return q instanceof C;
  }
  class L extends r.ElementNode {
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "list";
    }
    static clone(Y) {
      const se = Y.__listType || oe[Y.__tag];
      return new L(se, Y.__start, Y.__key);
    }
    constructor(Y, se, j) {
      super(j);
      const Q = oe[Y] || Y;
      this.__listType = Q, this.__tag = Q === "number" ? "ol" : "ul", this.__start = se;
    }
    getTag() {
      return this.__tag;
    }
    setListType(Y) {
      const se = this.getWritable();
      se.__listType = Y, se.__tag = Y === "number" ? "ol" : "ul";
    }
    getListType() {
      return this.__listType;
    }
    getStart() {
      return this.__start;
    }
    // View
    createDOM(Y, se) {
      const j = this.__tag, Q = document.createElement(j);
      return this.__start !== 1 && Q.setAttribute("start", String(this.__start)), Q.__lexicalListType = this.__listType, P(Q, Y.theme, this), Q;
    }
    updateDOM(Y, se, j) {
      return Y.__tag !== this.__tag ? !0 : (P(se, j.theme, this), !1);
    }
    static importDOM() {
      return {
        ol: (Y) => ({
          conversion: Z,
          priority: 0
        }),
        ul: (Y) => ({
          conversion: Z,
          priority: 0
        })
      };
    }
    static importJSON(Y) {
      const se = ne(Y.listType, Y.start);
      return se.setFormat(Y.format), se.setIndent(Y.indent), se.setDirection(Y.direction), se;
    }
    exportDOM(Y) {
      const {
        element: se
      } = super.exportDOM(Y);
      return se && n.isHTMLElement(se) && (this.__start !== 1 && se.setAttribute("start", String(this.__start)), this.__listType === "check" && se.setAttribute("__lexicalListType", "check")), {
        element: se
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        listType: this.getListType(),
        start: this.getStart(),
        tag: this.getTag(),
        type: "list",
        version: 1
      };
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
    append(...Y) {
      for (let se = 0; se < Y.length; se++) {
        const j = Y[se];
        if (B(j))
          super.append(j);
        else {
          const Q = $();
          if (te(j))
            Q.append(j);
          else if (r.$isElementNode(j)) {
            const ae = r.$createTextNode(j.getTextContent());
            Q.append(ae);
          } else
            Q.append(j);
          super.append(Q);
        }
      }
      return N(this), this;
    }
    extractWithChild(Y) {
      return B(Y);
    }
  }
  function P(q, Y, se) {
    const j = [], Q = [], ae = Y.list;
    if (ae !== void 0) {
      const de = ae[`${se.__tag}Depth`] || [], Ne = t(se) - 1, De = Ne % de.length, Pe = de[De], Le = ae[se.__tag];
      let ke;
      const J = ae.nested, G = ae.checklist;
      if (J !== void 0 && J.list && (ke = J.list), Le !== void 0 && j.push(Le), G !== void 0 && se.__listType === "check" && j.push(G), Pe !== void 0) {
        const H = Pe.split(" ");
        j.push(...H);
        for (let re = 0; re < de.length; re++)
          re !== De && Q.push(se.__tag + re);
      }
      if (ke !== void 0) {
        const H = ke.split(" ");
        Ne > 1 ? j.push(...H) : Q.push(...H);
      }
    }
    Q.length > 0 && n.removeClassNamesFromElement(q, ...Q), j.length > 0 && n.addClassNamesToElement(q, ...j);
  }
  function F(q) {
    const Y = [];
    for (let se = 0; se < q.length; se++) {
      const j = q[se];
      if (B(j)) {
        Y.push(j);
        const Q = j.getChildren();
        Q.length > 1 && Q.forEach((ae) => {
          te(ae) && Y.push(f(ae));
        });
      } else
        Y.push(f(j));
    }
    return Y;
  }
  function Z(q) {
    const Y = q.nodeName.toLowerCase();
    let se = null;
    if (Y === "ol") {
      const j = q.start;
      se = ne("number", j);
    } else
      Y === "ul" && (n.isHTMLElement(q) && q.getAttribute("__lexicallisttype") === "check" ? se = ne("check") : se = ne("bullet"));
    return {
      after: F,
      node: se
    };
  }
  const oe = {
    ol: "number",
    ul: "bullet"
  };
  function ne(q, Y = 1) {
    return r.$applyNodeReplacement(new L(q, Y));
  }
  function te(q) {
    return q instanceof L;
  }
  const K = r.createCommand("INSERT_UNORDERED_LIST_COMMAND"), A = r.createCommand("INSERT_ORDERED_LIST_COMMAND"), z = r.createCommand("INSERT_CHECK_LIST_COMMAND"), ie = r.createCommand("REMOVE_LIST_COMMAND");
  return ur.$createListItemNode = $, ur.$createListNode = ne, ur.$getListDepth = t, ur.$handleListInsertParagraph = D, ur.$isListItemNode = B, ur.$isListNode = te, ur.INSERT_CHECK_LIST_COMMAND = z, ur.INSERT_ORDERED_LIST_COMMAND = A, ur.INSERT_UNORDERED_LIST_COMMAND = K, ur.ListItemNode = C, ur.ListNode = L, ur.REMOVE_LIST_COMMAND = ie, ur.insertList = E, ur.removeList = _, ur;
}
var dr = {}, jd;
function Hp() {
  if (jd)
    return dr;
  jd = 1;
  var r = St(), n = kt();
  function t(K) {
    let A = new URLSearchParams();
    A.append("code", K);
    for (let z = 1; z < arguments.length; z++)
      A.append("v", arguments[z]);
    throw Error(`Minified Lexical error #${K}; visit https://lexical.dev/docs/error?${A} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  function o(K) {
    let A = 1;
    for (K = K.getParent(); K != null; ) {
      if (x(K)) {
        if (K = K.getParent(), F(K)) {
          A++, K = K.getParent();
          continue;
        }
        t(40);
      }
      break;
    }
    return A;
  }
  function u(K) {
    K = K.getParent(), F(K) || t(40);
    let A = K;
    for (; A !== null; )
      A = A.getParent(), F(A) && (K = A);
    return K;
  }
  function p(K) {
    let A = [];
    K = K.getChildren().filter(x);
    for (let z = 0; z < K.length; z++) {
      let ie = K[z], q = ie.getFirstChild();
      F(q) ? A = A.concat(p(q)) : A.push(ie);
    }
    return A;
  }
  function m(K) {
    return x(K) && F(K.getFirstChild());
  }
  function f(K) {
    for (; K.getNextSibling() == null && K.getPreviousSibling() == null; ) {
      let A = K.getParent();
      if (A == null || !x(K) && !F(K))
        break;
      K = A;
    }
    K.remove();
  }
  function O(K) {
    return C().append(K);
  }
  function S(K, A) {
    return x(K) && (A.length === 0 || A.length === 1 && K.is(A[0]) && K.getChildrenSize() === 0);
  }
  function E(K, A) {
    K.splice(K.getChildrenSize(), 0, A);
  }
  function R(K, A) {
    if (F(K))
      return K;
    let z = K.getPreviousSibling(), ie = K.getNextSibling(), q = C();
    return q.setFormat(K.getFormatType()), q.setIndent(K.getIndent()), E(q, K.getChildren()), F(z) && A === z.getListType() ? (z.append(q), K.remove(), F(ie) && A === ie.getListType() && (E(z, ie.getChildren()), ie.remove()), z) : F(ie) && A === ie.getListType() ? (ie.getFirstChildOrThrow().insertBefore(q), K.remove(), ie) : (A = P(A), A.append(q), K.replace(A), g(A), A);
  }
  function y(K, A) {
    var z = K.getLastChild();
    let ie = A.getFirstChild();
    z && ie && m(z) && m(ie) && (y(z.getFirstChild(), ie.getFirstChild()), ie.remove()), z = A.getChildren(), 0 < z.length && (K.append(...z), g(K)), A.remove();
  }
  function g(K, A) {
    if (K = A || K.getChildren(), K !== void 0)
      for (A = 0; A < K.length; A++) {
        let Y = K[A];
        if (x(Y)) {
          let se = Y.getValue();
          var z = Y, ie = z.getParent(), q = 1;
          for (ie != null && (F(ie) ? q = ie.getStart() : t(44)), z = z.getPreviousSiblings(), ie = 0; ie < z.length; ie++) {
            let j = z[ie];
            x(j) && !F(j.getFirstChild()) && q++;
          }
          se !== q && Y.setValue(q);
        }
      }
  }
  function _(K) {
    if (!m(K)) {
      var A = K.getParent(), z = A ? A.getParent() : void 0, ie = z ? z.getParent() : void 0;
      if (F(ie) && x(z) && F(A)) {
        var q = A ? A.getFirstChild() : void 0, Y = A ? A.getLastChild() : void 0;
        if (K.is(q))
          z.insertBefore(K), A.isEmpty() && z.remove();
        else if (K.is(Y))
          z.insertAfter(K), A.isEmpty() && z.remove();
        else {
          var se = A.getListType();
          q = C();
          let j = P(se);
          q.append(j), K.getPreviousSiblings().forEach((Q) => j.append(Q)), Y = C(), se = P(se), Y.append(se), E(se, K.getNextSiblings()), z.insertBefore(q), z.insertAfter(Y), z.replace(K);
        }
        g(A), g(ie);
      }
    }
  }
  class N extends r.ElementNode {
    static getType() {
      return "listitem";
    }
    static clone(A) {
      return new N(A.__value, A.__checked, A.__key);
    }
    constructor(A, z, ie) {
      super(ie), this.__value = A === void 0 ? 1 : A, this.__checked = z;
    }
    createDOM(A) {
      let z = document.createElement("li"), ie = this.getParent();
      return F(ie) && ie.getListType() === "check" && T(z, this, null), z.value = this.__value, w(z, A.theme, this), z;
    }
    updateDOM(A, z, ie) {
      let q = this.getParent();
      return F(q) && q.getListType() === "check" && T(z, this, A), z.value = this.__value, w(z, ie.theme, this), !1;
    }
    static transform() {
      return (A) => {
        let z = A.getParent();
        F(z) && (g(z), x(A) || t(144), z.getListType() !== "check" && A.getChecked() != null && A.setChecked(void 0));
      };
    }
    static importDOM() {
      return { li: () => ({ conversion: D, priority: 0 }) };
    }
    static importJSON(A) {
      let z = C();
      return z.setChecked(A.checked), z.setValue(A.value), z.setFormat(A.format), z.setDirection(A.direction), z;
    }
    exportDOM(A) {
      return A = this.createDOM(A._config), A.style.textAlign = this.getFormatType(), { element: A };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        checked: this.getChecked(),
        type: "listitem",
        value: this.getValue(),
        version: 1
      };
    }
    append(...A) {
      for (let z = 0; z < A.length; z++) {
        let ie = A[z];
        if (r.$isElementNode(ie) && this.canMergeWith(ie)) {
          let q = ie.getChildren();
          this.append(...q), ie.remove();
        } else
          super.append(ie);
      }
      return this;
    }
    replace(A, z) {
      if (x(A))
        return super.replace(A);
      this.setIndent(0);
      let ie = this.getParentOrThrow();
      if (!F(ie))
        return A;
      if (ie.__first === this.getKey())
        ie.insertBefore(A);
      else if (ie.__last === this.getKey())
        ie.insertAfter(A);
      else {
        let q = P(ie.getListType()), Y = this.getNextSibling();
        for (; Y; ) {
          let se = Y;
          Y = Y.getNextSibling(), q.append(se);
        }
        ie.insertAfter(A), A.insertAfter(q);
      }
      return z && (r.$isElementNode(A) || t(139), this.getChildren().forEach((q) => {
        A.append(q);
      })), this.remove(), ie.getChildrenSize() === 0 && ie.remove(), A;
    }
    insertAfter(A, z = !0) {
      var ie = this.getParentOrThrow();
      F(ie) || t(39);
      var q = this.getNextSiblings();
      if (x(A))
        return z = super.insertAfter(A, z), A = A.getParentOrThrow(), F(A) && g(A), z;
      if (F(A)) {
        for (ie = A, A = A.getChildren(), q = A.length - 1; 0 <= q; q--)
          ie = A[q], this.insertAfter(ie, z);
        return ie;
      }
      if (ie.insertAfter(A, z), q.length !== 0) {
        let Y = P(ie.getListType());
        q.forEach((se) => Y.append(se)), A.insertAfter(Y, z);
      }
      return A;
    }
    remove(A) {
      let z = this.getPreviousSibling(), ie = this.getNextSibling();
      super.remove(A), z && ie && m(z) && m(ie) ? (y(z.getFirstChild(), ie.getFirstChild()), ie.remove()) : ie && (A = ie.getParent(), F(A) && g(A));
    }
    insertNewAfter(A, z = !0) {
      return A = C(this.__checked == null ? void 0 : !1), this.insertAfter(A, z), A;
    }
    collapseAtStart(A) {
      let z = r.$createParagraphNode();
      this.getChildren().forEach((se) => z.append(se));
      var ie = this.getParentOrThrow(), q = ie.getParentOrThrow();
      let Y = x(q);
      return ie.getChildrenSize() === 1 ? Y ? (ie.remove(), q.select()) : (ie.insertBefore(z), ie.remove(), ie = A.anchor, A = A.focus, q = z.getKey(), ie.type === "element" && ie.getNode().is(this) && ie.set(q, ie.offset, "element"), A.type === "element" && A.getNode().is(this) && A.set(q, A.offset, "element")) : (ie.insertBefore(z), this.remove()), !0;
    }
    getValue() {
      return this.getLatest().__value;
    }
    setValue(A) {
      this.getWritable().__value = A;
    }
    getChecked() {
      return this.getLatest().__checked;
    }
    setChecked(A) {
      this.getWritable().__checked = A;
    }
    toggleChecked() {
      this.setChecked(!this.__checked);
    }
    getIndent() {
      var A = this.getParent();
      if (A === null)
        return this.getLatest().__indent;
      A = A.getParentOrThrow();
      let z = 0;
      for (; x(A); )
        A = A.getParentOrThrow().getParentOrThrow(), z++;
      return z;
    }
    setIndent(A) {
      typeof A == "number" && -1 < A || t(117);
      let z = this.getIndent();
      for (; z !== A; )
        if (z < A) {
          e: {
            var ie = /* @__PURE__ */ new Set();
            if (m(this) || ie.has(this.getKey()))
              break e;
            let j = this.getParent();
            var q = this.getNextSibling(), Y = this.getPreviousSibling();
            if (m(q) && m(Y)) {
              if (Y = Y.getFirstChild(), F(Y)) {
                Y.append(this);
                var se = q.getFirstChild();
                F(se) && (se = se.getChildren(), E(Y, se), q.remove(), ie.add(q.getKey())), g(Y);
              }
            } else
              m(q) ? (q = q.getFirstChild(), F(q) && (ie = q.getFirstChild(), ie !== null && ie.insertBefore(this), g(q))) : m(Y) ? (q = Y.getFirstChild(), F(q) && (q.append(this), g(q))) : F(j) && (ie = C(), se = P(j.getListType()), ie.append(se), se.append(this), Y ? Y.insertAfter(ie) : q ? q.insertBefore(ie) : j.append(ie), g(se));
            F(j) && g(j);
          }
          z++;
        } else
          _(this), z--;
      return this;
    }
    insertBefore(A) {
      if (x(A)) {
        let z = this.getParentOrThrow();
        if (F(z)) {
          let ie = this.getNextSiblings();
          g(z, ie);
        }
      }
      return super.insertBefore(A);
    }
    canInsertAfter(A) {
      return x(A);
    }
    canReplaceWith(A) {
      return x(A);
    }
    canMergeWith(A) {
      return r.$isParagraphNode(A) || x(A);
    }
    extractWithChild(A, z) {
      if (!r.$isRangeSelection(z))
        return !1;
      A = z.anchor.getNode();
      let ie = z.focus.getNode();
      return this.isParentOf(A) && this.isParentOf(ie) && this.getTextContent().length === z.getTextContent().length;
    }
    isParentRequired() {
      return !0;
    }
    createParentElementNode() {
      return P("bullet");
    }
  }
  function w(K, A, z) {
    let ie = [], q = [];
    var Y = (A = A.list) ? A.listitem : void 0;
    if (A && A.nested)
      var se = A.nested.listitem;
    if (Y !== void 0 && (Y = Y.split(" "), ie.push(...Y)), A) {
      Y = z.getParent(), Y = F(Y) && Y.getListType() === "check";
      let j = z.getChecked();
      Y && !j || q.push(A.listitemUnchecked), Y && j || q.push(A.listitemChecked), Y && ie.push(j ? A.listitemChecked : A.listitemUnchecked);
    }
    se !== void 0 && (se = se.split(" "), z.getChildren().some((j) => F(j)) ? ie.push(...se) : q.push(...se)), 0 < q.length && n.removeClassNamesFromElement(K, ...q), 0 < ie.length && n.addClassNamesToElement(
      K,
      ...ie
    );
  }
  function T(K, A, z) {
    F(A.getFirstChild()) ? (K.removeAttribute("role"), K.removeAttribute("tabIndex"), K.removeAttribute("aria-checked")) : (K.setAttribute("role", "checkbox"), K.setAttribute("tabIndex", "-1"), z && A.__checked === z.__checked || K.setAttribute("aria-checked", A.getChecked() ? "true" : "false"));
  }
  function D(K) {
    return K = n.isHTMLElement(K) && K.getAttribute("aria-checked") === "true", { node: C(K) };
  }
  function C(K) {
    return r.$applyNodeReplacement(new N(void 0, K));
  }
  function x(K) {
    return K instanceof N;
  }
  class I extends r.ElementNode {
    static getType() {
      return "list";
    }
    static clone(A) {
      return new I(A.__listType || L[A.__tag], A.__start, A.__key);
    }
    constructor(A, z, ie) {
      super(ie), this.__listType = A = L[A] || A, this.__tag = A === "number" ? "ol" : "ul", this.__start = z;
    }
    getTag() {
      return this.__tag;
    }
    setListType(A) {
      let z = this.getWritable();
      z.__listType = A, z.__tag = A === "number" ? "ol" : "ul";
    }
    getListType() {
      return this.__listType;
    }
    getStart() {
      return this.__start;
    }
    createDOM(A) {
      let z = document.createElement(this.__tag);
      return this.__start !== 1 && z.setAttribute(
        "start",
        String(this.__start)
      ), z.__lexicalListType = this.__listType, W(z, A.theme, this), z;
    }
    updateDOM(A, z, ie) {
      return A.__tag !== this.__tag ? !0 : (W(z, ie.theme, this), !1);
    }
    static importDOM() {
      return { ol: () => ({ conversion: B, priority: 0 }), ul: () => ({ conversion: B, priority: 0 }) };
    }
    static importJSON(A) {
      let z = P(A.listType, A.start);
      return z.setFormat(A.format), z.setIndent(A.indent), z.setDirection(A.direction), z;
    }
    exportDOM(A) {
      return { element: A } = super.exportDOM(A), A && n.isHTMLElement(A) && (this.__start !== 1 && A.setAttribute("start", String(this.__start)), this.__listType === "check" && A.setAttribute("__lexicalListType", "check")), { element: A };
    }
    exportJSON() {
      return { ...super.exportJSON(), listType: this.getListType(), start: this.getStart(), tag: this.getTag(), type: "list", version: 1 };
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
    append(...A) {
      for (let ie = 0; ie < A.length; ie++) {
        var z = A[ie];
        if (x(z))
          super.append(z);
        else {
          let q = C();
          F(z) || r.$isElementNode(z) && (z = r.$createTextNode(z.getTextContent())), q.append(z), super.append(q);
        }
      }
      return g(this), this;
    }
    extractWithChild(A) {
      return x(A);
    }
  }
  function W(K, A, z) {
    let ie = [], q = [];
    var Y = A.list;
    if (Y !== void 0) {
      let j = Y[`${z.__tag}Depth`] || [];
      A = o(z) - 1;
      let Q = A % j.length;
      var se = j[Q];
      let ae = Y[z.__tag], de, Ne = Y.nested;
      if (Y = Y.checklist, Ne !== void 0 && Ne.list && (de = Ne.list), ae !== void 0 && ie.push(ae), Y !== void 0 && z.__listType === "check" && ie.push(Y), se !== void 0)
        for (se = se.split(" "), ie.push(...se), se = 0; se < j.length; se++)
          se !== Q && q.push(z.__tag + se);
      de !== void 0 && (z = de.split(" "), 1 < A ? ie.push(...z) : q.push(...z));
    }
    0 < q.length && n.removeClassNamesFromElement(K, ...q), 0 < ie.length && n.addClassNamesToElement(
      K,
      ...ie
    );
  }
  function $(K) {
    let A = [];
    for (let ie = 0; ie < K.length; ie++) {
      var z = K[ie];
      x(z) ? (A.push(z), z = z.getChildren(), 1 < z.length && z.forEach((q) => {
        F(q) && A.push(O(q));
      })) : A.push(O(z));
    }
    return A;
  }
  function B(K) {
    let A = K.nodeName.toLowerCase(), z = null;
    return A === "ol" ? z = P("number", K.start) : A === "ul" && (z = n.isHTMLElement(K) && K.getAttribute("__lexicallisttype") === "check" ? P("check") : P("bullet")), { after: $, node: z };
  }
  let L = { ol: "number", ul: "bullet" };
  function P(K, A = 1) {
    return r.$applyNodeReplacement(new I(K, A));
  }
  function F(K) {
    return K instanceof I;
  }
  let Z = r.createCommand("INSERT_UNORDERED_LIST_COMMAND"), oe = r.createCommand("INSERT_ORDERED_LIST_COMMAND"), ne = r.createCommand("INSERT_CHECK_LIST_COMMAND"), te = r.createCommand("REMOVE_LIST_COMMAND");
  return dr.$createListItemNode = C, dr.$createListNode = P, dr.$getListDepth = o, dr.$handleListInsertParagraph = function() {
    var K = r.$getSelection();
    if (!r.$isRangeSelection(K) || !K.isCollapsed() || (K = K.anchor.getNode(), !x(K) || K.getChildrenSize() !== 0))
      return !1;
    var A = u(K), z = K.getParent();
    F(z) || t(40);
    let ie = z.getParent(), q;
    if (r.$isRootOrShadowRoot(ie))
      q = r.$createParagraphNode(), A.insertAfter(q);
    else if (x(ie))
      q = C(), ie.insertAfter(q);
    else
      return !1;
    if (q.select(), A = K.getNextSiblings(), 0 < A.length) {
      let Y = P(z.getListType());
      r.$isParagraphNode(q) ? q.insertAfter(Y) : (z = C(), z.append(Y), q.insertAfter(z)), A.forEach((se) => {
        se.remove(), Y.append(se);
      });
    }
    return f(K), !0;
  }, dr.$isListItemNode = x, dr.$isListNode = F, dr.INSERT_CHECK_LIST_COMMAND = ne, dr.INSERT_ORDERED_LIST_COMMAND = oe, dr.INSERT_UNORDERED_LIST_COMMAND = Z, dr.ListItemNode = N, dr.ListNode = I, dr.REMOVE_LIST_COMMAND = te, dr.insertList = function(K, A) {
    K.update(() => {
      var z = r.$getSelection();
      if (z !== null) {
        var ie = z.getNodes();
        z = z.getStartEndPoints(), z === null && t(143), [z] = z, z = z.getNode();
        var q = z.getParent();
        if (S(z, ie))
          ie = P(A), r.$isRootOrShadowRoot(q) ? (z.replace(ie), q = C(), r.$isElementNode(z) && (q.setFormat(z.getFormatType()), q.setIndent(z.getIndent())), ie.append(q)) : x(z) && (z = z.getParentOrThrow(), E(ie, z.getChildren()), z.replace(ie));
        else
          for (z = /* @__PURE__ */ new Set(), q = 0; q < ie.length; q++) {
            var Y = ie[q];
            if (r.$isElementNode(Y) && Y.isEmpty() && !x(Y) && !z.has(Y.getKey()))
              R(
                Y,
                A
              );
            else if (r.$isLeafNode(Y))
              for (Y = Y.getParent(); Y != null; ) {
                let j = Y.getKey();
                if (F(Y)) {
                  if (!z.has(j)) {
                    var se = P(A);
                    E(se, Y.getChildren()), Y.replace(se), g(se), z.add(j);
                  }
                  break;
                } else {
                  if (se = Y.getParent(), r.$isRootOrShadowRoot(se) && !z.has(j)) {
                    z.add(j), R(Y, A);
                    break;
                  }
                  Y = se;
                }
              }
          }
      }
    });
  }, dr.removeList = function(K) {
    K.update(() => {
      let A = r.$getSelection();
      if (r.$isRangeSelection(A)) {
        var z = /* @__PURE__ */ new Set(), ie = A.getNodes(), q = A.anchor.getNode();
        if (S(q, ie))
          z.add(u(q));
        else
          for (q = 0; q < ie.length; q++) {
            var Y = ie[q];
            r.$isLeafNode(Y) && (Y = n.$getNearestNodeOfType(Y, N), Y != null && z.add(u(Y)));
          }
        for (let se of z) {
          z = se, ie = p(se);
          for (let j of ie)
            ie = r.$createParagraphNode(), E(ie, j.getChildren()), z.insertAfter(ie), z = ie, j.__key === A.anchor.key && A.anchor.set(ie.getKey(), 0, "element"), j.__key === A.focus.key && A.focus.set(ie.getKey(), 0, "element"), j.remove();
          se.remove();
        }
      }
    });
  }, dr;
}
const Wp = process.env.NODE_ENV === "development" ? jp() : Hp();
var Vn = Wp, ai = {}, Hd;
function Up() {
  if (Hd)
    return ai;
  Hd = 1;
  var r = St(), n = kt();
  class t extends r.ElementNode {
    /** @internal */
    static getType() {
      return "mark";
    }
    static clone(S) {
      return new t(Array.from(S.__ids), S.__key);
    }
    static importDOM() {
      return null;
    }
    static importJSON(S) {
      const E = o(S.ids);
      return E.setFormat(S.format), E.setIndent(S.indent), E.setDirection(S.direction), E;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        ids: this.getIDs(),
        type: "mark",
        version: 1
      };
    }
    constructor(S, E) {
      super(E), this.__ids = S || [];
    }
    createDOM(S) {
      const E = document.createElement("mark");
      return n.addClassNamesToElement(E, S.theme.mark), this.__ids.length > 1 && n.addClassNamesToElement(E, S.theme.markOverlap), E;
    }
    updateDOM(S, E, R) {
      const y = S.__ids, g = this.__ids, _ = y.length, N = g.length, w = R.theme.markOverlap;
      return _ !== N && (_ === 1 ? N === 2 && n.addClassNamesToElement(E, w) : N === 1 && n.removeClassNamesFromElement(E, w)), !1;
    }
    hasID(S) {
      const E = this.getIDs();
      for (let R = 0; R < E.length; R++)
        if (S === E[R])
          return !0;
      return !1;
    }
    getIDs() {
      const S = this.getLatest();
      return u(S) ? S.__ids : [];
    }
    addID(S) {
      const E = this.getWritable();
      if (u(E)) {
        const R = E.__ids;
        E.__ids = R;
        for (let y = 0; y < R.length; y++)
          if (S === R[y])
            return;
        R.push(S);
      }
    }
    deleteID(S) {
      const E = this.getWritable();
      if (u(E)) {
        const R = E.__ids;
        E.__ids = R;
        for (let y = 0; y < R.length; y++)
          if (S === R[y]) {
            R.splice(y, 1);
            return;
          }
      }
    }
    insertNewAfter(S, E = !0) {
      const R = o(this.__ids);
      return this.insertAfter(R, E), R;
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isInline() {
      return !0;
    }
    extractWithChild(S, E, R) {
      if (!r.$isRangeSelection(E) || R === "html")
        return !1;
      const y = E.anchor, g = E.focus, _ = y.getNode(), N = g.getNode(), T = E.isBackward() ? y.offset - g.offset : g.offset - y.offset;
      return this.isParentOf(_) && this.isParentOf(N) && this.getTextContent().length === T;
    }
    excludeFromCopy(S) {
      return S !== "clone";
    }
  }
  function o(O) {
    return r.$applyNodeReplacement(new t(O));
  }
  function u(O) {
    return O instanceof t;
  }
  function p(O) {
    const S = O.getChildren();
    let E = null;
    for (let R = 0; R < S.length; R++) {
      const y = S[R];
      E === null ? O.insertBefore(y) : E.insertAfter(y), E = y;
    }
    O.remove();
  }
  function m(O, S, E, R) {
    const y = O.getNodes(), g = O.anchor.offset, _ = O.focus.offset, N = y.length, w = S ? _ : g, T = S ? g : _;
    let D, C;
    for (let x = 0; x < N; x++) {
      const I = y[x];
      if (r.$isElementNode(C) && C.isParentOf(I))
        continue;
      const W = x === 0, $ = x === N - 1;
      let B = null;
      if (r.$isTextNode(I)) {
        const L = I.getTextContentSize(), P = W ? w : 0, F = $ ? T : L;
        if (P === 0 && F === 0)
          continue;
        const Z = I.splitText(P, F);
        B = Z.length > 1 && (Z.length === 3 || W && !$ || F === L) ? Z[1] : Z[0];
      } else {
        if (u(I))
          continue;
        r.$isElementNode(I) && I.isInline() && (B = I);
      }
      if (B !== null) {
        if (B && B.is(D))
          continue;
        const L = B.getParent();
        (L == null || !L.is(D)) && (C = void 0), D = L, C === void 0 && (C = (R || o)([E]), B.insertBefore(C)), C.append(B);
      } else
        D = void 0, C = void 0;
    }
    r.$isElementNode(C) && (S ? C.selectStart() : C.selectEnd());
  }
  function f(O, S) {
    let E = O;
    for (; E !== null; ) {
      if (u(E))
        return E.getIDs();
      if (r.$isTextNode(E) && S === E.getTextContentSize()) {
        const R = E.getNextSibling();
        if (u(R))
          return R.getIDs();
      }
      E = E.getParent();
    }
    return null;
  }
  return ai.$createMarkNode = o, ai.$getMarkIDs = f, ai.$isMarkNode = u, ai.$unwrapMarkNode = p, ai.$wrapSelectionInMarkNode = m, ai.MarkNode = t, ai;
}
var ci = {}, Wd;
function Yp() {
  if (Wd)
    return ci;
  Wd = 1;
  var r = St(), n = kt();
  class t extends r.ElementNode {
    static getType() {
      return "mark";
    }
    static clone(m) {
      return new t(Array.from(m.__ids), m.__key);
    }
    static importDOM() {
      return null;
    }
    static importJSON(m) {
      let f = o(m.ids);
      return f.setFormat(m.format), f.setIndent(m.indent), f.setDirection(m.direction), f;
    }
    exportJSON() {
      return { ...super.exportJSON(), ids: this.getIDs(), type: "mark", version: 1 };
    }
    constructor(m, f) {
      super(f), this.__ids = m || [];
    }
    createDOM(m) {
      let f = document.createElement("mark");
      return n.addClassNamesToElement(f, m.theme.mark), 1 < this.__ids.length && n.addClassNamesToElement(f, m.theme.markOverlap), f;
    }
    updateDOM(m, f, O) {
      m = m.__ids.length;
      let S = this.__ids.length;
      return O = O.theme.markOverlap, m !== S && (m === 1 ? S === 2 && n.addClassNamesToElement(f, O) : S === 1 && n.removeClassNamesFromElement(f, O)), !1;
    }
    hasID(m) {
      let f = this.getIDs();
      for (let O = 0; O < f.length; O++)
        if (m === f[O])
          return !0;
      return !1;
    }
    getIDs() {
      let m = this.getLatest();
      return u(m) ? m.__ids : [];
    }
    addID(m) {
      var f = this.getWritable();
      if (u(f)) {
        let O = f.__ids;
        for (f.__ids = O, f = 0; f < O.length; f++)
          if (m === O[f])
            return;
        O.push(m);
      }
    }
    deleteID(m) {
      var f = this.getWritable();
      if (u(f)) {
        let O = f.__ids;
        for (f.__ids = O, f = 0; f < O.length; f++)
          if (m === O[f]) {
            O.splice(f, 1);
            break;
          }
      }
    }
    insertNewAfter(m, f = !0) {
      return m = o(this.__ids), this.insertAfter(m, f), m;
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isInline() {
      return !0;
    }
    extractWithChild(m, f, O) {
      if (!r.$isRangeSelection(f) || O === "html")
        return !1;
      let S = f.anchor, E = f.focus;
      return m = S.getNode(), O = E.getNode(), f = f.isBackward() ? S.offset - E.offset : E.offset - S.offset, this.isParentOf(m) && this.isParentOf(O) && this.getTextContent().length === f;
    }
    excludeFromCopy(m) {
      return m !== "clone";
    }
  }
  function o(p) {
    return r.$applyNodeReplacement(new t(p));
  }
  function u(p) {
    return p instanceof t;
  }
  return ci.$createMarkNode = o, ci.$getMarkIDs = function(p, m) {
    for (; p !== null; ) {
      if (u(p))
        return p.getIDs();
      if (r.$isTextNode(p) && m === p.getTextContentSize()) {
        let f = p.getNextSibling();
        if (u(f))
          return f.getIDs();
      }
      p = p.getParent();
    }
    return null;
  }, ci.$isMarkNode = u, ci.$unwrapMarkNode = function(p) {
    let m = p.getChildren(), f = null;
    for (let O = 0; O < m.length; O++) {
      let S = m[O];
      f === null ? p.insertBefore(S) : f.insertAfter(S), f = S;
    }
    p.remove();
  }, ci.$wrapSelectionInMarkNode = function(p, m, f, O) {
    let S = p.getNodes();
    var E = p.anchor.offset, R = p.focus.offset;
    p = S.length;
    let y = m ? R : E;
    E = m ? E : R;
    let g, _;
    for (R = 0; R < p; R++) {
      var N = S[R];
      if (r.$isElementNode(_) && _.isParentOf(N))
        continue;
      var w = R === 0;
      let D = R === p - 1;
      var T = null;
      if (r.$isTextNode(N)) {
        T = N.getTextContentSize();
        let C = w ? y : 0, x = D ? E : T;
        if (C === 0 && x === 0)
          continue;
        N = N.splitText(C, x), T = 1 < N.length && (N.length === 3 || w && !D || x === T) ? N[1] : N[0];
      } else {
        if (u(N))
          continue;
        r.$isElementNode(N) && N.isInline() && (T = N);
      }
      T !== null ? T && T.is(g) || (w = T.getParent(), w != null && w.is(g) || (_ = void 0), g = w, _ === void 0 && (_ = (O || o)([f]), T.insertBefore(_)), _.append(T)) : _ = g = void 0;
    }
    r.$isElementNode(_) && (m ? _.selectStart() : _.selectEnd());
  }, ci.MarkNode = t, ci;
}
const zp = process.env.NODE_ENV === "development" ? Up() : Yp();
var qp = zp, dl = {}, Ud;
function Gp() {
  if (Ud)
    return dl;
  Ud = 1;
  var r = St();
  class n extends r.ElementNode {
    static getType() {
      return "overflow";
    }
    static clone(p) {
      return new n(p.__key);
    }
    static importJSON(p) {
      return t();
    }
    static importDOM() {
      return null;
    }
    constructor(p) {
      super(p), this.__type = "overflow";
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "overflow"
      };
    }
    createDOM(p) {
      const m = document.createElement("span"), f = p.theme.characterLimit;
      return typeof f == "string" && (m.className = f), m;
    }
    updateDOM(p, m) {
      return !1;
    }
    insertNewAfter(p, m = !0) {
      return this.getParentOrThrow().insertNewAfter(p, m);
    }
    excludeFromCopy() {
      return !0;
    }
  }
  function t() {
    return r.$applyNodeReplacement(new n());
  }
  function o(u) {
    return u instanceof n;
  }
  return dl.$createOverflowNode = t, dl.$isOverflowNode = o, dl.OverflowNode = n, dl;
}
var fl = {}, Yd;
function Vp() {
  if (Yd)
    return fl;
  Yd = 1;
  var r = St();
  class n extends r.ElementNode {
    static getType() {
      return "overflow";
    }
    static clone(u) {
      return new n(u.__key);
    }
    static importJSON() {
      return t();
    }
    static importDOM() {
      return null;
    }
    constructor(u) {
      super(u), this.__type = "overflow";
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "overflow" };
    }
    createDOM(u) {
      let p = document.createElement("span");
      return u = u.theme.characterLimit, typeof u == "string" && (p.className = u), p;
    }
    updateDOM() {
      return !1;
    }
    insertNewAfter(u, p = !0) {
      return this.getParentOrThrow().insertNewAfter(u, p);
    }
    excludeFromCopy() {
      return !0;
    }
  }
  function t() {
    return r.$applyNodeReplacement(new n());
  }
  return fl.$createOverflowNode = t, fl.$isOverflowNode = function(o) {
    return o instanceof n;
  }, fl.OverflowNode = n, fl;
}
const Jp = process.env.NODE_ENV === "development" ? Gp() : Vp();
var Xp = Jp, Cs = {}, oc = {}, zd;
function Zp() {
  if (zd)
    return oc;
  zd = 1;
  var r = zt(), n = St(), t = $t;
  function o(p, m) {
    return p.getEditorState().read(() => {
      const f = n.$getNodeByKey(m);
      return f === null ? !1 : f.isSelected();
    });
  }
  function u(p) {
    const [m] = r.useLexicalComposerContext(), [f, O] = t.useState(() => o(m, p));
    t.useEffect(() => {
      let R = !0;
      const y = m.registerUpdateListener(() => {
        R && O(o(m, p));
      });
      return () => {
        R = !1, y();
      };
    }, [m, p]);
    const S = t.useCallback((R) => {
      m.update(() => {
        let y = n.$getSelection();
        n.$isNodeSelection(y) || (y = n.$createNodeSelection(), n.$setSelection(y)), n.$isNodeSelection(y) && (R ? y.add(p) : y.delete(p));
      });
    }, [m, p]), E = t.useCallback(() => {
      m.update(() => {
        const R = n.$getSelection();
        n.$isNodeSelection(R) && R.clear();
      });
    }, [m]);
    return [f, S, E];
  }
  return oc.useLexicalNodeSelection = u, oc;
}
var ic = {}, qd;
function Qp() {
  if (qd)
    return ic;
  qd = 1;
  var r = zt(), n = St(), t = $t;
  function o(u, p) {
    return u.getEditorState().read(() => {
      let m = n.$getNodeByKey(p);
      return m === null ? !1 : m.isSelected();
    });
  }
  return ic.useLexicalNodeSelection = function(u) {
    let [p] = r.useLexicalComposerContext(), [m, f] = t.useState(() => o(p, u));
    t.useEffect(() => {
      let E = !0, R = p.registerUpdateListener(() => {
        E && f(o(p, u));
      });
      return () => {
        E = !1, R();
      };
    }, [p, u]);
    let O = t.useCallback((E) => {
      p.update(() => {
        let R = n.$getSelection();
        n.$isNodeSelection(R) || (R = n.$createNodeSelection(), n.$setSelection(R)), n.$isNodeSelection(R) && (E ? R.add(u) : R.delete(u));
      });
    }, [p, u]), S = t.useCallback(
      () => {
        p.update(() => {
          const E = n.$getSelection();
          n.$isNodeSelection(E) && E.clear();
        });
      },
      [p]
    );
    return [m, O, S];
  }, ic;
}
var sc, Gd;
function Nl() {
  return Gd || (Gd = 1, sc = process.env.NODE_ENV === "development" ? Zp() : Qp()), sc;
}
var Vd;
function em() {
  if (Vd)
    return Cs;
  Vd = 1;
  var r = zt(), n = Nl(), t = kt(), o = St(), u = $t;
  const p = o.createCommand("INSERT_HORIZONTAL_RULE_COMMAND");
  function m({
    nodeKey: R
  }) {
    const [y] = r.useLexicalComposerContext(), [g, _, N] = n.useLexicalNodeSelection(R), w = u.useCallback((T) => {
      if (g && o.$isNodeSelection(o.$getSelection())) {
        T.preventDefault();
        const D = o.$getNodeByKey(R);
        E(D) && D.remove();
      }
      return !1;
    }, [g, R]);
    return u.useEffect(() => t.mergeRegister(y.registerCommand(o.CLICK_COMMAND, (T) => {
      const D = y.getElementByKey(R);
      return T.target === D ? (T.shiftKey || N(), _(!g), !0) : !1;
    }, o.COMMAND_PRIORITY_LOW), y.registerCommand(o.KEY_DELETE_COMMAND, w, o.COMMAND_PRIORITY_LOW), y.registerCommand(o.KEY_BACKSPACE_COMMAND, w, o.COMMAND_PRIORITY_LOW)), [N, y, g, R, w, _]), u.useEffect(() => {
      const T = y.getElementByKey(R);
      T !== null && (T.className = g ? "selected" : "");
    }, [y, g, R]), null;
  }
  class f extends o.DecoratorNode {
    static getType() {
      return "horizontalrule";
    }
    static clone(y) {
      return new f(y.__key);
    }
    static importJSON(y) {
      return S();
    }
    static importDOM() {
      return {
        hr: () => ({
          conversion: O,
          priority: 0
        })
      };
    }
    exportJSON() {
      return {
        type: "horizontalrule",
        version: 1
      };
    }
    exportDOM() {
      return {
        element: document.createElement("hr")
      };
    }
    createDOM() {
      return document.createElement("hr");
    }
    getTextContent() {
      return `
`;
    }
    isInline() {
      return !1;
    }
    updateDOM() {
      return !1;
    }
    decorate() {
      return /* @__PURE__ */ u.createElement(m, {
        nodeKey: this.__key
      });
    }
  }
  function O() {
    return {
      node: S()
    };
  }
  function S() {
    return o.$applyNodeReplacement(new f());
  }
  function E(R) {
    return R instanceof f;
  }
  return Cs.$createHorizontalRuleNode = S, Cs.$isHorizontalRuleNode = E, Cs.HorizontalRuleNode = f, Cs.INSERT_HORIZONTAL_RULE_COMMAND = p, Cs;
}
var xs = {}, Jd;
function tm() {
  if (Jd)
    return xs;
  Jd = 1;
  var r = zt(), n = Nl(), t = kt(), o = St(), u = $t;
  let p = o.createCommand("INSERT_HORIZONTAL_RULE_COMMAND");
  function m({ nodeKey: R }) {
    let [y] = r.useLexicalComposerContext(), [g, _, N] = n.useLexicalNodeSelection(R), w = u.useCallback((T) => (g && o.$isNodeSelection(o.$getSelection()) && (T.preventDefault(), T = o.$getNodeByKey(R), E(T) && T.remove()), !1), [g, R]);
    return u.useEffect(() => t.mergeRegister(y.registerCommand(o.CLICK_COMMAND, (T) => {
      let D = y.getElementByKey(R);
      return T.target === D ? (T.shiftKey || N(), _(!g), !0) : !1;
    }, o.COMMAND_PRIORITY_LOW), y.registerCommand(o.KEY_DELETE_COMMAND, w, o.COMMAND_PRIORITY_LOW), y.registerCommand(
      o.KEY_BACKSPACE_COMMAND,
      w,
      o.COMMAND_PRIORITY_LOW
    )), [N, y, g, R, w, _]), u.useEffect(() => {
      let T = y.getElementByKey(R);
      T !== null && (T.className = g ? "selected" : "");
    }, [y, g, R]), null;
  }
  class f extends o.DecoratorNode {
    static getType() {
      return "horizontalrule";
    }
    static clone(y) {
      return new f(y.__key);
    }
    static importJSON() {
      return S();
    }
    static importDOM() {
      return { hr: () => ({ conversion: O, priority: 0 }) };
    }
    exportJSON() {
      return { type: "horizontalrule", version: 1 };
    }
    exportDOM() {
      return { element: document.createElement("hr") };
    }
    createDOM() {
      return document.createElement("hr");
    }
    getTextContent() {
      return `
`;
    }
    isInline() {
      return !1;
    }
    updateDOM() {
      return !1;
    }
    decorate() {
      return u.createElement(m, { nodeKey: this.__key });
    }
  }
  function O() {
    return { node: S() };
  }
  function S() {
    return o.$applyNodeReplacement(new f());
  }
  function E(R) {
    return R instanceof f;
  }
  return xs.$createHorizontalRuleNode = S, xs.$isHorizontalRuleNode = E, xs.HorizontalRuleNode = f, xs.INSERT_HORIZONTAL_RULE_COMMAND = p, xs;
}
const nm = process.env.NODE_ENV === "development" ? em() : tm();
var Cl = nm, Jr = {}, go = {}, ca = {}, Xd;
function rm() {
  if (Xd)
    return ca;
  Xd = 1;
  var r = Ko(), n = kt(), t = St();
  function o(S, E) {
    const R = E.body ? E.body.childNodes : [];
    let y = [];
    for (let g = 0; g < R.length; g++) {
      const _ = R[g];
      if (!f.has(_.nodeName)) {
        const N = O(_, S);
        N !== null && (y = y.concat(N));
      }
    }
    return y;
  }
  function u(S, E) {
    if (typeof document > "u" || typeof window > "u" && typeof Oa.window > "u")
      throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
    const R = document.createElement("div"), g = t.$getRoot().getChildren();
    for (let _ = 0; _ < g.length; _++) {
      const N = g[_];
      p(S, N, R, E);
    }
    return R.innerHTML;
  }
  function p(S, E, R, y = null) {
    let g = y !== null ? E.isSelected(y) : !0;
    const _ = t.$isElementNode(E) && E.excludeFromCopy("html");
    let N = E;
    if (y !== null) {
      let W = r.$cloneWithProperties(E);
      W = t.$isTextNode(W) && y !== null ? r.$sliceSelectedTextNodeContent(y, W) : W, N = W;
    }
    const w = t.$isElementNode(N) ? N.getChildren() : [], T = S._nodes.get(N.getType());
    let D;
    T && T.exportDOM !== void 0 ? D = T.exportDOM(S, N) : D = N.exportDOM(S);
    const {
      element: C,
      after: x
    } = D;
    if (!C)
      return !1;
    const I = document.createDocumentFragment();
    for (let W = 0; W < w.length; W++) {
      const $ = w[W], B = p(S, $, I, y);
      !g && t.$isElementNode(E) && B && E.extractWithChild($, y, "html") && (g = !0);
    }
    if (g && !_) {
      if (n.isHTMLElement(C) && C.append(I), R.append(C), x) {
        const W = x.call(N, C);
        W && C.replaceWith(W);
      }
    } else
      R.append(I);
    return g;
  }
  function m(S, E) {
    const {
      nodeName: R
    } = S, y = E._htmlConversions.get(R.toLowerCase());
    let g = null;
    if (y !== void 0)
      for (const _ of y) {
        const N = _(S);
        N !== null && (g === null || (g.priority || 0) < (N.priority || 0)) && (g = N);
      }
    return g !== null ? g.conversion : null;
  }
  const f = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
  function O(S, E, R = /* @__PURE__ */ new Map(), y) {
    let g = [];
    if (f.has(S.nodeName))
      return g;
    let _ = null;
    const N = m(S, E), w = N ? N(S) : null;
    let T = null;
    if (w !== null) {
      T = w.after;
      const x = w.node;
      if (_ = Array.isArray(x) ? x[x.length - 1] : x, _ !== null) {
        for (const [, I] of R)
          if (_ = I(_, y), !_)
            break;
        _ && g.push(...Array.isArray(x) ? x : [_]);
      }
      w.forChild != null && R.set(S.nodeName, w.forChild);
    }
    const D = S.childNodes;
    let C = [];
    for (let x = 0; x < D.length; x++)
      C.push(...O(D[x], E, new Map(R), _));
    return T != null && (C = T(C)), _ == null ? g = g.concat(C) : t.$isElementNode(_) && _.append(...C), g;
  }
  return ca.$generateHtmlFromNodes = u, ca.$generateNodesFromDOM = o, ca;
}
var ua = {}, Zd;
function om() {
  if (Zd)
    return ua;
  Zd = 1;
  var r = Ko(), n = kt(), t = St();
  function o(m, f, O, S = null) {
    let E = S !== null ? f.isSelected(S) : !0, R = t.$isElementNode(f) && f.excludeFromCopy("html");
    var y = f;
    S !== null && (y = r.$cloneWithProperties(f), y = t.$isTextNode(y) && S !== null ? r.$sliceSelectedTextNodeContent(S, y) : y);
    let g = t.$isElementNode(y) ? y.getChildren() : [];
    var _ = m._nodes.get(y.getType());
    _ = _ && _.exportDOM !== void 0 ? _.exportDOM(m, y) : y.exportDOM(m);
    let { element: N, after: w } = _;
    if (!N)
      return !1;
    _ = document.createDocumentFragment();
    for (let T = 0; T < g.length; T++) {
      let D = g[T], C = o(m, D, _, S);
      !E && t.$isElementNode(f) && C && f.extractWithChild(D, S, "html") && (E = !0);
    }
    return E && !R ? (n.isHTMLElement(N) && N.append(_), O.append(N), w && (m = w.call(y, N)) && N.replaceWith(m)) : O.append(_), E;
  }
  let u = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
  function p(m, f, O = /* @__PURE__ */ new Map(), S) {
    let E = [];
    if (u.has(m.nodeName))
      return E;
    let R = null;
    var y, { nodeName: g } = m, _ = f._htmlConversions.get(g.toLowerCase());
    if (g = null, _ !== void 0)
      for (y of _)
        _ = y(m), _ !== null && (g === null || (g.priority || 0) < (_.priority || 0)) && (g = _);
    if (g = (y = g !== null ? g.conversion : null) ? y(m) : null, y = null, g !== null) {
      if (y = g.after, _ = g.node, R = Array.isArray(_) ? _[_.length - 1] : _, R !== null) {
        for (var [, N] of O)
          if (R = N(R, S), !R)
            break;
        R && E.push(...Array.isArray(_) ? _ : [R]);
      }
      g.forChild != null && O.set(m.nodeName, g.forChild);
    }
    for (m = m.childNodes, S = [], N = 0; N < m.length; N++)
      S.push(...p(m[N], f, new Map(O), R));
    return y != null && (S = y(S)), R == null ? E = E.concat(S) : t.$isElementNode(R) && R.append(...S), E;
  }
  return ua.$generateHtmlFromNodes = function(m, f) {
    if (typeof document > "u" || typeof window > "u" && typeof Oa.window > "u")
      throw Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
    let O = document.createElement("div"), S = t.$getRoot().getChildren();
    for (let E = 0; E < S.length; E++)
      o(m, S[E], O, f);
    return O.innerHTML;
  }, ua.$generateNodesFromDOM = function(m, f) {
    f = f.body ? f.body.childNodes : [];
    let O = [];
    for (let E = 0; E < f.length; E++) {
      var S = f[E];
      u.has(S.nodeName) || (S = p(S, m), S !== null && (O = O.concat(S)));
    }
    return O;
  }, ua;
}
var lc, Qd;
function Gg() {
  return Qd || (Qd = 1, lc = process.env.NODE_ENV === "development" ? rm() : om()), lc;
}
var ef;
function im() {
  if (ef)
    return go;
  ef = 1;
  var r = Gg(), n = Ko(), t = kt(), o = St();
  const u = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", p = (C) => u ? (C || window).getSelection() : null;
  function m(C) {
    const x = o.$getSelection();
    if (x == null)
      throw Error("Expected valid LexicalSelection");
    return o.$isRangeSelection(x) && x.isCollapsed() || x.getNodes().length === 0 ? "" : r.$generateHtmlFromNodes(C, x);
  }
  function f(C) {
    const x = o.$getSelection();
    if (x == null)
      throw Error("Expected valid LexicalSelection");
    return o.$isRangeSelection(x) && x.isCollapsed() || x.getNodes().length === 0 ? null : JSON.stringify(g(C, x));
  }
  function O(C, x) {
    const I = C.getData("text/plain") || C.getData("text/uri-list");
    I != null && x.insertRawText(I);
  }
  function S(C, x, I) {
    const W = C.getData("application/x-lexical-editor");
    if (W)
      try {
        const L = JSON.parse(W);
        if (L.namespace === I._config.namespace && Array.isArray(L.nodes)) {
          const P = _(L.nodes);
          return E(I, P, x);
        }
      } catch {
      }
    const $ = C.getData("text/html");
    if ($)
      try {
        const P = new DOMParser().parseFromString($, "text/html"), F = r.$generateNodesFromDOM(I, P);
        return E(I, F, x);
      } catch {
      }
    const B = C.getData("text/plain") || C.getData("text/uri-list");
    if (B != null)
      if (o.$isRangeSelection(x)) {
        const L = B.split(/(\r?\n|\t)/);
        L[L.length - 1] === "" && L.pop();
        for (let P = 0; P < L.length; P++) {
          const F = L[P];
          F === `
` || F === `\r
` ? x.insertParagraph() : F === "	" ? x.insertNodes([o.$createTabNode()]) : x.insertText(F);
        }
      } else
        x.insertRawText(B);
  }
  function E(C, x, I) {
    C.dispatchCommand(o.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {
      nodes: x,
      selection: I
    }) || I.insertNodes(x);
  }
  function R(C) {
    const x = C.exportJSON(), I = C.constructor;
    if (x.type !== I.getType())
      throw Error(`LexicalNode: Node ${I.name} does not implement .exportJSON().`);
    if (o.$isElementNode(C)) {
      const W = x.children;
      if (!Array.isArray(W))
        throw Error(`LexicalNode: Node ${I.name} is an element but .exportJSON() does not have a children array.`);
    }
    return x;
  }
  function y(C, x, I, W = []) {
    let $ = x !== null ? I.isSelected(x) : !0;
    const B = o.$isElementNode(I) && I.excludeFromCopy("html");
    let L = I;
    if (x !== null) {
      let Z = n.$cloneWithProperties(I);
      Z = o.$isTextNode(Z) && x !== null ? n.$sliceSelectedTextNodeContent(x, Z) : Z, L = Z;
    }
    const P = o.$isElementNode(L) ? L.getChildren() : [], F = R(L);
    if (o.$isTextNode(L)) {
      const Z = L.__text;
      Z.length > 0 ? F.text = Z : $ = !1;
    }
    for (let Z = 0; Z < P.length; Z++) {
      const oe = P[Z], ne = y(C, x, oe, F.children);
      !$ && o.$isElementNode(I) && ne && I.extractWithChild(oe, x, "clone") && ($ = !0);
    }
    if ($ && !B)
      W.push(F);
    else if (Array.isArray(F.children))
      for (let Z = 0; Z < F.children.length; Z++) {
        const oe = F.children[Z];
        W.push(oe);
      }
    return $;
  }
  function g(C, x) {
    const I = [], $ = o.$getRoot().getChildren();
    for (let B = 0; B < $.length; B++) {
      const L = $[B];
      y(C, x, L, I);
    }
    return {
      namespace: C._config.namespace,
      nodes: I
    };
  }
  function _(C) {
    const x = [];
    for (let I = 0; I < C.length; I++) {
      const W = C[I], $ = o.$parseSerializedNode(W);
      o.$isTextNode($) && n.$addNodeStyle($), x.push($);
    }
    return x;
  }
  const N = 50;
  let w = null;
  async function T(C, x) {
    if (w !== null)
      return !1;
    if (x !== null)
      return new Promise((P, F) => {
        C.update(() => {
          P(D(C, x));
        });
      });
    const I = C.getRootElement(), W = C._window == null ? window.document : C._window.document, $ = p(C._window);
    if (I === null || $ === null)
      return !1;
    const B = W.createElement("span");
    B.style.cssText = "position: fixed; top: -1000px;", B.append(W.createTextNode("#")), I.append(B);
    const L = new Range();
    return L.setStart(B, 0), L.setEnd(B, 1), $.removeAllRanges(), $.addRange(L), new Promise((P, F) => {
      const Z = C.registerCommand(o.COPY_COMMAND, (oe) => (t.objectKlassEquals(oe, ClipboardEvent) && (Z(), w !== null && (window.clearTimeout(w), w = null), P(D(C, oe))), !0), o.COMMAND_PRIORITY_CRITICAL);
      w = window.setTimeout(() => {
        Z(), w = null, P(!1);
      }, N), W.execCommand("copy"), B.remove();
    });
  }
  function D(C, x) {
    const I = p(C._window);
    if (!I)
      return !1;
    const W = I.anchorNode, $ = I.focusNode;
    if (W !== null && $ !== null && !o.isSelectionWithinEditor(C, W, $))
      return !1;
    x.preventDefault();
    const B = x.clipboardData, L = o.$getSelection();
    if (B === null || L === null)
      return !1;
    const P = m(C), F = f(C);
    let Z = "";
    return L !== null && (Z = L.getTextContent()), P !== null && B.setData("text/html", P), F !== null && B.setData("application/x-lexical-editor", F), B.setData("text/plain", Z), !0;
  }
  return go.$generateJSONFromSelectedNodes = g, go.$generateNodesFromSerializedNodes = _, go.$getHtmlContent = m, go.$getLexicalContent = f, go.$insertDataTransferForPlainText = O, go.$insertDataTransferForRichText = S, go.$insertGeneratedNodes = E, go.copyToClipboard = T, go;
}
var ho = {}, tf;
function sm() {
  if (tf)
    return ho;
  tf = 1;
  var r = Gg(), n = Ko(), t = kt(), o = St();
  function u(_) {
    let N = new URLSearchParams();
    N.append("code", _);
    for (let w = 1; w < arguments.length; w++)
      N.append("v", arguments[w]);
    throw Error(`Minified Lexical error #${_}; visit https://lexical.dev/docs/error?${N} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  let p = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  function m(_) {
    let N = o.$getSelection();
    if (N == null)
      throw Error("Expected valid LexicalSelection");
    return o.$isRangeSelection(N) && N.isCollapsed() || N.getNodes().length === 0 ? "" : r.$generateHtmlFromNodes(_, N);
  }
  function f(_) {
    let N = o.$getSelection();
    if (N == null)
      throw Error("Expected valid LexicalSelection");
    return o.$isRangeSelection(N) && N.isCollapsed() || N.getNodes().length === 0 ? null : JSON.stringify(E(_, N));
  }
  function O(_, N, w) {
    _.dispatchCommand(o.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, { nodes: N, selection: w }) || w.insertNodes(N);
  }
  function S(_, N, w, T = []) {
    let D = N !== null ? w.isSelected(N) : !0, C = o.$isElementNode(w) && w.excludeFromCopy("html");
    var x = w;
    if (N !== null) {
      var I = n.$cloneWithProperties(w);
      x = I = o.$isTextNode(I) && N !== null ? n.$sliceSelectedTextNodeContent(N, I) : I;
    }
    let W = o.$isElementNode(x) ? x.getChildren() : [];
    var $ = x;
    I = $.exportJSON();
    var B = $.constructor;
    for (I.type !== B.getType() && u(58, B.name), o.$isElementNode($) && (Array.isArray(I.children) || u(59, B.name)), o.$isTextNode(x) && (x = x.__text, 0 < x.length ? I.text = x : D = !1), x = 0; x < W.length; x++)
      $ = W[x], B = S(_, N, $, I.children), !D && o.$isElementNode(w) && B && w.extractWithChild($, N, "clone") && (D = !0);
    if (D && !C)
      T.push(I);
    else if (Array.isArray(I.children))
      for (_ = 0; _ < I.children.length; _++)
        T.push(I.children[_]);
    return D;
  }
  function E(_, N) {
    let w = [], T = o.$getRoot().getChildren();
    for (let D = 0; D < T.length; D++)
      S(_, N, T[D], w);
    return { namespace: _._config.namespace, nodes: w };
  }
  function R(_) {
    let N = [];
    for (let w = 0; w < _.length; w++) {
      let T = o.$parseSerializedNode(_[w]);
      o.$isTextNode(T) && n.$addNodeStyle(T), N.push(T);
    }
    return N;
  }
  let y = null;
  function g(_, N) {
    var w = p ? (_._window || window).getSelection() : null;
    if (!w)
      return !1;
    var T = w.anchorNode;
    if (w = w.focusNode, T !== null && w !== null && !o.isSelectionWithinEditor(_, T, w) || (N.preventDefault(), N = N.clipboardData, T = o.$getSelection(), N === null || T === null))
      return !1;
    w = m(_), _ = f(_);
    let D = "";
    return T !== null && (D = T.getTextContent()), w !== null && N.setData("text/html", w), _ !== null && N.setData("application/x-lexical-editor", _), N.setData("text/plain", D), !0;
  }
  return ho.$generateJSONFromSelectedNodes = E, ho.$generateNodesFromSerializedNodes = R, ho.$getHtmlContent = m, ho.$getLexicalContent = f, ho.$insertDataTransferForPlainText = function(_, N) {
    _ = _.getData("text/plain") || _.getData("text/uri-list"), _ != null && N.insertRawText(_);
  }, ho.$insertDataTransferForRichText = function(_, N, w) {
    var T = _.getData("application/x-lexical-editor");
    if (T)
      try {
        let C = JSON.parse(T);
        if (C.namespace === w._config.namespace && Array.isArray(C.nodes)) {
          let x = R(C.nodes);
          return O(w, x, N);
        }
      } catch {
      }
    if (T = _.getData("text/html"))
      try {
        var D = new DOMParser().parseFromString(T, "text/html");
        let C = r.$generateNodesFromDOM(w, D);
        return O(w, C, N);
      } catch {
      }
    if (_ = _.getData("text/plain") || _.getData("text/uri-list"), _ != null)
      if (o.$isRangeSelection(N))
        for (_ = _.split(/(\r?\n|\t)/), _[_.length - 1] === "" && _.pop(), w = 0; w < _.length; w++)
          D = _[w], D === `
` || D === `\r
` ? N.insertParagraph() : D === "	" ? N.insertNodes([o.$createTabNode()]) : N.insertText(D);
      else
        N.insertRawText(_);
  }, ho.$insertGeneratedNodes = O, ho.copyToClipboard = async function(_, N) {
    if (y !== null)
      return !1;
    if (N !== null)
      return new Promise((x) => {
        _.update(() => {
          x(g(_, N));
        });
      });
    var w = _.getRootElement();
    let T = _._window == null ? window.document : _._window.document, D = p ? (_._window || window).getSelection() : null;
    if (w === null || D === null)
      return !1;
    let C = T.createElement("span");
    return C.style.cssText = "position: fixed; top: -1000px;", C.append(T.createTextNode("#")), w.append(C), w = new Range(), w.setStart(C, 0), w.setEnd(C, 1), D.removeAllRanges(), D.addRange(w), new Promise((x) => {
      let I = _.registerCommand(o.COPY_COMMAND, (W) => (t.objectKlassEquals(W, ClipboardEvent) && (I(), y !== null && (window.clearTimeout(y), y = null), x(g(_, W))), !0), o.COMMAND_PRIORITY_CRITICAL);
      y = window.setTimeout(() => {
        I(), y = null, x(!1);
      }, 50), T.execCommand("copy"), C.remove();
    });
  }, ho;
}
var ac, nf;
function Vg() {
  return nf || (nf = 1, ac = process.env.NODE_ENV === "development" ? im() : sm()), ac;
}
var rf;
function lm() {
  if (rf)
    return Jr;
  rf = 1;
  var r = Vg(), n = Ko(), t = kt(), o = St();
  function u(oe, ne) {
    if (typeof document.caretRangeFromPoint < "u") {
      const te = document.caretRangeFromPoint(oe, ne);
      return te === null ? null : {
        node: te.startContainer,
        offset: te.startOffset
      };
    } else if (document.caretPositionFromPoint !== "undefined") {
      const te = document.caretPositionFromPoint(oe, ne);
      return te === null ? null : {
        node: te.offsetNode,
        offset: te.offset
      };
    } else
      return null;
  }
  const p = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", m = p && "documentMode" in document ? document.documentMode : null, f = p && "InputEvent" in window && !m ? "getTargetRanges" in new window.InputEvent("input") : !1, O = p && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), S = p && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, E = p && /^(?=.*Chrome).*/i.test(navigator.userAgent), R = p && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !E, y = o.createCommand("DRAG_DROP_PASTE_FILE");
  class g extends o.ElementNode {
    static getType() {
      return "quote";
    }
    static clone(ne) {
      return new g(ne.__key);
    }
    constructor(ne) {
      super(ne);
    }
    // View
    createDOM(ne) {
      const te = document.createElement("blockquote");
      return t.addClassNamesToElement(te, ne.theme.quote), te;
    }
    updateDOM(ne, te) {
      return !1;
    }
    static importDOM() {
      return {
        blockquote: (ne) => ({
          conversion: C,
          priority: 0
        })
      };
    }
    exportDOM(ne) {
      const {
        element: te
      } = super.exportDOM(ne);
      if (te && t.isHTMLElement(te)) {
        this.isEmpty() && te.append(document.createElement("br"));
        const K = this.getFormatType();
        te.style.textAlign = K;
        const A = this.getDirection();
        A && (te.dir = A);
      }
      return {
        element: te
      };
    }
    static importJSON(ne) {
      const te = _();
      return te.setFormat(ne.format), te.setIndent(ne.indent), te.setDirection(ne.direction), te;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "quote"
      };
    }
    // Mutation
    insertNewAfter(ne, te) {
      const K = o.$createParagraphNode(), A = this.getDirection();
      return K.setDirection(A), this.insertAfter(K, te), K;
    }
    collapseAtStart() {
      const ne = o.$createParagraphNode();
      return this.getChildren().forEach((K) => ne.append(K)), this.replace(ne), !0;
    }
  }
  function _() {
    return o.$applyNodeReplacement(new g());
  }
  function N(oe) {
    return oe instanceof g;
  }
  class w extends o.ElementNode {
    /** @internal */
    static getType() {
      return "heading";
    }
    static clone(ne) {
      return new w(ne.__tag, ne.__key);
    }
    constructor(ne, te) {
      super(te), this.__tag = ne;
    }
    getTag() {
      return this.__tag;
    }
    // View
    createDOM(ne) {
      const te = this.__tag, K = document.createElement(te), z = ne.theme.heading;
      if (z !== void 0) {
        const ie = z[te];
        t.addClassNamesToElement(K, ie);
      }
      return K;
    }
    updateDOM(ne, te) {
      return !1;
    }
    static importDOM() {
      return {
        h1: (ne) => ({
          conversion: D,
          priority: 0
        }),
        h2: (ne) => ({
          conversion: D,
          priority: 0
        }),
        h3: (ne) => ({
          conversion: D,
          priority: 0
        }),
        h4: (ne) => ({
          conversion: D,
          priority: 0
        }),
        h5: (ne) => ({
          conversion: D,
          priority: 0
        }),
        h6: (ne) => ({
          conversion: D,
          priority: 0
        }),
        p: (ne) => {
          const K = ne.firstChild;
          return K !== null && T(K) ? {
            conversion: () => ({
              node: null
            }),
            priority: 3
          } : null;
        },
        span: (ne) => T(ne) ? {
          conversion: (te) => ({
            node: x("h1")
          }),
          priority: 3
        } : null
      };
    }
    exportDOM(ne) {
      const {
        element: te
      } = super.exportDOM(ne);
      if (te && t.isHTMLElement(te)) {
        this.isEmpty() && te.append(document.createElement("br"));
        const K = this.getFormatType();
        te.style.textAlign = K;
        const A = this.getDirection();
        A && (te.dir = A);
      }
      return {
        element: te
      };
    }
    static importJSON(ne) {
      const te = x(ne.tag);
      return te.setFormat(ne.format), te.setIndent(ne.indent), te.setDirection(ne.direction), te;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        tag: this.getTag(),
        type: "heading",
        version: 1
      };
    }
    // Mutation
    insertNewAfter(ne, te = !0) {
      const K = ne ? ne.anchor.offset : 0, A = K === this.getTextContentSize() || !ne ? o.$createParagraphNode() : x(this.getTag()), z = this.getDirection();
      if (A.setDirection(z), this.insertAfter(A, te), K === 0 && !this.isEmpty() && ne) {
        const ie = o.$createParagraphNode();
        ie.select(), this.replace(ie, !0);
      }
      return A;
    }
    collapseAtStart() {
      const ne = this.isEmpty() ? o.$createParagraphNode() : x(this.getTag());
      return this.getChildren().forEach((K) => ne.append(K)), this.replace(ne), !0;
    }
    extractWithChild() {
      return !0;
    }
  }
  function T(oe) {
    return oe.nodeName.toLowerCase() === "span" ? oe.style.fontSize === "26pt" : !1;
  }
  function D(oe) {
    const ne = oe.nodeName.toLowerCase();
    let te = null;
    return (ne === "h1" || ne === "h2" || ne === "h3" || ne === "h4" || ne === "h5" || ne === "h6") && (te = x(ne), oe.style !== null && te.setFormat(oe.style.textAlign)), {
      node: te
    };
  }
  function C(oe) {
    const ne = _();
    return oe.style !== null && ne.setFormat(oe.style.textAlign), {
      node: ne
    };
  }
  function x(oe) {
    return o.$applyNodeReplacement(new w(oe));
  }
  function I(oe) {
    return oe instanceof w;
  }
  function W(oe, ne) {
    oe.preventDefault(), ne.update(() => {
      const te = o.$getSelection(), K = oe instanceof InputEvent || oe instanceof KeyboardEvent ? null : oe.clipboardData;
      K != null && te !== null && r.$insertDataTransferForRichText(K, te, ne);
    }, {
      tag: "paste"
    });
  }
  async function $(oe, ne) {
    await r.copyToClipboard(ne, t.objectKlassEquals(oe, ClipboardEvent) ? oe : null), ne.update(() => {
      const te = o.$getSelection();
      o.$isRangeSelection(te) ? te.removeText() : o.$isNodeSelection(te) && te.getNodes().forEach((K) => K.remove());
    });
  }
  function B(oe) {
    let ne = null;
    if (oe instanceof DragEvent ? ne = oe.dataTransfer : oe instanceof ClipboardEvent && (ne = oe.clipboardData), ne === null)
      return [!1, [], !1];
    const te = ne.types, K = te.includes("Files"), A = te.includes("text/html") || te.includes("text/plain");
    return [K, Array.from(ne.files), A];
  }
  function L(oe) {
    const ne = o.$getSelection();
    if (!o.$isRangeSelection(ne))
      return !1;
    const te = /* @__PURE__ */ new Set(), K = ne.getNodes();
    for (let A = 0; A < K.length; A++) {
      const z = K[A], ie = z.getKey();
      if (te.has(ie))
        continue;
      const q = t.$getNearestBlockElementAncestorOrThrow(z), Y = q.getKey();
      q.canIndent() && !te.has(Y) && (te.add(Y), oe(q));
    }
    return te.size > 0;
  }
  function P(oe) {
    const ne = o.$getNearestNodeFromDOMNode(oe);
    return o.$isDecoratorNode(ne);
  }
  function F(oe) {
    const ne = oe.focus;
    return ne.key === "root" && ne.offset === o.$getRoot().getChildrenSize();
  }
  function Z(oe) {
    return t.mergeRegister(oe.registerCommand(o.CLICK_COMMAND, (te) => {
      const K = o.$getSelection();
      return o.$isNodeSelection(K) ? (K.clear(), !0) : !1;
    }, 0), oe.registerCommand(o.DELETE_CHARACTER_COMMAND, (te) => {
      const K = o.$getSelection();
      return o.$isRangeSelection(K) ? (K.deleteCharacter(te), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.DELETE_WORD_COMMAND, (te) => {
      const K = o.$getSelection();
      return o.$isRangeSelection(K) ? (K.deleteWord(te), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.DELETE_LINE_COMMAND, (te) => {
      const K = o.$getSelection();
      return o.$isRangeSelection(K) ? (K.deleteLine(te), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.CONTROLLED_TEXT_INSERTION_COMMAND, (te) => {
      const K = o.$getSelection();
      if (typeof te == "string")
        K !== null && K.insertText(te);
      else {
        if (K === null)
          return !1;
        const A = te.dataTransfer;
        if (A != null)
          r.$insertDataTransferForRichText(A, K, oe);
        else if (o.$isRangeSelection(K)) {
          const z = te.data;
          return z && K.insertText(z), !0;
        }
      }
      return !0;
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.REMOVE_TEXT_COMMAND, () => {
      const te = o.$getSelection();
      return o.$isRangeSelection(te) ? (te.removeText(), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.FORMAT_TEXT_COMMAND, (te) => {
      const K = o.$getSelection();
      return o.$isRangeSelection(K) ? (K.formatText(te), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.FORMAT_ELEMENT_COMMAND, (te) => {
      const K = o.$getSelection();
      if (!o.$isRangeSelection(K) && !o.$isNodeSelection(K))
        return !1;
      const A = K.getNodes();
      for (const z of A) {
        const ie = t.$findMatchingParent(z, (q) => o.$isElementNode(q) && !q.isInline());
        ie !== null && ie.setFormat(te);
      }
      return !0;
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.INSERT_LINE_BREAK_COMMAND, (te) => {
      const K = o.$getSelection();
      return o.$isRangeSelection(K) ? (K.insertLineBreak(te), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.INSERT_PARAGRAPH_COMMAND, () => {
      const te = o.$getSelection();
      return o.$isRangeSelection(te) ? (te.insertParagraph(), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.INSERT_TAB_COMMAND, () => (o.$insertNodes([o.$createTabNode()]), !0), o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.INDENT_CONTENT_COMMAND, () => L((te) => {
      const K = te.getIndent();
      te.setIndent(K + 1);
    }), o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.OUTDENT_CONTENT_COMMAND, () => L((te) => {
      const K = te.getIndent();
      K > 0 && te.setIndent(K - 1);
    }), o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.KEY_ARROW_UP_COMMAND, (te) => {
      const K = o.$getSelection();
      if (o.$isNodeSelection(K) && !P(te.target)) {
        const A = K.getNodes();
        if (A.length > 0)
          return A[0].selectPrevious(), !0;
      } else if (o.$isRangeSelection(K)) {
        const A = o.$getAdjacentNode(K.focus, !0);
        if (!te.shiftKey && o.$isDecoratorNode(A) && !A.isIsolated() && !A.isInline())
          return A.selectPrevious(), te.preventDefault(), !0;
      }
      return !1;
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.KEY_ARROW_DOWN_COMMAND, (te) => {
      const K = o.$getSelection();
      if (o.$isNodeSelection(K)) {
        const A = K.getNodes();
        if (A.length > 0)
          return A[0].selectNext(0, 0), !0;
      } else if (o.$isRangeSelection(K)) {
        if (F(K))
          return te.preventDefault(), !0;
        const A = o.$getAdjacentNode(K.focus, !1);
        if (!te.shiftKey && o.$isDecoratorNode(A) && !A.isIsolated() && !A.isInline())
          return A.selectNext(), te.preventDefault(), !0;
      }
      return !1;
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.KEY_ARROW_LEFT_COMMAND, (te) => {
      const K = o.$getSelection();
      if (o.$isNodeSelection(K)) {
        const A = K.getNodes();
        if (A.length > 0)
          return te.preventDefault(), A[0].selectPrevious(), !0;
      }
      if (!o.$isRangeSelection(K))
        return !1;
      if (n.$shouldOverrideDefaultCharacterSelection(K, !0)) {
        const A = te.shiftKey;
        return te.preventDefault(), n.$moveCharacter(K, A, !0), !0;
      }
      return !1;
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.KEY_ARROW_RIGHT_COMMAND, (te) => {
      const K = o.$getSelection();
      if (o.$isNodeSelection(K) && !P(te.target)) {
        const z = K.getNodes();
        if (z.length > 0)
          return te.preventDefault(), z[0].selectNext(0, 0), !0;
      }
      if (!o.$isRangeSelection(K))
        return !1;
      const A = te.shiftKey;
      return n.$shouldOverrideDefaultCharacterSelection(K, !1) ? (te.preventDefault(), n.$moveCharacter(K, A, !1), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.KEY_BACKSPACE_COMMAND, (te) => {
      if (P(te.target))
        return !1;
      const K = o.$getSelection();
      if (!o.$isRangeSelection(K))
        return !1;
      te.preventDefault();
      const {
        anchor: A
      } = K, z = A.getNode();
      return K.isCollapsed() && A.offset === 0 && !o.$isRootNode(z) && t.$getNearestBlockElementAncestorOrThrow(z).getIndent() > 0 ? oe.dispatchCommand(o.OUTDENT_CONTENT_COMMAND, void 0) : oe.dispatchCommand(o.DELETE_CHARACTER_COMMAND, !0);
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.KEY_DELETE_COMMAND, (te) => {
      if (P(te.target))
        return !1;
      const K = o.$getSelection();
      return o.$isRangeSelection(K) ? (te.preventDefault(), oe.dispatchCommand(o.DELETE_CHARACTER_COMMAND, !1)) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.KEY_ENTER_COMMAND, (te) => {
      const K = o.$getSelection();
      if (!o.$isRangeSelection(K))
        return !1;
      if (te !== null) {
        if ((S || O || R) && f)
          return !1;
        if (te.preventDefault(), te.shiftKey)
          return oe.dispatchCommand(o.INSERT_LINE_BREAK_COMMAND, !1);
      }
      return oe.dispatchCommand(o.INSERT_PARAGRAPH_COMMAND, void 0);
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.KEY_ESCAPE_COMMAND, () => {
      const te = o.$getSelection();
      return o.$isRangeSelection(te) ? (oe.blur(), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.DROP_COMMAND, (te) => {
      const [, K] = B(te);
      if (K.length > 0) {
        const z = te.clientX, ie = te.clientY, q = u(z, ie);
        if (q !== null) {
          const {
            offset: Y,
            node: se
          } = q, j = o.$getNearestNodeFromDOMNode(se);
          if (j !== null) {
            const Q = o.$createRangeSelection();
            if (o.$isTextNode(j))
              Q.anchor.set(j.getKey(), Y, "text"), Q.focus.set(j.getKey(), Y, "text");
            else {
              const de = j.getParentOrThrow().getKey(), Ne = j.getIndexWithinParent() + 1;
              Q.anchor.set(de, Ne, "element"), Q.focus.set(de, Ne, "element");
            }
            const ae = o.$normalizeSelection__EXPERIMENTAL(Q);
            o.$setSelection(ae);
          }
          oe.dispatchCommand(y, K);
        }
        return te.preventDefault(), !0;
      }
      const A = o.$getSelection();
      return !!o.$isRangeSelection(A);
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.DRAGSTART_COMMAND, (te) => {
      const [K] = B(te), A = o.$getSelection();
      return !(K && !o.$isRangeSelection(A));
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.DRAGOVER_COMMAND, (te) => {
      const [K] = B(te), A = o.$getSelection();
      if (K && !o.$isRangeSelection(A))
        return !1;
      const z = te.clientX, ie = te.clientY, q = u(z, ie);
      if (q !== null) {
        const Y = o.$getNearestNodeFromDOMNode(q.node);
        o.$isDecoratorNode(Y) && te.preventDefault();
      }
      return !0;
    }, o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.SELECT_ALL_COMMAND, () => (o.$selectAll(), !0), o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.COPY_COMMAND, (te) => (r.copyToClipboard(oe, t.objectKlassEquals(te, ClipboardEvent) ? te : null), !0), o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.CUT_COMMAND, (te) => ($(te, oe), !0), o.COMMAND_PRIORITY_EDITOR), oe.registerCommand(o.PASTE_COMMAND, (te) => {
      const [, K, A] = B(te);
      return K.length > 0 && !A ? (oe.dispatchCommand(y, K), !0) : o.isSelectionCapturedInDecoratorInput(te.target) ? !1 : o.$getSelection() !== null ? (W(te, oe), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR));
  }
  return Jr.$createHeadingNode = x, Jr.$createQuoteNode = _, Jr.$isHeadingNode = I, Jr.$isQuoteNode = N, Jr.DRAG_DROP_PASTE = y, Jr.HeadingNode = w, Jr.QuoteNode = g, Jr.eventFiles = B, Jr.registerRichText = Z, Jr;
}
var Xr = {}, of;
function am() {
  if (of)
    return Xr;
  of = 1;
  var r = Vg(), n = Ko(), t = kt(), o = St();
  function u(L, P) {
    return typeof document.caretRangeFromPoint < "u" ? (L = document.caretRangeFromPoint(L, P), L === null ? null : { node: L.startContainer, offset: L.startOffset }) : document.caretPositionFromPoint !== "undefined" ? (L = document.caretPositionFromPoint(L, P), L === null ? null : { node: L.offsetNode, offset: L.offset }) : null;
  }
  let p = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", m = p && "documentMode" in document ? document.documentMode : null, f = p && "InputEvent" in window && !m ? "getTargetRanges" in new window.InputEvent("input") : !1, O = p && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), S = p && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, E = p && /^(?=.*Chrome).*/i.test(navigator.userAgent), R = p && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !E, y = o.createCommand("DRAG_DROP_PASTE_FILE");
  class g extends o.ElementNode {
    static getType() {
      return "quote";
    }
    static clone(P) {
      return new g(P.__key);
    }
    constructor(P) {
      super(P);
    }
    createDOM(P) {
      let F = document.createElement("blockquote");
      return t.addClassNamesToElement(F, P.theme.quote), F;
    }
    updateDOM() {
      return !1;
    }
    static importDOM() {
      return { blockquote: () => ({ conversion: D, priority: 0 }) };
    }
    exportDOM(P) {
      if ({ element: P } = super.exportDOM(P), P && t.isHTMLElement(P)) {
        this.isEmpty() && P.append(document.createElement("br"));
        var F = this.getFormatType();
        P.style.textAlign = F, (F = this.getDirection()) && (P.dir = F);
      }
      return { element: P };
    }
    static importJSON(P) {
      let F = _();
      return F.setFormat(P.format), F.setIndent(P.indent), F.setDirection(P.direction), F;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "quote" };
    }
    insertNewAfter(P, F) {
      P = o.$createParagraphNode();
      let Z = this.getDirection();
      return P.setDirection(Z), this.insertAfter(P, F), P;
    }
    collapseAtStart() {
      let P = o.$createParagraphNode();
      return this.getChildren().forEach((F) => P.append(F)), this.replace(P), !0;
    }
  }
  function _() {
    return o.$applyNodeReplacement(new g());
  }
  class N extends o.ElementNode {
    static getType() {
      return "heading";
    }
    static clone(P) {
      return new N(P.__tag, P.__key);
    }
    constructor(P, F) {
      super(F), this.__tag = P;
    }
    getTag() {
      return this.__tag;
    }
    createDOM(P) {
      let F = this.__tag, Z = document.createElement(F);
      return P = P.theme.heading, P !== void 0 && t.addClassNamesToElement(Z, P[F]), Z;
    }
    updateDOM() {
      return !1;
    }
    static importDOM() {
      return { h1: () => ({ conversion: T, priority: 0 }), h2: () => ({ conversion: T, priority: 0 }), h3: () => ({ conversion: T, priority: 0 }), h4: () => ({ conversion: T, priority: 0 }), h5: () => ({
        conversion: T,
        priority: 0
      }), h6: () => ({ conversion: T, priority: 0 }), p: (P) => (P = P.firstChild, P !== null && w(P) ? { conversion: () => ({ node: null }), priority: 3 } : null), span: (P) => w(P) ? { conversion: () => ({ node: C("h1") }), priority: 3 } : null };
    }
    exportDOM(P) {
      if ({ element: P } = super.exportDOM(P), P && t.isHTMLElement(P)) {
        this.isEmpty() && P.append(document.createElement("br"));
        var F = this.getFormatType();
        P.style.textAlign = F, (F = this.getDirection()) && (P.dir = F);
      }
      return { element: P };
    }
    static importJSON(P) {
      let F = C(P.tag);
      return F.setFormat(P.format), F.setIndent(P.indent), F.setDirection(P.direction), F;
    }
    exportJSON() {
      return { ...super.exportJSON(), tag: this.getTag(), type: "heading", version: 1 };
    }
    insertNewAfter(P, F = !0) {
      let Z = P ? P.anchor.offset : 0, oe = Z !== this.getTextContentSize() && P ? C(this.getTag()) : o.$createParagraphNode(), ne = this.getDirection();
      return oe.setDirection(ne), this.insertAfter(oe, F), Z === 0 && !this.isEmpty() && P && (P = o.$createParagraphNode(), P.select(), this.replace(P, !0)), oe;
    }
    collapseAtStart() {
      let P = this.isEmpty() ? o.$createParagraphNode() : C(this.getTag());
      return this.getChildren().forEach((F) => P.append(F)), this.replace(P), !0;
    }
    extractWithChild() {
      return !0;
    }
  }
  function w(L) {
    return L.nodeName.toLowerCase() === "span" ? L.style.fontSize === "26pt" : !1;
  }
  function T(L) {
    let P = L.nodeName.toLowerCase(), F = null;
    return (P === "h1" || P === "h2" || P === "h3" || P === "h4" || P === "h5" || P === "h6") && (F = C(P), L.style !== null && F.setFormat(L.style.textAlign)), { node: F };
  }
  function D(L) {
    let P = _();
    return L.style !== null && P.setFormat(L.style.textAlign), { node: P };
  }
  function C(L) {
    return o.$applyNodeReplacement(new N(L));
  }
  function x(L, P) {
    L.preventDefault(), P.update(() => {
      let F = o.$getSelection(), Z = L instanceof InputEvent || L instanceof KeyboardEvent ? null : L.clipboardData;
      Z != null && F !== null && r.$insertDataTransferForRichText(Z, F, P);
    }, { tag: "paste" });
  }
  async function I(L, P) {
    await r.copyToClipboard(P, t.objectKlassEquals(L, ClipboardEvent) ? L : null), P.update(() => {
      let F = o.$getSelection();
      o.$isRangeSelection(F) ? F.removeText() : o.$isNodeSelection(F) && F.getNodes().forEach((Z) => Z.remove());
    });
  }
  function W(L) {
    let P = null;
    if (L instanceof DragEvent ? P = L.dataTransfer : L instanceof ClipboardEvent && (P = L.clipboardData), P === null)
      return [!1, [], !1];
    var F = P.types;
    return L = F.includes("Files"), F = F.includes("text/html") || F.includes("text/plain"), [L, Array.from(P.files), F];
  }
  function $(L) {
    var P = o.$getSelection();
    if (!o.$isRangeSelection(P))
      return !1;
    let F = /* @__PURE__ */ new Set();
    P = P.getNodes();
    for (let ne = 0; ne < P.length; ne++) {
      var Z = P[ne], oe = Z.getKey();
      F.has(oe) || (Z = t.$getNearestBlockElementAncestorOrThrow(Z), oe = Z.getKey(), Z.canIndent() && !F.has(oe) && (F.add(oe), L(Z)));
    }
    return 0 < F.size;
  }
  function B(L) {
    return L = o.$getNearestNodeFromDOMNode(L), o.$isDecoratorNode(L);
  }
  return Xr.$createHeadingNode = C, Xr.$createQuoteNode = _, Xr.$isHeadingNode = function(L) {
    return L instanceof N;
  }, Xr.$isQuoteNode = function(L) {
    return L instanceof g;
  }, Xr.DRAG_DROP_PASTE = y, Xr.HeadingNode = N, Xr.QuoteNode = g, Xr.eventFiles = W, Xr.registerRichText = function(L) {
    return t.mergeRegister(
      L.registerCommand(o.CLICK_COMMAND, () => {
        const P = o.$getSelection();
        return o.$isNodeSelection(P) ? (P.clear(), !0) : !1;
      }, 0),
      L.registerCommand(o.DELETE_CHARACTER_COMMAND, (P) => {
        const F = o.$getSelection();
        return o.$isRangeSelection(F) ? (F.deleteCharacter(P), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.DELETE_WORD_COMMAND, (P) => {
        const F = o.$getSelection();
        return o.$isRangeSelection(F) ? (F.deleteWord(P), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.DELETE_LINE_COMMAND, (P) => {
        const F = o.$getSelection();
        return o.$isRangeSelection(F) ? (F.deleteLine(P), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.CONTROLLED_TEXT_INSERTION_COMMAND, (P) => {
        const F = o.$getSelection();
        if (typeof P == "string")
          F !== null && F.insertText(P);
        else {
          if (F === null)
            return !1;
          const Z = P.dataTransfer;
          Z != null ? r.$insertDataTransferForRichText(Z, F, L) : o.$isRangeSelection(F) && (P = P.data) && F.insertText(P);
        }
        return !0;
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(
        o.REMOVE_TEXT_COMMAND,
        () => {
          const P = o.$getSelection();
          return o.$isRangeSelection(P) ? (P.removeText(), !0) : !1;
        },
        o.COMMAND_PRIORITY_EDITOR
      ),
      L.registerCommand(o.FORMAT_TEXT_COMMAND, (P) => {
        const F = o.$getSelection();
        return o.$isRangeSelection(F) ? (F.formatText(P), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.FORMAT_ELEMENT_COMMAND, (P) => {
        var F = o.$getSelection();
        if (!o.$isRangeSelection(F) && !o.$isNodeSelection(F))
          return !1;
        F = F.getNodes();
        for (const Z of F)
          F = t.$findMatchingParent(Z, (oe) => o.$isElementNode(oe) && !oe.isInline()), F !== null && F.setFormat(P);
        return !0;
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.INSERT_LINE_BREAK_COMMAND, (P) => {
        const F = o.$getSelection();
        return o.$isRangeSelection(F) ? (F.insertLineBreak(P), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.INSERT_PARAGRAPH_COMMAND, () => {
        const P = o.$getSelection();
        return o.$isRangeSelection(P) ? (P.insertParagraph(), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.INSERT_TAB_COMMAND, () => (o.$insertNodes([o.$createTabNode()]), !0), o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.INDENT_CONTENT_COMMAND, () => $((P) => {
        const F = P.getIndent();
        P.setIndent(F + 1);
      }), o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.OUTDENT_CONTENT_COMMAND, () => $((P) => {
        const F = P.getIndent();
        0 < F && P.setIndent(F - 1);
      }), o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.KEY_ARROW_UP_COMMAND, (P) => {
        var F = o.$getSelection();
        if (o.$isNodeSelection(F) && !B(P.target)) {
          if (P = F.getNodes(), 0 < P.length)
            return P[0].selectPrevious(), !0;
        } else if (o.$isRangeSelection(F) && (F = o.$getAdjacentNode(F.focus, !0), !P.shiftKey && o.$isDecoratorNode(F) && !F.isIsolated() && !F.isInline()))
          return F.selectPrevious(), P.preventDefault(), !0;
        return !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.KEY_ARROW_DOWN_COMMAND, (P) => {
        var F = o.$getSelection();
        if (o.$isNodeSelection(F)) {
          if (P = F.getNodes(), 0 < P.length)
            return P[0].selectNext(0, 0), !0;
        } else if (o.$isRangeSelection(F)) {
          let Z = F.focus;
          if (Z.key === "root" && Z.offset === o.$getRoot().getChildrenSize())
            return P.preventDefault(), !0;
          if (F = o.$getAdjacentNode(F.focus, !1), !P.shiftKey && o.$isDecoratorNode(F) && !F.isIsolated() && !F.isInline())
            return F.selectNext(), P.preventDefault(), !0;
        }
        return !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.KEY_ARROW_LEFT_COMMAND, (P) => {
        const F = o.$getSelection();
        if (o.$isNodeSelection(F)) {
          var Z = F.getNodes();
          if (0 < Z.length)
            return P.preventDefault(), Z[0].selectPrevious(), !0;
        }
        return o.$isRangeSelection(F) && n.$shouldOverrideDefaultCharacterSelection(F, !0) ? (Z = P.shiftKey, P.preventDefault(), n.$moveCharacter(F, Z, !0), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.KEY_ARROW_RIGHT_COMMAND, (P) => {
        const F = o.$getSelection();
        if (o.$isNodeSelection(F) && !B(P.target)) {
          var Z = F.getNodes();
          if (0 < Z.length)
            return P.preventDefault(), Z[0].selectNext(0, 0), !0;
        }
        return o.$isRangeSelection(F) ? (Z = P.shiftKey, n.$shouldOverrideDefaultCharacterSelection(F, !1) ? (P.preventDefault(), n.$moveCharacter(F, Z, !1), !0) : !1) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.KEY_BACKSPACE_COMMAND, (P) => {
        if (B(P.target))
          return !1;
        const F = o.$getSelection();
        if (!o.$isRangeSelection(F))
          return !1;
        P.preventDefault(), { anchor: P } = F;
        const Z = P.getNode();
        return F.isCollapsed() && P.offset === 0 && !o.$isRootNode(Z) && 0 < t.$getNearestBlockElementAncestorOrThrow(Z).getIndent() ? L.dispatchCommand(o.OUTDENT_CONTENT_COMMAND, void 0) : L.dispatchCommand(o.DELETE_CHARACTER_COMMAND, !0);
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.KEY_DELETE_COMMAND, (P) => {
        if (B(P.target))
          return !1;
        const F = o.$getSelection();
        return o.$isRangeSelection(F) ? (P.preventDefault(), L.dispatchCommand(o.DELETE_CHARACTER_COMMAND, !1)) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.KEY_ENTER_COMMAND, (P) => {
        const F = o.$getSelection();
        if (!o.$isRangeSelection(F))
          return !1;
        if (P !== null) {
          if ((S || O || R) && f)
            return !1;
          if (P.preventDefault(), P.shiftKey)
            return L.dispatchCommand(o.INSERT_LINE_BREAK_COMMAND, !1);
        }
        return L.dispatchCommand(o.INSERT_PARAGRAPH_COMMAND, void 0);
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.KEY_ESCAPE_COMMAND, () => {
        const P = o.$getSelection();
        return o.$isRangeSelection(P) ? (L.blur(), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.DROP_COMMAND, (P) => {
        const [, F] = W(P);
        if (0 < F.length) {
          var Z = u(P.clientX, P.clientY);
          if (Z !== null) {
            const { offset: ne, node: te } = Z;
            var oe = o.$getNearestNodeFromDOMNode(te);
            if (oe !== null) {
              if (Z = o.$createRangeSelection(), o.$isTextNode(oe))
                Z.anchor.set(oe.getKey(), ne, "text"), Z.focus.set(oe.getKey(), ne, "text");
              else {
                const K = oe.getParentOrThrow().getKey();
                oe = oe.getIndexWithinParent() + 1, Z.anchor.set(K, oe, "element"), Z.focus.set(K, oe, "element");
              }
              Z = o.$normalizeSelection__EXPERIMENTAL(Z), o.$setSelection(Z);
            }
            L.dispatchCommand(y, F);
          }
          return P.preventDefault(), !0;
        }
        return P = o.$getSelection(), !!o.$isRangeSelection(P);
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.DRAGSTART_COMMAND, (P) => {
        [P] = W(P);
        const F = o.$getSelection();
        return !(P && !o.$isRangeSelection(F));
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.DRAGOVER_COMMAND, (P) => {
        var [F] = W(P);
        const Z = o.$getSelection();
        return F && !o.$isRangeSelection(Z) ? !1 : (F = u(P.clientX, P.clientY), F !== null && (F = o.$getNearestNodeFromDOMNode(F.node), o.$isDecoratorNode(F) && P.preventDefault()), !0);
      }, o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.SELECT_ALL_COMMAND, () => (o.$selectAll(), !0), o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.COPY_COMMAND, (P) => (r.copyToClipboard(L, t.objectKlassEquals(P, ClipboardEvent) ? P : null), !0), o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.CUT_COMMAND, (P) => (I(P, L), !0), o.COMMAND_PRIORITY_EDITOR),
      L.registerCommand(o.PASTE_COMMAND, (P) => {
        const [, F, Z] = W(P);
        return 0 < F.length && !Z ? (L.dispatchCommand(y, F), !0) : o.isSelectionCapturedInDecoratorInput(P.target) ? !1 : o.$getSelection() !== null ? (x(P, L), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR)
    );
  }, Xr;
}
const cm = process.env.NODE_ENV === "development" ? lm() : am();
var Tr = cm, tn = {}, sf;
function um() {
  if (sf)
    return tn;
  sf = 1;
  var r = kt(), n = St();
  const t = /^(\d+(?:\.\d+)?)px$/, o = {
    BOTH: 3,
    COLUMN: 2,
    NO_STATUS: 0,
    ROW: 1
  };
  class u extends n.ElementNode {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "tablecell";
    }
    static clone(ue) {
      const he = new u(ue.__headerState, ue.__colSpan, ue.__width, ue.__key);
      return he.__rowSpan = ue.__rowSpan, he.__backgroundColor = ue.__backgroundColor, he;
    }
    static importDOM() {
      return {
        td: (ue) => ({
          conversion: p,
          priority: 0
        }),
        th: (ue) => ({
          conversion: p,
          priority: 0
        })
      };
    }
    static importJSON(ue) {
      const he = ue.colSpan || 1, Se = ue.rowSpan || 1, $e = m(ue.headerState, he, ue.width || void 0);
      return $e.__rowSpan = Se, $e.__backgroundColor = ue.backgroundColor || null, $e;
    }
    constructor(ue = o.NO_STATUS, he = 1, Se, $e) {
      super($e), this.__colSpan = he, this.__rowSpan = 1, this.__headerState = ue, this.__width = Se, this.__backgroundColor = null;
    }
    createDOM(ue) {
      const he = document.createElement(this.getTag());
      return this.__width && (he.style.width = `${this.__width}px`), this.__colSpan > 1 && (he.colSpan = this.__colSpan), this.__rowSpan > 1 && (he.rowSpan = this.__rowSpan), this.__backgroundColor !== null && (he.style.backgroundColor = this.__backgroundColor), r.addClassNamesToElement(he, ue.theme.tableCell, this.hasHeader() && ue.theme.tableCellHeader), he;
    }
    exportDOM(ue) {
      const {
        element: he
      } = super.exportDOM(ue);
      if (he) {
        const Se = he, $e = 700, Re = this.getParentOrThrow().getChildrenSize();
        Se.style.border = "1px solid black", this.__colSpan > 1 && (Se.colSpan = this.__colSpan), this.__rowSpan > 1 && (Se.rowSpan = this.__rowSpan), Se.style.width = `${this.getWidth() || Math.max(90, $e / Re)}px`, Se.style.verticalAlign = "top", Se.style.textAlign = "start";
        const We = this.getBackgroundColor();
        We !== null ? Se.style.backgroundColor = We : this.hasHeader() && (Se.style.backgroundColor = "#f2f3f5");
      }
      return {
        element: he
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        backgroundColor: this.getBackgroundColor(),
        colSpan: this.__colSpan,
        headerState: this.__headerState,
        rowSpan: this.__rowSpan,
        type: "tablecell",
        width: this.getWidth()
      };
    }
    getColSpan() {
      return this.__colSpan;
    }
    setColSpan(ue) {
      return this.getWritable().__colSpan = ue, this;
    }
    getRowSpan() {
      return this.__rowSpan;
    }
    setRowSpan(ue) {
      return this.getWritable().__rowSpan = ue, this;
    }
    getTag() {
      return this.hasHeader() ? "th" : "td";
    }
    setHeaderStyles(ue) {
      const he = this.getWritable();
      return he.__headerState = ue, this.__headerState;
    }
    getHeaderStyles() {
      return this.getLatest().__headerState;
    }
    setWidth(ue) {
      const he = this.getWritable();
      return he.__width = ue, this.__width;
    }
    getWidth() {
      return this.getLatest().__width;
    }
    getBackgroundColor() {
      return this.getLatest().__backgroundColor;
    }
    setBackgroundColor(ue) {
      this.getWritable().__backgroundColor = ue;
    }
    toggleHeaderStyle(ue) {
      const he = this.getWritable();
      return (he.__headerState & ue) === ue ? he.__headerState -= ue : he.__headerState += ue, he;
    }
    hasHeaderState(ue) {
      return (this.getHeaderStyles() & ue) === ue;
    }
    hasHeader() {
      return this.getLatest().__headerState !== o.NO_STATUS;
    }
    updateDOM(ue) {
      return ue.__headerState !== this.__headerState || ue.__width !== this.__width || ue.__colSpan !== this.__colSpan || ue.__rowSpan !== this.__rowSpan || ue.__backgroundColor !== this.__backgroundColor;
    }
    isShadowRoot() {
      return !0;
    }
    collapseAtStart() {
      return !0;
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
  }
  function p(Te) {
    const ue = Te, he = Te.nodeName.toLowerCase();
    let Se;
    t.test(ue.style.width) && (Se = parseFloat(ue.style.width));
    const $e = m(he === "th" ? o.ROW : o.NO_STATUS, ue.colSpan, Se);
    $e.__rowSpan = ue.rowSpan;
    const Re = ue.style.backgroundColor;
    return Re !== "" && ($e.__backgroundColor = Re), {
      forChild: (We, rt) => {
        if (f(rt) && !n.$isElementNode(We)) {
          const lt = n.$createParagraphNode();
          return n.$isLineBreakNode(We) && We.getTextContent() === `
` ? null : (lt.append(We), lt);
        }
        return We;
      },
      node: $e
    };
  }
  function m(Te, ue = 1, he) {
    return n.$applyNodeReplacement(new u(Te, ue, he));
  }
  function f(Te) {
    return Te instanceof u;
  }
  const O = n.createCommand("INSERT_TABLE_COMMAND");
  class S extends n.ElementNode {
    /** @internal */
    static getType() {
      return "tablerow";
    }
    static clone(ue) {
      return new S(ue.__height, ue.__key);
    }
    static importDOM() {
      return {
        tr: (ue) => ({
          conversion: E,
          priority: 0
        })
      };
    }
    static importJSON(ue) {
      return R(ue.height);
    }
    constructor(ue, he) {
      super(he), this.__height = ue;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "tablerow",
        version: 1
      };
    }
    createDOM(ue) {
      const he = document.createElement("tr");
      return this.__height && (he.style.height = `${this.__height}px`), r.addClassNamesToElement(he, ue.theme.tableRow), he;
    }
    isShadowRoot() {
      return !0;
    }
    setHeight(ue) {
      const he = this.getWritable();
      return he.__height = ue, this.__height;
    }
    getHeight() {
      return this.getLatest().__height;
    }
    updateDOM(ue) {
      return ue.__height !== this.__height;
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
  }
  function E(Te) {
    const ue = Te;
    let he;
    return t.test(ue.style.height) && (he = parseFloat(ue.style.height)), {
      node: R(he)
    };
  }
  function R(Te) {
    return n.$applyNodeReplacement(new S(Te));
  }
  function y(Te) {
    return Te instanceof S;
  }
  const g = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  function _(Te, ue, he = !0) {
    const Se = Gt();
    for (let $e = 0; $e < Te; $e++) {
      const Re = R();
      for (let We = 0; We < ue; We++) {
        let rt = o.NO_STATUS;
        typeof he == "object" ? ($e === 0 && he.rows && (rt |= o.ROW), We === 0 && he.columns && (rt |= o.COLUMN)) : he && ($e === 0 && (rt |= o.ROW), We === 0 && (rt |= o.COLUMN));
        const lt = m(rt), tt = n.$createParagraphNode();
        tt.append(n.$createTextNode()), lt.append(tt), Re.append(lt);
      }
      Se.append(Re);
    }
    return Se;
  }
  function N(Te) {
    const ue = r.$findMatchingParent(Te, (he) => f(he));
    return f(ue) ? ue : null;
  }
  function w(Te) {
    const ue = r.$findMatchingParent(Te, (he) => y(he));
    if (y(ue))
      return ue;
    throw new Error("Expected table cell to be inside of table row.");
  }
  function T(Te) {
    const ue = r.$findMatchingParent(Te, (he) => Ot(he));
    if (Ot(ue))
      return ue;
    throw new Error("Expected table cell to be inside of table.");
  }
  function D(Te) {
    const ue = w(Te);
    return T(ue).getChildren().findIndex((Se) => Se.is(ue));
  }
  function C(Te) {
    return w(Te).getChildren().findIndex((he) => he.is(Te));
  }
  function x(Te, ue) {
    const he = T(Te), {
      x: Se,
      y: $e
    } = he.getCordsFromCellNode(Te, ue);
    return {
      above: he.getCellNodeFromCords(Se, $e - 1, ue),
      below: he.getCellNodeFromCords(Se, $e + 1, ue),
      left: he.getCellNodeFromCords(Se - 1, $e, ue),
      right: he.getCellNodeFromCords(Se + 1, $e, ue)
    };
  }
  function I(Te, ue) {
    const he = Te.getChildren();
    if (ue >= he.length || ue < 0)
      throw new Error("Expected table cell to be inside of table row.");
    return he[ue].remove(), Te;
  }
  function W(Te, ue, he = !0, Se, $e) {
    const Re = Te.getChildren();
    if (ue >= Re.length || ue < 0)
      throw new Error("Table row target index out of range");
    const We = Re[ue];
    if (y(We))
      for (let rt = 0; rt < Se; rt++) {
        const lt = We.getChildren(), tt = lt.length, Nt = R();
        for (let Be = 0; Be < tt; Be++) {
          const Ke = lt[Be];
          if (!f(Ke))
            throw Error("Expected table cell");
          const {
            above: Ye,
            below: ft
          } = x(Ke, $e);
          let ct = o.NO_STATUS;
          const gt = Ye && Ye.getWidth() || ft && ft.getWidth() || void 0;
          (Ye && Ye.hasHeaderState(o.COLUMN) || ft && ft.hasHeaderState(o.COLUMN)) && (ct |= o.COLUMN);
          const wt = m(ct, 1, gt);
          wt.append(n.$createParagraphNode()), Nt.append(wt);
        }
        he ? We.insertAfter(Nt) : We.insertBefore(Nt);
      }
    else
      throw new Error("Row before insertion index does not exist.");
    return Te;
  }
  const $ = (Te, ue) => Te === o.BOTH || Te === ue ? ue : o.NO_STATUS;
  function B(Te = !0) {
    const ue = n.$getSelection();
    if (!(n.$isRangeSelection(ue) || Y(ue)))
      throw Error("Expected a RangeSelection or GridSelection");
    const he = ue.focus.getNode(), [Se, , $e] = z(he), [Re, We] = A($e, Se, Se), rt = Re[0].length, {
      startRow: lt
    } = We;
    if (Te) {
      const tt = lt + Se.__rowSpan - 1, Nt = Re[tt], Be = R();
      for (let Ye = 0; Ye < rt; Ye++) {
        const {
          cell: ft,
          startRow: ct
        } = Nt[Ye];
        if (ct + ft.__rowSpan - 1 <= tt) {
          const wt = Nt[Ye].cell.__headerState, Mt = $(wt, o.COLUMN);
          Be.append(m(Mt).append(n.$createParagraphNode()));
        } else
          ft.setRowSpan(ft.__rowSpan + 1);
      }
      const Ke = $e.getChildAtIndex(tt);
      if (!y(Ke))
        throw Error("focusEndRow is not a TableRowNode");
      Ke.insertAfter(Be);
    } else {
      const tt = Re[lt], Nt = R();
      for (let Ke = 0; Ke < rt; Ke++) {
        const {
          cell: Ye,
          startRow: ft
        } = tt[Ke];
        if (ft === lt) {
          const gt = tt[Ke].cell.__headerState, wt = $(gt, o.COLUMN);
          Nt.append(m(wt).append(n.$createParagraphNode()));
        } else
          Ye.setRowSpan(Ye.__rowSpan + 1);
      }
      const Be = $e.getChildAtIndex(lt);
      if (!y(Be))
        throw Error("focusEndRow is not a TableRowNode");
      Be.insertBefore(Nt);
    }
  }
  function L(Te, ue, he = !0, Se, $e) {
    const Re = Te.getChildren(), We = [];
    for (let rt = 0; rt < Re.length; rt++) {
      const lt = Re[rt];
      if (y(lt))
        for (let tt = 0; tt < Se; tt++) {
          const Nt = lt.getChildren();
          if (ue >= Nt.length || ue < 0)
            throw new Error("Table column target index out of range");
          const Be = Nt[ue];
          if (!f(Be))
            throw Error("Expected table cell");
          const {
            left: Ke,
            right: Ye
          } = x(Be, $e);
          let ft = o.NO_STATUS;
          (Ke && Ke.hasHeaderState(o.ROW) || Ye && Ye.hasHeaderState(o.ROW)) && (ft |= o.ROW);
          const ct = m(ft);
          ct.append(n.$createParagraphNode()), We.push({
            newTableCell: ct,
            targetCell: Be
          });
        }
    }
    return We.forEach(({
      newTableCell: rt,
      targetCell: lt
    }) => {
      he ? lt.insertAfter(rt) : lt.insertBefore(rt);
    }), Te;
  }
  function P(Te = !0) {
    const ue = n.$getSelection();
    if (!(n.$isRangeSelection(ue) || Y(ue)))
      throw Error("Expected a RangeSelection or GridSelection");
    const he = ue.anchor.getNode(), Se = ue.focus.getNode(), [$e] = z(he), [Re, , We] = z(Se), [rt, lt, tt] = A(We, Re, $e), Nt = rt.length, Be = Te ? Math.max(lt.startColumn, tt.startColumn) : Math.min(lt.startColumn, tt.startColumn), Ke = Te ? Be + Re.__colSpan - 1 : Be - 1, Ye = We.getFirstChild();
    if (!y(Ye))
      throw Error("Expected firstTable child to be a row");
    let ft = null;
    function ct(wt = o.NO_STATUS) {
      const Mt = m(wt).append(n.$createParagraphNode());
      return ft === null && (ft = Mt), Mt;
    }
    let gt = Ye;
    e:
      for (let wt = 0; wt < Nt; wt++) {
        if (wt !== 0) {
          const qt = gt.getNextSibling();
          if (!y(qt))
            throw Error("Expected row nextSibling to be a row");
          gt = qt;
        }
        const Mt = rt[wt], It = Mt[Ke < 0 ? 0 : Ke].cell.__headerState, on = $(It, o.ROW);
        if (Ke < 0) {
          te(gt, ct(on));
          continue;
        }
        const {
          cell: Dt,
          startColumn: en,
          startRow: jt
        } = Mt[Ke];
        if (en + Dt.__colSpan - 1 <= Ke) {
          let qt = Dt, _e = jt, Ue = Ke;
          for (; _e !== wt && qt.__rowSpan > 1; )
            if (Ue -= Dt.__colSpan, Ue >= 0) {
              const {
                cell: at,
                startRow: Rt
              } = Mt[Ue];
              qt = at, _e = Rt;
            } else {
              gt.append(ct(on));
              continue e;
            }
          qt.insertAfter(ct(on));
        } else
          Dt.setColSpan(Dt.__colSpan + 1);
      }
    ft !== null && ne(ft);
  }
  function F(Te, ue) {
    const he = Te.getChildren();
    for (let Se = 0; Se < he.length; Se++) {
      const $e = he[Se];
      if (y($e)) {
        const Re = $e.getChildren();
        if (ue >= Re.length || ue < 0)
          throw new Error("Table column target index out of range");
        Re[ue].remove();
      }
    }
    return Te;
  }
  function Z() {
    const Te = n.$getSelection();
    if (!(n.$isRangeSelection(Te) || Y(Te)))
      throw Error("Expected a RangeSelection or GridSelection");
    const ue = Te.anchor.getNode(), he = Te.focus.getNode(), [Se, , $e] = z(ue), [Re] = z(he), [We, rt, lt] = A($e, Se, Re), {
      startRow: tt
    } = rt, {
      startRow: Nt
    } = lt, Be = Nt + Re.__rowSpan - 1;
    if (We.length === Be - tt + 1) {
      $e.remove();
      return;
    }
    const Ke = We[0].length, Ye = We[Be + 1], ft = $e.getChildAtIndex(Be + 1);
    for (let ct = Be; ct >= tt; ct--) {
      for (let wt = Ke - 1; wt >= 0; wt--) {
        const {
          cell: Mt,
          startRow: It,
          startColumn: on
        } = We[ct][wt];
        if (on === wt && (ct === tt && It < tt && Mt.setRowSpan(Mt.__rowSpan - (It - tt)), It >= tt && It + Mt.__rowSpan - 1 > Be)) {
          if (Mt.setRowSpan(Mt.__rowSpan - (Be - It + 1)), ft === null)
            throw Error("Expected nextRowNode not to be null");
          if (wt === 0)
            te(ft, Mt);
          else {
            const {
              cell: Dt
            } = Ye[wt - 1];
            Dt.insertAfter(Mt);
          }
        }
      }
      const gt = $e.getChildAtIndex(ct);
      if (!y(gt))
        throw Error(`Expected GridNode childAtIndex(${String(ct)}) to be RowNode`);
      gt.remove();
    }
    if (Ye !== void 0) {
      const {
        cell: ct
      } = Ye[0];
      ne(ct);
    } else {
      const ct = We[tt - 1], {
        cell: gt
      } = ct[0];
      ne(gt);
    }
  }
  function oe() {
    const Te = n.$getSelection();
    if (!(n.$isRangeSelection(Te) || Y(Te)))
      throw Error("Expected a RangeSelection or GridSelection");
    const ue = Te.anchor.getNode(), he = Te.focus.getNode(), [Se, , $e] = z(ue), [Re] = z(he), [We, rt, lt] = A($e, Se, Re), {
      startColumn: tt
    } = rt, {
      startRow: Nt,
      startColumn: Be
    } = lt, Ke = Math.min(tt, Be), Ye = Math.max(tt + Se.__colSpan - 1, Be + Re.__colSpan - 1), ft = Ye - Ke + 1;
    if (We[0].length === Ye - Ke + 1) {
      $e.selectPrevious(), $e.remove();
      return;
    }
    const gt = We.length;
    for (let It = 0; It < gt; It++)
      for (let on = Ke; on <= Ye; on++) {
        const {
          cell: Dt,
          startColumn: en
        } = We[It][on];
        if (en < Ke) {
          if (on === Ke) {
            const jt = Ke - en;
            Dt.setColSpan(Dt.__colSpan - // Possible overflow right too
            Math.min(ft, Dt.__colSpan - jt));
          }
        } else if (en + Dt.__colSpan - 1 > Ye) {
          if (on === Ye) {
            const jt = Ye - en + 1;
            Dt.setColSpan(Dt.__colSpan - jt);
          }
        } else
          Dt.remove();
      }
    const wt = We[Nt], Mt = wt[Be + Re.__colSpan];
    if (Mt !== void 0) {
      const {
        cell: It
      } = Mt;
      ne(It);
    } else {
      const It = wt[Be - 1], {
        cell: on
      } = It;
      ne(on);
    }
  }
  function ne(Te) {
    const ue = Te.getFirstDescendant();
    ue == null ? Te.selectStart() : ue.getParentOrThrow().selectStart();
  }
  function te(Te, ue) {
    const he = Te.getFirstChild();
    he !== null ? he.insertBefore(ue) : Te.append(ue);
  }
  function K() {
    const Te = n.$getSelection();
    if (!(n.$isRangeSelection(Te) || Y(Te)))
      throw Error("Expected a RangeSelection or GridSelection");
    const ue = Te.anchor.getNode(), [he, Se, $e] = z(ue), Re = he.__colSpan, We = he.__rowSpan;
    if (Re > 1) {
      for (let rt = 1; rt < Re; rt++)
        he.insertAfter(m(o.NO_STATUS));
      he.setColSpan(1);
    }
    if (We > 1) {
      const [rt, lt] = A($e, he, he), {
        startColumn: tt,
        startRow: Nt
      } = lt;
      let Be;
      for (let Ke = 1; Ke < We; Ke++) {
        const Ye = Nt + Ke, ft = rt[Ye];
        if (Be = (Be || Se).getNextSibling(), !y(Be))
          throw Error("Expected row next sibling to be a row");
        let ct = null;
        for (let gt = 0; gt < tt; gt++) {
          const wt = ft[gt], Mt = wt.cell;
          wt.startRow === Ye && (ct = Mt), Mt.__colSpan > 1 && (gt += Mt.__colSpan - 1);
        }
        if (ct === null)
          for (let gt = 0; gt < Re; gt++)
            te(Be, m(o.NO_STATUS));
        else
          for (let gt = 0; gt < Re; gt++)
            ct.insertAfter(m(o.NO_STATUS));
      }
      he.setRowSpan(1);
    }
  }
  function A(Te, ue, he) {
    const Se = [];
    let $e = null, Re = null;
    function We(tt, Nt, Be) {
      const Ke = {
        cell: Be,
        startColumn: Nt,
        startRow: tt
      }, Ye = Be.__rowSpan, ft = Be.__colSpan;
      for (let ct = 0; ct < Ye; ct++) {
        Se[tt + ct] === void 0 && (Se[tt + ct] = []);
        for (let gt = 0; gt < ft; gt++)
          Se[tt + ct][Nt + gt] = Ke;
      }
      ue.is(Be) && ($e = Ke), he.is(Be) && (Re = Ke);
    }
    function rt(tt, Nt) {
      return Se[tt] === void 0 || Se[tt][Nt] === void 0;
    }
    const lt = Te.getChildren();
    for (let tt = 0; tt < lt.length; tt++) {
      const Nt = lt[tt];
      if (!y(Nt))
        throw Error("Expected GridNode children to be TableRowNode");
      const Be = Nt.getChildren();
      let Ke = 0;
      for (const Ye of Be) {
        if (!f(Ye))
          throw Error("Expected TableRowNode children to be TableCellNode");
        for (; !rt(tt, Ke); )
          Ke++;
        We(tt, Ke, Ye), Ke += Ye.__colSpan;
      }
    }
    if ($e === null)
      throw Error("Anchor not found in Grid");
    if (Re === null)
      throw Error("Focus not found in Grid");
    return [Se, $e, Re];
  }
  function z(Te) {
    let ue;
    if (Te instanceof u)
      ue = Te;
    else if ("__type" in Te) {
      const $e = r.$findMatchingParent(Te, f);
      if (!f($e))
        throw Error("Expected to find a parent TableCellNode");
      ue = $e;
    } else {
      const $e = r.$findMatchingParent(Te.getNode(), f);
      if (!f($e))
        throw Error("Expected to find a parent TableCellNode");
      ue = $e;
    }
    const he = ue.getParent();
    if (!y(he))
      throw Error("Expected TableCellNode to have a parent TableRowNode");
    const Se = he.getParent();
    if (!Ot(Se))
      throw Error("Expected TableRowNode to have a parent GridNode");
    return [ue, he, Se];
  }
  function ie(Te) {
    const [ue, , he] = z(Te), Se = he.getChildren(), $e = Se.length, Re = Se[0].getChildren().length, We = new Array($e);
    for (let rt = 0; rt < $e; rt++)
      We[rt] = new Array(Re);
    for (let rt = 0; rt < $e; rt++) {
      const tt = Se[rt].getChildren();
      let Nt = 0;
      for (let Be = 0; Be < tt.length; Be++) {
        for (; We[rt][Nt]; )
          Nt++;
        const Ke = tt[Be], Ye = Ke.__rowSpan || 1, ft = Ke.__colSpan || 1;
        for (let ct = 0; ct < Ye; ct++)
          for (let gt = 0; gt < ft; gt++)
            We[rt + ct][Nt + gt] = Ke;
        if (ue === Ke)
          return {
            colSpan: ft,
            columnIndex: Nt,
            rowIndex: rt,
            rowSpan: Ye
          };
        Nt += ft;
      }
    }
    return null;
  }
  class q {
    constructor(ue, he, Se) {
      this.anchor = he, this.focus = Se, he._selection = this, Se._selection = this, this._cachedNodes = null, this.dirty = !1, this.tableKey = ue;
    }
    getStartEndPoints() {
      return [this.anchor, this.focus];
    }
    /**
     * Returns whether the Selection is "backwards", meaning the focus
     * logically precedes the anchor in the EditorState.
     * @returns true if the Selection is backwards, false otherwise.
     */
    isBackward() {
      return this.focus.isBefore(this.anchor);
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(ue) {
      this._cachedNodes = ue;
    }
    is(ue) {
      return Y(ue) ? this.tableKey === ue.tableKey && this.anchor.is(ue.anchor) && this.focus.is(ue.focus) : !1;
    }
    set(ue, he, Se) {
      this.dirty = !0, this.tableKey = ue, this.anchor.key = he, this.focus.key = Se, this._cachedNodes = null;
    }
    clone() {
      return new q(this.tableKey, this.anchor, this.focus);
    }
    isCollapsed() {
      return !1;
    }
    extract() {
      return this.getNodes();
    }
    insertRawText(ue) {
    }
    insertText() {
    }
    insertNodes(ue) {
      const he = this.focus.getNode();
      if (!n.$isElementNode(he))
        throw Error("Expected TableSelection focus to be an ElementNode");
      n.$normalizeSelection__EXPERIMENTAL(he.select(0, he.getChildrenSize())).insertNodes(ue);
    }
    // TODO Deprecate this method. It's confusing when used with colspan|rowspan
    getShape() {
      const ue = n.$getNodeByKey(this.anchor.key);
      if (!f(ue))
        throw Error("Expected TableSelection anchor to be (or a child of) TableCellNode");
      const he = ie(ue);
      if (he === null)
        throw Error("getCellRect: expected to find AnchorNode");
      const Se = n.$getNodeByKey(this.focus.key);
      if (!f(Se))
        throw Error("Expected TableSelection focus to be (or a child of) TableCellNode");
      const $e = ie(Se);
      if ($e === null)
        throw Error("getCellRect: expected to find focusCellNode");
      const Re = Math.min(he.columnIndex, $e.columnIndex), We = Math.max(he.columnIndex, $e.columnIndex), rt = Math.min(he.rowIndex, $e.rowIndex), lt = Math.max(he.rowIndex, $e.rowIndex);
      return {
        fromX: Math.min(Re, We),
        fromY: Math.min(rt, lt),
        toX: Math.max(Re, We),
        toY: Math.max(rt, lt)
      };
    }
    getNodes() {
      const ue = this._cachedNodes;
      if (ue !== null)
        return ue;
      const he = this.anchor.getNode(), Se = this.focus.getNode(), $e = r.$findMatchingParent(he, f), Re = r.$findMatchingParent(Se, f);
      if (!f($e))
        throw Error("Expected TableSelection anchor to be (or a child of) TableCellNode");
      if (!f(Re))
        throw Error("Expected TableSelection focus to be (or a child of) TableCellNode");
      const We = $e.getParent();
      if (!y(We))
        throw Error("Expected anchorCell to have a parent TableRowNode");
      const rt = We.getParent();
      if (!Ot(rt))
        throw Error("Expected tableNode to have a parent TableNode");
      const lt = Re.getParents()[1];
      if (lt !== rt) {
        if (rt.isParentOf(Re)) {
          const jt = lt.getParent();
          if (jt == null)
            throw Error("Expected focusCellParent to have a parent");
          this.set(this.tableKey, Re.getKey(), jt.getKey());
        } else {
          const jt = rt.getParent();
          if (jt == null)
            throw Error("Expected gridParent to have a parent");
          this.set(this.tableKey, jt.getKey(), Re.getKey());
        }
        return this.getNodes();
      }
      const [tt, Nt, Be] = A(rt, $e, Re);
      let Ke = Math.min(Nt.startColumn, Be.startColumn), Ye = Math.min(Nt.startRow, Be.startRow), ft = Math.max(Nt.startColumn + Nt.cell.__colSpan - 1, Be.startColumn + Be.cell.__colSpan - 1), ct = Math.max(Nt.startRow + Nt.cell.__rowSpan - 1, Be.startRow + Be.cell.__rowSpan - 1), gt = Ke, wt = Ye, Mt = Ke, It = Ye;
      function on(jt) {
        const {
          cell: qt,
          startColumn: _e,
          startRow: Ue
        } = jt;
        Ke = Math.min(Ke, _e), Ye = Math.min(Ye, Ue), ft = Math.max(ft, _e + qt.__colSpan - 1), ct = Math.max(ct, Ue + qt.__rowSpan - 1);
      }
      for (; Ke < gt || Ye < wt || ft > Mt || ct > It; ) {
        if (Ke < gt) {
          const jt = It - wt, qt = gt - 1;
          for (let _e = 0; _e <= jt; _e++)
            on(tt[wt + _e][qt]);
          gt = qt;
        }
        if (Ye < wt) {
          const jt = Mt - gt, qt = wt - 1;
          for (let _e = 0; _e <= jt; _e++)
            on(tt[qt][gt + _e]);
          wt = qt;
        }
        if (ft > Mt) {
          const jt = It - wt, qt = Mt + 1;
          for (let _e = 0; _e <= jt; _e++)
            on(tt[wt + _e][qt]);
          Mt = qt;
        }
        if (ct > It) {
          const jt = Mt - gt, qt = It + 1;
          for (let _e = 0; _e <= jt; _e++)
            on(tt[qt][gt + _e]);
          It = qt;
        }
      }
      const Dt = [rt];
      let en = null;
      for (let jt = Ye; jt <= ct; jt++)
        for (let qt = Ke; qt <= ft; qt++) {
          const {
            cell: _e
          } = tt[jt][qt], Ue = _e.getParent();
          if (!y(Ue))
            throw Error("Expected TableCellNode parent to be a TableRowNode");
          Ue !== en && Dt.push(Ue), Dt.push(_e, ...j(_e)), en = Ue;
        }
      return n.isCurrentlyReadOnlyMode() || (this._cachedNodes = Dt), Dt;
    }
    getTextContent() {
      const ue = this.getNodes();
      let he = "";
      for (let Se = 0; Se < ue.length; Se++)
        he += ue[Se].getTextContent();
      return he;
    }
  }
  function Y(Te) {
    return Te instanceof q;
  }
  function se() {
    const Te = n.$createPoint("root", 0, "element"), ue = n.$createPoint("root", 0, "element");
    return new q("root", Te, ue);
  }
  function j(Te) {
    const ue = [], he = [Te];
    for (; he.length > 0; ) {
      const Se = he.pop();
      if (Se === void 0)
        throw Error("Stack.length > 0; can't be undefined");
      n.$isElementNode(Se) && he.unshift(...Se.getChildren()), Se !== Te && ue.push(Se);
    }
    return ue;
  }
  const Q = (Te) => g ? (Te || window).getSelection() : null;
  class ae {
    constructor(ue, he) {
      this.isHighlightingCells = !1, this.anchorX = -1, this.anchorY = -1, this.focusX = -1, this.focusY = -1, this.listenersToRemove = /* @__PURE__ */ new Set(), this.tableNodeKey = he, this.editor = ue, this.table = {
        columns: 0,
        domRows: [],
        rows: 0
      }, this.tableSelection = null, this.anchorCellNodeKey = null, this.focusCellNodeKey = null, this.anchorCell = null, this.focusCell = null, this.hasHijackedSelectionStyles = !1, this.trackTable();
    }
    getTable() {
      return this.table;
    }
    removeListeners() {
      Array.from(this.listenersToRemove).forEach((ue) => ue());
    }
    trackTable() {
      const ue = new MutationObserver((he) => {
        this.editor.update(() => {
          let Se = !1;
          for (let Re = 0; Re < he.length; Re++) {
            const lt = he[Re].target.nodeName;
            if (lt === "TABLE" || lt === "TR") {
              Se = !0;
              break;
            }
          }
          if (!Se)
            return;
          const $e = this.editor.getElementByKey(this.tableNodeKey);
          if (!$e)
            throw new Error("Expected to find TableElement in DOM");
          this.table = ke($e);
        });
      });
      this.editor.update(() => {
        const he = this.editor.getElementByKey(this.tableNodeKey);
        if (!he)
          throw new Error("Expected to find TableElement in DOM");
        this.table = ke(he), ue.observe(he, {
          childList: !0,
          subtree: !0
        });
      });
    }
    clearHighlight() {
      const ue = this.editor;
      this.isHighlightingCells = !1, this.anchorX = -1, this.anchorY = -1, this.focusX = -1, this.focusY = -1, this.tableSelection = null, this.anchorCellNodeKey = null, this.focusCellNodeKey = null, this.anchorCell = null, this.focusCell = null, this.hasHijackedSelectionStyles = !1, this.enableHighlightStyle(), ue.update(() => {
        const he = n.$getNodeByKey(this.tableNodeKey);
        if (!Ot(he))
          throw new Error("Expected TableNode.");
        const Se = ue.getElementByKey(this.tableNodeKey);
        if (!Se)
          throw new Error("Expected to find TableElement in DOM");
        const $e = ke(Se);
        J(ue, $e, null), n.$setSelection(null), ue.dispatchCommand(n.SELECTION_CHANGE_COMMAND, void 0);
      });
    }
    enableHighlightStyle() {
      const ue = this.editor;
      ue.update(() => {
        const he = ue.getElementByKey(this.tableNodeKey);
        if (!he)
          throw new Error("Expected to find TableElement in DOM");
        r.removeClassNamesFromElement(he, ue._config.theme.tableSelection), he.classList.remove("disable-selection"), this.hasHijackedSelectionStyles = !1;
      });
    }
    disableHighlightStyle() {
      const ue = this.editor;
      ue.update(() => {
        const he = ue.getElementByKey(this.tableNodeKey);
        if (!he)
          throw new Error("Expected to find TableElement in DOM");
        r.addClassNamesToElement(he, ue._config.theme.tableSelection), this.hasHijackedSelectionStyles = !0;
      });
    }
    updateTableTableSelection(ue) {
      if (ue !== null && ue.tableKey === this.tableNodeKey) {
        const he = this.editor;
        this.tableSelection = ue, this.isHighlightingCells = !0, this.disableHighlightStyle(), J(he, this.table, this.tableSelection);
      } else
        ue == null ? this.clearHighlight() : (this.tableNodeKey = ue.tableKey, this.updateTableTableSelection(ue));
    }
    setFocusCellForSelection(ue, he = !1) {
      const Se = this.editor;
      Se.update(() => {
        const $e = n.$getNodeByKey(this.tableNodeKey);
        if (!Ot($e))
          throw new Error("Expected TableNode.");
        if (!Se.getElementByKey(this.tableNodeKey))
          throw new Error("Expected to find TableElement in DOM");
        const We = ue.x, rt = ue.y;
        if (this.focusCell = ue, this.anchorCell !== null) {
          const lt = Q(Se._window);
          lt && lt.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);
        }
        if (!this.isHighlightingCells && (this.anchorX !== We || this.anchorY !== rt || he))
          this.isHighlightingCells = !0, this.disableHighlightStyle();
        else if (We === this.focusX && rt === this.focusY)
          return;
        if (this.focusX = We, this.focusY = rt, this.isHighlightingCells) {
          const lt = n.$getNearestNodeFromDOMNode(ue.elem);
          if (this.tableSelection != null && this.anchorCellNodeKey != null && f(lt)) {
            const tt = lt.getKey();
            this.tableSelection = this.tableSelection.clone() || se(), this.focusCellNodeKey = tt, this.tableSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey), n.$setSelection(this.tableSelection), Se.dispatchCommand(n.SELECTION_CHANGE_COMMAND, void 0), J(Se, this.table, this.tableSelection);
          }
        }
      });
    }
    setAnchorCellForSelection(ue) {
      this.isHighlightingCells = !1, this.anchorCell = ue, this.anchorX = ue.x, this.anchorY = ue.y, this.editor.update(() => {
        const he = n.$getNearestNodeFromDOMNode(ue.elem);
        if (f(he)) {
          const Se = he.getKey();
          this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : se(), this.anchorCellNodeKey = Se;
        }
      });
    }
    formatCells(ue) {
      this.editor.update(() => {
        const he = n.$getSelection();
        if (!Y(he))
          throw Error("Expected grid selection");
        const Se = n.$createRangeSelection(), $e = Se.anchor, Re = Se.focus;
        he.getNodes().forEach((We) => {
          f(We) && We.getTextContentSize() !== 0 && ($e.set(We.getKey(), 0, "element"), Re.set(We.getKey(), We.getChildrenSize(), "element"), Se.formatText(ue));
        }), n.$setSelection(he), this.editor.dispatchCommand(n.SELECTION_CHANGE_COMMAND, void 0);
      });
    }
    clearText() {
      const ue = this.editor;
      ue.update(() => {
        const he = n.$getNodeByKey(this.tableNodeKey);
        if (!Ot(he))
          throw new Error("Expected TableNode.");
        const Se = n.$getSelection();
        if (!Y(Se))
          throw Error("Expected grid selection");
        const $e = Se.getNodes().filter(f);
        if ($e.length === this.table.columns * this.table.rows) {
          he.selectPrevious(), he.remove(), n.$getRoot().selectStart();
          return;
        }
        $e.forEach((Re) => {
          if (n.$isElementNode(Re)) {
            const We = n.$createParagraphNode(), rt = n.$createTextNode();
            We.append(rt), Re.append(We), Re.getChildren().forEach((lt) => {
              lt !== We && lt.remove();
            });
          }
        }), J(ue, this.table, null), n.$setSelection(null), ue.dispatchCommand(n.SELECTION_CHANGE_COMMAND, void 0);
      });
    }
  }
  const de = "__lexicalTableSelection";
  function Ne(Te, ue, he, Se) {
    const $e = he.getRootElement();
    if ($e === null)
      throw new Error("No root element.");
    const Re = new ae(he, Te.getKey()), We = he._window || window;
    De(ue, Re), ue.addEventListener("mousedown", (Be) => {
      setTimeout(() => {
        if (Be.button !== 0 || !We)
          return;
        const Ke = Le(Be.target);
        Ke !== null && (dt(Be), Re.setAnchorCellForSelection(Ke));
        const Ye = () => {
          We.removeEventListener("mouseup", Ye), We.removeEventListener("mousemove", ft);
        }, ft = (ct) => {
          const gt = Le(ct.target);
          gt !== null && (Re.anchorX !== gt.x || Re.anchorY !== gt.y) && (ct.preventDefault(), Re.setFocusCellForSelection(gt));
        };
        We.addEventListener("mouseup", Ye), We.addEventListener("mousemove", ft);
      }, 0);
    });
    const rt = (Be) => {
      Be.button === 0 && he.update(() => {
        const Ke = n.$getSelection(), Ye = Be.target;
        Y(Ke) && Ke.tableKey === Re.tableNodeKey && $e.contains(Ye) && Re.clearHighlight();
      });
    };
    We.addEventListener("mousedown", rt), Re.listenersToRemove.add(() => We.removeEventListener("mousedown", rt)), Re.listenersToRemove.add(he.registerCommand(n.KEY_ARROW_DOWN_COMMAND, (Be) => Ge(he, Be, "down", Te, Re), n.COMMAND_PRIORITY_HIGH)), Re.listenersToRemove.add(he.registerCommand(n.KEY_ARROW_UP_COMMAND, (Be) => Ge(he, Be, "up", Te, Re), n.COMMAND_PRIORITY_HIGH)), Re.listenersToRemove.add(he.registerCommand(n.KEY_ARROW_LEFT_COMMAND, (Be) => Ge(he, Be, "backward", Te, Re), n.COMMAND_PRIORITY_HIGH)), Re.listenersToRemove.add(he.registerCommand(n.KEY_ARROW_RIGHT_COMMAND, (Be) => Ge(he, Be, "forward", Te, Re), n.COMMAND_PRIORITY_HIGH)), Re.listenersToRemove.add(he.registerCommand(n.KEY_ESCAPE_COMMAND, (Be) => {
      const Ke = n.$getSelection();
      if (Y(Ke)) {
        const Ye = r.$findMatchingParent(Ke.focus.getNode(), f);
        if (f(Ye))
          return dt(Be), Ye.selectEnd(), !0;
      }
      return !1;
    }, n.COMMAND_PRIORITY_HIGH));
    const lt = (Be) => () => {
      const Ke = n.$getSelection();
      if (!ge(Ke, Te))
        return !1;
      if (Y(Ke))
        return Re.clearText(), !0;
      if (n.$isRangeSelection(Ke)) {
        const Ye = r.$findMatchingParent(Ke.anchor.getNode(), (Dt) => f(Dt));
        if (!f(Ye))
          return !1;
        const ft = Ke.anchor.getNode(), ct = Ke.focus.getNode(), gt = Te.isParentOf(ft), wt = Te.isParentOf(ct);
        if (gt && !wt || wt && !gt)
          return Re.clearText(), !0;
        const It = r.$findMatchingParent(Ke.anchor.getNode(), (Dt) => n.$isElementNode(Dt)), on = It && r.$findMatchingParent(It, (Dt) => n.$isElementNode(Dt) && f(Dt.getParent()));
        if (!n.$isElementNode(on) || !n.$isElementNode(It))
          return !1;
        if (Be === n.DELETE_LINE_COMMAND && on.getPreviousSibling() === null)
          return !0;
        if ((Be === n.DELETE_CHARACTER_COMMAND || Be === n.DELETE_WORD_COMMAND) && Ke.isCollapsed() && Ke.anchor.offset === 0 && It !== on) {
          const Dt = It.getChildren(), en = n.$createParagraphNode();
          return Dt.forEach((jt) => en.append(jt)), It.replace(en), It.getWritable().__parent = Ye.getKey(), !0;
        }
      }
      return !1;
    };
    [n.DELETE_WORD_COMMAND, n.DELETE_LINE_COMMAND, n.DELETE_CHARACTER_COMMAND].forEach((Be) => {
      Re.listenersToRemove.add(he.registerCommand(Be, lt(Be), n.COMMAND_PRIORITY_CRITICAL));
    });
    const tt = (Be) => {
      const Ke = n.$getSelection();
      if (!ge(Ke, Te))
        return !1;
      if (Y(Ke))
        return Be.preventDefault(), Be.stopPropagation(), Re.clearText(), !0;
      if (n.$isRangeSelection(Ke)) {
        const Ye = r.$findMatchingParent(Ke.anchor.getNode(), (ft) => f(ft));
        if (!f(Ye))
          return !1;
      }
      return !1;
    };
    Re.listenersToRemove.add(he.registerCommand(n.KEY_BACKSPACE_COMMAND, tt, n.COMMAND_PRIORITY_CRITICAL)), Re.listenersToRemove.add(he.registerCommand(n.KEY_DELETE_COMMAND, tt, n.COMMAND_PRIORITY_CRITICAL)), Re.listenersToRemove.add(he.registerCommand(n.FORMAT_TEXT_COMMAND, (Be) => {
      const Ke = n.$getSelection();
      if (!ge(Ke, Te))
        return !1;
      if (Y(Ke))
        return Re.formatCells(Be), !0;
      if (n.$isRangeSelection(Ke)) {
        const Ye = r.$findMatchingParent(Ke.anchor.getNode(), (ft) => f(ft));
        if (!f(Ye))
          return !1;
      }
      return !1;
    }, n.COMMAND_PRIORITY_CRITICAL)), Re.listenersToRemove.add(he.registerCommand(n.CONTROLLED_TEXT_INSERTION_COMMAND, (Be) => {
      const Ke = n.$getSelection();
      if (!ge(Ke, Te))
        return !1;
      if (Y(Ke))
        return Re.clearHighlight(), !1;
      if (n.$isRangeSelection(Ke)) {
        const Ye = r.$findMatchingParent(Ke.anchor.getNode(), (ft) => f(ft));
        if (!f(Ye))
          return !1;
      }
      return !1;
    }, n.COMMAND_PRIORITY_CRITICAL)), Se && Re.listenersToRemove.add(he.registerCommand(n.KEY_TAB_COMMAND, (Be) => {
      const Ke = n.$getSelection();
      if (!n.$isRangeSelection(Ke) || !Ke.isCollapsed() || !ge(Ke, Te))
        return !1;
      const Ye = be(Ke.anchor.getNode());
      if (Ye === null)
        return !1;
      dt(Be);
      const ft = Te.getCordsFromCellNode(Ye, Re.table);
      return le(Re, Te, ft.x, ft.y, Be.shiftKey ? "backward" : "forward"), !0;
    }, n.COMMAND_PRIORITY_CRITICAL)), Re.listenersToRemove.add(he.registerCommand(n.FOCUS_COMMAND, (Be) => Te.isSelected(), n.COMMAND_PRIORITY_HIGH));
    function Nt(Be) {
      const Ke = Te.getCordsFromCellNode(Be, Re.table);
      return Te.getDOMCellFromCordsOrThrow(Ke.x, Ke.y, Re.table);
    }
    return Re.listenersToRemove.add(he.registerCommand(n.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, (Be) => {
      const {
        nodes: Ke,
        selection: Ye
      } = Be, ft = Ye.getStartEndPoints(), ct = Y(Ye), wt = n.$isRangeSelection(Ye) && r.$findMatchingParent(Ye.anchor.getNode(), (fn) => f(fn)) !== null && r.$findMatchingParent(Ye.focus.getNode(), (fn) => f(fn)) !== null || ct;
      if (Ke.length !== 1 || !Ot(Ke[0]) || !wt || ft === null)
        return !1;
      const [Mt] = ft, It = Ke[0], on = It.getChildren(), Dt = It.getFirstChildOrThrow().getChildrenSize(), en = It.getChildrenSize(), jt = r.$findMatchingParent(Mt.getNode(), (fn) => f(fn)), qt = jt && r.$findMatchingParent(jt, (fn) => y(fn)), _e = qt && r.$findMatchingParent(qt, (fn) => Ot(fn));
      if (!f(jt) || !y(qt) || !Ot(_e))
        return !1;
      const Ue = qt.getIndexWithinParent(), at = Math.min(_e.getChildrenSize() - 1, Ue + en - 1), Rt = jt.getIndexWithinParent(), Xt = Math.min(qt.getChildrenSize() - 1, Rt + Dt - 1), Zt = Math.min(Rt, Xt), Wt = Math.min(Ue, at), Ht = Math.max(Rt, Xt), yn = Math.max(Ue, at), cn = _e.getChildren();
      let un = 0, On, Qn;
      for (let fn = Wt; fn <= yn; fn++) {
        const Fn = cn[fn];
        if (!y(Fn))
          return !1;
        const jo = on[un];
        if (!y(jo))
          return !1;
        const yr = Fn.getChildren(), fi = jo.getChildren();
        let Wr = 0;
        for (let Lr = Zt; Lr <= Ht; Lr++) {
          const Sr = yr[Lr];
          if (!f(Sr))
            return !1;
          const Ho = fi[Wr];
          if (!f(Ho))
            return !1;
          fn === Wt && Lr === Zt ? On = Sr.getKey() : fn === yn && Lr === Ht && (Qn = Sr.getKey());
          const pr = Sr.getChildren();
          Ho.getChildren().forEach((Or) => {
            n.$isTextNode(Or) && n.$createParagraphNode().append(Or), Sr.append(Or);
          }), pr.forEach((Or) => Or.remove()), Wr++;
        }
        un++;
      }
      if (On && Qn) {
        const fn = se();
        fn.set(Ke[0].getKey(), On, Qn), n.$setSelection(fn);
      }
      return !0;
    }, n.COMMAND_PRIORITY_CRITICAL)), Re.listenersToRemove.add(he.registerCommand(n.SELECTION_CHANGE_COMMAND, () => {
      const Be = n.$getSelection(), Ke = n.$getPreviousSelection();
      if (n.$isRangeSelection(Be)) {
        const {
          anchor: Ye,
          focus: ft
        } = Be, ct = Ye.getNode(), gt = ft.getNode(), wt = be(ct), Mt = be(gt), It = wt && Te.is(He(wt)), on = Mt && Te.is(He(Mt)), Dt = It !== on, en = It && on, jt = Be.isBackward();
        if (Dt) {
          const qt = Be.clone();
          qt.focus.set(Te.getKey(), jt ? 0 : Te.getChildrenSize(), "element"), n.$setSelection(qt), H(he, Re);
        } else
          en && (wt.is(Mt) || (Re.setAnchorCellForSelection(Nt(wt)), Re.setFocusCellForSelection(Nt(Mt), !0)));
      }
      return Be && !Be.is(Ke) && (Y(Be) || Y(Ke)) && Re.tableSelection && !Re.tableSelection.is(Ke) ? (Y(Be) && Be.tableKey === Re.tableNodeKey ? Re.updateTableTableSelection(Be) : !Y(Be) && Y(Ke) && Ke.tableKey === Re.tableNodeKey && Re.updateTableTableSelection(null), !1) : (Re.hasHijackedSelectionStyles && !Te.isSelected() ? re(he, Re) : !Re.hasHijackedSelectionStyles && Te.isSelected() && H(he, Re), !1);
    }, n.COMMAND_PRIORITY_CRITICAL)), Re;
  }
  function De(Te, ue) {
    Te[de] = ue;
  }
  function Pe(Te) {
    return Te[de];
  }
  function Le(Te) {
    let ue = Te;
    for (; ue != null; ) {
      const he = ue.nodeName;
      if (he === "TD" || he === "TH") {
        const Se = ue._cell;
        return Se === void 0 ? null : Se;
      }
      ue = ue.parentNode;
    }
    return null;
  }
  function ke(Te) {
    const ue = [], he = {
      columns: 0,
      domRows: ue,
      rows: 0
    };
    let Se = Te.firstChild, $e = 0, Re = 0;
    for (ue.length = 0; Se != null; ) {
      const We = Se.nodeName;
      if (We === "TD" || We === "TH") {
        const tt = Se, Nt = {
          elem: tt,
          hasBackgroundColor: tt.style.backgroundColor !== "",
          highlighted: !1,
          x: $e,
          y: Re
        };
        Se._cell = Nt;
        let Be = ue[Re];
        Be === void 0 && (Be = ue[Re] = []), Be[$e] = Nt;
      } else {
        const tt = Se.firstChild;
        if (tt != null) {
          Se = tt;
          continue;
        }
      }
      const rt = Se.nextSibling;
      if (rt != null) {
        $e++, Se = rt;
        continue;
      }
      const lt = Se.parentNode;
      if (lt != null) {
        const tt = lt.nextSibling;
        if (tt == null)
          break;
        Re++, $e = 0, Se = tt;
      }
    }
    return he.columns = $e + 1, he.rows = Re + 1, he;
  }
  function J(Te, ue, he) {
    const Se = new Set(he ? he.getNodes() : []);
    G(ue, ($e, Re) => {
      const We = $e.elem;
      Se.has(Re) ? ($e.highlighted = !0, je(Te, $e)) : ($e.highlighted = !1, Oe(Te, $e), We.getAttribute("style") || We.removeAttribute("style"));
    });
  }
  function G(Te, ue) {
    const {
      domRows: he
    } = Te;
    for (let Se = 0; Se < he.length; Se++) {
      const $e = he[Se];
      if ($e)
        for (let Re = 0; Re < $e.length; Re++) {
          const We = $e[Re];
          if (!We)
            continue;
          const rt = n.$getNearestNodeFromDOMNode(We.elem);
          rt !== null && ue(We, rt, {
            x: Re,
            y: Se
          });
        }
    }
  }
  function H(Te, ue) {
    ue.disableHighlightStyle(), G(ue.table, (he) => {
      he.highlighted = !0, je(Te, he);
    });
  }
  function re(Te, ue) {
    ue.enableHighlightStyle(), G(ue.table, (he) => {
      const Se = he.elem;
      he.highlighted = !1, Oe(Te, he), Se.getAttribute("style") || Se.removeAttribute("style");
    });
  }
  const le = (Te, ue, he, Se, $e) => {
    const Re = $e === "forward";
    switch ($e) {
      case "backward":
      case "forward":
        return he !== (Re ? Te.table.columns - 1 : 0) ? Me(ue.getCellNodeFromCordsOrThrow(he + (Re ? 1 : -1), Se, Te.table), Re) : Se !== (Re ? Te.table.rows - 1 : 0) ? Me(ue.getCellNodeFromCordsOrThrow(Re ? 0 : Te.table.columns - 1, Se + (Re ? 1 : -1), Te.table), Re) : Re ? ue.selectNext() : ue.selectPrevious(), !0;
      case "up":
        return Se !== 0 ? Me(ue.getCellNodeFromCordsOrThrow(he, Se - 1, Te.table), !1) : ue.selectPrevious(), !0;
      case "down":
        return Se !== Te.table.rows - 1 ? Me(ue.getCellNodeFromCordsOrThrow(he, Se + 1, Te.table), !0) : ue.selectNext(), !0;
      default:
        return !1;
    }
  }, me = (Te, ue, he, Se, $e) => {
    const Re = $e === "forward";
    switch ($e) {
      case "backward":
      case "forward":
        return he !== (Re ? Te.table.columns - 1 : 0) && Te.setFocusCellForSelection(ue.getDOMCellFromCordsOrThrow(he + (Re ? 1 : -1), Se, Te.table)), !0;
      case "up":
        return Se !== 0 ? (Te.setFocusCellForSelection(ue.getDOMCellFromCordsOrThrow(he, Se - 1, Te.table)), !0) : !1;
      case "down":
        return Se !== Te.table.rows - 1 ? (Te.setFocusCellForSelection(ue.getDOMCellFromCordsOrThrow(he, Se + 1, Te.table)), !0) : !1;
      default:
        return !1;
    }
  };
  function ge(Te, ue) {
    if (n.$isRangeSelection(Te) || Y(Te)) {
      const he = ue.isParentOf(Te.anchor.getNode()), Se = ue.isParentOf(Te.focus.getNode());
      return he && Se;
    }
    return !1;
  }
  function Me(Te, ue) {
    ue ? Te.selectStart() : Te.selectEnd();
  }
  const Ie = "172,206,247";
  function je(Te, ue) {
    const he = ue.elem, Se = n.$getNearestNodeFromDOMNode(he);
    if (!f(Se))
      throw Error("Expected to find LexicalNode from Table Cell DOMNode");
    Se.getBackgroundColor() === null ? he.style.setProperty("background-color", `rgb(${Ie})`) : he.style.setProperty("background-image", `linear-gradient(to right, rgba(${Ie},0.85), rgba(${Ie},0.85))`), he.style.setProperty("caret-color", "transparent");
  }
  function Oe(Te, ue) {
    const he = ue.elem, Se = n.$getNearestNodeFromDOMNode(he);
    if (!f(Se))
      throw Error("Expected to find LexicalNode from Table Cell DOMNode");
    Se.getBackgroundColor() === null && he.style.removeProperty("background-color"), he.style.removeProperty("background-image"), he.style.removeProperty("caret-color");
  }
  function be(Te) {
    const ue = r.$findMatchingParent(Te, f);
    return f(ue) ? ue : null;
  }
  function He(Te) {
    const ue = r.$findMatchingParent(Te, Ot);
    return Ot(ue) ? ue : null;
  }
  function Ge(Te, ue, he, Se, $e) {
    const Re = n.$getSelection();
    if (!ge(Re, Se))
      return !1;
    if (n.$isRangeSelection(Re) && Re.isCollapsed()) {
      if (he === "backward" || he === "forward")
        return !1;
      const {
        anchor: We,
        focus: rt
      } = Re, lt = r.$findMatchingParent(We.getNode(), f), tt = r.$findMatchingParent(rt.getNode(), f);
      if (!f(lt) || !lt.is(tt))
        return !1;
      const Nt = He(lt);
      if (Nt !== Se && Nt != null) {
        const Mt = Te.getElementByKey(Nt.getKey());
        if (Mt != null)
          return $e.table = ke(Mt), Ge(Te, ue, he, Nt, $e);
      }
      const Be = Te.getElementByKey(lt.__key), Ke = Te.getElementByKey(We.key);
      if (Ke == null || Be == null)
        return !1;
      let Ye;
      if (We.type === "element")
        Ye = Ke.getBoundingClientRect();
      else {
        const Mt = window.getSelection();
        if (Mt === null || Mt.rangeCount === 0)
          return !1;
        Ye = Mt.getRangeAt(0).getBoundingClientRect();
      }
      const ft = he === "up" ? lt.getFirstChild() : lt.getLastChild();
      if (ft == null)
        return !1;
      const ct = Te.getElementByKey(ft.__key);
      if (ct == null)
        return !1;
      const gt = ct.getBoundingClientRect();
      if (he === "up" ? gt.top > Ye.top - Ye.height : Ye.bottom + Ye.height > gt.bottom) {
        dt(ue);
        const Mt = Se.getCordsFromCellNode(lt, $e.table);
        if (ue.shiftKey) {
          const It = Se.getDOMCellFromCordsOrThrow(Mt.x, Mt.y, $e.table);
          $e.setAnchorCellForSelection(It), $e.setFocusCellForSelection(It, !0);
        } else
          return le($e, Se, Mt.x, Mt.y, he);
        return !0;
      }
    } else if (Y(Re)) {
      const {
        anchor: We,
        focus: rt
      } = Re, lt = r.$findMatchingParent(We.getNode(), f), tt = r.$findMatchingParent(rt.getNode(), f), [Nt] = Re.getNodes(), Be = Te.getElementByKey(Nt.getKey());
      if (!f(lt) || !f(tt) || !Ot(Nt) || Be == null)
        return !1;
      $e.updateTableTableSelection(Re);
      const Ke = ke(Be), Ye = Se.getCordsFromCellNode(lt, Ke), ft = Se.getDOMCellFromCordsOrThrow(Ye.x, Ye.y, Ke);
      if ($e.setAnchorCellForSelection(ft), dt(ue), ue.shiftKey) {
        const ct = Se.getCordsFromCellNode(tt, Ke);
        return me($e, Nt, ct.x, ct.y, he);
      } else
        tt.selectEnd();
      return !0;
    }
    return !1;
  }
  function dt(Te) {
    Te.preventDefault(), Te.stopImmediatePropagation(), Te.stopPropagation();
  }
  class nt extends n.ElementNode {
    static getType() {
      return "table";
    }
    static clone(ue) {
      return new nt(ue.__key);
    }
    static importDOM() {
      return {
        table: (ue) => ({
          conversion: an,
          priority: 1
        })
      };
    }
    static importJSON(ue) {
      return Gt();
    }
    constructor(ue) {
      super(ue);
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "table",
        version: 1
      };
    }
    createDOM(ue, he) {
      const Se = document.createElement("table");
      return r.addClassNamesToElement(Se, ue.theme.table), Se;
    }
    updateDOM() {
      return !1;
    }
    exportDOM(ue) {
      return {
        ...super.exportDOM(ue),
        after: (he) => {
          if (he) {
            const Se = he.cloneNode(), $e = document.createElement("colgroup"), Re = document.createElement("tbody");
            r.isHTMLElement(he) && Re.append(...he.children);
            const We = this.getFirstChildOrThrow();
            if (!y(We))
              throw new Error("Expected to find row node.");
            const rt = We.getChildrenSize();
            for (let lt = 0; lt < rt; lt++) {
              const tt = document.createElement("col");
              $e.append(tt);
            }
            return Se.replaceChildren($e, Re), Se;
          }
        }
      };
    }
    // TODO 0.10 deprecate
    canExtractContents() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isShadowRoot() {
      return !0;
    }
    getCordsFromCellNode(ue, he) {
      const {
        rows: Se,
        domRows: $e
      } = he;
      for (let Re = 0; Re < Se; Re++) {
        const We = $e[Re];
        if (We == null)
          continue;
        const rt = We.findIndex((lt) => {
          if (!lt)
            return;
          const {
            elem: tt
          } = lt;
          return n.$getNearestNodeFromDOMNode(tt) === ue;
        });
        if (rt !== -1)
          return {
            x: rt,
            y: Re
          };
      }
      throw new Error("Cell not found in table.");
    }
    getDOMCellFromCords(ue, he, Se) {
      const {
        domRows: $e
      } = Se, Re = $e[he];
      if (Re == null)
        return null;
      const We = Re[ue];
      return We ?? null;
    }
    getDOMCellFromCordsOrThrow(ue, he, Se) {
      const $e = this.getDOMCellFromCords(ue, he, Se);
      if (!$e)
        throw new Error("Cell not found at cords.");
      return $e;
    }
    getCellNodeFromCords(ue, he, Se) {
      const $e = this.getDOMCellFromCords(ue, he, Se);
      if ($e == null)
        return null;
      const Re = n.$getNearestNodeFromDOMNode($e.elem);
      return f(Re) ? Re : null;
    }
    getCellNodeFromCordsOrThrow(ue, he, Se) {
      const $e = this.getCellNodeFromCords(ue, he, Se);
      if (!$e)
        throw new Error("Node at cords not TableCellNode.");
      return $e;
    }
    canSelectBefore() {
      return !0;
    }
    canIndent() {
      return !1;
    }
  }
  function At(Te, ue) {
    const he = Te.getElementByKey(ue.getKey());
    if (he == null)
      throw new Error("Table Element Not Found");
    return ke(he);
  }
  function an(Te) {
    return {
      node: Gt()
    };
  }
  function Gt() {
    return n.$applyNodeReplacement(new nt());
  }
  function Ot(Te) {
    return Te instanceof nt;
  }
  return tn.$computeTableMap = A, tn.$createTableCellNode = m, tn.$createTableNode = Gt, tn.$createTableNodeWithDimensions = _, tn.$createTableRowNode = R, tn.$createTableSelection = se, tn.$deleteTableColumn = F, tn.$deleteTableColumn__EXPERIMENTAL = oe, tn.$deleteTableRow__EXPERIMENTAL = Z, tn.$getElementForTableNode = At, tn.$getNodeTriplet = z, tn.$getTableCellNodeFromLexicalNode = N, tn.$getTableCellNodeRect = ie, tn.$getTableColumnIndexFromTableCellNode = C, tn.$getTableNodeFromLexicalNodeOrThrow = T, tn.$getTableRowIndexFromTableCellNode = D, tn.$getTableRowNodeFromTableCellNodeOrThrow = w, tn.$insertTableColumn = L, tn.$insertTableColumn__EXPERIMENTAL = P, tn.$insertTableRow = W, tn.$insertTableRow__EXPERIMENTAL = B, tn.$isTableCellNode = f, tn.$isTableNode = Ot, tn.$isTableRowNode = y, tn.$isTableSelection = Y, tn.$removeTableRowAtIndex = I, tn.$unmergeCell = K, tn.INSERT_TABLE_COMMAND = O, tn.TableCellHeaderStates = o, tn.TableCellNode = u, tn.TableNode = nt, tn.TableObserver = ae, tn.TableRowNode = S, tn.applyTableHandlers = Ne, tn.getDOMCellFromTarget = Le, tn.getTableObserverFromTableElement = Pe, tn;
}
var nn = {}, lf;
function dm() {
  if (lf)
    return nn;
  lf = 1;
  var r = kt(), n = St();
  let t = /^(\d+(?:\.\d+)?)px$/, o = { BOTH: 3, COLUMN: 2, NO_STATUS: 0, ROW: 1 };
  class u extends n.ElementNode {
    static getType() {
      return "tablecell";
    }
    static clone(G) {
      let H = new u(G.__headerState, G.__colSpan, G.__width, G.__key);
      return H.__rowSpan = G.__rowSpan, H.__backgroundColor = G.__backgroundColor, H;
    }
    static importDOM() {
      return { td: () => ({ conversion: p, priority: 0 }), th: () => ({ conversion: p, priority: 0 }) };
    }
    static importJSON(G) {
      let H = G.rowSpan || 1, re = m(G.headerState, G.colSpan || 1, G.width || void 0);
      return re.__rowSpan = H, re.__backgroundColor = G.backgroundColor || null, re;
    }
    constructor(G = o.NO_STATUS, H = 1, re, le) {
      super(le), this.__colSpan = H, this.__rowSpan = 1, this.__headerState = G, this.__width = re, this.__backgroundColor = null;
    }
    createDOM(G) {
      let H = document.createElement(this.getTag());
      return this.__width && (H.style.width = `${this.__width}px`), 1 < this.__colSpan && (H.colSpan = this.__colSpan), 1 < this.__rowSpan && (H.rowSpan = this.__rowSpan), this.__backgroundColor !== null && (H.style.backgroundColor = this.__backgroundColor), r.addClassNamesToElement(H, G.theme.tableCell, this.hasHeader() && G.theme.tableCellHeader), H;
    }
    exportDOM(G) {
      if ({ element: G } = super.exportDOM(G), G) {
        var H = this.getParentOrThrow().getChildrenSize();
        G.style.border = "1px solid black", 1 < this.__colSpan && (G.colSpan = this.__colSpan), 1 < this.__rowSpan && (G.rowSpan = this.__rowSpan), G.style.width = `${this.getWidth() || Math.max(90, 700 / H)}px`, G.style.verticalAlign = "top", G.style.textAlign = "start", H = this.getBackgroundColor(), H !== null ? G.style.backgroundColor = H : this.hasHeader() && (G.style.backgroundColor = "#f2f3f5");
      }
      return { element: G };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        backgroundColor: this.getBackgroundColor(),
        colSpan: this.__colSpan,
        headerState: this.__headerState,
        rowSpan: this.__rowSpan,
        type: "tablecell",
        width: this.getWidth()
      };
    }
    getColSpan() {
      return this.__colSpan;
    }
    setColSpan(G) {
      return this.getWritable().__colSpan = G, this;
    }
    getRowSpan() {
      return this.__rowSpan;
    }
    setRowSpan(G) {
      return this.getWritable().__rowSpan = G, this;
    }
    getTag() {
      return this.hasHeader() ? "th" : "td";
    }
    setHeaderStyles(G) {
      return this.getWritable().__headerState = G, this.__headerState;
    }
    getHeaderStyles() {
      return this.getLatest().__headerState;
    }
    setWidth(G) {
      return this.getWritable().__width = G, this.__width;
    }
    getWidth() {
      return this.getLatest().__width;
    }
    getBackgroundColor() {
      return this.getLatest().__backgroundColor;
    }
    setBackgroundColor(G) {
      this.getWritable().__backgroundColor = G;
    }
    toggleHeaderStyle(G) {
      let H = this.getWritable();
      return H.__headerState = (H.__headerState & G) === G ? H.__headerState - G : H.__headerState + G, H;
    }
    hasHeaderState(G) {
      return (this.getHeaderStyles() & G) === G;
    }
    hasHeader() {
      return this.getLatest().__headerState !== o.NO_STATUS;
    }
    updateDOM(G) {
      return G.__headerState !== this.__headerState || G.__width !== this.__width || G.__colSpan !== this.__colSpan || G.__rowSpan !== this.__rowSpan || G.__backgroundColor !== this.__backgroundColor;
    }
    isShadowRoot() {
      return !0;
    }
    collapseAtStart() {
      return !0;
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
  }
  function p(J) {
    var G = J.nodeName.toLowerCase();
    let H;
    return t.test(J.style.width) && (H = parseFloat(J.style.width)), G = m(G === "th" ? o.ROW : o.NO_STATUS, J.colSpan, H), G.__rowSpan = J.rowSpan, J = J.style.backgroundColor, J !== "" && (G.__backgroundColor = J), { forChild: (re, le) => f(le) && !n.$isElementNode(re) ? (le = n.$createParagraphNode(), n.$isLineBreakNode(re) && re.getTextContent() === `
` ? null : (le.append(re), le)) : re, node: G };
  }
  function m(J, G = 1, H) {
    return n.$applyNodeReplacement(new u(J, G, H));
  }
  function f(J) {
    return J instanceof u;
  }
  let O = n.createCommand("INSERT_TABLE_COMMAND");
  class S extends n.ElementNode {
    static getType() {
      return "tablerow";
    }
    static clone(G) {
      return new S(G.__height, G.__key);
    }
    static importDOM() {
      return { tr: () => ({ conversion: E, priority: 0 }) };
    }
    static importJSON(G) {
      return R(G.height);
    }
    constructor(G, H) {
      super(H), this.__height = G;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "tablerow", version: 1 };
    }
    createDOM(G) {
      let H = document.createElement("tr");
      return this.__height && (H.style.height = `${this.__height}px`), r.addClassNamesToElement(H, G.theme.tableRow), H;
    }
    isShadowRoot() {
      return !0;
    }
    setHeight(G) {
      return this.getWritable().__height = G, this.__height;
    }
    getHeight() {
      return this.getLatest().__height;
    }
    updateDOM(G) {
      return G.__height !== this.__height;
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
  }
  function E(J) {
    let G;
    return t.test(J.style.height) && (G = parseFloat(J.style.height)), { node: R(G) };
  }
  function R(J) {
    return n.$applyNodeReplacement(new S(J));
  }
  function y(J) {
    return J instanceof S;
  }
  function g(J) {
    let G = new URLSearchParams();
    G.append("code", J);
    for (let H = 1; H < arguments.length; H++)
      G.append("v", arguments[H]);
    throw Error(`Minified Lexical error #${J}; visit https://lexical.dev/docs/error?${G} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  let _ = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  function N(J) {
    if (J = r.$findMatchingParent(J, (G) => y(G)), y(J))
      return J;
    throw Error("Expected table cell to be inside of table row.");
  }
  function w(J) {
    if (J = r.$findMatchingParent(J, (G) => ke(G)), ke(J))
      return J;
    throw Error("Expected table cell to be inside of table.");
  }
  function T(J, G) {
    let H = w(J), { x: re, y: le } = H.getCordsFromCellNode(J, G);
    return { above: H.getCellNodeFromCords(re, le - 1, G), below: H.getCellNodeFromCords(re, le + 1, G), left: H.getCellNodeFromCords(re - 1, le, G), right: H.getCellNodeFromCords(re + 1, le, G) };
  }
  let D = (J, G) => J === o.BOTH || J === G ? G : o.NO_STATUS;
  function C(J) {
    let G = J.getFirstDescendant();
    G == null ? J.selectStart() : G.getParentOrThrow().selectStart();
  }
  function x(J, G) {
    let H = J.getFirstChild();
    H !== null ? H.insertBefore(G) : J.append(G);
  }
  function I(J, G, H) {
    let re = [], le = null, me = null;
    J = J.getChildren();
    for (let Oe = 0; Oe < J.length; Oe++) {
      var ge = J[Oe];
      y(ge) || g(146);
      var Me = ge.getChildren();
      ge = 0;
      for (let be of Me) {
        for (f(be) || g(147); re[Oe] !== void 0 && re[Oe][ge] !== void 0; )
          ge++;
        Me = Oe;
        var Ie = ge, je = be;
        let He = { cell: je, startColumn: Ie, startRow: Me }, Ge = je.__rowSpan, dt = je.__colSpan;
        for (let nt = 0; nt < Ge; nt++) {
          re[Me + nt] === void 0 && (re[Me + nt] = []);
          for (let At = 0; At < dt; At++)
            re[Me + nt][Ie + At] = He;
        }
        G.is(je) && (le = He), H.is(je) && (me = He), ge += be.__colSpan;
      }
    }
    return le === null && g(110), me === null && g(111), [re, le, me];
  }
  function W(J) {
    J instanceof u || ("__type" in J ? (J = r.$findMatchingParent(J, f), f(J) || g(148)) : (J = r.$findMatchingParent(J.getNode(), f), f(J) || g(148)));
    let G = J.getParent();
    y(G) || g(149);
    let H = G.getParent();
    return ke(H) || g(150), [J, G, H];
  }
  function $(J) {
    let [G, , H] = W(J);
    J = H.getChildren();
    let re = J.length;
    var le = J[0].getChildren().length;
    let me = Array(re);
    for (var ge = 0; ge < re; ge++)
      me[ge] = Array(le);
    for (le = 0; le < re; le++) {
      ge = J[le].getChildren();
      let Me = 0;
      for (let Ie = 0; Ie < ge.length; Ie++) {
        for (; me[le][Me]; )
          Me++;
        let je = ge[Ie], Oe = je.__rowSpan || 1, be = je.__colSpan || 1;
        for (let He = 0; He < Oe; He++)
          for (let Ge = 0; Ge < be; Ge++)
            me[le + He][Me + Ge] = je;
        if (G === je)
          return { colSpan: be, columnIndex: Me, rowIndex: le, rowSpan: Oe };
        Me += be;
      }
    }
    return null;
  }
  class B {
    constructor(G, H, re) {
      this.anchor = H, this.focus = re, H._selection = this, re._selection = this, this._cachedNodes = null, this.dirty = !1, this.tableKey = G;
    }
    getStartEndPoints() {
      return [this.anchor, this.focus];
    }
    isBackward() {
      return this.focus.isBefore(this.anchor);
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(G) {
      this._cachedNodes = G;
    }
    is(G) {
      return L(G) ? this.tableKey === G.tableKey && this.anchor.is(G.anchor) && this.focus.is(G.focus) : !1;
    }
    set(G, H, re) {
      this.dirty = !0, this.tableKey = G, this.anchor.key = H, this.focus.key = re, this._cachedNodes = null;
    }
    clone() {
      return new B(this.tableKey, this.anchor, this.focus);
    }
    isCollapsed() {
      return !1;
    }
    extract() {
      return this.getNodes();
    }
    insertRawText() {
    }
    insertText() {
    }
    insertNodes(G) {
      let H = this.focus.getNode();
      n.$isElementNode(H) || g(151), n.$normalizeSelection__EXPERIMENTAL(H.select(0, H.getChildrenSize())).insertNodes(G);
    }
    getShape() {
      var G = n.$getNodeByKey(this.anchor.key);
      f(G) || g(152), G = $(G), G === null && g(153);
      var H = n.$getNodeByKey(this.focus.key);
      f(H) || g(154);
      let re = $(H);
      re === null && g(155), H = Math.min(
        G.columnIndex,
        re.columnIndex
      );
      let le = Math.max(G.columnIndex, re.columnIndex), me = Math.min(G.rowIndex, re.rowIndex);
      return G = Math.max(G.rowIndex, re.rowIndex), { fromX: Math.min(H, le), fromY: Math.min(me, G), toX: Math.max(H, le), toY: Math.max(me, G) };
    }
    getNodes() {
      function G(At) {
        let { cell: an, startColumn: Gt, startRow: Ot } = At;
        je = Math.min(je, Gt), Oe = Math.min(Oe, Ot), be = Math.max(be, Gt + an.__colSpan - 1), He = Math.max(He, Ot + an.__rowSpan - 1);
      }
      var H = this._cachedNodes;
      if (H !== null)
        return H;
      var re = this.anchor.getNode();
      H = this.focus.getNode();
      var le = r.$findMatchingParent(re, f);
      re = r.$findMatchingParent(
        H,
        f
      ), f(le) || g(152), f(re) || g(154), H = le.getParent(), y(H) || g(156), H = H.getParent(), ke(H) || g(157);
      var me = re.getParents()[1];
      if (me !== H)
        return H.isParentOf(re) ? (H = me.getParent(), H == null && g(159), this.set(this.tableKey, re.getKey(), H.getKey())) : (H = H.getParent(), H == null && g(158), this.set(this.tableKey, H.getKey(), re.getKey())), this.getNodes();
      let [ge, Me, Ie] = I(H, le, re), je = Math.min(Me.startColumn, Ie.startColumn), Oe = Math.min(Me.startRow, Ie.startRow), be = Math.max(Me.startColumn + Me.cell.__colSpan - 1, Ie.startColumn + Ie.cell.__colSpan - 1), He = Math.max(Me.startRow + Me.cell.__rowSpan - 1, Ie.startRow + Ie.cell.__rowSpan - 1);
      re = je, le = Oe, me = je;
      for (var Ge = Oe; je < re || Oe < le || be > me || He > Ge; ) {
        if (je < re) {
          var dt = Ge - le;
          --re;
          for (var nt = 0; nt <= dt; nt++)
            G(ge[le + nt][re]);
        }
        if (Oe < le)
          for (dt = me - re, --le, nt = 0; nt <= dt; nt++)
            G(ge[le][re + nt]);
        if (be > me)
          for (dt = Ge - le, me += 1, nt = 0; nt <= dt; nt++)
            G(ge[le + nt][me]);
        if (He > Ge)
          for (dt = me - re, Ge += 1, nt = 0; nt <= dt; nt++)
            G(ge[Ge][re + nt]);
      }
      for (H = [H], re = null, le = Oe; le <= He; le++)
        for (me = je; me <= be; me++)
          ({ cell: Ge } = ge[le][me]), dt = Ge.getParent(), y(dt) || g(160), dt !== re && H.push(dt), H.push(Ge, ...F(Ge)), re = dt;
      return n.isCurrentlyReadOnlyMode() || (this._cachedNodes = H), H;
    }
    getTextContent() {
      let G = this.getNodes(), H = "";
      for (let re = 0; re < G.length; re++)
        H += G[re].getTextContent();
      return H;
    }
  }
  function L(J) {
    return J instanceof B;
  }
  function P() {
    let J = n.$createPoint("root", 0, "element"), G = n.$createPoint("root", 0, "element");
    return new B("root", J, G);
  }
  function F(J) {
    let G = [], H = [J];
    for (; 0 < H.length; ) {
      let re = H.pop();
      re === void 0 && g(112), n.$isElementNode(re) && H.unshift(...re.getChildren()), re !== J && G.push(re);
    }
    return G;
  }
  class Z {
    constructor(G, H) {
      this.isHighlightingCells = !1, this.focusY = this.focusX = this.anchorY = this.anchorX = -1, this.listenersToRemove = /* @__PURE__ */ new Set(), this.tableNodeKey = H, this.editor = G, this.table = { columns: 0, domRows: [], rows: 0 }, this.focusCell = this.anchorCell = this.focusCellNodeKey = this.anchorCellNodeKey = this.tableSelection = null, this.hasHijackedSelectionStyles = !1, this.trackTable();
    }
    getTable() {
      return this.table;
    }
    removeListeners() {
      Array.from(this.listenersToRemove).forEach((G) => G());
    }
    trackTable() {
      let G = new MutationObserver((H) => {
        this.editor.update(() => {
          var re = !1;
          for (let le = 0; le < H.length; le++) {
            const me = H[le].target.nodeName;
            if (me === "TABLE" || me === "TR") {
              re = !0;
              break;
            }
          }
          if (re) {
            if (re = this.editor.getElementByKey(this.tableNodeKey), !re)
              throw Error("Expected to find TableElement in DOM");
            this.table = ne(re);
          }
        });
      });
      this.editor.update(() => {
        let H = this.editor.getElementByKey(this.tableNodeKey);
        if (!H)
          throw Error("Expected to find TableElement in DOM");
        this.table = ne(H), G.observe(H, { childList: !0, subtree: !0 });
      });
    }
    clearHighlight() {
      let G = this.editor;
      this.isHighlightingCells = !1, this.focusY = this.focusX = this.anchorY = this.anchorX = -1, this.focusCell = this.anchorCell = this.focusCellNodeKey = this.anchorCellNodeKey = this.tableSelection = null, this.hasHijackedSelectionStyles = !1, this.enableHighlightStyle(), G.update(() => {
        var H = n.$getNodeByKey(this.tableNodeKey);
        if (!ke(H))
          throw Error("Expected TableNode.");
        if (H = G.getElementByKey(this.tableNodeKey), !H)
          throw Error("Expected to find TableElement in DOM");
        H = ne(H), te(G, H, null), n.$setSelection(null), G.dispatchCommand(
          n.SELECTION_CHANGE_COMMAND,
          void 0
        );
      });
    }
    enableHighlightStyle() {
      let G = this.editor;
      G.update(() => {
        let H = G.getElementByKey(this.tableNodeKey);
        if (!H)
          throw Error("Expected to find TableElement in DOM");
        r.removeClassNamesFromElement(H, G._config.theme.tableSelection), H.classList.remove("disable-selection"), this.hasHijackedSelectionStyles = !1;
      });
    }
    disableHighlightStyle() {
      let G = this.editor;
      G.update(() => {
        let H = G.getElementByKey(this.tableNodeKey);
        if (!H)
          throw Error("Expected to find TableElement in DOM");
        r.addClassNamesToElement(H, G._config.theme.tableSelection), this.hasHijackedSelectionStyles = !0;
      });
    }
    updateTableTableSelection(G) {
      if (G !== null && G.tableKey === this.tableNodeKey) {
        let H = this.editor;
        this.tableSelection = G, this.isHighlightingCells = !0, this.disableHighlightStyle(), te(H, this.table, this.tableSelection);
      } else
        G == null ? this.clearHighlight() : (this.tableNodeKey = G.tableKey, this.updateTableTableSelection(G));
    }
    setFocusCellForSelection(G, H = !1) {
      let re = this.editor;
      re.update(() => {
        var le = n.$getNodeByKey(this.tableNodeKey);
        if (!ke(le))
          throw Error("Expected TableNode.");
        if (!re.getElementByKey(this.tableNodeKey))
          throw Error("Expected to find TableElement in DOM");
        le = G.x;
        let me = G.y;
        if (this.focusCell = G, this.anchorCell !== null) {
          let ge = _ ? (re._window || window).getSelection() : null;
          ge && ge.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);
        }
        if (!this.isHighlightingCells && (this.anchorX !== le || this.anchorY !== me || H))
          this.isHighlightingCells = !0, this.disableHighlightStyle();
        else if (le === this.focusX && me === this.focusY)
          return;
        this.focusX = le, this.focusY = me, this.isHighlightingCells && (le = n.$getNearestNodeFromDOMNode(G.elem), this.tableSelection != null && this.anchorCellNodeKey != null && f(le) && (le = le.getKey(), this.tableSelection = this.tableSelection.clone() || P(), this.focusCellNodeKey = le, this.tableSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey), n.$setSelection(this.tableSelection), re.dispatchCommand(n.SELECTION_CHANGE_COMMAND, void 0), te(re, this.table, this.tableSelection)));
      });
    }
    setAnchorCellForSelection(G) {
      this.isHighlightingCells = !1, this.anchorCell = G, this.anchorX = G.x, this.anchorY = G.y, this.editor.update(() => {
        var H = n.$getNearestNodeFromDOMNode(G.elem);
        f(H) && (H = H.getKey(), this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : P(), this.anchorCellNodeKey = H);
      });
    }
    formatCells(G) {
      this.editor.update(() => {
        let H = n.$getSelection();
        L(H) || g(11);
        let re = n.$createRangeSelection(), le = re.anchor, me = re.focus;
        H.getNodes().forEach((ge) => {
          f(ge) && ge.getTextContentSize() !== 0 && (le.set(ge.getKey(), 0, "element"), me.set(ge.getKey(), ge.getChildrenSize(), "element"), re.formatText(G));
        }), n.$setSelection(H), this.editor.dispatchCommand(n.SELECTION_CHANGE_COMMAND, void 0);
      });
    }
    clearText() {
      let G = this.editor;
      G.update(() => {
        let H = n.$getNodeByKey(this.tableNodeKey);
        if (!ke(H))
          throw Error("Expected TableNode.");
        var re = n.$getSelection();
        L(re) || g(11), re = re.getNodes().filter(f), re.length === this.table.columns * this.table.rows ? (H.selectPrevious(), H.remove(), n.$getRoot().selectStart()) : (re.forEach((le) => {
          if (n.$isElementNode(le)) {
            let me = n.$createParagraphNode(), ge = n.$createTextNode();
            me.append(ge), le.append(me), le.getChildren().forEach((Me) => {
              Me !== me && Me.remove();
            });
          }
        }), te(G, this.table, null), n.$setSelection(null), G.dispatchCommand(
          n.SELECTION_CHANGE_COMMAND,
          void 0
        ));
      });
    }
  }
  function oe(J) {
    for (; J != null; ) {
      let G = J.nodeName;
      if (G === "TD" || G === "TH") {
        if (J = J._cell, J === void 0)
          break;
        return J;
      }
      J = J.parentNode;
    }
    return null;
  }
  function ne(J) {
    let G = [], H = { columns: 0, domRows: G, rows: 0 };
    var re = J.firstChild;
    let le = J = 0;
    for (G.length = 0; re != null; ) {
      var me = re.nodeName;
      if (me === "TD" || me === "TH") {
        me = re, me = { elem: me, hasBackgroundColor: me.style.backgroundColor !== "", highlighted: !1, x: J, y: le }, re._cell = me;
        let ge = G[le];
        ge === void 0 && (ge = G[le] = []), ge[J] = me;
      } else if (me = re.firstChild, me != null) {
        re = me;
        continue;
      }
      if (me = re.nextSibling, me != null)
        J++, re = me;
      else if (me = re.parentNode, me != null) {
        if (re = me.nextSibling, re == null)
          break;
        le++, J = 0;
      }
    }
    return H.columns = J + 1, H.rows = le + 1, H;
  }
  function te(J, G, H) {
    let re = new Set(H ? H.getNodes() : []);
    K(G, (le, me) => {
      let ge = le.elem;
      re.has(me) ? (le.highlighted = !0, se(J, le)) : (le.highlighted = !1, j(J, le), ge.getAttribute("style") || ge.removeAttribute("style"));
    });
  }
  function K(J, G) {
    ({ domRows: J } = J);
    for (let H = 0; H < J.length; H++) {
      let re = J[H];
      if (re)
        for (let le = 0; le < re.length; le++) {
          let me = re[le];
          if (!me)
            continue;
          let ge = n.$getNearestNodeFromDOMNode(me.elem);
          ge !== null && G(me, ge, { x: le, y: H });
        }
    }
  }
  function A(J, G) {
    G.disableHighlightStyle(), K(G.table, (H) => {
      H.highlighted = !0, se(J, H);
    });
  }
  function z(J, G) {
    G.enableHighlightStyle(), K(G.table, (H) => {
      let re = H.elem;
      H.highlighted = !1, j(J, H), re.getAttribute("style") || re.removeAttribute("style");
    });
  }
  let ie = (J, G, H, re, le) => {
    const me = le === "forward";
    switch (le) {
      case "backward":
      case "forward":
        return H !== (me ? J.table.columns - 1 : 0) ? (J = G.getCellNodeFromCordsOrThrow(H + (me ? 1 : -1), re, J.table), me ? J.selectStart() : J.selectEnd()) : re !== (me ? J.table.rows - 1 : 0) ? (J = G.getCellNodeFromCordsOrThrow(me ? 0 : J.table.columns - 1, re + (me ? 1 : -1), J.table), me ? J.selectStart() : J.selectEnd()) : me ? G.selectNext() : G.selectPrevious(), !0;
      case "up":
        return re !== 0 ? G.getCellNodeFromCordsOrThrow(H, re - 1, J.table).selectEnd() : G.selectPrevious(), !0;
      case "down":
        return re !== J.table.rows - 1 ? G.getCellNodeFromCordsOrThrow(H, re + 1, J.table).selectStart() : G.selectNext(), !0;
      default:
        return !1;
    }
  }, q = (J, G, H, re, le) => {
    const me = le === "forward";
    switch (le) {
      case "backward":
      case "forward":
        return H !== (me ? J.table.columns - 1 : 0) && J.setFocusCellForSelection(G.getDOMCellFromCordsOrThrow(H + (me ? 1 : -1), re, J.table)), !0;
      case "up":
        return re !== 0 ? (J.setFocusCellForSelection(G.getDOMCellFromCordsOrThrow(H, re - 1, J.table)), !0) : !1;
      case "down":
        return re !== J.table.rows - 1 ? (J.setFocusCellForSelection(G.getDOMCellFromCordsOrThrow(
          H,
          re + 1,
          J.table
        )), !0) : !1;
      default:
        return !1;
    }
  };
  function Y(J, G) {
    if (n.$isRangeSelection(J) || L(J)) {
      let H = G.isParentOf(J.anchor.getNode());
      return J = G.isParentOf(J.focus.getNode()), H && J;
    }
    return !1;
  }
  function se(J, G) {
    J = G.elem, G = n.$getNearestNodeFromDOMNode(J), f(G) || g(131), G.getBackgroundColor() === null ? J.style.setProperty("background-color", "rgb(172,206,247)") : J.style.setProperty("background-image", "linear-gradient(to right, rgba(172,206,247,0.85), rgba(172,206,247,0.85))"), J.style.setProperty("caret-color", "transparent");
  }
  function j(J, G) {
    J = G.elem, G = n.$getNearestNodeFromDOMNode(J), f(G) || g(131), G.getBackgroundColor() === null && J.style.removeProperty("background-color"), J.style.removeProperty("background-image"), J.style.removeProperty("caret-color");
  }
  function Q(J) {
    return J = r.$findMatchingParent(J, f), f(J) ? J : null;
  }
  function ae(J) {
    return J = r.$findMatchingParent(J, ke), ke(J) ? J : null;
  }
  function de(J, G, H, re, le) {
    let me = n.$getSelection();
    if (!Y(me, re))
      return !1;
    if (n.$isRangeSelection(me) && me.isCollapsed()) {
      if (H === "backward" || H === "forward")
        return !1;
      let { anchor: je, focus: Oe } = me;
      var ge = r.$findMatchingParent(je.getNode(), f), Me = r.$findMatchingParent(Oe.getNode(), f);
      if (!f(ge) || !ge.is(Me))
        return !1;
      if (Me = ae(ge), Me !== re && Me != null) {
        var Ie = J.getElementByKey(Me.getKey());
        if (Ie != null)
          return le.table = ne(Ie), de(J, G, H, Me, le);
      }
      if (Me = J.getElementByKey(ge.__key), Ie = J.getElementByKey(je.key), Ie == null || Me == null)
        return !1;
      if (je.type === "element")
        Me = Ie.getBoundingClientRect();
      else {
        if (Me = window.getSelection(), Me === null || Me.rangeCount === 0)
          return !1;
        Me = Me.getRangeAt(0).getBoundingClientRect();
      }
      if (Ie = H === "up" ? ge.getFirstChild() : ge.getLastChild(), Ie == null || (J = J.getElementByKey(Ie.__key), J == null))
        return !1;
      if (J = J.getBoundingClientRect(), H === "up" ? J.top > Me.top - Me.height : Me.bottom + Me.height > J.bottom) {
        if (Ne(G), J = re.getCordsFromCellNode(ge, le.table), G.shiftKey)
          H = re.getDOMCellFromCordsOrThrow(J.x, J.y, le.table), le.setAnchorCellForSelection(H), le.setFocusCellForSelection(
            H,
            !0
          );
        else
          return ie(le, re, J.x, J.y, H);
        return !0;
      }
    } else if (L(me)) {
      let { anchor: je, focus: Oe } = me;
      return Ie = r.$findMatchingParent(je.getNode(), f), Me = r.$findMatchingParent(Oe.getNode(), f), [ge] = me.getNodes(), J = J.getElementByKey(ge.getKey()), !f(Ie) || !f(Me) || !ke(ge) || J == null ? !1 : (le.updateTableTableSelection(me), J = ne(J), Ie = re.getCordsFromCellNode(Ie, J), Ie = re.getDOMCellFromCordsOrThrow(Ie.x, Ie.y, J), le.setAnchorCellForSelection(Ie), Ne(G), G.shiftKey ? (G = re.getCordsFromCellNode(Me, J), q(le, ge, G.x, G.y, H)) : (Me.selectEnd(), !0));
    }
    return !1;
  }
  function Ne(J) {
    J.preventDefault(), J.stopImmediatePropagation(), J.stopPropagation();
  }
  class De extends n.ElementNode {
    static getType() {
      return "table";
    }
    static clone(G) {
      return new De(G.__key);
    }
    static importDOM() {
      return { table: () => ({ conversion: Pe, priority: 1 }) };
    }
    static importJSON() {
      return Le();
    }
    constructor(G) {
      super(G);
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "table", version: 1 };
    }
    createDOM(G) {
      let H = document.createElement("table");
      return r.addClassNamesToElement(H, G.theme.table), H;
    }
    updateDOM() {
      return !1;
    }
    exportDOM(G) {
      return { ...super.exportDOM(G), after: (H) => {
        if (H) {
          let re = H.cloneNode(), le = document.createElement("colgroup"), me = document.createElement("tbody");
          if (r.isHTMLElement(H) && me.append(...H.children), H = this.getFirstChildOrThrow(), !y(H))
            throw Error("Expected to find row node.");
          H = H.getChildrenSize();
          for (let ge = 0; ge < H; ge++) {
            let Me = document.createElement("col");
            le.append(Me);
          }
          return re.replaceChildren(le, me), re;
        }
      } };
    }
    canExtractContents() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isShadowRoot() {
      return !0;
    }
    getCordsFromCellNode(G, H) {
      let { rows: re, domRows: le } = H;
      for (H = 0; H < re; H++) {
        var me = le[H];
        if (me != null && (me = me.findIndex((ge) => {
          if (ge)
            return { elem: ge } = ge, n.$getNearestNodeFromDOMNode(ge) === G;
        }), me !== -1))
          return { x: me, y: H };
      }
      throw Error("Cell not found in table.");
    }
    getDOMCellFromCords(G, H, re) {
      return { domRows: re } = re, H = re[H], H == null ? null : (G = H[G], G ?? null);
    }
    getDOMCellFromCordsOrThrow(G, H, re) {
      if (G = this.getDOMCellFromCords(G, H, re), !G)
        throw Error("Cell not found at cords.");
      return G;
    }
    getCellNodeFromCords(G, H, re) {
      return G = this.getDOMCellFromCords(G, H, re), G == null ? null : (G = n.$getNearestNodeFromDOMNode(G.elem), f(G) ? G : null);
    }
    getCellNodeFromCordsOrThrow(G, H, re) {
      if (G = this.getCellNodeFromCords(
        G,
        H,
        re
      ), !G)
        throw Error("Node at cords not TableCellNode.");
      return G;
    }
    canSelectBefore() {
      return !0;
    }
    canIndent() {
      return !1;
    }
  }
  function Pe() {
    return { node: Le() };
  }
  function Le() {
    return n.$applyNodeReplacement(new De());
  }
  function ke(J) {
    return J instanceof De;
  }
  return nn.$computeTableMap = I, nn.$createTableCellNode = m, nn.$createTableNode = Le, nn.$createTableNodeWithDimensions = function(J, G, H = !0) {
    let re = Le();
    for (let me = 0; me < J; me++) {
      let ge = R();
      for (let Me = 0; Me < G; Me++) {
        var le = o.NO_STATUS;
        typeof H == "object" ? (me === 0 && H.rows && (le |= o.ROW), Me === 0 && H.columns && (le |= o.COLUMN)) : H && (me === 0 && (le |= o.ROW), Me === 0 && (le |= o.COLUMN)), le = m(le);
        let Ie = n.$createParagraphNode();
        Ie.append(n.$createTextNode()), le.append(Ie), ge.append(le);
      }
      re.append(ge);
    }
    return re;
  }, nn.$createTableRowNode = R, nn.$createTableSelection = P, nn.$deleteTableColumn = function(J, G) {
    let H = J.getChildren();
    for (let le = 0; le < H.length; le++) {
      var re = H[le];
      if (y(re)) {
        if (re = re.getChildren(), G >= re.length || 0 > G)
          throw Error("Table column target index out of range");
        re[G].remove();
      }
    }
    return J;
  }, nn.$deleteTableColumn__EXPERIMENTAL = function() {
    var J = n.$getSelection();
    n.$isRangeSelection(J) || L(J) || g(118);
    var G = J.anchor.getNode();
    J = J.focus.getNode();
    let [H, , re] = W(G);
    [G] = W(J);
    let [le, me, ge] = I(re, H, G);
    var { startColumn: Me } = me;
    let { startRow: Ie, startColumn: je } = ge;
    J = Math.min(Me, je), Me = Math.max(Me + H.__colSpan - 1, je + G.__colSpan - 1);
    let Oe = Me - J + 1;
    if (le[0].length === Me - J + 1)
      re.selectPrevious(), re.remove();
    else {
      var be = le.length;
      for (let He = 0; He < be; He++)
        for (let Ge = J; Ge <= Me; Ge++) {
          let { cell: dt, startColumn: nt } = le[He][Ge];
          nt < J ? Ge === J && dt.setColSpan(dt.__colSpan - Math.min(Oe, dt.__colSpan - (J - nt))) : nt + dt.__colSpan - 1 > Me ? Ge === Me && dt.setColSpan(dt.__colSpan - (Me - nt + 1)) : dt.remove();
        }
      J = le[Ie], G = J[je + G.__colSpan], G !== void 0 ? ({ cell: G } = G, C(G)) : ({ cell: G } = J[je - 1], C(G));
    }
  }, nn.$deleteTableRow__EXPERIMENTAL = function() {
    var J = n.$getSelection();
    n.$isRangeSelection(J) || L(J) || g(118);
    var G = J.anchor.getNode();
    J = J.focus.getNode();
    let [H, , re] = W(G);
    [J] = W(J);
    let [le, me, ge] = I(re, H, J);
    ({ startRow: G } = me);
    var { startRow: Me } = ge;
    if (J = Me + J.__rowSpan - 1, le.length === J - G + 1)
      re.remove();
    else {
      Me = le[0].length;
      var Ie = le[J + 1], je = re.getChildAtIndex(J + 1);
      for (let be = J; be >= G; be--) {
        for (var Oe = Me - 1; 0 <= Oe; Oe--) {
          let { cell: He, startRow: Ge, startColumn: dt } = le[be][Oe];
          if (dt === Oe && (be === G && Ge < G && He.setRowSpan(He.__rowSpan - (Ge - G)), Ge >= G && Ge + He.__rowSpan - 1 > J))
            if (He.setRowSpan(He.__rowSpan - (J - Ge + 1)), je === null && g(122), Oe === 0)
              x(je, He);
            else {
              let { cell: nt } = Ie[Oe - 1];
              nt.insertAfter(He);
            }
        }
        Oe = re.getChildAtIndex(be), y(Oe) || g(123, String(be)), Oe.remove();
      }
      Ie !== void 0 ? ({ cell: G } = Ie[0], C(G)) : ({ cell: G } = le[G - 1][0], C(G));
    }
  }, nn.$getElementForTableNode = function(J, G) {
    if (J = J.getElementByKey(G.getKey()), J == null)
      throw Error("Table Element Not Found");
    return ne(J);
  }, nn.$getNodeTriplet = W, nn.$getTableCellNodeFromLexicalNode = function(J) {
    return J = r.$findMatchingParent(J, (G) => f(G)), f(J) ? J : null;
  }, nn.$getTableCellNodeRect = $, nn.$getTableColumnIndexFromTableCellNode = function(J) {
    return N(J).getChildren().findIndex((G) => G.is(J));
  }, nn.$getTableNodeFromLexicalNodeOrThrow = w, nn.$getTableRowIndexFromTableCellNode = function(J) {
    let G = N(J);
    return w(G).getChildren().findIndex((H) => H.is(G));
  }, nn.$getTableRowNodeFromTableCellNodeOrThrow = N, nn.$insertTableColumn = function(J, G, H = !0, re, le) {
    let me = J.getChildren(), ge = [];
    for (let je = 0; je < me.length; je++) {
      let Oe = me[je];
      if (y(Oe))
        for (let be = 0; be < re; be++) {
          var Me = Oe.getChildren();
          if (G >= Me.length || 0 > G)
            throw Error("Table column target index out of range");
          Me = Me[G], f(Me) || g(12);
          let { left: He, right: Ge } = T(Me, le);
          var Ie = o.NO_STATUS;
          (He && He.hasHeaderState(o.ROW) || Ge && Ge.hasHeaderState(o.ROW)) && (Ie |= o.ROW), Ie = m(Ie), Ie.append(n.$createParagraphNode()), ge.push({ newTableCell: Ie, targetCell: Me });
        }
    }
    return ge.forEach(({ newTableCell: je, targetCell: Oe }) => {
      H ? Oe.insertAfter(je) : Oe.insertBefore(je);
    }), J;
  }, nn.$insertTableColumn__EXPERIMENTAL = function(J = !0) {
    function G(be = o.NO_STATUS) {
      return be = m(be).append(n.$createParagraphNode()), je === null && (je = be), be;
    }
    var H = n.$getSelection();
    n.$isRangeSelection(H) || L(H) || g(118);
    var re = H.anchor.getNode();
    H = H.focus.getNode(), [re] = W(re);
    let [le, , me] = W(H), [ge, Me, Ie] = I(me, le, re);
    re = ge.length, H = J ? Math.max(Me.startColumn, Ie.startColumn) : Math.min(Me.startColumn, Ie.startColumn), J = J ? H + le.__colSpan - 1 : H - 1, H = me.getFirstChild(), y(H) || g(120);
    let je = null;
    var Oe = H;
    e:
      for (H = 0; H < re; H++) {
        H !== 0 && (Oe = Oe.getNextSibling(), y(Oe) || g(121));
        let be = ge[H], He = D(be[0 > J ? 0 : J].cell.__headerState, o.ROW);
        if (0 > J) {
          x(Oe, G(He));
          continue;
        }
        let { cell: Ge, startColumn: dt, startRow: nt } = be[J];
        if (dt + Ge.__colSpan - 1 <= J) {
          let At = Ge, an = nt, Gt = J;
          for (; an !== H && 1 < At.__rowSpan; )
            if (Gt -= Ge.__colSpan, 0 <= Gt) {
              let { cell: Ot, startRow: Te } = be[Gt];
              At = Ot, an = Te;
            } else {
              Oe.append(G(He));
              continue e;
            }
          At.insertAfter(G(He));
        } else
          Ge.setColSpan(Ge.__colSpan + 1);
      }
    je !== null && C(je);
  }, nn.$insertTableRow = function(J, G, H = !0, re, le) {
    var me = J.getChildren();
    if (G >= me.length || 0 > G)
      throw Error("Table row target index out of range");
    if (G = me[G], y(G))
      for (me = 0; me < re; me++) {
        let Me = G.getChildren(), Ie = Me.length, je = R();
        for (let Oe = 0; Oe < Ie; Oe++) {
          var ge = Me[Oe];
          f(ge) || g(12);
          let { above: be, below: He } = T(ge, le);
          ge = o.NO_STATUS;
          let Ge = be && be.getWidth() || He && He.getWidth() || void 0;
          (be && be.hasHeaderState(o.COLUMN) || He && He.hasHeaderState(o.COLUMN)) && (ge |= o.COLUMN), ge = m(ge, 1, Ge), ge.append(n.$createParagraphNode()), je.append(ge);
        }
        H ? G.insertAfter(je) : G.insertBefore(je);
      }
    else
      throw Error("Row before insertion index does not exist.");
    return J;
  }, nn.$insertTableRow__EXPERIMENTAL = function(J = !0) {
    var G = n.$getSelection();
    n.$isRangeSelection(G) || L(G) || g(118), G = G.focus.getNode();
    let [H, , re] = W(G), [le, me] = I(re, H, H);
    G = le[0].length;
    var { startRow: ge } = me;
    if (J) {
      J = ge + H.__rowSpan - 1;
      var Me = le[J];
      ge = R();
      for (var Ie = 0; Ie < G; Ie++) {
        let { cell: Oe, startRow: be } = Me[Ie];
        if (be + Oe.__rowSpan - 1 <= J) {
          var je = D(Me[Ie].cell.__headerState, o.COLUMN);
          ge.append(m(je).append(n.$createParagraphNode()));
        } else
          Oe.setRowSpan(Oe.__rowSpan + 1);
      }
      G = re.getChildAtIndex(J), y(G) || g(145), G.insertAfter(ge);
    } else {
      for (Me = le[ge], J = R(), Ie = 0; Ie < G; Ie++) {
        let { cell: Oe, startRow: be } = Me[Ie];
        be === ge ? (je = D(Me[Ie].cell.__headerState, o.COLUMN), J.append(m(je).append(n.$createParagraphNode()))) : Oe.setRowSpan(Oe.__rowSpan + 1);
      }
      G = re.getChildAtIndex(ge), y(G) || g(145), G.insertBefore(J);
    }
  }, nn.$isTableCellNode = f, nn.$isTableNode = ke, nn.$isTableRowNode = y, nn.$isTableSelection = L, nn.$removeTableRowAtIndex = function(J, G) {
    let H = J.getChildren();
    if (G >= H.length || 0 > G)
      throw Error("Expected table cell to be inside of table row.");
    return H[G].remove(), J;
  }, nn.$unmergeCell = function() {
    var J = n.$getSelection();
    n.$isRangeSelection(J) || L(J) || g(118), J = J.anchor.getNode();
    let [G, H, re] = W(J);
    J = G.__colSpan;
    let le = G.__rowSpan;
    if (1 < J) {
      for (var me = 1; me < J; me++)
        G.insertAfter(m(o.NO_STATUS));
      G.setColSpan(1);
    }
    if (1 < le) {
      let [Ie, je] = I(re, G, G), { startColumn: Oe, startRow: be } = je, He;
      for (me = 1; me < le; me++) {
        var ge = be + me;
        let Ge = Ie[ge];
        He = (He || H).getNextSibling(), y(He) || g(125);
        var Me = null;
        for (let dt = 0; dt < Oe; dt++) {
          let nt = Ge[dt], At = nt.cell;
          nt.startRow === ge && (Me = At), 1 < At.__colSpan && (dt += At.__colSpan - 1);
        }
        if (Me === null)
          for (Me = 0; Me < J; Me++)
            x(He, m(o.NO_STATUS));
        else
          for (ge = 0; ge < J; ge++)
            Me.insertAfter(m(o.NO_STATUS));
      }
      G.setRowSpan(1);
    }
  }, nn.INSERT_TABLE_COMMAND = O, nn.TableCellHeaderStates = o, nn.TableCellNode = u, nn.TableNode = De, nn.TableObserver = Z, nn.TableRowNode = S, nn.applyTableHandlers = function(J, G, H, re) {
    function le(Oe) {
      return Oe = J.getCordsFromCellNode(Oe, ge.table), J.getDOMCellFromCordsOrThrow(Oe.x, Oe.y, ge.table);
    }
    let me = H.getRootElement();
    if (me === null)
      throw Error("No root element.");
    let ge = new Z(H, J.getKey()), Me = H._window || window;
    G.__lexicalTableSelection = ge, G.addEventListener("mousedown", (Oe) => {
      setTimeout(() => {
        if (Oe.button === 0 && Me) {
          var be = oe(Oe.target);
          be !== null && (Ne(Oe), ge.setAnchorCellForSelection(be));
          var He = () => {
            Me.removeEventListener("mouseup", He), Me.removeEventListener(
              "mousemove",
              Ge
            );
          }, Ge = (dt) => {
            const nt = oe(dt.target);
            nt === null || ge.anchorX === nt.x && ge.anchorY === nt.y || (dt.preventDefault(), ge.setFocusCellForSelection(nt));
          };
          Me.addEventListener("mouseup", He), Me.addEventListener("mousemove", Ge);
        }
      }, 0);
    });
    let Ie = (Oe) => {
      Oe.button === 0 && H.update(() => {
        const be = n.$getSelection(), He = Oe.target;
        L(be) && be.tableKey === ge.tableNodeKey && me.contains(He) && ge.clearHighlight();
      });
    };
    Me.addEventListener("mousedown", Ie), ge.listenersToRemove.add(() => Me.removeEventListener("mousedown", Ie)), ge.listenersToRemove.add(H.registerCommand(
      n.KEY_ARROW_DOWN_COMMAND,
      (Oe) => de(H, Oe, "down", J, ge),
      n.COMMAND_PRIORITY_HIGH
    )), ge.listenersToRemove.add(H.registerCommand(n.KEY_ARROW_UP_COMMAND, (Oe) => de(H, Oe, "up", J, ge), n.COMMAND_PRIORITY_HIGH)), ge.listenersToRemove.add(H.registerCommand(n.KEY_ARROW_LEFT_COMMAND, (Oe) => de(H, Oe, "backward", J, ge), n.COMMAND_PRIORITY_HIGH)), ge.listenersToRemove.add(H.registerCommand(n.KEY_ARROW_RIGHT_COMMAND, (Oe) => de(H, Oe, "forward", J, ge), n.COMMAND_PRIORITY_HIGH)), ge.listenersToRemove.add(H.registerCommand(n.KEY_ESCAPE_COMMAND, (Oe) => {
      var be = n.$getSelection();
      return L(be) && (be = r.$findMatchingParent(
        be.focus.getNode(),
        f
      ), f(be)) ? (Ne(Oe), be.selectEnd(), !0) : !1;
    }, n.COMMAND_PRIORITY_HIGH));
    let je = (Oe) => () => {
      var be = n.$getSelection();
      if (!Y(be, J))
        return !1;
      if (L(be))
        return ge.clearText(), !0;
      if (n.$isRangeSelection(be)) {
        const dt = r.$findMatchingParent(be.anchor.getNode(), (nt) => f(nt));
        if (!f(dt))
          return !1;
        var He = be.anchor.getNode(), Ge = be.focus.getNode();
        if (He = J.isParentOf(He), Ge = J.isParentOf(Ge), He && !Ge || Ge && !He)
          return ge.clearText(), !0;
        if (He = (Ge = r.$findMatchingParent(be.anchor.getNode(), (nt) => n.$isElementNode(nt))) && r.$findMatchingParent(Ge, (nt) => n.$isElementNode(nt) && f(nt.getParent())), !n.$isElementNode(He) || !n.$isElementNode(Ge))
          return !1;
        if (Oe === n.DELETE_LINE_COMMAND && He.getPreviousSibling() === null)
          return !0;
        if ((Oe === n.DELETE_CHARACTER_COMMAND || Oe === n.DELETE_WORD_COMMAND) && be.isCollapsed() && be.anchor.offset === 0 && Ge !== He) {
          be = Ge.getChildren();
          const nt = n.$createParagraphNode();
          return be.forEach((At) => nt.append(At)), Ge.replace(nt), Ge.getWritable().__parent = dt.getKey(), !0;
        }
      }
      return !1;
    };
    return [n.DELETE_WORD_COMMAND, n.DELETE_LINE_COMMAND, n.DELETE_CHARACTER_COMMAND].forEach((Oe) => {
      ge.listenersToRemove.add(H.registerCommand(
        Oe,
        je(Oe),
        n.COMMAND_PRIORITY_CRITICAL
      ));
    }), G = (Oe) => {
      const be = n.$getSelection();
      return Y(be, J) ? L(be) ? (Oe.preventDefault(), Oe.stopPropagation(), ge.clearText(), !0) : (n.$isRangeSelection(be) && (Oe = r.$findMatchingParent(be.anchor.getNode(), (He) => f(He)), f(Oe)), !1) : !1;
    }, ge.listenersToRemove.add(H.registerCommand(n.KEY_BACKSPACE_COMMAND, G, n.COMMAND_PRIORITY_CRITICAL)), ge.listenersToRemove.add(H.registerCommand(n.KEY_DELETE_COMMAND, G, n.COMMAND_PRIORITY_CRITICAL)), ge.listenersToRemove.add(H.registerCommand(
      n.FORMAT_TEXT_COMMAND,
      (Oe) => {
        let be = n.$getSelection();
        return Y(be, J) ? L(be) ? (ge.formatCells(Oe), !0) : (n.$isRangeSelection(be) && (Oe = r.$findMatchingParent(be.anchor.getNode(), (He) => f(He)), f(Oe)), !1) : !1;
      },
      n.COMMAND_PRIORITY_CRITICAL
    )), ge.listenersToRemove.add(H.registerCommand(n.CONTROLLED_TEXT_INSERTION_COMMAND, () => {
      var Oe = n.$getSelection();
      return Y(Oe, J) && (L(Oe) ? ge.clearHighlight() : n.$isRangeSelection(Oe) && (Oe = r.$findMatchingParent(Oe.anchor.getNode(), (be) => f(be)), f(Oe))), !1;
    }, n.COMMAND_PRIORITY_CRITICAL)), re && ge.listenersToRemove.add(H.registerCommand(
      n.KEY_TAB_COMMAND,
      (Oe) => {
        var be = n.$getSelection();
        return !n.$isRangeSelection(be) || !be.isCollapsed() || !Y(be, J) || (be = Q(be.anchor.getNode()), be === null) ? !1 : (Ne(Oe), be = J.getCordsFromCellNode(be, ge.table), ie(ge, J, be.x, be.y, Oe.shiftKey ? "backward" : "forward"), !0);
      },
      n.COMMAND_PRIORITY_CRITICAL
    )), ge.listenersToRemove.add(H.registerCommand(n.FOCUS_COMMAND, () => J.isSelected(), n.COMMAND_PRIORITY_HIGH)), ge.listenersToRemove.add(H.registerCommand(n.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, (Oe) => {
      let { nodes: be, selection: He } = Oe;
      Oe = He.getStartEndPoints();
      var Ge = L(He);
      if (Ge = n.$isRangeSelection(He) && r.$findMatchingParent(He.anchor.getNode(), ($e) => f($e)) !== null && r.$findMatchingParent(He.focus.getNode(), ($e) => f($e)) !== null || Ge, be.length !== 1 || !ke(be[0]) || !Ge || Oe === null)
        return !1;
      var [dt] = Oe, nt = be[0];
      Oe = nt.getChildren(), Ge = nt.getFirstChildOrThrow().getChildrenSize(), nt = nt.getChildrenSize();
      var At = r.$findMatchingParent(dt.getNode(), ($e) => f($e)), an = (dt = At && r.$findMatchingParent(At, ($e) => y($e))) && r.$findMatchingParent(dt, ($e) => ke($e));
      if (!f(At) || !y(dt) || !ke(an))
        return !1;
      var Gt = dt.getIndexWithinParent(), Ot = Math.min(an.getChildrenSize() - 1, Gt + nt - 1);
      nt = At.getIndexWithinParent(), At = Math.min(dt.getChildrenSize() - 1, nt + Ge - 1), Ge = Math.min(nt, At), dt = Math.min(Gt, Ot), nt = Math.max(nt, At), Gt = Math.max(Gt, Ot), an = an.getChildren(), Ot = 0;
      let Te, ue;
      for (At = dt; At <= Gt; At++) {
        var he = an[At];
        if (!y(he))
          return !1;
        var Se = Oe[Ot];
        if (!y(Se))
          return !1;
        he = he.getChildren(), Se = Se.getChildren();
        let $e = 0;
        for (let Re = Ge; Re <= nt; Re++) {
          let We = he[Re];
          if (!f(We))
            return !1;
          let rt = Se[$e];
          if (!f(rt))
            return !1;
          At === dt && Re === Ge ? Te = We.getKey() : At === Gt && Re === nt && (ue = We.getKey());
          let lt = We.getChildren();
          rt.getChildren().forEach((tt) => {
            n.$isTextNode(tt) && n.$createParagraphNode().append(tt), We.append(tt);
          }), lt.forEach((tt) => tt.remove()), $e++;
        }
        Ot++;
      }
      return Te && ue && (Oe = P(), Oe.set(be[0].getKey(), Te, ue), n.$setSelection(Oe)), !0;
    }, n.COMMAND_PRIORITY_CRITICAL)), ge.listenersToRemove.add(H.registerCommand(n.SELECTION_CHANGE_COMMAND, () => {
      let Oe = n.$getSelection(), be = n.$getPreviousSelection();
      if (n.$isRangeSelection(Oe)) {
        let { anchor: At, focus: an } = Oe;
        var He = At.getNode(), Ge = an.getNode();
        He = Q(He), Ge = Q(Ge);
        var dt = He && J.is(ae(He)), nt = Ge && J.is(ae(Ge));
        let Gt = dt !== nt;
        nt = dt && nt, dt = Oe.isBackward(), Gt ? (He = Oe.clone(), He.focus.set(
          J.getKey(),
          dt ? 0 : J.getChildrenSize(),
          "element"
        ), n.$setSelection(He), A(H, ge)) : nt && !He.is(Ge) && (ge.setAnchorCellForSelection(le(He)), ge.setFocusCellForSelection(le(Ge), !0));
      }
      return Oe && !Oe.is(be) && (L(Oe) || L(be)) && ge.tableSelection && !ge.tableSelection.is(be) ? (L(Oe) && Oe.tableKey === ge.tableNodeKey ? ge.updateTableTableSelection(Oe) : !L(Oe) && L(be) && be.tableKey === ge.tableNodeKey && ge.updateTableTableSelection(null), !1) : (ge.hasHijackedSelectionStyles && !J.isSelected() ? z(H, ge) : !ge.hasHijackedSelectionStyles && J.isSelected() && A(H, ge), !1);
    }, n.COMMAND_PRIORITY_CRITICAL)), ge;
  }, nn.getDOMCellFromTarget = oe, nn.getTableObserverFromTableElement = function(J) {
    return J.__lexicalTableSelection;
  }, nn;
}
const fm = process.env.NODE_ENV === "development" ? um() : dm();
var vt = fm, gn = zt(), gm = Nl(), Jt = kt(), fe = St();
function hm({ nodeKey: r }) {
  const [n] = gn.useLexicalComposerContext(), [t, o, u] = gm.useLexicalNodeSelection(r), p = Vt(
    (m) => {
      if (m.preventDefault(), t && fe.$isNodeSelection(fe.$getSelection())) {
        const f = fe.$getNodeByKey(r);
        if (mm(f))
          return f.remove(), !0;
      }
      return !1;
    },
    [t, r]
  );
  return yt(() => Jt.mergeRegister(
    n.registerCommand(
      fe.CLICK_COMMAND,
      (m) => {
        const f = n.getElementByKey(r);
        return m.target === f ? (m.shiftKey || u(), o(!t), !0) : !1;
      },
      fe.COMMAND_PRIORITY_LOW
    ),
    n.registerCommand(
      fe.KEY_DELETE_COMMAND,
      p,
      fe.COMMAND_PRIORITY_LOW
    ),
    n.registerCommand(
      fe.KEY_BACKSPACE_COMMAND,
      p,
      fe.COMMAND_PRIORITY_LOW
    )
  ), [u, n, t, r, p, o]), yt(() => {
    const m = n.getElementByKey(r);
    m !== null && (m.className = t ? "selected" : "");
  }, [n, t, r]), null;
}
class Ms extends fe.DecoratorNode {
  static getType() {
    return "page-break";
  }
  static clone(n) {
    return new Ms(n.__key);
  }
  static importJSON() {
    return nu();
  }
  static importDOM() {
    return {
      figure: (n) => n.getAttribute("type") !== this.getType() ? null : {
        conversion: pm,
        priority: fe.COMMAND_PRIORITY_HIGH
      }
    };
  }
  exportJSON() {
    return {
      type: this.getType(),
      version: 1
    };
  }
  createDOM() {
    const n = document.createElement("figure");
    return n.style.pageBreakAfter = "always", n.setAttribute("type", this.getType()), n;
  }
  getTextContent() {
    return `
`;
  }
  isInline() {
    return !1;
  }
  updateDOM() {
    return !1;
  }
  decorate() {
    return /* @__PURE__ */ U.jsx(hm, { nodeKey: this.__key });
  }
}
function pm() {
  return { node: nu() };
}
function nu() {
  return new Ms();
}
function mm(r) {
  return r instanceof Ms;
}
class xl extends fe.TextNode {
  constructor(t, o, u) {
    super(o, u);
    Tt(this, "__className");
    this.__className = t;
  }
  static getType() {
    return "emoji";
  }
  static clone(t) {
    return new xl(t.__className, t.__text, t.__key);
  }
  createDOM(t) {
    const o = document.createElement("span"), u = super.createDOM(t);
    return o.className = this.__className, u.className = "emoji-inner", o.appendChild(u), o;
  }
  updateDOM(t, o, u) {
    const p = o.firstChild;
    return p === null ? !0 : (super.updateDOM(t, p, u), !1);
  }
  static importJSON(t) {
    const o = Jg(
      t.className,
      t.text
    );
    return o.setFormat(t.format), o.setDetail(t.detail), o.setMode(t.mode), o.setStyle(t.style), o;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      className: this.getClassName(),
      type: "emoji"
    };
  }
  getClassName() {
    return this.getLatest().__className;
  }
}
function Jg(r, n) {
  const t = new xl(r, n).setMode("token");
  return fe.$applyNodeReplacement(t);
}
const _m = Er.lazy(() => import("./ImageComponent-4zb7_kEY.js"));
function Nm(r) {
  const n = r;
  if (n.src.startsWith("file:///"))
    return null;
  const { alt: t, src: o, width: u, height: p } = n;
  return { node: ru({ altText: t, height: p, src: o, width: u }) };
}
class Rs extends fe.DecoratorNode {
  constructor(t, o, u, p, m, f, O, S, E, R, y, g) {
    super(E);
    Tt(this, "__src");
    Tt(this, "__altText");
    Tt(this, "__width");
    Tt(this, "__height");
    Tt(this, "__maxWidth");
    Tt(this, "__showCaption");
    Tt(this, "__caption");
    // Captions cannot yet be used within editor cells
    Tt(this, "__captionsEnabled");
    Tt(this, "__isAbsolute");
    Tt(this, "__x");
    Tt(this, "__y");
    this.__src = t, this.__altText = o, this.__maxWidth = u, this.__width = p || "inherit", this.__height = m || "inherit", this.__showCaption = f || !1, this.__caption = O || fe.createEditor(), this.__captionsEnabled = S || S === void 0, this.__isAbsolute = R || !1, this.__x = y || 0, this.__y = g || 0;
  }
  static getType() {
    return "image";
  }
  static clone(t) {
    return new Rs(
      t.__src,
      t.__altText,
      t.__maxWidth,
      t.__width,
      t.__height,
      t.__showCaption,
      t.__caption,
      t.__captionsEnabled,
      t.__key,
      t.__isAbsolute,
      t.__x,
      t.__y
    );
  }
  static importJSON(t) {
    const {
      altText: o,
      height: u,
      width: p,
      maxWidth: m,
      caption: f,
      src: O,
      showCaption: S,
      isAbsolute: E,
      xOffset: R,
      yOffset: y
    } = t, g = ru({
      altText: o,
      height: u,
      maxWidth: m,
      showCaption: S,
      src: O,
      width: p,
      isAbsolute: E,
      xOffset: R,
      yOffset: y
    }), _ = g.__caption, N = _.parseEditorState(f.editorState);
    return N.isEmpty() || _.setEditorState(N), g;
  }
  exportDOM() {
    const t = document.createElement("img");
    return t.setAttribute("src", this.__src), t.setAttribute("alt", this.__altText), t.setAttribute("width", this.__width.toString()), t.setAttribute("height", this.__height.toString()), { element: t };
  }
  static importDOM() {
    return {
      img: () => ({
        conversion: Nm,
        priority: 0
      })
    };
  }
  exportJSON() {
    return {
      altText: this.getAltText(),
      caption: this.__caption.toJSON(),
      height: this.__height === "inherit" ? 0 : this.__height,
      maxWidth: this.__maxWidth,
      showCaption: this.__showCaption,
      src: this.getSrc(),
      type: "image",
      version: 1,
      width: this.__width === "inherit" ? 0 : this.__width,
      isAbsolute: this.__isAbsolute,
      xOffset: this.__x,
      yOffset: this.__y
    };
  }
  setWidthAndHeight(t, o) {
    const u = this.getWritable();
    u.__width = t, u.__height = o;
  }
  setShowCaption(t) {
    const o = this.getWritable();
    o.__showCaption = t;
  }
  setAbsolute(t) {
    const o = this.getWritable();
    o.__isAbsolute = t;
  }
  setPosition(t, o) {
    const u = this.getWritable();
    u.__x = t, u.__y = o, fe.$setSelection(null);
  }
  // View
  createDOM(t) {
    const o = document.createElement("span"), p = t.theme.image;
    return p !== void 0 && (o.className = p), o;
  }
  updateDOM() {
    return !1;
  }
  getSrc() {
    return this.__src;
  }
  getAltText() {
    return this.__altText;
  }
  decorate() {
    return /* @__PURE__ */ U.jsx(Ki, { fallback: null, children: /* @__PURE__ */ U.jsx(
      _m,
      {
        src: this.__src,
        altText: this.__altText,
        width: this.__width,
        height: this.__height,
        maxWidth: this.__maxWidth,
        nodeKey: this.getKey(),
        showCaption: this.__showCaption,
        caption: this.__caption,
        captionsEnabled: this.__captionsEnabled,
        resizable: !0,
        isAbsolute: this.__isAbsolute,
        xOffset: this.__x,
        yOffset: this.__y
      }
    ) });
  }
}
function ru({
  altText: r,
  height: n,
  maxWidth: t = 500,
  captionsEnabled: o,
  src: u,
  width: p,
  showCaption: m,
  caption: f,
  key: O,
  xOffset: S,
  yOffset: E,
  isAbsolute: R
}) {
  return fe.$applyNodeReplacement(
    new Rs(
      u,
      r,
      t,
      p,
      n,
      m,
      f,
      o,
      O,
      R,
      S,
      E
    )
  );
}
function Cm(r) {
  return r instanceof Rs;
}
class Os extends fe.TextNode {
  static getType() {
    return "keyword";
  }
  static clone(n) {
    return new Os(n.__text, n.__key);
  }
  static importJSON(n) {
    const t = Xg(n.text);
    return t.setFormat(n.format), t.setDetail(n.detail), t.setMode(n.mode), t.setStyle(n.style), t;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "keyword",
      version: 1
    };
  }
  createDOM(n) {
    const t = super.createDOM(n);
    return t.style.cursor = "default", t.className = "keyword", t;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
  isTextEntity() {
    return !0;
  }
}
function Xg(r) {
  return new Os(r);
}
var cc = {}, da = {}, af;
function xm() {
  if (af)
    return da;
  af = 1;
  var r = St();
  class n extends r.DecoratorNode {
    constructor(u, p) {
      super(p), this.__format = u || "";
    }
    exportJSON() {
      return {
        format: this.__format || "",
        type: "decorator-block",
        version: 1
      };
    }
    createDOM() {
      return document.createElement("div");
    }
    updateDOM() {
      return !1;
    }
    setFormat(u) {
      const p = this.getWritable();
      p.__format = u;
    }
    isInline() {
      return !1;
    }
  }
  function t(o) {
    return o instanceof n;
  }
  return da.$isDecoratorBlockNode = t, da.DecoratorBlockNode = n, da;
}
var fa = {}, cf;
function Em() {
  if (cf)
    return fa;
  cf = 1;
  var r = St();
  class n extends r.DecoratorNode {
    constructor(o, u) {
      super(u), this.__format = o || "";
    }
    exportJSON() {
      return { format: this.__format || "", type: "decorator-block", version: 1 };
    }
    createDOM() {
      return document.createElement("div");
    }
    updateDOM() {
      return !1;
    }
    setFormat(o) {
      this.getWritable().__format = o;
    }
    isInline() {
      return !1;
    }
  }
  return fa.$isDecoratorBlockNode = function(t) {
    return t instanceof n;
  }, fa.DecoratorBlockNode = n, fa;
}
const Tm = process.env.NODE_ENV === "development" ? xm() : Em();
var bs = Tm, uf;
function ym() {
  if (uf)
    return cc;
  uf = 1;
  var r = zt(), n = bs, t = Nl(), o = kt(), u = St(), p = $t;
  function m({
    children: f,
    format: O,
    nodeKey: S,
    className: E
  }) {
    const [R] = r.useLexicalComposerContext(), [y, g, _] = t.useLexicalNodeSelection(S), N = p.useRef(null), w = p.useCallback((T) => {
      if (y && u.$isNodeSelection(u.$getSelection())) {
        T.preventDefault();
        const D = u.$getNodeByKey(S);
        u.$isDecoratorNode(D) && D.remove();
      }
      return !1;
    }, [y, S]);
    return p.useEffect(() => o.mergeRegister(R.registerCommand(u.FORMAT_ELEMENT_COMMAND, (T) => {
      if (y) {
        const D = u.$getSelection();
        if (u.$isNodeSelection(D)) {
          const C = u.$getNodeByKey(S);
          n.$isDecoratorBlockNode(C) && C.setFormat(T);
        } else if (u.$isRangeSelection(D)) {
          const C = D.getNodes();
          for (const x of C)
            n.$isDecoratorBlockNode(x) ? x.setFormat(T) : o.$getNearestBlockElementAncestorOrThrow(x).setFormat(T);
        }
        return !0;
      }
      return !1;
    }, u.COMMAND_PRIORITY_LOW), R.registerCommand(u.CLICK_COMMAND, (T) => T.target === N.current ? (T.preventDefault(), T.shiftKey || _(), g(!y), !0) : !1, u.COMMAND_PRIORITY_LOW), R.registerCommand(u.KEY_DELETE_COMMAND, w, u.COMMAND_PRIORITY_LOW), R.registerCommand(u.KEY_BACKSPACE_COMMAND, w, u.COMMAND_PRIORITY_LOW)), [_, R, y, S, w, g]), /* @__PURE__ */ p.createElement("div", {
      className: [E.base, y ? E.focus : null].filter(Boolean).join(" "),
      ref: N,
      style: {
        textAlign: O || void 0
      }
    }, f);
  }
  return cc.BlockWithAlignableContents = m, cc;
}
var uc = {}, df;
function Sm() {
  if (df)
    return uc;
  df = 1;
  var r = zt(), n = bs, t = Nl(), o = kt(), u = St(), p = $t;
  return uc.BlockWithAlignableContents = function({ children: m, format: f, nodeKey: O, className: S }) {
    let [E] = r.useLexicalComposerContext(), [R, y, g] = t.useLexicalNodeSelection(O), _ = p.useRef(null), N = p.useCallback((w) => (R && u.$isNodeSelection(u.$getSelection()) && (w.preventDefault(), w = u.$getNodeByKey(O), u.$isDecoratorNode(w) && w.remove()), !1), [R, O]);
    return p.useEffect(() => o.mergeRegister(E.registerCommand(u.FORMAT_ELEMENT_COMMAND, (w) => {
      if (R) {
        var T = u.$getSelection();
        if (u.$isNodeSelection(T)) {
          var D = u.$getNodeByKey(O);
          n.$isDecoratorBlockNode(D) && D.setFormat(w);
        } else if (u.$isRangeSelection(T)) {
          T = T.getNodes();
          for (D of T)
            n.$isDecoratorBlockNode(D) ? D.setFormat(w) : o.$getNearestBlockElementAncestorOrThrow(D).setFormat(w);
        }
        return !0;
      }
      return !1;
    }, u.COMMAND_PRIORITY_LOW), E.registerCommand(u.CLICK_COMMAND, (w) => w.target === _.current ? (w.preventDefault(), w.shiftKey || g(), y(!R), !0) : !1, u.COMMAND_PRIORITY_LOW), E.registerCommand(u.KEY_DELETE_COMMAND, N, u.COMMAND_PRIORITY_LOW), E.registerCommand(u.KEY_BACKSPACE_COMMAND, N, u.COMMAND_PRIORITY_LOW)), [g, E, R, O, N, y]), p.createElement(
      "div",
      { className: [S.base, R ? S.focus : null].filter(Boolean).join(" "), ref: _, style: { textAlign: f || void 0 } },
      m
    );
  }, uc;
}
const Om = process.env.NODE_ENV === "development" ? ym() : Sm();
var ou = Om;
function vm({
  className: r,
  format: n,
  nodeKey: t,
  documentID: o
}) {
  return /* @__PURE__ */ U.jsx(
    ou.BlockWithAlignableContents,
    {
      className: r,
      format: n,
      nodeKey: t,
      children: /* @__PURE__ */ U.jsx(
        "iframe",
        {
          width: "560",
          height: "315",
          src: `https://www.figma.com/embed?embed_host=lexical&url=        https://www.figma.com/file/${o}`,
          allowFullScreen: !0
        }
      )
    }
  );
}
class El extends bs.DecoratorBlockNode {
  constructor(t, o, u) {
    super(o, u);
    Tt(this, "__id");
    this.__id = t;
  }
  static getType() {
    return "figma";
  }
  static clone(t) {
    return new El(t.__id, t.__format, t.__key);
  }
  static importJSON(t) {
    const o = Zg(t.documentID);
    return o.setFormat(t.format), o;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      documentID: this.__id,
      type: "figma",
      version: 1
    };
  }
  updateDOM() {
    return !1;
  }
  getId() {
    return this.__id;
  }
  getTextContent() {
    return `https://www.figma.com/file/${this.__id}`;
  }
  decorate(t, o) {
    const u = o.theme.embedBlock || {}, p = {
      base: u.base || "",
      focus: u.focus || ""
    };
    return /* @__PURE__ */ U.jsx(
      vm,
      {
        className: p,
        format: this.__format,
        nodeKey: this.getKey(),
        documentID: this.__id
      }
    );
  }
}
function Zg(r) {
  return new El(r);
}
const wm = "https://platform.twitter.com/widgets.js";
function Mm(r) {
  const n = r.getAttribute("data-lexical-tweet-id");
  return n ? { node: iu(n) } : null;
}
let ff = !0;
function Rm({
  className: r,
  format: n,
  loadingComponent: t,
  nodeKey: o,
  onError: u,
  onLoad: p,
  tweetID: m
}) {
  const f = Cn(null), O = Cn(""), [S, E] = ut(!1), R = Vt(async () => {
    try {
      await window.twttr.widgets.createTweet(m, f.current), E(!1), ff = !1, p && p();
    } catch (y) {
      u && u(String(y));
    }
  }, [u, p, m]);
  return yt(() => {
    var y;
    if (m !== O.current) {
      if (E(!0), ff) {
        const g = document.createElement("script");
        g.src = wm, g.async = !0, (y = document.body) == null || y.appendChild(g), g.onload = R, u && (g.onerror = u);
      } else
        R();
      O && (O.current = m);
    }
  }, [R, u, m]), /* @__PURE__ */ U.jsxs(
    ou.BlockWithAlignableContents,
    {
      className: r,
      format: n,
      nodeKey: o,
      children: [
        S ? t : null,
        /* @__PURE__ */ U.jsx(
          "div",
          {
            style: { display: "inline-block", width: "550px" },
            ref: f
          }
        )
      ]
    }
  );
}
class Tl extends bs.DecoratorBlockNode {
  constructor(t, o, u) {
    super(o, u);
    Tt(this, "__id");
    this.__id = t;
  }
  static getType() {
    return "tweet";
  }
  static clone(t) {
    return new Tl(t.__id, t.__format, t.__key);
  }
  static importJSON(t) {
    const o = iu(t.id);
    return o.setFormat(t.format), o;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      id: this.getId(),
      type: "tweet",
      version: 1
    };
  }
  static importDOM() {
    return {
      div: (t) => t.hasAttribute("data-lexical-tweet-id") ? {
        conversion: Mm,
        priority: 2
      } : null
    };
  }
  exportDOM() {
    const t = document.createElement("div");
    t.setAttribute("data-lexical-tweet-id", this.__id);
    const o = document.createTextNode(this.getTextContent());
    return t.append(o), { element: t };
  }
  getId() {
    return this.__id;
  }
  getTextContent(t, o) {
    return `https://x.com/i/web/status/${this.__id}`;
  }
  decorate(t, o) {
    const u = o.theme.embedBlock || {}, p = {
      base: u.base || "",
      focus: u.focus || ""
    };
    return /* @__PURE__ */ U.jsx(
      Rm,
      {
        className: p,
        format: this.__format,
        loadingComponent: "Loading...",
        nodeKey: this.getKey(),
        tweetID: this.__id
      }
    );
  }
}
function iu(r) {
  return new Tl(r);
}
function bm({
  className: r,
  format: n,
  nodeKey: t,
  videoID: o
}) {
  return /* @__PURE__ */ U.jsx(
    ou.BlockWithAlignableContents,
    {
      className: r,
      format: n,
      nodeKey: t,
      children: /* @__PURE__ */ U.jsx(
        "iframe",
        {
          width: "560",
          height: "315",
          src: `https://www.youtube-nocookie.com/embed/${o}`,
          frameBorder: "0",
          allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",
          allowFullScreen: !0,
          title: "YouTube video"
        }
      )
    }
  );
}
function Am(r) {
  const n = r.getAttribute("data-lexical-youtube");
  return n ? { node: su(n) } : null;
}
class yl extends bs.DecoratorBlockNode {
  constructor(t, o, u) {
    super(o, u);
    Tt(this, "__id");
    this.__id = t;
  }
  static getType() {
    return "youtube";
  }
  static clone(t) {
    return new yl(t.__id, t.__format, t.__key);
  }
  static importJSON(t) {
    const o = su(t.videoID);
    return o.setFormat(t.format), o;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "youtube",
      version: 1,
      videoID: this.__id
    };
  }
  exportDOM() {
    const t = document.createElement("iframe");
    return t.setAttribute("data-lexical-youtube", this.__id), t.setAttribute("width", "560"), t.setAttribute("height", "315"), t.setAttribute(
      "src",
      `https://www.youtube-nocookie.com/embed/${this.__id}`
    ), t.setAttribute("frameborder", "0"), t.setAttribute(
      "allow",
      "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    ), t.setAttribute("allowfullscreen", "true"), t.setAttribute("title", "YouTube video"), { element: t };
  }
  static importDOM() {
    return {
      iframe: (t) => t.hasAttribute("data-lexical-youtube") ? {
        conversion: Am,
        priority: 1
      } : null
    };
  }
  updateDOM() {
    return !1;
  }
  getId() {
    return this.__id;
  }
  getTextContent(t, o) {
    return `https://www.youtube.com/watch?v=${this.__id}`;
  }
  decorate(t, o) {
    const u = o.theme.embedBlock || {}, p = {
      base: u.base || "",
      focus: u.focus || ""
    };
    return /* @__PURE__ */ U.jsx(
      bm,
      {
        className: p,
        format: this.__format,
        nodeKey: this.getKey(),
        videoID: this.__id
      }
    );
  }
}
function su(r) {
  return new yl(r);
}
function Dm(r) {
  const n = r.open !== void 0 ? r.open : !0;
  return {
    node: lu(n)
  };
}
class Li extends fe.ElementNode {
  constructor(t, o) {
    super(o);
    Tt(this, "__open");
    this.__open = t;
  }
  static getType() {
    return "collapsible-container";
  }
  static clone(t) {
    return new Li(t.__open, t.__key);
  }
  createDOM(t, o) {
    const u = document.createElement("details");
    return u.classList.add("Collapsible__container"), u.open = this.__open, u.addEventListener("toggle", () => {
      o.getEditorState().read(() => this.getOpen()) !== u.open && o.update(() => this.toggleOpen());
    }), u;
  }
  updateDOM(t, o) {
    return t.__open !== this.__open && (o.open = this.__open), !1;
  }
  static importDOM() {
    return {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      details: (t) => ({
        conversion: Dm,
        priority: 1
      })
    };
  }
  static importJSON(t) {
    return lu(t.open);
  }
  exportDOM() {
    const t = document.createElement("details");
    return t.setAttribute("open", this.__open.toString()), { element: t };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      open: this.__open,
      type: "collapsible-container",
      version: 1
    };
  }
  setOpen(t) {
    const o = this.getWritable();
    o.__open = t;
  }
  getOpen() {
    return this.getLatest().__open;
  }
  toggleOpen() {
    this.setOpen(!this.getOpen());
  }
}
function lu(r) {
  return new Li(r);
}
function Po(r) {
  return r instanceof Li;
}
function Lm(r) {
  return {
    node: au()
  };
}
class Ii extends fe.ElementNode {
  static getType() {
    return "collapsible-content";
  }
  static clone(n) {
    return new Ii(n.__key);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createDOM(n) {
    const t = document.createElement("div");
    return t.classList.add("Collapsible__content"), t;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  updateDOM(n, t) {
    return !1;
  }
  static importDOM() {
    return {
      div: (n) => n.hasAttribute("data-lexical-collapsible-content") ? {
        conversion: Lm,
        priority: 2
      } : null
    };
  }
  exportDOM() {
    const n = document.createElement("div");
    return n.setAttribute("data-lexical-collapsible-content", "true"), { element: n };
  }
  static importJSON(n) {
    return au();
  }
  isShadowRoot() {
    return !0;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "collapsible-content",
      version: 1
    };
  }
}
function au() {
  return new Ii();
}
function Qg(r) {
  return r instanceof Ii;
}
function Im(r) {
  return {
    node: cu()
  };
}
class $i extends fe.ElementNode {
  static getType() {
    return "collapsible-title";
  }
  static clone(n) {
    return new $i(n.__key);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createDOM(n, t) {
    const o = document.createElement("summary");
    return o.classList.add("Collapsible__title"), o;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  updateDOM(n, t) {
    return !1;
  }
  static importDOM() {
    return {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      summary: (n) => ({
        conversion: Im,
        priority: 1
      })
    };
  }
  static importJSON(n) {
    return cu();
  }
  exportDOM() {
    return { element: document.createElement("summary") };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "collapsible-title",
      version: 1
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  collapseAtStart(n) {
    return this.getParentOrThrow().insertBefore(this), !0;
  }
  insertNewAfter(n, t = !0) {
    const o = this.getParentOrThrow();
    if (!Po(o))
      throw new Error(
        "CollapsibleTitleNode expects to be child of CollapsibleContainerNode"
      );
    if (o.getOpen()) {
      const u = this.getNextSibling();
      if (!Qg(u))
        throw new Error(
          "CollapsibleTitleNode expects to have CollapsibleContentNode sibling"
        );
      const p = u.getFirstChild();
      if (fe.$isElementNode(p))
        return p;
      {
        const m = fe.$createParagraphNode();
        return u.append(m), m;
      }
    } else {
      const u = fe.$createParagraphNode();
      return o.insertAfter(u, t), u;
    }
  }
}
function cu() {
  return new $i();
}
function gf(r) {
  return r instanceof $i;
}
const $m = Er.lazy(() => import("./EquationComponent-DLu5M4Ot.js"));
function hf(r) {
  let n = r.getAttribute("data-lexical-equation");
  const t = r.getAttribute("data-lexical-inline") === "true";
  return n = atob(n || ""), n ? { node: uu(n, t) } : null;
}
class As extends fe.DecoratorNode {
  constructor(t, o, u) {
    super(u);
    Tt(this, "__equation");
    Tt(this, "__inline");
    this.__equation = t, this.__inline = o ?? !1;
  }
  static getType() {
    return "equation";
  }
  static clone(t) {
    return new As(t.__equation, t.__inline, t.__key);
  }
  static importJSON(t) {
    return uu(
      t.equation,
      t.inline
    );
  }
  exportJSON() {
    return {
      equation: this.getEquation(),
      inline: this.__inline,
      type: "equation",
      version: 1
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createDOM(t) {
    const o = document.createElement(this.__inline ? "span" : "div");
    return o.className = "editor-equation", o;
  }
  exportDOM() {
    const t = document.createElement(this.__inline ? "span" : "div"), o = btoa(this.__equation);
    return t.setAttribute("data-lexical-equation", o), t.setAttribute("data-lexical-inline", `${this.__inline}`), bg.render(this.__equation, t, {
      displayMode: !this.__inline,
      // true === block display //
      errorColor: "#cc0000",
      output: "html",
      strict: "warn",
      throwOnError: !1,
      trust: !1
    }), { element: t };
  }
  static importDOM() {
    return {
      div: (t) => t.hasAttribute("data-lexical-equation") ? {
        conversion: hf,
        priority: 2
      } : null,
      span: (t) => t.hasAttribute("data-lexical-equation") ? {
        conversion: hf,
        priority: 1
      } : null
    };
  }
  updateDOM(t) {
    return this.__inline !== t.__inline;
  }
  getTextContent() {
    return this.__equation;
  }
  getEquation() {
    return this.__equation;
  }
  setEquation(t) {
    const o = this.getWritable();
    o.__equation = t;
  }
  decorate() {
    return /* @__PURE__ */ U.jsx(Ki, { fallback: null, children: /* @__PURE__ */ U.jsx(
      $m,
      {
        equation: this.__equation,
        inline: this.__inline,
        nodeKey: this.__key
      }
    ) });
  }
}
function uu(r = "", n = !1) {
  const t = new As(r, n);
  return fe.$applyNodeReplacement(t);
}
function oE(r) {
  return r instanceof As;
}
const km = Er.lazy(() => import("./ExcalidrawComponent-CxoN26X-.js"));
function Pm(r) {
  const n = r.getAttribute("data-lexical-excalidraw-json");
  if (n) {
    const t = eh();
    return t.__data = n, {
      node: t
    };
  }
  return null;
}
class ki extends fe.DecoratorNode {
  constructor(t = "[]", o = "inherit", u = "inherit", p) {
    super(p);
    Tt(this, "__data");
    Tt(this, "__width");
    Tt(this, "__height");
    this.__data = t, this.__width = o, this.__height = u;
  }
  static getType() {
    return "excalidraw";
  }
  static clone(t) {
    return new ki(t.__data, t.__width, t.__height, t.__key);
  }
  static importJSON(t) {
    return new ki(t.data, t.width, t.height);
  }
  exportJSON() {
    return {
      data: this.__data,
      height: this.__height,
      type: "excalidraw",
      version: 1,
      width: this.__width
    };
  }
  // View
  createDOM(t) {
    const o = document.createElement("span"), p = t.theme.image;
    return o.style.width = this.__width === "inherit" ? "inherit" : `${this.__width}px`, o.style.height = this.__height === "inherit" ? "inherit" : `${this.__height}px`, p !== void 0 && (o.className = p), o;
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return {
      span: (t) => t.hasAttribute("data-lexical-excalidraw-json") ? {
        conversion: Pm,
        priority: 1
      } : null
    };
  }
  exportDOM(t) {
    const o = document.createElement("span");
    o.style.display = "inline-block";
    const u = t.getElementByKey(this.getKey());
    if (u !== null) {
      const p = u.querySelector("svg");
      p !== null && (o.innerHTML = p.outerHTML);
    }
    return o.style.width = this.__width === "inherit" ? "inherit" : `${this.__width}px`, o.style.height = this.__height === "inherit" ? "inherit" : `${this.__height}px`, o.setAttribute("data-lexical-excalidraw-json", this.__data), { element: o };
  }
  setData(t) {
    const o = this.getWritable();
    o.__data = t;
  }
  setWidth(t) {
    const o = this.getWritable();
    o.__width = t;
  }
  setHeight(t) {
    const o = this.getWritable();
    o.__height = t;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  decorate(t, o) {
    return /* @__PURE__ */ U.jsx(Ki, { fallback: null, children: /* @__PURE__ */ U.jsx(km, { nodeKey: this.getKey(), data: this.__data }) });
  }
}
function eh() {
  return new ki();
}
function iE(r) {
  return r instanceof ki;
}
class Pi extends fe.ElementNode {
  constructor(t, o) {
    super(o);
    Tt(this, "__templateColumns");
    this.__templateColumns = t;
  }
  static getType() {
    return "layout-container";
  }
  static clone(t) {
    return new Pi(t.__templateColumns, t.__key);
  }
  createDOM(t) {
    const o = document.createElement("div");
    return o.style.gridTemplateColumns = this.__templateColumns, typeof t.theme.layoutContainer == "string" && Jt.addClassNamesToElement(o, t.theme.layoutContainer), o;
  }
  updateDOM(t, o) {
    return t.__templateColumns !== this.__templateColumns && (o.style.gridTemplateColumns = this.__templateColumns), !1;
  }
  static importDOM() {
    return {};
  }
  static importJSON(t) {
    return th(t.templateColumns);
  }
  canBeEmpty() {
    return !1;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      templateColumns: this.__templateColumns,
      type: "layout-container",
      version: 1
    };
  }
  getTemplateColumns() {
    return this.getLatest().__templateColumns;
  }
  setTemplateColumns(t) {
    this.getWritable().__templateColumns = t;
  }
}
function th(r) {
  return new Pi(r);
}
function ga(r) {
  return r instanceof Pi;
}
class Fi extends fe.ElementNode {
  static getType() {
    return "layout-item";
  }
  static clone(n) {
    return new Fi(n.__key);
  }
  createDOM(n) {
    const t = document.createElement("div");
    return typeof n.theme.layoutItem == "string" && Jt.addClassNamesToElement(t, n.theme.layoutItem), t;
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return {};
  }
  static importJSON() {
    return Jc();
  }
  isShadowRoot() {
    return !0;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "layout-item",
      version: 1
    };
  }
}
function Jc() {
  return new Fi();
}
function pf(r) {
  return r instanceof Fi;
}
const Fm = Er.lazy(() => import("./PollComponent-D3vDguV6.js"));
function Bm() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
}
function mf(r = "") {
  return {
    text: r,
    uid: Bm(),
    votes: []
  };
}
function _f(r, n, t) {
  return {
    text: n,
    uid: r.uid,
    votes: t || Array.from(r.votes)
  };
}
function Km(r) {
  const n = r.getAttribute("data-lexical-poll-question"), t = r.getAttribute("data-lexical-poll-options");
  return n !== null && t !== null ? { node: du(n, JSON.parse(t)) } : null;
}
class Ds extends fe.DecoratorNode {
  constructor(t, o, u) {
    super(u);
    Tt(this, "__question");
    Tt(this, "__options");
    this.__question = t, this.__options = o;
  }
  static getType() {
    return "poll";
  }
  static clone(t) {
    return new Ds(t.__question, t.__options, t.__key);
  }
  static importJSON(t) {
    const o = du(
      t.question,
      t.options
    );
    return t.options.forEach(o.addOption), o;
  }
  exportJSON() {
    return {
      options: this.__options,
      question: this.__question,
      type: "poll",
      version: 1
    };
  }
  addOption(t) {
    const o = this.getWritable(), u = Array.from(o.__options);
    u.push(t), o.__options = u;
  }
  deleteOption(t) {
    const o = this.getWritable(), u = Array.from(o.__options), p = u.indexOf(t);
    u.splice(p, 1), o.__options = u;
  }
  setOptionText(t, o) {
    const u = this.getWritable(), p = _f(t, o), m = Array.from(u.__options), f = m.indexOf(t);
    m[f] = p, u.__options = m;
  }
  toggleVote(t, o) {
    const u = this.getWritable(), p = t.votes, m = Array.from(p), f = p.indexOf(o);
    f === -1 ? m.push(o) : m.splice(f, 1);
    const O = _f(t, t.text, m), S = Array.from(u.__options), E = S.indexOf(t);
    S[E] = O, u.__options = S;
  }
  static importDOM() {
    return {
      span: (t) => t.hasAttribute("data-lexical-poll-question") ? {
        conversion: Km,
        priority: 2
      } : null
    };
  }
  exportDOM() {
    const t = document.createElement("span");
    return t.setAttribute("data-lexical-poll-question", this.__question), t.setAttribute(
      "data-lexical-poll-options",
      JSON.stringify(this.__options)
    ), { element: t };
  }
  createDOM() {
    const t = document.createElement("span");
    return t.style.display = "inline-block", t;
  }
  updateDOM() {
    return !1;
  }
  decorate() {
    return /* @__PURE__ */ U.jsx(Ki, { fallback: null, children: /* @__PURE__ */ U.jsx(
      Fm,
      {
        question: this.__question,
        options: this.__options,
        nodeKey: this.__key
      }
    ) });
  }
}
function du(r, n) {
  return new Ds(r, n);
}
function sE(r) {
  return r instanceof Ds;
}
const jm = Er.lazy(() => import("./InlineImageComponent-Cswp9tlQ.js"));
function Hm(r) {
  if (r instanceof HTMLImageElement) {
    const { alt: n, src: t, width: o, height: u } = r;
    return { node: fu({ altText: n, height: u, src: t, width: o }) };
  }
  return null;
}
class Ls extends fe.DecoratorNode {
  constructor(t, o, u, p, m, f, O, S) {
    super(S);
    Tt(this, "__src");
    Tt(this, "__altText");
    Tt(this, "__width");
    Tt(this, "__height");
    Tt(this, "__showCaption");
    Tt(this, "__caption");
    Tt(this, "__position");
    this.__src = t, this.__altText = o, this.__width = p || "inherit", this.__height = m || "inherit", this.__showCaption = f || !1, this.__caption = O || fe.createEditor(), this.__position = u;
  }
  static getType() {
    return "inline-image";
  }
  static clone(t) {
    return new Ls(
      t.__src,
      t.__altText,
      t.__position,
      t.__width,
      t.__height,
      t.__showCaption,
      t.__caption,
      t.__key
    );
  }
  static importJSON(t) {
    const { altText: o, height: u, width: p, caption: m, src: f, showCaption: O, position: S } = t, E = fu({
      altText: o,
      height: u,
      position: S,
      showCaption: O,
      src: f,
      width: p
    }), R = E.__caption, y = R.parseEditorState(m.editorState);
    return y.isEmpty() || R.setEditorState(y), E;
  }
  static importDOM() {
    return {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      img: (t) => ({
        conversion: Hm,
        priority: 0
      })
    };
  }
  exportDOM() {
    const t = document.createElement("img");
    return t.setAttribute("src", this.__src), t.setAttribute("alt", this.__altText), t.setAttribute("width", this.__width.toString()), t.setAttribute("height", this.__height.toString()), { element: t };
  }
  exportJSON() {
    return {
      altText: this.getAltText(),
      caption: this.__caption.toJSON(),
      height: this.__height === "inherit" ? 0 : this.__height,
      position: this.__position,
      showCaption: this.__showCaption,
      src: this.getSrc(),
      type: "inline-image",
      version: 1,
      width: this.__width === "inherit" ? 0 : this.__width
    };
  }
  getSrc() {
    return this.__src;
  }
  getAltText() {
    return this.__altText;
  }
  setAltText(t) {
    const o = this.getWritable();
    o.__altText = t;
  }
  setWidthAndHeight(t, o) {
    const u = this.getWritable();
    u.__width = t, u.__height = o;
  }
  getShowCaption() {
    return this.__showCaption;
  }
  setShowCaption(t) {
    const o = this.getWritable();
    o.__showCaption = t;
  }
  getPosition() {
    return this.__position;
  }
  setPosition(t) {
    const o = this.getWritable();
    o.__position = t;
  }
  update(t) {
    const o = this.getWritable(), { altText: u, showCaption: p, position: m } = t;
    u !== void 0 && (o.__altText = u), p !== void 0 && (o.__showCaption = p), m !== void 0 && (o.__position = m);
  }
  // View
  createDOM(t) {
    const o = document.createElement("span"), u = `${t.theme.inlineImage} position-${this.__position}`;
    return u !== void 0 && (o.className = u), o;
  }
  updateDOM(t, o, u) {
    const p = this.__position;
    if (p !== t.__position) {
      const m = `${u.theme.inlineImage} position-${p}`;
      m !== void 0 && (o.className = m);
    }
    return !1;
  }
  decorate() {
    return /* @__PURE__ */ U.jsx(Ki, { fallback: null, children: /* @__PURE__ */ U.jsx(
      jm,
      {
        src: this.__src,
        altText: this.__altText,
        width: this.__width,
        height: this.__height,
        nodeKey: this.getKey(),
        showCaption: this.__showCaption,
        caption: this.__caption,
        position: this.__position
      }
    ) });
  }
}
function fu({
  altText: r,
  position: n,
  height: t,
  src: o,
  width: u,
  showCaption: p,
  caption: m,
  key: f
}) {
  return fe.$applyNodeReplacement(
    new Ls(
      o,
      r,
      n,
      u,
      t,
      p,
      m,
      f
    )
  );
}
function Wm(r) {
  return r instanceof Ls;
}
const Um = Er.lazy(() => import("./StickyComponent-C22EmjHB.js"));
class vs extends fe.DecoratorNode {
  constructor(t, o, u, p, m) {
    super(m);
    Tt(this, "__x");
    Tt(this, "__y");
    Tt(this, "__color");
    Tt(this, "__caption");
    this.__x = t, this.__y = o, this.__caption = p || fe.createEditor(), this.__color = u;
  }
  static getType() {
    return "sticky";
  }
  static clone(t) {
    return new vs(
      t.__x,
      t.__y,
      t.__color,
      t.__caption,
      t.__key
    );
  }
  static importJSON(t) {
    const o = new vs(
      t.xOffset,
      t.yOffset,
      t.color
    ), u = t.caption, p = o.__caption, m = p.parseEditorState(u.editorState);
    return m.isEmpty() || p.setEditorState(m), o;
  }
  exportJSON() {
    return {
      caption: this.__caption.toJSON(),
      color: this.__color,
      type: "sticky",
      version: 1,
      xOffset: this.__x,
      yOffset: this.__y
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createDOM(t) {
    const o = document.createElement("div");
    return o.style.display = "contents", o;
  }
  updateDOM() {
    return !1;
  }
  setPosition(t, o) {
    const u = this.getWritable();
    u.__x = t, u.__y = o, fe.$setSelection(null);
  }
  toggleColor() {
    const t = this.getWritable();
    t.__color = t.__color === "pink" ? "yellow" : "pink";
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  decorate(t, o) {
    return Bo(
      /* @__PURE__ */ U.jsx(Ki, { fallback: null, children: /* @__PURE__ */ U.jsx(
        Um,
        {
          color: this.__color,
          x: this.__x,
          y: this.__y,
          nodeKey: this.getKey(),
          caption: this.__caption
        }
      ) }),
      document.body
    );
  }
  isIsolated() {
    return !0;
  }
}
function lE(r) {
  return r instanceof vs;
}
function Ym(r, n) {
  return new vs(r, n, "yellow");
}
const zm = [
  va.CodeNode,
  qp.MarkNode,
  Tr.HeadingNode,
  Tr.QuoteNode,
  Vn.ListNode,
  Vn.ListItemNode,
  dn.AutoLinkNode,
  dn.LinkNode,
  Cl.HorizontalRuleNode,
  Ms,
  xl,
  Rs,
  Os,
  El,
  Tl,
  yl,
  Li,
  Ii,
  $i,
  As,
  ki,
  Pi,
  Fi,
  Ds,
  Pp.HashtagNode,
  Ls,
  vt.TableNode,
  vt.TableRowNode,
  vt.TableCellNode,
  vs,
  Xp.OverflowNode
];
var ha = {}, pa = {}, Nf;
function qm() {
  if (Nf)
    return pa;
  Nf = 1;
  var r = kt(), n = St();
  const t = 0, o = 1, u = 2, p = 0, m = 1, f = 2, O = 3, S = 4;
  function E(C, x, I) {
    const W = C._nodeMap, $ = [];
    for (const B of x) {
      const L = W.get(B);
      L !== void 0 && $.push(L);
    }
    for (const [B, L] of I) {
      if (!L)
        continue;
      const P = W.get(B);
      P !== void 0 && !n.$isRootNode(P) && $.push(P);
    }
    return $;
  }
  function R(C, x, I, W, $) {
    if (C === null || I.size === 0 && W.size === 0 && !$)
      return p;
    const B = x._selection, L = C._selection;
    if ($)
      return m;
    if (!n.$isRangeSelection(B) || !n.$isRangeSelection(L) || !L.isCollapsed() || !B.isCollapsed())
      return p;
    const P = E(x, I, W);
    if (P.length === 0)
      return p;
    if (P.length > 1) {
      const q = x._nodeMap, Y = q.get(B.anchor.key), se = q.get(L.anchor.key);
      return Y && se && !C._nodeMap.has(Y.__key) && n.$isTextNode(Y) && Y.__text.length === 1 && B.anchor.offset === 1 ? f : p;
    }
    const F = P[0], Z = C._nodeMap.get(F.__key);
    if (!n.$isTextNode(Z) || !n.$isTextNode(F) || Z.__mode !== F.__mode)
      return p;
    const oe = Z.__text, ne = F.__text;
    if (oe === ne)
      return p;
    const te = B.anchor, K = L.anchor;
    if (te.key !== K.key || te.type !== "text")
      return p;
    const A = te.offset, z = K.offset, ie = ne.length - oe.length;
    return ie === 1 && z === A - 1 ? f : ie === -1 && z === A + 1 ? O : ie === -1 && z === A ? S : p;
  }
  function y(C, x, I) {
    const W = x._nodeMap.get(C), $ = I._nodeMap.get(C), B = x._selection, L = I._selection;
    let P = !1;
    return n.$isRangeSelection(B) && n.$isRangeSelection(L) && (P = B.anchor.type === "element" && B.focus.type === "element" && L.anchor.type === "text" && L.focus.type === "text"), !P && n.$isTextNode(W) && n.$isTextNode($) ? W.__type === $.__type && W.__text === $.__text && W.__mode === $.__mode && W.__detail === $.__detail && W.__style === $.__style && W.__format === $.__format && W.__parent === $.__parent : !1;
  }
  function g(C, x) {
    let I = Date.now(), W = p;
    return ($, B, L, P, F, Z) => {
      const oe = Date.now();
      if (Z.has("historic"))
        return W = p, I = oe, u;
      const ne = R($, B, P, F, C.isComposing()), te = (() => {
        const K = L === null || L.editor === C, A = Z.has("history-push");
        if (!A && K && Z.has("history-merge"))
          return t;
        if ($ === null)
          return o;
        const ie = B._selection;
        if (!(P.size > 0 || F.size > 0))
          return ie !== null ? t : u;
        if (A === !1 && ne !== p && ne === W && oe < I + x && K)
          return t;
        if (P.size === 1) {
          const Y = Array.from(P)[0];
          if (y(Y, $, B))
            return t;
        }
        return o;
      })();
      return I = oe, W = ne, te;
    };
  }
  function _(C, x) {
    const I = x.redoStack, W = x.undoStack;
    if (I.length !== 0) {
      const $ = x.current;
      $ !== null && (W.push($), C.dispatchCommand(n.CAN_UNDO_COMMAND, !0));
      const B = I.pop();
      I.length === 0 && C.dispatchCommand(n.CAN_REDO_COMMAND, !1), x.current = B || null, B && B.editor.setEditorState(B.editorState, {
        tag: "historic"
      });
    }
  }
  function N(C, x) {
    const I = x.redoStack, W = x.undoStack;
    if (W.length !== 0) {
      const B = x.current, L = W.pop();
      B !== null && (I.push(B), C.dispatchCommand(n.CAN_REDO_COMMAND, !0)), W.length === 0 && C.dispatchCommand(n.CAN_UNDO_COMMAND, !1), x.current = L || null, L && L.editor.setEditorState(L.editorState, {
        tag: "historic"
      });
    }
  }
  function w(C) {
    C.undoStack = [], C.redoStack = [], C.current = null;
  }
  function T(C, x, I) {
    const W = g(C, I), $ = ({
      editorState: P,
      prevEditorState: F,
      dirtyLeaves: Z,
      dirtyElements: oe,
      tags: ne
    }) => {
      const te = x.current, K = x.redoStack, A = x.undoStack, z = te === null ? null : te.editorState;
      if (te !== null && P === z)
        return;
      const ie = W(F, P, te, Z, oe, ne);
      if (ie === o)
        K.length !== 0 && (x.redoStack = [], C.dispatchCommand(n.CAN_REDO_COMMAND, !1)), te !== null && (A.push({
          ...te
        }), C.dispatchCommand(n.CAN_UNDO_COMMAND, !0));
      else if (ie === u)
        return;
      x.current = {
        editor: C,
        editorState: P
      };
    }, B = r.mergeRegister(C.registerCommand(n.UNDO_COMMAND, () => (N(C, x), !0), n.COMMAND_PRIORITY_EDITOR), C.registerCommand(n.REDO_COMMAND, () => (_(C, x), !0), n.COMMAND_PRIORITY_EDITOR), C.registerCommand(n.CLEAR_EDITOR_COMMAND, () => (w(x), !1), n.COMMAND_PRIORITY_EDITOR), C.registerCommand(n.CLEAR_HISTORY_COMMAND, () => (w(x), C.dispatchCommand(n.CAN_REDO_COMMAND, !1), C.dispatchCommand(n.CAN_UNDO_COMMAND, !1), !0), n.COMMAND_PRIORITY_EDITOR), C.registerUpdateListener($)), L = C.registerUpdateListener($);
    return () => {
      B(), L();
    };
  }
  function D() {
    return {
      current: null,
      redoStack: [],
      undoStack: []
    };
  }
  return pa.createEmptyHistoryState = D, pa.registerHistory = T, pa;
}
var ma = {}, Cf;
function Gm() {
  if (Cf)
    return ma;
  Cf = 1;
  var r = kt(), n = St();
  function t(u, p, m, f, O) {
    if (u === null || m.size === 0 && f.size === 0 && !O)
      return 0;
    var S = p._selection, E = u._selection;
    if (O)
      return 1;
    if (!(n.$isRangeSelection(S) && n.$isRangeSelection(E) && E.isCollapsed() && S.isCollapsed()))
      return 0;
    O = p._nodeMap;
    let R = [];
    for (let y of m)
      m = O.get(y), m !== void 0 && R.push(m);
    for (let [y, g] of f)
      g && (f = O.get(y), f === void 0 || n.$isRootNode(f) || R.push(f));
    return R.length === 0 ? 0 : 1 < R.length ? (f = p._nodeMap, p = f.get(S.anchor.key), E = f.get(E.anchor.key), p && E && !u._nodeMap.has(p.__key) && n.$isTextNode(p) && p.__text.length === 1 && S.anchor.offset === 1 ? 2 : 0) : (p = R[0], u = u._nodeMap.get(p.__key), !n.$isTextNode(u) || !n.$isTextNode(p) || u.__mode !== p.__mode || (u = u.__text, p = p.__text, u === p) || (S = S.anchor, E = E.anchor, S.key !== E.key || S.type !== "text") ? 0 : (S = S.offset, E = E.offset, u = p.length - u.length, u === 1 && E === S - 1 ? 2 : u === -1 && E === S + 1 ? 3 : u === -1 && E === S ? 4 : 0));
  }
  function o(u, p) {
    let m = Date.now(), f = 0;
    return (O, S, E, R, y, g) => {
      let _ = Date.now();
      if (g.has("historic"))
        return f = 0, m = _, 2;
      let N = t(O, S, R, y, u.isComposing()), w = (() => {
        var T = E === null || E.editor === u, D = g.has("history-push");
        if (!D && T && g.has("history-merge"))
          return 0;
        if (O === null)
          return 1;
        var C = S._selection;
        if (!(0 < R.size || 0 < y.size))
          return C !== null ? 0 : 2;
        if (D === !1 && N !== 0 && N === f && _ < m + p && T)
          return 0;
        if (R.size === 1) {
          {
            D = Array.from(R)[0], T = O._nodeMap.get(D), D = S._nodeMap.get(D), C = O._selection;
            let x = S._selection, I = !1;
            n.$isRangeSelection(C) && n.$isRangeSelection(x) && (I = C.anchor.type === "element" && C.focus.type === "element" && x.anchor.type === "text" && x.focus.type === "text"), T = !I && n.$isTextNode(T) && n.$isTextNode(D) ? T.__type === D.__type && T.__text === D.__text && T.__mode === D.__mode && T.__detail === D.__detail && T.__style === D.__style && T.__format === D.__format && T.__parent === D.__parent : !1;
          }
          if (T)
            return 0;
        }
        return 1;
      })();
      return m = _, f = N, w;
    };
  }
  return ma.createEmptyHistoryState = function() {
    return { current: null, redoStack: [], undoStack: [] };
  }, ma.registerHistory = function(u, p, m) {
    let f = o(u, m);
    m = ({ editorState: E, prevEditorState: R, dirtyLeaves: y, dirtyElements: g, tags: _ }) => {
      const N = p.current, w = p.redoStack, T = p.undoStack, D = N === null ? null : N.editorState;
      if (N === null || E !== D) {
        if (R = f(R, E, N, y, g, _), R === 1)
          w.length !== 0 && (p.redoStack = [], u.dispatchCommand(n.CAN_REDO_COMMAND, !1)), N !== null && (T.push({ ...N }), u.dispatchCommand(n.CAN_UNDO_COMMAND, !0));
        else if (R === 2)
          return;
        p.current = { editor: u, editorState: E };
      }
    };
    let O = r.mergeRegister(u.registerCommand(
      n.UNDO_COMMAND,
      () => {
        let E = p.redoStack, R = p.undoStack;
        if (R.length !== 0) {
          let y = p.current, g = R.pop();
          y !== null && (E.push(y), u.dispatchCommand(n.CAN_REDO_COMMAND, !0)), R.length === 0 && u.dispatchCommand(n.CAN_UNDO_COMMAND, !1), p.current = g || null, g && g.editor.setEditorState(g.editorState, { tag: "historic" });
        }
        return !0;
      },
      n.COMMAND_PRIORITY_EDITOR
    ), u.registerCommand(n.REDO_COMMAND, () => {
      let E = p.redoStack;
      var R = p.undoStack;
      if (E.length !== 0) {
        let y = p.current;
        y !== null && (R.push(y), u.dispatchCommand(n.CAN_UNDO_COMMAND, !0)), R = E.pop(), E.length === 0 && u.dispatchCommand(n.CAN_REDO_COMMAND, !1), p.current = R || null, R && R.editor.setEditorState(R.editorState, { tag: "historic" });
      }
      return !0;
    }, n.COMMAND_PRIORITY_EDITOR), u.registerCommand(n.CLEAR_EDITOR_COMMAND, () => (p.undoStack = [], p.redoStack = [], p.current = null, !1), n.COMMAND_PRIORITY_EDITOR), u.registerCommand(n.CLEAR_HISTORY_COMMAND, () => (p.undoStack = [], p.redoStack = [], p.current = null, u.dispatchCommand(n.CAN_REDO_COMMAND, !1), u.dispatchCommand(n.CAN_UNDO_COMMAND, !1), !0), n.COMMAND_PRIORITY_EDITOR), u.registerUpdateListener(m)), S = u.registerUpdateListener(m);
    return () => {
      O(), S();
    };
  }, ma;
}
var dc, xf;
function nh() {
  return xf || (xf = 1, dc = process.env.NODE_ENV === "development" ? qm() : Gm()), dc;
}
var Ef;
function Vm() {
  if (Ef)
    return ha;
  Ef = 1;
  var r = zt(), n = nh(), t = $t;
  function o(p, m, f = 1e3) {
    const O = t.useMemo(() => m || n.createEmptyHistoryState(), [m]);
    t.useEffect(() => n.registerHistory(p, O, f), [f, p, O]);
  }
  function u({
    externalHistoryState: p
  }) {
    const [m] = r.useLexicalComposerContext();
    return o(m, p), null;
  }
  return ha.createEmptyHistoryState = n.createEmptyHistoryState, ha.HistoryPlugin = u, ha;
}
var _a = {}, Tf;
function Jm() {
  if (Tf)
    return _a;
  Tf = 1;
  var r = zt(), n = nh(), t = $t;
  function o(u, p, m = 1e3) {
    let f = t.useMemo(() => p || n.createEmptyHistoryState(), [p]);
    t.useEffect(() => n.registerHistory(u, f, m), [m, u, f]);
  }
  return _a.createEmptyHistoryState = n.createEmptyHistoryState, _a.HistoryPlugin = function({ externalHistoryState: u }) {
    let [p] = r.useLexicalComposerContext();
    return o(p, u), null;
  }, _a;
}
const Xm = process.env.NODE_ENV === "development" ? Vm() : Jm();
var rh = Xm;
const oh = Rg({}), Zm = ({
  children: r,
  initHistoryState: n
}) => {
  const t = Zr(
    () => ({ historyState: n || rh.createEmptyHistoryState() }),
    []
  );
  return /* @__PURE__ */ U.jsx(oh.Provider, { value: t, children: r });
}, Qm = () => pp(oh);
var fc = {}, gc, yf;
function e_() {
  if (yf)
    return gc;
  yf = 1;
  var r = zt(), n = $t, u = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? n.useLayoutEffect : n.useEffect;
  function p(O) {
    const [S] = r.useLexicalComposerContext(), E = n.useMemo(() => O(S), [S, O]), R = n.useRef(E.initialValueFn()), [y, g] = n.useState(R.current);
    return u(() => {
      const {
        initialValueFn: _,
        subscribe: N
      } = E, w = _();
      return R.current !== w && (R.current = w, g(w)), N((T) => {
        R.current = T, g(T);
      });
    }, [E, O]), y;
  }
  function m(O) {
    return {
      initialValueFn: () => O.isEditable(),
      subscribe: (S) => O.registerEditableListener(S)
    };
  }
  function f() {
    return p(m);
  }
  return gc = f, gc;
}
var hc, Sf;
function t_() {
  if (Sf)
    return hc;
  Sf = 1;
  var r = zt(), n = $t, t = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? n.useLayoutEffect : n.useEffect;
  function o(p) {
    let [m] = r.useLexicalComposerContext(), f = n.useMemo(() => p(m), [m, p]), O = n.useRef(f.initialValueFn()), [S, E] = n.useState(O.current);
    return t(() => {
      let { initialValueFn: R, subscribe: y } = f, g = R();
      return O.current !== g && (O.current = g, E(g)), y((_) => {
        O.current = _, E(_);
      });
    }, [f, p]), S;
  }
  function u(p) {
    return { initialValueFn: () => p.isEditable(), subscribe: (m) => p.registerEditableListener(m) };
  }
  return hc = function() {
    return o(u);
  }, hc;
}
var pc, Of;
function gu() {
  return Of || (Of = 1, pc = process.env.NODE_ENV === "development" ? e_() : t_()), pc;
}
var Lo = {}, vf;
function n_() {
  if (vf)
    return Lo;
  vf = 1;
  var r = St();
  function n(O, S) {
    let E = O.getFirstChild(), R = 0;
    e:
      for (; E !== null; ) {
        if (r.$isElementNode(E)) {
          const _ = E.getFirstChild();
          if (_ !== null) {
            E = _;
            continue;
          }
        } else if (r.$isTextNode(E)) {
          const _ = E.getTextContentSize();
          if (R + _ > S)
            return {
              node: E,
              offset: S - R
            };
          R += _;
        }
        const y = E.getNextSibling();
        if (y !== null) {
          E = y;
          continue;
        }
        let g = E.getParent();
        for (; g !== null; ) {
          const _ = g.getNextSibling();
          if (_ !== null) {
            E = _;
            continue e;
          }
          g = g.getParent();
        }
        break;
      }
    return null;
  }
  function t(O, S = !0) {
    if (O)
      return !1;
    let E = u();
    return S && (E = E.trim()), E === "";
  }
  function o(O, S) {
    return () => t(O, S);
  }
  function u() {
    return r.$getRoot().getTextContent();
  }
  function p(O) {
    if (!t(O, !1))
      return !1;
    const E = r.$getRoot().getChildren(), R = E.length;
    if (R > 1)
      return !1;
    for (let y = 0; y < R; y++) {
      const g = E[y];
      if (r.$isDecoratorNode(g))
        return !1;
      if (r.$isElementNode(g)) {
        if (!r.$isParagraphNode(g) || g.__indent !== 0)
          return !1;
        const _ = g.getChildren(), N = _.length;
        for (let w = 0; w < N; w++) {
          const T = _[y];
          if (!r.$isTextNode(T))
            return !1;
        }
      }
    }
    return !0;
  }
  function m(O) {
    return () => p(O);
  }
  function f(O, S, E, R) {
    const y = (C) => C instanceof E, g = (C) => {
      const x = r.$createTextNode(C.getTextContent());
      x.setFormat(C.getFormat()), C.replace(x);
    }, _ = (C) => C.getLatest().__mode, N = (C) => {
      if (!C.isSimpleText())
        return;
      const x = C.getPreviousSibling();
      let I = C.getTextContent(), W = C, $;
      if (r.$isTextNode(x)) {
        const B = x.getTextContent(), L = B + I, P = S(L);
        if (y(x))
          if (P === null || _(x) !== 0) {
            g(x);
            return;
          } else {
            const F = P.end - B.length;
            if (F > 0) {
              const Z = I.slice(0, F), oe = B + Z;
              if (x.select(), x.setTextContent(oe), F === I.length)
                C.remove();
              else {
                const ne = I.slice(F);
                C.setTextContent(ne);
              }
              return;
            }
          }
        else if (P === null || P.start < B.length)
          return;
      }
      for (; ; ) {
        $ = S(I);
        let B = $ === null ? "" : I.slice($.end);
        if (I = B, B === "") {
          const F = W.getNextSibling();
          if (r.$isTextNode(F)) {
            B = W.getTextContent() + F.getTextContent();
            const Z = S(B);
            if (Z === null) {
              y(F) ? g(F) : F.markDirty();
              return;
            } else if (Z.start !== 0)
              return;
          }
        } else {
          const F = S(B);
          if (F !== null && F.start === 0)
            return;
        }
        if ($ === null)
          return;
        if ($.start === 0 && r.$isTextNode(x) && x.isTextEntity())
          continue;
        let L;
        $.start === 0 ? [L, W] = W.splitText($.end) : [, L, W] = W.splitText($.start, $.end);
        const P = R(L);
        if (P.setFormat(L.getFormat()), L.replace(P), W == null)
          return;
      }
    }, w = (C) => {
      const x = C.getTextContent(), I = S(x);
      if (I === null || I.start !== 0) {
        g(C);
        return;
      }
      if (x.length > I.end) {
        C.splitText(I.end);
        return;
      }
      const W = C.getPreviousSibling();
      r.$isTextNode(W) && W.isTextEntity() && (g(W), g(C));
      const $ = C.getNextSibling();
      r.$isTextNode($) && $.isTextEntity() && (g($), y(C) && g(C));
    }, T = O.registerNodeTransform(r.TextNode, N), D = O.registerNodeTransform(E, w);
    return [T, D];
  }
  return Lo.$canShowPlaceholder = p, Lo.$canShowPlaceholderCurry = m, Lo.$findTextIntersectionFromCharacters = n, Lo.$isRootTextContentEmpty = t, Lo.$isRootTextContentEmptyCurry = o, Lo.$rootTextContent = u, Lo.registerLexicalTextEntity = f, Lo;
}
var Io = {}, wf;
function r_() {
  if (wf)
    return Io;
  wf = 1;
  var r = St();
  function n(u, p = !0) {
    return u ? !1 : (u = t(), p && (u = u.trim()), u === "");
  }
  function t() {
    return r.$getRoot().getTextContent();
  }
  function o(u) {
    if (!n(u, !1))
      return !1;
    u = r.$getRoot().getChildren();
    let p = u.length;
    if (1 < p)
      return !1;
    for (let f = 0; f < p; f++) {
      var m = u[f];
      if (r.$isDecoratorNode(m))
        return !1;
      if (r.$isElementNode(m)) {
        if (!r.$isParagraphNode(m) || m.__indent !== 0)
          return !1;
        m = m.getChildren();
        let O = m.length;
        for (let S = 0; S < O; S++)
          if (!r.$isTextNode(m[f]))
            return !1;
      }
    }
    return !0;
  }
  return Io.$canShowPlaceholder = o, Io.$canShowPlaceholderCurry = function(u) {
    return () => o(u);
  }, Io.$findTextIntersectionFromCharacters = function(u, p) {
    var m = u.getFirstChild();
    u = 0;
    e:
      for (; m !== null; ) {
        if (r.$isElementNode(m)) {
          var f = m.getFirstChild();
          if (f !== null) {
            m = f;
            continue;
          }
        } else if (r.$isTextNode(m)) {
          if (f = m.getTextContentSize(), u + f > p)
            return { node: m, offset: p - u };
          u += f;
        }
        if (f = m.getNextSibling(), f !== null)
          m = f;
        else {
          for (m = m.getParent(); m !== null; ) {
            if (f = m.getNextSibling(), f !== null) {
              m = f;
              continue e;
            }
            m = m.getParent();
          }
          break;
        }
      }
    return null;
  }, Io.$isRootTextContentEmpty = n, Io.$isRootTextContentEmptyCurry = function(u, p) {
    return () => n(u, p);
  }, Io.$rootTextContent = t, Io.registerLexicalTextEntity = function(u, p, m, f) {
    let O = (E) => {
      const R = r.$createTextNode(E.getTextContent());
      R.setFormat(E.getFormat()), E.replace(R);
    }, S = u.registerNodeTransform(r.TextNode, (E) => {
      if (E.isSimpleText()) {
        var R = E.getPreviousSibling(), y = E.getTextContent(), g = E;
        if (r.$isTextNode(R)) {
          var _ = R.getTextContent(), N = p(_ + y);
          if (R instanceof m) {
            if (N === null || R.getLatest().__mode !== 0) {
              O(R);
              return;
            }
            if (N = N.end - _.length, 0 < N) {
              g = y.slice(0, N), g = _ + g, R.select(), R.setTextContent(g), N === y.length ? E.remove() : (R = y.slice(N), E.setTextContent(R));
              return;
            }
          } else if (N === null || N.start < _.length)
            return;
        }
        for (; ; ) {
          if (E = p(y), y = N = E === null ? "" : y.slice(E.end), N === "") {
            if (_ = g.getNextSibling(), r.$isTextNode(_)) {
              if (N = g.getTextContent() + _.getTextContent(), N = p(N), N === null) {
                _ instanceof m ? O(_) : _.markDirty();
                break;
              } else if (N.start !== 0)
                break;
            }
          } else if (_ = p(N), _ !== null && _.start === 0)
            break;
          if (E === null)
            break;
          if (E.start === 0 && r.$isTextNode(R) && R.isTextEntity())
            continue;
          let w;
          if (E.start === 0 ? [w, g] = g.splitText(E.end) : [, w, g] = g.splitText(E.start, E.end), E = f(w), E.setFormat(w.getFormat()), w.replace(E), g == null)
            break;
        }
      }
    });
    return u = u.registerNodeTransform(m, (E) => {
      var R = E.getTextContent();
      const y = p(R);
      y === null || y.start !== 0 ? O(E) : R.length > y.end ? E.splitText(y.end) : (R = E.getPreviousSibling(), r.$isTextNode(R) && R.isTextEntity() && (O(R), O(E)), R = E.getNextSibling(), r.$isTextNode(R) && R.isTextEntity() && (O(R), E instanceof m && O(E)));
    }), [S, u];
  }, Io;
}
var mc, Mf;
function Ra() {
  return Mf || (Mf = 1, mc = process.env.NODE_ENV === "development" ? n_() : r_()), mc;
}
var _c = {}, Rf;
function o_() {
  if (Rf)
    return _c;
  Rf = 1;
  var r = St();
  function n(t) {
    const o = window.location.origin, u = (p) => {
      if (p.origin !== o)
        return;
      const m = t.getRootElement();
      if (document.activeElement !== m)
        return;
      const f = p.data;
      if (typeof f == "string") {
        let O;
        try {
          O = JSON.parse(f);
        } catch {
          return;
        }
        if (O && O.protocol === "nuanria_messaging" && O.type === "request") {
          const S = O.payload;
          if (S && S.functionId === "makeChanges") {
            const E = S.args;
            if (E) {
              const [R, y, g, _, N, w] = E;
              t.update(() => {
                const T = r.$getSelection();
                if (r.$isRangeSelection(T)) {
                  const D = T.anchor;
                  let C = D.getNode(), x = 0, I = 0;
                  if (r.$isTextNode(C) && R >= 0 && y >= 0 && (x = R, I = R + y, T.setTextNodeRange(C, x, C, I)), (x !== I || g !== "") && (T.insertRawText(g), C = D.getNode()), r.$isTextNode(C)) {
                    x = _, I = _ + N;
                    const W = C.getTextContentSize();
                    x = x > W ? W : x, I = I > W ? W : I, T.setTextNodeRange(C, x, C, I);
                  }
                  p.stopImmediatePropagation();
                }
              });
            }
          }
        }
      }
    };
    return window.addEventListener("message", u, !0), () => {
      window.removeEventListener("message", u, !0);
    };
  }
  return _c.registerDragonSupport = n, _c;
}
var Nc = {}, bf;
function i_() {
  if (bf)
    return Nc;
  bf = 1;
  var r = St();
  return Nc.registerDragonSupport = function(n) {
    let t = window.location.origin, o = (u) => {
      if (u.origin === t) {
        var p = n.getRootElement();
        if (document.activeElement === p && (p = u.data, typeof p == "string")) {
          try {
            var m = JSON.parse(p);
          } catch {
            return;
          }
          if (m && m.protocol === "nuanria_messaging" && m.type === "request" && (m = m.payload) && m.functionId === "makeChanges" && (m = m.args)) {
            const [f, O, S, E, R] = m;
            n.update(() => {
              const y = r.$getSelection();
              if (r.$isRangeSelection(y)) {
                var g = y.anchor;
                let _ = g.getNode(), N = 0, w = 0;
                r.$isTextNode(_) && 0 <= f && 0 <= O && (N = f, w = f + O, y.setTextNodeRange(_, N, _, w)), (N !== w || S !== "") && (y.insertRawText(S), _ = g.getNode()), r.$isTextNode(_) && (N = E, w = E + R, g = _.getTextContentSize(), N = N > g ? g : N, w = w > g ? g : w, y.setTextNodeRange(_, N, _, w)), u.stopImmediatePropagation();
              }
            });
          }
        }
      }
    };
    return window.addEventListener("message", o, !0), () => {
      window.removeEventListener("message", o, !0);
    };
  }, Nc;
}
var Cc, Af;
function ih() {
  return Af || (Af = 1, Cc = process.env.NODE_ENV === "development" ? o_() : i_()), Cc;
}
var Df;
function s_() {
  if (Df)
    return fc;
  Df = 1;
  var r = zt(), n = gu(), t = $t, o = Ra(), u = kt(), p = Ag, m = ih(), f = Tr, E = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  function R(T) {
    return T.getEditorState().read(o.$canShowPlaceholderCurry(T.isComposing()));
  }
  function y(T) {
    const [D, C] = t.useState(() => R(T));
    return E(() => {
      function x() {
        const I = R(T);
        C(I);
      }
      return x(), u.mergeRegister(T.registerUpdateListener(() => {
        x();
      }), T.registerEditableListener(() => {
        x();
      }));
    }, [T]), D;
  }
  function g(T, D) {
    const [C, x] = t.useState(() => T.getDecorators());
    return E(() => T.registerDecoratorListener((I) => {
      p.flushSync(() => {
        x(I);
      });
    }), [T]), t.useEffect(() => {
      x(T.getDecorators());
    }, [T]), t.useMemo(() => {
      const I = [], W = Object.keys(C);
      for (let $ = 0; $ < W.length; $++) {
        const B = W[$], L = /* @__PURE__ */ t.createElement(D, {
          onError: (F) => T._onError(F)
        }, /* @__PURE__ */ t.createElement(t.Suspense, {
          fallback: null
        }, C[B])), P = T.getElementByKey(B);
        P !== null && I.push(/* @__PURE__ */ p.createPortal(L, P, B));
      }
      return I;
    }, [D, C, T]);
  }
  function _(T) {
    E(() => u.mergeRegister(f.registerRichText(T), m.registerDragonSupport(T)), [T]);
  }
  function N({
    contentEditable: T,
    placeholder: D,
    ErrorBoundary: C
  }) {
    const [x] = r.useLexicalComposerContext(), I = g(x, C);
    return _(x), /* @__PURE__ */ t.createElement(t.Fragment, null, T, /* @__PURE__ */ t.createElement(w, {
      content: D
    }), I);
  }
  function w({
    content: T
  }) {
    const [D] = r.useLexicalComposerContext(), C = y(D), x = n();
    return C ? typeof T == "function" ? T(x) : T : null;
  }
  return fc.RichTextPlugin = N, fc;
}
var xc = {}, Lf;
function l_() {
  if (Lf)
    return xc;
  Lf = 1;
  var r = zt(), n = gu(), t = $t, o = Ra(), u = kt(), p = Ag, m = ih(), f = Tr, O = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  function S(_) {
    return _.getEditorState().read(o.$canShowPlaceholderCurry(_.isComposing()));
  }
  function E(_) {
    let [N, w] = t.useState(() => S(_));
    return O(() => {
      function T() {
        let D = S(_);
        w(D);
      }
      return T(), u.mergeRegister(_.registerUpdateListener(() => {
        T();
      }), _.registerEditableListener(() => {
        T();
      }));
    }, [_]), N;
  }
  function R(_, N) {
    let [w, T] = t.useState(() => _.getDecorators());
    return O(() => _.registerDecoratorListener((D) => {
      p.flushSync(() => {
        T(D);
      });
    }), [_]), t.useEffect(() => {
      T(_.getDecorators());
    }, [_]), t.useMemo(() => {
      let D = [], C = Object.keys(w);
      for (let x = 0; x < C.length; x++) {
        let I = C[x], W = t.createElement(N, { onError: (B) => _._onError(B) }, t.createElement(t.Suspense, { fallback: null }, w[I])), $ = _.getElementByKey(I);
        $ !== null && D.push(p.createPortal(W, $, I));
      }
      return D;
    }, [N, w, _]);
  }
  function y(_) {
    O(() => u.mergeRegister(f.registerRichText(_), m.registerDragonSupport(_)), [_]);
  }
  function g({ content: _ }) {
    var [N] = r.useLexicalComposerContext();
    N = E(N);
    let w = n();
    return N ? typeof _ == "function" ? _(w) : _ : null;
  }
  return xc.RichTextPlugin = function({ contentEditable: _, placeholder: N, ErrorBoundary: w }) {
    let [T] = r.useLexicalComposerContext();
    return w = R(T, w), y(T), t.createElement(t.Fragment, null, _, t.createElement(g, { content: N }), w);
  }, xc;
}
const a_ = process.env.NODE_ENV === "development" ? s_() : l_();
var c_ = a_, Ec, If;
function u_() {
  if (If)
    return Ec;
  If = 1;
  var r = $t;
  function n(f, O) {
    return n = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(E, R) {
      return E.__proto__ = R, E;
    }, n(f, O);
  }
  function t(f, O) {
    f.prototype = Object.create(O.prototype), f.prototype.constructor = f, n(f, O);
  }
  var o = function(O, S) {
    return O === void 0 && (O = []), S === void 0 && (S = []), O.length !== S.length || O.some(function(E, R) {
      return !Object.is(E, S[R]);
    });
  }, u = {
    error: null
  }, p = /* @__PURE__ */ function(f) {
    t(O, f);
    function O() {
      for (var E, R = arguments.length, y = new Array(R), g = 0; g < R; g++)
        y[g] = arguments[g];
      return E = f.call.apply(f, [this].concat(y)) || this, E.state = u, E.resetErrorBoundary = function() {
        for (var _, N = arguments.length, w = new Array(N), T = 0; T < N; T++)
          w[T] = arguments[T];
        E.props.onReset == null || (_ = E.props).onReset.apply(_, w), E.reset();
      }, E;
    }
    O.getDerivedStateFromError = function(R) {
      return {
        error: R
      };
    };
    var S = O.prototype;
    return S.reset = function() {
      this.setState(u);
    }, S.componentDidCatch = function(R, y) {
      var g, _;
      (g = (_ = this.props).onError) == null || g.call(_, R, y);
    }, S.componentDidUpdate = function(R, y) {
      var g = this.state.error, _ = this.props.resetKeys;
      if (g !== null && y.error !== null && o(R.resetKeys, _)) {
        var N, w;
        (N = (w = this.props).onResetKeysChange) == null || N.call(w, R.resetKeys, _), this.reset();
      }
    }, S.render = function() {
      var R = this.state.error, y = this.props, g = y.fallbackRender, _ = y.FallbackComponent, N = y.fallback;
      if (R !== null) {
        var w = {
          error: R,
          resetErrorBoundary: this.resetErrorBoundary
        };
        if (/* @__PURE__ */ r.isValidElement(N))
          return N;
        if (typeof g == "function")
          return g(w);
        if (_)
          return /* @__PURE__ */ r.createElement(_, w);
        throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
      }
      return this.props.children;
    }, O;
  }(r.Component);
  function m({
    children: f,
    onError: O
  }) {
    return /* @__PURE__ */ r.createElement(p, {
      fallback: /* @__PURE__ */ r.createElement("div", {
        style: {
          border: "1px solid #f00",
          color: "#f00",
          padding: "8px"
        }
      }, "An error was thrown."),
      onError: O
    }, f);
  }
  return Ec = m, Ec;
}
var Tc, $f;
function d_() {
  if ($f)
    return Tc;
  $f = 1;
  var r = $t;
  function n(m, f) {
    return n = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(O, S) {
      return O.__proto__ = S, O;
    }, n(m, f);
  }
  function t(m, f) {
    m.prototype = Object.create(f.prototype), m.prototype.constructor = m, n(m, f);
  }
  function o(m, f) {
    return m === void 0 && (m = []), f === void 0 && (f = []), m.length !== f.length || m.some(function(O, S) {
      return !Object.is(O, f[S]);
    });
  }
  var u = { error: null }, p = function(m) {
    function f() {
      for (var S, E = arguments.length, R = Array(E), y = 0; y < E; y++)
        R[y] = arguments[y];
      return S = m.call.apply(m, [this].concat(R)) || this, S.state = u, S.resetErrorBoundary = function() {
        for (var g, _ = arguments.length, N = Array(_), w = 0; w < _; w++)
          N[w] = arguments[w];
        S.props.onReset == null || (g = S.props).onReset.apply(g, N), S.reset();
      }, S;
    }
    t(f, m), f.getDerivedStateFromError = function(S) {
      return { error: S };
    };
    var O = f.prototype;
    return O.reset = function() {
      this.setState(u);
    }, O.componentDidCatch = function(S, E) {
      var R, y;
      (R = (y = this.props).onError) == null || R.call(y, S, E);
    }, O.componentDidUpdate = function(S, E) {
      var R = this.props.resetKeys;
      if (this.state.error !== null && E.error !== null && o(S.resetKeys, R)) {
        var y, g;
        (y = (g = this.props).onResetKeysChange) == null || y.call(g, S.resetKeys, R), this.reset();
      }
    }, O.render = function() {
      var S = this.state.error, E = this.props, R = E.fallbackRender, y = E.FallbackComponent;
      if (E = E.fallback, S !== null) {
        if (S = { error: S, resetErrorBoundary: this.resetErrorBoundary }, r.isValidElement(E))
          return E;
        if (typeof R == "function")
          return R(S);
        if (y)
          return r.createElement(y, S);
        throw Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
      }
      return this.props.children;
    }, f;
  }(r.Component);
  return Tc = function({ children: m, onError: f }) {
    return r.createElement(p, { fallback: r.createElement("div", { style: { border: "1px solid #f00", color: "#f00", padding: "8px" } }, "An error was thrown."), onError: f }, m);
  }, Tc;
}
const f_ = process.env.NODE_ENV === "development" ? u_() : d_();
var g_ = f_;
const h_ = /* @__PURE__ */ Dg(g_);
var yc = {}, kf;
function p_() {
  if (kf)
    return yc;
  kf = 1;
  var r = zt(), n = $t;
  function t({
    defaultSelection: o
  }) {
    const [u] = r.useLexicalComposerContext();
    return n.useEffect(() => {
      u.focus(() => {
        const p = document.activeElement, m = u.getRootElement();
        m !== null && (p === null || !m.contains(p)) && m.focus({
          preventScroll: !0
        });
      }, {
        defaultSelection: o
      });
    }, [o, u]), null;
  }
  return yc.AutoFocusPlugin = t, yc;
}
var Sc = {}, Pf;
function m_() {
  if (Pf)
    return Sc;
  Pf = 1;
  var r = zt(), n = $t;
  return Sc.AutoFocusPlugin = function({ defaultSelection: t }) {
    let [o] = r.useLexicalComposerContext();
    return n.useEffect(() => {
      o.focus(() => {
        let u = document.activeElement, p = o.getRootElement();
        p === null || u !== null && p.contains(u) || p.focus({ preventScroll: !0 });
      }, { defaultSelection: t });
    }, [t, o]), null;
  }, Sc;
}
const __ = process.env.NODE_ENV === "development" ? p_() : m_();
var N_ = __, Na = {}, Ff;
function C_() {
  if (Ff)
    return Na;
  Ff = 1;
  var r = zt(), n = kt(), t = St(), o = $t;
  function u(f) {
    const O = f.getNodes();
    if (n.$filter(O, (N) => t.$isBlockElementNode(N) && N.canIndent() ? N : null).length > 0)
      return !0;
    const E = f.anchor, R = f.focus, y = R.isBefore(E) ? R : E, g = y.getNode(), _ = n.$getNearestBlockElementAncestorOrThrow(g);
    if (_.canIndent()) {
      const N = _.getKey();
      let w = t.$createRangeSelection();
      if (w.anchor.set(N, 0, "element"), w.focus.set(N, 0, "element"), w = t.$normalizeSelection__EXPERIMENTAL(w), w.anchor.is(y))
        return !0;
    }
    return !1;
  }
  function p(f) {
    return f.registerCommand(t.KEY_TAB_COMMAND, (O) => {
      const S = t.$getSelection();
      if (!t.$isRangeSelection(S))
        return !1;
      O.preventDefault();
      const E = u(S) ? O.shiftKey ? t.OUTDENT_CONTENT_COMMAND : t.INDENT_CONTENT_COMMAND : t.INSERT_TAB_COMMAND;
      return f.dispatchCommand(E, void 0);
    }, t.COMMAND_PRIORITY_EDITOR);
  }
  function m() {
    const [f] = r.useLexicalComposerContext();
    return o.useEffect(() => p(f)), null;
  }
  return Na.TabIndentationPlugin = m, Na.registerTabIndentation = p, Na;
}
var Ca = {}, Bf;
function x_() {
  if (Bf)
    return Ca;
  Bf = 1;
  var r = zt(), n = kt(), t = St(), o = $t;
  function u(m) {
    var f = m.getNodes();
    if (0 < n.$filter(f, (O) => t.$isBlockElementNode(O) && O.canIndent() ? O : null).length)
      return !0;
    if (f = m.anchor, m = m.focus, m = m.isBefore(f) ? m : f, f = m.getNode(), f = n.$getNearestBlockElementAncestorOrThrow(f), f.canIndent()) {
      f = f.getKey();
      let O = t.$createRangeSelection();
      if (O.anchor.set(f, 0, "element"), O.focus.set(f, 0, "element"), O = t.$normalizeSelection__EXPERIMENTAL(O), O.anchor.is(m))
        return !0;
    }
    return !1;
  }
  function p(m) {
    return m.registerCommand(t.KEY_TAB_COMMAND, (f) => {
      let O = t.$getSelection();
      return t.$isRangeSelection(O) ? (f.preventDefault(), f = u(O) ? f.shiftKey ? t.OUTDENT_CONTENT_COMMAND : t.INDENT_CONTENT_COMMAND : t.INSERT_TAB_COMMAND, m.dispatchCommand(f, void 0)) : !1;
    }, t.COMMAND_PRIORITY_EDITOR);
  }
  return Ca.TabIndentationPlugin = function() {
    let [m] = r.useLexicalComposerContext();
    return o.useEffect(() => p(m)), null;
  }, Ca.registerTabIndentation = p, Ca;
}
const E_ = process.env.NODE_ENV === "development" ? C_() : x_();
var T_ = E_, Oc = {}, Kf;
function y_() {
  if (Kf)
    return Oc;
  Kf = 1;
  var r = zt(), n = Cl, t = kt(), o = St(), u = $t;
  function p() {
    const [m] = r.useLexicalComposerContext();
    return u.useEffect(() => m.registerCommand(n.INSERT_HORIZONTAL_RULE_COMMAND, (f) => {
      const O = o.$getSelection();
      if (!o.$isRangeSelection(O))
        return !1;
      if (O.focus.getNode() !== null) {
        const E = n.$createHorizontalRuleNode();
        t.$insertNodeToNearestRoot(E);
      }
      return !0;
    }, o.COMMAND_PRIORITY_EDITOR), [m]), null;
  }
  return Oc.HorizontalRulePlugin = p, Oc;
}
var vc = {}, jf;
function S_() {
  if (jf)
    return vc;
  jf = 1;
  var r = zt(), n = Cl, t = kt(), o = St(), u = $t;
  return vc.HorizontalRulePlugin = function() {
    let [p] = r.useLexicalComposerContext();
    return u.useEffect(() => p.registerCommand(n.INSERT_HORIZONTAL_RULE_COMMAND, () => {
      var m = o.$getSelection();
      return o.$isRangeSelection(m) ? (m.focus.getNode() !== null && (m = n.$createHorizontalRuleNode(), t.$insertNodeToNearestRoot(m)), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), [p]), null;
  }, vc;
}
const O_ = process.env.NODE_ENV === "development" ? y_() : S_();
var v_ = O_;
function w_({
  children: r,
  className: n
}) {
  return /* @__PURE__ */ U.jsx("div", { className: n || "placeholder__root", children: r });
}
var wc = {}, Hf;
function M_() {
  if (Hf)
    return wc;
  Hf = 1;
  var r = zt(), n = $t;
  function t() {
    return t = Object.assign ? Object.assign.bind() : function(f) {
      for (var O = 1; O < arguments.length; O++) {
        var S = arguments[O];
        for (var E in S)
          Object.prototype.hasOwnProperty.call(S, E) && (f[E] = S[E]);
      }
      return f;
    }, t.apply(this, arguments);
  }
  var p = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? n.useLayoutEffect : n.useEffect;
  function m({
    ariaActiveDescendant: f,
    ariaAutoComplete: O,
    ariaControls: S,
    ariaDescribedBy: E,
    ariaExpanded: R,
    ariaLabel: y,
    ariaLabelledBy: g,
    ariaMultiline: _,
    ariaOwns: N,
    ariaRequired: w,
    autoCapitalize: T,
    className: D,
    id: C,
    role: x = "textbox",
    spellCheck: I = !0,
    style: W,
    tabIndex: $,
    "data-testid": B,
    ...L
  }) {
    const [P] = r.useLexicalComposerContext(), [F, Z] = n.useState(!1), oe = n.useCallback((ne) => {
      P.setRootElement(ne);
    }, [P]);
    return p(() => (Z(P.isEditable()), P.registerEditableListener((ne) => {
      Z(ne);
    })), [P]), /* @__PURE__ */ n.createElement("div", t({}, L, {
      "aria-activedescendant": F ? f : void 0,
      "aria-autocomplete": F ? O : "none",
      "aria-controls": F ? S : void 0,
      "aria-describedby": E,
      "aria-expanded": F && x === "combobox" ? !!R : void 0,
      "aria-label": y,
      "aria-labelledby": g,
      "aria-multiline": _,
      "aria-owns": F ? N : void 0,
      "aria-readonly": F ? void 0 : !0,
      "aria-required": w,
      autoCapitalize: T,
      className: D,
      contentEditable: F,
      "data-testid": B,
      id: C,
      ref: oe,
      role: x,
      spellCheck: I,
      style: W,
      tabIndex: $
    }));
  }
  return wc.ContentEditable = m, wc;
}
var Mc = {}, Wf;
function R_() {
  if (Wf)
    return Mc;
  Wf = 1;
  var r = zt(), n = $t;
  function t() {
    return t = Object.assign ? Object.assign.bind() : function(u) {
      for (var p = 1; p < arguments.length; p++) {
        var m = arguments[p], f;
        for (f in m)
          Object.prototype.hasOwnProperty.call(m, f) && (u[f] = m[f]);
      }
      return u;
    }, t.apply(this, arguments);
  }
  var o = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? n.useLayoutEffect : n.useEffect;
  return Mc.ContentEditable = function({ ariaActiveDescendant: u, ariaAutoComplete: p, ariaControls: m, ariaDescribedBy: f, ariaExpanded: O, ariaLabel: S, ariaLabelledBy: E, ariaMultiline: R, ariaOwns: y, ariaRequired: g, autoCapitalize: _, className: N, id: w, role: T = "textbox", spellCheck: D = !0, style: C, tabIndex: x, "data-testid": I, ...W }) {
    let [$] = r.useLexicalComposerContext(), [B, L] = n.useState(!1), P = n.useCallback((F) => {
      $.setRootElement(F);
    }, [$]);
    return o(() => (L($.isEditable()), $.registerEditableListener((F) => {
      L(F);
    })), [$]), n.createElement(
      "div",
      t({}, W, { "aria-activedescendant": B ? u : void 0, "aria-autocomplete": B ? p : "none", "aria-controls": B ? m : void 0, "aria-describedby": f, "aria-expanded": B && T === "combobox" ? !!O : void 0, "aria-label": S, "aria-labelledby": E, "aria-multiline": R, "aria-owns": B ? y : void 0, "aria-readonly": B ? void 0 : !0, "aria-required": g, autoCapitalize: _, className: N, contentEditable: B, "data-testid": I, id: w, ref: P, role: T, spellCheck: D, style: C, tabIndex: x })
    );
  }, Mc;
}
const b_ = process.env.NODE_ENV === "development" ? M_() : R_();
var A_ = b_;
function D_({
  className: r
}) {
  return /* @__PURE__ */ U.jsx(A_.ContentEditable, { className: r || "content-editable__root" });
}
var sr = Ko();
const Is = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", L_ = Is && "documentMode" in document ? document.documentMode : null, ui = Is && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
Is && "InputEvent" in window && !L_ && "getTargetRanges" in new window.InputEvent("input");
const sh = Er.createContext(null), Uf = 4;
function sn({
  children: r,
  className: n,
  onClick: t,
  title: o
}) {
  const u = Cn(null), p = Er.useContext(sh);
  if (p === null)
    throw new Error("DropDownItem must be used within a DropDown");
  const { registerItem: m } = p;
  return yt(() => {
    u && u.current && m(u);
  }, [u, m]), /* @__PURE__ */ U.jsx(
    "button",
    {
      className: n,
      onClick: t,
      ref: u,
      title: o,
      type: "button",
      children: r
    }
  );
}
function I_({
  children: r,
  dropDownRef: n,
  onClose: t
}) {
  const [o, u] = ut(), [p, m] = ut(), f = Vt(
    (E) => {
      u((R) => R ? [...R, E] : [E]);
    },
    [u]
  ), O = (E) => {
    if (!o)
      return;
    const R = E.key;
    ["Escape", "ArrowUp", "ArrowDown", "Tab"].includes(R) && E.preventDefault(), R === "Escape" || R === "Tab" ? t() : R === "ArrowUp" ? m((y) => {
      if (!y)
        return o[0];
      const g = o.indexOf(y) - 1;
      return o[g === -1 ? o.length - 1 : g];
    }) : R === "ArrowDown" && m((y) => y ? o[o.indexOf(y) + 1] : o[0]);
  }, S = Zr(
    () => ({
      registerItem: f
    }),
    [f]
  );
  return yt(() => {
    o && !p && m(o[0]), p && p.current && p.current.focus();
  }, [o, p]), /* @__PURE__ */ U.jsx(sh.Provider, { value: S, children: /* @__PURE__ */ U.jsx("div", { className: "dropdown", ref: n, onKeyDown: O, children: r }) });
}
function Bi({
  disabled: r = !1,
  buttonLabel: n,
  buttonAriaLabel: t,
  buttonClassName: o,
  buttonIconClassName: u,
  children: p,
  stopCloseOnClickSelf: m
}) {
  const f = Cn(null), O = Cn(null), [S, E] = ut(!1), R = () => {
    E(!1), O && O.current && O.current.focus();
  };
  return yt(() => {
    const y = O.current, g = f.current;
    if (S && y !== null && g !== null) {
      const { top: _, left: N } = y.getBoundingClientRect();
      g.style.top = `${_ + y.offsetHeight + Uf}px`, g.style.left = `${Math.min(
        N,
        window.innerWidth - g.offsetWidth - 20
      )}px`;
    }
  }, [f, O, S]), yt(() => {
    const y = O.current;
    if (y !== null && S) {
      const g = (_) => {
        const N = _.target;
        m && f.current && f.current.contains(N) || y.contains(N) || E(!1);
      };
      return document.addEventListener("click", g), () => {
        document.removeEventListener("click", g);
      };
    }
  }, [f, O, S, m]), yt(() => {
    const y = () => {
      if (S) {
        const g = O.current, _ = f.current;
        if (g !== null && _ !== null) {
          const { top: N } = g.getBoundingClientRect(), w = N + g.offsetHeight + Uf;
          w !== _.getBoundingClientRect().top && (_.style.top = `${w}px`);
        }
      }
    };
    return document.addEventListener("scroll", y), () => {
      document.removeEventListener("scroll", y);
    };
  }, [O, f, S]), /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    /* @__PURE__ */ U.jsxs(
      "button",
      {
        type: "button",
        disabled: r,
        "aria-label": t || n,
        className: o,
        onClick: () => E(!S),
        ref: O,
        children: [
          u && /* @__PURE__ */ U.jsx("span", { className: u }),
          n && /* @__PURE__ */ U.jsx("span", { className: "text dropdown-button-text", children: n }),
          /* @__PURE__ */ U.jsx("i", { className: "chevron-down" })
        ]
      }
    ),
    S && Bo(
      /* @__PURE__ */ U.jsx(I_, { dropDownRef: f, onClose: R, children: p }),
      document.body
    )
  ] });
}
const Ri = 8, bi = 72, $_ = 15;
function k_({
  selectionFontSize: r,
  disabled: n = !1,
  editor: t
}) {
  const [o, u] = Er.useState(r), p = (S, E) => {
    if (!E)
      return S;
    let R = S;
    switch (E) {
      case 2:
        switch (!0) {
          case S > bi:
            R = bi;
            break;
          case S >= 48:
            R -= 12;
            break;
          case S >= 24:
            R -= 4;
            break;
          case S >= 14:
            R -= 2;
            break;
          case S >= 9:
            R -= 1;
            break;
          default:
            R = Ri;
            break;
        }
        break;
      case 1:
        switch (!0) {
          case S < Ri:
            R = Ri;
            break;
          case S < 12:
            R += 1;
            break;
          case S < 20:
            R += 2;
            break;
          case S < 36:
            R += 4;
            break;
          case S <= 60:
            R += 12;
            break;
          default:
            R = bi;
            break;
        }
        break;
    }
    return R;
  }, m = Er.useCallback(
    (S, E) => {
      const R = (y) => (y || (y = `${$_}px`), y = y.slice(0, -2), `${p(
        Number(y),
        E
      )}px`);
      t.update(() => {
        if (t.isEditable()) {
          const y = fe.$getSelection();
          y !== null && sr.$patchStyleText(y, {
            "font-size": S || R
          });
        }
      });
    },
    [t]
  ), f = (S) => {
    const E = Number(o);
    if (["e", "E", "+", "-"].includes(S.key) || isNaN(E)) {
      S.preventDefault(), u("");
      return;
    }
    if (S.key === "Enter") {
      S.preventDefault();
      let R = E;
      E > bi ? R = bi : E < Ri && (R = Ri), u(String(R)), m(String(R) + "px", null);
    }
  }, O = (S) => {
    if (o !== "") {
      const E = p(
        Number(o),
        S
      );
      m(String(E) + "px", null);
    } else
      m(null, S);
  };
  return Er.useEffect(() => {
    u(r);
  }, [r]), /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    /* @__PURE__ */ U.jsx(
      "button",
      {
        type: "button",
        disabled: n || r !== "" && Number(o) <= Ri,
        onClick: () => O(
          2
          /* decrement */
        ),
        className: "toolbar-item font-decrement",
        children: /* @__PURE__ */ U.jsx("i", { className: "format minus-icon" })
      }
    ),
    /* @__PURE__ */ U.jsx(
      "input",
      {
        type: "number",
        value: o,
        disabled: n,
        className: "toolbar-item font-size-input",
        min: Ri,
        max: bi,
        onChange: (S) => u(S.target.value),
        onKeyDown: f
      }
    ),
    /* @__PURE__ */ U.jsx(
      "button",
      {
        type: "button",
        disabled: n || r !== "" && Number(o) >= bi,
        onClick: () => O(
          1
          /* increment */
        ),
        className: "toolbar-item font-increment",
        children: /* @__PURE__ */ U.jsx("i", { className: "format add-icon" })
      }
    )
  ] });
}
const P_ = /* @__PURE__ */ new Set([
  "http:",
  "https:",
  "mailto:",
  "sms:",
  "tel:"
]);
function wa(r) {
  try {
    const n = new URL(r);
    if (!P_.has(n.protocol))
      return "about:blank";
  } catch {
    return r;
  }
  return r;
}
const F_ = new RegExp(
  /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=+$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=+$,\w]+@)[A-Za-z0-9.-]+)((?:\/[+~%/.\w-_]*)?\??(?:[-+=&;%@.\w_]*)#?(?:[\w]*))?)/
);
function B_(r) {
  return r === "https://" || F_.test(r);
}
function ws(r) {
  const n = r.anchor, t = r.focus, o = r.anchor.getNode(), u = r.focus.getNode();
  return o === u ? o : r.isBackward() ? sr.$isAtNodeEnd(t) ? o : u : sr.$isAtNodeEnd(n) ? o : u;
}
function di({
  label: r,
  value: n,
  onChange: t,
  placeholder: o = "",
  "data-test-id": u,
  type: p = "text"
}) {
  return /* @__PURE__ */ U.jsxs("div", { className: "Input__wrapper", children: [
    /* @__PURE__ */ U.jsx("label", { className: "Input__label", children: r }),
    /* @__PURE__ */ U.jsx(
      "input",
      {
        type: p,
        className: "Input__input",
        placeholder: o,
        value: n,
        onChange: (m) => {
          t(m.target.value);
        },
        "data-test-id": u
      }
    )
  ] });
}
let Xc = !1;
const K_ = [
  "#d0021b",
  "#f5a623",
  "#f8e71c",
  "#8b572a",
  "#7ed321",
  "#417505",
  "#bd10e0",
  "#9013fe",
  "#4a90e2",
  "#50e3c2",
  "#b8e986",
  "#000000",
  "#4a4a4a",
  "#9b9b9b",
  "#ffffff"
], gl = 214, Yf = 150;
function lh({
  color: r,
  onChange: n
}) {
  const [t, o] = ut(Es("hex", r)), [u, p] = ut(r), m = Cn(null), f = Zr(
    () => ({
      x: t.hsv.s / 100 * gl,
      y: (100 - t.hsv.v) / 100 * Yf
    }),
    [t.hsv.s, t.hsv.v]
  ), O = Zr(
    () => ({
      x: t.hsv.h / 360 * gl
    }),
    [t.hsv]
  ), S = (y) => {
    if (p(y), /^#[0-9A-Fa-f]{6}$/i.test(y)) {
      const g = Es("hex", y);
      o(g);
    }
  }, E = ({ x: y, y: g }) => {
    const _ = {
      ...t.hsv,
      s: y / gl * 100,
      v: 100 - g / Yf * 100
    }, N = Es("hsv", _);
    o(N), p(N.hex);
  }, R = ({ x: y }) => {
    const g = { ...t.hsv, h: y / gl * 360 }, _ = Es("hsv", g);
    o(_), p(_.hex);
  };
  return yt(() => {
    m.current !== null && n && (n(t.hex, Xc), p(t.hex));
  }, [t, n]), yt(() => {
    if (r === void 0)
      return;
    const y = Es("hex", r);
    o(y), p(y.hex);
  }, [r]), /* @__PURE__ */ U.jsxs(
    "div",
    {
      className: "color-picker-wrapper",
      style: { width: gl },
      ref: m,
      children: [
        /* @__PURE__ */ U.jsx(di, { label: "Hex", onChange: S, value: u }),
        /* @__PURE__ */ U.jsx("div", { className: "color-picker-basic-color", children: K_.map((y) => /* @__PURE__ */ U.jsx(
          "button",
          {
            className: y === t.hex ? " active" : "",
            style: { backgroundColor: y },
            onClick: () => {
              p(y), o(Es("hex", y));
            }
          },
          y
        )) }),
        /* @__PURE__ */ U.jsx(
          zf,
          {
            className: "color-picker-saturation",
            style: { backgroundColor: `hsl(${t.hsv.h}, 100%, 50%)` },
            onChange: E,
            children: /* @__PURE__ */ U.jsx(
              "div",
              {
                className: "color-picker-saturation_cursor",
                style: {
                  backgroundColor: t.hex,
                  left: f.x,
                  top: f.y
                }
              }
            )
          }
        ),
        /* @__PURE__ */ U.jsx(zf, { className: "color-picker-hue", onChange: R, children: /* @__PURE__ */ U.jsx(
          "div",
          {
            className: "color-picker-hue_cursor",
            style: {
              backgroundColor: `hsl(${t.hsv.h}, 100%, 50%)`,
              left: O.x
            }
          }
        ) }),
        /* @__PURE__ */ U.jsx(
          "div",
          {
            className: "color-picker-color",
            style: { backgroundColor: t.hex }
          }
        )
      ]
    }
  );
}
function zf({ className: r, style: n, onChange: t, children: o }) {
  const u = Cn(null), p = Cn(!1), m = (O) => {
    if (u.current) {
      const { current: S } = u, { width: E, height: R, left: y, top: g } = S.getBoundingClientRect(), _ = qf(O.clientX - y, E, 0), N = qf(O.clientY - g, R, 0);
      t({ x: _, y: N });
    }
  }, f = (O) => {
    if (O.button !== 0)
      return;
    m(O);
    const S = (R) => {
      p.current = !0, Xc = !0, m(R);
    }, E = (R) => {
      p.current && (Xc = !1), document.removeEventListener("mousemove", S, !1), document.removeEventListener("mouseup", E, !1), m(R), p.current = !1;
    };
    document.addEventListener("mousemove", S, !1), document.addEventListener("mouseup", E, !1);
  };
  return /* @__PURE__ */ U.jsx(
    "div",
    {
      ref: u,
      className: r,
      style: n,
      onMouseDown: f,
      children: o
    }
  );
}
function qf(r, n, t) {
  return r > n ? n : r < t ? t : r;
}
function Gf(r) {
  if (r.startsWith("#")) {
    if (r.length === 4 || r.length === 5)
      return r = r.split("").map((n, t) => t ? n + n : "#").join(""), r;
    if (r.length === 7 || r.length === 9)
      return r;
  } else {
    const n = document.createElement("canvas").getContext("2d");
    if (!n)
      throw new Error("2d context not supported or canvas already initialized");
    return n.fillStyle = r, n.fillStyle;
  }
  return "#000000";
}
function Vf(r) {
  const n = (r.replace(
    /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
    (t, o, u, p) => "#" + o + o + u + u + p + p
  ).substring(1).match(/.{2}/g) || []).map((t) => parseInt(t, 16));
  return {
    b: n[2],
    g: n[1],
    r: n[0]
  };
}
function Rc({ r, g: n, b: t }) {
  r /= 255, n /= 255, t /= 255;
  const o = Math.max(r, n, t), u = o - Math.min(r, n, t), p = u ? (o === r ? (n - t) / u + (n < t ? 6 : 0) : o === n ? 2 + (t - r) / u : 4 + (r - n) / u) * 60 : 0, m = o ? u / o * 100 : 0, f = o * 100;
  return { h: p, s: m, v: f };
}
function j_({ h: r, s: n, v: t }) {
  n /= 100, t /= 100;
  const o = ~~(r / 60), u = r / 60 - o, p = t * (1 - n), m = t * (1 - n * u), f = t * (1 - n * (1 - u)), O = o % 6, S = Math.round([t, m, p, p, f, t][O] * 255), E = Math.round([f, t, t, m, p, p][O] * 255);
  return { b: Math.round([p, p, f, t, t, m][O] * 255), g: E, r: S };
}
function Jf({ b: r, g: n, r: t }) {
  return "#" + [t, n, r].map((o) => o.toString(16).padStart(2, "0")).join("");
}
function Es(r, n) {
  let t = Gf("#121212"), o = Vf(t), u = Rc(o);
  return r === "hex" ? (t = Gf(n), o = Vf(t), u = Rc(o)) : r === "rgb" ? (o = n, t = Jf(o), u = Rc(o)) : r === "hsv" && (u = n, o = j_(u), t = Jf(o)), { hex: t, hsv: u, rgb: o };
}
function Xf({
  disabled: r = !1,
  stopCloseOnClickSelf: n = !0,
  color: t,
  onChange: o,
  ...u
}) {
  return /* @__PURE__ */ U.jsx(
    Bi,
    {
      ...u,
      disabled: r,
      stopCloseOnClickSelf: n,
      children: /* @__PURE__ */ U.jsx(lh, { color: t, onChange: o })
    }
  );
}
const hu = fe.createCommand();
function H_() {
  const [r] = gn.useLexicalComposerContext();
  return yt(() => {
    if (!r.hasNodes([Ms]))
      throw new Error(
        "PageBreakPlugin: PageBreakNode is not registered on editor"
      );
    return Jt.mergeRegister(
      r.registerCommand(
        hu,
        () => {
          const n = fe.$getSelection();
          if (!fe.$isRangeSelection(n))
            return !1;
          if (n.focus.getNode() !== null) {
            const o = nu();
            Jt.$insertNodeToNearestRoot(o);
          }
          return !0;
        },
        fe.COMMAND_PRIORITY_EDITOR
      )
    );
  }, [r]), null;
}
function W_({ children: r }) {
  return /* @__PURE__ */ U.jsx("div", { className: "DialogButtonsList", children: r });
}
function $s({
  "data-test-id": r,
  children: n
}) {
  return /* @__PURE__ */ U.jsx("div", { className: "DialogActions", "data-test-id": r, children: n });
}
function U_(...r) {
  return r.filter(Boolean).join(" ");
}
function po({
  "data-test-id": r,
  children: n,
  className: t,
  onClick: o,
  disabled: u,
  small: p,
  title: m
}) {
  return /* @__PURE__ */ U.jsx(
    "button",
    {
      disabled: u,
      className: U_(
        "Button__root",
        u && "Button__disabled",
        p && "Button__small",
        t
      ),
      onClick: o,
      title: m,
      "aria-label": m,
      ...r && { "data-test-id": r },
      children: n
    }
  );
}
function ah({
  accept: r,
  label: n,
  onChange: t,
  "data-test-id": o
}) {
  return /* @__PURE__ */ U.jsxs("div", { className: "Input__wrapper", children: [
    /* @__PURE__ */ U.jsx("label", { className: "Input__label", children: n }),
    /* @__PURE__ */ U.jsx(
      "input",
      {
        type: "file",
        accept: r,
        className: "Input__input",
        onChange: (u) => t(u.target.files),
        "data-test-id": o
      }
    )
  ] });
}
const Y_ = (r) => Is ? (r || window).getSelection() : null, Sl = fe.createCommand("INSERT_IMAGE_COMMAND");
function z_({
  onClick: r
}) {
  const [n, t] = ut(""), [o, u] = ut(""), p = n === "";
  return /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    /* @__PURE__ */ U.jsx(
      di,
      {
        label: "Image URL",
        placeholder: "i.e. https://source.unsplash.com/random",
        onChange: t,
        value: n,
        "data-test-id": "image-modal-url-input"
      }
    ),
    /* @__PURE__ */ U.jsx(
      di,
      {
        label: "Alt Text",
        placeholder: "Random unsplash image",
        onChange: u,
        value: o,
        "data-test-id": "image-modal-alt-text-input"
      }
    ),
    /* @__PURE__ */ U.jsx($s, { children: /* @__PURE__ */ U.jsx(
      po,
      {
        "data-test-id": "image-modal-confirm-btn",
        disabled: p,
        onClick: () => r({ altText: o, src: n }),
        children: "Confirm"
      }
    ) })
  ] });
}
function q_({
  onClick: r
}) {
  const [n, t] = ut(""), [o, u] = ut(""), p = n === "", m = (f) => {
    const O = new FileReader();
    O.onload = function() {
      return typeof O.result == "string" && t(O.result), "";
    }, f !== null && O.readAsDataURL(f[0]);
  };
  return /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    /* @__PURE__ */ U.jsx(
      ah,
      {
        label: "Image Upload",
        onChange: m,
        accept: "image/*",
        "data-test-id": "image-modal-file-upload"
      }
    ),
    /* @__PURE__ */ U.jsx(
      di,
      {
        label: "Alt Text",
        placeholder: "Descriptive alternative text",
        onChange: u,
        value: o,
        "data-test-id": "image-modal-alt-text-input"
      }
    ),
    /* @__PURE__ */ U.jsx($s, { children: /* @__PURE__ */ U.jsx(
      po,
      {
        "data-test-id": "image-modal-file-upload-btn",
        disabled: p,
        onClick: () => r({ altText: o, src: n }),
        children: "Confirm"
      }
    ) })
  ] });
}
function ch({
  activeEditor: r,
  onClose: n
}) {
  const [t, o] = ut(null), u = Cn(!1);
  yt(() => {
    u.current = !1;
    const m = (f) => {
      u.current = f.altKey;
    };
    return document.addEventListener("keydown", m), () => {
      document.removeEventListener("keydown", m);
    };
  }, [r]);
  const p = (m) => {
    r.dispatchCommand(Sl, m), n();
  };
  return /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    !t && /* @__PURE__ */ U.jsxs(W_, { children: [
      /* @__PURE__ */ U.jsx(
        po,
        {
          "data-test-id": "image-modal-option-url",
          onClick: () => o("url"),
          children: "URL"
        }
      ),
      /* @__PURE__ */ U.jsx(
        po,
        {
          "data-test-id": "image-modal-option-file",
          onClick: () => o("file"),
          children: "File"
        }
      )
    ] }),
    t === "url" && /* @__PURE__ */ U.jsx(z_, { onClick: p }),
    t === "file" && /* @__PURE__ */ U.jsx(q_, { onClick: p })
  ] });
}
function G_({
  captionsEnabled: r
}) {
  const [n] = gn.useLexicalComposerContext();
  return yt(() => {
    if (!n.hasNodes([Rs]))
      throw new Error("ImagesPlugin: ImageNode not registered on editor");
    return Jt.mergeRegister(
      n.registerCommand(
        Sl,
        (t) => {
          const o = ru(t);
          return fe.$insertNodes([o]), fe.$isRootOrShadowRoot(o.getParentOrThrow()) && Jt.$wrapNodeInElement(o, fe.$createParagraphNode).selectEnd(), !0;
        },
        fe.COMMAND_PRIORITY_EDITOR
      ),
      n.registerCommand(
        fe.DRAGSTART_COMMAND,
        (t) => J_(t),
        fe.COMMAND_PRIORITY_HIGH
      ),
      n.registerCommand(
        fe.DRAGOVER_COMMAND,
        (t) => X_(t),
        fe.COMMAND_PRIORITY_LOW
      ),
      n.registerCommand(
        fe.DROP_COMMAND,
        (t) => Z_(t, n),
        fe.COMMAND_PRIORITY_HIGH
      )
    );
  }, [r, n]), null;
}
const V_ = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", uh = document.createElement("img");
uh.src = V_;
function J_(r) {
  const n = pu();
  if (!n)
    return !1;
  const t = r.dataTransfer;
  return t ? (t.setData("text/plain", "_"), t.setDragImage(uh, 0, 0), t.setData(
    "application/x-lexical-drag",
    JSON.stringify({
      data: {
        altText: n.__altText,
        caption: n.__caption,
        height: n.__height,
        key: n.getKey(),
        maxWidth: n.__maxWidth,
        showCaption: n.__showCaption,
        src: n.__src,
        width: n.__width
      },
      type: "image"
    })
  ), !0) : !1;
}
function X_(r) {
  return pu() ? (dh(r) || r.preventDefault(), !0) : !1;
}
function Z_(r, n) {
  const t = pu();
  if (!t)
    return !1;
  const o = Q_(r);
  if (!o)
    return !1;
  if (r.preventDefault(), dh(r)) {
    const u = eN(r);
    t.remove();
    const p = fe.$createRangeSelection();
    u != null && p.applyDOMRange(u), fe.$setSelection(p), n.dispatchCommand(Sl, o);
  }
  return !0;
}
function pu() {
  const r = fe.$getSelection();
  if (!fe.$isNodeSelection(r))
    return null;
  const t = r.getNodes()[0];
  return Cm(t) ? t : null;
}
function Q_(r) {
  var u;
  const n = (u = r.dataTransfer) == null ? void 0 : u.getData("application/x-lexical-drag");
  if (!n)
    return null;
  const { type: t, data: o } = JSON.parse(n);
  return t !== "image" ? null : o;
}
function dh(r) {
  const n = r.target;
  return !!(n && n instanceof HTMLElement && !n.closest("code, span.editor-image") && n.parentElement && n.parentElement.closest("div.content-editable__root"));
}
function eN(r) {
  let n;
  const t = r.target, o = t == null ? null : t.nodeType === 9 ? t.defaultView : t.ownerDocument.defaultView, u = Y_(o);
  if (document.caretRangeFromPoint)
    n = document.caretRangeFromPoint(r.clientX, r.clientY);
  else if (r.rangeParent && u !== null)
    u.collapse(r.rangeParent, r.rangeOffset || 0), n = u.getRangeAt(0);
  else
    throw Error("Cannot get the selection when dragging");
  return n;
}
function tN({
  onClose: r,
  children: n,
  title: t,
  closeOnClickOutside: o
}) {
  const u = Cn(null);
  return yt(() => {
    u.current !== null && u.current.focus();
  }, []), yt(() => {
    let p = null;
    const m = (S) => {
      S.key === "Escape" && r();
    }, f = (S) => {
      const E = S.target;
      u.current !== null && !u.current.contains(E) && o && r();
    }, O = u.current;
    return O !== null && (p = O.parentElement, p !== null && p.addEventListener("click", f)), window.addEventListener("keydown", m), () => {
      window.removeEventListener("keydown", m), p !== null && (p == null || p.removeEventListener("click", f));
    };
  }, [o, r]), /* @__PURE__ */ U.jsx("div", { className: "Modal__overlay", role: "dialog", children: /* @__PURE__ */ U.jsxs("div", { className: "Modal__modal", tabIndex: -1, ref: u, children: [
    /* @__PURE__ */ U.jsx("h2", { className: "Modal__title", children: t }),
    /* @__PURE__ */ U.jsx(
      "button",
      {
        className: "Modal__closeButton",
        "aria-label": "Close modal",
        type: "button",
        onClick: r,
        children: "X"
      }
    ),
    /* @__PURE__ */ U.jsx("div", { className: "Modal__content", children: n })
  ] }) });
}
function nN({
  onClose: r,
  children: n,
  title: t,
  closeOnClickOutside: o = !1
}) {
  return Bo(
    /* @__PURE__ */ U.jsx(
      tN,
      {
        onClose: r,
        title: t,
        closeOnClickOutside: o,
        children: n
      }
    ),
    document.body
  );
}
function ba() {
  const [r, n] = ut(null), t = Vt(() => {
    n(null);
  }, []), o = Zr(() => {
    if (r === null)
      return null;
    const { title: p, content: m, closeOnClickOutside: f } = r;
    return /* @__PURE__ */ U.jsx(
      nN,
      {
        onClose: t,
        title: p,
        closeOnClickOutside: f,
        children: m
      }
    );
  }, [r, t]), u = Vt(
    (p, m, f = !1) => {
      n({
        closeOnClickOutside: f,
        content: m(t),
        title: p
      });
    },
    [t]
  );
  return [o, u];
}
function rN({
  children: r,
  label: n,
  className: t,
  ...o
}) {
  return /* @__PURE__ */ U.jsxs("div", { className: "Input__wrapper", children: [
    /* @__PURE__ */ U.jsx("label", { style: { marginTop: "-1em" }, className: "Input__label", children: n }),
    /* @__PURE__ */ U.jsx("select", { ...o, className: t || "select", children: r })
  ] });
}
const oN = (r) => Is ? (r || window).getSelection() : null, mu = fe.createCommand("INSERT_INLINE_IMAGE_COMMAND");
function iN({
  activeEditor: r,
  onClose: n
}) {
  const t = Cn(!1), [o, u] = ut(""), [p, m] = ut(""), [f, O] = ut(!1), [S, E] = ut("left"), R = o === "", y = (w) => {
    O(w.target.checked);
  }, g = (w) => {
    E(w.target.value);
  }, _ = (w) => {
    const T = new FileReader();
    T.onload = function() {
      return typeof T.result == "string" && u(T.result), "";
    }, w !== null && T.readAsDataURL(w[0]);
  };
  yt(() => {
    t.current = !1;
    const w = (T) => {
      t.current = T.altKey;
    };
    return document.addEventListener("keydown", w), () => {
      document.removeEventListener("keydown", w);
    };
  }, [r]);
  const N = () => {
    const w = { altText: p, position: S, showCaption: f, src: o };
    r.dispatchCommand(mu, w), n();
  };
  return /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    /* @__PURE__ */ U.jsx("div", { style: { marginBottom: "1em" }, children: /* @__PURE__ */ U.jsx(
      ah,
      {
        label: "Image Upload",
        onChange: _,
        accept: "image/*",
        "data-test-id": "image-modal-file-upload"
      }
    ) }),
    /* @__PURE__ */ U.jsx("div", { style: { marginBottom: "1em" }, children: /* @__PURE__ */ U.jsx(
      di,
      {
        label: "Alt Text",
        placeholder: "Descriptive alternative text",
        onChange: m,
        value: p,
        "data-test-id": "image-modal-alt-text-input"
      }
    ) }),
    /* @__PURE__ */ U.jsxs(
      rN,
      {
        style: { marginBottom: "1em", width: "290px" },
        label: "Position",
        name: "position",
        id: "position-select",
        onChange: g,
        children: [
          /* @__PURE__ */ U.jsx("option", { value: "left", children: "Left" }),
          /* @__PURE__ */ U.jsx("option", { value: "right", children: "Right" }),
          /* @__PURE__ */ U.jsx("option", { value: "full", children: "Full Width" })
        ]
      }
    ),
    /* @__PURE__ */ U.jsxs("div", { className: "Input__wrapper", children: [
      /* @__PURE__ */ U.jsx(
        "input",
        {
          id: "caption",
          className: "InlineImageNode_Checkbox",
          type: "checkbox",
          checked: f,
          onChange: y
        }
      ),
      /* @__PURE__ */ U.jsx("label", { htmlFor: "caption", children: "Show Caption" })
    ] }),
    /* @__PURE__ */ U.jsx($s, { children: /* @__PURE__ */ U.jsx(
      po,
      {
        "data-test-id": "image-modal-file-upload-btn",
        disabled: R,
        onClick: () => N(),
        children: "Confirm"
      }
    ) })
  ] });
}
function sN() {
  const [r] = gn.useLexicalComposerContext();
  return yt(() => {
    if (!r.hasNodes([Ls]))
      throw new Error("ImagesPlugin: ImageNode not registered on editor");
    return Jt.mergeRegister(
      r.registerCommand(
        mu,
        (n) => {
          const t = fu(n);
          return fe.$insertNodes([t]), fe.$isRootOrShadowRoot(t.getParentOrThrow()) && Jt.$wrapNodeInElement(t, fe.$createParagraphNode).selectEnd(), !0;
        },
        fe.COMMAND_PRIORITY_EDITOR
      ),
      r.registerCommand(
        fe.DRAGSTART_COMMAND,
        (n) => aN(n),
        fe.COMMAND_PRIORITY_HIGH
      ),
      r.registerCommand(
        fe.DRAGOVER_COMMAND,
        (n) => cN(n),
        fe.COMMAND_PRIORITY_LOW
      ),
      r.registerCommand(
        fe.DROP_COMMAND,
        (n) => uN(n, r),
        fe.COMMAND_PRIORITY_HIGH
      )
    );
  }, [r]), null;
}
const lN = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", fh = document.createElement("img");
fh.src = lN;
function aN(r) {
  const n = _u();
  if (!n)
    return !1;
  const t = r.dataTransfer;
  return t ? (t.setData("text/plain", "_"), t.setDragImage(fh, 0, 0), t.setData(
    "application/x-lexical-drag",
    JSON.stringify({
      data: {
        altText: n.__altText,
        caption: n.__caption,
        height: n.__height,
        key: n.getKey(),
        showCaption: n.__showCaption,
        src: n.__src,
        width: n.__width
      },
      type: "image"
    })
  ), !0) : !1;
}
function cN(r) {
  return _u() ? (gh(r) || r.preventDefault(), !0) : !1;
}
function uN(r, n) {
  const t = _u();
  if (!t)
    return !1;
  const o = dN(r);
  if (!o)
    return !1;
  if (r.preventDefault(), gh(r)) {
    const u = fN(r);
    t.remove();
    const p = fe.$createRangeSelection();
    u != null && p.applyDOMRange(u), fe.$setSelection(p), n.dispatchCommand(mu, o);
  }
  return !0;
}
function _u() {
  const r = fe.$getSelection();
  if (!fe.$isNodeSelection(r))
    return null;
  const t = r.getNodes()[0];
  return Wm(t) ? t : null;
}
function dN(r) {
  var u;
  const n = (u = r.dataTransfer) == null ? void 0 : u.getData("application/x-lexical-drag");
  if (!n)
    return null;
  const { type: t, data: o } = JSON.parse(n);
  return t !== "image" ? null : o;
}
function gh(r) {
  const n = r.target;
  return !!(n && n instanceof HTMLElement && !n.closest("code, span.editor-image") && n.parentElement && n.parentElement.closest("div.content-editable__root"));
}
function fN(r) {
  let n;
  const t = r.target, o = t == null ? null : t.nodeType === 9 ? t.defaultView : t.ownerDocument.defaultView, u = oN(o);
  if (document.caretRangeFromPoint)
    n = document.caretRangeFromPoint(r.clientX, r.clientY);
  else if (r.rangeParent && u !== null)
    u.collapse(r.rangeParent, r.rangeOffset || 0), n = u.getRangeAt(0);
  else
    throw Error("Cannot get the selection when dragging");
  return n;
}
const Nu = fe.createCommand(
  "INSERT_EXCALIDRAW_COMMAND"
);
function gN() {
  const [r] = gn.useLexicalComposerContext();
  return yt(() => {
    if (!r.hasNodes([ki]))
      throw new Error(
        "ExcalidrawPlugin: ExcalidrawNode not registered on editor"
      );
    return r.registerCommand(
      Nu,
      () => {
        const n = eh();
        return fe.$insertNodes([n]), fe.$isRootOrShadowRoot(n.getParentOrThrow()) && Jt.$wrapNodeInElement(n, fe.$createParagraphNode).selectEnd(), !0;
      },
      fe.COMMAND_PRIORITY_EDITOR
    );
  }, [r]), null;
}
function hN(r, n, ...t) {
  if (!r)
    throw new Error(
      "Internal Lexical error: invariant() is meant to be replaced at compile time. There is no runtime version. Error: " + n
    );
}
fe.createCommand("INSERT_NEW_TABLE_COMMAND");
Rg({
  cellEditorConfig: null,
  cellEditorPlugins: null,
  set: () => {
  }
});
function hh({
  activeEditor: r,
  onClose: n
}) {
  const [t, o] = ut("5"), [u, p] = ut("5"), [m, f] = ut(!0);
  yt(() => {
    const S = Number(t), E = Number(u);
    S && S > 0 && S <= 500 && E && E > 0 && E <= 50 ? f(!1) : f(!0);
  }, [t, u]);
  const O = () => {
    r.dispatchCommand(vt.INSERT_TABLE_COMMAND, {
      columns: u,
      rows: t
    }), n();
  };
  return /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    /* @__PURE__ */ U.jsx(
      di,
      {
        placeholder: "# of rows (1-500)",
        label: "Rows",
        onChange: o,
        value: t,
        "data-test-id": "table-modal-rows",
        type: "number"
      }
    ),
    /* @__PURE__ */ U.jsx(
      di,
      {
        placeholder: "# of columns (1-50)",
        label: "Columns",
        onChange: p,
        value: u,
        "data-test-id": "table-modal-columns",
        type: "number"
      }
    ),
    /* @__PURE__ */ U.jsx($s, { "data-test-id": "table-model-confirm-insert", children: /* @__PURE__ */ U.jsx(po, { disabled: m, onClick: O, children: "Confirm" }) })
  ] });
}
const ph = fe.createCommand(
  "INSERT_POLL_COMMAND"
);
function mh({
  activeEditor: r,
  onClose: n
}) {
  const [t, o] = ut(""), u = () => {
    r.dispatchCommand(ph, t), n();
  };
  return /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    /* @__PURE__ */ U.jsx(di, { label: "Question", onChange: o, value: t }),
    /* @__PURE__ */ U.jsx($s, { children: /* @__PURE__ */ U.jsx(po, { disabled: t.trim() === "", onClick: u, children: "Confirm" }) })
  ] });
}
function pN() {
  const [r] = gn.useLexicalComposerContext();
  return yt(() => {
    if (!r.hasNodes([Ds]))
      throw new Error("PollPlugin: PollNode not registered on editor");
    return r.registerCommand(
      ph,
      (n) => {
        const t = du(n, [
          mf(),
          mf()
        ]);
        return fe.$insertNodes([t]), fe.$isRootOrShadowRoot(t.getParentOrThrow()) && Jt.$wrapNodeInElement(t, fe.$createParagraphNode).selectEnd(), !0;
      },
      fe.COMMAND_PRIORITY_EDITOR
    );
  }, [r]), null;
}
const _h = fe.createCommand(), mN = fe.createCommand();
function _N() {
  const [r] = gn.useLexicalComposerContext();
  return yt(() => {
    if (!r.hasNodes([Pi, Fi]))
      throw new Error(
        "LayoutPlugin: LayoutContainerNode, or LayoutItemNode not registered on editor"
      );
    const n = (t) => {
      var u, p;
      const o = fe.$getSelection();
      if (fe.$isRangeSelection(o) && o.isCollapsed() && o.anchor.offset === 0) {
        const m = Jt.$findMatchingParent(
          o.anchor.getNode(),
          ga
        );
        if (ga(m)) {
          const f = m.getParent(), O = f && (t ? f.getFirstChild() : f == null ? void 0 : f.getLastChild()), S = t ? (u = m.getFirstDescendant()) == null ? void 0 : u.getKey() : (p = m.getLastDescendant()) == null ? void 0 : p.getKey();
          f !== null && O === m && o.anchor.key === S && (t ? m.insertBefore(fe.$createParagraphNode()) : m.insertAfter(fe.$createParagraphNode()));
        }
      }
      return !1;
    };
    return Jt.mergeRegister(
      // When layout is the last child pressing down/right arrow will insert paragraph
      // below it to allow adding more content. It's similar what $insertBlockNode
      // (mainly for decorators), except it'll always be possible to continue adding
      // new content even if trailing paragraph is accidentally deleted
      r.registerCommand(
        fe.KEY_ARROW_DOWN_COMMAND,
        () => n(!1),
        fe.COMMAND_PRIORITY_LOW
      ),
      r.registerCommand(
        fe.KEY_ARROW_RIGHT_COMMAND,
        () => n(!1),
        fe.COMMAND_PRIORITY_LOW
      ),
      // When layout is the first child pressing up/left arrow will insert paragraph
      // above it to allow adding more content. It's similar what $insertBlockNode
      // (mainly for decorators), except it'll always be possible to continue adding
      // new content even if leading paragraph is accidentally deleted
      r.registerCommand(
        fe.KEY_ARROW_UP_COMMAND,
        () => n(!0),
        fe.COMMAND_PRIORITY_LOW
      ),
      r.registerCommand(
        fe.KEY_ARROW_LEFT_COMMAND,
        () => n(!0),
        fe.COMMAND_PRIORITY_LOW
      ),
      r.registerCommand(
        _h,
        (t) => (r.update(() => {
          const o = th(t), u = bc(t);
          for (let p = 0; p < u; p++)
            o.append(
              Jc().append(fe.$createParagraphNode())
            );
          Jt.$insertNodeToNearestRoot(o), o.selectStart();
        }), !0),
        fe.COMMAND_PRIORITY_EDITOR
      ),
      r.registerCommand(
        mN,
        ({ template: t, nodeKey: o }) => (r.update(() => {
          const u = fe.$getNodeByKey(o);
          if (!ga(u))
            return;
          const p = bc(t), m = bc(
            u.getTemplateColumns()
          );
          if (p > m)
            for (let f = m; f < p; f++)
              u.append(
                Jc().append(fe.$createParagraphNode())
              );
          else if (p < m)
            for (let f = m - 1; f >= p; f--) {
              const O = u.getChildAtIndex(f);
              pf(O) && O.remove();
            }
          u.setTemplateColumns(t);
        }), !0),
        fe.COMMAND_PRIORITY_EDITOR
      ),
      // Structure enforcing transformers for each node type. In case nesting structure is not
      // "Container > Item" it'll unwrap nodes and convert it back
      // to regular content.
      r.registerNodeTransform(Fi, (t) => {
        const o = t.getParent();
        if (!ga(o)) {
          const u = t.getChildren();
          for (const p of u)
            t.insertBefore(p);
          t.remove();
        }
      }),
      r.registerNodeTransform(Pi, (t) => {
        const o = t.getChildren();
        if (!o.every(pf)) {
          for (const u of o)
            t.insertBefore(u);
          t.remove();
        }
      })
    );
  }, [r]), null;
}
function bc(r) {
  return r.trim().split(/\s+/).length;
}
const Ac = [
  { label: "2 columns (equal width)", value: "1fr 1fr" },
  { label: "2 columns (25% - 75%)", value: "1fr 3fr" },
  { label: "3 columns (equal width)", value: "1fr 1fr 1fr" },
  { label: "3 columns (25% - 50% - 25%)", value: "1fr 2fr 1fr" },
  { label: "4 columns (equal width)", value: "1fr 1fr 1fr 1fr" }
];
function Nh({
  activeEditor: r,
  onClose: n
}) {
  var m;
  const [t, o] = ut(Ac[0].value), u = (m = Ac.find((f) => f.value === t)) == null ? void 0 : m.label, p = () => {
    r.dispatchCommand(_h, t), n();
  };
  return /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    /* @__PURE__ */ U.jsx(
      Bi,
      {
        buttonClassName: "toolbar-item dialog-dropdown",
        buttonLabel: u,
        children: Ac.map(({ label: f, value: O }) => /* @__PURE__ */ U.jsx(
          sn,
          {
            className: "item",
            onClick: () => o(O),
            children: /* @__PURE__ */ U.jsx("span", { className: "text", children: f })
          },
          O
        ))
      }
    ),
    /* @__PURE__ */ U.jsx(po, { onClick: p, children: "Insert" })
  ] });
}
function Zc(r, n) {
  return Zc = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, u) {
    return o.__proto__ = u, o;
  }, Zc(r, n);
}
function NN(r, n) {
  r.prototype = Object.create(n.prototype), r.prototype.constructor = r, Zc(r, n);
}
var CN = function(n, t) {
  return n === void 0 && (n = []), t === void 0 && (t = []), n.length !== t.length || n.some(function(o, u) {
    return !Object.is(o, t[u]);
  });
}, Zf = {
  error: null
}, xN = /* @__PURE__ */ function(r) {
  NN(n, r);
  function n() {
    for (var o, u = arguments.length, p = new Array(u), m = 0; m < u; m++)
      p[m] = arguments[m];
    return o = r.call.apply(r, [this].concat(p)) || this, o.state = Zf, o.resetErrorBoundary = function() {
      for (var f, O = arguments.length, S = new Array(O), E = 0; E < O; E++)
        S[E] = arguments[E];
      o.props.onReset == null || (f = o.props).onReset.apply(f, S), o.reset();
    }, o;
  }
  n.getDerivedStateFromError = function(u) {
    return {
      error: u
    };
  };
  var t = n.prototype;
  return t.reset = function() {
    this.setState(Zf);
  }, t.componentDidCatch = function(u, p) {
    var m, f;
    (m = (f = this.props).onError) == null || m.call(f, u, p);
  }, t.componentDidUpdate = function(u, p) {
    var m = this.state.error, f = this.props.resetKeys;
    if (m !== null && p.error !== null && CN(u.resetKeys, f)) {
      var O, S;
      (O = (S = this.props).onResetKeysChange) == null || O.call(S, u.resetKeys, f), this.reset();
    }
  }, t.render = function() {
    var u = this.state.error, p = this.props, m = p.fallbackRender, f = p.FallbackComponent, O = p.fallback;
    if (u !== null) {
      var S = {
        error: u,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (/* @__PURE__ */ Er.isValidElement(O))
        return O;
      if (typeof m == "function")
        return m(S);
      if (f)
        return /* @__PURE__ */ Er.createElement(f, S);
      throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
    }
    return this.props.children;
  }, n;
}(Er.Component);
function EN({
  equation: r,
  inline: n,
  onDoubleClick: t
}) {
  const o = Cn(null);
  return yt(() => {
    const u = o.current;
    u !== null && bg.render(r, u, {
      displayMode: !n,
      // true === block display //
      errorColor: "#cc0000",
      output: "html",
      strict: "warn",
      throwOnError: !1,
      trust: !1
    });
  }, [r, n]), // We use an empty image tag either side to ensure Android doesn't try and compose from the
  // inner text from Katex. There didn't seem to be any other way of making this work,
  // without having a physical space.
  /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    /* @__PURE__ */ U.jsx("img", { src: "#", alt: "" }),
    /* @__PURE__ */ U.jsx(
      "span",
      {
        role: "button",
        tabIndex: -1,
        onDoubleClick: t,
        ref: o
      }
    ),
    /* @__PURE__ */ U.jsx("img", { src: "#", alt: "" })
  ] });
}
function TN({
  onConfirm: r,
  initialEquation: n = ""
}) {
  const [t] = gn.useLexicalComposerContext(), [o, u] = ut(n), [p, m] = ut(!0), f = Vt(() => {
    r(o, p);
  }, [r, o, p]), O = Vt(() => {
    m(!p);
  }, [m, p]);
  return /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    /* @__PURE__ */ U.jsxs("div", { className: "KatexEquationAlterer_defaultRow", children: [
      "Inline",
      /* @__PURE__ */ U.jsx("input", { type: "checkbox", checked: p, onChange: O })
    ] }),
    /* @__PURE__ */ U.jsx("div", { className: "KatexEquationAlterer_defaultRow", children: "Equation " }),
    /* @__PURE__ */ U.jsx("div", { className: "KatexEquationAlterer_centerRow", children: p ? /* @__PURE__ */ U.jsx(
      "input",
      {
        onChange: (S) => {
          u(S.target.value);
        },
        value: o,
        className: "KatexEquationAlterer_textArea"
      }
    ) : /* @__PURE__ */ U.jsx(
      "textarea",
      {
        onChange: (S) => {
          u(S.target.value);
        },
        value: o,
        className: "KatexEquationAlterer_textArea"
      }
    ) }),
    /* @__PURE__ */ U.jsx("div", { className: "KatexEquationAlterer_defaultRow", children: "Visualization " }),
    /* @__PURE__ */ U.jsx("div", { className: "KatexEquationAlterer_centerRow", children: /* @__PURE__ */ U.jsx(xN, { onError: (S) => t._onError(S), fallback: null, children: /* @__PURE__ */ U.jsx(
      EN,
      {
        equation: o,
        inline: !1,
        onDoubleClick: () => null
      }
    ) }) }),
    /* @__PURE__ */ U.jsx("div", { className: "KatexEquationAlterer_dialogActions", children: /* @__PURE__ */ U.jsx(po, { onClick: f, children: "Confirm" }) })
  ] });
}
const Ch = fe.createCommand("INSERT_EQUATION_COMMAND");
function xh({
  activeEditor: r,
  onClose: n
}) {
  const t = Vt(
    (o, u) => {
      r.dispatchCommand(Ch, { equation: o, inline: u }), n();
    },
    [r, n]
  );
  return /* @__PURE__ */ U.jsx(TN, { onConfirm: t });
}
function yN() {
  const [r] = gn.useLexicalComposerContext();
  return yt(() => {
    if (!r.hasNodes([As]))
      throw new Error(
        "EquationsPlugins: EquationsNode not registered on editor"
      );
    return r.registerCommand(
      Ch,
      (n) => {
        const { equation: t, inline: o } = n, u = uu(t, o);
        return fe.$insertNodes([u]), fe.$isRootOrShadowRoot(u.getParentOrThrow()) && Jt.$wrapNodeInElement(u, fe.$createParagraphNode).selectEnd(), !0;
      },
      fe.COMMAND_PRIORITY_EDITOR
    );
  }, [r]), null;
}
const Cu = fe.createCommand();
fe.createCommand();
function SN() {
  const [r] = gn.useLexicalComposerContext();
  return yt(() => {
    if (!r.hasNodes([
      Li,
      $i,
      Ii
    ]))
      throw new Error(
        "CollapsiblePlugin: CollapsibleContainerNode, CollapsibleTitleNode, or CollapsibleContentNode not registered on editor"
      );
    const n = () => {
      var u;
      const o = fe.$getSelection();
      if (fe.$isRangeSelection(o) && o.isCollapsed() && o.anchor.offset === 0) {
        const p = Jt.$findMatchingParent(
          o.anchor.getNode(),
          Po
        );
        if (Po(p)) {
          const m = p.getParent();
          m !== null && m.getFirstChild() === p && o.anchor.key === ((u = p.getFirstDescendant()) == null ? void 0 : u.getKey()) && p.insertBefore(fe.$createParagraphNode());
        }
      }
      return !1;
    }, t = () => {
      const o = fe.$getSelection();
      if (fe.$isRangeSelection(o) && o.isCollapsed()) {
        const u = Jt.$findMatchingParent(
          o.anchor.getNode(),
          Po
        );
        if (Po(u)) {
          const p = u.getParent();
          if (p !== null && p.getLastChild() === u) {
            const m = u.getFirstDescendant(), f = u.getLastDescendant();
            (f !== null && o.anchor.key === f.getKey() && o.anchor.offset === f.getTextContentSize() || m !== null && o.anchor.key === m.getKey() && o.anchor.offset === m.getTextContentSize()) && u.insertAfter(fe.$createParagraphNode());
          }
        }
      }
      return !1;
    };
    return Jt.mergeRegister(
      // Structure enforcing transformers for each node type. In case nesting structure is not
      // "Container > Title + Content" it'll unwrap nodes and convert it back
      // to regular content.
      r.registerNodeTransform(Ii, (o) => {
        const u = o.getParent();
        if (!Po(u)) {
          const p = o.getChildren();
          for (const m of p)
            o.insertBefore(m);
          o.remove();
        }
      }),
      r.registerNodeTransform($i, (o) => {
        const u = o.getParent();
        if (!Po(u)) {
          o.replace(
            fe.$createParagraphNode().append(...o.getChildren())
          );
          return;
        }
      }),
      r.registerNodeTransform(Li, (o) => {
        const u = o.getChildren();
        if (u.length !== 2 || !gf(u[0]) || !Qg(u[1])) {
          for (const p of u)
            o.insertBefore(p);
          o.remove();
        }
      }),
      // This handles the case when container is collapsed and we delete its previous sibling
      // into it, it would cause collapsed content deleted (since it's display: none, and selection
      // swallows it when deletes single char). Instead we expand container, which is although
      // not perfect, but avoids bigger problem
      r.registerCommand(
        fe.DELETE_CHARACTER_COMMAND,
        () => {
          const o = fe.$getSelection();
          if (!fe.$isRangeSelection(o) || !o.isCollapsed() || o.anchor.offset !== 0)
            return !1;
          const p = o.anchor.getNode().getTopLevelElement();
          if (p === null)
            return !1;
          const m = p.getPreviousSibling();
          return !Po(m) || m.getOpen() ? !1 : (m.setOpen(!0), !0);
        },
        fe.COMMAND_PRIORITY_LOW
      ),
      // When collapsible is the last child pressing down/right arrow will insert paragraph
      // below it to allow adding more content. It's similar what $insertBlockNode
      // (mainly for decorators), except it'll always be possible to continue adding
      // new content even if trailing paragraph is accidentally deleted
      r.registerCommand(
        fe.KEY_ARROW_DOWN_COMMAND,
        t,
        fe.COMMAND_PRIORITY_LOW
      ),
      r.registerCommand(
        fe.KEY_ARROW_RIGHT_COMMAND,
        t,
        fe.COMMAND_PRIORITY_LOW
      ),
      // When collapsible is the first child pressing up/left arrow will insert paragraph
      // above it to allow adding more content. It's similar what $insertBlockNode
      // (mainly for decorators), except it'll always be possible to continue adding
      // new content even if leading paragraph is accidentally deleted
      r.registerCommand(
        fe.KEY_ARROW_UP_COMMAND,
        n,
        fe.COMMAND_PRIORITY_LOW
      ),
      r.registerCommand(
        fe.KEY_ARROW_LEFT_COMMAND,
        n,
        fe.COMMAND_PRIORITY_LOW
      ),
      // Handling CMD+Enter to toggle collapsible element collapsed state
      r.registerCommand(
        fe.INSERT_PARAGRAPH_COMMAND,
        () => {
          var u;
          const o = (u = r._window) == null ? void 0 : u.event;
          if (o && (o.ctrlKey || o.metaKey) && o.key === "Enter") {
            const p = fe.$getPreviousSelection();
            if (fe.$isRangeSelection(p) && p.isCollapsed()) {
              const m = Jt.$findMatchingParent(
                p.anchor.getNode(),
                (f) => fe.$isElementNode(f) && !f.isInline()
              );
              if (gf(m)) {
                const f = m.getParent();
                if (Po(f))
                  return f.toggleOpen(), fe.$setSelection(p.clone()), !0;
              }
            }
          }
          return !1;
        },
        fe.COMMAND_PRIORITY_LOW
      ),
      r.registerCommand(
        Cu,
        () => (r.update(() => {
          const o = cu(), u = fe.$createParagraphNode();
          Jt.$insertNodeToNearestRoot(
            lu(!0).append(
              o.append(u),
              au().append(fe.$createParagraphNode())
            )
          ), u.select();
        }), !0),
        fe.COMMAND_PRIORITY_LOW
      )
    );
  }, [r]), null;
}
var Ts = {}, xa = {}, Qf;
function ON() {
  if (Qf)
    return xa;
  Qf = 1;
  var r = zt(), n = St(), t = $t, o = kt(), m = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  class f {
    constructor(x) {
      this.key = x, this.ref = {
        current: null
      }, this.setRefElement = this.setRefElement.bind(this);
    }
    setRefElement(x) {
      this.ref = {
        current: x
      };
    }
  }
  const O = (C) => {
    const x = document.getElementById("typeahead-menu");
    if (!x)
      return;
    const I = x.getBoundingClientRect();
    I.top + I.height > window.innerHeight && x.scrollIntoView({
      block: "center"
    }), I.top < 0 && x.scrollIntoView({
      block: "center"
    }), C.scrollIntoView({
      block: "nearest"
    });
  };
  function S(C, x, I) {
    let W = I;
    for (let $ = W; $ <= x.length; $++)
      C.substr(-$) === x.substr(0, $) && (W = $);
    return W;
  }
  function E(C) {
    const x = n.$getSelection();
    if (!n.$isRangeSelection(x) || !x.isCollapsed())
      return null;
    const I = x.anchor;
    if (I.type !== "text")
      return null;
    const W = I.getNode();
    if (!W.isSimpleText())
      return null;
    const $ = I.offset, B = W.getTextContent().slice(0, $), L = C.replaceableString.length, P = S(B, C.matchingString, L), F = $ - P;
    if (F < 0)
      return null;
    let Z;
    return F === 0 ? [Z] = W.splitText($) : [, Z] = W.splitText(F, $), Z;
  }
  function R(C, x) {
    let I = getComputedStyle(C);
    const W = I.position === "absolute", $ = x ? /(auto|scroll|hidden)/ : /(auto|scroll)/;
    if (I.position === "fixed")
      return document.body;
    for (let B = C; B = B.parentElement; )
      if (I = getComputedStyle(B), !(W && I.position === "static") && $.test(I.overflow + I.overflowY + I.overflowX))
        return B;
    return document.body;
  }
  function y(C, x) {
    const I = C.getBoundingClientRect(), W = x.getBoundingClientRect();
    return I.top > W.top && I.top < W.bottom;
  }
  function g(C, x, I, W) {
    const [$] = r.useLexicalComposerContext();
    t.useEffect(() => {
      if (x != null && C != null) {
        const B = $.getRootElement(), L = B != null ? R(B, !1) : document.body;
        let P = !1, F = y(x, L);
        const Z = function() {
          P || (window.requestAnimationFrame(function() {
            I(), P = !1;
          }), P = !0);
          const ne = y(x, L);
          ne !== F && (F = ne, W != null && W(ne));
        }, oe = new ResizeObserver(I);
        return window.addEventListener("resize", I), document.addEventListener("scroll", Z, {
          capture: !0,
          passive: !0
        }), oe.observe(x), () => {
          oe.unobserve(x), window.removeEventListener("resize", I), document.removeEventListener("scroll", Z, !0);
        };
      }
    }, [x, $, W, I, C]);
  }
  const _ = n.createCommand("SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND");
  function N({
    close: C,
    editor: x,
    anchorElementRef: I,
    resolution: W,
    options: $,
    menuRenderFn: B,
    onSelectOption: L,
    shouldSplitNodeWithQuery: P = !1,
    commandPriority: F = n.COMMAND_PRIORITY_LOW
  }) {
    const [Z, oe] = t.useState(null), ne = W.match && W.match.matchingString;
    t.useEffect(() => {
      oe(0);
    }, [ne]);
    const te = t.useCallback((z) => {
      x.update(() => {
        const ie = W.match != null && P ? E(W.match) : null;
        L(z, ie, C, W.match ? W.match.matchingString : "");
      });
    }, [x, P, W.match, L, C]), K = t.useCallback((z) => {
      const ie = x.getRootElement();
      ie !== null && (ie.setAttribute("aria-activedescendant", "typeahead-item-" + z), oe(z));
    }, [x]);
    t.useEffect(() => () => {
      const z = x.getRootElement();
      z !== null && z.removeAttribute("aria-activedescendant");
    }, [x]), m(() => {
      $ === null ? oe(null) : Z === null && K(0);
    }, [$, Z, K]), t.useEffect(() => o.mergeRegister(x.registerCommand(_, ({
      option: z
    }) => z.ref && z.ref.current != null ? (O(z.ref.current), !0) : !1, F)), [x, K, F]), t.useEffect(() => o.mergeRegister(x.registerCommand(n.KEY_ARROW_DOWN_COMMAND, (z) => {
      const ie = z;
      if ($ !== null && $.length && Z !== null) {
        const q = Z !== $.length - 1 ? Z + 1 : 0;
        K(q);
        const Y = $[q];
        Y.ref != null && Y.ref.current && x.dispatchCommand(_, {
          index: q,
          option: Y
        }), ie.preventDefault(), ie.stopImmediatePropagation();
      }
      return !0;
    }, F), x.registerCommand(n.KEY_ARROW_UP_COMMAND, (z) => {
      const ie = z;
      if ($ !== null && $.length && Z !== null) {
        const q = Z !== 0 ? Z - 1 : $.length - 1;
        K(q);
        const Y = $[q];
        Y.ref != null && Y.ref.current && O(Y.ref.current), ie.preventDefault(), ie.stopImmediatePropagation();
      }
      return !0;
    }, F), x.registerCommand(n.KEY_ESCAPE_COMMAND, (z) => {
      const ie = z;
      return ie.preventDefault(), ie.stopImmediatePropagation(), C(), !0;
    }, F), x.registerCommand(n.KEY_TAB_COMMAND, (z) => {
      const ie = z;
      return $ === null || Z === null || $[Z] == null ? !1 : (ie.preventDefault(), ie.stopImmediatePropagation(), te($[Z]), !0);
    }, F), x.registerCommand(n.KEY_ENTER_COMMAND, (z) => $ === null || Z === null || $[Z] == null ? !1 : (z !== null && (z.preventDefault(), z.stopImmediatePropagation()), te($[Z]), !0), F)), [te, C, x, $, Z, K, F]);
    const A = t.useMemo(() => ({
      options: $,
      selectOptionAndCleanUp: te,
      selectedIndex: Z,
      setHighlightedIndex: oe
    }), [te, Z, $]);
    return B(I, A, W.match ? W.match.matchingString : "");
  }
  function w(C, x, I, W = document.body) {
    const [$] = r.useLexicalComposerContext(), B = t.useRef(document.createElement("div")), L = t.useCallback(() => {
      B.current.style.top = B.current.style.bottom;
      const F = $.getRootElement(), Z = B.current, oe = Z.firstChild;
      if (F !== null && C !== null) {
        const {
          left: ne,
          top: te,
          width: K,
          height: A
        } = C.getRect(), z = B.current.offsetHeight;
        if (Z.style.top = `${te + window.pageYOffset + z + 3}px`, Z.style.left = `${ne + window.pageXOffset}px`, Z.style.height = `${A}px`, Z.style.width = `${K}px`, oe !== null) {
          oe.style.top = `${te}`;
          const ie = oe.getBoundingClientRect(), q = ie.height, Y = ie.width, se = F.getBoundingClientRect();
          ne + Y > se.right && (Z.style.left = `${se.right - Y + window.pageXOffset}px`), (te + q > window.innerHeight || te + q > se.bottom) && te - se.top > q && (Z.style.top = `${te - q + window.pageYOffset - A}px`);
        }
        Z.isConnected || (I != null && (Z.className = I), Z.setAttribute("aria-label", "Typeahead menu"), Z.setAttribute("id", "typeahead-menu"), Z.setAttribute("role", "listbox"), Z.style.display = "block", Z.style.position = "absolute", W.append(Z)), B.current = Z, F.setAttribute("aria-controls", "typeahead-menu");
      }
    }, [$, C, I, W]);
    t.useEffect(() => {
      const F = $.getRootElement();
      if (C !== null)
        return L(), () => {
          F !== null && F.removeAttribute("aria-controls");
          const Z = B.current;
          Z !== null && Z.isConnected && Z.remove();
        };
    }, [$, L, C]);
    const P = t.useCallback((F) => {
      C !== null && (F || x(null));
    }, [C, x]);
    return g(C, B.current, L, P), B;
  }
  function T(C) {
    t.startTransition ? t.startTransition(C) : C();
  }
  function D({
    options: C,
    nodeKey: x,
    onClose: I,
    onOpen: W,
    onSelectOption: $,
    menuRenderFn: B,
    anchorClassName: L,
    commandPriority: P = n.COMMAND_PRIORITY_LOW,
    parent: F
  }) {
    const [Z] = r.useLexicalComposerContext(), [oe, ne] = t.useState(null), te = w(oe, ne, L, F), K = t.useCallback(() => {
      ne(null), I != null && oe !== null && I();
    }, [I, oe]), A = t.useCallback((ie) => {
      ne(ie), W != null && oe === null && W(ie);
    }, [W, oe]), z = t.useCallback(() => {
      x ? Z.update(() => {
        const ie = n.$getNodeByKey(x), q = Z.getElementByKey(x);
        ie != null && q != null && oe == null && T(() => A({
          getRect: () => q.getBoundingClientRect()
        }));
      }) : x == null && oe != null && K();
    }, [K, Z, x, A, oe]);
    return t.useEffect(() => {
      z();
    }, [z, x]), t.useEffect(() => {
      if (x != null)
        return Z.registerUpdateListener(({
          dirtyElements: ie
        }) => {
          ie.get(x) && z();
        });
    }, [Z, z, x]), oe === null || Z === null ? null : /* @__PURE__ */ t.createElement(N, {
      close: K,
      resolution: oe,
      editor: Z,
      anchorElementRef: te,
      options: C,
      menuRenderFn: B,
      onSelectOption: $,
      commandPriority: P
    });
  }
  return xa.LexicalNodeMenuPlugin = D, xa.MenuOption = f, xa;
}
var Ea = {}, eg;
function vN() {
  if (eg)
    return Ea;
  eg = 1;
  var r = zt(), n = St(), t = $t, o = kt(), u = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  class p {
    constructor(w) {
      this.key = w, this.ref = { current: null }, this.setRefElement = this.setRefElement.bind(this);
    }
    setRefElement(w) {
      this.ref = { current: w };
    }
  }
  let m = (N) => {
    const w = document.getElementById("typeahead-menu");
    if (w) {
      var T = w.getBoundingClientRect();
      T.top + T.height > window.innerHeight && w.scrollIntoView({ block: "center" }), 0 > T.top && w.scrollIntoView({ block: "center" }), N.scrollIntoView({ block: "nearest" });
    }
  };
  function f(N) {
    var w = n.$getSelection();
    if (!n.$isRangeSelection(w) || !w.isCollapsed())
      return null;
    var T = w.anchor;
    if (T.type !== "text" || (w = T.getNode(), !w.isSimpleText()))
      return null;
    T = T.offset;
    let D = w.getTextContent().slice(0, T);
    var C = N.matchingString;
    N = N.replaceableString.length;
    for (let I = N; I <= C.length; I++)
      D.substr(-I) === C.substr(0, I) && (N = I);
    if (N = T - N, 0 > N)
      return null;
    let x;
    return N === 0 ? [x] = w.splitText(T) : [, x] = w.splitText(N, T), x;
  }
  function O(N, w) {
    let T = getComputedStyle(N), D = T.position === "absolute";
    if (w = w ? /(auto|scroll|hidden)/ : /(auto|scroll)/, T.position === "fixed")
      return document.body;
    for (; N = N.parentElement; )
      if (T = getComputedStyle(N), (!D || T.position !== "static") && w.test(T.overflow + T.overflowY + T.overflowX))
        return N;
    return document.body;
  }
  function S(N, w) {
    return N = N.getBoundingClientRect(), w = w.getBoundingClientRect(), N.top > w.top && N.top < w.bottom;
  }
  function E(N, w, T, D) {
    let [C] = r.useLexicalComposerContext();
    t.useEffect(() => {
      if (w != null && N != null) {
        let x = C.getRootElement(), I = x != null ? O(x, !1) : document.body, W = !1, $ = S(w, I), B = function() {
          W || (window.requestAnimationFrame(function() {
            T(), W = !1;
          }), W = !0);
          const P = S(w, I);
          P !== $ && ($ = P, D != null && D(P));
        }, L = new ResizeObserver(T);
        return window.addEventListener("resize", T), document.addEventListener("scroll", B, { capture: !0, passive: !0 }), L.observe(w), () => {
          L.unobserve(w), window.removeEventListener("resize", T), document.removeEventListener(
            "scroll",
            B,
            !0
          );
        };
      }
    }, [w, C, D, T, N]);
  }
  let R = n.createCommand("SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND");
  function y({ close: N, editor: w, anchorElementRef: T, resolution: D, options: C, menuRenderFn: x, onSelectOption: I, shouldSplitNodeWithQuery: W = !1, commandPriority: $ = n.COMMAND_PRIORITY_LOW }) {
    let [B, L] = t.useState(null);
    t.useEffect(() => {
      L(0);
    }, [D.match && D.match.matchingString]);
    let P = t.useCallback((oe) => {
      w.update(() => {
        const ne = D.match != null && W ? f(D.match) : null;
        I(oe, ne, N, D.match ? D.match.matchingString : "");
      });
    }, [w, W, D.match, I, N]), F = t.useCallback((oe) => {
      const ne = w.getRootElement();
      ne !== null && (ne.setAttribute(
        "aria-activedescendant",
        "typeahead-item-" + oe
      ), L(oe));
    }, [w]);
    t.useEffect(() => () => {
      let oe = w.getRootElement();
      oe !== null && oe.removeAttribute("aria-activedescendant");
    }, [w]), u(() => {
      C === null ? L(null) : B === null && F(0);
    }, [C, B, F]), t.useEffect(() => o.mergeRegister(w.registerCommand(R, ({ option: oe }) => oe.ref && oe.ref.current != null ? (m(oe.ref.current), !0) : !1, $)), [w, F, $]), t.useEffect(() => o.mergeRegister(w.registerCommand(n.KEY_ARROW_DOWN_COMMAND, (oe) => {
      if (C !== null && C.length && B !== null) {
        let ne = B !== C.length - 1 ? B + 1 : 0;
        F(ne);
        let te = C[ne];
        te.ref != null && te.ref.current && w.dispatchCommand(R, { index: ne, option: te }), oe.preventDefault(), oe.stopImmediatePropagation();
      }
      return !0;
    }, $), w.registerCommand(n.KEY_ARROW_UP_COMMAND, (oe) => {
      if (C !== null && C.length && B !== null) {
        var ne = B !== 0 ? B - 1 : C.length - 1;
        F(ne), ne = C[ne], ne.ref != null && ne.ref.current && m(ne.ref.current), oe.preventDefault(), oe.stopImmediatePropagation();
      }
      return !0;
    }, $), w.registerCommand(n.KEY_ESCAPE_COMMAND, (oe) => (oe.preventDefault(), oe.stopImmediatePropagation(), N(), !0), $), w.registerCommand(n.KEY_TAB_COMMAND, (oe) => C === null || B === null || C[B] == null ? !1 : (oe.preventDefault(), oe.stopImmediatePropagation(), P(C[B]), !0), $), w.registerCommand(n.KEY_ENTER_COMMAND, (oe) => C === null || B === null || C[B] == null ? !1 : (oe !== null && (oe.preventDefault(), oe.stopImmediatePropagation()), P(C[B]), !0), $)), [P, N, w, C, B, F, $]);
    let Z = t.useMemo(() => ({ options: C, selectOptionAndCleanUp: P, selectedIndex: B, setHighlightedIndex: L }), [P, B, C]);
    return x(T, Z, D.match ? D.match.matchingString : "");
  }
  function g(N, w, T, D = document.body) {
    let [C] = r.useLexicalComposerContext(), x = t.useRef(document.createElement("div")), I = t.useCallback(
      () => {
        x.current.style.top = x.current.style.bottom;
        const $ = C.getRootElement(), B = x.current;
        var L = B.firstChild;
        if ($ !== null && N !== null) {
          const { left: F, top: Z, width: oe, height: ne } = N.getRect();
          if (B.style.top = `${Z + window.pageYOffset + x.current.offsetHeight + 3}px`, B.style.left = `${F + window.pageXOffset}px`, B.style.height = `${ne}px`, B.style.width = `${oe}px`, L !== null) {
            L.style.top = `${Z}`;
            var P = L.getBoundingClientRect();
            L = P.height, P = P.width;
            const te = $.getBoundingClientRect();
            F + P > te.right && (B.style.left = `${te.right - P + window.pageXOffset}px`), (Z + L > window.innerHeight || Z + L > te.bottom) && Z - te.top > L && (B.style.top = `${Z - L + window.pageYOffset - ne}px`);
          }
          B.isConnected || (T != null && (B.className = T), B.setAttribute("aria-label", "Typeahead menu"), B.setAttribute("id", "typeahead-menu"), B.setAttribute("role", "listbox"), B.style.display = "block", B.style.position = "absolute", D.append(B)), x.current = B, $.setAttribute("aria-controls", "typeahead-menu");
        }
      },
      [C, N, T, D]
    );
    t.useEffect(() => {
      let $ = C.getRootElement();
      if (N !== null)
        return I(), () => {
          $ !== null && $.removeAttribute("aria-controls");
          let B = x.current;
          B !== null && B.isConnected && B.remove();
        };
    }, [C, I, N]);
    let W = t.useCallback(($) => {
      N !== null && ($ || w(null));
    }, [N, w]);
    return E(N, x.current, I, W), x;
  }
  function _(N) {
    t.startTransition ? t.startTransition(N) : N();
  }
  return Ea.LexicalNodeMenuPlugin = function({ options: N, nodeKey: w, onClose: T, onOpen: D, onSelectOption: C, menuRenderFn: x, anchorClassName: I, commandPriority: W = n.COMMAND_PRIORITY_LOW, parent: $ }) {
    let [B] = r.useLexicalComposerContext(), [L, P] = t.useState(null);
    I = g(L, P, I, $);
    let F = t.useCallback(() => {
      P(null), T != null && L !== null && T();
    }, [T, L]), Z = t.useCallback((ne) => {
      P(ne), D != null && L === null && D(ne);
    }, [D, L]), oe = t.useCallback(() => {
      w ? B.update(() => {
        const ne = n.$getNodeByKey(w), te = B.getElementByKey(w);
        ne != null && te != null && L == null && _(() => Z({ getRect: () => te.getBoundingClientRect() }));
      }) : w == null && L != null && F();
    }, [F, B, w, Z, L]);
    return t.useEffect(() => {
      oe();
    }, [oe, w]), t.useEffect(() => {
      if (w != null)
        return B.registerUpdateListener(({ dirtyElements: ne }) => {
          ne.get(w) && oe();
        });
    }, [B, oe, w]), L === null || B === null ? null : t.createElement(y, { close: F, resolution: L, editor: B, anchorElementRef: I, options: N, menuRenderFn: x, onSelectOption: C, commandPriority: W });
  }, Ea.MenuOption = p, Ea;
}
var Dc, tg;
function Eh() {
  return tg || (tg = 1, Dc = process.env.NODE_ENV === "development" ? ON() : vN()), Dc;
}
var ng;
function wN() {
  if (ng)
    return Ts;
  ng = 1;
  var r = dn, n = zt(), t = Eh(), o = kt(), u = St(), p = $t;
  const m = /((https?:\/\/(www\.)?)|(www\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/, f = u.createCommand("INSERT_EMBED_COMMAND");
  class O extends t.MenuOption {
    constructor(R, y) {
      super(R), this.title = R, this.onSelect = y.onSelect.bind(this);
    }
  }
  function S({
    embedConfigs: E,
    onOpenEmbedModalForConfig: R,
    getMenuOptions: y,
    menuRenderFn: g,
    menuCommandPriority: _ = u.COMMAND_PRIORITY_LOW
  }) {
    const [N] = n.useLexicalComposerContext(), [w, T] = p.useState(null), [D, C] = p.useState(null), x = p.useCallback(() => {
      T(null), C(null);
    }, []), I = p.useCallback((L) => {
      N.getEditorState().read(async () => {
        const P = u.$getNodeByKey(L);
        if (r.$isLinkNode(P))
          for (let F = 0; F < E.length; F++) {
            const Z = E[F];
            await Promise.resolve(Z.parseUrl(P.__url)) != null && (C(Z), T(P.getKey()));
          }
      });
    }, [N, E]);
    p.useEffect(() => {
      const L = (P, {
        updateTags: F,
        dirtyLeaves: Z
      }) => {
        for (const [oe, ne] of P)
          ne === "created" && F.has("paste") && Z.size <= 3 ? I(oe) : oe === w && x();
      };
      return o.mergeRegister(...[r.LinkNode, r.AutoLinkNode].map((P) => N.registerMutationListener(P, (...F) => L(...F))));
    }, [I, N, E, w, x]), p.useEffect(() => N.registerCommand(f, (L) => {
      const P = E.find(({
        type: F
      }) => F === L);
      return P ? (R(P), !0) : !1;
    }, u.COMMAND_PRIORITY_EDITOR), [N, E, R]);
    const W = p.useCallback(async () => {
      if (D != null && w != null) {
        const L = N.getEditorState().read(() => {
          const P = u.$getNodeByKey(w);
          return r.$isLinkNode(P) ? P : null;
        });
        if (r.$isLinkNode(L)) {
          const P = await Promise.resolve(D.parseUrl(L.__url));
          P != null && N.update(() => {
            u.$getSelection() || L.selectEnd(), D.insertNode(N, P), L.isAttached() && L.remove();
          });
        }
      }
    }, [D, N, w]), $ = p.useMemo(() => D != null && w != null ? y(D, W, x) : [], [D, W, y, w, x]), B = p.useCallback((L, P, F) => {
      N.update(() => {
        L.onSelect(P), F();
      });
    }, [N]);
    return w != null ? /* @__PURE__ */ p.createElement(t.LexicalNodeMenuPlugin, {
      nodeKey: w,
      onClose: x,
      onSelectOption: B,
      options: $,
      menuRenderFn: g,
      commandPriority: _
    }) : null;
  }
  return Ts.AutoEmbedOption = O, Ts.INSERT_EMBED_COMMAND = f, Ts.LexicalAutoEmbedPlugin = S, Ts.URL_MATCHER = m, Ts;
}
var ys = {}, rg;
function MN() {
  if (rg)
    return ys;
  rg = 1;
  var r = dn, n = zt(), t = Eh(), o = kt(), u = St(), p = $t;
  let m = u.createCommand("INSERT_EMBED_COMMAND");
  class f extends t.MenuOption {
    constructor(S, E) {
      super(S), this.title = S, this.onSelect = E.onSelect.bind(this);
    }
  }
  return ys.AutoEmbedOption = f, ys.INSERT_EMBED_COMMAND = m, ys.LexicalAutoEmbedPlugin = function({ embedConfigs: O, onOpenEmbedModalForConfig: S, getMenuOptions: E, menuRenderFn: R, menuCommandPriority: y = u.COMMAND_PRIORITY_LOW }) {
    let [g] = n.useLexicalComposerContext(), [_, N] = p.useState(null), [w, T] = p.useState(null), D = p.useCallback(() => {
      N(null), T(null);
    }, []), C = p.useCallback(
      ($) => {
        g.getEditorState().read(async () => {
          const B = u.$getNodeByKey($);
          if (r.$isLinkNode(B))
            for (let L = 0; L < O.length; L++) {
              const P = O[L];
              await Promise.resolve(P.parseUrl(B.__url)) != null && (T(P), N(B.getKey()));
            }
        });
      },
      [g, O]
    );
    p.useEffect(() => {
      let $ = (B, { updateTags: L, dirtyLeaves: P }) => {
        for (const [F, Z] of B)
          Z === "created" && L.has("paste") && 3 >= P.size ? C(F) : F === _ && D();
      };
      return o.mergeRegister(...[r.LinkNode, r.AutoLinkNode].map((B) => g.registerMutationListener(B, (...L) => $(...L))));
    }, [C, g, O, _, D]), p.useEffect(() => g.registerCommand(m, ($) => {
      let B = O.find(({ type: L }) => L === $);
      return B ? (S(B), !0) : !1;
    }, u.COMMAND_PRIORITY_EDITOR), [g, O, S]);
    let x = p.useCallback(async () => {
      if (w != null && _ != null) {
        const $ = g.getEditorState().read(() => {
          const B = u.$getNodeByKey(_);
          return r.$isLinkNode(B) ? B : null;
        });
        if (r.$isLinkNode($)) {
          const B = await Promise.resolve(w.parseUrl($.__url));
          B != null && g.update(() => {
            u.$getSelection() || $.selectEnd(), w.insertNode(g, B), $.isAttached() && $.remove();
          });
        }
      }
    }, [w, g, _]), I = p.useMemo(() => w != null && _ != null ? E(w, x, D) : [], [w, x, E, _, D]), W = p.useCallback(($, B, L) => {
      g.update(() => {
        $.onSelect(B), L();
      });
    }, [g]);
    return _ != null ? p.createElement(t.LexicalNodeMenuPlugin, { nodeKey: _, onClose: D, onSelectOption: W, options: I, menuRenderFn: R, commandPriority: y }) : null;
  }, ys.URL_MATCHER = /((https?:\/\/(www\.)?)|(www\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/, ys;
}
const RN = process.env.NODE_ENV === "development" ? wN() : MN();
var Ss = RN;
const Th = fe.createCommand(
  "INSERT_FIGMA_COMMAND"
);
function bN() {
  const [r] = gn.useLexicalComposerContext();
  return yt(() => {
    if (!r.hasNodes([El]))
      throw new Error("FigmaPlugin: FigmaNode not registered on editor");
    return r.registerCommand(
      Th,
      (n) => {
        const t = Zg(n);
        return Jt.$insertNodeToNearestRoot(t), !0;
      },
      fe.COMMAND_PRIORITY_EDITOR
    );
  }, [r]), null;
}
const yh = fe.createCommand(
  "INSERT_TWEET_COMMAND"
);
function AN() {
  const [r] = gn.useLexicalComposerContext();
  return yt(() => {
    if (!r.hasNodes([Tl]))
      throw new Error("TwitterPlugin: TweetNode not registered on editor");
    return r.registerCommand(
      yh,
      (n) => {
        const t = iu(n);
        return Jt.$insertNodeToNearestRoot(t), !0;
      },
      fe.COMMAND_PRIORITY_EDITOR
    );
  }, [r]), null;
}
const Sh = fe.createCommand(
  "INSERT_YOUTUBE_COMMAND"
);
function DN() {
  const [r] = gn.useLexicalComposerContext();
  return yt(() => {
    if (!r.hasNodes([yl]))
      throw new Error("YouTubePlugin: YouTubeNode not registered on editor");
    return r.registerCommand(
      Sh,
      (n) => {
        const t = su(n);
        return Jt.$insertNodeToNearestRoot(t), !0;
      },
      fe.COMMAND_PRIORITY_EDITOR
    );
  }, [r]), null;
}
const LN = {
  contentName: "Youtube Video",
  exampleUrl: "https://www.youtube.com/watch?v=jNQXAC9IVRw",
  // Icon for display.
  icon: /* @__PURE__ */ U.jsx("i", { className: "icon youtube" }),
  insertNode: (r, n) => {
    r.dispatchCommand(Sh, n.id);
  },
  keywords: ["youtube", "video"],
  // Determine if a given URL is a match and return url data.
  parseUrl: async (r) => {
    const n = /^.*(youtu\.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/.exec(r), t = n && (n == null ? void 0 : n[2].length) === 11 ? n[2] : null;
    return t != null ? {
      id: t,
      url: r
    } : null;
  },
  type: "youtube-video"
}, IN = {
  // e.g. Tweet or Google Map.
  contentName: "Tweet",
  exampleUrl: "https://twitter.com/jack/status/20",
  // Icon for display.
  icon: /* @__PURE__ */ U.jsx("i", { className: "icon tweet" }),
  // Create the Lexical embed node from the url data.
  insertNode: (r, n) => {
    r.dispatchCommand(yh, n.id);
  },
  // For extra searching.
  keywords: ["tweet", "twitter"],
  // Determine if a given URL is a match and return url data.
  parseUrl: (r) => {
    const n = /^https:\/\/(twitter|x)\.com\/(#!\/)?(\w+)\/status(es)*\/(\d+)/.exec(
      r
    );
    return n != null ? {
      id: n[5],
      url: n[1]
    } : null;
  },
  type: "tweet"
}, $N = {
  contentName: "Figma Document",
  exampleUrl: "https://www.figma.com/file/LKQ4FJ4bTnCSjedbRpk931/Sample-File",
  icon: /* @__PURE__ */ U.jsx("i", { className: "icon figma" }),
  insertNode: (r, n) => {
    r.dispatchCommand(Th, n.id);
  },
  keywords: ["figma", "figma.com", "mock-up"],
  // Determine if a given URL is a match and return url data.
  parseUrl: (r) => {
    const n = /https:\/\/([\w.-]+\.)?figma.com\/(file|proto)\/([0-9a-zA-Z]{22,128})(?:\/.*)?$/.exec(
      r
    );
    return n != null ? {
      id: n[3],
      url: n[0]
    } : null;
  },
  type: "figma"
}, xu = [
  IN,
  LN,
  $N
];
function kN({
  index: r,
  isSelected: n,
  onClick: t,
  onMouseEnter: o,
  option: u
}) {
  let p = "item";
  return n && (p += " selected"), /* @__PURE__ */ U.jsx(
    "li",
    {
      tabIndex: -1,
      className: p,
      ref: u.setRefElement,
      role: "option",
      "aria-selected": n,
      id: "typeahead-item-" + r,
      onMouseEnter: o,
      onClick: t,
      children: /* @__PURE__ */ U.jsx("span", { className: "text", children: u.title })
    },
    u.key
  );
}
function PN({
  options: r,
  selectedItemIndex: n,
  onOptionClick: t,
  onOptionMouseEnter: o
}) {
  return /* @__PURE__ */ U.jsx("div", { className: "typeahead-popover", children: /* @__PURE__ */ U.jsx("ul", { children: r.map((u, p) => /* @__PURE__ */ U.jsx(
    kN,
    {
      index: p,
      isSelected: n === p,
      onClick: () => t(u, p),
      onMouseEnter: () => o(p),
      option: u
    },
    u.key
  )) }) });
}
const FN = (r, n) => {
  let t;
  return (o) => {
    window.clearTimeout(t), t = window.setTimeout(() => {
      r(o);
    }, n);
  };
};
function BN({
  embedConfig: r,
  onClose: n
}) {
  const [t, o] = ut(""), [u] = gn.useLexicalComposerContext(), [p, m] = ut(null), f = Zr(
    () => FN((S) => {
      const E = Ss.URL_MATCHER.exec(S);
      r != null && S != null && E != null ? Promise.resolve(r.parseUrl(S)).then(
        (R) => {
          m(R);
        }
      ) : p != null && m(null);
    }, 200),
    [r, p]
  ), O = () => {
    p != null && (r.insertNode(u, p), n());
  };
  return /* @__PURE__ */ U.jsxs("div", { style: { width: "600px" }, children: [
    /* @__PURE__ */ U.jsx("div", { className: "Input__wrapper", children: /* @__PURE__ */ U.jsx(
      "input",
      {
        type: "text",
        className: "Input__input",
        placeholder: r.exampleUrl,
        value: t,
        "data-test-id": `${r.type}-embed-modal-url`,
        onChange: (S) => {
          const { value: E } = S.target;
          o(E), f(E);
        }
      }
    ) }),
    /* @__PURE__ */ U.jsx($s, { children: /* @__PURE__ */ U.jsx(
      po,
      {
        disabled: !p,
        onClick: O,
        "data-test-id": `${r.type}-embed-modal-submit-btn`,
        children: "Embed"
      }
    ) })
  ] });
}
function KN() {
  const [r, n] = ba(), t = (u) => {
    n(`Embed ${u.contentName}`, (p) => /* @__PURE__ */ U.jsx(BN, { embedConfig: u, onClose: p }));
  }, o = (u, p, m) => [
    new Ss.AutoEmbedOption("Dismiss", {
      onSelect: m
    }),
    new Ss.AutoEmbedOption(`Embed ${u.contentName}`, {
      onSelect: p
    })
  ];
  return /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    r,
    /* @__PURE__ */ U.jsx(
      Ss.LexicalAutoEmbedPlugin,
      {
        embedConfigs: xu,
        onOpenEmbedModalForConfig: t,
        getMenuOptions: o,
        menuRenderFn: (u, { selectedIndex: p, options: m, selectOptionAndCleanUp: f, setHighlightedIndex: O }) => u.current ? ml.createPortal(
          /* @__PURE__ */ U.jsx(
            "div",
            {
              className: "typeahead-popover auto-embed-menu",
              style: {
                marginLeft: u.current.style.width,
                width: 200
              },
              children: /* @__PURE__ */ U.jsx(
                PN,
                {
                  options: m,
                  selectedItemIndex: p,
                  onOptionClick: (S, E) => {
                    O(E), f(S);
                  },
                  onOptionMouseEnter: (S) => {
                    O(S);
                  }
                }
              )
            }
          ),
          u.current
        ) : null
      }
    )
  ] });
}
const Qc = {
  bullet: "Bulleted List",
  check: "Check List",
  code: "Code Block",
  h1: "Heading 1",
  h2: "Heading 2",
  h3: "Heading 3",
  h4: "Heading 4",
  h5: "Heading 5",
  h6: "Heading 6",
  number: "Numbered List",
  paragraph: "Normal",
  quote: "Quote"
}, jN = [
  ["Arial", "Arial"],
  ["Courier New", "Courier New"],
  ["Georgia", "Georgia"],
  ["Times New Roman", "Times New Roman"],
  ["Trebuchet MS", "Trebuchet MS"],
  ["Verdana", "Verdana"]
], HN = [
  ["10px", "10px"],
  ["11px", "11px"],
  ["12px", "12px"],
  ["13px", "13px"],
  ["14px", "14px"],
  ["15px", "15px"],
  ["16px", "16px"],
  ["17px", "17px"],
  ["18px", "18px"],
  ["19px", "19px"],
  ["20px", "20px"]
], hl = {
  center: {
    icon: "center-align",
    iconRTL: "center-align",
    name: "Center Align"
  },
  end: {
    icon: "right-align",
    iconRTL: "left-align",
    name: "End Align"
  },
  justify: {
    icon: "justify-align",
    iconRTL: "justify-align",
    name: "Justify Align"
  },
  left: {
    icon: "left-align",
    iconRTL: "left-align",
    name: "Left Align"
  },
  right: {
    icon: "right-align",
    iconRTL: "right-align",
    name: "Right Align"
  },
  start: {
    icon: "left-align",
    iconRTL: "right-align",
    name: "Start Align"
  }
};
function Hr(r) {
  return r ? "active dropdown-item-active" : "";
}
function WN({
  editor: r,
  blockType: n,
  disabled: t = !1
}) {
  const o = () => {
    r.update(() => {
      const S = fe.$getSelection();
      sr.$setBlocksType(S, () => fe.$createParagraphNode());
    });
  }, u = (S) => {
    n !== S && r.update(() => {
      const E = fe.$getSelection();
      sr.$setBlocksType(E, () => Tr.$createHeadingNode(S));
    });
  }, p = () => {
    n !== "bullet" ? r.dispatchCommand(Vn.INSERT_UNORDERED_LIST_COMMAND, void 0) : o();
  }, m = () => {
    n !== "check" ? r.dispatchCommand(Vn.INSERT_CHECK_LIST_COMMAND, void 0) : o();
  }, f = () => {
    n !== "number" ? r.dispatchCommand(Vn.INSERT_ORDERED_LIST_COMMAND, void 0) : o();
  }, O = () => {
    n !== "quote" && r.update(() => {
      const S = fe.$getSelection();
      sr.$setBlocksType(S, () => Tr.$createQuoteNode());
    });
  };
  return /* @__PURE__ */ U.jsxs(
    Bi,
    {
      disabled: t,
      buttonClassName: "toolbar-item block-controls",
      buttonIconClassName: "icon block-type " + n,
      buttonLabel: Qc[n],
      buttonAriaLabel: "Formatting options for text style",
      children: [
        /* @__PURE__ */ U.jsxs(
          sn,
          {
            className: "item " + Hr(n === "paragraph"),
            onClick: o,
            children: [
              /* @__PURE__ */ U.jsx("i", { className: "icon paragraph" }),
              /* @__PURE__ */ U.jsx("span", { className: "text", children: "Normal" })
            ]
          }
        ),
        /* @__PURE__ */ U.jsxs(
          sn,
          {
            className: "item " + Hr(n === "h1"),
            onClick: () => u("h1"),
            children: [
              /* @__PURE__ */ U.jsx("i", { className: "icon h1" }),
              /* @__PURE__ */ U.jsx("span", { className: "text", children: "Heading 1" })
            ]
          }
        ),
        /* @__PURE__ */ U.jsxs(
          sn,
          {
            className: "item " + Hr(n === "h2"),
            onClick: () => u("h2"),
            children: [
              /* @__PURE__ */ U.jsx("i", { className: "icon h2" }),
              /* @__PURE__ */ U.jsx("span", { className: "text", children: "Heading 2" })
            ]
          }
        ),
        /* @__PURE__ */ U.jsxs(
          sn,
          {
            className: "item " + Hr(n === "h3"),
            onClick: () => u("h3"),
            children: [
              /* @__PURE__ */ U.jsx("i", { className: "icon h3" }),
              /* @__PURE__ */ U.jsx("span", { className: "text", children: "Heading 3" })
            ]
          }
        ),
        /* @__PURE__ */ U.jsxs(
          sn,
          {
            className: "item " + Hr(n === "bullet"),
            onClick: p,
            children: [
              /* @__PURE__ */ U.jsx("i", { className: "icon bullet-list" }),
              /* @__PURE__ */ U.jsx("span", { className: "text", children: "Bullet List" })
            ]
          }
        ),
        /* @__PURE__ */ U.jsxs(
          sn,
          {
            className: "item " + Hr(n === "number"),
            onClick: f,
            children: [
              /* @__PURE__ */ U.jsx("i", { className: "icon numbered-list" }),
              /* @__PURE__ */ U.jsx("span", { className: "text", children: "Numbered List" })
            ]
          }
        ),
        /* @__PURE__ */ U.jsxs(
          sn,
          {
            className: "item " + Hr(n === "check"),
            onClick: m,
            children: [
              /* @__PURE__ */ U.jsx("i", { className: "icon check-list" }),
              /* @__PURE__ */ U.jsx("span", { className: "text", children: "Check List" })
            ]
          }
        ),
        /* @__PURE__ */ U.jsxs(
          sn,
          {
            className: "item " + Hr(n === "quote"),
            onClick: O,
            children: [
              /* @__PURE__ */ U.jsx("i", { className: "icon quote" }),
              /* @__PURE__ */ U.jsx("span", { className: "text", children: "Quote" })
            ]
          }
        )
      ]
    }
  );
}
function UN({
  editor: r,
  value: n,
  style: t,
  disabled: o = !1
}) {
  const u = Vt(
    (m) => {
      r.update(() => {
        const f = fe.$getSelection();
        f !== null && sr.$patchStyleText(f, {
          [t]: m
        });
      });
    },
    [r, t]
  ), p = t === "font-family" ? "Formatting options for font family" : "Formatting options for font size";
  return /* @__PURE__ */ U.jsx(
    Bi,
    {
      disabled: o,
      buttonClassName: "toolbar-item " + t,
      buttonLabel: n,
      buttonIconClassName: t === "font-family" ? "icon block-type font-family" : "",
      buttonAriaLabel: p,
      children: (t === "font-family" ? jN : HN).map(
        ([m, f]) => /* @__PURE__ */ U.jsx(
          sn,
          {
            className: `item ${Hr(n === m)} ${t === "font-size" ? "fontsize-item" : ""}`,
            onClick: () => u(m),
            children: /* @__PURE__ */ U.jsx("span", { className: "text", children: f })
          },
          m
        )
      )
    }
  );
}
function Ai() {
  return /* @__PURE__ */ U.jsx("div", { className: "divider" });
}
function YN({
  editor: r,
  value: n,
  isRTL: t,
  disabled: o = !1
}) {
  const u = hl[n || "left"];
  return /* @__PURE__ */ U.jsxs(
    Bi,
    {
      disabled: o,
      buttonLabel: u.name,
      buttonIconClassName: `icon ${t ? u.iconRTL : u.icon}`,
      buttonClassName: "toolbar-item spaced alignment",
      buttonAriaLabel: "Formatting options for text alignment",
      children: [
        /* @__PURE__ */ U.jsxs(
          sn,
          {
            onClick: () => {
              r.dispatchCommand(fe.FORMAT_ELEMENT_COMMAND, "left");
            },
            className: "item",
            children: [
              /* @__PURE__ */ U.jsx("i", { className: "icon left-align" }),
              /* @__PURE__ */ U.jsx("span", { className: "text", children: "Left Align" })
            ]
          }
        ),
        /* @__PURE__ */ U.jsxs(
          sn,
          {
            onClick: () => {
              r.dispatchCommand(fe.FORMAT_ELEMENT_COMMAND, "center");
            },
            className: "item",
            children: [
              /* @__PURE__ */ U.jsx("i", { className: "icon center-align" }),
              /* @__PURE__ */ U.jsx("span", { className: "text", children: "Center Align" })
            ]
          }
        ),
        /* @__PURE__ */ U.jsxs(
          sn,
          {
            onClick: () => {
              r.dispatchCommand(fe.FORMAT_ELEMENT_COMMAND, "right");
            },
            className: "item",
            children: [
              /* @__PURE__ */ U.jsx("i", { className: "icon right-align" }),
              /* @__PURE__ */ U.jsx("span", { className: "text", children: "Right Align" })
            ]
          }
        ),
        /* @__PURE__ */ U.jsxs(
          sn,
          {
            onClick: () => {
              r.dispatchCommand(fe.FORMAT_ELEMENT_COMMAND, "justify");
            },
            className: "item",
            children: [
              /* @__PURE__ */ U.jsx("i", { className: "icon justify-align" }),
              /* @__PURE__ */ U.jsx("span", { className: "text", children: "Justify Align" })
            ]
          }
        ),
        /* @__PURE__ */ U.jsxs(
          sn,
          {
            onClick: () => {
              r.dispatchCommand(fe.FORMAT_ELEMENT_COMMAND, "start");
            },
            className: "item",
            children: [
              /* @__PURE__ */ U.jsx(
                "i",
                {
                  className: `icon ${t ? hl.start.iconRTL : hl.start.icon}`
                }
              ),
              /* @__PURE__ */ U.jsx("span", { className: "text", children: "Start Align" })
            ]
          }
        ),
        /* @__PURE__ */ U.jsxs(
          sn,
          {
            onClick: () => {
              r.dispatchCommand(fe.FORMAT_ELEMENT_COMMAND, "end");
            },
            className: "item",
            children: [
              /* @__PURE__ */ U.jsx(
                "i",
                {
                  className: `icon ${t ? hl.end.iconRTL : hl.end.icon}`
                }
              ),
              /* @__PURE__ */ U.jsx("span", { className: "text", children: "End Align" })
            ]
          }
        ),
        /* @__PURE__ */ U.jsx(Ai, {}),
        /* @__PURE__ */ U.jsxs(
          sn,
          {
            onClick: () => {
              r.dispatchCommand(fe.OUTDENT_CONTENT_COMMAND, void 0);
            },
            className: "item",
            children: [
              /* @__PURE__ */ U.jsx("i", { className: "icon " + (t ? "indent" : "outdent") }),
              /* @__PURE__ */ U.jsx("span", { className: "text", children: "Outdent" })
            ]
          }
        ),
        /* @__PURE__ */ U.jsxs(
          sn,
          {
            onClick: () => {
              r.dispatchCommand(fe.INDENT_CONTENT_COMMAND, void 0);
            },
            className: "item",
            children: [
              /* @__PURE__ */ U.jsx("i", { className: "icon " + (t ? "outdent" : "indent") }),
              /* @__PURE__ */ U.jsx("span", { className: "text", children: "Indent" })
            ]
          }
        )
      ]
    }
  );
}
function zN({ setIsLinkEditMode: r }) {
  const [n] = gn.useLexicalComposerContext(), [t, o] = ut("paragraph"), [u, p] = ut(n), [m, f] = ut("15px"), [O, S] = ut("#000"), [E, R] = ut("#fff"), [y, g] = ut("Arial"), [_, N] = ut("left"), [w, T] = ut(!1), [D, C] = ut(!1), [x, I] = ut(!1), [W, $] = ut(!1), [B, L] = ut(!1), [P, F] = ut(!1), [Z, oe] = ut(!1), [ne, te] = ut(!1), [K, A] = ut(!1), [z, ie] = ut(!1), [q, Y] = ut(!1), [se, j] = ut(() => n.isEditable()), [Q, ae] = ba(), de = Vt(() => {
    const J = fe.$getSelection();
    if (fe.$isRangeSelection(J)) {
      const G = J.anchor.getNode();
      let H = G.getKey() === "root" ? G : Jt.$findMatchingParent(G, (Ie) => {
        const je = Ie.getParent();
        return je !== null && fe.$isRootOrShadowRoot(je);
      });
      H === null && (H = G.getTopLevelElementOrThrow());
      const re = H.getKey(), le = u.getElementByKey(re);
      C(J.hasFormat("bold")), I(J.hasFormat("italic")), $(J.hasFormat("underline")), L(J.hasFormat("strikethrough")), F(J.hasFormat("subscript")), oe(J.hasFormat("superscript")), te(J.hasFormat("code")), A(sr.$isParentElementRTL(J));
      const me = ws(J), ge = me.getParent();
      if (dn.$isLinkNode(ge) || dn.$isLinkNode(me) ? T(!0) : T(!1), le !== null)
        if (Vn.$isListNode(H)) {
          const Ie = Jt.$getNearestNodeOfType(
            G,
            Vn.ListNode
          ), je = Ie ? Ie.getListType() : H.getListType();
          o(je);
        } else {
          const Ie = Tr.$isHeadingNode(H) ? H.getTag() : H.getType();
          Ie in Qc && o(Ie);
        }
      f(
        sr.$getSelectionStyleValueForProperty(J, "font-size", "15px")
      ), S(
        sr.$getSelectionStyleValueForProperty(J, "color", "#000")
      ), R(
        sr.$getSelectionStyleValueForProperty(
          J,
          "background-color",
          "#fff"
        )
      ), g(
        sr.$getSelectionStyleValueForProperty(J, "font-family", "Arial")
      );
      let Me;
      dn.$isLinkNode(ge) && (Me = Jt.$findMatchingParent(
        me,
        (Ie) => fe.$isElementNode(Ie) && !Ie.isInline()
      )), N(
        fe.$isElementNode(Me) ? Me.getFormatType() : fe.$isElementNode(me) ? me.getFormatType() : (ge == null ? void 0 : ge.getFormatType()) || "left"
      );
    }
  }, [u]);
  yt(() => n.registerCommand(
    fe.SELECTION_CHANGE_COMMAND,
    (J, G) => (de(), p(G), !1),
    fe.COMMAND_PRIORITY_CRITICAL
  ), [n, de]), yt(() => Jt.mergeRegister(
    n.registerEditableListener((J) => {
      j(J);
    }),
    u.registerUpdateListener(({ editorState: J }) => {
      J.read(() => {
        de();
      });
    }),
    u.registerCommand(
      fe.CAN_UNDO_COMMAND,
      (J) => (ie(J), !1),
      fe.COMMAND_PRIORITY_CRITICAL
    ),
    u.registerCommand(
      fe.CAN_REDO_COMMAND,
      (J) => (Y(J), !1),
      fe.COMMAND_PRIORITY_CRITICAL
    )
  ), [de, u, n]), yt(() => u.registerCommand(
    fe.KEY_MODIFIER_COMMAND,
    (J) => {
      const G = J, { code: H, ctrlKey: re, metaKey: le } = G;
      if (H === "KeyK" && (re || le)) {
        G.preventDefault();
        let me;
        return w ? (r(!1), me = null) : (r(!0), me = wa("https://")), u.dispatchCommand(dn.TOGGLE_LINK_COMMAND, me);
      }
      return !1;
    },
    fe.COMMAND_PRIORITY_NORMAL
  ), [u, w, r]);
  const Ne = Vt(
    (J, G) => {
      u.update(
        () => {
          const H = fe.$getSelection();
          H !== null && sr.$patchStyleText(H, J);
        },
        G ? { tag: "historic" } : {}
      );
    },
    [u]
  ), De = Vt(() => {
    u.update(() => {
      const J = fe.$getSelection();
      if (fe.$isRangeSelection(J)) {
        const G = J.anchor, H = J.focus, re = J.getNodes();
        if (G.key === H.key && G.offset === H.offset)
          return;
        re.forEach((le, me) => {
          if (fe.$isTextNode(le)) {
            let ge = le;
            me === 0 && G.offset !== 0 && (ge = ge.splitText(G.offset)[1] || ge), me === re.length - 1 && (ge = ge.splitText(H.offset)[0] || ge), ge.__style !== "" && ge.setStyle(""), ge.__format !== 0 && (ge.setFormat(0), Jt.$getNearestBlockElementAncestorOrThrow(ge).setFormat("")), le = ge;
          } else
            Tr.$isHeadingNode(le) || Tr.$isQuoteNode(le) ? le.replace(fe.$createParagraphNode(), !0) : bs.$isDecoratorBlockNode(le) && le.setFormat("");
        });
      }
    });
  }, [u]), Pe = Vt(
    (J, G) => {
      Ne({ color: J }, G);
    },
    [Ne]
  ), Le = Vt(
    (J, G) => {
      Ne({ "background-color": J }, G);
    },
    [Ne]
  ), ke = Vt(() => {
    w ? (r(!1), n.dispatchCommand(dn.TOGGLE_LINK_COMMAND, null)) : (r(!0), n.dispatchCommand(dn.TOGGLE_LINK_COMMAND, wa("https://")));
  }, [n, w, r]);
  return /* @__PURE__ */ U.jsxs("div", { className: "toolbar", children: [
    /* @__PURE__ */ U.jsx(
      "button",
      {
        disabled: !z || !se,
        onClick: () => {
          u.dispatchCommand(fe.UNDO_COMMAND, void 0);
        },
        title: ui ? "Undo (⌘Z)" : "Undo (Ctrl+Z)",
        type: "button",
        className: "toolbar-item spaced",
        "aria-label": "Undo",
        children: /* @__PURE__ */ U.jsx("i", { className: "format undo" })
      }
    ),
    /* @__PURE__ */ U.jsx(
      "button",
      {
        disabled: !q || !se,
        onClick: () => {
          u.dispatchCommand(fe.REDO_COMMAND, void 0);
        },
        title: ui ? "Redo (⌘Y)" : "Redo (Ctrl+Y)",
        type: "button",
        className: "toolbar-item spaced",
        "aria-label": "Redo",
        children: /* @__PURE__ */ U.jsx("i", { className: "format redo" })
      }
    ),
    /* @__PURE__ */ U.jsx(Ai, {}),
    t in Qc && u === n && /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
      /* @__PURE__ */ U.jsx(
        WN,
        {
          disabled: !se,
          blockType: t,
          editor: n
        }
      ),
      /* @__PURE__ */ U.jsx(Ai, {})
    ] }),
    /* @__PURE__ */ U.jsx(
      UN,
      {
        disabled: !se,
        editor: n,
        value: y,
        style: "font-family"
      }
    ),
    /* @__PURE__ */ U.jsx(Ai, {}),
    /* @__PURE__ */ U.jsx(k_, { selectionFontSize: m.slice(0, -2), editor: n, disabled: !se }),
    /* @__PURE__ */ U.jsx(Ai, {}),
    /* @__PURE__ */ U.jsx(
      "button",
      {
        disabled: !se,
        onClick: () => {
          u.dispatchCommand(fe.FORMAT_TEXT_COMMAND, "bold");
        },
        className: "toolbar-item spaced " + (D ? "active" : ""),
        title: ui ? "Bold (⌘B)" : "Bold (Ctrl+B)",
        type: "button",
        "aria-label": `Format text as bold. Shortcut: ${ui ? "⌘B" : "Ctrl+B"}`,
        children: /* @__PURE__ */ U.jsx("i", { className: "format bold" })
      }
    ),
    /* @__PURE__ */ U.jsx(
      "button",
      {
        disabled: !se,
        onClick: () => {
          u.dispatchCommand(fe.FORMAT_TEXT_COMMAND, "italic");
        },
        className: "toolbar-item spaced " + (x ? "active" : ""),
        title: ui ? "Italic (⌘I)" : "Italic (Ctrl+I)",
        type: "button",
        "aria-label": `Format text as italics. Shortcut: ${ui ? "⌘I" : "Ctrl+I"}`,
        children: /* @__PURE__ */ U.jsx("i", { className: "format italic" })
      }
    ),
    /* @__PURE__ */ U.jsx(
      "button",
      {
        disabled: !se,
        onClick: () => {
          u.dispatchCommand(fe.FORMAT_TEXT_COMMAND, "underline");
        },
        className: "toolbar-item spaced " + (W ? "active" : ""),
        title: ui ? "Underline (⌘U)" : "Underline (Ctrl+U)",
        type: "button",
        "aria-label": `Format text to underlined. Shortcut: ${ui ? "⌘U" : "Ctrl+U"}`,
        children: /* @__PURE__ */ U.jsx("i", { className: "format underline" })
      }
    ),
    /* @__PURE__ */ U.jsx(
      "button",
      {
        disabled: !se,
        onClick: () => {
          u.dispatchCommand(fe.FORMAT_TEXT_COMMAND, "code");
        },
        className: "toolbar-item spaced " + (ne ? "active" : ""),
        title: "Insert code block",
        type: "button",
        "aria-label": "Insert code block",
        children: /* @__PURE__ */ U.jsx("i", { className: "format code" })
      }
    ),
    /* @__PURE__ */ U.jsx(
      "button",
      {
        disabled: !se,
        onClick: ke,
        className: "toolbar-item spaced " + (w ? "active" : ""),
        "aria-label": "Insert link",
        title: "Insert link",
        type: "button",
        children: /* @__PURE__ */ U.jsx("i", { className: "format link" })
      }
    ),
    /* @__PURE__ */ U.jsx(
      Xf,
      {
        disabled: !se,
        buttonClassName: "toolbar-item color-picker",
        buttonAriaLabel: "Formatting text color",
        buttonIconClassName: "icon font-color",
        color: O,
        onChange: Pe,
        title: "text color"
      }
    ),
    /* @__PURE__ */ U.jsx(
      Xf,
      {
        disabled: !se,
        buttonClassName: "toolbar-item color-picker",
        buttonAriaLabel: "Formatting background color",
        buttonIconClassName: "icon bg-color",
        color: E,
        onChange: Le,
        title: "bg color"
      }
    ),
    /* @__PURE__ */ U.jsxs(
      Bi,
      {
        disabled: !se,
        buttonClassName: "toolbar-item spaced",
        buttonLabel: "",
        buttonAriaLabel: "Formatting options for additional text styles",
        buttonIconClassName: "icon dropdown-more",
        children: [
          /* @__PURE__ */ U.jsxs(
            sn,
            {
              onClick: () => {
                u.dispatchCommand(
                  fe.FORMAT_TEXT_COMMAND,
                  "strikethrough"
                );
              },
              className: "item " + Hr(B),
              title: "Strikethrough",
              "aria-label": "Format text with a strikethrough",
              children: [
                /* @__PURE__ */ U.jsx("i", { className: "icon strikethrough" }),
                /* @__PURE__ */ U.jsx("span", { className: "text", children: "Strikethrough" })
              ]
            }
          ),
          /* @__PURE__ */ U.jsxs(
            sn,
            {
              onClick: () => {
                u.dispatchCommand(fe.FORMAT_TEXT_COMMAND, "subscript");
              },
              className: "item " + Hr(P),
              title: "Subscript",
              "aria-label": "Format text with a subscript",
              children: [
                /* @__PURE__ */ U.jsx("i", { className: "icon subscript" }),
                /* @__PURE__ */ U.jsx("span", { className: "text", children: "Subscript" })
              ]
            }
          ),
          /* @__PURE__ */ U.jsxs(
            sn,
            {
              onClick: () => {
                u.dispatchCommand(
                  fe.FORMAT_TEXT_COMMAND,
                  "superscript"
                );
              },
              className: "item " + Hr(Z),
              title: "Superscript",
              "aria-label": "Format text with a superscript",
              children: [
                /* @__PURE__ */ U.jsx("i", { className: "icon superscript" }),
                /* @__PURE__ */ U.jsx("span", { className: "text", children: "Superscript" })
              ]
            }
          ),
          /* @__PURE__ */ U.jsxs(
            sn,
            {
              onClick: De,
              className: "item",
              title: "Clear text formatting",
              "aria-label": "Clear all text formatting",
              children: [
                /* @__PURE__ */ U.jsx("i", { className: "icon clear" }),
                /* @__PURE__ */ U.jsx("span", { className: "text", children: "Clear Formatting" })
              ]
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ U.jsx(Ai, {}),
    /* @__PURE__ */ U.jsxs(
      Bi,
      {
        disabled: !se,
        buttonClassName: "toolbar-item spaced",
        buttonLabel: "Insert",
        buttonAriaLabel: "Insert specialized editor node",
        buttonIconClassName: "icon plus",
        children: [
          /* @__PURE__ */ U.jsxs(
            sn,
            {
              onClick: () => {
                u.dispatchCommand(
                  Cl.INSERT_HORIZONTAL_RULE_COMMAND,
                  void 0
                );
              },
              className: "item",
              children: [
                /* @__PURE__ */ U.jsx("i", { className: "icon horizontal-rule" }),
                /* @__PURE__ */ U.jsx("span", { className: "text", children: "Horizontal Rule" })
              ]
            }
          ),
          /* @__PURE__ */ U.jsxs(
            sn,
            {
              onClick: () => {
                u.dispatchCommand(hu, void 0);
              },
              className: "item",
              children: [
                /* @__PURE__ */ U.jsx("i", { className: "icon page-break" }),
                /* @__PURE__ */ U.jsx("span", { className: "text", children: "Page Break" })
              ]
            }
          ),
          /* @__PURE__ */ U.jsxs(
            sn,
            {
              onClick: () => {
                ae("Insert Image", (J) => /* @__PURE__ */ U.jsx(
                  ch,
                  {
                    activeEditor: u,
                    onClose: J
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ U.jsx("i", { className: "icon image" }),
                /* @__PURE__ */ U.jsx("span", { className: "text", children: "Image" })
              ]
            }
          ),
          /* @__PURE__ */ U.jsxs(
            sn,
            {
              onClick: () => {
                ae("Insert Inline Image", (J) => /* @__PURE__ */ U.jsx(
                  iN,
                  {
                    activeEditor: u,
                    onClose: J
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ U.jsx("i", { className: "icon image" }),
                /* @__PURE__ */ U.jsx("span", { className: "text", children: "Inline Image" })
              ]
            }
          ),
          /* @__PURE__ */ U.jsxs(
            sn,
            {
              onClick: () => {
                u.dispatchCommand(
                  Nu,
                  void 0
                );
              },
              className: "item",
              children: [
                /* @__PURE__ */ U.jsx("i", { className: "icon diagram-2" }),
                /* @__PURE__ */ U.jsx("span", { className: "text", children: "Excalidraw" })
              ]
            }
          ),
          /* @__PURE__ */ U.jsxs(
            sn,
            {
              onClick: () => {
                ae("Insert Table", (J) => /* @__PURE__ */ U.jsx(
                  hh,
                  {
                    activeEditor: u,
                    onClose: J
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ U.jsx("i", { className: "icon table" }),
                /* @__PURE__ */ U.jsx("span", { className: "text", children: "Table" })
              ]
            }
          ),
          /* @__PURE__ */ U.jsxs(
            sn,
            {
              onClick: () => {
                ae("Insert Poll", (J) => /* @__PURE__ */ U.jsx(
                  mh,
                  {
                    activeEditor: u,
                    onClose: J
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ U.jsx("i", { className: "icon poll" }),
                /* @__PURE__ */ U.jsx("span", { className: "text", children: "Poll" })
              ]
            }
          ),
          /* @__PURE__ */ U.jsxs(
            sn,
            {
              onClick: () => {
                ae("Insert Columns Layout", (J) => /* @__PURE__ */ U.jsx(
                  Nh,
                  {
                    activeEditor: u,
                    onClose: J
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ U.jsx("i", { className: "icon columns" }),
                /* @__PURE__ */ U.jsx("span", { className: "text", children: "Columns Layout" })
              ]
            }
          ),
          /* @__PURE__ */ U.jsxs(
            sn,
            {
              onClick: () => {
                ae("Insert Equation", (J) => /* @__PURE__ */ U.jsx(
                  xh,
                  {
                    activeEditor: u,
                    onClose: J
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ U.jsx("i", { className: "icon equation" }),
                /* @__PURE__ */ U.jsx("span", { className: "text", children: "Equation" })
              ]
            }
          ),
          /* @__PURE__ */ U.jsxs(
            sn,
            {
              onClick: () => {
                n.update(() => {
                  const J = fe.$getRoot(), G = Ym(0, 0);
                  J.append(G);
                });
              },
              className: "item",
              children: [
                /* @__PURE__ */ U.jsx("i", { className: "icon sticky" }),
                /* @__PURE__ */ U.jsx("span", { className: "text", children: "Sticky Note" })
              ]
            }
          ),
          /* @__PURE__ */ U.jsxs(
            sn,
            {
              onClick: () => {
                n.dispatchCommand(Cu, void 0);
              },
              className: "item",
              children: [
                /* @__PURE__ */ U.jsx("i", { className: "icon caret-right" }),
                /* @__PURE__ */ U.jsx("span", { className: "text", children: "Collapsible container" })
              ]
            }
          ),
          xu.map((J) => /* @__PURE__ */ U.jsxs(
            sn,
            {
              onClick: () => {
                u.dispatchCommand(
                  Ss.INSERT_EMBED_COMMAND,
                  J.type
                );
              },
              className: "item",
              children: [
                J.icon,
                /* @__PURE__ */ U.jsx("span", { className: "text", children: J.contentName })
              ]
            },
            J.type
          ))
        ]
      }
    ),
    /* @__PURE__ */ U.jsx(Ai, {}),
    /* @__PURE__ */ U.jsx(
      YN,
      {
        disabled: !se,
        value: _,
        editor: n,
        isRTL: K
      }
    ),
    Q
  ] });
}
var Lc = {}, og;
function qN() {
  if (og)
    return Lc;
  og = 1;
  var r = Vn, n = zt(), t = $t, o = kt(), u = St();
  function p(f) {
    t.useEffect(() => o.mergeRegister(f.registerCommand(r.INSERT_ORDERED_LIST_COMMAND, () => (r.insertList(f, "number"), !0), u.COMMAND_PRIORITY_LOW), f.registerCommand(r.INSERT_UNORDERED_LIST_COMMAND, () => (r.insertList(f, "bullet"), !0), u.COMMAND_PRIORITY_LOW), f.registerCommand(r.REMOVE_LIST_COMMAND, () => (r.removeList(f), !0), u.COMMAND_PRIORITY_LOW), f.registerCommand(u.INSERT_PARAGRAPH_COMMAND, () => !!r.$handleListInsertParagraph(), u.COMMAND_PRIORITY_LOW)), [f]);
  }
  function m() {
    const [f] = n.useLexicalComposerContext();
    return t.useEffect(() => {
      if (!f.hasNodes([r.ListNode, r.ListItemNode]))
        throw new Error("ListPlugin: ListNode and/or ListItemNode not registered on editor");
    }, [f]), p(f), null;
  }
  return Lc.ListPlugin = m, Lc;
}
var Ic = {}, ig;
function GN() {
  if (ig)
    return Ic;
  ig = 1;
  var r = Vn, n = zt(), t = $t, o = kt(), u = St();
  function p(m) {
    t.useEffect(() => o.mergeRegister(m.registerCommand(r.INSERT_ORDERED_LIST_COMMAND, () => (r.insertList(m, "number"), !0), u.COMMAND_PRIORITY_LOW), m.registerCommand(r.INSERT_UNORDERED_LIST_COMMAND, () => (r.insertList(m, "bullet"), !0), u.COMMAND_PRIORITY_LOW), m.registerCommand(r.REMOVE_LIST_COMMAND, () => (r.removeList(m), !0), u.COMMAND_PRIORITY_LOW), m.registerCommand(u.INSERT_PARAGRAPH_COMMAND, () => !!r.$handleListInsertParagraph(), u.COMMAND_PRIORITY_LOW)), [m]);
  }
  return Ic.ListPlugin = function() {
    let [m] = n.useLexicalComposerContext();
    return t.useEffect(() => {
      if (!m.hasNodes([r.ListNode, r.ListItemNode]))
        throw Error("ListPlugin: ListNode and/or ListItemNode not registered on editor");
    }, [m]), p(m), null;
  }, Ic;
}
const VN = process.env.NODE_ENV === "development" ? qN() : GN();
var JN = VN, $c = {}, sg;
function XN() {
  if (sg)
    return $c;
  sg = 1;
  var r = Vn, n = zt(), t = kt(), o = St(), u = $t;
  function p() {
    const [g] = n.useLexicalComposerContext();
    return u.useEffect(() => t.mergeRegister(g.registerCommand(r.INSERT_CHECK_LIST_COMMAND, () => (r.insertList(g, "check"), !0), o.COMMAND_PRIORITY_LOW), g.registerCommand(o.KEY_ARROW_DOWN_COMMAND, (_) => y(_, g, !1), o.COMMAND_PRIORITY_LOW), g.registerCommand(o.KEY_ARROW_UP_COMMAND, (_) => y(_, g, !0), o.COMMAND_PRIORITY_LOW), g.registerCommand(o.KEY_ESCAPE_COMMAND, (_) => {
      if (E() != null) {
        const w = g.getRootElement();
        return w != null && w.focus(), !0;
      }
      return !1;
    }, o.COMMAND_PRIORITY_LOW), g.registerCommand(o.KEY_SPACE_COMMAND, (_) => {
      const N = E();
      return N != null && g.isEditable() ? (g.update(() => {
        const w = o.$getNearestNodeFromDOMNode(N);
        r.$isListItemNode(w) && (_.preventDefault(), w.toggleChecked());
      }), !0) : !1;
    }, o.COMMAND_PRIORITY_LOW), g.registerCommand(o.KEY_ARROW_LEFT_COMMAND, (_) => g.getEditorState().read(() => {
      const N = o.$getSelection();
      if (o.$isRangeSelection(N) && N.isCollapsed()) {
        const {
          anchor: w
        } = N, T = w.type === "element";
        if (T || w.offset === 0) {
          const D = w.getNode(), C = t.$findMatchingParent(D, (x) => o.$isElementNode(x) && !x.isInline());
          if (r.$isListItemNode(C)) {
            const x = C.getParent();
            if (r.$isListNode(x) && x.getListType() === "check" && (T || C.getFirstDescendant() === D)) {
              const I = g.getElementByKey(C.__key);
              if (I != null && document.activeElement !== I)
                return I.focus(), _.preventDefault(), !0;
            }
          }
        }
      }
      return !1;
    }), o.COMMAND_PRIORITY_LOW), g.registerRootListener((_, N) => {
      _ !== null && (_.addEventListener("click", f), _.addEventListener("pointerdown", O)), N !== null && (N.removeEventListener("click", f), N.removeEventListener("pointerdown", O));
    }))), null;
  }
  function m(g, _) {
    const N = g.target;
    if (N === null || !t.isHTMLElement(N))
      return;
    const w = N.firstChild;
    if (w != null && t.isHTMLElement(w) && (w.tagName === "UL" || w.tagName === "OL"))
      return;
    const T = N.parentNode;
    if (!T || T.__lexicalListType !== "check")
      return;
    const D = g.pageX, C = N.getBoundingClientRect();
    (N.dir === "rtl" ? D < C.right && D > C.right - 20 : D > C.left && D < C.left + 20) && _();
  }
  function f(g) {
    m(g, () => {
      const _ = g.target, N = S(_);
      N != null && N.isEditable() && N.update(() => {
        if (g.target) {
          const w = o.$getNearestNodeFromDOMNode(_);
          r.$isListItemNode(w) && (_.focus(), w.toggleChecked());
        }
      });
    });
  }
  function O(g) {
    m(g, () => {
      g.preventDefault();
    });
  }
  function S(g) {
    let _ = g;
    for (; _; ) {
      if (_.__lexicalEditor)
        return _.__lexicalEditor;
      _ = _.parentNode;
    }
    return null;
  }
  function E() {
    const g = document.activeElement;
    return g != null && g.tagName === "LI" && g.parentNode != null && // @ts-ignore internal field
    g.parentNode.__lexicalListType === "check" ? g : null;
  }
  function R(g, _) {
    let N = _ ? g.getPreviousSibling() : g.getNextSibling(), w = g;
    for (; N == null && r.$isListItemNode(w); )
      w = w.getParentOrThrow().getParent(), w != null && (N = _ ? w.getPreviousSibling() : w.getNextSibling());
    for (; r.$isListItemNode(N); ) {
      const T = _ ? N.getLastChild() : N.getFirstChild();
      if (!r.$isListNode(T))
        return N;
      N = _ ? T.getLastChild() : T.getFirstChild();
    }
    return null;
  }
  function y(g, _, N) {
    const w = E();
    return w != null && _.update(() => {
      const T = o.$getNearestNodeFromDOMNode(w);
      if (!r.$isListItemNode(T))
        return;
      const D = R(T, N);
      if (D != null) {
        D.selectStart();
        const C = _.getElementByKey(D.__key);
        C != null && (g.preventDefault(), setTimeout(() => {
          C.focus();
        }, 0));
      }
    }), !1;
  }
  return $c.CheckListPlugin = p, $c;
}
var kc = {}, lg;
function ZN() {
  if (lg)
    return kc;
  lg = 1;
  var r = Vn, n = zt(), t = kt(), o = St(), u = $t;
  function p(y, g) {
    let _ = y.target;
    if (_ !== null && t.isHTMLElement(_)) {
      var N = _.firstChild;
      (N == null || !t.isHTMLElement(N) || N.tagName !== "UL" && N.tagName !== "OL") && (N = _.parentNode) && N.__lexicalListType === "check" && (y = y.pageX, N = _.getBoundingClientRect(), (_.dir === "rtl" ? y < N.right && y > N.right - 20 : y > N.left && y < N.left + 20) && g());
    }
  }
  function m(y) {
    p(y, () => {
      let g = y.target, _ = O(g);
      _ != null && _.isEditable() && _.update(() => {
        if (y.target) {
          let N = o.$getNearestNodeFromDOMNode(g);
          r.$isListItemNode(N) && (g.focus(), N.toggleChecked());
        }
      });
    });
  }
  function f(y) {
    p(y, () => {
      y.preventDefault();
    });
  }
  function O(y) {
    for (; y; ) {
      if (y.__lexicalEditor)
        return y.__lexicalEditor;
      y = y.parentNode;
    }
    return null;
  }
  function S() {
    let y = document.activeElement;
    return y != null && y.tagName === "LI" && y.parentNode != null && y.parentNode.__lexicalListType === "check" ? y : null;
  }
  function E(y, g) {
    let _ = g ? y.getPreviousSibling() : y.getNextSibling();
    for (; _ == null && r.$isListItemNode(y); )
      y = y.getParentOrThrow().getParent(), y != null && (_ = g ? y.getPreviousSibling() : y.getNextSibling());
    for (; r.$isListItemNode(_); ) {
      if (y = g ? _.getLastChild() : _.getFirstChild(), !r.$isListNode(y))
        return _;
      _ = g ? y.getLastChild() : y.getFirstChild();
    }
    return null;
  }
  function R(y, g, _) {
    let N = S();
    return N != null && g.update(() => {
      var w = o.$getNearestNodeFromDOMNode(N);
      if (r.$isListItemNode(w) && (w = E(w, _), w != null)) {
        w.selectStart();
        let T = g.getElementByKey(w.__key);
        T != null && (y.preventDefault(), setTimeout(() => {
          T.focus();
        }, 0));
      }
    }), !1;
  }
  return kc.CheckListPlugin = function() {
    let [y] = n.useLexicalComposerContext();
    return u.useEffect(() => t.mergeRegister(
      y.registerCommand(r.INSERT_CHECK_LIST_COMMAND, () => (r.insertList(y, "check"), !0), o.COMMAND_PRIORITY_LOW),
      y.registerCommand(o.KEY_ARROW_DOWN_COMMAND, (g) => R(g, y, !1), o.COMMAND_PRIORITY_LOW),
      y.registerCommand(o.KEY_ARROW_UP_COMMAND, (g) => R(g, y, !0), o.COMMAND_PRIORITY_LOW),
      y.registerCommand(o.KEY_ESCAPE_COMMAND, () => {
        if (S() != null) {
          let g = y.getRootElement();
          return g != null && g.focus(), !0;
        }
        return !1;
      }, o.COMMAND_PRIORITY_LOW),
      y.registerCommand(o.KEY_SPACE_COMMAND, (g) => {
        let _ = S();
        return _ != null && y.isEditable() ? (y.update(() => {
          let N = o.$getNearestNodeFromDOMNode(_);
          r.$isListItemNode(N) && (g.preventDefault(), N.toggleChecked());
        }), !0) : !1;
      }, o.COMMAND_PRIORITY_LOW),
      y.registerCommand(o.KEY_ARROW_LEFT_COMMAND, (g) => y.getEditorState().read(() => {
        var _ = o.$getSelection();
        if (o.$isRangeSelection(_) && _.isCollapsed()) {
          var { anchor: N } = _;
          if ((_ = N.type === "element") || N.offset === 0) {
            N = N.getNode();
            let w = t.$findMatchingParent(N, (T) => o.$isElementNode(T) && !T.isInline());
            if (r.$isListItemNode(w)) {
              let T = w.getParent();
              if (r.$isListNode(T) && T.getListType() === "check" && (_ || w.getFirstDescendant() === N) && (_ = y.getElementByKey(w.__key), _ != null && document.activeElement !== _))
                return _.focus(), g.preventDefault(), !0;
            }
          }
        }
        return !1;
      }), o.COMMAND_PRIORITY_LOW),
      y.registerRootListener((g, _) => {
        g !== null && (g.addEventListener("click", m), g.addEventListener("pointerdown", f)), _ !== null && (_.removeEventListener("click", m), _.removeEventListener("pointerdown", f));
      })
    )), null;
  }, kc;
}
const QN = process.env.NODE_ENV === "development" ? XN() : ZN();
var eC = QN;
function tC(r) {
  const n = r.getNodes();
  return n.length === 0 ? /* @__PURE__ */ new Set([
    r.anchor.getNode().getParentOrThrow(),
    r.focus.getNode().getParentOrThrow()
  ]) : new Set(
    n.map((t) => fe.$isElementNode(t) ? t : t.getParentOrThrow())
  );
}
function nC(r) {
  const n = fe.$getSelection();
  if (!fe.$isRangeSelection(n))
    return !1;
  const t = tC(n);
  let o = 0;
  for (const u of t)
    if (Vn.$isListNode(u))
      o = Math.max(Vn.$getListDepth(u) + 1, o);
    else if (Vn.$isListItemNode(u)) {
      const p = u.getParent();
      if (!Vn.$isListNode(p))
        throw new Error(
          "ListMaxIndentLevelPlugin: A ListItemNode must have a ListNode for a parent."
        );
      o = Math.max(Vn.$getListDepth(p) + 1, o);
    }
  return o <= r;
}
function rC({ maxDepth: r }) {
  const [n] = gn.useLexicalComposerContext();
  return yt(() => n.registerCommand(
    fe.INDENT_CONTENT_COMMAND,
    () => !nC(r ?? 7),
    fe.COMMAND_PRIORITY_CRITICAL
  ), [n, r]), null;
}
const oC = 1, iC = 100;
let Oh = 0, ag = !1;
function sC() {
  window.addEventListener(
    "keydown",
    (r) => {
      r.key === "Tab" && (Oh = r.timeStamp);
    },
    !0
  );
}
function lC() {
  const [r] = gn.useLexicalComposerContext();
  return yt(() => (ag || (sC(), ag = !0), r.registerCommand(
    fe.FOCUS_COMMAND,
    (n) => {
      const t = fe.$getSelection();
      return fe.$isRangeSelection(t) && Oh + iC > n.timeStamp && fe.$setSelection(t.clone()), !1;
    },
    oC
  )), [r]), null;
}
const aC = 10, cC = 5;
function cg(r, n, t, o = aC, u = cC) {
  const p = t.parentElement;
  if (r === null || !p) {
    n.style.opacity = "0", n.style.transform = "translate(-10000px, -10000px)";
    return;
  }
  const m = n.getBoundingClientRect(), f = t.getBoundingClientRect(), O = p.getBoundingClientRect();
  let S = r.top - o, E = r.left - u;
  S < O.top && (S += m.height + r.height + o * 2), E + m.width > O.right && (E = O.right - m.width - u), S -= f.top, E -= f.left, n.style.opacity = "1", n.style.transform = `translate(${E}px, ${S}px)`;
}
function uC({
  editor: r,
  isLink: n,
  setIsLink: t,
  anchorElem: o,
  isLinkEditMode: u,
  setIsLinkEditMode: p
}) {
  const m = Cn(null), f = Cn(null), [O, S] = ut(""), [E, R] = ut("https://"), [y, g] = ut(
    null
  ), _ = Vt(() => {
    var W, $;
    const T = fe.$getSelection();
    if (fe.$isRangeSelection(T)) {
      const B = ws(T), L = Jt.$findMatchingParent(B, dn.$isLinkNode);
      L ? S(L.getURL()) : dn.$isLinkNode(B) ? S(B.getURL()) : S(""), u && R(O);
    }
    const D = m.current, C = window.getSelection(), x = document.activeElement;
    if (D === null)
      return;
    const I = r.getRootElement();
    if (T !== null && C !== null && I !== null && I.contains(C.anchorNode) && r.isEditable()) {
      const B = ($ = (W = C.focusNode) == null ? void 0 : W.parentElement) == null ? void 0 : $.getBoundingClientRect();
      B && (B.y += 40, cg(B, D, o)), g(T);
    } else
      (!x || x.className !== "link-input") && (I !== null && cg(null, D, o), g(null), p(!1), S(""));
    return !0;
  }, [o, r, p, u, O]);
  yt(() => {
    const T = o.parentElement, D = () => {
      r.getEditorState().read(() => {
        _();
      });
    };
    return window.addEventListener("resize", D), T && T.addEventListener("scroll", D), () => {
      window.removeEventListener("resize", D), T && T.removeEventListener("scroll", D);
    };
  }, [o.parentElement, r, _]), yt(() => Jt.mergeRegister(
    r.registerUpdateListener(({ editorState: T }) => {
      T.read(() => {
        _();
      });
    }),
    r.registerCommand(
      fe.SELECTION_CHANGE_COMMAND,
      () => (_(), !0),
      fe.COMMAND_PRIORITY_LOW
    ),
    r.registerCommand(
      fe.KEY_ESCAPE_COMMAND,
      () => n ? (t(!1), !0) : !1,
      fe.COMMAND_PRIORITY_HIGH
    )
  ), [r, _, t, n]), yt(() => {
    r.getEditorState().read(() => {
      _();
    });
  }, [r, _]), yt(() => {
    u && f.current && f.current.focus();
  }, [u, n]);
  const N = (T) => {
    T.key === "Enter" ? (T.preventDefault(), w()) : T.key === "Escape" && (T.preventDefault(), p(!1));
  }, w = () => {
    y !== null && (O !== "" && (r.dispatchCommand(dn.TOGGLE_LINK_COMMAND, wa(E)), r.update(() => {
      const T = fe.$getSelection();
      if (fe.$isRangeSelection(T)) {
        const D = ws(T).getParent();
        if (dn.$isAutoLinkNode(D)) {
          const C = dn.$createLinkNode(D.getURL(), {
            rel: D.__rel,
            target: D.__target,
            title: D.__title
          });
          D.replace(C, !0);
        }
      }
    })), R("https://"), p(!1));
  };
  return /* @__PURE__ */ U.jsx("div", { ref: m, className: "link-editor", children: n ? u ? /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    /* @__PURE__ */ U.jsx(
      "input",
      {
        ref: f,
        className: "link-input",
        value: E,
        onChange: (T) => {
          R(T.target.value);
        },
        onKeyDown: (T) => {
          N(T);
        }
      }
    ),
    /* @__PURE__ */ U.jsxs("div", { children: [
      /* @__PURE__ */ U.jsx(
        "div",
        {
          className: "link-cancel",
          role: "button",
          tabIndex: 0,
          onMouseDown: (T) => T.preventDefault(),
          onClick: () => {
            p(!1);
          }
        }
      ),
      /* @__PURE__ */ U.jsx(
        "div",
        {
          className: "link-confirm",
          role: "button",
          tabIndex: 0,
          onMouseDown: (T) => T.preventDefault(),
          onClick: w
        }
      )
    ] })
  ] }) : /* @__PURE__ */ U.jsxs("div", { className: "link-view", children: [
    /* @__PURE__ */ U.jsx(
      "a",
      {
        href: wa(O),
        target: "_blank",
        rel: "noopener noreferrer",
        children: O
      }
    ),
    /* @__PURE__ */ U.jsx(
      "div",
      {
        className: "link-edit",
        role: "button",
        tabIndex: 0,
        onMouseDown: (T) => T.preventDefault(),
        onClick: () => {
          R(O), p(!0);
        }
      }
    ),
    /* @__PURE__ */ U.jsx(
      "div",
      {
        className: "link-trash",
        role: "button",
        tabIndex: 0,
        onMouseDown: (T) => T.preventDefault(),
        onClick: () => {
          r.dispatchCommand(dn.TOGGLE_LINK_COMMAND, null);
        }
      }
    )
  ] }) : null });
}
function dC(r, n, t, o) {
  const [u, p] = ut(r), [m, f] = ut(!1);
  return yt(() => {
    function O() {
      const S = fe.$getSelection();
      if (fe.$isRangeSelection(S)) {
        const E = ws(S), R = Jt.$findMatchingParent(E, dn.$isLinkNode), y = Jt.$findMatchingParent(
          E,
          dn.$isAutoLinkNode
        );
        if (!(R || y)) {
          f(!1);
          return;
        }
        const g = S.getNodes().find((_) => {
          const N = Jt.$findMatchingParent(_, dn.$isLinkNode), w = Jt.$findMatchingParent(_, dn.$isAutoLinkNode);
          if (!(N != null && N.is(R)) && !(w != null && w.is(y)) && !N && !w && !fe.$isLineBreakNode(_))
            return _;
        });
        f(!g);
      }
    }
    return Jt.mergeRegister(
      r.registerUpdateListener(({ editorState: S }) => {
        S.read(() => {
          O();
        });
      }),
      r.registerCommand(
        fe.SELECTION_CHANGE_COMMAND,
        (S, E) => (O(), p(E), !1),
        fe.COMMAND_PRIORITY_CRITICAL
      ),
      r.registerCommand(
        fe.CLICK_COMMAND,
        (S) => {
          const E = fe.$getSelection();
          if (fe.$isRangeSelection(E)) {
            const R = ws(E), y = Jt.$findMatchingParent(R, dn.$isLinkNode);
            if (dn.$isLinkNode(y) && (S.metaKey || S.ctrlKey))
              return window.open(y.getURL(), "_blank"), !0;
          }
          return !1;
        },
        fe.COMMAND_PRIORITY_LOW
      )
    );
  }, [r]), Bo(
    /* @__PURE__ */ U.jsx(
      uC,
      {
        editor: u,
        isLink: m,
        anchorElem: n,
        setIsLink: f,
        isLinkEditMode: t,
        setIsLinkEditMode: o
      }
    ),
    n
  );
}
function fC({
  anchorElem: r = document.body,
  isLinkEditMode: n,
  setIsLinkEditMode: t
}) {
  const [o] = gn.useLexicalComposerContext();
  return dC(
    o,
    r,
    n,
    t
  );
}
var Ta = {}, ug;
function gC() {
  if (ug)
    return Ta;
  ug = 1;
  var r = dn, n = zt(), t = kt(), o = St(), u = $t;
  function p($, B = (L) => L) {
    return (L) => {
      const P = $.exec(L);
      return P === null ? null : {
        index: P.index,
        length: P[0].length,
        text: P[0],
        url: B(P[0])
      };
    };
  }
  function m($, B) {
    for (let L = 0; L < B.length; L++) {
      const P = B[L]($);
      if (P)
        return P;
    }
    return null;
  }
  const f = /[.,;\s]/;
  function O($) {
    return f.test($);
  }
  function S($) {
    return O($[$.length - 1]);
  }
  function E($) {
    return O($[0]);
  }
  function R($) {
    let B = $.getPreviousSibling();
    return o.$isElementNode(B) && (B = B.getLastDescendant()), B === null || o.$isLineBreakNode(B) || o.$isTextNode(B) && S(B.getTextContent());
  }
  function y($) {
    let B = $.getNextSibling();
    return o.$isElementNode(B) && (B = B.getFirstDescendant()), B === null || o.$isLineBreakNode(B) || o.$isTextNode(B) && E(B.getTextContent());
  }
  function g($, B, L, P) {
    return ($ > 0 ? O(L[$ - 1]) : R(P[0])) ? B < L.length ? O(L[B]) : y(P[P.length - 1]) : !1;
  }
  function _($, B, L) {
    const P = [], F = [], Z = [];
    let oe = 0, ne = 0;
    const te = [...$];
    for (; te.length > 0; ) {
      const K = te[0], z = K.getTextContent().length, ie = ne;
      ne + z <= B ? (P.push(K), oe += z) : ie >= L ? Z.push(K) : F.push(K), ne += z, te.shift();
    }
    return [oe, P, F, Z];
  }
  function N($, B, L, P) {
    const F = r.$createAutoLinkNode(P.url, P.attributes);
    if ($.length === 1) {
      let Z = $[0], oe;
      B === 0 ? [oe, Z] = Z.splitText(L) : [, oe, Z] = Z.splitText(B, L);
      const ne = o.$createTextNode(P.text);
      return ne.setFormat(oe.getFormat()), ne.setDetail(oe.getDetail()), F.append(ne), oe.replace(F), Z;
    } else if ($.length > 1) {
      const Z = $[0];
      let oe = Z.getTextContent().length, ne;
      B === 0 ? ne = Z : [, ne] = Z.splitText(B);
      const te = [];
      let K;
      for (let q = 1; q < $.length; q++) {
        const Y = $[q], j = Y.getTextContent().length, Q = oe, ae = oe + j;
        if (Q < L)
          if (ae <= L)
            te.push(Y);
          else {
            const [de, Ne] = Y.splitText(L - Q);
            te.push(de), K = Ne;
          }
        oe += j;
      }
      const A = o.$getSelection(), z = A ? A.getNodes().find(o.$isTextNode) : void 0, ie = o.$createTextNode(ne.getTextContent());
      return ie.setFormat(ne.getFormat()), ie.setDetail(ne.getDetail()), F.append(ie, ...te), z && z === ne && (o.$isRangeSelection(A) ? ie.select(A.anchor.offset, A.focus.offset) : o.$isNodeSelection(A) && ie.select(0, ie.getTextContent().length)), ne.replace(F), K;
    }
  }
  function w($, B, L) {
    let P = [...$];
    const F = P.map((te) => te.getTextContent()).join("");
    let Z = F, oe, ne = 0;
    for (; (oe = m(Z, B)) && oe !== null; ) {
      const te = oe.index, K = oe.length, A = te + K;
      if (g(ne + te, ne + A, F, P)) {
        const [ie, , q, Y] = _(P, ne + te, ne + A), se = ne + te - ie, j = ne + A - ie, Q = N(q, se, j, oe);
        P = Q ? [Q, ...Y] : Y, L(oe.url, null), ne = 0;
      } else
        ne += A;
      Z = Z.substring(A);
    }
  }
  function T($, B, L) {
    const P = $.getChildren(), F = P.length;
    for (let te = 0; te < F; te++) {
      const K = P[te];
      if (!o.$isTextNode(K) || !K.isSimpleText()) {
        C($), L(null, $.getURL());
        return;
      }
    }
    const Z = $.getTextContent(), oe = m(Z, B);
    if (oe === null || oe.text !== Z) {
      C($), L(null, $.getURL());
      return;
    }
    if (!R($) || !y($)) {
      C($), L(null, $.getURL());
      return;
    }
    const ne = $.getURL();
    if (ne !== oe.url && ($.setURL(oe.url), L(oe.url, ne)), oe.attributes) {
      const te = $.getRel();
      te !== oe.attributes.rel && ($.setRel(oe.attributes.rel || null), L(oe.attributes.rel || null, te));
      const K = $.getTarget();
      K !== oe.attributes.target && ($.setTarget(oe.attributes.target || null), L(oe.attributes.target || null, K));
    }
  }
  function D($, B, L) {
    const P = $.getPreviousSibling(), F = $.getNextSibling(), Z = $.getTextContent();
    r.$isAutoLinkNode(P) && !E(Z) && (P.append($), T(P, B, L), L(null, P.getURL())), r.$isAutoLinkNode(F) && !S(Z) && (C(F), T(F, B, L), L(null, F.getURL()));
  }
  function C($) {
    const B = $.getChildren(), L = B.length;
    for (let P = L - 1; P >= 0; P--)
      $.insertAfter(B[P]);
    return $.remove(), B.map((P) => P.getLatest());
  }
  function x($) {
    const B = [$];
    let L = $.getNextSibling();
    for (; L !== null && o.$isTextNode(L) && L.isSimpleText() && (B.push(L), !/[\s]/.test(L.getTextContent())); )
      L = L.getNextSibling();
    return B;
  }
  function I($, B, L) {
    u.useEffect(() => {
      if (!$.hasNodes([r.AutoLinkNode]))
        throw Error("LexicalAutoLinkPlugin: AutoLinkNode not registered on editor");
      const P = (F, Z) => {
        L && L(F, Z);
      };
      return t.mergeRegister($.registerNodeTransform(o.TextNode, (F) => {
        const Z = F.getParentOrThrow(), oe = F.getPreviousSibling();
        if (r.$isAutoLinkNode(Z))
          T(Z, B, P);
        else if (!r.$isLinkNode(Z)) {
          if (F.isSimpleText() && (E(F.getTextContent()) || !r.$isAutoLinkNode(oe))) {
            const ne = x(F);
            w(ne, B, P);
          }
          D(F, B, P);
        }
      }));
    }, [$, B, L]);
  }
  function W({
    matchers: $,
    onChange: B
  }) {
    const [L] = n.useLexicalComposerContext();
    return I(L, $, B), null;
  }
  return Ta.AutoLinkPlugin = W, Ta.createLinkMatcherWithRegExp = p, Ta;
}
var ya = {}, dg;
function hC() {
  if (dg)
    return ya;
  dg = 1;
  var r = dn, n = zt(), t = kt(), o = St(), u = $t;
  function p(T) {
    let D = new URLSearchParams();
    D.append("code", T);
    for (let C = 1; C < arguments.length; C++)
      D.append("v", arguments[C]);
    throw Error(`Minified Lexical error #${T}; visit https://lexical.dev/docs/error?${D} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  function m(T, D) {
    for (let C = 0; C < D.length; C++) {
      let x = D[C](T);
      if (x)
        return x;
    }
    return null;
  }
  let f = /[.,;\s]/;
  function O(T) {
    T = T.getPreviousSibling(), o.$isElementNode(T) && (T = T.getLastDescendant());
    var D;
    return !(D = T === null || o.$isLineBreakNode(T)) && (D = o.$isTextNode(T)) && (T = T.getTextContent(), D = f.test(T[T.length - 1])), D;
  }
  function S(T) {
    return T = T.getNextSibling(), o.$isElementNode(T) && (T = T.getFirstDescendant()), T === null || o.$isLineBreakNode(T) || o.$isTextNode(T) && f.test(T.getTextContent()[0]);
  }
  function E(T, D, C, x) {
    return (0 < T ? f.test(C[T - 1]) : O(x[0])) ? D < C.length ? f.test(C[D]) : S(x[x.length - 1]) : !1;
  }
  function R(T, D, C) {
    let x = [], I = [], W = [], $ = 0, B = 0;
    for (T = [...T]; 0 < T.length; ) {
      let L = T[0], P = L.getTextContent().length, F = B;
      B + P <= D ? (x.push(L), $ += P) : F >= C ? W.push(L) : I.push(L), B += P, T.shift();
    }
    return [$, x, I, W];
  }
  function y(T, D, C, x) {
    let I = r.$createAutoLinkNode(x.url, x.attributes);
    if (T.length === 1) {
      var W = T[0];
      D === 0 ? [B, W] = W.splitText(C) : [, B, W] = W.splitText(D, C);
      var $ = o.$createTextNode(x.text);
      return $.setFormat(B.getFormat()), $.setDetail(B.getDetail()), I.append($), B.replace(I), W;
    }
    if (1 < T.length) {
      x = T[0];
      var B = x.getTextContent().length;
      for (D === 0 ? W = x : [, W] = x.splitText(D), D = [], x = 1; x < T.length; x++) {
        let L = T[x], P = L.getTextContent().length, F = B, Z = B + P;
        if (F < C)
          if (Z <= C)
            D.push(L);
          else {
            let [oe, ne] = L.splitText(C - F);
            D.push(oe), $ = ne;
          }
        B += P;
      }
      return T = (C = o.$getSelection()) ? C.getNodes().find(o.$isTextNode) : void 0, B = o.$createTextNode(W.getTextContent()), B.setFormat(W.getFormat()), B.setDetail(W.getDetail()), I.append(B, ...D), T && T === W && (o.$isRangeSelection(C) ? B.select(C.anchor.offset, C.focus.offset) : o.$isNodeSelection(C) && B.select(0, B.getTextContent().length)), W.replace(I), $;
    }
  }
  function g(T, D, C) {
    var x = [...T];
    let I = T = x.map((B) => B.getTextContent()).join(""), W, $ = 0;
    for (; (W = m(I, D)) && W !== null; ) {
      let B = W.index, L = B + W.length;
      if (E($ + B, $ + L, T, x)) {
        let [P, , F, Z] = R(x, $ + B, $ + L);
        x = (x = y(F, $ + B - P, $ + L - P, W)) ? [x, ...Z] : Z, C(W.url, null), $ = 0;
      } else
        $ += L;
      I = I.substring(L);
    }
  }
  function _(T, D, C) {
    var x = T.getChildren();
    let I = x.length;
    for (let W = 0; W < I; W++) {
      let $ = x[W];
      if (!o.$isTextNode($) || !$.isSimpleText()) {
        N(T), C(null, T.getURL());
        return;
      }
    }
    x = T.getTextContent(), D = m(x, D), D === null || D.text !== x ? (N(T), C(null, T.getURL())) : O(T) && S(T) ? (x = T.getURL(), x !== D.url && (T.setURL(D.url), C(D.url, x)), D.attributes && (x = T.getRel(), x !== D.attributes.rel && (T.setRel(D.attributes.rel || null), C(D.attributes.rel || null, x)), x = T.getTarget(), x !== D.attributes.target && (T.setTarget(D.attributes.target || null), C(D.attributes.target || null, x)))) : (N(T), C(null, T.getURL()));
  }
  function N(T) {
    let D = T.getChildren();
    var C = D.length;
    for (--C; 0 <= C; C--)
      T.insertAfter(D[C]);
    return T.remove(), D.map((x) => x.getLatest());
  }
  function w(T, D, C) {
    u.useEffect(() => {
      T.hasNodes([r.AutoLinkNode]) || p(77);
      let x = (I, W) => {
        C && C(I, W);
      };
      return t.mergeRegister(T.registerNodeTransform(o.TextNode, (I) => {
        var W = I.getParentOrThrow(), $ = I.getPreviousSibling();
        if (r.$isAutoLinkNode(W))
          _(W, D, x);
        else if (!r.$isLinkNode(W)) {
          if (I.isSimpleText() && (f.test(I.getTextContent()[0]) || !r.$isAutoLinkNode($))) {
            for (W = [I], $ = I.getNextSibling(); $ !== null && o.$isTextNode($) && $.isSimpleText() && (W.push($), !/[\s]/.test($.getTextContent())); )
              $ = $.getNextSibling();
            g(
              W,
              D,
              x
            );
          }
          let B = I.getPreviousSibling();
          W = I.getNextSibling(), $ = I.getTextContent(), r.$isAutoLinkNode(B) && !f.test($[0]) && (B.append(I), _(B, D, x), I = B.getURL(), C && C(null, I)), r.$isAutoLinkNode(W) && !f.test($[$.length - 1]) && (N(W), _(W, D, x), I = W.getURL(), C && C(null, I));
        }
      }));
    }, [T, D, C]);
  }
  return ya.AutoLinkPlugin = function({ matchers: T, onChange: D }) {
    let [C] = n.useLexicalComposerContext();
    return w(C, T, D), null;
  }, ya.createLinkMatcherWithRegExp = function(T, D = (C) => C) {
    return (C) => (C = T.exec(C), C === null ? null : { index: C.index, length: C[0].length, text: C[0], url: D(C[0]) });
  }, ya;
}
const pC = process.env.NODE_ENV === "development" ? gC() : hC();
var eu = pC;
const mC = /((https?:\/\/(www\.)?)|(www\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/, _C = /(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/, NC = [
  eu.createLinkMatcherWithRegExp(mC, (r) => r.startsWith("http") ? r : `https://${r}`),
  eu.createLinkMatcherWithRegExp(_C, (r) => `mailto:${r}`)
];
function CC() {
  return /* @__PURE__ */ U.jsx(eu.AutoLinkPlugin, { matchers: NC });
}
var Pc = {}, fg;
function xC() {
  if (fg)
    return Pc;
  fg = 1;
  var r = dn, n = zt(), t = kt(), o = St(), u = $t;
  function p({
    validateUrl: m
  }) {
    const [f] = n.useLexicalComposerContext();
    return u.useEffect(() => {
      if (!f.hasNodes([r.LinkNode]))
        throw new Error("LinkPlugin: LinkNode not registered on editor");
      return t.mergeRegister(f.registerCommand(r.TOGGLE_LINK_COMMAND, (O) => {
        if (O === null)
          return r.toggleLink(O), !0;
        if (typeof O == "string")
          return m === void 0 || m(O) ? (r.toggleLink(O), !0) : !1;
        {
          const {
            url: S,
            target: E,
            rel: R,
            title: y
          } = O;
          return r.toggleLink(S, {
            rel: R,
            target: E,
            title: y
          }), !0;
        }
      }, o.COMMAND_PRIORITY_LOW), m !== void 0 ? f.registerCommand(o.PASTE_COMMAND, (O) => {
        const S = o.$getSelection();
        if (!o.$isRangeSelection(S) || S.isCollapsed() || !(O instanceof ClipboardEvent) || O.clipboardData == null)
          return !1;
        const E = O.clipboardData.getData("text");
        return m(E) ? S.getNodes().some((R) => o.$isElementNode(R)) ? !1 : (f.dispatchCommand(r.TOGGLE_LINK_COMMAND, E), O.preventDefault(), !0) : !1;
      }, o.COMMAND_PRIORITY_LOW) : () => {
      });
    }, [f, m]), null;
  }
  return Pc.LinkPlugin = p, Pc;
}
var Fc = {}, gg;
function EC() {
  if (gg)
    return Fc;
  gg = 1;
  var r = dn, n = zt(), t = kt(), o = St(), u = $t;
  return Fc.LinkPlugin = function({ validateUrl: p }) {
    let [m] = n.useLexicalComposerContext();
    return u.useEffect(() => {
      if (!m.hasNodes([r.LinkNode]))
        throw Error("LinkPlugin: LinkNode not registered on editor");
      return t.mergeRegister(m.registerCommand(r.TOGGLE_LINK_COMMAND, (f) => {
        if (f === null)
          return r.toggleLink(f), !0;
        if (typeof f == "string")
          return p === void 0 || p(f) ? (r.toggleLink(f), !0) : !1;
        let { url: O, target: S, rel: E, title: R } = f;
        return r.toggleLink(O, { rel: E, target: S, title: R }), !0;
      }, o.COMMAND_PRIORITY_LOW), p !== void 0 ? m.registerCommand(
        o.PASTE_COMMAND,
        (f) => {
          let O = o.$getSelection();
          if (!o.$isRangeSelection(O) || O.isCollapsed() || !(f instanceof ClipboardEvent) || f.clipboardData == null)
            return !1;
          let S = f.clipboardData.getData("text");
          return p(S) ? O.getNodes().some((E) => o.$isElementNode(E)) ? !1 : (m.dispatchCommand(r.TOGGLE_LINK_COMMAND, S), f.preventDefault(), !0) : !1;
        },
        o.COMMAND_PRIORITY_LOW
      ) : () => {
      });
    }, [m, p]), null;
  }, Fc;
}
const TC = process.env.NODE_ENV === "development" ? xC() : EC();
var yC = TC;
function SC() {
  return /* @__PURE__ */ U.jsx(yC.LinkPlugin, { validateUrl: B_ });
}
var Bc = {}, hg;
function OC() {
  if (hg)
    return Bc;
  hg = 1;
  var r = zt(), n = Ra(), t = kt(), o = $t;
  function u(p, m, f) {
    const [O] = r.useLexicalComposerContext();
    o.useEffect(() => t.mergeRegister(...n.registerLexicalTextEntity(O, p, m, f)), [f, O, p, m]);
  }
  return Bc.useLexicalTextEntity = u, Bc;
}
var Kc = {}, pg;
function vC() {
  if (pg)
    return Kc;
  pg = 1;
  var r = zt(), n = Ra(), t = kt(), o = $t;
  return Kc.useLexicalTextEntity = function(u, p, m) {
    let [f] = r.useLexicalComposerContext();
    o.useEffect(() => t.mergeRegister(...n.registerLexicalTextEntity(f, u, p, m)), [m, f, u, p]);
  }, Kc;
}
const wC = process.env.NODE_ENV === "development" ? OC() : vC();
var MC = wC;
const RC = /(^|$|[^A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԧԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠࢢ-ࢬऄ-हऽॐक़-ॡॱ-ॷॹ-ॿঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-ళవ-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤜᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎↃↄⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々〆〱-〵〻〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚗꚠ-ꛥꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞓꞠ-Ɦꟸ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꪀ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ])(congrats|congratulations|gratuluju|gratuluji|gratulujeme|blahopřeju|blahopřeji|blahopřejeme|Til lykke|Tillykke|Glückwunsch|Gratuliere|felicitaciones|enhorabuena|paljon onnea|onnittelut|Félicitations|gratula|gratulálok|gratulálunk|congratulazioni|complimenti|おめでとう|おめでとうございます|축하해|축하해요|gratulerer|Gefeliciteerd|gratulacje|Parabéns|parabéns|felicitações|felicitări|мои поздравления|поздравляем|поздравляю|gratulujem|blahoželám|ยินดีด้วย|ขอแสดงความยินดี|tebrikler|tebrik ederim|恭喜|祝贺你|恭喜你|恭喜|恭喜|baie geluk|veels geluk|অভিনন্দন|Čestitam|Čestitke|Čestitamo|Συγχαρητήρια|Μπράβο|અભિનંદન|badhai|बधाई|अभिनंदन|Честитам|Свака част|hongera|வாழ்த்துகள்|வாழ்த்துக்கள்|అభినందనలు|അഭിനന്ദനങ്ങൾ|Chúc mừng|מזל טוב|mazel tov|mazal tov)(^|$|[^A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԧԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠࢢ-ࢬऄ-हऽॐक़-ॡॱ-ॷॹ-ॿঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-ళవ-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤜᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎↃↄⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々〆〱-〵〻〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚗꚠ-ꛥꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞓꞠ-Ɦꟸ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꪀ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ])/i;
function bC() {
  const [r] = gn.useLexicalComposerContext();
  yt(() => {
    if (!r.hasNodes([Os]))
      throw new Error("KeywordsPlugin: KeywordNode not registered on editor");
  }, [r]);
  const n = Vt((o) => Xg(o.getTextContent()), []), t = Vt((o) => {
    const u = RC.exec(o);
    if (u === null)
      return null;
    const p = u[2].length, m = u.index + u[1].length;
    return {
      end: m + p,
      start: m
    };
  }, []);
  return MC.useLexicalTextEntity(
    t,
    Os,
    n
  ), null;
}
const mg = /* @__PURE__ */ new Map([
  [":)", ["emoji happysmile", "🙂"]],
  [":D", ["emoji veryhappysmile", "😀"]],
  [":(", ["emoji unhappysmile", "🙁"]],
  ["<3", ["emoji heart", "❤"]],
  ["🙂", ["emoji happysmile", "🙂"]],
  ["😀", ["emoji veryhappysmile", "😀"]],
  ["🙁", ["emoji unhappysmile", "🙁"]],
  ["❤", ["emoji heart", "❤"]]
]);
function AC(r) {
  const n = r.getTextContent();
  for (let t = 0; t < n.length; t++) {
    const o = mg.get(n[t]) || mg.get(n.slice(t, t + 2));
    if (o !== void 0) {
      const [u, p] = o;
      let m;
      t === 0 ? [m] = r.splitText(t + 2) : [, m] = r.splitText(t, t + 2);
      const f = Jg(u, p);
      return m.replace(f), f;
    }
  }
  return null;
}
function DC(r) {
  let n = r;
  for (; n !== null; ) {
    if (!n.isSimpleText())
      return;
    n = AC(n);
  }
}
function LC(r) {
  yt(() => {
    if (!r.hasNodes([xl]))
      throw new Error("EmojisPlugin: EmojiNode not registered on editor");
    return r.registerNodeTransform(fe.TextNode, DC);
  }, [r]);
}
function IC() {
  const [r] = gn.useLexicalComposerContext();
  return LC(r), null;
}
var $o = {}, _g;
function $C() {
  if (_g)
    return $o;
  _g = 1;
  var r = zt(), n = St(), t = $t, o = kt(), m = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  class f {
    constructor(Z) {
      this.key = Z, this.ref = {
        current: null
      }, this.setRefElement = this.setRefElement.bind(this);
    }
    setRefElement(Z) {
      this.ref = {
        current: Z
      };
    }
  }
  const O = (F) => {
    const Z = document.getElementById("typeahead-menu");
    if (!Z)
      return;
    const oe = Z.getBoundingClientRect();
    oe.top + oe.height > window.innerHeight && Z.scrollIntoView({
      block: "center"
    }), oe.top < 0 && Z.scrollIntoView({
      block: "center"
    }), F.scrollIntoView({
      block: "nearest"
    });
  };
  function S(F, Z, oe) {
    let ne = oe;
    for (let te = ne; te <= Z.length; te++)
      F.substr(-te) === Z.substr(0, te) && (ne = te);
    return ne;
  }
  function E(F) {
    const Z = n.$getSelection();
    if (!n.$isRangeSelection(Z) || !Z.isCollapsed())
      return null;
    const oe = Z.anchor;
    if (oe.type !== "text")
      return null;
    const ne = oe.getNode();
    if (!ne.isSimpleText())
      return null;
    const te = oe.offset, K = ne.getTextContent().slice(0, te), A = F.replaceableString.length, z = S(K, F.matchingString, A), ie = te - z;
    if (ie < 0)
      return null;
    let q;
    return ie === 0 ? [q] = ne.splitText(te) : [, q] = ne.splitText(ie, te), q;
  }
  function R(F, Z) {
    let oe = getComputedStyle(F);
    const ne = oe.position === "absolute", te = Z ? /(auto|scroll|hidden)/ : /(auto|scroll)/;
    if (oe.position === "fixed")
      return document.body;
    for (let K = F; K = K.parentElement; )
      if (oe = getComputedStyle(K), !(ne && oe.position === "static") && te.test(oe.overflow + oe.overflowY + oe.overflowX))
        return K;
    return document.body;
  }
  function y(F, Z) {
    const oe = F.getBoundingClientRect(), ne = Z.getBoundingClientRect();
    return oe.top > ne.top && oe.top < ne.bottom;
  }
  function g(F, Z, oe, ne) {
    const [te] = r.useLexicalComposerContext();
    t.useEffect(() => {
      if (Z != null && F != null) {
        const K = te.getRootElement(), A = K != null ? R(K, !1) : document.body;
        let z = !1, ie = y(Z, A);
        const q = function() {
          z || (window.requestAnimationFrame(function() {
            oe(), z = !1;
          }), z = !0);
          const se = y(Z, A);
          se !== ie && (ie = se, ne != null && ne(se));
        }, Y = new ResizeObserver(oe);
        return window.addEventListener("resize", oe), document.addEventListener("scroll", q, {
          capture: !0,
          passive: !0
        }), Y.observe(Z), () => {
          Y.unobserve(Z), window.removeEventListener("resize", oe), document.removeEventListener("scroll", q, !0);
        };
      }
    }, [Z, te, ne, oe, F]);
  }
  const _ = n.createCommand("SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND");
  function N({
    close: F,
    editor: Z,
    anchorElementRef: oe,
    resolution: ne,
    options: te,
    menuRenderFn: K,
    onSelectOption: A,
    shouldSplitNodeWithQuery: z = !1,
    commandPriority: ie = n.COMMAND_PRIORITY_LOW
  }) {
    const [q, Y] = t.useState(null), se = ne.match && ne.match.matchingString;
    t.useEffect(() => {
      Y(0);
    }, [se]);
    const j = t.useCallback((de) => {
      Z.update(() => {
        const Ne = ne.match != null && z ? E(ne.match) : null;
        A(de, Ne, F, ne.match ? ne.match.matchingString : "");
      });
    }, [Z, z, ne.match, A, F]), Q = t.useCallback((de) => {
      const Ne = Z.getRootElement();
      Ne !== null && (Ne.setAttribute("aria-activedescendant", "typeahead-item-" + de), Y(de));
    }, [Z]);
    t.useEffect(() => () => {
      const de = Z.getRootElement();
      de !== null && de.removeAttribute("aria-activedescendant");
    }, [Z]), m(() => {
      te === null ? Y(null) : q === null && Q(0);
    }, [te, q, Q]), t.useEffect(() => o.mergeRegister(Z.registerCommand(_, ({
      option: de
    }) => de.ref && de.ref.current != null ? (O(de.ref.current), !0) : !1, ie)), [Z, Q, ie]), t.useEffect(() => o.mergeRegister(Z.registerCommand(n.KEY_ARROW_DOWN_COMMAND, (de) => {
      const Ne = de;
      if (te !== null && te.length && q !== null) {
        const De = q !== te.length - 1 ? q + 1 : 0;
        Q(De);
        const Pe = te[De];
        Pe.ref != null && Pe.ref.current && Z.dispatchCommand(_, {
          index: De,
          option: Pe
        }), Ne.preventDefault(), Ne.stopImmediatePropagation();
      }
      return !0;
    }, ie), Z.registerCommand(n.KEY_ARROW_UP_COMMAND, (de) => {
      const Ne = de;
      if (te !== null && te.length && q !== null) {
        const De = q !== 0 ? q - 1 : te.length - 1;
        Q(De);
        const Pe = te[De];
        Pe.ref != null && Pe.ref.current && O(Pe.ref.current), Ne.preventDefault(), Ne.stopImmediatePropagation();
      }
      return !0;
    }, ie), Z.registerCommand(n.KEY_ESCAPE_COMMAND, (de) => {
      const Ne = de;
      return Ne.preventDefault(), Ne.stopImmediatePropagation(), F(), !0;
    }, ie), Z.registerCommand(n.KEY_TAB_COMMAND, (de) => {
      const Ne = de;
      return te === null || q === null || te[q] == null ? !1 : (Ne.preventDefault(), Ne.stopImmediatePropagation(), j(te[q]), !0);
    }, ie), Z.registerCommand(n.KEY_ENTER_COMMAND, (de) => te === null || q === null || te[q] == null ? !1 : (de !== null && (de.preventDefault(), de.stopImmediatePropagation()), j(te[q]), !0), ie)), [j, F, Z, te, q, Q, ie]);
    const ae = t.useMemo(() => ({
      options: te,
      selectOptionAndCleanUp: j,
      selectedIndex: q,
      setHighlightedIndex: Y
    }), [j, q, te]);
    return K(oe, ae, ne.match ? ne.match.matchingString : "");
  }
  function w(F, Z, oe, ne = document.body) {
    const [te] = r.useLexicalComposerContext(), K = t.useRef(document.createElement("div")), A = t.useCallback(() => {
      K.current.style.top = K.current.style.bottom;
      const ie = te.getRootElement(), q = K.current, Y = q.firstChild;
      if (ie !== null && F !== null) {
        const {
          left: se,
          top: j,
          width: Q,
          height: ae
        } = F.getRect(), de = K.current.offsetHeight;
        if (q.style.top = `${j + window.pageYOffset + de + 3}px`, q.style.left = `${se + window.pageXOffset}px`, q.style.height = `${ae}px`, q.style.width = `${Q}px`, Y !== null) {
          Y.style.top = `${j}`;
          const Ne = Y.getBoundingClientRect(), De = Ne.height, Pe = Ne.width, Le = ie.getBoundingClientRect();
          se + Pe > Le.right && (q.style.left = `${Le.right - Pe + window.pageXOffset}px`), (j + De > window.innerHeight || j + De > Le.bottom) && j - Le.top > De && (q.style.top = `${j - De + window.pageYOffset - ae}px`);
        }
        q.isConnected || (oe != null && (q.className = oe), q.setAttribute("aria-label", "Typeahead menu"), q.setAttribute("id", "typeahead-menu"), q.setAttribute("role", "listbox"), q.style.display = "block", q.style.position = "absolute", ne.append(q)), K.current = q, ie.setAttribute("aria-controls", "typeahead-menu");
      }
    }, [te, F, oe, ne]);
    t.useEffect(() => {
      const ie = te.getRootElement();
      if (F !== null)
        return A(), () => {
          ie !== null && ie.removeAttribute("aria-controls");
          const q = K.current;
          q !== null && q.isConnected && q.remove();
        };
    }, [te, A, F]);
    const z = t.useCallback((ie) => {
      F !== null && (ie || Z(null));
    }, [F, Z]);
    return g(F, K.current, A, z), K;
  }
  const T = `\\.,\\+\\*\\?\\$\\@\\|#{}\\(\\)\\^\\-\\[\\]\\\\/!%'"~=<>_:;`;
  function D(F) {
    const Z = F.anchor;
    if (Z.type !== "text")
      return null;
    const oe = Z.getNode();
    if (!oe.isSimpleText())
      return null;
    const ne = Z.offset;
    return oe.getTextContent().slice(0, ne);
  }
  function C(F, Z, oe) {
    const ne = oe.getSelection();
    if (ne === null || !ne.isCollapsed)
      return !1;
    const te = ne.anchorNode, K = F, A = ne.anchorOffset;
    if (te == null || A == null)
      return !1;
    try {
      Z.setStart(te, K), Z.setEnd(te, A);
    } catch {
      return !1;
    }
    return !0;
  }
  function x(F) {
    let Z = null;
    return F.getEditorState().read(() => {
      const oe = n.$getSelection();
      n.$isRangeSelection(oe) && (Z = D(oe));
    }), Z;
  }
  function I(F, Z) {
    return Z !== 0 ? !1 : F.getEditorState().read(() => {
      const oe = n.$getSelection();
      if (n.$isRangeSelection(oe)) {
        const K = oe.anchor.getNode().getPreviousSibling();
        return n.$isTextNode(K) && K.isTextEntity();
      }
      return !1;
    });
  }
  function W(F) {
    t.startTransition ? t.startTransition(F) : F();
  }
  function $(F, Z) {
    let oe = getComputedStyle(F);
    const ne = oe.position === "absolute", te = Z ? /(auto|scroll|hidden)/ : /(auto|scroll)/;
    if (oe.position === "fixed")
      return document.body;
    for (let K = F; K = K.parentElement; )
      if (oe = getComputedStyle(K), !(ne && oe.position === "static") && te.test(oe.overflow + oe.overflowY + oe.overflowX))
        return K;
    return document.body;
  }
  const B = n.createCommand("SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND");
  function L(F, {
    minLength: Z = 1,
    maxLength: oe = 75
  }) {
    return t.useCallback((ne) => {
      const te = "[^" + F + T + "\\s]", A = new RegExp("(^|\\s|\\()([" + F + "]((?:" + te + "){0," + oe + "}))$").exec(ne);
      if (A !== null) {
        const z = A[1], ie = A[3];
        if (ie.length >= Z)
          return {
            leadOffset: A.index + z.length,
            matchingString: ie,
            replaceableString: A[2]
          };
      }
      return null;
    }, [oe, Z, F]);
  }
  function P({
    options: F,
    onQueryChange: Z,
    onSelectOption: oe,
    onOpen: ne,
    onClose: te,
    menuRenderFn: K,
    triggerFn: A,
    anchorClassName: z,
    commandPriority: ie = n.COMMAND_PRIORITY_LOW,
    parent: q
  }) {
    const [Y] = r.useLexicalComposerContext(), [se, j] = t.useState(null), Q = w(se, j, z, q), ae = t.useCallback(() => {
      j(null), te != null && se !== null && te();
    }, [te, se]), de = t.useCallback((Ne) => {
      j(Ne), ne != null && se === null && ne(Ne);
    }, [ne, se]);
    return t.useEffect(() => {
      const Ne = () => {
        Y.getEditorState().read(() => {
          const Pe = Y._window || window, Le = Pe.document.createRange(), ke = n.$getSelection(), J = x(Y);
          if (!n.$isRangeSelection(ke) || !ke.isCollapsed() || J === null || Le === null) {
            ae();
            return;
          }
          const G = A(J, Y);
          if (Z(G ? G.matchingString : null), G !== null && !I(Y, G.leadOffset) && C(G.leadOffset, Le, Pe) !== null) {
            W(() => de({
              getRect: () => Le.getBoundingClientRect(),
              match: G
            }));
            return;
          }
          ae();
        });
      }, De = Y.registerUpdateListener(Ne);
      return () => {
        De();
      };
    }, [Y, A, Z, se, ae, de]), se === null || Y === null ? null : /* @__PURE__ */ t.createElement(N, {
      close: ae,
      resolution: se,
      editor: Y,
      anchorElementRef: Q,
      options: F,
      menuRenderFn: K,
      shouldSplitNodeWithQuery: !0,
      onSelectOption: oe,
      commandPriority: ie
    });
  }
  return $o.LexicalTypeaheadMenuPlugin = P, $o.MenuOption = f, $o.PUNCTUATION = T, $o.SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND = B, $o.getScrollParent = $, $o.useBasicTypeaheadTriggerMatch = L, $o.useDynamicPositioning = g, $o;
}
var ko = {}, Ng;
function kC() {
  if (Ng)
    return ko;
  Ng = 1;
  var r = zt(), n = St(), t = $t, o = kt(), u = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  class p {
    constructor(x) {
      this.key = x, this.ref = { current: null }, this.setRefElement = this.setRefElement.bind(this);
    }
    setRefElement(x) {
      this.ref = { current: x };
    }
  }
  let m = (C) => {
    const x = document.getElementById("typeahead-menu");
    if (x) {
      var I = x.getBoundingClientRect();
      I.top + I.height > window.innerHeight && x.scrollIntoView({ block: "center" }), 0 > I.top && x.scrollIntoView({ block: "center" }), C.scrollIntoView({ block: "nearest" });
    }
  };
  function f(C) {
    var x = n.$getSelection();
    if (!n.$isRangeSelection(x) || !x.isCollapsed())
      return null;
    var I = x.anchor;
    if (I.type !== "text" || (x = I.getNode(), !x.isSimpleText()))
      return null;
    I = I.offset;
    let W = x.getTextContent().slice(0, I);
    var $ = C.matchingString;
    C = C.replaceableString.length;
    for (let L = C; L <= $.length; L++)
      W.substr(-L) === $.substr(0, L) && (C = L);
    if (C = I - C, 0 > C)
      return null;
    let B;
    return C === 0 ? [B] = x.splitText(I) : [, B] = x.splitText(C, I), B;
  }
  function O(C, x) {
    let I = getComputedStyle(C), W = I.position === "absolute";
    if (x = x ? /(auto|scroll|hidden)/ : /(auto|scroll)/, I.position === "fixed")
      return document.body;
    for (; C = C.parentElement; )
      if (I = getComputedStyle(C), (!W || I.position !== "static") && x.test(I.overflow + I.overflowY + I.overflowX))
        return C;
    return document.body;
  }
  function S(C, x) {
    return C = C.getBoundingClientRect(), x = x.getBoundingClientRect(), C.top > x.top && C.top < x.bottom;
  }
  function E(C, x, I, W) {
    let [$] = r.useLexicalComposerContext();
    t.useEffect(() => {
      if (x != null && C != null) {
        let B = $.getRootElement(), L = B != null ? O(B, !1) : document.body, P = !1, F = S(x, L), Z = function() {
          P || (window.requestAnimationFrame(function() {
            I(), P = !1;
          }), P = !0);
          const ne = S(x, L);
          ne !== F && (F = ne, W != null && W(ne));
        }, oe = new ResizeObserver(I);
        return window.addEventListener("resize", I), document.addEventListener("scroll", Z, { capture: !0, passive: !0 }), oe.observe(x), () => {
          oe.unobserve(x), window.removeEventListener("resize", I), document.removeEventListener(
            "scroll",
            Z,
            !0
          );
        };
      }
    }, [x, $, W, I, C]);
  }
  let R = n.createCommand("SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND");
  function y({ close: C, editor: x, anchorElementRef: I, resolution: W, options: $, menuRenderFn: B, onSelectOption: L, shouldSplitNodeWithQuery: P = !1, commandPriority: F = n.COMMAND_PRIORITY_LOW }) {
    let [Z, oe] = t.useState(null);
    t.useEffect(() => {
      oe(0);
    }, [W.match && W.match.matchingString]);
    let ne = t.useCallback((A) => {
      x.update(() => {
        const z = W.match != null && P ? f(W.match) : null;
        L(A, z, C, W.match ? W.match.matchingString : "");
      });
    }, [x, P, W.match, L, C]), te = t.useCallback((A) => {
      const z = x.getRootElement();
      z !== null && (z.setAttribute(
        "aria-activedescendant",
        "typeahead-item-" + A
      ), oe(A));
    }, [x]);
    t.useEffect(() => () => {
      let A = x.getRootElement();
      A !== null && A.removeAttribute("aria-activedescendant");
    }, [x]), u(() => {
      $ === null ? oe(null) : Z === null && te(0);
    }, [$, Z, te]), t.useEffect(() => o.mergeRegister(x.registerCommand(R, ({ option: A }) => A.ref && A.ref.current != null ? (m(A.ref.current), !0) : !1, F)), [x, te, F]), t.useEffect(() => o.mergeRegister(x.registerCommand(n.KEY_ARROW_DOWN_COMMAND, (A) => {
      if ($ !== null && $.length && Z !== null) {
        let z = Z !== $.length - 1 ? Z + 1 : 0;
        te(z);
        let ie = $[z];
        ie.ref != null && ie.ref.current && x.dispatchCommand(R, { index: z, option: ie }), A.preventDefault(), A.stopImmediatePropagation();
      }
      return !0;
    }, F), x.registerCommand(n.KEY_ARROW_UP_COMMAND, (A) => {
      if ($ !== null && $.length && Z !== null) {
        var z = Z !== 0 ? Z - 1 : $.length - 1;
        te(z), z = $[z], z.ref != null && z.ref.current && m(z.ref.current), A.preventDefault(), A.stopImmediatePropagation();
      }
      return !0;
    }, F), x.registerCommand(n.KEY_ESCAPE_COMMAND, (A) => (A.preventDefault(), A.stopImmediatePropagation(), C(), !0), F), x.registerCommand(n.KEY_TAB_COMMAND, (A) => $ === null || Z === null || $[Z] == null ? !1 : (A.preventDefault(), A.stopImmediatePropagation(), ne($[Z]), !0), F), x.registerCommand(n.KEY_ENTER_COMMAND, (A) => $ === null || Z === null || $[Z] == null ? !1 : (A !== null && (A.preventDefault(), A.stopImmediatePropagation()), ne($[Z]), !0), F)), [ne, C, x, $, Z, te, F]);
    let K = t.useMemo(() => ({ options: $, selectOptionAndCleanUp: ne, selectedIndex: Z, setHighlightedIndex: oe }), [ne, Z, $]);
    return B(I, K, W.match ? W.match.matchingString : "");
  }
  function g(C, x, I, W = document.body) {
    let [$] = r.useLexicalComposerContext(), B = t.useRef(document.createElement("div")), L = t.useCallback(
      () => {
        B.current.style.top = B.current.style.bottom;
        const F = $.getRootElement(), Z = B.current;
        var oe = Z.firstChild;
        if (F !== null && C !== null) {
          const { left: te, top: K, width: A, height: z } = C.getRect();
          if (Z.style.top = `${K + window.pageYOffset + B.current.offsetHeight + 3}px`, Z.style.left = `${te + window.pageXOffset}px`, Z.style.height = `${z}px`, Z.style.width = `${A}px`, oe !== null) {
            oe.style.top = `${K}`;
            var ne = oe.getBoundingClientRect();
            oe = ne.height, ne = ne.width;
            const ie = F.getBoundingClientRect();
            te + ne > ie.right && (Z.style.left = `${ie.right - ne + window.pageXOffset}px`), (K + oe > window.innerHeight || K + oe > ie.bottom) && K - ie.top > oe && (Z.style.top = `${K - oe + window.pageYOffset - z}px`);
          }
          Z.isConnected || (I != null && (Z.className = I), Z.setAttribute("aria-label", "Typeahead menu"), Z.setAttribute("id", "typeahead-menu"), Z.setAttribute("role", "listbox"), Z.style.display = "block", Z.style.position = "absolute", W.append(Z)), B.current = Z, F.setAttribute("aria-controls", "typeahead-menu");
        }
      },
      [$, C, I, W]
    );
    t.useEffect(() => {
      let F = $.getRootElement();
      if (C !== null)
        return L(), () => {
          F !== null && F.removeAttribute("aria-controls");
          let Z = B.current;
          Z !== null && Z.isConnected && Z.remove();
        };
    }, [$, L, C]);
    let P = t.useCallback((F) => {
      C !== null && (F || x(null));
    }, [C, x]);
    return E(C, B.current, L, P), B;
  }
  function _(C, x, I) {
    var W = I.getSelection();
    if (W === null || !W.isCollapsed || (I = W.anchorNode, W = W.anchorOffset, I == null || W == null))
      return !1;
    try {
      x.setStart(I, C), x.setEnd(I, W);
    } catch {
      return !1;
    }
    return !0;
  }
  function N(C) {
    let x = null;
    return C.getEditorState().read(() => {
      var I = n.$getSelection();
      if (n.$isRangeSelection(I)) {
        var W = I.anchor;
        W.type !== "text" ? x = null : (I = W.getNode(), I.isSimpleText() ? (W = W.offset, x = I.getTextContent().slice(0, W)) : x = null);
      }
    }), x;
  }
  function w(C, x) {
    return x !== 0 ? !1 : C.getEditorState().read(() => {
      var I = n.$getSelection();
      return n.$isRangeSelection(I) ? (I = I.anchor.getNode().getPreviousSibling(), n.$isTextNode(I) && I.isTextEntity()) : !1;
    });
  }
  function T(C) {
    t.startTransition ? t.startTransition(C) : C();
  }
  let D = n.createCommand("SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND");
  return ko.LexicalTypeaheadMenuPlugin = function({ options: C, onQueryChange: x, onSelectOption: I, onOpen: W, onClose: $, menuRenderFn: B, triggerFn: L, anchorClassName: P, commandPriority: F = n.COMMAND_PRIORITY_LOW, parent: Z }) {
    let [oe] = r.useLexicalComposerContext(), [ne, te] = t.useState(null);
    P = g(ne, te, P, Z);
    let K = t.useCallback(() => {
      te(null), $ != null && ne !== null && $();
    }, [$, ne]), A = t.useCallback((z) => {
      te(z), W != null && ne === null && W(z);
    }, [W, ne]);
    return t.useEffect(() => {
      let z = oe.registerUpdateListener(() => {
        oe.getEditorState().read(() => {
          const ie = oe._window || window, q = ie.document.createRange(), Y = n.$getSelection(), se = N(oe);
          if (n.$isRangeSelection(Y) && Y.isCollapsed() && se !== null && q !== null) {
            var j = L(se, oe);
            x(j ? j.matchingString : null), j === null || w(oe, j.leadOffset) || _(j.leadOffset, q, ie) === null ? K() : T(() => A({ getRect: () => q.getBoundingClientRect(), match: j }));
          } else
            K();
        });
      });
      return () => {
        z();
      };
    }, [oe, L, x, ne, K, A]), ne === null || oe === null ? null : t.createElement(y, { close: K, resolution: ne, editor: oe, anchorElementRef: P, options: C, menuRenderFn: B, shouldSplitNodeWithQuery: !0, onSelectOption: I, commandPriority: F });
  }, ko.MenuOption = p, ko.PUNCTUATION = `\\.,\\+\\*\\?\\$\\@\\|#{}\\(\\)\\^\\-\\[\\]\\\\/!%'"~=<>_:;`, ko.SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND = D, ko.getScrollParent = function(C, x) {
    let I = getComputedStyle(C), W = I.position === "absolute";
    if (x = x ? /(auto|scroll|hidden)/ : /(auto|scroll)/, I.position === "fixed")
      return document.body;
    for (; C = C.parentElement; )
      if (I = getComputedStyle(C), (!W || I.position !== "static") && x.test(I.overflow + I.overflowY + I.overflowX))
        return C;
    return document.body;
  }, ko.useBasicTypeaheadTriggerMatch = function(C, { minLength: x = 1, maxLength: I = 75 }) {
    return t.useCallback((W) => {
      if (W = new RegExp("(^|\\s|\\()([" + C + "]((?:[^" + (C + `\\.,\\+\\*\\?\\$\\@\\|#{}\\(\\)\\^\\-\\[\\]\\\\/!%'"~=<>_:;\\s]){0,`) + I + "}))$").exec(W), W !== null) {
        let $ = W[1], B = W[3];
        if (B.length >= x)
          return { leadOffset: W.index + $.length, matchingString: B, replaceableString: W[2] };
      }
      return null;
    }, [I, x, C]);
  }, ko.useDynamicPositioning = E, ko;
}
const PC = process.env.NODE_ENV === "development" ? $C() : kC();
var Fo = PC;
class jn extends Fo.MenuOption {
  constructor(t, o) {
    super(t);
    // What shows up in the editor
    Tt(this, "title");
    // Icon for display
    Tt(this, "icon");
    // For extra searching.
    Tt(this, "keywords");
    // TBD
    Tt(this, "keyboardShortcut");
    // What happens when you select this option?
    Tt(this, "onSelect");
    this.title = t, this.keywords = o.keywords || [], this.icon = o.icon, this.keyboardShortcut = o.keyboardShortcut, this.onSelect = o.onSelect.bind(this);
  }
}
function FC({
  index: r,
  isSelected: n,
  onClick: t,
  onMouseEnter: o,
  option: u
}) {
  let p = "item";
  return n && (p += " selected"), /* @__PURE__ */ U.jsxs(
    "li",
    {
      tabIndex: -1,
      className: p,
      ref: u.setRefElement,
      role: "option",
      "aria-selected": n,
      id: "typeahead-item-" + r,
      onMouseEnter: o,
      onClick: t,
      children: [
        u.icon,
        /* @__PURE__ */ U.jsx("span", { className: "text", children: u.title })
      ]
    },
    u.key
  );
}
function BC(r, n) {
  const t = [];
  if (n == null)
    return t;
  const o = n.match(/^([1-9]\d?)(?:x([1-9]\d?)?)?$/);
  if (o !== null) {
    const u = o[1], p = o[2] ? [o[2]] : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(String);
    t.push(
      ...p.map(
        (m) => new jn(`${u}x${m} Table`, {
          icon: /* @__PURE__ */ U.jsx("i", { className: "icon table" }),
          keywords: ["table"],
          onSelect: () => r.dispatchCommand(vt.INSERT_TABLE_COMMAND, { columns: m, rows: u })
        })
      )
    );
  }
  return t;
}
function KC(r, n) {
  return [
    new jn("Paragraph", {
      icon: /* @__PURE__ */ U.jsx("i", { className: "icon paragraph" }),
      keywords: ["normal", "paragraph", "p", "text"],
      onSelect: () => r.update(() => {
        const t = fe.$getSelection();
        fe.$isRangeSelection(t) && sr.$setBlocksType(t, () => fe.$createParagraphNode());
      })
    }),
    ...[1, 2, 3].map(
      (t) => new jn(`Heading ${t}`, {
        icon: /* @__PURE__ */ U.jsx("i", { className: `icon h${t}` }),
        keywords: ["heading", "header", `h${t}`],
        onSelect: () => r.update(() => {
          const o = fe.$getSelection();
          fe.$isRangeSelection(o) && sr.$setBlocksType(o, () => Tr.$createHeadingNode(`h${t}`));
        })
      })
    ),
    new jn("Table", {
      icon: /* @__PURE__ */ U.jsx("i", { className: "icon table" }),
      keywords: ["table", "grid", "spreadsheet", "rows", "columns"],
      onSelect: () => n("Insert Table", (t) => /* @__PURE__ */ U.jsx(hh, { activeEditor: r, onClose: t }))
    }),
    new jn("Numbered List", {
      icon: /* @__PURE__ */ U.jsx("i", { className: "icon number" }),
      keywords: ["numbered list", "ordered list", "ol"],
      onSelect: () => r.dispatchCommand(Vn.INSERT_ORDERED_LIST_COMMAND, void 0)
    }),
    new jn("Bulleted List", {
      icon: /* @__PURE__ */ U.jsx("i", { className: "icon bullet" }),
      keywords: ["bulleted list", "unordered list", "ul"],
      onSelect: () => r.dispatchCommand(Vn.INSERT_UNORDERED_LIST_COMMAND, void 0)
    }),
    new jn("Check List", {
      icon: /* @__PURE__ */ U.jsx("i", { className: "icon check" }),
      keywords: ["check list", "todo list"],
      onSelect: () => r.dispatchCommand(Vn.INSERT_CHECK_LIST_COMMAND, void 0)
    }),
    new jn("Quote", {
      icon: /* @__PURE__ */ U.jsx("i", { className: "icon quote" }),
      keywords: ["block quote"],
      onSelect: () => r.update(() => {
        const t = fe.$getSelection();
        fe.$isRangeSelection(t) && sr.$setBlocksType(t, () => Tr.$createQuoteNode());
      })
    }),
    new jn("Code", {
      icon: /* @__PURE__ */ U.jsx("i", { className: "icon code" }),
      keywords: ["javascript", "python", "js", "codeblock"],
      onSelect: () => r.update(() => {
        const t = fe.$getSelection();
        if (fe.$isRangeSelection(t))
          if (t.isCollapsed())
            sr.$setBlocksType(t, () => va.$createCodeNode());
          else {
            const o = t.getTextContent(), u = va.$createCodeNode();
            t.insertNodes([u]), t.insertRawText(o);
          }
      })
    }),
    new jn("Divider", {
      icon: /* @__PURE__ */ U.jsx("i", { className: "icon horizontal-rule" }),
      keywords: ["horizontal rule", "divider", "hr"],
      onSelect: () => r.dispatchCommand(Cl.INSERT_HORIZONTAL_RULE_COMMAND, void 0)
    }),
    new jn("Page Break", {
      icon: /* @__PURE__ */ U.jsx("i", { className: "icon page-break" }),
      keywords: ["page break", "divider"],
      onSelect: () => r.dispatchCommand(hu, void 0)
    }),
    new jn("Excalidraw", {
      icon: /* @__PURE__ */ U.jsx("i", { className: "icon diagram-2" }),
      keywords: ["excalidraw", "diagram", "drawing"],
      onSelect: () => r.dispatchCommand(Nu, void 0)
    }),
    new jn("Poll", {
      icon: /* @__PURE__ */ U.jsx("i", { className: "icon poll" }),
      keywords: ["poll", "vote"],
      onSelect: () => n("Insert Poll", (t) => /* @__PURE__ */ U.jsx(mh, { activeEditor: r, onClose: t }))
    }),
    ...xu.map(
      (t) => new jn(`Embed ${t.contentName}`, {
        icon: t.icon,
        keywords: [...t.keywords, "embed"],
        onSelect: () => r.dispatchCommand(Ss.INSERT_EMBED_COMMAND, t.type)
      })
    ),
    new jn("Equation", {
      icon: /* @__PURE__ */ U.jsx("i", { className: "icon equation" }),
      keywords: ["equation", "latex", "math"],
      onSelect: () => n("Insert Equation", (t) => /* @__PURE__ */ U.jsx(xh, { activeEditor: r, onClose: t }))
    }),
    new jn("GIF", {
      icon: /* @__PURE__ */ U.jsx("i", { className: "icon gif" }),
      keywords: ["gif", "animate", "image", "file"],
      onSelect: () => r.dispatchCommand(Sl, {
        altText: "Cat typing on a laptop",
        src: "https://media.giphy.com/media/3o7TKz5R0Lkzg7g9gI/giphy.gif"
      })
    }),
    new jn("Image", {
      icon: /* @__PURE__ */ U.jsx("i", { className: "icon image" }),
      keywords: ["image", "photo", "picture", "file"],
      onSelect: () => n("Insert Image", (t) => /* @__PURE__ */ U.jsx(ch, { activeEditor: r, onClose: t }))
    }),
    new jn("Collapsible", {
      icon: /* @__PURE__ */ U.jsx("i", { className: "icon caret-right" }),
      keywords: ["collapse", "collapsible", "toggle"],
      onSelect: () => r.dispatchCommand(Cu, void 0)
    }),
    new jn("Columns Layout", {
      icon: /* @__PURE__ */ U.jsx("i", { className: "icon columns" }),
      keywords: ["columns", "layout", "grid"],
      onSelect: () => n("Insert Columns Layout", (t) => /* @__PURE__ */ U.jsx(Nh, { activeEditor: r, onClose: t }))
    }),
    ...["left", "center", "right", "justify"].map(
      (t) => new jn(`Align ${t}`, {
        icon: /* @__PURE__ */ U.jsx("i", { className: `icon ${t}-align` }),
        keywords: ["align", "justify", t],
        onSelect: () => r.dispatchCommand(fe.FORMAT_ELEMENT_COMMAND, t)
      })
    )
  ];
}
function jC() {
  const [r] = gn.useLexicalComposerContext(), [n, t] = ba(), [o, u] = ut(null), p = Fo.useBasicTypeaheadTriggerMatch("/", {
    minLength: 0
  }), m = Zr(() => {
    const O = KC(r, t);
    if (!o)
      return O;
    const S = new RegExp(o, "i");
    return [
      ...BC(r, o),
      ...O.filter(
        (E) => S.test(E.title) || E.keywords.some((R) => S.test(R))
      )
    ];
  }, [r, o, t]), f = Vt(
    (O, S, E, R) => {
      r.update(() => {
        S == null || S.remove(), O.onSelect(R), E();
      });
    },
    [r]
  );
  return /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    n,
    /* @__PURE__ */ U.jsx(
      Fo.LexicalTypeaheadMenuPlugin,
      {
        onQueryChange: u,
        onSelectOption: f,
        triggerFn: p,
        options: m,
        menuRenderFn: (O, { selectedIndex: S, selectOptionAndCleanUp: E, setHighlightedIndex: R }) => O.current && m.length ? ml.createPortal(
          /* @__PURE__ */ U.jsx("div", { className: "typeahead-popover component-picker-menu", children: /* @__PURE__ */ U.jsx("ul", { children: m.map((y, g) => /* @__PURE__ */ U.jsx(
            FC,
            {
              index: g,
              isSelected: S === g,
              onClick: () => {
                R(g), E(y);
              },
              onMouseEnter: () => {
                R(g);
              },
              option: y
            },
            y.key
          )) }) }),
          O.current
        ) : null
      }
    )
  ] });
}
function HC(r, n) {
  const t = r.getRangeAt(0);
  let o;
  if (r.anchorNode === n) {
    let u = n;
    for (; u.firstElementChild != null; )
      u = u.firstElementChild;
    o = u.getBoundingClientRect();
  } else
    o = t.getBoundingClientRect();
  return o;
}
const WC = 10, UC = 5;
function YC(r, n, t, o = !1, u = WC, p = UC) {
  const m = t.parentElement;
  if (r === null || !m) {
    n.style.opacity = "0", n.style.transform = "translate(-10000px, -10000px)";
    return;
  }
  const f = n.getBoundingClientRect(), O = t.getBoundingClientRect(), S = m.getBoundingClientRect();
  let E = r.top - f.height - u, R = r.left - p;
  E < S.top && (E += f.height + r.height + u * (o ? 9 : 2)), R + f.width > S.right && (R = S.right - f.width - p), E -= O.top, R -= O.left, n.style.opacity = "1", n.style.transform = `translate(${R}px, ${E}px)`;
}
function zC({
  editor: r,
  anchorElem: n,
  isLink: t,
  isBold: o,
  isItalic: u,
  isUnderline: p,
  isCode: m,
  isStrikethrough: f,
  isSubscript: O,
  isSuperscript: S
}) {
  const E = Cn(null), R = Vt(() => {
    t ? r.dispatchCommand(dn.TOGGLE_LINK_COMMAND, null) : r.dispatchCommand(dn.TOGGLE_LINK_COMMAND, "https://");
  }, [r, t]);
  function y(N) {
    if (E != null && E.current && (N.buttons === 1 || N.buttons === 3) && E.current.style.pointerEvents !== "none") {
      const w = N.clientX, T = N.clientY, D = document.elementFromPoint(w, T);
      E.current.contains(D) || (E.current.style.pointerEvents = "none");
    }
  }
  function g(N) {
    E != null && E.current && E.current.style.pointerEvents !== "auto" && (E.current.style.pointerEvents = "auto");
  }
  yt(() => {
    if (E != null && E.current)
      return document.addEventListener("mousemove", y), document.addEventListener("mouseup", g), () => {
        document.removeEventListener("mousemove", y), document.removeEventListener("mouseup", g);
      };
  }, [E]);
  const _ = Vt(() => {
    const N = fe.$getSelection(), w = E.current, T = window.getSelection();
    if (w === null)
      return;
    const D = r.getRootElement();
    if (N !== null && T !== null && !T.isCollapsed && D !== null && D.contains(T.anchorNode)) {
      const C = HC(T, D);
      YC(
        C,
        w,
        n,
        t
      );
    }
  }, [r, n, t]);
  return yt(() => {
    const N = n.parentElement, w = () => {
      r.getEditorState().read(() => {
        _();
      });
    };
    return window.addEventListener("resize", w), N && N.addEventListener("scroll", w), () => {
      window.removeEventListener("resize", w), N && N.removeEventListener("scroll", w);
    };
  }, [r, _, n]), yt(() => (r.getEditorState().read(() => {
    _();
  }), Jt.mergeRegister(
    r.registerUpdateListener(({ editorState: N }) => {
      N.read(() => {
        _();
      });
    }),
    r.registerCommand(
      fe.SELECTION_CHANGE_COMMAND,
      () => (_(), !1),
      fe.COMMAND_PRIORITY_LOW
    )
  )), [r, _]), /* @__PURE__ */ U.jsx("div", { ref: E, className: "floating-text-format-popup", children: r.isEditable() && /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    /* @__PURE__ */ U.jsx(
      "button",
      {
        type: "button",
        onClick: () => {
          r.dispatchCommand(fe.FORMAT_TEXT_COMMAND, "bold");
        },
        className: "popup-item spaced " + (o ? "active" : ""),
        "aria-label": "Format text as bold",
        children: /* @__PURE__ */ U.jsx("i", { className: "format bold" })
      }
    ),
    /* @__PURE__ */ U.jsx(
      "button",
      {
        type: "button",
        onClick: () => {
          r.dispatchCommand(fe.FORMAT_TEXT_COMMAND, "italic");
        },
        className: "popup-item spaced " + (u ? "active" : ""),
        "aria-label": "Format text as italics",
        children: /* @__PURE__ */ U.jsx("i", { className: "format italic" })
      }
    ),
    /* @__PURE__ */ U.jsx(
      "button",
      {
        type: "button",
        onClick: () => {
          r.dispatchCommand(fe.FORMAT_TEXT_COMMAND, "underline");
        },
        className: "popup-item spaced " + (p ? "active" : ""),
        "aria-label": "Format text to underlined",
        children: /* @__PURE__ */ U.jsx("i", { className: "format underline" })
      }
    ),
    /* @__PURE__ */ U.jsx(
      "button",
      {
        type: "button",
        onClick: () => {
          r.dispatchCommand(fe.FORMAT_TEXT_COMMAND, "strikethrough");
        },
        className: "popup-item spaced " + (f ? "active" : ""),
        "aria-label": "Format text with a strikethrough",
        children: /* @__PURE__ */ U.jsx("i", { className: "format strikethrough" })
      }
    ),
    /* @__PURE__ */ U.jsx(
      "button",
      {
        type: "button",
        onClick: () => {
          r.dispatchCommand(fe.FORMAT_TEXT_COMMAND, "subscript");
        },
        className: "popup-item spaced " + (O ? "active" : ""),
        title: "Subscript",
        "aria-label": "Format Subscript",
        children: /* @__PURE__ */ U.jsx("i", { className: "format subscript" })
      }
    ),
    /* @__PURE__ */ U.jsx(
      "button",
      {
        type: "button",
        onClick: () => {
          r.dispatchCommand(fe.FORMAT_TEXT_COMMAND, "superscript");
        },
        className: "popup-item spaced " + (S ? "active" : ""),
        title: "Superscript",
        "aria-label": "Format Superscript",
        children: /* @__PURE__ */ U.jsx("i", { className: "format superscript" })
      }
    ),
    /* @__PURE__ */ U.jsx(
      "button",
      {
        type: "button",
        onClick: () => {
          r.dispatchCommand(fe.FORMAT_TEXT_COMMAND, "code");
        },
        className: "popup-item spaced " + (m ? "active" : ""),
        "aria-label": "Insert code block",
        children: /* @__PURE__ */ U.jsx("i", { className: "format code" })
      }
    ),
    /* @__PURE__ */ U.jsx(
      "button",
      {
        type: "button",
        onClick: R,
        className: "popup-item spaced " + (t ? "active" : ""),
        "aria-label": "Insert link",
        children: /* @__PURE__ */ U.jsx("i", { className: "format link" })
      }
    )
  ] }) });
}
function qC(r, n) {
  const [t, o] = ut(!1), [u, p] = ut(!1), [m, f] = ut(!1), [O, S] = ut(!1), [E, R] = ut(!1), [y, g] = ut(!1), [_, N] = ut(!1), [w, T] = ut(!1), [D, C] = ut(!1), x = Vt(() => {
    r.getEditorState().read(() => {
      if (r.isComposing())
        return;
      const I = fe.$getSelection(), W = window.getSelection(), $ = r.getRootElement();
      if (W !== null && (!fe.$isRangeSelection(I) || $ === null || !$.contains(W.anchorNode))) {
        o(!1);
        return;
      }
      if (!fe.$isRangeSelection(I))
        return;
      const B = ws(I);
      f(I.hasFormat("bold")), S(I.hasFormat("italic")), R(I.hasFormat("underline")), g(I.hasFormat("strikethrough")), N(I.hasFormat("subscript")), T(I.hasFormat("superscript")), C(I.hasFormat("code"));
      const L = B.getParent();
      dn.$isLinkNode(L) || dn.$isLinkNode(B) ? p(!0) : p(!1), !va.$isCodeHighlightNode(I.anchor.getNode()) && I.getTextContent() !== "" ? o(fe.$isTextNode(B) || fe.$isParagraphNode(B)) : o(!1);
      const P = I.getTextContent().replace(/\n/g, "");
      if (!I.isCollapsed() && P === "") {
        o(!1);
        return;
      }
    });
  }, [r]);
  return yt(() => (document.addEventListener("selectionchange", x), () => {
    document.removeEventListener("selectionchange", x);
  }), [x]), yt(() => Jt.mergeRegister(
    r.registerUpdateListener(() => {
      x();
    }),
    r.registerRootListener(() => {
      r.getRootElement() === null && o(!1);
    })
  ), [r, x]), t ? Bo(
    /* @__PURE__ */ U.jsx(
      zC,
      {
        editor: r,
        anchorElem: n,
        isLink: u,
        isBold: m,
        isItalic: O,
        isStrikethrough: y,
        isSubscript: _,
        isSuperscript: w,
        isUnderline: E,
        isCode: D
      }
    ),
    n
  ) : null;
}
function GC({
  anchorElem: r = document.body
}) {
  const [n] = gn.useLexicalComposerContext();
  return qC(n, r);
}
var jc = {}, Cg;
function VC() {
  if (Cg)
    return jc;
  Cg = 1;
  var r = zt(), n = vt, t = kt(), o = St(), u = $t;
  function p({
    hasCellMerge: m = !0,
    hasCellBackgroundColor: f = !0,
    hasTabHandler: O = !0
  }) {
    const [S] = r.useLexicalComposerContext();
    return u.useEffect(() => {
      if (!S.hasNodes([n.TableNode, n.TableCellNode, n.TableRowNode]))
        throw Error("TablePlugin: TableNode, TableCellNode or TableRowNode not registered on editor");
      return S.registerCommand(n.INSERT_TABLE_COMMAND, ({
        columns: E,
        rows: R,
        includeHeaders: y
      }) => {
        const g = n.$createTableNodeWithDimensions(Number(R), Number(E), y);
        t.$insertNodeToNearestRoot(g);
        const _ = g.getFirstDescendant();
        return o.$isTextNode(_) && _.select(), !0;
      }, o.COMMAND_PRIORITY_EDITOR);
    }, [S]), u.useEffect(() => {
      const E = /* @__PURE__ */ new Map(), R = (g) => {
        const _ = g.getKey(), N = S.getElementByKey(_);
        if (N && !E.has(_)) {
          const w = n.applyTableHandlers(g, N, S, O);
          E.set(_, w);
        }
      };
      S.getEditorState().read(() => {
        const g = o.$nodesOfType(n.TableNode);
        for (const _ of g)
          n.$isTableNode(_) && R(_);
      });
      const y = S.registerMutationListener(n.TableNode, (g) => {
        for (const [_, N] of g)
          if (N === "created")
            S.getEditorState().read(() => {
              const w = o.$getNodeByKey(_);
              n.$isTableNode(w) && R(w);
            });
          else if (N === "destroyed") {
            const w = E.get(_);
            w !== void 0 && (w.removeListeners(), E.delete(_));
          }
      });
      return () => {
        y();
        for (const [, g] of E)
          g.removeListeners();
      };
    }, [S, O]), u.useEffect(() => {
      if (!m)
        return S.registerNodeTransform(n.TableCellNode, (E) => {
          if (E.getColSpan() > 1 || E.getRowSpan() > 1) {
            const [, , R] = n.$getNodeTriplet(E), [y] = n.$computeTableMap(R, E, E), g = y.length, _ = y[0].length;
            let N = R.getFirstChild();
            if (!n.$isTableRowNode(N))
              throw Error("Expected TableNode first child to be a RowNode");
            const w = [];
            for (let T = 0; T < g; T++) {
              if (T !== 0 && (N = N.getNextSibling(), !n.$isTableRowNode(N)))
                throw Error("Expected TableNode first child to be a RowNode");
              let D = null;
              for (let C = 0; C < _; C++) {
                const x = y[T][C], I = x.cell;
                if (x.startRow === T && x.startColumn === C)
                  D = I, w.push(I);
                else if (I.getColSpan() > 1 || I.getRowSpan() > 1) {
                  if (!n.$isTableCellNode(I))
                    throw Error("Expected TableNode cell to be a TableCellNode");
                  const W = n.$createTableCellNode(I.__headerState);
                  D !== null ? D.insertAfter(W) : t.$insertFirst(N, W);
                }
              }
            }
            for (const T of w)
              T.setColSpan(1), T.setRowSpan(1);
          }
        });
    }, [S, m]), u.useEffect(() => {
      if (!f)
        return S.registerNodeTransform(n.TableCellNode, (E) => {
          E.getBackgroundColor() !== null && E.setBackgroundColor(null);
        });
    }, [S, f, m]), null;
  }
  return jc.TablePlugin = p, jc;
}
var Hc = {}, xg;
function JC() {
  if (xg)
    return Hc;
  xg = 1;
  var r = zt(), n = vt, t = kt(), o = St(), u = $t;
  function p(m) {
    let f = new URLSearchParams();
    f.append("code", m);
    for (let O = 1; O < arguments.length; O++)
      f.append("v", arguments[O]);
    throw Error(`Minified Lexical error #${m}; visit https://lexical.dev/docs/error?${f} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  return Hc.TablePlugin = function({ hasCellMerge: m = !0, hasCellBackgroundColor: f = !0, hasTabHandler: O = !0 }) {
    let [S] = r.useLexicalComposerContext();
    return u.useEffect(() => (S.hasNodes([n.TableNode, n.TableCellNode, n.TableRowNode]) || p(10), S.registerCommand(n.INSERT_TABLE_COMMAND, ({ columns: E, rows: R, includeHeaders: y }) => (E = n.$createTableNodeWithDimensions(Number(R), Number(E), y), t.$insertNodeToNearestRoot(E), E = E.getFirstDescendant(), o.$isTextNode(E) && E.select(), !0), o.COMMAND_PRIORITY_EDITOR)), [S]), u.useEffect(
      () => {
        let E = /* @__PURE__ */ new Map(), R = (g) => {
          const _ = g.getKey(), N = S.getElementByKey(_);
          N && !E.has(_) && (g = n.applyTableHandlers(g, N, S, O), E.set(_, g));
        };
        S.getEditorState().read(() => {
          let g = o.$nodesOfType(n.TableNode);
          for (let _ of g)
            n.$isTableNode(_) && R(_);
        });
        let y = S.registerMutationListener(n.TableNode, (g) => {
          for (const [_, N] of g)
            N === "created" ? S.getEditorState().read(() => {
              const w = o.$getNodeByKey(_);
              n.$isTableNode(w) && R(w);
            }) : N === "destroyed" && (g = E.get(_), g !== void 0 && (g.removeListeners(), E.delete(_)));
        });
        return () => {
          y();
          for (let [, g] of E)
            g.removeListeners();
        };
      },
      [S, O]
    ), u.useEffect(() => {
      if (!m)
        return S.registerNodeTransform(n.TableCellNode, (E) => {
          if (1 < E.getColSpan() || 1 < E.getRowSpan()) {
            var [, , R] = n.$getNodeTriplet(E);
            [E] = n.$computeTableMap(R, E, E);
            let g = E.length, _ = E[0].length;
            if (R = R.getFirstChild(), !n.$isTableRowNode(R))
              throw Error("Expected TableNode first child to be a RowNode");
            let N = [];
            for (let w = 0; w < g; w++) {
              if (w !== 0 && (R = R.getNextSibling(), !n.$isTableRowNode(R)))
                throw Error("Expected TableNode first child to be a RowNode");
              let T = null;
              for (let D = 0; D < _; D++) {
                var y = E[w][D];
                let C = y.cell;
                if (y.startRow === w && y.startColumn === D)
                  T = C, N.push(C);
                else if (1 < C.getColSpan() || 1 < C.getRowSpan()) {
                  if (!n.$isTableCellNode(C))
                    throw Error("Expected TableNode cell to be a TableCellNode");
                  y = n.$createTableCellNode(C.__headerState), T !== null ? T.insertAfter(y) : t.$insertFirst(R, y);
                }
              }
            }
            for (let w of N)
              w.setColSpan(1), w.setRowSpan(1);
          }
        });
    }, [S, m]), u.useEffect(() => {
      if (!f)
        return S.registerNodeTransform(n.TableCellNode, (E) => {
          E.getBackgroundColor() !== null && E.setBackgroundColor(null);
        });
    }, [S, f, m]), null;
  }, Hc;
}
const XC = process.env.NODE_ENV === "development" ? VC() : JC();
var ZC = XC, QC = gu();
const vh = /* @__PURE__ */ Dg(QC), ex = 33, tx = 50;
function nx({ editor: r }) {
  const n = Cn(null), t = Cn(null), o = Cn(null), u = Cn(null), [p, m] = ut(null), [f, O] = ut(null), [S, E] = ut(!1), [R, y] = ut(null);
  yt(() => r.registerCommand(
    fe.SELECTION_CHANGE_COMMAND,
    () => {
      const I = fe.$getSelection(), W = vt.$isTableSelection(I);
      return S !== W && E(W), !1;
    },
    fe.COMMAND_PRIORITY_HIGH
  ));
  const g = Vt(() => {
    O(null), n.current = null, y(null), u.current = null, o.current = null;
  }, []);
  yt(() => {
    const I = (W) => {
      setTimeout(() => {
        const $ = W.target;
        if (R) {
          m({
            x: W.clientX,
            y: W.clientY
          });
          return;
        }
        if (!(t.current && t.current.contains($)) && n.current !== $) {
          n.current = $;
          const B = vt.getDOMCellFromTarget($);
          B && f !== B ? r.update(() => {
            const L = fe.$getNearestNodeFromDOMNode(B.elem);
            if (!L)
              throw new Error("TableCellResizer: Table cell node not found.");
            const P = vt.$getTableNodeFromLexicalNodeOrThrow(L), F = r.getElementByKey(P.getKey());
            if (!F)
              throw new Error("TableCellResizer: Table element not found.");
            n.current = $, o.current = F.getBoundingClientRect(), O(B);
          }) : B == null && g();
        }
      }, 0);
    };
    return document.addEventListener("mousemove", I), () => {
      document.removeEventListener("mousemove", I);
    };
  }, [f, R, r, g]);
  const _ = (I) => I === "bottom", N = Vt(
    (I) => {
      if (!f)
        throw new Error("TableCellResizer: Expected active cell.");
      r.update(() => {
        const W = fe.$getNearestNodeFromDOMNode(f.elem);
        if (!vt.$isTableCellNode(W))
          throw new Error("TableCellResizer: Table cell node not found.");
        const $ = vt.$getTableNodeFromLexicalNodeOrThrow(W), B = vt.$getTableRowIndexFromTableCellNode(W), L = $.getChildren();
        if (B >= L.length || B < 0)
          throw new Error("Expected table cell to be inside of table row.");
        const P = L[B];
        if (!vt.$isTableRowNode(P))
          throw new Error("Expected table row");
        P.setHeight(I);
      });
    },
    [f, r]
  ), w = Vt(
    (I) => {
      if (!f)
        throw new Error("TableCellResizer: Expected active cell.");
      r.update(() => {
        const W = fe.$getNearestNodeFromDOMNode(f.elem);
        if (!vt.$isTableCellNode(W))
          throw new Error("TableCellResizer: Table cell node not found.");
        const $ = vt.$getTableNodeFromLexicalNodeOrThrow(W), B = vt.$getTableColumnIndexFromTableCellNode(W), L = $.getChildren();
        for (let P = 0; P < L.length; P++) {
          const F = L[P];
          if (!vt.$isTableRowNode(F))
            throw new Error("Expected table row");
          const Z = F.getChildren(), te = Z.map((A) => A.getColSpan()).reduce(
            (A, z) => {
              const ie = A[A.length - 1] ?? 0;
              return A.push(ie + z), A;
            },
            []
          ).findIndex(
            (A) => A > B
          );
          if (te >= Z.length || te < 0)
            throw new Error("Expected table cell to be inside of table row.");
          const K = Z[te];
          if (!vt.$isTableCellNode(K))
            throw new Error("Expected table cell");
          K.setWidth(I);
        }
      });
    },
    [f, r]
  ), T = Vt(
    (I) => {
      const W = ($) => {
        if ($.preventDefault(), $.stopPropagation(), !f)
          throw new Error("TableCellResizer: Expected active cell.");
        if (u.current) {
          const { x: B, y: L } = u.current;
          if (f === null)
            return;
          if (_(I)) {
            const P = f.elem.getBoundingClientRect().height, F = Math.abs($.clientY - L), Z = I === "bottom" && L > $.clientY;
            N(
              Math.max(
                Z ? P - F : F + P,
                ex
              )
            );
          } else {
            const P = getComputedStyle(f.elem);
            let F = f.elem.clientWidth;
            F -= parseFloat(P.paddingLeft) + parseFloat(P.paddingRight);
            const Z = Math.abs($.clientX - B), oe = I === "right" && B > $.clientX;
            w(
              Math.max(
                oe ? F - Z : Z + F,
                tx
              )
            );
          }
          g(), document.removeEventListener("mouseup", W);
        }
      };
      return W;
    },
    [f, g, w, N]
  ), D = Vt(
    (I) => (W) => {
      if (W.preventDefault(), W.stopPropagation(), !f)
        throw new Error("TableCellResizer: Expected active cell.");
      u.current = {
        x: W.clientX,
        y: W.clientY
      }, m(u.current), y(I), document.addEventListener("mouseup", T(I));
    },
    [f, T]
  ), x = Vt(() => {
    if (f) {
      const { height: I, width: W, top: $, left: B } = f.elem.getBoundingClientRect(), L = {
        bottom: {
          backgroundColor: "none",
          cursor: "row-resize",
          height: "10px",
          left: `${window.pageXOffset + B}px`,
          top: `${window.pageYOffset + $ + I}px`,
          width: `${W}px`
        },
        right: {
          backgroundColor: "none",
          cursor: "col-resize",
          height: `${I}px`,
          left: `${window.pageXOffset + B + W}px`,
          top: `${window.pageYOffset + $}px`,
          width: "10px"
        }
      }, P = o.current;
      return R && p && P && (_(R) ? (L[R].left = `${window.pageXOffset + P.left}px`, L[R].top = `${window.pageYOffset + p.y}px`, L[R].height = "3px", L[R].width = `${P.width}px`) : (L[R].top = `${window.pageYOffset + P.top}px`, L[R].left = `${window.pageXOffset + p.x}px`, L[R].width = "3px", L[R].height = `${P.height}px`), L[R].backgroundColor = "#adf"), L;
    }
    return {
      bottom: null,
      left: null,
      right: null,
      top: null
    };
  }, [f, R, p])();
  return /* @__PURE__ */ U.jsx("div", { ref: t, children: f != null && !S && /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    /* @__PURE__ */ U.jsx(
      "div",
      {
        className: "TableCellResizer__resizer TableCellResizer__ui",
        style: x.right || void 0,
        onMouseDown: D("right")
      }
    ),
    /* @__PURE__ */ U.jsx(
      "div",
      {
        className: "TableCellResizer__resizer TableCellResizer__ui",
        style: x.bottom || void 0,
        onMouseDown: D("bottom")
      }
    )
  ] }) });
}
function rx() {
  const [r] = gn.useLexicalComposerContext(), n = vh();
  return Zr(
    () => n ? Bo(/* @__PURE__ */ U.jsx(nx, { editor: r }), document.body) : null,
    [r, n]
  );
}
function Wc(r) {
  const n = r.getShape();
  return {
    columns: n.toX - n.fromX + 1,
    rows: n.toY - n.fromY + 1
  };
}
function ox(r) {
  const n = r.getNodes(), t = [];
  let o = null, u = null, p = 0;
  for (let m = 0; m < n.length; m++) {
    const f = n[m];
    if (vt.$isTableCellNode(f)) {
      const O = f.getParentOrThrow();
      if (hN(
        vt.$isTableRowNode(O),
        "Expected CellNode to have a RowNode parent"
      ), o !== O) {
        if (u !== null && p !== u)
          return !1;
        o !== null && (u = p), o = O, p = 0;
      }
      const S = f.__colSpan;
      for (let E = 0; E < S; E++)
        t[p + E] === void 0 && (t[p + E] = 0), t[p + E] += f.__rowSpan;
      p += S;
    }
  }
  return (u === null || p === u) && t.every((m) => m === t[0]);
}
function ix() {
  const r = fe.$getSelection();
  if (fe.$isRangeSelection(r) && !r.isCollapsed() || vt.$isTableSelection(r) && !r.anchor.is(r.focus) || !fe.$isRangeSelection(r) && !vt.$isTableSelection(r))
    return !1;
  const [n] = vt.$getNodeTriplet(r.anchor);
  return n.__colSpan > 1 || n.__rowSpan > 1;
}
function Eg(r) {
  if (r.getChildrenSize() !== 1)
    return !1;
  const n = r.getFirstChildOrThrow();
  return !(!fe.$isParagraphNode(n) || !n.isEmpty());
}
function sx(r) {
  const n = r.getLastDescendant();
  fe.$isTextNode(n) ? n.select() : fe.$isElementNode(n) ? n.selectEnd() : n !== null && n.selectNext();
}
function Tg(r) {
  return r.getEditorState().read(() => {
    const n = fe.$getSelection();
    if (fe.$isRangeSelection(n) || vt.$isTableSelection(n)) {
      const [t] = vt.$getNodeTriplet(n.anchor);
      if (vt.$isTableCellNode(t))
        return t.getBackgroundColor();
    }
    return null;
  });
}
function lx({
  onClose: r,
  tableCellNode: n,
  setIsMenuOpen: t,
  contextRef: o,
  cellMerge: u,
  showColorPickerModal: p
}) {
  const [m] = gn.useLexicalComposerContext(), f = Cn(null), [O, S] = ut(n), [E, R] = ut({
    columns: 1,
    rows: 1
  }), [y, g] = ut(!1), [_, N] = ut(!1), [w, T] = ut(
    () => Tg(m) || ""
  );
  yt(() => m.registerMutationListener(vt.TableCellNode, (ne) => {
    ne.get(O.getKey()) === "updated" && (m.getEditorState().read(() => {
      S(O.getLatest());
    }), T(Tg(m) || ""));
  }), [m, O]), yt(() => {
    m.getEditorState().read(() => {
      const ne = fe.$getSelection();
      if (vt.$isTableSelection(ne)) {
        const te = Wc(ne);
        R(Wc(ne)), g(
          ox(ne) && (te.columns > 1 || te.rows > 1)
        );
      }
      N(ix());
    });
  }, [m]), yt(() => {
    const ne = o.current, te = f.current, K = m.getRootElement();
    if (ne != null && te != null && K != null) {
      const A = K.getBoundingClientRect(), z = ne.getBoundingClientRect();
      te.style.opacity = "1";
      const ie = te.getBoundingClientRect(), q = 5;
      let Y = z.right + q;
      if (Y + ie.width > window.innerWidth || Y + ie.width > A.right) {
        const j = z.left - ie.width - q;
        Y = (j < 0 ? q : j) + window.pageXOffset;
      }
      te.style.left = `${Y + window.pageXOffset}px`;
      let se = z.top;
      if (se + ie.height > window.innerHeight) {
        const j = z.bottom - ie.height;
        se = (j < 0 ? q : j) + window.pageYOffset;
      }
      te.style.top = `${se + +window.pageYOffset}px`;
    }
  }, [o, f, m]), yt(() => {
    function ne(te) {
      f.current != null && o.current != null && !f.current.contains(te.target) && !o.current.contains(te.target) && t(!1);
    }
    return window.addEventListener("click", ne), () => window.removeEventListener("click", ne);
  }, [t, o]);
  const D = Vt(() => {
    m.update(() => {
      if (O.isAttached()) {
        const te = vt.$getTableNodeFromLexicalNodeOrThrow(O), K = m.getElementByKey(
          te.getKey()
        );
        if (!K)
          throw new Error("Expected to find tableElement in DOM");
        const A = vt.getTableObserverFromTableElement(K);
        A !== null && A.clearHighlight(), te.markDirty(), S(O.getLatest());
      }
      fe.$getRoot().selectStart();
    });
  }, [m, O]), C = () => {
    m.update(() => {
      const ne = fe.$getSelection();
      if (vt.$isTableSelection(ne)) {
        const { columns: te, rows: K } = Wc(ne), A = ne.getNodes();
        let z = null;
        for (let ie = 0; ie < A.length; ie++) {
          const q = A[ie];
          if (vt.$isTableCellNode(q))
            if (z === null) {
              q.setColSpan(te).setRowSpan(K), z = q;
              const Y = Eg(q);
              let se;
              Y && fe.$isParagraphNode(se = q.getFirstChild()) && se.remove();
            } else
              vt.$isTableCellNode(z) && (Eg(q) || z.append(...q.getChildren()), q.remove());
        }
        z !== null && (z.getChildrenSize() === 0 && z.append(fe.$createParagraphNode()), sx(z)), r();
      }
    });
  }, x = () => {
    m.update(() => {
      vt.$unmergeCell();
    });
  }, I = Vt(
    (ne) => {
      m.update(() => {
        vt.$insertTableRow__EXPERIMENTAL(ne), r();
      });
    },
    [m, r]
  ), W = Vt(
    (ne) => {
      m.update(() => {
        for (let te = 0; te < E.columns; te++)
          vt.$insertTableColumn__EXPERIMENTAL(ne);
        r();
      });
    },
    [m, r, E.columns]
  ), $ = Vt(() => {
    m.update(() => {
      vt.$deleteTableRow__EXPERIMENTAL(), r();
    });
  }, [m, r]), B = Vt(() => {
    m.update(() => {
      vt.$getTableNodeFromLexicalNodeOrThrow(O).remove(), D(), r();
    });
  }, [m, O, D, r]), L = Vt(() => {
    m.update(() => {
      vt.$deleteTableColumn__EXPERIMENTAL(), r();
    });
  }, [m, r]), P = Vt(() => {
    m.update(() => {
      const ne = vt.$getTableNodeFromLexicalNodeOrThrow(O), te = vt.$getTableRowIndexFromTableCellNode(O), K = ne.getChildren();
      if (te >= K.length || te < 0)
        throw new Error("Expected table cell to be inside of table row.");
      const A = K[te];
      if (!vt.$isTableRowNode(A))
        throw new Error("Expected table row");
      A.getChildren().forEach((z) => {
        if (!vt.$isTableCellNode(z))
          throw new Error("Expected table cell");
        z.toggleHeaderStyle(vt.TableCellHeaderStates.ROW);
      }), D(), r();
    });
  }, [m, O, D, r]), F = Vt(() => {
    m.update(() => {
      const ne = vt.$getTableNodeFromLexicalNodeOrThrow(O), te = vt.$getTableColumnIndexFromTableCellNode(O), K = ne.getChildren(), A = Math.max(
        ...K.map((z) => z.getChildren().length)
      );
      if (te >= A || te < 0)
        throw new Error("Expected table cell to be inside of table row.");
      for (let z = 0; z < K.length; z++) {
        const ie = K[z];
        if (!vt.$isTableRowNode(ie))
          throw new Error("Expected table row");
        const q = ie.getChildren();
        if (te >= q.length)
          continue;
        const Y = q[te];
        if (!vt.$isTableCellNode(Y))
          throw new Error("Expected table cell");
        Y.toggleHeaderStyle(vt.TableCellHeaderStates.COLUMN);
      }
      D(), r();
    });
  }, [m, O, D, r]), Z = Vt(
    (ne) => {
      m.update(() => {
        const te = fe.$getSelection();
        if (fe.$isRangeSelection(te) || vt.$isTableSelection(te)) {
          const [K] = vt.$getNodeTriplet(te.anchor);
          if (vt.$isTableCellNode(K) && K.setBackgroundColor(ne), vt.$isTableSelection(te)) {
            const A = te.getNodes();
            for (let z = 0; z < A.length; z++) {
              const ie = A[z];
              vt.$isTableCellNode(ie) && ie.setBackgroundColor(ne);
            }
          }
        }
      });
    },
    [m]
  );
  let oe = null;
  return u && (y ? oe = /* @__PURE__ */ U.jsx(
    "button",
    {
      type: "button",
      className: "item",
      onClick: () => C(),
      "data-test-id": "table-merge-cells",
      children: "Merge cells"
    }
  ) : _ && (oe = /* @__PURE__ */ U.jsx(
    "button",
    {
      type: "button",
      className: "item",
      onClick: () => x(),
      "data-test-id": "table-unmerge-cells",
      children: "Unmerge cells"
    }
  ))), Bo(
    /* @__PURE__ */ U.jsxs(
      "div",
      {
        className: "dropdown",
        ref: f,
        onClick: (ne) => {
          ne.stopPropagation();
        },
        children: [
          oe,
          /* @__PURE__ */ U.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => p("Cell background color", () => /* @__PURE__ */ U.jsx(
                lh,
                {
                  color: w,
                  onChange: Z
                }
              )),
              "data-test-id": "table-background-color",
              children: /* @__PURE__ */ U.jsx("span", { className: "text", children: "Background color" })
            }
          ),
          /* @__PURE__ */ U.jsx("hr", {}),
          /* @__PURE__ */ U.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => I(!1),
              "data-test-id": "table-insert-row-above",
              children: /* @__PURE__ */ U.jsxs("span", { className: "text", children: [
                "Insert",
                " ",
                E.rows === 1 ? "row" : `${E.rows} rows`,
                " ",
                "above"
              ] })
            }
          ),
          /* @__PURE__ */ U.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => I(!0),
              "data-test-id": "table-insert-row-below",
              children: /* @__PURE__ */ U.jsxs("span", { className: "text", children: [
                "Insert",
                " ",
                E.rows === 1 ? "row" : `${E.rows} rows`,
                " ",
                "below"
              ] })
            }
          ),
          /* @__PURE__ */ U.jsx("hr", {}),
          /* @__PURE__ */ U.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => W(!1),
              "data-test-id": "table-insert-column-before",
              children: /* @__PURE__ */ U.jsxs("span", { className: "text", children: [
                "Insert",
                " ",
                E.columns === 1 ? "column" : `${E.columns} columns`,
                " ",
                "left"
              ] })
            }
          ),
          /* @__PURE__ */ U.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => W(!0),
              "data-test-id": "table-insert-column-after",
              children: /* @__PURE__ */ U.jsxs("span", { className: "text", children: [
                "Insert",
                " ",
                E.columns === 1 ? "column" : `${E.columns} columns`,
                " ",
                "right"
              ] })
            }
          ),
          /* @__PURE__ */ U.jsx("hr", {}),
          /* @__PURE__ */ U.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => L(),
              "data-test-id": "table-delete-columns",
              children: /* @__PURE__ */ U.jsx("span", { className: "text", children: "Delete column" })
            }
          ),
          /* @__PURE__ */ U.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => $(),
              "data-test-id": "table-delete-rows",
              children: /* @__PURE__ */ U.jsx("span", { className: "text", children: "Delete row" })
            }
          ),
          /* @__PURE__ */ U.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => B(),
              "data-test-id": "table-delete",
              children: /* @__PURE__ */ U.jsx("span", { className: "text", children: "Delete table" })
            }
          ),
          /* @__PURE__ */ U.jsx("hr", {}),
          /* @__PURE__ */ U.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => P(),
              children: /* @__PURE__ */ U.jsxs("span", { className: "text", children: [
                (O.__headerState & vt.TableCellHeaderStates.ROW) === vt.TableCellHeaderStates.ROW ? "Remove" : "Add",
                " ",
                "row header"
              ] })
            }
          ),
          /* @__PURE__ */ U.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => F(),
              "data-test-id": "table-column-header",
              children: /* @__PURE__ */ U.jsxs("span", { className: "text", children: [
                (O.__headerState & vt.TableCellHeaderStates.COLUMN) === vt.TableCellHeaderStates.COLUMN ? "Remove" : "Add",
                " ",
                "column header"
              ] })
            }
          )
        ]
      }
    ),
    document.body
  );
}
function ax({
  anchorElem: r,
  cellMerge: n
}) {
  const [t] = gn.useLexicalComposerContext(), o = Cn(null), u = Cn(null), [p, m] = ut(!1), [f, O] = ut(
    null
  ), [S, E] = ba(), R = Vt(() => {
    const g = o.current, _ = fe.$getSelection(), N = window.getSelection(), w = document.activeElement;
    if (_ == null || g == null) {
      O(null);
      return;
    }
    const T = t.getRootElement();
    if (fe.$isRangeSelection(_) && T !== null && N !== null && T.contains(N.anchorNode)) {
      const D = vt.$getTableCellNodeFromLexicalNode(
        _.anchor.getNode()
      );
      if (D == null) {
        O(null);
        return;
      }
      if (t.getElementByKey(
        D.getKey()
      ) == null) {
        O(null);
        return;
      }
      O(D);
    } else
      w || O(null);
  }, [t]);
  yt(() => t.registerUpdateListener(() => {
    t.getEditorState().read(() => {
      R();
    });
  })), yt(() => {
    const g = o.current;
    if (g != null && f != null) {
      const _ = t.getElementByKey(f.getKey());
      if (_ != null) {
        const N = _.getBoundingClientRect(), w = g.getBoundingClientRect(), T = r.getBoundingClientRect(), D = N.top - T.top + 4, C = N.right - w.width - 10 - T.left;
        g.style.opacity = "1", g.style.transform = `translate(${C}px, ${D}px)`;
      } else
        g.style.opacity = "0", g.style.transform = "translate(-10000px, -10000px)";
    }
  }, [o, f, t, r]);
  const y = Cn(f);
  return yt(() => {
    y.current !== f && m(!1), y.current = f;
  }, [y, f]), /* @__PURE__ */ U.jsx("div", { className: "table-cell-action-button-container", ref: o, children: f != null && /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    /* @__PURE__ */ U.jsx(
      "button",
      {
        type: "button",
        className: "table-cell-action-button chevron-down",
        onClick: (g) => {
          g.stopPropagation(), m(!p);
        },
        ref: u,
        children: /* @__PURE__ */ U.jsx("i", { className: "chevron-down" })
      }
    ),
    S,
    p && /* @__PURE__ */ U.jsx(
      lx,
      {
        contextRef: u,
        setIsMenuOpen: m,
        onClose: () => m(!1),
        tableCellNode: f,
        cellMerge: n,
        showColorPickerModal: E
      }
    )
  ] }) });
}
function cx({
  anchorElem: r = document.body,
  cellMerge: n = !1
}) {
  const t = vh();
  return Bo(
    t ? /* @__PURE__ */ U.jsx(
      ax,
      {
        anchorElem: r,
        cellMerge: n
      }
    ) : null,
    r
  );
}
const yg = [
  "image/",
  "image/heic",
  "image/heif",
  "image/gif",
  "image/webp"
];
function ux() {
  const [r] = gn.useLexicalComposerContext();
  return yt(() => r.registerCommand(
    Tr.DRAG_DROP_PASTE,
    (n) => ((async () => {
      const t = await Jt.mediaFileReader(
        n,
        [yg].flatMap((o) => o)
      );
      for (const { file: o, result: u } of t)
        Jt.isMimeType(o, yg) && r.dispatchCommand(Sl, {
          altText: o.name,
          src: u
        });
    })(), !0),
    fe.COMMAND_PRIORITY_LOW
  ), [r]), null;
}
class dx extends Fo.MenuOption {
  constructor(t, o, u) {
    super(t);
    Tt(this, "title");
    Tt(this, "emoji");
    Tt(this, "keywords");
    this.title = t, this.emoji = o, this.keywords = u.keywords || [];
  }
}
function fx({
  index: r,
  isSelected: n,
  onClick: t,
  onMouseEnter: o,
  option: u
}) {
  let p = "item";
  return n && (p += " selected"), /* @__PURE__ */ U.jsx(
    "li",
    {
      tabIndex: -1,
      className: p,
      ref: u.setRefElement,
      role: "option",
      "aria-selected": n,
      id: "typeahead-item-" + r,
      onMouseEnter: o,
      onClick: t,
      children: /* @__PURE__ */ U.jsxs("span", { className: "text", children: [
        u.emoji,
        " ",
        u.title
      ] })
    },
    u.key
  );
}
const gx = 10;
function hx() {
  const [r] = gn.useLexicalComposerContext(), [n, t] = ut(null), [o, u] = ut([]);
  yt(() => {
    import("./emoji-list-CKk-PE96.js").then((S) => u(S.default));
  }, []);
  const p = Zr(
    () => o != null ? o.map(
      ({ emoji: S, aliases: E, tags: R }) => new dx(E[0], S, {
        keywords: [...E, ...R]
      })
    ) : [],
    [o]
  ), m = Fo.useBasicTypeaheadTriggerMatch(":", {
    minLength: 0
  }), f = Zr(() => p.filter((S) => n != null ? new RegExp(n, "gi").exec(S.title) || S.keywords != null ? S.keywords.some(
    (E) => new RegExp(n, "gi").exec(E)
  ) : !1 : p).slice(0, gx), [p, n]), O = Vt(
    (S, E, R) => {
      r.update(() => {
        const y = fe.$getSelection();
        !fe.$isRangeSelection(y) || S == null || (E && E.remove(), y.insertNodes([fe.$createTextNode(S.emoji)]), R());
      });
    },
    [r]
  );
  return /* @__PURE__ */ U.jsx(
    Fo.LexicalTypeaheadMenuPlugin,
    {
      onQueryChange: t,
      onSelectOption: O,
      triggerFn: m,
      options: f,
      menuRenderFn: (S, { selectedIndex: E, selectOptionAndCleanUp: R, setHighlightedIndex: y }) => S.current == null || f.length === 0 ? null : S.current && f.length ? ml.createPortal(
        /* @__PURE__ */ U.jsx("div", { className: "typeahead-popover emoji-menu", children: /* @__PURE__ */ U.jsx("ul", { children: f.map((g, _) => /* @__PURE__ */ U.jsx("div", { children: /* @__PURE__ */ U.jsx(
          fx,
          {
            index: _,
            isSelected: E === _,
            onClick: () => {
              y(_), R(g);
            },
            onMouseEnter: () => {
              y(_);
            },
            option: g
          }
        ) }, g.key)) }) }),
        S.current
      ) : null
    }
  );
}
function Uc(r) {
  return r instanceof HTMLElement;
}
class wh {
  constructor(n, t) {
    Tt(this, "_x");
    Tt(this, "_y");
    this._x = n, this._y = t;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  equals({ x: n, y: t }) {
    return this.x === n && this.y === t;
  }
  calcDeltaXTo({ x: n }) {
    return this.x - n;
  }
  calcDeltaYTo({ y: n }) {
    return this.y - n;
  }
  calcHorizontalDistanceTo(n) {
    return Math.abs(this.calcDeltaXTo(n));
  }
  calcVerticalDistance(n) {
    return Math.abs(this.calcDeltaYTo(n));
  }
  calcDistanceTo(n) {
    return Math.sqrt(
      Math.pow(this.calcDeltaXTo(n), 2) + Math.pow(this.calcDeltaYTo(n), 2)
    );
  }
}
function px(r) {
  return r instanceof wh;
}
class Di {
  constructor(n, t, o, u) {
    Tt(this, "_left");
    Tt(this, "_top");
    Tt(this, "_right");
    Tt(this, "_bottom");
    const [p, m] = t <= u ? [t, u] : [u, t], [f, O] = n <= o ? [n, o] : [o, n];
    this._top = p, this._right = O, this._left = f, this._bottom = m;
  }
  get top() {
    return this._top;
  }
  get right() {
    return this._right;
  }
  get bottom() {
    return this._bottom;
  }
  get left() {
    return this._left;
  }
  get width() {
    return Math.abs(this._left - this._right);
  }
  get height() {
    return Math.abs(this._bottom - this._top);
  }
  equals({ top: n, left: t, bottom: o, right: u }) {
    return n === this._top && o === this._bottom && t === this._left && u === this._right;
  }
  contains(n) {
    if (px(n)) {
      const { x: t, y: o } = n, u = o < this._top, p = o > this._bottom, m = t < this._left, f = t > this._right;
      return {
        reason: {
          isOnBottomSide: p,
          isOnLeftSide: m,
          isOnRightSide: f,
          isOnTopSide: u
        },
        result: !u && !p && !m && !f
      };
    } else {
      const { top: t, left: o, bottom: u, right: p } = n;
      return t >= this._top && t <= this._bottom && u >= this._top && u <= this._bottom && o >= this._left && o <= this._right && p >= this._left && p <= this._right;
    }
  }
  intersectsWith(n) {
    const { left: t, top: o, width: u, height: p } = n, { left: m, top: f, width: O, height: S } = this, E = t + u >= m + O ? t + u : m + O, R = o + p >= f + S ? o + p : f + S, y = t <= m ? t : m, g = o <= f ? o : f;
    return E - y <= u + O && R - g <= p + S;
  }
  generateNewRect({
    left: n = this.left,
    top: t = this.top,
    right: o = this.right,
    bottom: u = this.bottom
  }) {
    return new Di(n, t, o, u);
  }
  static fromLTRB(n, t, o, u) {
    return new Di(n, t, o, u);
  }
  static fromLWTH(n, t, o, u) {
    return new Di(n, o, n + t, o + u);
  }
  static fromPoints(n, t) {
    const { y: o, x: u } = n, { y: p, x: m } = t;
    return Di.fromLTRB(u, o, m, p);
  }
  static fromDOM(n) {
    const { top: t, width: o, left: u, height: p } = n.getBoundingClientRect();
    return Di.fromLWTH(u, o, t, p);
  }
}
const tu = 4, mx = 2, _x = "draggable-block-menu", Sg = "application/x-lexical-drag-block", Og = 28, Nx = 1, Cx = -1, vg = 0;
let Sa = 1 / 0;
function xx(r) {
  return r === 0 ? 1 / 0 : Sa >= 0 && Sa < r ? Sa : Math.floor(r / 2);
}
function Ex(r) {
  return r.getEditorState().read(() => fe.$getRoot().getChildrenKeys());
}
function Mh(r) {
  const n = (O, S) => O ? parseFloat(window.getComputedStyle(O)[S]) : 0, { marginTop: t, marginBottom: o } = window.getComputedStyle(r), u = n(
    r.previousElementSibling,
    "marginBottom"
  ), p = n(
    r.nextElementSibling,
    "marginTop"
  ), m = Math.max(
    parseFloat(t),
    u
  );
  return { marginBottom: Math.max(
    parseFloat(o),
    p
  ), marginTop: m };
}
function Yc(r, n, t, o = !1) {
  const u = r.getBoundingClientRect(), p = Ex(n);
  let m = null;
  return n.getEditorState().read(() => {
    if (o) {
      const [S, E] = [
        n.getElementByKey(p[0]),
        n.getElementByKey(p[p.length - 1])
      ], [R, y] = [
        S == null ? void 0 : S.getBoundingClientRect(),
        E == null ? void 0 : E.getBoundingClientRect()
      ];
      if (R && y && (t.y < R.top ? m = S : t.y > y.bottom && (m = E), m))
        return;
    }
    let f = xx(p.length), O = vg;
    for (; f >= 0 && f < p.length; ) {
      const S = p[f], E = n.getElementByKey(S);
      if (E === null)
        break;
      const R = new wh(t.x, t.y), y = Di.fromDOM(E), { marginTop: g, marginBottom: _ } = Mh(E), N = y.generateNewRect({
        bottom: y.bottom + _,
        left: u.left,
        right: u.right,
        top: y.top - g
      }), {
        result: w,
        reason: { isOnTopSide: T, isOnBottomSide: D }
      } = N.contains(R);
      if (w) {
        m = E, Sa = f;
        break;
      }
      O === vg && (T ? O = Cx : D ? O = Nx : O = 1 / 0), f += O;
    }
  }), m;
}
function Tx(r) {
  return !!r.closest(`.${_x}`);
}
function yx(r, n, t) {
  if (!r) {
    n.style.opacity = "0", n.style.transform = "translate(-10000px, -10000px)";
    return;
  }
  const o = r.getBoundingClientRect(), u = window.getComputedStyle(r), p = n.getBoundingClientRect(), m = t.getBoundingClientRect(), f = o.top + (parseInt(u.lineHeight, 10) - p.height) / 2 - m.top, O = tu;
  n.style.opacity = "1", n.style.transform = `translate(${O}px, ${f}px)`;
}
function Sx(r, n) {
  const { transform: t } = n.style;
  n.style.transform = "translateZ(0)", r.setDragImage(n, 0, 0), setTimeout(() => {
    n.style.transform = t;
  });
}
function Ox(r, n, t, o) {
  const { top: u, height: p } = n.getBoundingClientRect(), { top: m, width: f } = o.getBoundingClientRect(), { marginTop: O, marginBottom: S } = Mh(n);
  let E = u;
  t >= u ? E += p + S / 2 : E -= O / 2;
  const R = E - m - mx, y = Og - tu;
  r.style.transform = `translate(${y}px, ${R}px)`, r.style.width = `${f - (Og - tu) * 2}px`, r.style.opacity = ".4";
}
function vx(r) {
  r && (r.style.opacity = "0", r.style.transform = "translate(-10000px, -10000px)");
}
function wx(r, n, t) {
  const o = n.parentElement, u = Cn(null), p = Cn(null), m = Cn(!1), [f, O] = ut(null);
  yt(() => {
    function R(g) {
      const _ = g.target;
      if (!Uc(_)) {
        O(null);
        return;
      }
      if (Tx(_))
        return;
      const N = Yc(n, r, g);
      O(N);
    }
    function y() {
      O(null);
    }
    return o == null || o.addEventListener("mousemove", R), o == null || o.addEventListener("mouseleave", y), () => {
      o == null || o.removeEventListener("mousemove", R), o == null || o.removeEventListener("mouseleave", y);
    };
  }, [o, n, r]), yt(() => {
    u.current && yx(f, u.current, n);
  }, [n, f]), yt(() => {
    function R(g) {
      if (!m.current)
        return !1;
      const [_] = Tr.eventFiles(g);
      if (_)
        return !1;
      const { pageY: N, target: w } = g;
      if (!Uc(w))
        return !1;
      const T = Yc(n, r, g, !0), D = p.current;
      return T === null || D === null ? !1 : (Ox(D, T, N, n), g.preventDefault(), !0);
    }
    function y(g) {
      if (!m.current)
        return !1;
      const [_] = Tr.eventFiles(g);
      if (_)
        return !1;
      const { target: N, dataTransfer: w, pageY: T } = g, D = (w == null ? void 0 : w.getData(Sg)) || "", C = fe.$getNodeByKey(D);
      if (!C || !Uc(N))
        return !1;
      const x = Yc(n, r, g, !0);
      if (!x)
        return !1;
      const I = fe.$getNearestNodeFromDOMNode(x);
      if (!I)
        return !1;
      if (I === C)
        return !0;
      const W = x.getBoundingClientRect().top;
      return T >= W ? I.insertAfter(C) : I.insertBefore(C), O(null), !0;
    }
    return Jt.mergeRegister(
      r.registerCommand(
        fe.DRAGOVER_COMMAND,
        (g) => R(g),
        fe.COMMAND_PRIORITY_LOW
      ),
      r.registerCommand(
        fe.DROP_COMMAND,
        (g) => y(g),
        fe.COMMAND_PRIORITY_HIGH
      )
    );
  }, [n, r]);
  function S(R) {
    const y = R.dataTransfer;
    if (!y || !f)
      return;
    Sx(y, f);
    let g = "";
    r.update(() => {
      const _ = fe.$getNearestNodeFromDOMNode(f);
      _ && (g = _.getKey());
    }), m.current = !0, y.setData(Sg, g);
  }
  function E() {
    m.current = !1, vx(p.current);
  }
  return Bo(
    /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
      /* @__PURE__ */ U.jsx(
        "div",
        {
          className: "icon draggable-block-menu",
          ref: u,
          draggable: !0,
          onDragStart: S,
          onDragEnd: E,
          children: /* @__PURE__ */ U.jsx("div", { className: t ? "icon" : "" })
        }
      ),
      /* @__PURE__ */ U.jsx("div", { className: "draggable-block-target-line", ref: p })
    ] }),
    n
  );
}
function Mx({
  anchorElem: r = document.body
}) {
  const [n] = gn.useLexicalComposerContext();
  return wx(n, r, n._editable);
}
const Rx = $t.lazy(() => import("./DataMentionComponent-CYf7c3UN.js"));
function bx(r) {
  const n = r.getAttribute("data-mention-data"), t = r.getAttribute("data-mention-type"), o = r.getAttribute("data-mention-field"), u = r.getAttribute("data-mention-label"), p = r.getAttribute("data-mention-step");
  return t !== null && o !== null && u !== null && p !== null ? {
    node: Ma({ dataMention: t, fieldName: o, label: u, data: n, step: parseInt(p) })
  } : null;
}
class _l extends fe.DecoratorNode {
  constructor(t, o, u, p, m, f, O) {
    super(O);
    Tt(this, "__dataMention");
    Tt(this, "__fieldName");
    Tt(this, "__label");
    Tt(this, "__value");
    Tt(this, "__data");
    Tt(this, "__step");
    Tt(this, "defaultStep", 1);
    this.__dataMention = t, this.__fieldName = o, this.__label = u, this.__value = m, this.__data = p, this.__step = f || this.defaultStep;
  }
  static getType() {
    return "data-mention";
  }
  static clone(t) {
    return new _l(
      t.__dataMention,
      t.__fieldName,
      t.__label,
      t.__data,
      t.__value,
      t.__step,
      t.__key
    );
  }
  static importJSON(t) {
    const {
      dataMention: o,
      fieldName: u,
      label: p,
      data: m,
      value: f
    } = t, O = Ma({ dataMention: o, fieldName: u, label: p, data: m, step: this.prototype.defaultStep });
    if (o === "input" && O.__value) {
      const S = O.__value;
      if (f) {
        const E = S.parseEditorState(f.editorState);
        E.isEmpty() || S.setEditorState(E);
      }
    }
    return O;
  }
  exportDOM() {
    var o;
    const t = document.createElement("span");
    return t.setAttribute("data-mention-type", this.__dataMention), t.setAttribute("data-mention-step", this.__step.toString()), t.setAttribute("data-mention-field", this.__fieldName), t.setAttribute("data-mention-label", this.__label), t.setAttribute("data-lexical-data-mention", "true"), t.setAttribute("data-mention-data", ((o = this.__data) == null ? void 0 : o.toString()) || ""), { element: t };
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return {
      span: (t) => t.hasAttribute("data-lexical-data-mention") ? {
        conversion: bx,
        priority: 1
      } : null
    };
  }
  exportJSON() {
    return {
      dataMention: this.__dataMention,
      fieldName: this.__fieldName,
      label: this.__label,
      value: this.__value && this.__value.toJSON(),
      data: this.__data,
      version: 1,
      type: "data-mention"
    };
  }
  createDOM(t) {
    var m;
    const o = document.createElement("span");
    o.setAttribute("data-mention-type", this.__dataMention), o.setAttribute("data-mention-step", this.__step.toString()), o.setAttribute("data-mention-field", this.__fieldName), o.setAttribute("data-mention-label", this.__label), o.setAttribute("data-lexical-data-mention", "true"), o.setAttribute("data-mention-data", ((m = this.__data) == null ? void 0 : m.toString()) || "");
    const p = t.theme.dataMention;
    return p !== void 0 && (o.className = p), o;
  }
  setData(t) {
    const o = this.getWritable();
    o.__data = t;
  }
  decorate() {
    return /* @__PURE__ */ U.jsx(Ki, { fallback: null, children: /* @__PURE__ */ U.jsx(
      Rx,
      {
        dataMention: this.__dataMention,
        label: this.__label,
        value: this.__value,
        data: this.__data,
        step: this.__step
      }
    ) });
  }
}
const Ma = ({ dataMention: r, fieldName: n, label: t, data: o, value: u, step: p }) => {
  !u && r === "input" && (u = fe.createEditor());
  const m = new _l(r, n, t, o, u, p);
  return fe.$applyNodeReplacement(m);
}, Rh = `\\.,\\+\\*\\?\\$\\@\\|#{}\\(\\)\\^\\-\\[\\]\\\\/!%'"~=<>_:;`, Ax = "\\b[A-Z][^\\s" + Rh + "]", Dx = {
  NAME: Ax,
  PUNCTUATION: Rh
}, bh = Dx.PUNCTUATION, Eu = ["=\\$a", "=\\$i", "=\\$f"].join("|"), pl = "=$a", Lx = "=$i", Ix = "=$f", Ah = "^(" + Eu + ")\\s|[^" + bh + "\\s]", $x = "(?:\\.[ |$]| |[" + bh + "]|)", kx = 75, Px = new RegExp(
  "(^|\\s|\\()((" + Eu + ")((?:" + Ah + $x + "){0," + kx + "}))$"
), Fx = 50, Bx = new RegExp(
  "(^|\\s|\\()((" + Eu + ")((?:" + Ah + "){0," + Fx + "}))$"
), Kx = 5, jx = [
  {
    inputField: {
      label: "Create a new input",
      value: null
    }
  }
], zc = /* @__PURE__ */ new Map(), Hx = {
  search(r, n, t) {
    setTimeout(() => {
      const o = n.filter(
        (u) => Object.keys(u).filter((p) => u[p].label.toLowerCase().includes(r.toLowerCase())).length > 0
      );
      t(o);
    }, 300);
  }
};
function Wx(r, n, t = "") {
  const [o, u] = ut([]);
  return yt(() => {
    const p = zc.get(t + r);
    if (r == null) {
      u([]);
      return;
    }
    if (p !== null) {
      if (p !== void 0) {
        u(p);
        return;
      }
      zc.set(t + r, null), Hx.search(r, n, (m) => {
        zc.set(t + r, m), u(m);
      });
    }
  }, [r, n, t]), o;
}
function Ux(r, n) {
  let t = Px.exec(r);
  if (t === null && (t = Bx.exec(r)), t !== null) {
    const o = t[1], u = t[4];
    if (u.length >= n)
      return {
        leadOffset: t.index + o.length,
        matchingString: u,
        replaceableString: t[3]
      };
  }
  return null;
}
function Yx(r) {
  return Ux(r, 0);
}
class zx extends Fo.MenuOption {
  constructor(t, o, u, p) {
    super(t + u);
    Tt(this, "dataMention");
    Tt(this, "fieldName");
    Tt(this, "label");
    Tt(this, "data");
    this.dataMention = t, this.fieldName = o, this.label = u, this.data = p;
  }
}
function qx({
  index: r,
  isSelected: n,
  onClick: t,
  onMouseEnter: o,
  option: u
}) {
  let p = "item";
  return n && (p += " selected"), /* @__PURE__ */ U.jsx(
    "li",
    {
      tabIndex: -1,
      className: p,
      ref: u.setRefElement,
      role: "option",
      "aria-selected": n,
      id: "typeahead-item-" + r,
      onMouseEnter: o,
      onClick: t,
      children: /* @__PURE__ */ U.jsx("span", { className: "text", children: u.label })
    },
    u.key
  );
}
function Gx({
  step: r,
  autoData: n,
  afterAutoData: t
}) {
  const [o] = gn.useLexicalComposerContext(), [u, p] = ut(null), [m, f] = ut(), [O, S] = ut(), [E, R] = ut(!1), [y, g] = ut(null), N = Wx(u, m === pl ? n : m === Ix ? t : jx, m), w = Fo.useBasicTypeaheadTriggerMatch("/", {
    minLength: 0
  }), T = Zr(
    () => N.map(
      (x) => {
        const I = Object.keys(x)[0];
        return new zx(m === pl ? "auto" : "after-auto", I, x[I].label, x[I].value);
      }
    ).slice(0, Kx),
    [N]
  ), D = Vt(
    (x, I, W) => {
      if (x.fieldName === "inputField") {
        R(!0), g({ nodeToReplace: I, selectedOption: x }), W();
        return;
      }
      o.update(() => {
        console.log(m, pl, m === pl);
        const $ = Ma(
          {
            dataMention: m === pl ? "auto" : m == Lx ? "input" : "after-auto",
            fieldName: x.fieldName,
            label: x.label,
            data: x.data
          }
        );
        I && I.replace($), W();
      });
    },
    [o, m]
  ), C = Vt(
    (x) => {
      if (w(x, o) !== null)
        return null;
      const W = Yx(x);
      return W !== null && f(W.replaceableString), W;
    },
    [w, o]
  );
  return yt(() => {
    r === 2 && o.registerCommand(
      fe.SELECTION_CHANGE_COMMAND,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      (x, I) => {
        var W, $;
        return ((W = I.getRootElement()) == null ? void 0 : W.className) === "DataMention__contentEditable" && !o.isEditable() ? (o.setEditable(!0), I.focus()) : (($ = I.getRootElement()) == null ? void 0 : $.className) !== "DataMention__contentEditable" && o.isEditable() && o.setEditable(!1), !0;
      },
      fe.COMMAND_PRIORITY_LOW
    );
  }, [r, o]), /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    /* @__PURE__ */ U.jsx(
      Fo.LexicalTypeaheadMenuPlugin,
      {
        onQueryChange: p,
        onSelectOption: D,
        triggerFn: C,
        options: T,
        menuRenderFn: (x, { selectedIndex: I, selectOptionAndCleanUp: W, setHighlightedIndex: $ }) => x.current && N.length ? ml.createPortal(
          /* @__PURE__ */ U.jsx("div", { className: "typeahead-popover mentions-menu", children: /* @__PURE__ */ U.jsx("ul", { children: T.map((B, L) => /* @__PURE__ */ U.jsx(
            qx,
            {
              index: L,
              isSelected: I === L,
              onClick: () => {
                $(L), W(B);
              },
              onMouseEnter: () => {
                $(L);
              },
              option: B
            },
            B.key
          )) }) }),
          x.current
        ) : null
      }
    ),
    E && y && ml.createPortal(
      /* @__PURE__ */ U.jsxs("div", { className: "data-mention-input-modal", children: [
        /* @__PURE__ */ U.jsx(
          "input",
          {
            placeholder: "Enter label of input field",
            value: O || "",
            type: "text",
            onChange: (x) => {
              S(x.target.value);
            }
          }
        ),
        /* @__PURE__ */ U.jsx("button", { onClick: () => {
          o.update(() => {
            const x = Ma(
              {
                dataMention: "input",
                fieldName: y.selectedOption.fieldName,
                label: O || "Empty",
                data: null
              }
            );
            y.nodeToReplace && y.nodeToReplace.replace(x), R(!1), g(null);
          });
        }, children: "Save" })
      ] }),
      document.body
    )
  ] });
}
var qc = {}, wg;
function Vx() {
  if (wg)
    return qc;
  wg = 1;
  var r = zt(), n = $t, u = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? n.useLayoutEffect : n.useEffect;
  function p({
    ignoreHistoryMergeTagChange: m = !0,
    ignoreSelectionChange: f = !1,
    onChange: O
  }) {
    const [S] = r.useLexicalComposerContext();
    return u(() => {
      if (O)
        return S.registerUpdateListener(({
          editorState: E,
          dirtyElements: R,
          dirtyLeaves: y,
          prevEditorState: g,
          tags: _
        }) => {
          f && R.size === 0 && y.size === 0 || m && _.has("history-merge") || g.isEmpty() || O(E, S, _);
        });
    }, [S, m, f, O]), null;
  }
  return qc.OnChangePlugin = p, qc;
}
var Gc = {}, Mg;
function Jx() {
  if (Mg)
    return Gc;
  Mg = 1;
  var r = zt(), n = $t, t = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? n.useLayoutEffect : n.useEffect;
  return Gc.OnChangePlugin = function({ ignoreHistoryMergeTagChange: o = !0, ignoreSelectionChange: u = !1, onChange: p }) {
    let [m] = r.useLexicalComposerContext();
    return t(() => {
      if (p)
        return m.registerUpdateListener(({ editorState: f, dirtyElements: O, dirtyLeaves: S, prevEditorState: E, tags: R }) => {
          u && O.size === 0 && S.size === 0 || o && R.has("history-merge") || E.isEmpty() || p(f, m, R);
        });
    }, [m, o, u, p]), null;
  }, Gc;
}
const Xx = process.env.NODE_ENV === "development" ? Vx() : Jx();
var Zx = Xx;
function Qx(r) {
  const { step: n, autoMentionData: t, autoAfterMentionData: o, onChange: u = () => {
  } } = r, { historyState: p } = Qm(), m = /* @__PURE__ */ U.jsx(w_, { children: "Enter text..." }), [f, O] = ut(null), [S, E] = ut(!1), [R, y] = ut(!1), g = (_) => {
    _ !== null && O(_);
  };
  return yt(() => {
    const _ = () => {
      const N = Is && window.matchMedia("(max-width: 1025px)").matches;
      N !== S && E(N);
    };
    return _(), window.addEventListener("resize", _), () => {
      window.removeEventListener("resize", _);
    };
  }, [S]), /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
    /* @__PURE__ */ U.jsx(zN, { setIsLinkEditMode: y }),
    /* @__PURE__ */ U.jsxs("div", { className: "editor-container", children: [
      /* @__PURE__ */ U.jsx(ux, {}),
      /* @__PURE__ */ U.jsx(N_.AutoFocusPlugin, {}),
      /* @__PURE__ */ U.jsx(jC, {}),
      /* @__PURE__ */ U.jsx(hx, {}),
      /* @__PURE__ */ U.jsx(KN, {}),
      /* @__PURE__ */ U.jsx(Gx, { step: n, autoData: t, afterAutoData: o }),
      /* @__PURE__ */ U.jsx(IC, {}),
      /* @__PURE__ */ U.jsx(bC, {}),
      /* @__PURE__ */ U.jsx(Zx.OnChangePlugin, { ignoreSelectionChange: !0, onChange: u }),
      /* @__PURE__ */ U.jsx(rh.HistoryPlugin, { externalHistoryState: p }),
      /* @__PURE__ */ U.jsx(CC, {}),
      /* @__PURE__ */ U.jsx(
        c_.RichTextPlugin,
        {
          contentEditable: /* @__PURE__ */ U.jsx("div", { className: "editor-scroller", children: /* @__PURE__ */ U.jsx("div", { className: "editor", ref: g, children: /* @__PURE__ */ U.jsx(D_, {}) }) }),
          placeholder: m,
          ErrorBoundary: h_
        }
      ),
      /* @__PURE__ */ U.jsx(JN.ListPlugin, {}),
      /* @__PURE__ */ U.jsx(eC.CheckListPlugin, {}),
      /* @__PURE__ */ U.jsx(rC, { maxDepth: 7 }),
      /* @__PURE__ */ U.jsx(
        ZC.TablePlugin,
        {
          hasCellMerge: !0,
          hasCellBackgroundColor: !0
        }
      ),
      /* @__PURE__ */ U.jsx(rx, {}),
      /* @__PURE__ */ U.jsx(G_, {}),
      /* @__PURE__ */ U.jsx(sN, {}),
      /* @__PURE__ */ U.jsx(SC, {}),
      /* @__PURE__ */ U.jsx(pN, {}),
      /* @__PURE__ */ U.jsx(AN, {}),
      /* @__PURE__ */ U.jsx(DN, {}),
      /* @__PURE__ */ U.jsx(bN, {}),
      /* @__PURE__ */ U.jsx(v_.HorizontalRulePlugin, {}),
      /* @__PURE__ */ U.jsx(yN, {}),
      /* @__PURE__ */ U.jsx(gN, {}),
      /* @__PURE__ */ U.jsx(lC, {}),
      /* @__PURE__ */ U.jsx(T_.TabIndentationPlugin, {}),
      /* @__PURE__ */ U.jsx(SN, {}),
      /* @__PURE__ */ U.jsx(H_, {}),
      /* @__PURE__ */ U.jsx(_N, {}),
      f && !S && /* @__PURE__ */ U.jsxs(U.Fragment, { children: [
        /* @__PURE__ */ U.jsx(
          Mx,
          {
            anchorElem: f
          }
        ),
        /* @__PURE__ */ U.jsx(
          fC,
          {
            anchorElem: f,
            isLinkEditMode: R,
            setIsLinkEditMode: y
          }
        ),
        /* @__PURE__ */ U.jsx(
          GC,
          {
            anchorElem: f
          }
        ),
        /* @__PURE__ */ U.jsx(
          cx,
          {
            anchorElem: f,
            cellMerge: !0
          }
        )
      ] })
    ] })
  ] });
}
function aE(r) {
  const {
    editorState: n,
    historyState: t,
    onChange: o,
    autoAfterMentionData: u = [],
    autoMentionData: p = [],
    step: m = 1
  } = r;
  _l.prototype.defaultStep = m;
  const f = {
    editorState: n,
    namespace: "Doc App",
    editable: m === 1,
    theme: vp,
    onError: (O) => {
      console.log("Error:", O.message);
    },
    nodes: [...zm, _l]
  };
  return /* @__PURE__ */ U.jsx(Op.LexicalComposer, { initialConfig: f, children: /* @__PURE__ */ U.jsx(Zm, { initHistoryState: t, children: /* @__PURE__ */ U.jsx("div", { className: "editor-shell", children: /* @__PURE__ */ U.jsx(Qx, { step: m, autoAfterMentionData: u, autoMentionData: p, onChange: o }) }) }) });
}
export {
  Cm as $,
  St as A,
  po as B,
  gu as C,
  $s as D,
  IC as E,
  GC as F,
  Ra as G,
  ih as H,
  Is as I,
  vp as J,
  bC as K,
  N_ as L,
  nN as M,
  D_ as N,
  lE as O,
  w_ as P,
  aE as Q,
  rN as S,
  di as T,
  SC as a,
  rh as b,
  c_ as c,
  A_ as d,
  h_ as e,
  gm as f,
  gn as g,
  fe as h,
  Jt as i,
  U as j,
  Pp as k,
  MC as l,
  oE as m,
  xN as n,
  EN as o,
  iE as p,
  sE as q,
  zt as r,
  U_ as s,
  mf as t,
  Qm as u,
  ba as v,
  Wm as w,
  Vg as x,
  Ko as y,
  kt as z
};
