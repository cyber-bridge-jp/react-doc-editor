var kO = Object.defineProperty;
var CO = (e, t, n) => t in e ? kO(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Ne = (e, t, n) => CO(e, typeof t != "symbol" ? t + "" : t, n);
import { jsx as m, jsxs as D, Fragment as ge } from "react/jsx-runtime";
import * as J from "react";
import pe, { useContext as Er, createContext as Ci, useMemo as Ke, useLayoutEffect as Bn, useEffect as Y, useState as Q, useCallback as he, Suspense as td, useRef as de, forwardRef as dn, useReducer as lk, useDebugValue as MO, createElement as zt, Children as Ir, isValidElement as Yi, cloneElement as nd, Fragment as lg, version as TO, useImperativeHandle as y3, memo as D0, useDeferredValue as IO } from "react";
import * as _c from "react-dom";
import AO, { createPortal as fi, flushSync as ga, unstable_batchedUpdates as w3 } from "react-dom";
function NO(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var DO = NO(function(e) {
  const t = new URLSearchParams();
  t.append("code", e);
  for (let n = 1; n < arguments.length; n++) t.append("v", arguments[n]);
  throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
});
const sk = Ci(null);
function LO(e, t) {
  let n = null;
  return e != null && (n = e[1]), { getTheme: function() {
    return t ?? (n != null ? n.getTheme() : null);
  } };
}
function Fe() {
  const e = Er(sk);
  return e == null && DO(8), e;
}
function xn(e) {
  return {};
}
const Ei = {}, ok = {}, L0 = {}, ls = {}, Gd = {}, kc = {}, gc = {}, sg = {}, Z5 = {}, i0 = {}, Cc = {}, Mn = {}, og = {}, cg = {}, RO = {}, pf = {}, PO = {}, R0 = {}, OO = {}, Io = {}, Ao = {}, a0 = {}, ck = {}, P0 = {}, rd = {}, O0 = {}, mf = {}, dk = {}, dg = {}, Pp = {}, gf = {}, il = {}, ug = {}, bf = {}, $O = {}, hg = {}, fg = {}, J5 = {}, FO = {}, zO = {}, Ru = {}, Pu = {}, x3 = {}, BO = {}, uk = {}, Ba = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, HO = Ba && "documentMode" in document ? document.documentMode : null, da = Ba && /Mac|iPod|iPhone|iPad/.test(navigator.platform), so = Ba && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Op = !(!Ba || !("InputEvent" in window) || HO) && "getTargetRanges" in new window.InputEvent("input"), E3 = Ba && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), pg = Ba && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, WO = Ba && /Android/.test(navigator.userAgent), hk = Ba && /^(?=.*Chrome).*/i.test(navigator.userAgent), XO = Ba && WO && hk, S3 = Ba && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !hk, Uf = 1, No = 3, Mc = 0, fk = 1, l0 = 2, VO = 0, GO = 1, jO = 2, KO = 1, YO = 2, s0 = 4, o0 = 8, qO = 16, ZO = 32, JO = 64, mg = 128, QO = 112 | (3 | s0 | o0) | mg, _3 = 1, k3 = 2, C3 = 3, M3 = 4, T3 = 5, I3 = 6, gg = E3 || pg || S3 ? " " : "​", us = `

`, e$ = so ? " " : gg, pk = "֑-߿יִ-﷽ﹰ-ﻼ", mk = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", t$ = new RegExp("^[^" + mk + "]*[" + pk + "]"), n$ = new RegExp("^[^" + pk + "]*[" + mk + "]"), Mi = { bold: 1, code: 16, highlight: mg, italic: 2, strikethrough: s0, subscript: 32, superscript: 64, underline: o0 }, r$ = { directionless: 1, unmergeable: 2 }, S9 = { center: k3, end: I3, justify: M3, left: _3, right: C3, start: T3 }, i$ = { [k3]: "center", [I3]: "end", [M3]: "justify", [_3]: "left", [C3]: "right", [T3]: "start" }, a$ = { normal: 0, segmented: 2, token: 1 }, l$ = { [VO]: "normal", [jO]: "segmented", [GO]: "token" };
function s$(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ce = s$(function(e) {
  const t = new URLSearchParams();
  t.append("code", e);
  for (let n = 1; n < arguments.length; n++) t.append("v", arguments[n]);
  throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
});
function $p(...e) {
  const t = [];
  for (const n of e) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) t.push(r);
  return t;
}
const o$ = 100;
let Q5 = !1, A3 = 0;
function c$(e) {
  A3 = e.timeStamp;
}
function z2(e, t, n) {
  return t.__lexicalLineBreak === e || e[`__lexicalKey_${n._key}`] !== void 0;
}
function d$(e, t, n) {
  const r = wl(n._window);
  let i = null, a = null;
  r !== null && r.anchorNode === e && (i = r.anchorOffset, a = r.focusOffset);
  const l = e.nodeValue;
  l !== null && O3(t, l, i, a, !1);
}
function u$(e, t, n) {
  if (ie(e)) {
    const r = e.anchor.getNode();
    if (r.is(n) && e.format !== r.getFormat()) return !1;
  }
  return t.nodeType === No && n.isAttached();
}
function gk(e, t, n) {
  Q5 = !0;
  const r = performance.now() - A3 > o$;
  try {
    wi(e, () => {
      const i = se() || function(h) {
        return h.getEditorState().read(() => {
          const f = se();
          return f !== null ? f.clone() : null;
        });
      }(e), a = /* @__PURE__ */ new Map(), l = e.getRootElement(), s = e._editorState, c = e._blockCursorElement;
      let d = !1, o = "";
      for (let h = 0; h < t.length; h++) {
        const f = t[h], p = f.type, g = f.target;
        let b = on(g, s);
        if (!(b === null && g !== l || Ft(b))) {
          if (p === "characterData") r && ce(b) && u$(i, g, b) && d$(g, b, e);
          else if (p === "childList") {
            d = !0;
            const v = f.addedNodes;
            for (let w = 0; w < v.length; w++) {
              const x = v[w], E = wk(x), S = x.parentNode;
              if (S != null && x !== c && E === null && (x.nodeName !== "BR" || !z2(x, S, e))) {
                if (so) {
                  const _ = x.innerText || x.nodeValue;
                  _ && (o += _);
                }
                S.removeChild(x);
              }
            }
            const U = f.removedNodes, y = U.length;
            if (y > 0) {
              let w = 0;
              for (let x = 0; x < y; x++) {
                const E = U[x];
                (E.nodeName === "BR" && z2(E, g, e) || c === E) && (g.appendChild(E), w++);
              }
              y !== w && (g === l && (b = Ek(s)), a.set(g, b));
            }
          }
        }
      }
      if (a.size > 0) for (const [h, f] of a) if (re(f)) {
        const p = f.getChildrenKeys();
        let g = h.firstChild;
        for (let b = 0; b < p.length; b++) {
          const v = p[b], U = e.getElementByKey(v);
          U !== null && (g == null ? (h.appendChild(U), g = U) : g !== U && h.replaceChild(U, g), g = g.nextSibling);
        }
      } else ce(f) && f.markDirty();
      const u = n.takeRecords();
      if (u.length > 0) {
        for (let h = 0; h < u.length; h++) {
          const f = u[h], p = f.addedNodes, g = f.target;
          for (let b = 0; b < p.length; b++) {
            const v = p[b], U = v.parentNode;
            U == null || v.nodeName !== "BR" || z2(v, g, e) || U.removeChild(v);
          }
        }
        n.takeRecords();
      }
      i !== null && (d && (i.dirty = !0, pn(i)), so && Ck(e) && i.insertRawText(o));
    });
  } finally {
    Q5 = !1;
  }
}
function bk(e) {
  const t = e._observer;
  t !== null && gk(e, t.takeRecords(), t);
}
function Uk(e) {
  (function(t) {
    A3 === 0 && wg(t).addEventListener("textInput", c$, !0);
  })(e), e._observer = new MutationObserver((t, n) => {
    gk(e, t, n);
  });
}
function _9(e, t) {
  const n = e.__mode, r = e.__format, i = e.__style, a = t.__mode, l = t.__format, s = t.__style;
  return !(n !== null && n !== a || r !== null && r !== l || i !== null && i !== s);
}
function k9(e, t) {
  const n = e.mergeWithSibling(t), r = Fn()._normalizedNodes;
  return r.add(e.__key), r.add(t.__key), n;
}
function C9(e) {
  let t, n, r = e;
  if (r.__text !== "" || !r.isSimpleText() || r.isUnmergeable()) {
    for (; (t = r.getPreviousSibling()) !== null && ce(t) && t.isSimpleText() && !t.isUnmergeable(); ) {
      if (t.__text !== "") {
        if (_9(t, r)) {
          r = k9(t, r);
          break;
        }
        break;
      }
      t.remove();
    }
    for (; (n = r.getNextSibling()) !== null && ce(n) && n.isSimpleText() && !n.isUnmergeable(); ) {
      if (n.__text !== "") {
        if (_9(r, n)) {
          r = k9(r, n);
          break;
        }
        break;
      }
      n.remove();
    }
  } else r.remove();
}
function bg(e) {
  return M9(e.anchor), M9(e.focus), e;
}
function M9(e) {
  for (; e.type === "element"; ) {
    const t = e.getNode(), n = e.offset;
    let r, i;
    if (n === t.getChildrenSize() ? (r = t.getChildAtIndex(n - 1), i = !0) : (r = t.getChildAtIndex(n), i = !1), ce(r)) {
      e.set(r.__key, i ? r.getTextContentSize() : 0, "text");
      break;
    }
    if (!re(r)) break;
    e.set(r.__key, i ? r.getChildrenSize() : 0, "element");
  }
}
let h$ = 1;
const f$ = typeof queueMicrotask == "function" ? queueMicrotask : (e) => {
  Promise.resolve().then(e);
};
function N3(e) {
  const t = document.activeElement;
  if (t === null) return !1;
  const n = t.nodeName;
  return Ft(on(e)) && (n === "INPUT" || n === "TEXTAREA" || t.contentEditable === "true" && Ug(t) == null);
}
function vf(e, t, n) {
  const r = e.getRootElement();
  try {
    return r !== null && r.contains(t) && r.contains(n) && t !== null && !N3(t) && L3(t) === e;
  } catch {
    return !1;
  }
}
function D3(e) {
  return e instanceof kg;
}
function L3(e) {
  let t = e;
  for (; t != null; ) {
    const n = Ug(t);
    if (D3(n)) return n;
    t = yg(t);
  }
  return null;
}
function Ug(e) {
  return e ? e.__lexicalEditor : null;
}
function al(e) {
  return e.isToken() || e.isSegmented();
}
function p$(e) {
  return e.nodeType === No;
}
function Fp(e) {
  let t = e;
  for (; t != null; ) {
    if (p$(t)) return t;
    t = t.firstChild;
  }
  return null;
}
function zp(e, t, n) {
  const r = Mi[t];
  if (n !== null && (e & r) == (n & r)) return e;
  let i = e ^ r;
  return t === "subscript" ? i &= -65 : t === "superscript" && (i &= -33), i;
}
function vk(e) {
  return ce(e) || Ca(e) || Ft(e);
}
function yk(e, t) {
  if (t != null) return void (e.__key = t);
  ii(), eC();
  const n = Fn(), r = Il(), i = "" + h$++;
  r._nodeMap.set(i, e), re(e) ? n._dirtyElements.set(i, !0) : n._dirtyLeaves.add(i), n._cloneNotNeeded.add(i), n._dirtyType = fk, e.__key = i;
}
function bc(e) {
  const t = e.getParent();
  if (t !== null) {
    const n = e.getWritable(), r = t.getWritable(), i = e.getPreviousSibling(), a = e.getNextSibling();
    if (i === null) if (a !== null) {
      const l = a.getWritable();
      r.__first = a.__key, l.__prev = null;
    } else r.__first = null;
    else {
      const l = i.getWritable();
      if (a !== null) {
        const s = a.getWritable();
        s.__prev = l.__key, l.__next = s.__key;
      } else l.__next = null;
      n.__prev = null;
    }
    if (a === null) if (i !== null) {
      const l = i.getWritable();
      r.__last = i.__key, l.__next = null;
    } else r.__last = null;
    else {
      const l = a.getWritable();
      if (i !== null) {
        const s = i.getWritable();
        s.__next = l.__key, l.__prev = s.__key;
      } else l.__prev = null;
      n.__next = null;
    }
    r.__size--, n.__parent = null;
  }
}
function Bp(e) {
  eC();
  const t = e.getLatest(), n = t.__parent, r = Il(), i = Fn(), a = r._nodeMap, l = i._dirtyElements;
  n !== null && function(c, d, o) {
    let u = c;
    for (; u !== null; ) {
      if (o.has(u)) return;
      const h = d.get(u);
      if (h === void 0) break;
      o.set(u, !1), u = h.__parent;
    }
  }(n, a, l);
  const s = t.__key;
  i._dirtyType = fk, re(e) ? l.set(s, !0) : i._dirtyLeaves.add(s);
}
function kr(e) {
  ii();
  const t = Fn(), n = t._compositionKey;
  if (e !== n) {
    if (t._compositionKey = e, n !== null) {
      const r = Rt(n);
      r !== null && r.getWritable();
    }
    if (e !== null) {
      const r = Rt(e);
      r !== null && r.getWritable();
    }
  }
}
function Qs() {
  return B0() ? null : Fn()._compositionKey;
}
function Rt(e, t) {
  const n = (t || Il())._nodeMap.get(e);
  return n === void 0 ? null : n;
}
function wk(e, t) {
  const n = e[`__lexicalKey_${Fn()._key}`];
  return n !== void 0 ? Rt(n, t) : null;
}
function on(e, t) {
  let n = e;
  for (; n != null; ) {
    const r = wk(n, t);
    if (r !== null) return r;
    n = yg(n);
  }
  return null;
}
function xk(e) {
  const t = e._decorators, n = Object.assign({}, t);
  return e._pendingDecorators = n, n;
}
function T9(e) {
  return e.read(() => Bt().getTextContent());
}
function Bt() {
  return Ek(Il());
}
function Ek(e) {
  return e._nodeMap.get("root");
}
function pn(e) {
  ii();
  const t = Il();
  e !== null && (e.dirty = !0, e.setCachedNodes(null)), t._selection = e;
}
function Dd(e) {
  const t = Fn(), n = function(r, i) {
    let a = r;
    for (; a != null; ) {
      const l = a[`__lexicalKey_${i._key}`];
      if (l !== void 0) return l;
      a = yg(a);
    }
    return null;
  }(e, t);
  return n === null ? e === t.getRootElement() ? Rt("root") : null : Rt(n);
}
function I9(e, t) {
  return t ? e.getTextContentSize() : 0;
}
function Sk(e) {
  return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(e);
}
function R3(e) {
  const t = [];
  let n = e;
  for (; n !== null; ) t.push(n), n = n._parentEditor;
  return t;
}
function _k() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
}
function kk(e) {
  return e.nodeType === No ? e.nodeValue : null;
}
function P3(e, t, n) {
  const r = wl(t._window);
  if (r === null) return;
  const i = r.anchorNode;
  let { anchorOffset: a, focusOffset: l } = r;
  if (i !== null) {
    let s = kk(i);
    const c = on(i);
    if (s !== null && ce(c)) {
      if (s === gg && n) {
        const d = n.length;
        s = n, a = d, l = d;
      }
      s !== null && O3(c, s, a, l, e);
    }
  }
}
function O3(e, t, n, r, i) {
  let a = e;
  if (a.isAttached() && (i || !a.isDirty())) {
    const l = a.isComposing();
    let s = t;
    (l || i) && t[t.length - 1] === gg && (s = t.slice(0, -1));
    const c = a.getTextContent();
    if (i || s !== c) {
      if (s === "") {
        if (kr(null), E3 || pg || S3) a.remove();
        else {
          const g = Fn();
          setTimeout(() => {
            g.update(() => {
              a.isAttached() && a.remove();
            });
          }, 20);
        }
        return;
      }
      const d = a.getParent(), o = Do(), u = a.getTextContentSize(), h = Qs(), f = a.getKey();
      if (a.isToken() || h !== null && f === h && !l || ie(o) && (d !== null && !d.canInsertTextBefore() && o.anchor.offset === 0 || o.anchor.key === e.__key && o.anchor.offset === 0 && !a.canInsertTextBefore() && !l || o.focus.key === e.__key && o.focus.offset === u && !a.canInsertTextAfter() && !l)) return void a.markDirty();
      const p = se();
      if (!ie(p) || n === null || r === null) return void a.setTextContent(s);
      if (p.setTextNodeRange(a, n, a, r), a.isSegmented()) {
        const g = un(a.getTextContent());
        a.replace(g), a = g;
      }
      a.setTextContent(s);
    }
  }
}
function m$(e, t) {
  if (t.isSegmented()) return !0;
  if (!e.isCollapsed()) return !1;
  const n = e.anchor.offset, r = t.getParentOrThrow(), i = t.isToken();
  return n === 0 ? !t.canInsertTextBefore() || !r.canInsertTextBefore() && !t.isComposing() || i || function(a) {
    const l = a.getPreviousSibling();
    return (ce(l) || re(l) && l.isInline()) && !l.canInsertTextAfter();
  }(t) : n === t.getTextContentSize() && (!t.canInsertTextAfter() || !r.canInsertTextAfter() && !t.isComposing() || i);
}
function A9(e) {
  return e === "ArrowLeft";
}
function N9(e) {
  return e === "ArrowRight";
}
function Ou(e, t) {
  return da ? e : t;
}
function D9(e) {
  return e === "Enter";
}
function du(e) {
  return e === "Backspace";
}
function uu(e) {
  return e === "Delete";
}
function L9(e, t, n) {
  return e.toLowerCase() === "a" && Ou(t, n);
}
function g$() {
  const e = Bt();
  pn(bg(e.select(0, e.getChildrenSize())));
}
function th(e, t) {
  e.__lexicalClassNameCache === void 0 && (e.__lexicalClassNameCache = {});
  const n = e.__lexicalClassNameCache, r = n[t];
  if (r !== void 0) return r;
  const i = e[t];
  if (typeof i == "string") {
    const a = $p(i);
    return n[t] = a, a;
  }
  return i;
}
function $3(e, t, n, r, i) {
  if (n.size === 0) return;
  const a = r.__type, l = r.__key, s = t.get(a);
  s === void 0 && Ce(33, a);
  const c = s.klass;
  let d = e.get(c);
  d === void 0 && (d = /* @__PURE__ */ new Map(), e.set(c, d));
  const o = d.get(l), u = o === "destroyed" && i === "created";
  (o === void 0 || u) && d.set(l, u ? "updated" : i);
}
function b$(e) {
  const t = e.getType(), n = Il();
  if (n._readOnly) {
    const a = Mk(n).get(t);
    return a ? Array.from(a.values()) : [];
  }
  const r = n._nodeMap, i = [];
  for (const [, a] of r) a instanceof e && a.__type === t && a.isAttached() && i.push(a);
  return i;
}
function R9(e, t, n) {
  const r = e.getParent();
  let i = n, a = e;
  return r !== null && (t && n === 0 ? (i = a.getIndexWithinParent(), a = r) : t || n !== a.getChildrenSize() || (i = a.getIndexWithinParent() + 1, a = r)), a.getChildAtIndex(t ? i - 1 : i);
}
function Ch(e, t) {
  const n = e.offset;
  if (e.type === "element")
    return R9(e.getNode(), t, n);
  {
    const r = e.getNode();
    if (t && n === 0 || !t && n === r.getTextContentSize()) {
      const i = t ? r.getPreviousSibling() : r.getNextSibling();
      return i === null ? R9(r.getParentOrThrow(), t, r.getIndexWithinParent() + (t ? 0 : 1)) : i;
    }
  }
  return null;
}
function Ck(e) {
  const t = wg(e).event, n = t && t.inputType;
  return n === "insertFromPaste" || n === "insertFromPasteAsQuotation";
}
function Ie(e, t, n) {
  return rC(e, t, n);
}
function vg(e) {
  return !Xr(e) && !e.isLastChild() && !e.isInline();
}
function Hp(e, t) {
  const n = e._keyToDOMMap.get(t);
  return n === void 0 && Ce(75, t), n;
}
function yg(e) {
  const t = e.assignedSlot || e.parentElement;
  return t !== null && t.nodeType === 11 ? t.host : t;
}
function nh(e, t) {
  let n = e.getParent();
  for (; n !== null; ) {
    if (n.is(t)) return !0;
    n = n.getParent();
  }
  return !1;
}
function wg(e) {
  const t = e._window;
  return t === null && Ce(78), t;
}
function U$(e) {
  let t = e.getParentOrThrow();
  for (; t !== null; ) {
    if (er(t)) return t;
    t = t.getParentOrThrow();
  }
  return t;
}
function er(e) {
  return Xr(e) || re(e) && e.isShadowRoot();
}
function v$(e) {
  const t = e.constructor.clone(e);
  return yk(t, null), t;
}
function En(e) {
  const t = Fn(), n = e.constructor.getType(), r = t._nodes.get(n);
  r === void 0 && Ce(200, e.constructor.name, n);
  const { replace: i, replaceWithKlass: a } = r;
  if (i !== null) {
    const l = i(e), s = l.constructor;
    return a !== null ? l instanceof a || Ce(201, a.name, a.getType(), s.name, s.getType(), e.constructor.name, n) : l instanceof e.constructor && s !== e.constructor || Ce(202, s.name, s.getType(), e.constructor.name, n), l.__key === e.__key && Ce(203, e.constructor.name, n, s.name, s.getType()), l;
  }
  return e;
}
function B2(e, t) {
  !Xr(e.getParent()) || re(t) || Ft(t) || Ce(99);
}
function H2(e) {
  return (Ft(e) || re(e) && !e.canBeEmpty()) && !e.isInline();
}
function F3(e, t, n) {
  n.style.removeProperty("caret-color"), t._blockCursorElement = null;
  const r = e.parentElement;
  r !== null && r.removeChild(e);
}
function y$(e, t, n) {
  let r = e._blockCursorElement;
  if (ie(n) && n.isCollapsed() && n.anchor.type === "element" && t.contains(document.activeElement)) {
    const i = n.anchor, a = i.getNode(), l = i.offset;
    let s = !1, c = null;
    if (l === a.getChildrenSize())
      H2(a.getChildAtIndex(l - 1)) && (s = !0);
    else {
      const d = a.getChildAtIndex(l);
      if (H2(d)) {
        const o = d.getPreviousSibling();
        (o === null || H2(o)) && (s = !0, c = e.getElementByKey(d.__key));
      }
    }
    if (s) {
      const d = e.getElementByKey(a.__key);
      return r === null && (e._blockCursorElement = r = function(o) {
        const u = o.theme, h = document.createElement("div");
        h.contentEditable = "false", h.setAttribute("data-lexical-cursor", "true");
        let f = u.blockCursor;
        if (f !== void 0) {
          if (typeof f == "string") {
            const p = $p(f);
            f = u.blockCursor = p;
          }
          f !== void 0 && h.classList.add(...f);
        }
        return h;
      }(e._config)), t.style.caretColor = "transparent", void (c === null ? d.appendChild(r) : d.insertBefore(r, c));
    }
  }
  r !== null && F3(r, e, t);
}
function wl(e) {
  return Ba ? (e || window).getSelection() : null;
}
function w$(e, t) {
  let n = e.getChildAtIndex(t);
  n == null && (n = e), er(e) && Ce(102);
  const r = (l) => {
    const s = l.getParentOrThrow(), c = er(s), d = l !== n || c ? v$(l) : l;
    if (c) return re(l) && re(d) || Ce(133), l.insertAfter(d), [l, d, d];
    {
      const [o, u, h] = r(s), f = l.getNextSiblings();
      return h.append(d, ...f), [o, u, d];
    }
  }, [i, a] = r(n);
  return [i, a];
}
function x$(e) {
  return Ti(e) && e.tagName === "A";
}
function Ti(e) {
  return e.nodeType === 1;
}
function P9(e) {
  return e.nodeType === 11;
}
function e4(e) {
  const t = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, "i");
  return e.nodeName.match(t) !== null;
}
function Wp(e) {
  const t = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, "i");
  return e.nodeName.match(t) !== null;
}
function Ws(e) {
  if (Ft(e) && !e.isInline()) return !0;
  if (!re(e) || er(e)) return !1;
  const t = e.getFirstChild(), n = t === null || Ca(t) || ce(t) || t.isInline();
  return !e.isInline() && e.canBeEmpty() !== !1 && n;
}
function hu(e, t) {
  let n = e;
  for (; n !== null && n.getParent() !== null && !t(n); ) n = n.getParentOrThrow();
  return t(n) ? n : null;
}
function E$() {
  return Fn();
}
const O9 = /* @__PURE__ */ new WeakMap(), S$ = /* @__PURE__ */ new Map();
function Mk(e) {
  if (!e._readOnly && e.isEmpty()) return S$;
  e._readOnly || Ce(192);
  let t = O9.get(e);
  if (!t) {
    t = /* @__PURE__ */ new Map(), O9.set(e, t);
    for (const [n, r] of e._nodeMap) {
      const i = r.__type;
      let a = t.get(i);
      a || (a = /* @__PURE__ */ new Map(), t.set(i, a)), a.set(n, r);
    }
  }
  return t;
}
function z3(e) {
  const t = e.constructor.clone(e);
  return t.afterCloneFrom(e), t;
}
function B3(e, t) {
  const n = (parseInt(e.style.paddingInlineStart, 10) || 0) / 40;
  t.setIndent(n);
}
function Tk(e, t, n, r, i, a) {
  let l = e.getFirstChild();
  for (; l !== null; ) {
    const s = l.__key;
    l.__parent === t && (re(l) && Tk(l, s, n, r, i, a), n.has(s) || a.delete(s), i.push(s)), l = l.getNextSibling();
  }
}
let bo, Gr, Mh, xg, t4, n4, Tc, ka, r4, Th, sr = "", Wr = "", qa = null, ua = "", jl = "", Ik = !1, Ih = !1, ep = null;
function Xp(e, t) {
  const n = Tc.get(e);
  if (t !== null) {
    const r = l4(e);
    r.parentNode === t && t.removeChild(r);
  }
  if (ka.has(e) || Gr._keyToDOMMap.delete(e), re(n)) {
    const r = Gp(n, Tc);
    i4(r, 0, r.length - 1, null);
  }
  n !== void 0 && $3(Th, Mh, xg, n, "destroyed");
}
function i4(e, t, n, r) {
  let i = t;
  for (; i <= n; ++i) {
    const a = e[i];
    a !== void 0 && Xp(a, r);
  }
}
function Bo(e, t) {
  e.setProperty("text-align", t);
}
const _$ = "40px";
function Ak(e, t) {
  const n = bo.theme.indent;
  if (typeof n == "string") {
    const i = e.classList.contains(n);
    t > 0 && !i ? e.classList.add(n) : t < 1 && i && e.classList.remove(n);
  }
  const r = getComputedStyle(e).getPropertyValue("--lexical-indent-base-value") || _$;
  e.style.setProperty("padding-inline-start", t === 0 ? "" : `calc(${t} * ${r})`);
}
function Nk(e, t) {
  const n = e.style;
  t === 0 ? Bo(n, "") : t === _3 ? Bo(n, "left") : t === k3 ? Bo(n, "center") : t === C3 ? Bo(n, "right") : t === M3 ? Bo(n, "justify") : t === T3 ? Bo(n, "start") : t === I3 && Bo(n, "end");
}
function Vp(e, t, n) {
  const r = ka.get(e);
  r === void 0 && Ce(60);
  const i = r.createDOM(bo, Gr);
  if (function(a, l, s) {
    const c = s._keyToDOMMap;
    l["__lexicalKey_" + s._key] = a, c.set(a, l);
  }(e, i, Gr), ce(r) ? i.setAttribute("data-lexical-text", "true") : Ft(r) && i.setAttribute("data-lexical-decorator", "true"), re(r)) {
    const a = r.__indent, l = r.__size;
    if (a !== 0 && Ak(i, a), l !== 0) {
      const c = l - 1;
      (function(d, o, u, h) {
        const f = Wr;
        Wr = "", a4(d, u, 0, o, h, null), Lk(u, h), Wr = f;
      })(Gp(r, ka), c, r, i);
    }
    const s = r.__format;
    s !== 0 && Nk(i, s), r.isInline() || Dk(null, r, i), vg(r) && (sr += us, jl += us);
  } else {
    const a = r.getTextContent();
    if (Ft(r)) {
      const l = r.decorate(Gr, bo);
      l !== null && Rk(e, l), i.contentEditable = "false";
    } else ce(r) && (r.isDirectionless() || (Wr += a));
    sr += a, jl += a;
  }
  if (t !== null) if (n != null) t.insertBefore(i, n);
  else {
    const a = t.__lexicalLineBreak;
    a != null ? t.insertBefore(i, a) : t.appendChild(i);
  }
  return $3(Th, Mh, xg, r, "created"), i;
}
function a4(e, t, n, r, i, a) {
  const l = sr;
  sr = "";
  let s = n;
  for (; s <= r; ++s) {
    Vp(e[s], i, a);
    const c = ka.get(e[s]);
    c !== null && ce(c) && (qa === null && (qa = c.getFormat()), ua === "" && (ua = c.getStyle()));
  }
  vg(t) && (sr += us), i.__lexicalTextContent = sr, sr = l + sr;
}
function $9(e, t) {
  const n = t.get(e);
  return Ca(n) || Ft(n) && n.isInline();
}
function Dk(e, t, n) {
  const r = e !== null && (e.__size === 0 || $9(e.__last, Tc)), i = t.__size === 0 || $9(t.__last, ka);
  if (r) {
    if (!i) {
      const a = n.__lexicalLineBreak;
      if (a != null) try {
        n.removeChild(a);
      } catch (l) {
        if (typeof l == "object" && l != null) {
          const s = `${l.toString()} Parent: ${n.tagName}, child: ${a.tagName}.`;
          throw new Error(s);
        }
        throw l;
      }
      n.__lexicalLineBreak = null;
    }
  } else if (i) {
    const a = document.createElement("br");
    n.__lexicalLineBreak = a, n.appendChild(a);
  }
}
function Lk(e, t) {
  const n = t.__lexicalDirTextContent, r = t.__lexicalDir;
  if (n !== Wr || r !== ep) {
    const a = Wr === "", l = a ? ep : (i = Wr, t$.test(i) ? "rtl" : n$.test(i) ? "ltr" : null);
    if (l !== r) {
      const s = t.classList, c = bo.theme;
      let d = r !== null ? c[r] : void 0, o = l !== null ? c[l] : void 0;
      if (d !== void 0) {
        if (typeof d == "string") {
          const u = $p(d);
          d = c[r] = u;
        }
        s.remove(...d);
      }
      if (l === null || a && l === "ltr") t.removeAttribute("dir");
      else {
        if (o !== void 0) {
          if (typeof o == "string") {
            const u = $p(o);
            o = c[l] = u;
          }
          o !== void 0 && s.add(...o);
        }
        t.dir = l;
      }
      Ih || (e.getWritable().__dir = l);
    }
    ep = l, t.__lexicalDirTextContent = Wr, t.__lexicalDir = l;
  }
  var i;
}
function k$(e, t, n) {
  const r = Wr;
  var i;
  Wr = "", qa = null, ua = "", function(a, l, s) {
    const c = sr, d = a.__size, o = l.__size;
    if (sr = "", d === 1 && o === 1) {
      const u = a.__first, h = l.__first;
      if (u === h) $u(u, s);
      else {
        const p = l4(u), g = Vp(h, null, null);
        try {
          s.replaceChild(g, p);
        } catch (b) {
          if (typeof b == "object" && b != null) {
            const v = `${b.toString()} Parent: ${s.tagName}, new child: {tag: ${g.tagName} key: ${h}}, old child: {tag: ${p.tagName}, key: ${u}}.`;
            throw new Error(v);
          }
          throw b;
        }
        Xp(u, null);
      }
      const f = ka.get(h);
      ce(f) && (qa === null && (qa = f.getFormat()), ua === "" && (ua = f.getStyle()));
    } else {
      const u = Gp(a, Tc), h = Gp(l, ka);
      if (d === 0) o !== 0 && a4(h, l, 0, o - 1, s, null);
      else if (o === 0) {
        if (d !== 0) {
          const f = s.__lexicalLineBreak == null;
          i4(u, 0, d - 1, f ? null : s), f && (s.textContent = "");
        }
      } else (function(f, p, g, b, v, U) {
        const y = b - 1, w = v - 1;
        let x, E, S = (M = U, M.firstChild), _ = 0, k = 0;
        for (var M; _ <= y && k <= w; ) {
          const R = p[_], z = g[k];
          if (R === z) S = W2($u(z, U)), _++, k++;
          else {
            x === void 0 && (x = new Set(p)), E === void 0 && (E = new Set(g));
            const W = E.has(R), B = x.has(z);
            if (W) if (B) {
              const j = Hp(Gr, z);
              j === S ? S = W2($u(z, U)) : (S != null ? U.insertBefore(j, S) : U.appendChild(j), $u(z, U)), _++, k++;
            } else Vp(z, U, S), k++;
            else S = W2(l4(R)), Xp(R, U), _++;
          }
          const F = ka.get(z);
          F !== null && ce(F) && (qa === null && (qa = F.getFormat()), ua === "" && (ua = F.getStyle()));
        }
        const A = _ > y, L = k > w;
        if (A && !L) {
          const R = g[w + 1];
          a4(g, f, k, w, U, R === void 0 ? null : Gr.getElementByKey(R));
        } else L && !A && i4(p, _, y, U);
      })(l, u, h, d, o, s);
    }
    vg(l) && (sr += us), s.__lexicalTextContent = sr, sr = c + sr;
  }(e, t, n), Lk(t, n), La(i = t) && qa != null && qa !== i.__textFormat && !Ih && (i.setTextFormat(qa), i.setTextStyle(ua)), function(a) {
    La(a) && ua !== "" && ua !== a.__textStyle && !Ih && a.setTextStyle(ua);
  }(t), Wr = r;
}
function Gp(e, t) {
  const n = [];
  let r = e.__first;
  for (; r !== null; ) {
    const i = t.get(r);
    i === void 0 && Ce(101), n.push(r), r = i.__next;
  }
  return n;
}
function $u(e, t) {
  const n = Tc.get(e);
  let r = ka.get(e);
  n !== void 0 && r !== void 0 || Ce(61);
  const i = Ik || n4.has(e) || t4.has(e), a = Hp(Gr, e);
  if (n === r && !i) {
    if (re(n)) {
      const l = a.__lexicalTextContent;
      l !== void 0 && (sr += l, jl += l);
      const s = a.__lexicalDirTextContent;
      s !== void 0 && (Wr += s);
    } else {
      const l = n.getTextContent();
      ce(n) && !n.isDirectionless() && (Wr += l), jl += l, sr += l;
    }
    return a;
  }
  if (n !== r && i && $3(Th, Mh, xg, r, "updated"), r.updateDOM(n, a, bo)) {
    const l = Vp(e, null, null);
    return t === null && Ce(62), t.replaceChild(l, a), Xp(e, null), l;
  }
  if (re(n) && re(r)) {
    const l = r.__indent;
    l !== n.__indent && Ak(a, l);
    const s = r.__format;
    s !== n.__format && Nk(a, s), i && (k$(n, r, a), Xr(r) || r.isInline() || Dk(n, r, a)), vg(r) && (sr += us, jl += us);
  } else {
    const l = r.getTextContent();
    if (Ft(r)) {
      const s = r.decorate(Gr, bo);
      s !== null && Rk(e, s);
    } else ce(r) && !r.isDirectionless() && (Wr += l);
    sr += l, jl += l;
  }
  if (!Ih && Xr(r) && r.__cachedText !== jl) {
    const l = r.getWritable();
    l.__cachedText = jl, r = l;
  }
  return a;
}
function Rk(e, t) {
  let n = Gr._pendingDecorators;
  const r = Gr._decorators;
  if (n === null) {
    if (r[e] === t) return;
    n = xk(Gr);
  }
  n[e] = t;
}
function W2(e) {
  let t = e.nextSibling;
  return t !== null && t === Gr._blockCursorElement && (t = t.nextSibling), t;
}
function C$(e, t, n, r, i, a) {
  sr = "", jl = "", Wr = "", Ik = r === l0, ep = null, Gr = n, bo = n._config, Mh = n._nodes, xg = Gr._listeners.mutation, t4 = i, n4 = a, Tc = e._nodeMap, ka = t._nodeMap, Ih = t._readOnly, r4 = new Map(n._keyToDOMMap);
  const l = /* @__PURE__ */ new Map();
  return Th = l, $u("root", null), Gr = void 0, Mh = void 0, t4 = void 0, n4 = void 0, Tc = void 0, ka = void 0, bo = void 0, r4 = void 0, Th = void 0, l;
}
function l4(e) {
  const t = r4.get(e);
  return t === void 0 && Ce(75, e), t;
}
const $l = Object.freeze({}), s4 = 30, o4 = [["keydown", function(e, t) {
  if (rh = e.timeStamp, Pk = e.key, t.isComposing()) return;
  const { key: n, shiftKey: r, ctrlKey: i, metaKey: a, altKey: l } = e;
  Ie(t, RO, e) || n != null && (function(s, c, d, o) {
    return N9(s) && !c && !o && !d;
  }(n, i, l, a) ? Ie(t, pf, e) : function(s, c, d, o, u) {
    return N9(s) && !o && !d && (c || u);
  }(n, i, r, l, a) ? Ie(t, PO, e) : function(s, c, d, o) {
    return A9(s) && !c && !o && !d;
  }(n, i, l, a) ? Ie(t, R0, e) : function(s, c, d, o, u) {
    return A9(s) && !o && !d && (c || u);
  }(n, i, r, l, a) ? Ie(t, OO, e) : /* @__PURE__ */ function(s, c, d) {
    return /* @__PURE__ */ function(o) {
      return o === "ArrowUp";
    }(s) && !c && !d;
  }(n, i, a) ? Ie(t, Io, e) : /* @__PURE__ */ function(s, c, d) {
    return /* @__PURE__ */ function(o) {
      return o === "ArrowDown";
    }(s) && !c && !d;
  }(n, i, a) ? Ie(t, Ao, e) : function(s, c) {
    return D9(s) && c;
  }(n, r) ? (ih = !0, Ie(t, a0, e)) : /* @__PURE__ */ function(s) {
    return s === " ";
  }(n) ? Ie(t, ck, e) : function(s, c) {
    return da && c && s.toLowerCase() === "o";
  }(n, i) ? (e.preventDefault(), ih = !0, Ie(t, Gd, !0)) : function(s, c) {
    return D9(s) && !c;
  }(n, r) ? (ih = !1, Ie(t, a0, e)) : function(s, c, d, o) {
    return da ? !c && !d && (du(s) || s.toLowerCase() === "h" && o) : !(o || c || d) && du(s);
  }(n, l, a, i) ? du(n) ? Ie(t, P0, e) : (e.preventDefault(), Ie(t, ls, !0)) : /* @__PURE__ */ function(s) {
    return s === "Escape";
  }(n) ? Ie(t, rd, e) : function(s, c, d, o, u) {
    return da ? !(d || o || u) && (uu(s) || s.toLowerCase() === "d" && c) : !(c || o || u) && uu(s);
  }(n, i, r, l, a) ? uu(n) ? Ie(t, O0, e) : (e.preventDefault(), Ie(t, ls, !1)) : function(s, c, d) {
    return du(s) && (da ? c : d);
  }(n, l, i) ? (e.preventDefault(), Ie(t, i0, !0)) : function(s, c, d) {
    return uu(s) && (da ? c : d);
  }(n, l, i) ? (e.preventDefault(), Ie(t, i0, !1)) : function(s, c) {
    return da && c && du(s);
  }(n, a) ? (e.preventDefault(), Ie(t, Cc, !0)) : function(s, c) {
    return da && c && uu(s);
  }(n, a) ? (e.preventDefault(), Ie(t, Cc, !1)) : function(s, c, d, o) {
    return s.toLowerCase() === "b" && !c && Ou(d, o);
  }(n, l, a, i) ? (e.preventDefault(), Ie(t, Mn, "bold")) : function(s, c, d, o) {
    return s.toLowerCase() === "u" && !c && Ou(d, o);
  }(n, l, a, i) ? (e.preventDefault(), Ie(t, Mn, "underline")) : function(s, c, d, o) {
    return s.toLowerCase() === "i" && !c && Ou(d, o);
  }(n, l, a, i) ? (e.preventDefault(), Ie(t, Mn, "italic")) : /* @__PURE__ */ function(s, c, d, o) {
    return s === "Tab" && !c && !d && !o;
  }(n, l, i, a) ? Ie(t, mf, e) : function(s, c, d, o) {
    return s.toLowerCase() === "z" && !c && Ou(d, o);
  }(n, r, a, i) ? (e.preventDefault(), Ie(t, og, void 0)) : function(s, c, d, o) {
    return da ? s.toLowerCase() === "z" && d && c : s.toLowerCase() === "y" && o || s.toLowerCase() === "z" && o && c;
  }(n, r, a, i) ? (e.preventDefault(), Ie(t, cg, void 0)) : Xn(t._editorState._selection) ? function(s, c, d, o) {
    return !c && s.toLowerCase() === "c" && (da ? d : o);
  }(n, r, a, i) ? (e.preventDefault(), Ie(t, hg, e)) : function(s, c, d, o) {
    return !c && s.toLowerCase() === "x" && (da ? d : o);
  }(n, r, a, i) ? (e.preventDefault(), Ie(t, fg, e)) : L9(n, a, i) && (e.preventDefault(), Ie(t, J5, e)) : !so && L9(n, a, i) && (e.preventDefault(), Ie(t, J5, e)), /* @__PURE__ */ function(s, c, d, o) {
    return s || c || d || o;
  }(i, r, l, a) && Ie(t, uk, e));
}], ["pointerdown", function(e, t) {
  const n = e.target, r = e.pointerType;
  n instanceof Node && r !== "touch" && wi(t, () => {
    Ft(on(n)) || (d4 = !0);
  });
}], ["compositionstart", function(e, t) {
  wi(t, () => {
    const n = se();
    if (ie(n) && !t.isComposing()) {
      const r = n.anchor, i = n.anchor.getNode();
      kr(r.key), (e.timeStamp < rh + s4 || r.type === "element" || !n.isCollapsed() || i.getFormat() !== n.format || ce(i) && i.getStyle() !== n.style) && Ie(t, gc, e$);
    }
  });
}], ["compositionend", function(e, t) {
  so ? fu = !0 : wi(t, () => {
    X2(t, e.data);
  });
}], ["input", function(e, t) {
  e.stopPropagation(), wi(t, () => {
    const n = se(), r = e.data, i = zk(e);
    if (r != null && ie(n) && Fk(n, i, r, e.timeStamp, !1)) {
      fu && (X2(t, r), fu = !1);
      const a = n.anchor.getNode(), l = wl(t._window);
      if (l === null) return;
      const s = n.isBackward(), c = s ? n.anchor.offset : n.focus.offset, d = s ? n.focus.offset : n.anchor.offset;
      Op && !n.isCollapsed() && ce(a) && l.anchorNode !== null && a.getTextContent().slice(0, c) + r + a.getTextContent().slice(c + d) === kk(l.anchorNode) || Ie(t, gc, r);
      const o = r.length;
      so && o > 1 && e.inputType === "insertCompositionText" && !t.isComposing() && (n.anchor.offset -= o), E3 || pg || S3 || !t.isComposing() || (rh = 0, kr(null));
    } else
      P3(!1, t, r !== null ? r : void 0), fu && (X2(t, r || void 0), fu = !1);
    ii(), bk(Fn());
  }), Td = null;
}], ["click", function(e, t) {
  wi(t, () => {
    const n = se(), r = wl(t._window), i = Do();
    if (r) {
      if (ie(n)) {
        const a = n.anchor, l = a.getNode();
        a.type === "element" && a.offset === 0 && n.isCollapsed() && !Xr(l) && Bt().getChildrenSize() === 1 && l.getTopLevelElementOrThrow().isEmpty() && i !== null && n.is(i) ? (r.removeAllRanges(), n.dirty = !0) : e.detail === 3 && !n.isCollapsed() && l !== n.focus.getNode() && (re(l) ? l.select(0) : l.getParentOrThrow().select(0));
      } else if (e.pointerType === "touch") {
        const a = r.anchorNode;
        if (a !== null) {
          const l = a.nodeType;
          (l === Uf || l === No) && pn(Sg(i, r, t, e));
        }
      }
    }
    Ie(t, L0, e);
  });
}], ["cut", $l], ["copy", $l], ["dragstart", $l], ["dragover", $l], ["dragend", $l], ["paste", $l], ["focus", $l], ["blur", $l], ["drop", $l]];
Op && o4.push(["beforeinput", (e, t) => function(n, r) {
  const i = n.inputType, a = zk(n);
  i === "deleteCompositionText" || so && Ck(r) || i !== "insertCompositionText" && wi(r, () => {
    const l = se();
    if (i === "deleteContentBackward") {
      if (l === null) {
        const f = Do();
        if (!ie(f)) return;
        pn(f.clone());
      }
      if (ie(l)) {
        const f = l.anchor.key === l.focus.key;
        if (s = n.timeStamp, Pk === "MediaLast" && s < rh + s4 && r.isComposing() && f) {
          if (kr(null), rh = 0, setTimeout(() => {
            wi(r, () => {
              kr(null);
            });
          }, s4), ie(l)) {
            const p = l.anchor.getNode();
            p.markDirty(), l.format = p.getFormat(), ce(p) || Ce(142), l.style = p.getStyle();
          }
        } else {
          kr(null), n.preventDefault();
          const p = l.anchor.getNode().getTextContent(), g = l.anchor.offset === 0 && l.focus.offset === p.length;
          XO && f && !g || Ie(r, ls, !0);
        }
        return;
      }
    }
    var s;
    if (!ie(l)) return;
    const c = n.data;
    Td !== null && P3(!1, r, Td), l.dirty && Td === null || !l.isCollapsed() || Xr(l.anchor.getNode()) || a === null || l.applyDOMRange(a), Td = null;
    const d = l.anchor, o = l.focus, u = d.getNode(), h = o.getNode();
    if (i !== "insertText" && i !== "insertTranspose") switch (n.preventDefault(), i) {
      case "insertFromYank":
      case "insertFromDrop":
      case "insertReplacementText":
        Ie(r, gc, n);
        break;
      case "insertFromComposition":
        kr(null), Ie(r, gc, n);
        break;
      case "insertLineBreak":
        kr(null), Ie(r, Gd, !1);
        break;
      case "insertParagraph":
        kr(null), ih && !pg ? (ih = !1, Ie(r, Gd, !1)) : Ie(r, kc, void 0);
        break;
      case "insertFromPaste":
      case "insertFromPasteAsQuotation":
        Ie(r, sg, n);
        break;
      case "deleteByComposition":
        (function(f, p) {
          return f !== p || re(f) || re(p) || !f.isToken() || !p.isToken();
        })(u, h) && Ie(r, Z5, n);
        break;
      case "deleteByDrag":
      case "deleteByCut":
        Ie(r, Z5, n);
        break;
      case "deleteContent":
        Ie(r, ls, !1);
        break;
      case "deleteWordBackward":
        Ie(r, i0, !0);
        break;
      case "deleteWordForward":
        Ie(r, i0, !1);
        break;
      case "deleteHardLineBackward":
      case "deleteSoftLineBackward":
        Ie(r, Cc, !0);
        break;
      case "deleteContentForward":
      case "deleteHardLineForward":
      case "deleteSoftLineForward":
        Ie(r, Cc, !1);
        break;
      case "formatStrikeThrough":
        Ie(r, Mn, "strikethrough");
        break;
      case "formatBold":
        Ie(r, Mn, "bold");
        break;
      case "formatItalic":
        Ie(r, Mn, "italic");
        break;
      case "formatUnderline":
        Ie(r, Mn, "underline");
        break;
      case "historyUndo":
        Ie(r, og, void 0);
        break;
      case "historyRedo":
        Ie(r, cg, void 0);
    }
    else {
      if (c === `
`) n.preventDefault(), Ie(r, Gd, !1);
      else if (c === us) n.preventDefault(), Ie(r, kc, void 0);
      else if (c == null && n.dataTransfer) {
        const f = n.dataTransfer.getData("text/plain");
        n.preventDefault(), l.insertRawText(f);
      } else c != null && Fk(l, a, c, n.timeStamp, !0) ? (n.preventDefault(), Ie(r, gc, c)) : Td = c;
      Ok = n.timeStamp;
    }
  });
}(e, t)]);
let rh = 0, Pk = null, Ok = 0, Td = null;
const jp = /* @__PURE__ */ new WeakMap();
let c4 = !1, d4 = !1, ih = !1, fu = !1, $k = [0, "", 0, "root", 0];
function Fk(e, t, n, r, i) {
  const a = e.anchor, l = e.focus, s = a.getNode(), c = Fn(), d = wl(c._window), o = d !== null ? d.anchorNode : null, u = a.key, h = c.getElementByKey(u), f = n.length;
  return u !== l.key || !ce(s) || (!i && (!Op || Ok < r + 50) || s.isDirty() && f < 2 || Sk(n)) && a.offset !== l.offset && !s.isComposing() || al(s) || s.isDirty() && f > 1 || (i || !Op) && h !== null && !s.isComposing() && o !== Fp(h) || d !== null && t !== null && (!t.collapsed || t.startContainer !== d.anchorNode || t.startOffset !== d.anchorOffset) || s.getFormat() !== e.format || s.getStyle() !== e.style || m$(e, s);
}
function F9(e, t) {
  return e !== null && e.nodeValue !== null && e.nodeType === No && t !== 0 && t !== e.nodeValue.length;
}
function z9(e, t, n) {
  const { anchorNode: r, anchorOffset: i, focusNode: a, focusOffset: l } = e;
  c4 && (c4 = !1, F9(r, i) && F9(a, l)) || wi(t, () => {
    if (!n) return void pn(null);
    if (!vf(t, r, a)) return;
    const s = se();
    if (ie(s)) {
      const c = s.anchor, d = c.getNode();
      if (s.isCollapsed()) {
        e.type === "Range" && e.anchorNode === e.focusNode && (s.dirty = !0);
        const o = wg(t).event, u = o ? o.timeStamp : performance.now(), [h, f, p, g, b] = $k, v = Bt(), U = t.isComposing() === !1 && v.getTextContent() === "";
        if (u < b + 200 && c.offset === p && c.key === g) s.format = h, s.style = f;
        else if (c.type === "text") ce(d) || Ce(141), s.format = d.getFormat(), s.style = d.getStyle();
        else if (c.type === "element" && !U) {
          const y = c.getNode();
          s.style = "", y instanceof _g && y.getChildrenSize() === 0 ? (s.format = y.getTextFormat(), s.style = y.getTextStyle()) : s.format = 0;
        }
      } else {
        const o = c.key, u = s.focus.key, h = s.getNodes(), f = h.length, p = s.isBackward(), g = p ? l : i, b = p ? i : l, v = p ? u : o, U = p ? o : u;
        let y = QO, w = !1;
        for (let x = 0; x < f; x++) {
          const E = h[x], S = E.getTextContentSize();
          if (ce(E) && S !== 0 && !(x === 0 && E.__key === v && g === S || x === f - 1 && E.__key === U && b === 0) && (w = !0, y &= E.getFormat(), y === 0)) break;
        }
        s.format = w ? y : 0;
      }
    }
    Ie(t, Ei, void 0);
  });
}
function zk(e) {
  if (!e.getTargetRanges) return null;
  const t = e.getTargetRanges();
  return t.length === 0 ? null : t[0];
}
function X2(e, t) {
  const n = e._compositionKey;
  if (kr(null), n !== null && t != null) {
    if (t === "") {
      const r = Rt(n), i = Fp(e.getElementByKey(n));
      return void (i !== null && i.nodeValue !== null && ce(r) && O3(r, i.nodeValue, null, null, !0));
    }
    if (t[t.length - 1] === `
`) {
      const r = se();
      if (ie(r)) {
        const i = r.focus;
        return r.anchor.set(i.key, i.offset, i.type), void Ie(e, a0, null);
      }
    }
  }
  P3(!0, e, t);
}
function Bk(e) {
  let t = e.__lexicalEventHandles;
  return t === void 0 && (t = [], e.__lexicalEventHandles = t), t;
}
const jd = /* @__PURE__ */ new Map();
function Hk(e) {
  const t = e.target, n = wl(t == null ? null : t.nodeType === 9 ? t.defaultView : t.ownerDocument.defaultView);
  if (n === null) return;
  const r = L3(n.anchorNode);
  if (r === null) return;
  d4 && (d4 = !1, wi(r, () => {
    const d = Do(), o = n.anchorNode;
    if (o === null) return;
    const u = o.nodeType;
    u !== Uf && u !== No || pn(Sg(d, n, r, e));
  }));
  const i = R3(r), a = i[i.length - 1], l = a._key, s = jd.get(l), c = s || a;
  c !== r && z9(n, c, !1), z9(n, r, !0), r !== a ? jd.set(l, r) : s && jd.delete(l);
}
function B9(e) {
  e._lexicalHandled = !0;
}
function H9(e) {
  return e._lexicalHandled === !0;
}
function M$(e) {
  const t = e.ownerDocument, n = jp.get(t);
  n === void 0 && Ce(162);
  const r = n - 1;
  r >= 0 || Ce(164), jp.set(t, r), r === 0 && t.removeEventListener("selectionchange", Hk);
  const i = Ug(e);
  D3(i) ? (function(l) {
    if (l._parentEditor !== null) {
      const s = R3(l), c = s[s.length - 1]._key;
      jd.get(c) === l && jd.delete(c);
    } else jd.delete(l._key);
  }(i), e.__lexicalEditor = null) : i && Ce(198);
  const a = Bk(e);
  for (let l = 0; l < a.length; l++) a[l]();
  e.__lexicalEventHandles = [];
}
function u4(e, t, n) {
  ii();
  const r = e.__key, i = e.getParent();
  if (i === null) return;
  const a = function(s) {
    const c = se();
    if (!ie(c) || !re(s)) return c;
    const { anchor: d, focus: o } = c, u = d.getNode(), h = o.getNode();
    return nh(u, s) && d.set(s.__key, 0, "element"), nh(h, s) && o.set(s.__key, 0, "element"), c;
  }(e);
  let l = !1;
  if (ie(a) && t) {
    const s = a.anchor, c = a.focus;
    s.key === r && (qp(s, e, i, e.getPreviousSibling(), e.getNextSibling()), l = !0), c.key === r && (qp(c, e, i, e.getPreviousSibling(), e.getNextSibling()), l = !0);
  } else Xn(a) && t && e.isSelected() && e.selectPrevious();
  if (ie(a) && t && !l) {
    const s = e.getIndexWithinParent();
    bc(e), Yp(a, i, s, -1);
  } else bc(e);
  n || er(i) || i.canBeEmpty() || !i.isEmpty() || u4(i, t), t && Xr(i) && i.isEmpty() && i.selectEnd();
}
let Eg = class {
  static getType() {
    Ce(64, this.name);
  }
  static clone(t) {
    Ce(65, this.name);
  }
  afterCloneFrom(t) {
    this.__parent = t.__parent, this.__next = t.__next, this.__prev = t.__prev;
  }
  constructor(t) {
    this.__type = this.constructor.getType(), this.__parent = null, this.__prev = null, this.__next = null, yk(this, t);
  }
  getType() {
    return this.__type;
  }
  isInline() {
    Ce(137, this.constructor.name);
  }
  isAttached() {
    let t = this.__key;
    for (; t !== null; ) {
      if (t === "root") return !0;
      const n = Rt(t);
      if (n === null) break;
      t = n.__parent;
    }
    return !1;
  }
  isSelected(t) {
    const n = t || se();
    if (n == null) return !1;
    const r = n.getNodes().some((i) => i.__key === this.__key);
    if (ce(this)) return r;
    if (ie(n) && n.anchor.type === "element" && n.focus.type === "element") {
      if (n.isCollapsed()) return !1;
      const i = this.getParent();
      if (Ft(this) && this.isInline() && i) {
        const a = n.isBackward() ? n.focus : n.anchor, l = a.getNode();
        if (a.offset === l.getChildrenSize() && l.is(i) && l.getLastChildOrThrow().is(this)) return !1;
      }
    }
    return r;
  }
  getKey() {
    return this.__key;
  }
  getIndexWithinParent() {
    const t = this.getParent();
    if (t === null) return -1;
    let n = t.getFirstChild(), r = 0;
    for (; n !== null; ) {
      if (this.is(n)) return r;
      r++, n = n.getNextSibling();
    }
    return -1;
  }
  getParent() {
    const t = this.getLatest().__parent;
    return t === null ? null : Rt(t);
  }
  getParentOrThrow() {
    const t = this.getParent();
    return t === null && Ce(66, this.__key), t;
  }
  getTopLevelElement() {
    let t = this;
    for (; t !== null; ) {
      const n = t.getParent();
      if (er(n)) return re(t) || t === this && Ft(t) || Ce(194), t;
      t = n;
    }
    return null;
  }
  getTopLevelElementOrThrow() {
    const t = this.getTopLevelElement();
    return t === null && Ce(67, this.__key), t;
  }
  getParents() {
    const t = [];
    let n = this.getParent();
    for (; n !== null; ) t.push(n), n = n.getParent();
    return t;
  }
  getParentKeys() {
    const t = [];
    let n = this.getParent();
    for (; n !== null; ) t.push(n.__key), n = n.getParent();
    return t;
  }
  getPreviousSibling() {
    const t = this.getLatest().__prev;
    return t === null ? null : Rt(t);
  }
  getPreviousSiblings() {
    const t = [], n = this.getParent();
    if (n === null) return t;
    let r = n.getFirstChild();
    for (; r !== null && !r.is(this); ) t.push(r), r = r.getNextSibling();
    return t;
  }
  getNextSibling() {
    const t = this.getLatest().__next;
    return t === null ? null : Rt(t);
  }
  getNextSiblings() {
    const t = [];
    let n = this.getNextSibling();
    for (; n !== null; ) t.push(n), n = n.getNextSibling();
    return t;
  }
  getCommonAncestor(t) {
    const n = this.getParents(), r = t.getParents();
    re(this) && n.unshift(this), re(t) && r.unshift(t);
    const i = n.length, a = r.length;
    if (i === 0 || a === 0 || n[i - 1] !== r[a - 1]) return null;
    const l = new Set(r);
    for (let s = 0; s < i; s++) {
      const c = n[s];
      if (l.has(c)) return c;
    }
    return null;
  }
  is(t) {
    return t != null && this.__key === t.__key;
  }
  isBefore(t) {
    if (this === t) return !1;
    if (t.isParentOf(this)) return !0;
    if (this.isParentOf(t)) return !1;
    const n = this.getCommonAncestor(t);
    let r = 0, i = 0, a = this;
    for (; ; ) {
      const l = a.getParentOrThrow();
      if (l === n) {
        r = a.getIndexWithinParent();
        break;
      }
      a = l;
    }
    for (a = t; ; ) {
      const l = a.getParentOrThrow();
      if (l === n) {
        i = a.getIndexWithinParent();
        break;
      }
      a = l;
    }
    return r < i;
  }
  isParentOf(t) {
    const n = this.__key;
    if (n === t.__key) return !1;
    let r = t;
    for (; r !== null; ) {
      if (r.__key === n) return !0;
      r = r.getParent();
    }
    return !1;
  }
  getNodesBetween(t) {
    const n = this.isBefore(t), r = [], i = /* @__PURE__ */ new Set();
    let a = this;
    for (; a !== null; ) {
      const l = a.__key;
      if (i.has(l) || (i.add(l), r.push(a)), a === t) break;
      const s = re(a) ? n ? a.getFirstChild() : a.getLastChild() : null;
      if (s !== null) {
        a = s;
        continue;
      }
      const c = n ? a.getNextSibling() : a.getPreviousSibling();
      if (c !== null) {
        a = c;
        continue;
      }
      const d = a.getParentOrThrow();
      if (i.has(d.__key) || r.push(d), d === t) break;
      let o = null, u = d;
      do {
        if (u === null && Ce(68), o = n ? u.getNextSibling() : u.getPreviousSibling(), u = u.getParent(), u === null) break;
        o !== null || i.has(u.__key) || r.push(u);
      } while (o === null);
      a = o;
    }
    return n || r.reverse(), r;
  }
  isDirty() {
    const t = Fn()._dirtyLeaves;
    return t !== null && t.has(this.__key);
  }
  getLatest() {
    const t = Rt(this.__key);
    return t === null && Ce(113), t;
  }
  getWritable() {
    ii();
    const t = Il(), n = Fn(), r = t._nodeMap, i = this.__key, a = this.getLatest(), l = n._cloneNotNeeded, s = se();
    if (s !== null && s.setCachedNodes(null), l.has(i)) return Bp(a), a;
    const c = z3(a);
    return l.add(i), Bp(c), r.set(i, c), c;
  }
  getTextContent() {
    return "";
  }
  getTextContentSize() {
    return this.getTextContent().length;
  }
  createDOM(t, n) {
    Ce(70);
  }
  updateDOM(t, n, r) {
    Ce(71);
  }
  exportDOM(t) {
    return { element: this.createDOM(t._config, t) };
  }
  exportJSON() {
    Ce(72);
  }
  static importJSON(t) {
    Ce(18, this.name);
  }
  static transform() {
    return null;
  }
  remove(t) {
    u4(this, !0, t);
  }
  replace(t, n) {
    ii();
    let r = se();
    r !== null && (r = r.clone()), B2(this, t);
    const i = this.getLatest(), a = this.__key, l = t.__key, s = t.getWritable(), c = this.getParentOrThrow().getWritable(), d = c.__size;
    bc(s);
    const o = i.getPreviousSibling(), u = i.getNextSibling(), h = i.__prev, f = i.__next, p = i.__parent;
    if (u4(i, !1, !0), o === null ? c.__first = l : o.getWritable().__next = l, s.__prev = h, u === null ? c.__last = l : u.getWritable().__prev = l, s.__next = f, s.__parent = p, c.__size = d, n && (re(this) && re(s) || Ce(139), this.getChildren().forEach((g) => {
      s.append(g);
    })), ie(r)) {
      pn(r);
      const g = r.anchor, b = r.focus;
      g.key === a && G9(g, s), b.key === a && G9(b, s);
    }
    return Qs() === a && kr(l), s;
  }
  insertAfter(t, n = !0) {
    ii(), B2(this, t);
    const r = this.getWritable(), i = t.getWritable(), a = i.getParent(), l = se();
    let s = !1, c = !1;
    if (a !== null) {
      const f = t.getIndexWithinParent();
      if (bc(i), ie(l)) {
        const p = a.__key, g = l.anchor, b = l.focus;
        s = g.type === "element" && g.key === p && g.offset === f + 1, c = b.type === "element" && b.key === p && b.offset === f + 1;
      }
    }
    const d = this.getNextSibling(), o = this.getParentOrThrow().getWritable(), u = i.__key, h = r.__next;
    if (d === null ? o.__last = u : d.getWritable().__prev = u, o.__size++, r.__next = u, i.__next = h, i.__prev = r.__key, i.__parent = r.__parent, n && ie(l)) {
      const f = this.getIndexWithinParent();
      Yp(l, o, f + 1);
      const p = o.__key;
      s && l.anchor.set(p, f + 2, "element"), c && l.focus.set(p, f + 2, "element");
    }
    return t;
  }
  insertBefore(t, n = !0) {
    ii(), B2(this, t);
    const r = this.getWritable(), i = t.getWritable(), a = i.__key;
    bc(i);
    const l = this.getPreviousSibling(), s = this.getParentOrThrow().getWritable(), c = r.__prev, d = this.getIndexWithinParent();
    l === null ? s.__first = a : l.getWritable().__next = a, s.__size++, r.__prev = a, i.__prev = c, i.__next = r.__key, i.__parent = r.__parent;
    const o = se();
    return n && ie(o) && Yp(o, this.getParentOrThrow(), d), t;
  }
  isParentRequired() {
    return !1;
  }
  createParentElementNode() {
    return He();
  }
  selectStart() {
    return this.selectPrevious();
  }
  selectEnd() {
    return this.selectNext(0, 0);
  }
  selectPrevious(t, n) {
    ii();
    const r = this.getPreviousSibling(), i = this.getParentOrThrow();
    if (r === null) return i.select(0, 0);
    if (re(r)) return r.select();
    if (!ce(r)) {
      const a = r.getIndexWithinParent() + 1;
      return i.select(a, a);
    }
    return r.select(t, n);
  }
  selectNext(t, n) {
    ii();
    const r = this.getNextSibling(), i = this.getParentOrThrow();
    if (r === null) return i.select();
    if (re(r)) return r.select(0, 0);
    if (!ce(r)) {
      const a = r.getIndexWithinParent();
      return i.select(a, a);
    }
    return r.select(t, n);
  }
  markDirty() {
    this.getWritable();
  }
}, H3 = class Wk extends Eg {
  static getType() {
    return "linebreak";
  }
  static clone(t) {
    return new Wk(t.__key);
  }
  constructor(t) {
    super(t);
  }
  getTextContent() {
    return `
`;
  }
  createDOM() {
    return document.createElement("br");
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return { br: (t) => function(n) {
      const r = n.parentElement;
      if (r !== null && Wp(r)) {
        const i = r.firstChild;
        if (i === n || i.nextSibling === n && r1(i)) {
          const a = r.lastChild;
          if (a === n || a.previousSibling === n && r1(a)) return !0;
        }
      }
      return !1;
    }(t) || function(n) {
      const r = n.parentElement;
      if (r !== null && Wp(r)) {
        const i = r.firstChild;
        if (i === n || i.nextSibling === n && r1(i)) return !1;
        const a = r.lastChild;
        if (a === n || a.previousSibling === n && r1(a)) return !0;
      }
      return !1;
    }(t) ? null : { conversion: T$, priority: 0 } };
  }
  static importJSON(t) {
    return hs();
  }
  exportJSON() {
    return { type: "linebreak", version: 1 };
  }
};
function T$(e) {
  return { node: hs() };
}
function hs() {
  return En(new H3());
}
function Ca(e) {
  return e instanceof H3;
}
function r1(e) {
  return e.nodeType === No && /^( |\t|\r?\n)+$/.test(e.textContent || "");
}
function V2(e, t) {
  return 16 & t ? "code" : t & mg ? "mark" : 32 & t ? "sub" : 64 & t ? "sup" : null;
}
function G2(e, t) {
  return 1 & t ? "strong" : 2 & t ? "em" : "span";
}
function Xk(e, t, n, r, i) {
  const a = r.classList;
  let l = th(i, "base");
  l !== void 0 && a.add(...l), l = th(i, "underlineStrikethrough");
  let s = !1;
  const c = t & o0 && t & s0;
  l !== void 0 && (n & o0 && n & s0 ? (s = !0, c || a.add(...l)) : c && a.remove(...l));
  for (const d in Mi) {
    const o = Mi[d];
    if (l = th(i, d), l !== void 0) if (n & o) {
      if (s && (d === "underline" || d === "strikethrough")) {
        t & o && a.remove(...l);
        continue;
      }
      t & o && (!c || d !== "underline") && d !== "strikethrough" || a.add(...l);
    } else t & o && a.remove(...l);
  }
}
function Vk(e, t, n) {
  const r = t.firstChild, i = n.isComposing(), a = e + (i ? gg : "");
  if (r == null) t.textContent = a;
  else {
    const l = r.nodeValue;
    if (l !== a) if (i || so) {
      const [s, c, d] = function(o, u) {
        const h = o.length, f = u.length;
        let p = 0, g = 0;
        for (; p < h && p < f && o[p] === u[p]; ) p++;
        for (; g + p < h && g + p < f && o[h - g - 1] === u[f - g - 1]; ) g++;
        return [p, h - p - g, u.slice(p, f - g)];
      }(l, a);
      c !== 0 && r.deleteData(s, c), r.insertData(s, d);
    } else r.nodeValue = a;
  }
}
function W9(e, t, n, r, i, a) {
  Vk(i, e, t);
  const l = a.theme.text;
  l !== void 0 && Xk(0, 0, r, e, l);
}
function i1(e, t) {
  const n = document.createElement(t);
  return n.appendChild(e), n;
}
let aa = class Gk extends Eg {
  static getType() {
    return "text";
  }
  static clone(t) {
    return new Gk(t.__text, t.__key);
  }
  afterCloneFrom(t) {
    super.afterCloneFrom(t), this.__format = t.__format, this.__style = t.__style, this.__mode = t.__mode, this.__detail = t.__detail;
  }
  constructor(t, n) {
    super(n), this.__text = t, this.__format = 0, this.__style = "", this.__mode = 0, this.__detail = 0;
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getDetail() {
    return this.getLatest().__detail;
  }
  getMode() {
    const t = this.getLatest();
    return l$[t.__mode];
  }
  getStyle() {
    return this.getLatest().__style;
  }
  isToken() {
    return this.getLatest().__mode === 1;
  }
  isComposing() {
    return this.__key === Qs();
  }
  isSegmented() {
    return this.getLatest().__mode === 2;
  }
  isDirectionless() {
    return !!(1 & this.getLatest().__detail);
  }
  isUnmergeable() {
    return !!(2 & this.getLatest().__detail);
  }
  hasFormat(t) {
    const n = Mi[t];
    return !!(this.getFormat() & n);
  }
  isSimpleText() {
    return this.__type === "text" && this.__mode === 0;
  }
  getTextContent() {
    return this.getLatest().__text;
  }
  getFormatFlags(t, n) {
    return zp(this.getLatest().__format, t, n);
  }
  canHaveFormat() {
    return !0;
  }
  createDOM(t, n) {
    const r = this.__format, i = V2(0, r), a = G2(0, r), l = i === null ? a : i, s = document.createElement(l);
    let c = s;
    this.hasFormat("code") && s.setAttribute("spellcheck", "false"), i !== null && (c = document.createElement(a), s.appendChild(c)), W9(c, this, 0, r, this.__text, t);
    const d = this.__style;
    return d !== "" && (s.style.cssText = d), s;
  }
  updateDOM(t, n, r) {
    const i = this.__text, a = t.__format, l = this.__format, s = V2(0, a), c = V2(0, l), d = G2(0, a), o = G2(0, l);
    if ((s === null ? d : s) !== (c === null ? o : c)) return !0;
    if (s === c && d !== o) {
      const g = n.firstChild;
      g == null && Ce(48);
      const b = document.createElement(o);
      return W9(b, this, 0, l, i, r), n.replaceChild(b, g), !1;
    }
    let u = n;
    c !== null && s !== null && (u = n.firstChild, u == null && Ce(49)), Vk(i, u, this);
    const h = r.theme.text;
    h !== void 0 && a !== l && Xk(0, a, l, u, h);
    const f = t.__style, p = this.__style;
    return f !== p && (n.style.cssText = p), !1;
  }
  static importDOM() {
    return { "#text": () => ({ conversion: D$, priority: 0 }), b: () => ({ conversion: A$, priority: 0 }), code: () => ({ conversion: Rs, priority: 0 }), em: () => ({ conversion: Rs, priority: 0 }), i: () => ({ conversion: Rs, priority: 0 }), s: () => ({ conversion: Rs, priority: 0 }), span: () => ({ conversion: I$, priority: 0 }), strong: () => ({ conversion: Rs, priority: 0 }), sub: () => ({ conversion: Rs, priority: 0 }), sup: () => ({ conversion: Rs, priority: 0 }), u: () => ({ conversion: Rs, priority: 0 }) };
  }
  static importJSON(t) {
    const n = un(t.text);
    return n.setFormat(t.format), n.setDetail(t.detail), n.setMode(t.mode), n.setStyle(t.style), n;
  }
  exportDOM(t) {
    let { element: n } = super.exportDOM(t);
    return n !== null && Ti(n) || Ce(132), n.style.whiteSpace = "pre-wrap", this.hasFormat("bold") && (n = i1(n, "b")), this.hasFormat("italic") && (n = i1(n, "i")), this.hasFormat("strikethrough") && (n = i1(n, "s")), this.hasFormat("underline") && (n = i1(n, "u")), { element: n };
  }
  exportJSON() {
    return { detail: this.getDetail(), format: this.getFormat(), mode: this.getMode(), style: this.getStyle(), text: this.getTextContent(), type: "text", version: 1 };
  }
  selectionTransform(t, n) {
  }
  setFormat(t) {
    const n = this.getWritable();
    return n.__format = typeof t == "string" ? Mi[t] : t, n;
  }
  setDetail(t) {
    const n = this.getWritable();
    return n.__detail = typeof t == "string" ? r$[t] : t, n;
  }
  setStyle(t) {
    const n = this.getWritable();
    return n.__style = t, n;
  }
  toggleFormat(t) {
    const n = zp(this.getFormat(), t, null);
    return this.setFormat(n);
  }
  toggleDirectionless() {
    const t = this.getWritable();
    return t.__detail ^= 1, t;
  }
  toggleUnmergeable() {
    const t = this.getWritable();
    return t.__detail ^= 2, t;
  }
  setMode(t) {
    const n = a$[t];
    if (this.__mode === n) return this;
    const r = this.getWritable();
    return r.__mode = n, r;
  }
  setTextContent(t) {
    if (this.__text === t) return this;
    const n = this.getWritable();
    return n.__text = t, n;
  }
  select(t, n) {
    ii();
    let r = t, i = n;
    const a = se(), l = this.getTextContent(), s = this.__key;
    if (typeof l == "string") {
      const c = l.length;
      r === void 0 && (r = c), i === void 0 && (i = c);
    } else r = 0, i = 0;
    if (!ie(a)) return Qk(s, r, s, i, "text", "text");
    {
      const c = Qs();
      c !== a.anchor.key && c !== a.focus.key || kr(s), a.setTextNodeRange(this, r, this, i);
    }
    return a;
  }
  selectStart() {
    return this.select(0, 0);
  }
  selectEnd() {
    const t = this.getTextContentSize();
    return this.select(t, t);
  }
  spliceText(t, n, r, i) {
    const a = this.getWritable(), l = a.__text, s = r.length;
    let c = t;
    c < 0 && (c = s + c, c < 0 && (c = 0));
    const d = se();
    if (i && ie(d)) {
      const u = t + s;
      d.setTextNodeRange(a, u, a, u);
    }
    const o = l.slice(0, c) + r + l.slice(c + n);
    return a.__text = o, a;
  }
  canInsertTextBefore() {
    return !0;
  }
  canInsertTextAfter() {
    return !0;
  }
  splitText(...t) {
    ii();
    const n = this.getLatest(), r = n.getTextContent(), i = n.__key, a = Qs(), l = new Set(t), s = [], c = r.length;
    let d = "";
    for (let x = 0; x < c; x++) d !== "" && l.has(x) && (s.push(d), d = ""), d += r[x];
    d !== "" && s.push(d);
    const o = s.length;
    if (o === 0) return [];
    if (s[0] === r) return [n];
    const u = s[0], h = n.getParent();
    let f;
    const p = n.getFormat(), g = n.getStyle(), b = n.__detail;
    let v = !1;
    n.isSegmented() ? (f = un(u), f.__format = p, f.__style = g, f.__detail = b, v = !0) : (f = n.getWritable(), f.__text = u);
    const U = se(), y = [f];
    let w = u.length;
    for (let x = 1; x < o; x++) {
      const E = s[x], S = E.length, _ = un(E).getWritable();
      _.__format = p, _.__style = g, _.__detail = b;
      const k = _.__key, M = w + S;
      if (ie(U)) {
        const A = U.anchor, L = U.focus;
        A.key === i && A.type === "text" && A.offset > w && A.offset <= M && (A.key = k, A.offset -= w, U.dirty = !0), L.key === i && L.type === "text" && L.offset > w && L.offset <= M && (L.key = k, L.offset -= w, U.dirty = !0);
      }
      a === i && kr(k), w = M, y.push(_);
    }
    if (h !== null) {
      (function(S) {
        const _ = S.getPreviousSibling(), k = S.getNextSibling();
        _ !== null && Bp(_), k !== null && Bp(k);
      })(this);
      const x = h.getWritable(), E = this.getIndexWithinParent();
      v ? (x.splice(E, 0, y), this.remove()) : x.splice(E, 1, y), ie(U) && Yp(U, h, E, o - 1);
    }
    return y;
  }
  mergeWithSibling(t) {
    const n = t === this.getPreviousSibling();
    n || t === this.getNextSibling() || Ce(50);
    const r = this.__key, i = t.__key, a = this.__text, l = a.length;
    Qs() === i && kr(r);
    const s = se();
    if (ie(s)) {
      const u = s.anchor, h = s.focus;
      u !== null && u.key === i && (J9(u, n, r, t, l), s.dirty = !0), h !== null && h.key === i && (J9(h, n, r, t, l), s.dirty = !0);
    }
    const c = t.__text, d = n ? c + a : a + c;
    this.setTextContent(d);
    const o = this.getWritable();
    return t.remove(), o;
  }
  isTextEntity() {
    return !1;
  }
};
function I$(e) {
  return { forChild: W3(e.style), node: null };
}
function A$(e) {
  const t = e, n = t.style.fontWeight === "normal";
  return { forChild: W3(t.style, n ? void 0 : "bold"), node: null };
}
const X9 = /* @__PURE__ */ new WeakMap();
function N$(e) {
  return e.nodeName === "PRE" || e.nodeType === Uf && e.style !== void 0 && e.style.whiteSpace !== void 0 && e.style.whiteSpace.startsWith("pre");
}
function D$(e) {
  const t = e;
  e.parentElement === null && Ce(129);
  let n = t.textContent || "";
  if (function(r) {
    let i, a = r.parentNode;
    const l = [r];
    for (; a !== null && (i = X9.get(a)) === void 0 && !N$(a); ) l.push(a), a = a.parentNode;
    const s = i === void 0 ? a : i;
    for (let c = 0; c < l.length; c++) X9.set(l[c], s);
    return s;
  }(t) !== null) {
    const r = n.split(/(\r?\n|\t)/), i = [], a = r.length;
    for (let l = 0; l < a; l++) {
      const s = r[l];
      s === `
` || s === `\r
` ? i.push(hs()) : s === "	" ? i.push($0()) : s !== "" && i.push(un(s));
    }
    return { node: i };
  }
  if (n = n.replace(/\r/g, "").replace(/[ \t\n]+/g, " "), n === "") return { node: null };
  if (n[0] === " ") {
    let r = t, i = !0;
    for (; r !== null && (r = V9(r, !1)) !== null; ) {
      const a = r.textContent || "";
      if (a.length > 0) {
        /[ \t\n]$/.test(a) && (n = n.slice(1)), i = !1;
        break;
      }
    }
    i && (n = n.slice(1));
  }
  if (n[n.length - 1] === " ") {
    let r = t, i = !0;
    for (; r !== null && (r = V9(r, !0)) !== null; )
      if ((r.textContent || "").replace(/^( |\t|\r?\n)+/, "").length > 0) {
        i = !1;
        break;
      }
    i && (n = n.slice(0, n.length - 1));
  }
  return n === "" ? { node: null } : { node: un(n) };
}
function V9(e, t) {
  let n = e;
  for (; ; ) {
    let r;
    for (; (r = t ? n.nextSibling : n.previousSibling) === null; ) {
      const a = n.parentElement;
      if (a === null) return null;
      n = a;
    }
    if (n = r, n.nodeType === Uf) {
      const a = n.style.display;
      if (a === "" && !e4(n) || a !== "" && !a.startsWith("inline")) return null;
    }
    let i = n;
    for (; (i = t ? n.firstChild : n.lastChild) !== null; ) n = i;
    if (n.nodeType === No) return n;
    if (n.nodeName === "BR") return null;
  }
}
const L$ = { code: "code", em: "italic", i: "italic", s: "strikethrough", strong: "bold", sub: "subscript", sup: "superscript", u: "underline" };
function Rs(e) {
  const t = L$[e.nodeName.toLowerCase()];
  return t === void 0 ? { node: null } : { forChild: W3(e.style, t), node: null };
}
function un(e = "") {
  return En(new aa(e));
}
function ce(e) {
  return e instanceof aa;
}
function W3(e, t) {
  const n = e.fontWeight, r = e.textDecoration.split(" "), i = n === "700" || n === "bold", a = r.includes("line-through"), l = e.fontStyle === "italic", s = r.includes("underline"), c = e.verticalAlign;
  return (d) => (ce(d) && (i && !d.hasFormat("bold") && d.toggleFormat("bold"), a && !d.hasFormat("strikethrough") && d.toggleFormat("strikethrough"), l && !d.hasFormat("italic") && d.toggleFormat("italic"), s && !d.hasFormat("underline") && d.toggleFormat("underline"), c !== "sub" || d.hasFormat("subscript") || d.toggleFormat("subscript"), c !== "super" || d.hasFormat("superscript") || d.toggleFormat("superscript"), t && !d.hasFormat(t) && d.toggleFormat(t)), d);
}
let X3 = class jk extends aa {
  static getType() {
    return "tab";
  }
  static clone(t) {
    return new jk(t.__key);
  }
  afterCloneFrom(t) {
    super.afterCloneFrom(t), this.__text = t.__text;
  }
  constructor(t) {
    super("	", t), this.__detail = 2;
  }
  static importDOM() {
    return null;
  }
  static importJSON(t) {
    const n = $0();
    return n.setFormat(t.format), n.setStyle(t.style), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), type: "tab", version: 1 };
  }
  setTextContent(t) {
    Ce(126);
  }
  setDetail(t) {
    Ce(127);
  }
  setMode(t) {
    Ce(128);
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
};
function $0() {
  return En(new X3());
}
function V3(e) {
  return e instanceof X3;
}
let R$ = class {
  constructor(t, n, r) {
    this._selection = null, this.key = t, this.offset = n, this.type = r;
  }
  is(t) {
    return this.key === t.key && this.offset === t.offset && this.type === t.type;
  }
  isBefore(t) {
    let n = this.getNode(), r = t.getNode();
    const i = this.offset, a = t.offset;
    if (re(n)) {
      const l = n.getDescendantByIndex(i);
      n = l ?? n;
    }
    if (re(r)) {
      const l = r.getDescendantByIndex(a);
      r = l ?? r;
    }
    return n === r ? i < a : n.isBefore(r);
  }
  getNode() {
    const t = Rt(this.key);
    return t === null && Ce(20), t;
  }
  set(t, n, r) {
    const i = this._selection, a = this.key;
    this.key = t, this.offset = n, this.type = r, B0() || (Qs() === a && kr(t), i !== null && (i.setCachedNodes(null), i.dirty = !0));
  }
};
function qi(e, t, n) {
  return new R$(e, t, n);
}
function j2(e, t) {
  let n = t.__key, r = e.offset, i = "element";
  if (ce(t)) {
    i = "text";
    const a = t.getTextContentSize();
    r > a && (r = a);
  } else if (!re(t)) {
    const a = t.getNextSibling();
    if (ce(a)) n = a.__key, r = 0, i = "text";
    else {
      const l = t.getParent();
      l && (n = l.__key, r = t.getIndexWithinParent() + 1);
    }
  }
  e.set(n, r, i);
}
function G9(e, t) {
  if (re(t)) {
    const n = t.getLastDescendant();
    re(n) || ce(n) ? j2(e, n) : j2(e, t);
  } else j2(e, t);
}
function Ys(e, t, n, r) {
  e.key = t, e.offset = n, e.type = r;
}
let Kk = class Yk {
  constructor(t) {
    this._cachedNodes = null, this._nodes = t, this.dirty = !1;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(t) {
    this._cachedNodes = t;
  }
  is(t) {
    if (!Xn(t)) return !1;
    const n = this._nodes, r = t._nodes;
    return n.size === r.size && Array.from(n).every((i) => r.has(i));
  }
  isCollapsed() {
    return !1;
  }
  isBackward() {
    return !1;
  }
  getStartEndPoints() {
    return null;
  }
  add(t) {
    this.dirty = !0, this._nodes.add(t), this._cachedNodes = null;
  }
  delete(t) {
    this.dirty = !0, this._nodes.delete(t), this._cachedNodes = null;
  }
  clear() {
    this.dirty = !0, this._nodes.clear(), this._cachedNodes = null;
  }
  has(t) {
    return this._nodes.has(t);
  }
  clone() {
    return new Yk(new Set(this._nodes));
  }
  extract() {
    return this.getNodes();
  }
  insertRawText(t) {
  }
  insertText() {
  }
  insertNodes(t) {
    const n = this.getNodes(), r = n.length, i = n[r - 1];
    let a;
    if (ce(i)) a = i.select();
    else {
      const l = i.getIndexWithinParent() + 1;
      a = i.getParentOrThrow().select(l, l);
    }
    a.insertNodes(t);
    for (let l = 0; l < r; l++) n[l].remove();
  }
  getNodes() {
    const t = this._cachedNodes;
    if (t !== null) return t;
    const n = this._nodes, r = [];
    for (const i of n) {
      const a = Rt(i);
      a !== null && r.push(a);
    }
    return B0() || (this._cachedNodes = r), r;
  }
  getTextContent() {
    const t = this.getNodes();
    let n = "";
    for (let r = 0; r < t.length; r++) n += t[r].getTextContent();
    return n;
  }
};
function ie(e) {
  return e instanceof F0;
}
let F0 = class qk {
  constructor(t, n, r, i) {
    this.anchor = t, this.focus = n, t._selection = this, n._selection = this, this._cachedNodes = null, this.format = r, this.style = i, this.dirty = !1;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(t) {
    this._cachedNodes = t;
  }
  is(t) {
    return !!ie(t) && this.anchor.is(t.anchor) && this.focus.is(t.focus) && this.format === t.format && this.style === t.style;
  }
  isCollapsed() {
    return this.anchor.is(this.focus);
  }
  getNodes() {
    const t = this._cachedNodes;
    if (t !== null) return t;
    const n = this.anchor, r = this.focus, i = n.isBefore(r), a = i ? n : r, l = i ? r : n;
    let s = a.getNode(), c = l.getNode();
    const d = a.offset, o = l.offset;
    if (re(s)) {
      const h = s.getDescendantByIndex(d);
      s = h ?? s;
    }
    if (re(c)) {
      let h = c.getDescendantByIndex(o);
      h !== null && h !== s && c.getChildAtIndex(o) === h && (h = h.getPreviousSibling()), c = h ?? c;
    }
    let u;
    return u = s.is(c) ? re(s) && s.getChildrenSize() > 0 ? [] : [s] : s.getNodesBetween(c), B0() || (this._cachedNodes = u), u;
  }
  setTextNodeRange(t, n, r, i) {
    Ys(this.anchor, t.__key, n, "text"), Ys(this.focus, r.__key, i, "text"), this._cachedNodes = null, this.dirty = !0;
  }
  getTextContent() {
    const t = this.getNodes();
    if (t.length === 0) return "";
    const n = t[0], r = t[t.length - 1], i = this.anchor, a = this.focus, l = i.isBefore(a), [s, c] = h4(this);
    let d = "", o = !0;
    for (let u = 0; u < t.length; u++) {
      const h = t[u];
      if (re(h) && !h.isInline()) o || (d += `
`), o = !h.isEmpty();
      else if (o = !1, ce(h)) {
        let f = h.getTextContent();
        h === n ? h === r ? i.type === "element" && a.type === "element" && a.offset !== i.offset || (f = s < c ? f.slice(s, c) : f.slice(c, s)) : f = l ? f.slice(s) : f.slice(c) : h === r && (f = l ? f.slice(0, c) : f.slice(0, s)), d += f;
      } else !Ft(h) && !Ca(h) || h === r && this.isCollapsed() || (d += h.getTextContent());
    }
    return d;
  }
  applyDOMRange(t) {
    const n = Fn(), r = n.getEditorState()._selection, i = Jk(t.startContainer, t.startOffset, t.endContainer, t.endOffset, n, r);
    if (i === null) return;
    const [a, l] = i;
    Ys(this.anchor, a.key, a.offset, a.type), Ys(this.focus, l.key, l.offset, l.type), this._cachedNodes = null;
  }
  clone() {
    const t = this.anchor, n = this.focus;
    return new qk(qi(t.key, t.offset, t.type), qi(n.key, n.offset, n.type), this.format, this.style);
  }
  toggleFormat(t) {
    this.format = zp(this.format, t, null), this.dirty = !0;
  }
  setStyle(t) {
    this.style = t, this.dirty = !0;
  }
  hasFormat(t) {
    const n = Mi[t];
    return !!(this.format & n);
  }
  insertRawText(t) {
    const n = t.split(/(\r?\n|\t)/), r = [], i = n.length;
    for (let a = 0; a < i; a++) {
      const l = n[a];
      l === `
` || l === `\r
` ? r.push(hs()) : l === "	" ? r.push($0()) : r.push(un(l));
    }
    this.insertNodes(r);
  }
  insertText(t) {
    const n = this.anchor, r = this.focus, i = this.format, a = this.style;
    let l = n, s = r;
    !this.isCollapsed() && r.isBefore(n) && (l = r, s = n), l.type === "element" && function(b, v, U, y) {
      const w = b.getNode(), x = w.getChildAtIndex(b.offset), E = un(), S = Xr(w) ? He().append(E) : E;
      E.setFormat(U), E.setStyle(y), x === null ? w.append(S) : x.insertBefore(S), b.is(v) && v.set(E.__key, 0, "text"), b.set(E.__key, 0, "text");
    }(l, s, i, a);
    const c = l.offset;
    let d = s.offset;
    const o = this.getNodes(), u = o.length;
    let h = o[0];
    ce(h) || Ce(26);
    const f = h.getTextContent().length, p = h.getParentOrThrow();
    let g = o[u - 1];
    if (u === 1 && s.type === "element" && (d = f, s.set(l.key, d, "text")), this.isCollapsed() && c === f && (h.isSegmented() || h.isToken() || !h.canInsertTextAfter() || !p.canInsertTextAfter() && h.getNextSibling() === null)) {
      let b = h.getNextSibling();
      if (ce(b) && b.canInsertTextBefore() && !al(b) || (b = un(), b.setFormat(i), b.setStyle(a), p.canInsertTextAfter() ? h.insertAfter(b) : p.insertAfter(b)), b.select(0, 0), h = b, t !== "") return void this.insertText(t);
    } else if (this.isCollapsed() && c === 0 && (h.isSegmented() || h.isToken() || !h.canInsertTextBefore() || !p.canInsertTextBefore() && h.getPreviousSibling() === null)) {
      let b = h.getPreviousSibling();
      if (ce(b) && !al(b) || (b = un(), b.setFormat(i), p.canInsertTextBefore() ? h.insertBefore(b) : p.insertBefore(b)), b.select(), h = b, t !== "") return void this.insertText(t);
    } else if (h.isSegmented() && c !== f) {
      const b = un(h.getTextContent());
      b.setFormat(i), h.replace(b), h = b;
    } else if (!this.isCollapsed() && t !== "") {
      const b = g.getParent();
      if (!p.canInsertTextBefore() || !p.canInsertTextAfter() || re(b) && (!b.canInsertTextBefore() || !b.canInsertTextAfter())) return this.insertText(""), Zk(this.anchor, this.focus, null), void this.insertText(t);
    }
    if (u === 1) {
      if (h.isToken()) {
        const y = un(t);
        return y.select(), void h.replace(y);
      }
      const b = h.getFormat(), v = h.getStyle();
      if (c !== d || b === i && v === a) {
        if (V3(h)) {
          const y = un(t);
          return y.setFormat(i), y.setStyle(a), y.select(), void h.replace(y);
        }
      } else {
        if (h.getTextContent() !== "") {
          const y = un(t);
          if (y.setFormat(i), y.setStyle(a), y.select(), c === 0) h.insertBefore(y, !1);
          else {
            const [w] = h.splitText(c);
            w.insertAfter(y, !1);
          }
          return void (y.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= t.length));
        }
        h.setFormat(i), h.setStyle(a);
      }
      const U = d - c;
      h = h.spliceText(c, U, t, !0), h.getTextContent() === "" ? h.remove() : this.anchor.type === "text" && (h.isComposing() ? this.anchor.offset -= t.length : (this.format = b, this.style = v));
    } else {
      const b = /* @__PURE__ */ new Set([...h.getParentKeys(), ...g.getParentKeys()]), v = re(h) ? h : h.getParentOrThrow();
      let U = re(g) ? g : g.getParentOrThrow(), y = g;
      if (!v.is(U) && U.isInline()) do
        y = U, U = U.getParentOrThrow();
      while (U.isInline());
      if (s.type === "text" && (d !== 0 || g.getTextContent() === "") || s.type === "element" && g.getIndexWithinParent() < d) if (ce(g) && !g.isToken() && d !== g.getTextContentSize()) {
        if (g.isSegmented()) {
          const _ = un(g.getTextContent());
          g.replace(_), g = _;
        }
        Xr(s.getNode()) || s.type !== "text" || (g = g.spliceText(0, d, "")), b.add(g.__key);
      } else {
        const _ = g.getParentOrThrow();
        _.canBeEmpty() || _.getChildrenSize() !== 1 ? g.remove() : _.remove();
      }
      else b.add(g.__key);
      const w = U.getChildren(), x = new Set(o), E = v.is(U), S = v.isInline() && h.getNextSibling() === null ? v : h;
      for (let _ = w.length - 1; _ >= 0; _--) {
        const k = w[_];
        if (k.is(h) || re(k) && k.isParentOf(h)) break;
        k.isAttached() && (!x.has(k) || k.is(y) ? E || S.insertAfter(k, !1) : k.remove());
      }
      if (!E) {
        let _ = U, k = null;
        for (; _ !== null; ) {
          const M = _.getChildren(), A = M.length;
          (A === 0 || M[A - 1].is(k)) && (b.delete(_.__key), k = _), _ = _.getParent();
        }
      }
      if (h.isToken()) if (c === f) h.select();
      else {
        const _ = un(t);
        _.select(), h.replace(_);
      }
      else h = h.spliceText(c, f - c, t, !0), h.getTextContent() === "" ? h.remove() : h.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= t.length);
      for (let _ = 1; _ < u; _++) {
        const k = o[_], M = k.__key;
        b.has(M) || k.remove();
      }
    }
  }
  removeText() {
    if (this.isCollapsed()) return;
    const { anchor: t, focus: n } = this, r = this.getNodes(), i = this.isBackward() ? n : t, a = this.isBackward() ? t : n;
    let l = i.getNode(), s = a.getNode();
    const c = hu(l, Ws), d = hu(s, Ws);
    ce(l) && l.isToken() && i.offset < l.getTextContentSize() && (i.offset = 0), a.offset > 0 && ce(s) && s.isToken() && (a.offset = s.getTextContentSize()), r.forEach((u) => {
      nh(l, u) || nh(s, u) || u.getKey() === l.getKey() || u.getKey() === s.getKey() || u.remove();
    });
    const o = (u, h) => {
      if (u.getTextContent() === "") u.remove();
      else if (h !== 0 && al(u)) {
        const f = un(u.getTextContent());
        return f.setFormat(u.getFormat()), f.setStyle(u.getStyle()), u.replace(f);
      }
    };
    if (l === s && ce(l)) {
      const u = Math.abs(n.offset - t.offset);
      return l.spliceText(i.offset, u, "", !0), void o(l, u);
    }
    if (ce(l)) {
      const u = l.getTextContentSize() - i.offset;
      l.spliceText(i.offset, u, ""), l = o(l, u) || l;
    }
    ce(s) && (s.spliceText(0, a.offset, ""), s = o(s, a.offset) || s), l.isAttached() && ce(l) ? l.selectEnd() : s.isAttached() && ce(s) && s.selectStart(), re(c) && re(d) && c !== d && (c.append(...d.getChildren()), d.remove(), a.set(i.key, i.offset, i.type));
  }
  formatText(t, n = null) {
    if (this.isCollapsed()) return this.toggleFormat(t), void kr(null);
    const r = this.getNodes(), i = [];
    for (const w of r) ce(w) && i.push(w);
    const a = (w) => {
      r.forEach((x) => {
        if (La(x)) {
          const E = x.getFormatFlags(t, w);
          x.setTextFormat(E);
        }
      });
    }, l = i.length;
    if (l === 0) return this.toggleFormat(t), kr(null), void a(n);
    const s = this.anchor, c = this.focus, d = this.isBackward(), o = d ? c : s, u = d ? s : c;
    let h = 0, f = i[0], p = o.type === "element" ? 0 : o.offset;
    if (o.type === "text" && p === f.getTextContentSize() && (h = 1, f = i[1], p = 0), f == null) return;
    const g = f.getFormatFlags(t, n);
    a(g);
    const b = l - 1;
    let v = i[b];
    const U = u.type === "text" ? u.offset : v.getTextContentSize();
    if (f.is(v)) {
      if (p === U) return;
      if (al(f) || p === 0 && U === f.getTextContentSize()) f.setFormat(g);
      else {
        const w = f.splitText(p, U), x = p === 0 ? w[0] : w[1];
        x.setFormat(g), o.type === "text" && o.set(x.__key, 0, "text"), u.type === "text" && u.set(x.__key, U - p, "text");
      }
      return void (this.format = g);
    }
    p === 0 || al(f) || ([, f] = f.splitText(p), p = 0), f.setFormat(g);
    const y = v.getFormatFlags(t, g);
    U > 0 && (U === v.getTextContentSize() || al(v) || ([v] = v.splitText(U)), v.setFormat(y));
    for (let w = h + 1; w < b; w++) {
      const x = i[w], E = x.getFormatFlags(t, y);
      x.setFormat(E);
    }
    o.type === "text" && o.set(f.__key, p, "text"), u.type === "text" && u.set(v.__key, U, "text"), this.format = g | y;
  }
  insertNodes(t) {
    if (t.length === 0) return;
    if (this.anchor.key === "root") {
      this.insertParagraph();
      const p = se();
      return ie(p) || Ce(134), p.insertNodes(t);
    }
    const n = (this.isBackward() ? this.focus : this.anchor).getNode(), r = hu(n, Ws), i = t[t.length - 1];
    if (re(r) && "__language" in r) {
      if ("__language" in t[0]) this.insertText(t[0].getTextContent());
      else {
        const p = K2(this);
        r.splice(p, 0, t), i.selectEnd();
      }
      return;
    }
    if (!t.some((p) => (re(p) || Ft(p)) && !p.isInline())) {
      re(r) || Ce(211, n.constructor.name, n.getType());
      const p = K2(this);
      return r.splice(p, 0, t), void i.selectEnd();
    }
    const a = function(p) {
      const g = He();
      let b = null;
      for (let v = 0; v < p.length; v++) {
        const U = p[v], y = Ca(U);
        if (y || Ft(U) && U.isInline() || re(U) && U.isInline() || ce(U) || U.isParentRequired()) {
          if (b === null && (b = U.createParentElementNode(), g.append(b), y)) continue;
          b !== null && b.append(U);
        } else g.append(U), b = null;
      }
      return g;
    }(t), l = a.getLastDescendant(), s = a.getChildren(), c = !re(r) || !r.isEmpty() ? this.insertParagraph() : null, d = s[s.length - 1];
    let o = s[0];
    var u;
    re(u = o) && Ws(u) && !u.isEmpty() && re(r) && (!r.isEmpty() || r.canMergeWhenEmpty()) && (re(r) || Ce(211, n.constructor.name, n.getType()), r.append(...o.getChildren()), o = s[1]), o && (r === null && Ce(212, n.constructor.name, n.getType()), function(p, g, b) {
      const v = g.getParentOrThrow().getLastChild();
      let U = g;
      const y = [g];
      for (; U !== v; ) U.getNextSibling() || Ce(140), U = U.getNextSibling(), y.push(U);
      let w = p;
      for (const x of y) w = w.insertAfter(x);
    }(r, o));
    const h = hu(l, Ws);
    c && re(h) && (c.canMergeWhenEmpty() || Ws(d)) && (h.append(...c.getChildren()), c.remove()), re(r) && r.isEmpty() && r.remove(), l.selectEnd();
    const f = re(r) ? r.getLastChild() : null;
    Ca(f) && h !== r && f.remove();
  }
  insertParagraph() {
    if (this.anchor.key === "root") {
      const l = He();
      return Bt().splice(this.anchor.offset, 0, [l]), l.select(), l;
    }
    const t = K2(this), n = hu(this.anchor.getNode(), Ws);
    re(n) || Ce(213);
    const r = n.getChildAtIndex(t), i = r ? [r, ...r.getNextSiblings()] : [], a = n.insertNewAfter(this, !1);
    return a ? (a.append(...i), a.selectStart(), a) : null;
  }
  insertLineBreak(t) {
    const n = hs();
    if (this.insertNodes([n]), t) {
      const r = n.getParentOrThrow(), i = n.getIndexWithinParent();
      r.select(i, i);
    }
  }
  extract() {
    const t = this.getNodes(), n = t.length, r = n - 1, i = this.anchor, a = this.focus;
    let l = t[0], s = t[r];
    const [c, d] = h4(this);
    if (n === 0) return [];
    if (n === 1) {
      if (ce(l) && !this.isCollapsed()) {
        const u = c > d ? d : c, h = c > d ? c : d, f = l.splitText(u, h), p = u === 0 ? f[0] : f[1];
        return p != null ? [p] : [];
      }
      return [l];
    }
    const o = i.isBefore(a);
    if (ce(l)) {
      const u = o ? c : d;
      u === l.getTextContentSize() ? t.shift() : u !== 0 && ([, l] = l.splitText(u), t[0] = l);
    }
    if (ce(s)) {
      const u = s.getTextContent().length, h = o ? d : c;
      h === 0 ? t.pop() : h !== u && ([s] = s.splitText(h), t[r] = s);
    }
    return t;
  }
  modify(t, n, r) {
    const i = this.focus, a = this.anchor, l = t === "move", s = Ch(i, n);
    if (Ft(s) && !s.isIsolated()) {
      if (l && s.isKeyboardSelectable()) {
        const f = f4();
        return f.add(s.__key), void pn(f);
      }
      const h = n ? s.getPreviousSibling() : s.getNextSibling();
      if (ce(h)) {
        const f = h.__key, p = n ? h.getTextContent().length : 0;
        return i.set(f, p, "text"), void (l && a.set(f, p, "text"));
      }
      {
        const f = s.getParentOrThrow();
        let p, g;
        return re(h) ? (g = h.__key, p = n ? h.getChildrenSize() : 0) : (p = s.getIndexWithinParent(), g = f.__key, n || p++), i.set(g, p, "element"), void (l && a.set(g, p, "element"));
      }
    }
    const c = Fn(), d = wl(c._window);
    if (!d) return;
    const o = c._blockCursorElement, u = c._rootElement;
    if (u === null || o === null || !re(s) || s.isInline() || s.canBeEmpty() || F3(o, c, u), function(h, f, p, g) {
      h.modify(f, p, g);
    }(d, t, n ? "backward" : "forward", r), d.rangeCount > 0) {
      const h = d.getRangeAt(0), f = this.anchor.getNode(), p = Xr(f) ? f : U$(f);
      if (this.applyDOMRange(h), this.dirty = !0, !l) {
        const g = this.getNodes(), b = [];
        let v = !1;
        for (let U = 0; U < g.length; U++) {
          const y = g[U];
          nh(y, p) ? b.push(y) : v = !0;
        }
        if (v && b.length > 0) if (n) {
          const U = b[0];
          re(U) ? U.selectStart() : U.getParentOrThrow().selectStart();
        } else {
          const U = b[b.length - 1];
          re(U) ? U.selectEnd() : U.getParentOrThrow().selectEnd();
        }
        d.anchorNode === h.startContainer && d.anchorOffset === h.startOffset || function(U) {
          const y = U.focus, w = U.anchor, x = w.key, E = w.offset, S = w.type;
          Ys(w, y.key, y.offset, y.type), Ys(y, x, E, S), U._cachedNodes = null;
        }(this);
      }
    }
  }
  forwardDeletion(t, n, r) {
    if (!r && (t.type === "element" && re(n) && t.offset === n.getChildrenSize() || t.type === "text" && t.offset === n.getTextContentSize())) {
      const i = n.getParent(), a = n.getNextSibling() || (i === null ? null : i.getNextSibling());
      if (re(a) && a.isShadowRoot()) return !0;
    }
    return !1;
  }
  deleteCharacter(t) {
    const n = this.isCollapsed();
    if (this.isCollapsed()) {
      const r = this.anchor;
      let i = r.getNode();
      if (this.forwardDeletion(r, i, t)) return;
      const a = this.focus, l = Ch(a, t);
      if (Ft(l) && !l.isIsolated()) {
        if (l.isKeyboardSelectable() && re(i) && i.getChildrenSize() === 0) {
          i.remove();
          const s = f4();
          s.add(l.__key), pn(s);
        } else
          l.remove(), Fn().dispatchCommand(Ei, void 0);
        return;
      }
      if (!t && re(l) && re(i) && i.isEmpty()) return i.remove(), void l.selectStart();
      if (this.modify("extend", t, "character"), this.isCollapsed()) {
        if (t && r.offset === 0 && (r.type === "element" ? r.getNode() : r.getNode().getParentOrThrow()).collapseAtStart(this))
          return;
      } else {
        const s = a.type === "text" ? a.getNode() : null;
        if (i = r.type === "text" ? r.getNode() : null, s !== null && s.isSegmented()) {
          const c = a.offset, d = s.getTextContentSize();
          if (s.is(i) || t && c !== d || !t && c !== 0) return void K9(s, t, c);
        } else if (i !== null && i.isSegmented()) {
          const c = r.offset, d = i.getTextContentSize();
          if (i.is(s) || t && c !== 0 || !t && c !== d) return void K9(i, t, c);
        }
        (function(c, d) {
          const o = c.anchor, u = c.focus, h = o.getNode(), f = u.getNode();
          if (h === f && o.type === "text" && u.type === "text") {
            const p = o.offset, g = u.offset, b = p < g, v = b ? p : g, U = b ? g : p, y = U - 1;
            v !== y && (Sk(h.getTextContent().slice(v, U)) || (d ? u.offset = y : o.offset = y));
          }
        })(this, t);
      }
    }
    if (this.removeText(), t && !n && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0) {
      const r = this.anchor.getNode();
      r.isEmpty() && Xr(r.getParent()) && r.getIndexWithinParent() === 0 && r.collapseAtStart(this);
    }
  }
  deleteLine(t) {
    if (this.isCollapsed()) {
      const n = this.anchor.type === "element";
      if (n && this.insertText(" "), this.modify("extend", t, "lineboundary"), this.isCollapsed() && this.anchor.offset === 0 && this.modify("extend", t, "character"), n) {
        const r = t ? this.anchor : this.focus;
        r.set(r.key, r.offset + 1, r.type);
      }
    }
    this.removeText();
  }
  deleteWord(t) {
    if (this.isCollapsed()) {
      const n = this.anchor, r = n.getNode();
      if (this.forwardDeletion(n, r, t)) return;
      this.modify("extend", t, "word");
    }
    this.removeText();
  }
  isBackward() {
    return this.focus.isBefore(this.anchor);
  }
  getStartEndPoints() {
    return [this.anchor, this.focus];
  }
};
function Xn(e) {
  return e instanceof Kk;
}
function j9(e) {
  const t = e.offset;
  if (e.type === "text") return t;
  const n = e.getNode();
  return t === n.getChildrenSize() ? n.getTextContent().length : 0;
}
function h4(e) {
  const t = e.getStartEndPoints();
  if (t === null) return [0, 0];
  const [n, r] = t;
  return n.type === "element" && r.type === "element" && n.key === r.key && n.offset === r.offset ? [0, 0] : [j9(n), j9(r)];
}
function K9(e, t, n) {
  const r = e, i = r.getTextContent().split(/(?=\s)/g), a = i.length;
  let l = 0, s = 0;
  for (let d = 0; d < a; d++) {
    const o = d === a - 1;
    if (s = l, l += i[d].length, t && l === n || l > n || o) {
      i.splice(d, 1), o && (s = void 0);
      break;
    }
  }
  const c = i.join("").trim();
  c === "" ? r.remove() : (r.setTextContent(c), r.select(s, s));
}
function Y9(e, t, n, r) {
  let i, a = t;
  if (e.nodeType === Uf) {
    let l = !1;
    const s = e.childNodes, c = s.length, d = r._blockCursorElement;
    a === c && (l = !0, a = c - 1);
    let o = s[a], u = !1;
    if (o === d) o = s[a + 1], u = !0;
    else if (d !== null) {
      const h = d.parentNode;
      e === h && t > Array.prototype.indexOf.call(h.children, d) && a--;
    }
    if (i = Dd(o), ce(i)) a = I9(i, l);
    else {
      let h = Dd(e);
      if (h === null) return null;
      if (re(h)) {
        a = Math.min(h.getChildrenSize(), a);
        let f = h.getChildAtIndex(a);
        if (re(f) && function(p, g, b) {
          const v = p.getParent();
          return b === null || v === null || !v.canBeEmpty() || v !== b.getNode();
        }(f, 0, n)) {
          const p = l ? f.getLastDescendant() : f.getFirstDescendant();
          p === null ? h = f : (f = p, h = re(f) ? f : f.getParentOrThrow()), a = 0;
        }
        ce(f) ? (i = f, h = null, a = I9(f, l)) : f !== h && l && !u && a++;
      } else {
        const f = h.getIndexWithinParent();
        a = t === 0 && Ft(h) && Dd(e) === h ? f : f + 1, h = h.getParentOrThrow();
      }
      if (re(h)) return qi(h.__key, a, "element");
    }
  } else i = Dd(e);
  return ce(i) ? qi(i.__key, a, "text") : null;
}
function q9(e, t, n) {
  const r = e.offset, i = e.getNode();
  if (r === 0) {
    const a = i.getPreviousSibling(), l = i.getParent();
    if (t) {
      if ((n || !t) && a === null && re(l) && l.isInline()) {
        const s = l.getPreviousSibling();
        ce(s) && (e.key = s.__key, e.offset = s.getTextContent().length);
      }
    } else re(a) && !n && a.isInline() ? (e.key = a.__key, e.offset = a.getChildrenSize(), e.type = "element") : ce(a) && (e.key = a.__key, e.offset = a.getTextContent().length);
  } else if (r === i.getTextContent().length) {
    const a = i.getNextSibling(), l = i.getParent();
    if (t && re(a) && a.isInline()) e.key = a.__key, e.offset = 0, e.type = "element";
    else if ((n || t) && a === null && re(l) && l.isInline() && !l.canInsertTextAfter()) {
      const s = l.getNextSibling();
      ce(s) && (e.key = s.__key, e.offset = 0);
    }
  }
}
function Zk(e, t, n) {
  if (e.type === "text" && t.type === "text") {
    const r = e.isBefore(t), i = e.is(t);
    q9(e, r, i), q9(t, !r, i), i && (t.key = e.key, t.offset = e.offset, t.type = e.type);
    const a = Fn();
    if (a.isComposing() && a._compositionKey !== e.key && ie(n)) {
      const l = n.anchor, s = n.focus;
      Ys(e, l.key, l.offset, l.type), Ys(t, s.key, s.offset, s.type);
    }
  }
}
function Jk(e, t, n, r, i, a) {
  if (e === null || n === null || !vf(i, e, n)) return null;
  const l = Y9(e, t, ie(a) ? a.anchor : null, i);
  if (l === null) return null;
  const s = Y9(n, r, ie(a) ? a.focus : null, i);
  if (s === null) return null;
  if (l.type === "element" && s.type === "element") {
    const c = Dd(e), d = Dd(n);
    if (Ft(c) && Ft(d)) return null;
  }
  return Zk(l, s, a), [l, s];
}
function Kp(e) {
  return re(e) && !e.isInline();
}
function Qk(e, t, n, r, i, a) {
  const l = Il(), s = new F0(qi(e, t, i), qi(n, r, a), 0, "");
  return s.dirty = !0, l._selection = s, s;
}
function yf() {
  const e = qi("root", 0, "element"), t = qi("root", 0, "element");
  return new F0(e, t, 0, "");
}
function f4() {
  return new Kk(/* @__PURE__ */ new Set());
}
function P$(e, t) {
  return Sg(null, e, t, null);
}
function Sg(e, t, n, r) {
  const i = n._window;
  if (i === null) return null;
  const a = r || i.event, l = a ? a.type : void 0, s = l === "selectionchange", c = !Q5 && (s || l === "beforeinput" || l === "compositionstart" || l === "compositionend" || l === "click" && a && a.detail === 3 || l === "drop" || l === void 0);
  let d, o, u, h;
  if (ie(e) && !c) return e.clone();
  if (t === null) return null;
  if (d = t.anchorNode, o = t.focusNode, u = t.anchorOffset, h = t.focusOffset, s && ie(e) && !vf(n, d, o)) return e.clone();
  const f = Jk(d, u, o, h, n, e);
  if (f === null) return null;
  const [p, g] = f;
  return new F0(p, g, ie(e) ? e.format : 0, ie(e) ? e.style : "");
}
function se() {
  return Il()._selection;
}
function Do() {
  return Fn()._editorState._selection;
}
function Yp(e, t, n, r = 1) {
  const i = e.anchor, a = e.focus, l = i.getNode(), s = a.getNode();
  if (!t.is(l) && !t.is(s)) return;
  const c = t.__key;
  if (e.isCollapsed()) {
    const d = i.offset;
    if (n <= d && r > 0 || n < d && r < 0) {
      const o = Math.max(0, d + r);
      i.set(c, o, "element"), a.set(c, o, "element"), Z9(e);
    }
  } else {
    const d = e.isBackward(), o = d ? a : i, u = o.getNode(), h = d ? i : a, f = h.getNode();
    if (t.is(u)) {
      const p = o.offset;
      (n <= p && r > 0 || n < p && r < 0) && o.set(c, Math.max(0, p + r), "element");
    }
    if (t.is(f)) {
      const p = h.offset;
      (n <= p && r > 0 || n < p && r < 0) && h.set(c, Math.max(0, p + r), "element");
    }
  }
  Z9(e);
}
function Z9(e) {
  const t = e.anchor, n = t.offset, r = e.focus, i = r.offset, a = t.getNode(), l = r.getNode();
  if (e.isCollapsed()) {
    if (!re(a)) return;
    const s = a.getChildrenSize(), c = n >= s, d = c ? a.getChildAtIndex(s - 1) : a.getChildAtIndex(n);
    if (ce(d)) {
      let o = 0;
      c && (o = d.getTextContentSize()), t.set(d.__key, o, "text"), r.set(d.__key, o, "text");
    }
  } else {
    if (re(a)) {
      const s = a.getChildrenSize(), c = n >= s, d = c ? a.getChildAtIndex(s - 1) : a.getChildAtIndex(n);
      if (ce(d)) {
        let o = 0;
        c && (o = d.getTextContentSize()), t.set(d.__key, o, "text");
      }
    }
    if (re(l)) {
      const s = l.getChildrenSize(), c = i >= s, d = c ? l.getChildAtIndex(s - 1) : l.getChildAtIndex(i);
      if (ce(d)) {
        let o = 0;
        c && (o = d.getTextContentSize()), r.set(d.__key, o, "text");
      }
    }
  }
}
function qp(e, t, n, r, i) {
  let a = null, l = 0, s = null;
  r !== null ? (a = r.__key, ce(r) ? (l = r.getTextContentSize(), s = "text") : re(r) && (l = r.getChildrenSize(), s = "element")) : i !== null && (a = i.__key, ce(i) ? s = "text" : re(i) && (s = "element")), a !== null && s !== null ? e.set(a, l, s) : (l = t.getIndexWithinParent(), l === -1 && (l = n.getChildrenSize()), e.set(n.__key, l, "element"));
}
function J9(e, t, n, r, i) {
  e.type === "text" ? (e.key = n, t || (e.offset += i)) : e.offset > r.getIndexWithinParent() && (e.offset -= 1);
}
function O$(e, t, n, r, i, a, l) {
  const s = r.anchorNode, c = r.focusNode, d = r.anchorOffset, o = r.focusOffset, u = document.activeElement;
  if (i.has("collaboration") && u !== a || u !== null && N3(u)) return;
  if (!ie(t)) return void (e !== null && vf(n, s, c) && r.removeAllRanges());
  const h = t.anchor, f = t.focus, p = h.key, g = f.key, b = Hp(n, p), v = Hp(n, g), U = h.offset, y = f.offset, w = t.format, x = t.style, E = t.isCollapsed();
  let S = b, _ = v, k = !1;
  if (h.type === "text") {
    S = Fp(b);
    const F = h.getNode();
    k = F.getFormat() !== w || F.getStyle() !== x;
  } else ie(e) && e.anchor.type === "text" && (k = !0);
  var M, A, L, R, z;
  if (f.type === "text" && (_ = Fp(v)), S !== null && _ !== null && (E && (e === null || k || ie(e) && (e.format !== w || e.style !== x)) && (M = w, A = x, L = U, R = p, z = performance.now(), $k = [M, A, L, R, z]), d !== U || o !== y || s !== S || c !== _ || r.type === "Range" && E || (u !== null && a.contains(u) || a.focus({ preventScroll: !0 }), h.type === "element"))) {
    try {
      r.setBaseAndExtent(S, U, _, y);
    } catch {
    }
    if (!i.has("skip-scroll-into-view") && t.isCollapsed() && a !== null && a === document.activeElement) {
      const F = t instanceof F0 && t.anchor.type === "element" ? S.childNodes[U] || null : r.rangeCount > 0 ? r.getRangeAt(0) : null;
      if (F !== null) {
        let W;
        if (F instanceof Text) {
          const B = document.createRange();
          B.selectNode(F), W = B.getBoundingClientRect();
        } else W = F.getBoundingClientRect();
        (function(B, j, V) {
          const q = V.ownerDocument, oe = q.defaultView;
          if (oe === null) return;
          let { top: Ue, bottom: fe } = j, Pe = 0, ze = 0, Oe = V;
          for (; Oe !== null; ) {
            const Be = Oe === q.body;
            if (Be) Pe = 0, ze = wg(B).innerHeight;
            else {
              const At = Oe.getBoundingClientRect();
              Pe = At.top, ze = At.bottom;
            }
            let qe = 0;
            if (Ue < Pe ? qe = -(Pe - Ue) : fe > ze && (qe = fe - ze), qe !== 0) if (Be) oe.scrollBy(0, qe);
            else {
              const At = Oe.scrollTop;
              Oe.scrollTop += qe;
              const Je = Oe.scrollTop - At;
              Ue -= Je, fe -= Je;
            }
            if (Be) break;
            Oe = yg(Oe);
          }
        })(n, W, a);
      }
    }
    c4 = !0;
  }
}
function z0(e) {
  let t = se() || Do();
  t === null && (t = Bt().selectEnd()), t.insertNodes(e);
}
function K2(e) {
  let t = e;
  e.isCollapsed() || t.removeText();
  const n = se();
  ie(n) && (t = n), ie(t) || Ce(161);
  const r = t.anchor;
  let i = r.getNode(), a = r.offset;
  for (; !Ws(i); ) [i, a] = $$(i, a);
  return a;
}
function $$(e, t) {
  const n = e.getParent();
  if (!n) {
    const i = He();
    return Bt().append(i), i.select(), [Bt(), 0];
  }
  if (ce(e)) {
    const i = e.splitText(t);
    if (i.length === 0) return [n, e.getIndexWithinParent()];
    const a = t === 0 ? 0 : 1;
    return [n, i[0].getIndexWithinParent() + a];
  }
  if (!re(e) || t === 0) return [n, e.getIndexWithinParent()];
  const r = e.getChildAtIndex(t);
  if (r) {
    const i = new F0(qi(e.__key, t, "element"), qi(e.__key, t, "element"), 0, ""), a = e.insertNewAfter(i);
    a && a.append(r, ...r.getNextSiblings());
  }
  return [n, e.getIndexWithinParent() + 1];
}
let Ur = null, vr = null, ci = !1, Y2 = !1, tp = 0;
const Q9 = { characterData: !0, childList: !0, subtree: !0 };
function B0() {
  return ci || Ur !== null && Ur._readOnly;
}
function ii() {
  ci && Ce(13);
}
function eC() {
  tp > 99 && Ce(14);
}
function Il() {
  return Ur === null && Ce(195, tC()), Ur;
}
function Fn() {
  return vr === null && Ce(196, tC()), vr;
}
function tC() {
  let e = 0;
  const t = /* @__PURE__ */ new Set(), n = kg.version;
  if (typeof window < "u") for (const i of document.querySelectorAll("[contenteditable]")) {
    const a = Ug(i);
    if (D3(a)) e++;
    else if (a) {
      let l = String(a.constructor.version || "<0.17.1");
      l === n && (l += " (separately built, likely a bundler configuration issue)"), t.add(l);
    }
  }
  let r = ` Detected on the page: ${e} compatible editor(s) with version ${n}`;
  return t.size && (r += ` and incompatible editors with versions ${Array.from(t).join(", ")}`), r;
}
function F$() {
  return vr;
}
function ev(e, t, n) {
  const r = t.__type, i = function(s, c) {
    const d = s._nodes.get(c);
    return d === void 0 && Ce(30, c), d;
  }(e, r);
  let a = n.get(r);
  a === void 0 && (a = Array.from(i.transforms), n.set(r, a));
  const l = a.length;
  for (let s = 0; s < l && (a[s](t), t.isAttached()); s++) ;
}
function tv(e, t) {
  return e !== void 0 && e.__key !== t && e.isAttached();
}
function nC(e, t) {
  if (!t) return;
  const n = e._updateTags;
  let r = t;
  Array.isArray(t) || (r = [t]);
  for (const i of r) n.add(i);
}
function z$(e) {
  return G3(e, Fn()._nodes);
}
function G3(e, t) {
  const n = e.type, r = t.get(n);
  r === void 0 && Ce(17, n);
  const i = r.klass;
  e.type !== i.getType() && Ce(18, i.name);
  const a = i.importJSON(e), l = e.children;
  if (re(a) && Array.isArray(l)) for (let s = 0; s < l.length; s++) {
    const c = G3(l[s], t);
    a.append(c);
  }
  return a;
}
function nv(e, t, n) {
  const r = Ur, i = ci, a = vr;
  Ur = t, ci = !0, vr = e;
  try {
    return n();
  } finally {
    Ur = r, ci = i, vr = a;
  }
}
function eo(e, t) {
  const n = e._pendingEditorState, r = e._rootElement, i = e._headless || r === null;
  if (n === null) return;
  const a = e._editorState, l = a._selection, s = n._selection, c = e._dirtyType !== Mc, d = Ur, o = ci, u = vr, h = e._updating, f = e._observer;
  let p = null;
  if (e._pendingEditorState = null, e._editorState = n, !i && c && f !== null) {
    vr = e, Ur = n, ci = !1, e._updating = !0;
    try {
      const E = e._dirtyType, S = e._dirtyElements, _ = e._dirtyLeaves;
      f.disconnect(), p = C$(a, n, e, E, S, _);
    } catch (E) {
      if (E instanceof Error && e._onError(E), Y2) throw E;
      return dC(e, null, r, n), Uk(e), e._dirtyType = l0, Y2 = !0, eo(e, a), void (Y2 = !1);
    } finally {
      f.observe(r, Q9), e._updating = h, Ur = d, ci = o, vr = u;
    }
  }
  n._readOnly || (n._readOnly = !0);
  const g = e._dirtyLeaves, b = e._dirtyElements, v = e._normalizedNodes, U = e._updateTags, y = e._deferred;
  c && (e._dirtyType = Mc, e._cloneNotNeeded.clear(), e._dirtyLeaves = /* @__PURE__ */ new Set(), e._dirtyElements = /* @__PURE__ */ new Map(), e._normalizedNodes = /* @__PURE__ */ new Set(), e._updateTags = /* @__PURE__ */ new Set()), function(E, S) {
    const _ = E._decorators;
    let k = E._pendingDecorators || _;
    const M = S._nodeMap;
    let A;
    for (A in k) M.has(A) || (k === _ && (k = xk(E)), delete k[A]);
  }(e, n);
  const w = i ? null : wl(e._window);
  if (e._editable && w !== null && (c || s === null || s.dirty)) {
    vr = e, Ur = n;
    try {
      if (f !== null && f.disconnect(), c || s === null || s.dirty) {
        const E = e._blockCursorElement;
        E !== null && F3(E, e, r), O$(l, s, e, w, U, r);
      }
      y$(e, r, s), f !== null && f.observe(r, Q9);
    } finally {
      vr = u, Ur = d;
    }
  }
  p !== null && function(E, S, _, k, M) {
    const A = Array.from(E._listeners.mutation), L = A.length;
    for (let R = 0; R < L; R++) {
      const [z, F] = A[R], W = S.get(F);
      W !== void 0 && z(W, { dirtyLeaves: k, prevEditorState: M, updateTags: _ });
    }
  }(e, p, U, g, a), ie(s) || s === null || l !== null && l.is(s) || e.dispatchCommand(Ei, void 0);
  const x = e._pendingDecorators;
  x !== null && (e._decorators = x, e._pendingDecorators = null, ah("decorator", e, !0, x)), function(E, S, _) {
    const k = T9(S), M = T9(_);
    k !== M && ah("textcontent", E, !0, M);
  }(e, t || a, n), ah("update", e, !0, { dirtyElements: b, dirtyLeaves: g, editorState: n, normalizedNodes: v, prevEditorState: t || a, tags: U }), function(E, S) {
    if (E._deferred = [], S.length !== 0) {
      const _ = E._updating;
      E._updating = !0;
      try {
        for (let k = 0; k < S.length; k++) S[k]();
      } finally {
        E._updating = _;
      }
    }
  }(e, y), function(E) {
    const S = E._updates;
    if (S.length !== 0) {
      const _ = S.shift();
      if (_) {
        const [k, M] = _;
        iC(E, k, M);
      }
    }
  }(e);
}
function ah(e, t, n, ...r) {
  const i = t._updating;
  t._updating = n;
  try {
    const a = Array.from(t._listeners[e]);
    for (let l = 0; l < a.length; l++) a[l].apply(null, r);
  } finally {
    t._updating = i;
  }
}
function rC(e, t, n) {
  if (e._updating === !1 || vr !== e) {
    let i = !1;
    return e.update(() => {
      i = rC(e, t, n);
    }), i;
  }
  const r = R3(e);
  for (let i = 4; i >= 0; i--) for (let a = 0; a < r.length; a++) {
    const l = r[a]._commands.get(t);
    if (l !== void 0) {
      const s = l[i];
      if (s !== void 0) {
        const c = Array.from(s), d = c.length;
        for (let o = 0; o < d; o++) if (c[o](n, e) === !0) return !0;
      }
    }
  }
  return !1;
}
function rv(e, t) {
  const n = e._updates;
  let r = t || !1;
  for (; n.length !== 0; ) {
    const i = n.shift();
    if (i) {
      const [a, l] = i;
      let s;
      if (l !== void 0) {
        if (s = l.onUpdate, l.skipTransforms && (r = !0), l.discrete) {
          const c = e._pendingEditorState;
          c === null && Ce(191), c._flushSync = !0;
        }
        s && e._deferred.push(s), nC(e, l.tag);
      }
      a();
    }
  }
  return r;
}
function iC(e, t, n) {
  const r = e._updateTags;
  let i, a = !1, l = !1;
  n !== void 0 && (i = n.onUpdate, nC(e, n.tag), a = n.skipTransforms || !1, l = n.discrete || !1), i && e._deferred.push(i);
  const s = e._editorState;
  let c = e._pendingEditorState, d = !1;
  (c === null || c._readOnly) && (c = e._pendingEditorState = new sC(new Map((c || s)._nodeMap)), d = !0), c._flushSync = l;
  const o = Ur, u = ci, h = vr, f = e._updating;
  Ur = c, ci = !1, e._updating = !0, vr = e;
  try {
    d && (e._headless ? s._selection !== null && (c._selection = s._selection.clone()) : c._selection = function(v) {
      const U = v.getEditorState()._selection, y = wl(v._window);
      return ie(U) || U == null ? Sg(U, y, v, null) : U.clone();
    }(e));
    const g = e._compositionKey;
    t(), a = rv(e, a), function(v, U) {
      const y = U.getEditorState()._selection, w = v._selection;
      if (ie(w)) {
        const x = w.anchor, E = w.focus;
        let S;
        if (x.type === "text" && (S = x.getNode(), S.selectionTransform(y, w)), E.type === "text") {
          const _ = E.getNode();
          S !== _ && _.selectionTransform(y, w);
        }
      }
    }(c, e), e._dirtyType !== Mc && (a ? function(v, U) {
      const y = U._dirtyLeaves, w = v._nodeMap;
      for (const x of y) {
        const E = w.get(x);
        ce(E) && E.isAttached() && E.isSimpleText() && !E.isUnmergeable() && C9(E);
      }
    }(c, e) : function(v, U) {
      const y = U._dirtyLeaves, w = U._dirtyElements, x = v._nodeMap, E = Qs(), S = /* @__PURE__ */ new Map();
      let _ = y, k = _.size, M = w, A = M.size;
      for (; k > 0 || A > 0; ) {
        if (k > 0) {
          U._dirtyLeaves = /* @__PURE__ */ new Set();
          for (const L of _) {
            const R = x.get(L);
            ce(R) && R.isAttached() && R.isSimpleText() && !R.isUnmergeable() && C9(R), R !== void 0 && tv(R, E) && ev(U, R, S), y.add(L);
          }
          if (_ = U._dirtyLeaves, k = _.size, k > 0) {
            tp++;
            continue;
          }
        }
        U._dirtyLeaves = /* @__PURE__ */ new Set(), U._dirtyElements = /* @__PURE__ */ new Map();
        for (const L of M) {
          const R = L[0], z = L[1];
          if (R !== "root" && !z) continue;
          const F = x.get(R);
          F !== void 0 && tv(F, E) && ev(U, F, S), w.set(R, z);
        }
        _ = U._dirtyLeaves, k = _.size, M = U._dirtyElements, A = M.size, tp++;
      }
      U._dirtyLeaves = y, U._dirtyElements = w;
    }(c, e), rv(e), function(v, U, y, w) {
      const x = v._nodeMap, E = U._nodeMap, S = [];
      for (const [_] of w) {
        const k = E.get(_);
        k !== void 0 && (k.isAttached() || (re(k) && Tk(k, _, x, E, S, w), x.has(_) || w.delete(_), S.push(_)));
      }
      for (const _ of S) E.delete(_);
      for (const _ of y) {
        const k = E.get(_);
        k === void 0 || k.isAttached() || (x.has(_) || y.delete(_), E.delete(_));
      }
    }(s, c, e._dirtyLeaves, e._dirtyElements)), g !== e._compositionKey && (c._flushSync = !0);
    const b = c._selection;
    if (ie(b)) {
      const v = c._nodeMap, U = b.anchor.key, y = b.focus.key;
      v.get(U) !== void 0 && v.get(y) !== void 0 || Ce(19);
    } else Xn(b) && b._nodes.size === 0 && (c._selection = null);
  } catch (g) {
    return g instanceof Error && e._onError(g), e._pendingEditorState = s, e._dirtyType = l0, e._cloneNotNeeded.clear(), e._dirtyLeaves = /* @__PURE__ */ new Set(), e._dirtyElements.clear(), void eo(e);
  } finally {
    Ur = o, ci = u, vr = h, e._updating = f, tp = 0;
  }
  e._dirtyType !== Mc || function(g, b) {
    const v = b.getEditorState()._selection, U = g._selection;
    if (U !== null) {
      if (U.dirty || !U.is(v)) return !0;
    } else if (v !== null) return !0;
    return !1;
  }(c, e) ? c._flushSync ? (c._flushSync = !1, eo(e)) : d && f$(() => {
    eo(e);
  }) : (c._flushSync = !1, d && (r.clear(), e._deferred = [], e._pendingEditorState = null));
}
function wi(e, t, n) {
  e._updating ? e._updates.push([t, n]) : iC(e, t, n);
}
let tr = class extends Eg {
  constructor(t) {
    super(t), this.__first = null, this.__last = null, this.__size = 0, this.__format = 0, this.__style = "", this.__indent = 0, this.__dir = null;
  }
  afterCloneFrom(t) {
    super.afterCloneFrom(t), this.__first = t.__first, this.__last = t.__last, this.__size = t.__size, this.__indent = t.__indent, this.__format = t.__format, this.__style = t.__style, this.__dir = t.__dir;
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getFormatType() {
    const t = this.getFormat();
    return i$[t] || "";
  }
  getStyle() {
    return this.getLatest().__style;
  }
  getIndent() {
    return this.getLatest().__indent;
  }
  getChildren() {
    const t = [];
    let n = this.getFirstChild();
    for (; n !== null; ) t.push(n), n = n.getNextSibling();
    return t;
  }
  getChildrenKeys() {
    const t = [];
    let n = this.getFirstChild();
    for (; n !== null; ) t.push(n.__key), n = n.getNextSibling();
    return t;
  }
  getChildrenSize() {
    return this.getLatest().__size;
  }
  isEmpty() {
    return this.getChildrenSize() === 0;
  }
  isDirty() {
    const t = Fn()._dirtyElements;
    return t !== null && t.has(this.__key);
  }
  isLastChild() {
    const t = this.getLatest(), n = this.getParentOrThrow().getLastChild();
    return n !== null && n.is(t);
  }
  getAllTextNodes() {
    const t = [];
    let n = this.getFirstChild();
    for (; n !== null; ) {
      if (ce(n) && t.push(n), re(n)) {
        const r = n.getAllTextNodes();
        t.push(...r);
      }
      n = n.getNextSibling();
    }
    return t;
  }
  getFirstDescendant() {
    let t = this.getFirstChild();
    for (; re(t); ) {
      const n = t.getFirstChild();
      if (n === null) break;
      t = n;
    }
    return t;
  }
  getLastDescendant() {
    let t = this.getLastChild();
    for (; re(t); ) {
      const n = t.getLastChild();
      if (n === null) break;
      t = n;
    }
    return t;
  }
  getDescendantByIndex(t) {
    const n = this.getChildren(), r = n.length;
    if (t >= r) {
      const a = n[r - 1];
      return re(a) && a.getLastDescendant() || a || null;
    }
    const i = n[t];
    return re(i) && i.getFirstDescendant() || i || null;
  }
  getFirstChild() {
    const t = this.getLatest().__first;
    return t === null ? null : Rt(t);
  }
  getFirstChildOrThrow() {
    const t = this.getFirstChild();
    return t === null && Ce(45, this.__key), t;
  }
  getLastChild() {
    const t = this.getLatest().__last;
    return t === null ? null : Rt(t);
  }
  getLastChildOrThrow() {
    const t = this.getLastChild();
    return t === null && Ce(96, this.__key), t;
  }
  getChildAtIndex(t) {
    const n = this.getChildrenSize();
    let r, i;
    if (t < n / 2) {
      for (r = this.getFirstChild(), i = 0; r !== null && i <= t; ) {
        if (i === t) return r;
        r = r.getNextSibling(), i++;
      }
      return null;
    }
    for (r = this.getLastChild(), i = n - 1; r !== null && i >= t; ) {
      if (i === t) return r;
      r = r.getPreviousSibling(), i--;
    }
    return null;
  }
  getTextContent() {
    let t = "";
    const n = this.getChildren(), r = n.length;
    for (let i = 0; i < r; i++) {
      const a = n[i];
      t += a.getTextContent(), re(a) && i !== r - 1 && !a.isInline() && (t += us);
    }
    return t;
  }
  getTextContentSize() {
    let t = 0;
    const n = this.getChildren(), r = n.length;
    for (let i = 0; i < r; i++) {
      const a = n[i];
      t += a.getTextContentSize(), re(a) && i !== r - 1 && !a.isInline() && (t += us.length);
    }
    return t;
  }
  getDirection() {
    return this.getLatest().__dir;
  }
  hasFormat(t) {
    if (t !== "") {
      const n = S9[t];
      return !!(this.getFormat() & n);
    }
    return !1;
  }
  select(t, n) {
    ii();
    const r = se();
    let i = t, a = n;
    const l = this.getChildrenSize();
    if (!this.canBeEmpty()) {
      if (t === 0 && n === 0) {
        const c = this.getFirstChild();
        if (ce(c) || re(c)) return c.select(0, 0);
      } else if (!(t !== void 0 && t !== l || n !== void 0 && n !== l)) {
        const c = this.getLastChild();
        if (ce(c) || re(c)) return c.select();
      }
    }
    i === void 0 && (i = l), a === void 0 && (a = l);
    const s = this.__key;
    return ie(r) ? (r.anchor.set(s, i, "element"), r.focus.set(s, a, "element"), r.dirty = !0, r) : Qk(s, i, s, a, "element", "element");
  }
  selectStart() {
    const t = this.getFirstDescendant();
    return t ? t.selectStart() : this.select();
  }
  selectEnd() {
    const t = this.getLastDescendant();
    return t ? t.selectEnd() : this.select();
  }
  clear() {
    const t = this.getWritable();
    return this.getChildren().forEach((n) => n.remove()), t;
  }
  append(...t) {
    return this.splice(this.getChildrenSize(), 0, t);
  }
  setDirection(t) {
    const n = this.getWritable();
    return n.__dir = t, n;
  }
  setFormat(t) {
    return this.getWritable().__format = t !== "" ? S9[t] : 0, this;
  }
  setStyle(t) {
    return this.getWritable().__style = t || "", this;
  }
  setIndent(t) {
    return this.getWritable().__indent = t, this;
  }
  splice(t, n, r) {
    const i = r.length, a = this.getChildrenSize(), l = this.getWritable(), s = l.__key, c = [], d = [], o = this.getChildAtIndex(t + n);
    let u = null, h = a - n + i;
    if (t !== 0) if (t === a) u = this.getLastChild();
    else {
      const p = this.getChildAtIndex(t);
      p !== null && (u = p.getPreviousSibling());
    }
    if (n > 0) {
      let p = u === null ? this.getFirstChild() : u.getNextSibling();
      for (let g = 0; g < n; g++) {
        p === null && Ce(100);
        const b = p.getNextSibling(), v = p.__key;
        bc(p.getWritable()), d.push(v), p = b;
      }
    }
    let f = u;
    for (let p = 0; p < i; p++) {
      const g = r[p];
      f !== null && g.is(f) && (u = f = f.getPreviousSibling());
      const b = g.getWritable();
      b.__parent === s && h--, bc(b);
      const v = g.__key;
      if (f === null) l.__first = v, b.__prev = null;
      else {
        const U = f.getWritable();
        U.__next = v, b.__prev = U.__key;
      }
      g.__key === s && Ce(76), b.__parent = s, c.push(v), f = g;
    }
    if (t + n === a)
      f !== null && (f.getWritable().__next = null, l.__last = f.__key);
    else if (o !== null) {
      const p = o.getWritable();
      if (f !== null) {
        const g = f.getWritable();
        p.__prev = f.__key, g.__next = o.__key;
      } else p.__prev = null;
    }
    if (l.__size = h, d.length) {
      const p = se();
      if (ie(p)) {
        const g = new Set(d), b = new Set(c), { anchor: v, focus: U } = p;
        iv(v, g, b) && qp(v, v.getNode(), this, u, o), iv(U, g, b) && qp(U, U.getNode(), this, u, o), h !== 0 || this.canBeEmpty() || er(this) || this.remove();
      }
    }
    return l;
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    if (n && Ti(n)) {
      const r = this.getIndent();
      r > 0 && (n.style.paddingInlineStart = 40 * r + "px");
    }
    return { element: n };
  }
  exportJSON() {
    return { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), type: "element", version: 1 };
  }
  insertNewAfter(t, n) {
    return null;
  }
  canIndent() {
    return !0;
  }
  collapseAtStart(t) {
    return !1;
  }
  excludeFromCopy(t) {
    return !1;
  }
  canReplaceWith(t) {
    return !0;
  }
  canInsertAfter(t) {
    return !0;
  }
  canBeEmpty() {
    return !0;
  }
  canInsertTextBefore() {
    return !0;
  }
  canInsertTextAfter() {
    return !0;
  }
  isInline() {
    return !1;
  }
  isShadowRoot() {
    return !1;
  }
  canMergeWith(t) {
    return !1;
  }
  extractWithChild(t, n, r) {
    return !1;
  }
  canMergeWhenEmpty() {
    return !1;
  }
};
function re(e) {
  return e instanceof tr;
}
function iv(e, t, n) {
  let r = e.getNode();
  for (; r; ) {
    const i = r.__key;
    if (t.has(i) && !n.has(i)) return !0;
    r = r.getParent();
  }
  return !1;
}
let Ha = class extends Eg {
  constructor(t) {
    super(t);
  }
  decorate(t, n) {
    Ce(47);
  }
  isIsolated() {
    return !1;
  }
  isInline() {
    return !0;
  }
  isKeyboardSelectable() {
    return !0;
  }
};
function Ft(e) {
  return e instanceof Ha;
}
let j3 = class aC extends tr {
  static getType() {
    return "root";
  }
  static clone() {
    return new aC();
  }
  constructor() {
    super("root"), this.__cachedText = null;
  }
  getTopLevelElementOrThrow() {
    Ce(51);
  }
  getTextContent() {
    const t = this.__cachedText;
    return !B0() && Fn()._dirtyType !== Mc || t === null ? super.getTextContent() : t;
  }
  remove() {
    Ce(52);
  }
  replace(t) {
    Ce(53);
  }
  insertBefore(t) {
    Ce(54);
  }
  insertAfter(t) {
    Ce(55);
  }
  updateDOM(t, n) {
    return !1;
  }
  append(...t) {
    for (let n = 0; n < t.length; n++) {
      const r = t[n];
      re(r) || Ft(r) || Ce(56);
    }
    return super.append(...t);
  }
  static importJSON(t) {
    const n = Bt();
    return n.setFormat(t.format), n.setIndent(t.indent), n.setDirection(t.direction), n;
  }
  exportJSON() {
    return { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), type: "root", version: 1 };
  }
  collapseAtStart() {
    return !0;
  }
};
function Xr(e) {
  return e instanceof j3;
}
function K3() {
  return new sC(/* @__PURE__ */ new Map([["root", new j3()]]));
}
function lC(e) {
  const t = e.exportJSON(), n = e.constructor;
  if (t.type !== n.getType() && Ce(130, n.name), re(e)) {
    const r = t.children;
    Array.isArray(r) || Ce(59, n.name);
    const i = e.getChildren();
    for (let a = 0; a < i.length; a++) {
      const l = lC(i[a]);
      r.push(l);
    }
  }
  return t;
}
let sC = class oC {
  constructor(t, n) {
    this._nodeMap = t, this._selection = n || null, this._flushSync = !1, this._readOnly = !1;
  }
  isEmpty() {
    return this._nodeMap.size === 1 && this._selection === null;
  }
  read(t, n) {
    return nv(n && n.editor || null, this, t);
  }
  clone(t) {
    const n = new oC(this._nodeMap, t === void 0 ? this._selection : t);
    return n._readOnly = !0, n;
  }
  toJSON() {
    return nv(null, this, () => ({ root: lC(Bt()) }));
  }
}, Y3 = class extends tr {
  static getType() {
    return "artificial";
  }
  createDOM(t) {
    return document.createElement("div");
  }
}, _g = class cC extends tr {
  constructor(t) {
    super(t), this.__textFormat = 0, this.__textStyle = "";
  }
  static getType() {
    return "paragraph";
  }
  getTextFormat() {
    return this.getLatest().__textFormat;
  }
  setTextFormat(t) {
    const n = this.getWritable();
    return n.__textFormat = t, n;
  }
  hasTextFormat(t) {
    const n = Mi[t];
    return !!(this.getTextFormat() & n);
  }
  getFormatFlags(t, n) {
    return zp(this.getLatest().__textFormat, t, n);
  }
  getTextStyle() {
    return this.getLatest().__textStyle;
  }
  setTextStyle(t) {
    const n = this.getWritable();
    return n.__textStyle = t, n;
  }
  static clone(t) {
    return new cC(t.__key);
  }
  afterCloneFrom(t) {
    super.afterCloneFrom(t), this.__textFormat = t.__textFormat, this.__textStyle = t.__textStyle;
  }
  createDOM(t) {
    const n = document.createElement("p"), r = th(t.theme, "paragraph");
    return r !== void 0 && n.classList.add(...r), n;
  }
  updateDOM(t, n, r) {
    return !1;
  }
  static importDOM() {
    return { p: (t) => ({ conversion: B$, priority: 0 }) };
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    if (n && Ti(n)) {
      this.isEmpty() && n.append(document.createElement("br"));
      const r = this.getFormatType();
      n.style.textAlign = r;
      const i = this.getDirection();
      i && (n.dir = i);
    }
    return { element: n };
  }
  static importJSON(t) {
    const n = He();
    return n.setFormat(t.format), n.setIndent(t.indent), n.setDirection(t.direction), n.setTextFormat(t.textFormat), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), textFormat: this.getTextFormat(), textStyle: this.getTextStyle(), type: "paragraph", version: 1 };
  }
  insertNewAfter(t, n) {
    const r = He();
    r.setTextFormat(t.format), r.setTextStyle(t.style);
    const i = this.getDirection();
    return r.setDirection(i), r.setFormat(this.getFormatType()), r.setStyle(this.getTextStyle()), this.insertAfter(r, n), r;
  }
  collapseAtStart() {
    const t = this.getChildren();
    if (t.length === 0 || ce(t[0]) && t[0].getTextContent().trim() === "") {
      if (this.getNextSibling() !== null) return this.selectNext(), this.remove(), !0;
      if (this.getPreviousSibling() !== null) return this.selectPrevious(), this.remove(), !0;
    }
    return !1;
  }
};
function B$(e) {
  const t = He();
  return e.style && (t.setFormat(e.style.textAlign), B3(e, t)), { node: t };
}
function He() {
  return En(new _g());
}
function La(e) {
  return e instanceof _g;
}
const it = 0, ot = 1, H$ = 2, vi = 3, mr = 4;
function dC(e, t, n, r) {
  const i = e._keyToDOMMap;
  i.clear(), e._editorState = K3(), e._pendingEditorState = r, e._compositionKey = null, e._dirtyType = Mc, e._cloneNotNeeded.clear(), e._dirtyLeaves = /* @__PURE__ */ new Set(), e._dirtyElements.clear(), e._normalizedNodes = /* @__PURE__ */ new Set(), e._updateTags = /* @__PURE__ */ new Set(), e._updates = [], e._blockCursorElement = null;
  const a = e._observer;
  a !== null && (a.disconnect(), e._observer = null), t !== null && (t.textContent = ""), n !== null && (n.textContent = "", i.set("root", n));
}
function wf(e) {
  const t = e || {}, n = F$(), r = t.theme || {}, i = e === void 0 ? n : t.parentEditor || null, a = t.disableEvents || !1, l = K3(), s = t.namespace || (i !== null ? i._config.namespace : _k()), c = t.editorState, d = [j3, aa, H3, X3, _g, Y3, ...t.nodes || []], { onError: o, html: u } = t, h = t.editable === void 0 || t.editable;
  let f;
  if (e === void 0 && n !== null) f = n._nodes;
  else {
    f = /* @__PURE__ */ new Map();
    for (let g = 0; g < d.length; g++) {
      let b = d[g], v = null, U = null;
      if (typeof b != "function") {
        const E = b;
        b = E.replace, v = E.with, U = E.withKlass || null;
      }
      const y = b.getType(), w = b.transform(), x = /* @__PURE__ */ new Set();
      w !== null && x.add(w), f.set(y, { exportDOM: u && u.export ? u.export.get(b) : void 0, klass: b, replace: v, replaceWithKlass: U, transforms: x });
    }
  }
  const p = new kg(l, i, f, { disableEvents: a, namespace: s, theme: r }, o || console.error, function(g, b) {
    const v = /* @__PURE__ */ new Map(), U = /* @__PURE__ */ new Set(), y = (w) => {
      Object.keys(w).forEach((x) => {
        let E = v.get(x);
        E === void 0 && (E = [], v.set(x, E)), E.push(w[x]);
      });
    };
    return g.forEach((w) => {
      const x = w.klass.importDOM;
      if (x == null || U.has(x)) return;
      U.add(x);
      const E = x.call(w.klass);
      E !== null && y(E);
    }), b && y(b), v;
  }(f, u ? u.import : void 0), h);
  return c !== void 0 && (p._pendingEditorState = c, p._dirtyType = l0), p;
}
let kg = class {
  constructor(t, n, r, i, a, l, s) {
    this._parentEditor = n, this._rootElement = null, this._editorState = t, this._pendingEditorState = null, this._compositionKey = null, this._deferred = [], this._keyToDOMMap = /* @__PURE__ */ new Map(), this._updates = [], this._updating = !1, this._listeners = { decorator: /* @__PURE__ */ new Set(), editable: /* @__PURE__ */ new Set(), mutation: /* @__PURE__ */ new Map(), root: /* @__PURE__ */ new Set(), textcontent: /* @__PURE__ */ new Set(), update: /* @__PURE__ */ new Set() }, this._commands = /* @__PURE__ */ new Map(), this._config = i, this._nodes = r, this._decorators = {}, this._pendingDecorators = null, this._dirtyType = Mc, this._cloneNotNeeded = /* @__PURE__ */ new Set(), this._dirtyLeaves = /* @__PURE__ */ new Set(), this._dirtyElements = /* @__PURE__ */ new Map(), this._normalizedNodes = /* @__PURE__ */ new Set(), this._updateTags = /* @__PURE__ */ new Set(), this._observer = null, this._key = _k(), this._onError = a, this._htmlConversions = l, this._editable = s, this._headless = n !== null && n._headless, this._window = null, this._blockCursorElement = null;
  }
  isComposing() {
    return this._compositionKey != null;
  }
  registerUpdateListener(t) {
    const n = this._listeners.update;
    return n.add(t), () => {
      n.delete(t);
    };
  }
  registerEditableListener(t) {
    const n = this._listeners.editable;
    return n.add(t), () => {
      n.delete(t);
    };
  }
  registerDecoratorListener(t) {
    const n = this._listeners.decorator;
    return n.add(t), () => {
      n.delete(t);
    };
  }
  registerTextContentListener(t) {
    const n = this._listeners.textcontent;
    return n.add(t), () => {
      n.delete(t);
    };
  }
  registerRootListener(t) {
    const n = this._listeners.root;
    return t(this._rootElement, null), n.add(t), () => {
      t(null, this._rootElement), n.delete(t);
    };
  }
  registerCommand(t, n, r) {
    r === void 0 && Ce(35);
    const i = this._commands;
    i.has(t) || i.set(t, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
    const a = i.get(t);
    a === void 0 && Ce(36, String(t));
    const l = a[r];
    return l.add(n), () => {
      l.delete(n), a.every((s) => s.size === 0) && i.delete(t);
    };
  }
  registerMutationListener(t, n, r) {
    const i = this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(t)).klass, a = this._listeners.mutation;
    a.set(n, i);
    const l = r && r.skipInitialization;
    return l === void 0 || l || this.initializeMutationListener(n, i), () => {
      a.delete(n);
    };
  }
  getRegisteredNode(t) {
    const n = this._nodes.get(t.getType());
    return n === void 0 && Ce(37, t.name), n;
  }
  resolveRegisteredNodeAfterReplacements(t) {
    for (; t.replaceWithKlass; ) t = this.getRegisteredNode(t.replaceWithKlass);
    return t;
  }
  initializeMutationListener(t, n) {
    const r = this._editorState, i = Mk(r).get(n.getType());
    if (!i) return;
    const a = /* @__PURE__ */ new Map();
    for (const l of i.keys()) a.set(l, "created");
    a.size > 0 && t(a, { dirtyLeaves: /* @__PURE__ */ new Set(), prevEditorState: r, updateTags: /* @__PURE__ */ new Set(["registerMutationListener"]) });
  }
  registerNodeTransformToKlass(t, n) {
    const r = this.getRegisteredNode(t);
    return r.transforms.add(n), r;
  }
  registerNodeTransform(t, n) {
    const r = this.registerNodeTransformToKlass(t, n), i = [r], a = r.replaceWithKlass;
    if (a != null) {
      const c = this.registerNodeTransformToKlass(a, n);
      i.push(c);
    }
    var l, s;
    return l = this, s = t.getType(), wi(l, () => {
      const c = Il();
      if (c.isEmpty()) return;
      if (s === "root") return void Bt().markDirty();
      const d = c._nodeMap;
      for (const [, o] of d) o.markDirty();
    }, l._pendingEditorState === null ? { tag: "history-merge" } : void 0), () => {
      i.forEach((c) => c.transforms.delete(n));
    };
  }
  hasNode(t) {
    return this._nodes.has(t.getType());
  }
  hasNodes(t) {
    return t.every(this.hasNode.bind(this));
  }
  dispatchCommand(t, n) {
    return Ie(this, t, n);
  }
  getDecorators() {
    return this._decorators;
  }
  getRootElement() {
    return this._rootElement;
  }
  getKey() {
    return this._key;
  }
  setRootElement(t) {
    const n = this._rootElement;
    if (t !== n) {
      const r = th(this._config.theme, "root"), i = this._pendingEditorState || this._editorState;
      if (this._rootElement = t, dC(this, n, t, i), n !== null && (this._config.disableEvents || M$(n), r != null && n.classList.remove(...r)), t !== null) {
        const a = function(s) {
          const c = s.ownerDocument;
          return c && c.defaultView || null;
        }(t), l = t.style;
        l.userSelect = "text", l.whiteSpace = "pre-wrap", l.wordBreak = "break-word", t.setAttribute("data-lexical-editor", "true"), this._window = a, this._dirtyType = l0, Uk(this), this._updateTags.add("history-merge"), eo(this), this._config.disableEvents || function(s, c) {
          const d = s.ownerDocument, o = jp.get(d);
          (o === void 0 || o < 1) && d.addEventListener("selectionchange", Hk), jp.set(d, (o || 0) + 1), s.__lexicalEditor = c;
          const u = Bk(s);
          for (let h = 0; h < o4.length; h++) {
            const [f, p] = o4[h], g = typeof p == "function" ? (b) => {
              H9(b) || (B9(b), (c.isEditable() || f === "click") && p(b, c));
            } : (b) => {
              if (H9(b)) return;
              B9(b);
              const v = c.isEditable();
              switch (f) {
                case "cut":
                  return v && Ie(c, fg, b);
                case "copy":
                  return Ie(c, hg, b);
                case "paste":
                  return v && Ie(c, sg, b);
                case "dragstart":
                  return v && Ie(c, ug, b);
                case "dragover":
                  return v && Ie(c, bf, b);
                case "dragend":
                  return v && Ie(c, $O, b);
                case "focus":
                  return v && Ie(c, x3, b);
                case "blur":
                  return v && Ie(c, BO, b);
                case "drop":
                  return v && Ie(c, gf, b);
              }
            };
            s.addEventListener(f, g), u.push(() => {
              s.removeEventListener(f, g);
            });
          }
        }(t, this), r != null && t.classList.add(...r);
      } else this._editorState = i, this._pendingEditorState = null, this._window = null;
      ah("root", this, !1, t, n);
    }
  }
  getElementByKey(t) {
    return this._keyToDOMMap.get(t) || null;
  }
  getEditorState() {
    return this._editorState;
  }
  setEditorState(t, n) {
    t.isEmpty() && Ce(38), bk(this);
    const r = this._pendingEditorState, i = this._updateTags, a = n !== void 0 ? n.tag : null;
    r === null || r.isEmpty() || (a != null && i.add(a), eo(this)), this._pendingEditorState = t, this._dirtyType = l0, this._dirtyElements.set("root", !1), this._compositionKey = null, a != null && i.add(a), eo(this);
  }
  parseEditorState(t, n) {
    return function(r, i, a) {
      const l = K3(), s = Ur, c = ci, d = vr, o = i._dirtyElements, u = i._dirtyLeaves, h = i._cloneNotNeeded, f = i._dirtyType;
      i._dirtyElements = /* @__PURE__ */ new Map(), i._dirtyLeaves = /* @__PURE__ */ new Set(), i._cloneNotNeeded = /* @__PURE__ */ new Set(), i._dirtyType = 0, Ur = l, ci = !1, vr = i;
      try {
        const p = i._nodes;
        G3(r.root, p), a && a(), l._readOnly = !0;
      } catch (p) {
        p instanceof Error && i._onError(p);
      } finally {
        i._dirtyElements = o, i._dirtyLeaves = u, i._cloneNotNeeded = h, i._dirtyType = f, Ur = s, ci = c, vr = d;
      }
      return l;
    }(typeof t == "string" ? JSON.parse(t) : t, this, n);
  }
  read(t) {
    return eo(this), this.getEditorState().read(t, { editor: this });
  }
  update(t, n) {
    wi(this, t, n);
  }
  focus(t, n = {}) {
    const r = this._rootElement;
    r !== null && (r.setAttribute("autocapitalize", "off"), wi(this, () => {
      const i = se(), a = Bt();
      i !== null ? i.dirty = !0 : a.getChildrenSize() !== 0 && (n.defaultSelection === "rootStart" ? a.selectStart() : a.selectEnd());
    }, { onUpdate: () => {
      r.removeAttribute("autocapitalize"), t && t();
    }, tag: "focus" }), this._pendingEditorState === null && r.removeAttribute("autocapitalize"));
  }
  blur() {
    const t = this._rootElement;
    t !== null && t.blur();
    const n = wl(this._window);
    n !== null && n.removeAllRanges();
  }
  isEditable() {
    return this._editable;
  }
  setEditable(t) {
    this._editable !== t && (this._editable = t, ah("editable", this, !0, t));
  }
  toJSON() {
    return { editorState: this._editorState.toJSON() };
  }
};
kg.version = "0.20.0+prod.esm";
const uC = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, W$ = uC ? Bn : Y, a1 = { tag: "history-merge" };
function X$({ initialConfig: e, children: t }) {
  const n = Ke(() => {
    const { theme: r, namespace: i, nodes: a, onError: l, editorState: s, html: c } = e, d = LO(null, r), o = wf({ editable: e.editable, html: c, namespace: i, nodes: a, onError: (u) => l(u, o), theme: r });
    return function(u, h) {
      if (h !== null) {
        if (h === void 0) u.update(() => {
          const f = Bt();
          if (f.isEmpty()) {
            const p = He();
            f.append(p);
            const g = uC ? document.activeElement : null;
            (se() !== null || g !== null && g === u.getRootElement()) && p.select();
          }
        }, a1);
        else if (h !== null) switch (typeof h) {
          case "string": {
            const f = u.parseEditorState(h);
            u.setEditorState(f, a1);
            break;
          }
          case "object":
            u.setEditorState(h, a1);
            break;
          case "function":
            u.update(() => {
              Bt().isEmpty() && h(u);
            }, a1);
        }
      }
    }(o, s), [o, d];
  }, []);
  return W$(() => {
    const r = e.editable, [i] = n;
    i.setEditable(r === void 0 || r);
  }, []), m(sk.Provider, { value: n, children: t });
}
const V$ = {
  blockCursor: "et_block-cursor",
  code: "et_code",
  characterLimit: "character-limit",
  embedBlock: {
    base: "et_embed-block",
    focus: "et_embed-block-focus"
  },
  hashtag: "et_hashtag",
  heading: {
    h1: "et_h1",
    h2: "et_h2",
    h3: "et_h3",
    h4: "et_h4",
    h5: "et_h5",
    h6: "et_h6"
  },
  image: "editor-image",
  indent: "et_indent",
  inlineImage: "inline-editor-image",
  layoutContainer: "et_layout-container",
  layoutItem: "et_layout-item",
  link: "et_link",
  list: {
    checklist: "et_checklist",
    listitem: "et_listitem",
    listitemChecked: "et_listitem-checked",
    listitemUnchecked: "et_listitem-unchecked",
    nested: {
      listitem: "et_nested-listitem"
    },
    olDepth: [
      "et_ol1",
      "et_ol2",
      "et_ol3",
      "et_ol4",
      "et_ol5"
    ],
    ul: "et_ul"
  },
  ltr: "et_ltr",
  mark: "et_mark",
  markOverlap: "et_mark-overlap",
  paragraph: "et_paragraph",
  quote: "et_quote",
  rtl: "et_rtl",
  table: "et_table",
  tableAddColumns: "et_table-add-columns",
  tableAddRows: "et_table-add-rows",
  tableCell: "et_table-cell",
  tableCellActionButton: "et_table-cell-action-button",
  tableCellActionButtonContainer: "et_table-cell-action-button-container",
  tableCellEditing: "et_table-cell-editing",
  tableCellHeader: "et_table-cell-header",
  tableCellPrimarySelected: "et_table-cell-primary-selected",
  tableCellResizer: "et_table-cell-resizer",
  tableCellSelected: "et_table-cell-selected",
  tableCellSortedIndicator: "et_table-cell-sorted-indicator",
  tableResizeRuler: "et_table-resize-ruler",
  tableSelected: "et_table-selected",
  tableSelection: "et_table-selection",
  text: {
    bold: "et_text-bold",
    code: "et_text-code",
    italic: "et_text-italic",
    strikethrough: "et_text-strikethrough",
    subscript: "et_text-subscript",
    superscript: "et_text-superscript",
    underline: "et_text-underline",
    underlineStrikethrough: "et_text-underline-strikethrough"
  },
  dataMention: "et_data-mention",
  fileAttachment: "file-attach"
};
function G$(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var hC = G$(function(e) {
  const t = new URLSearchParams();
  t.append("code", e);
  for (let n = 1; n < arguments.length; n++) t.append("v", arguments[n]);
  throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
});
const Zp = /* @__PURE__ */ new Map();
function fC(e) {
  const t = {};
  if (!e) return t;
  const n = e.split(";");
  for (const r of n) if (r !== "") {
    const [i, a] = r.split(/:([^]+)/);
    i && a && (t[i.trim()] = a.trim());
  }
  return t;
}
function q3(e) {
  let t = Zp.get(e);
  return t === void 0 && (t = fC(e), Zp.set(e, t)), t;
}
function j$(e) {
  let t = "";
  for (const n in e) n && (t += `${n}: ${e[n]};`);
  return t;
}
function pC(e, t) {
  const n = e.getStartEndPoints();
  if (t.isSelected(e) && !t.isSegmented() && !t.isToken() && n !== null) {
    const [r, i] = n, a = e.isBackward(), l = r.getNode(), s = i.getNode(), c = t.is(l), d = t.is(s);
    if (c || d) {
      const [o, u] = h4(e), h = l.is(s), f = t.is(a ? s : l), p = t.is(a ? l : s);
      let g, b = 0;
      return h ? (b = o > u ? u : o, g = o > u ? o : u) : f ? (b = a ? u : o, g = void 0) : p && (b = 0, g = a ? o : u), t.__text = t.__text.slice(b, g), t;
    }
  }
  return t;
}
function av(e) {
  if (e.type === "text") return e.offset === e.getNode().getTextContentSize();
  const t = e.getNode();
  return re(t) || hC(177), e.offset === t.getChildrenSize();
}
function K$(e) {
  const t = e.getStyle(), n = fC(t);
  Zp.set(t, n);
}
function ud(e, t) {
  const n = q3("getStyle" in e ? e.getStyle() : e.style), r = Object.entries(t).reduce((a, [l, s]) => (typeof s == "function" ? a[l] = s(n[l], e) : s === null ? delete a[l] : a[l] = s, a), { ...n }), i = j$(r);
  e.setStyle(i), Zp.set(i, r);
}
function Z3(e, t) {
  const n = e.getNodes(), r = n.length, i = e.getStartEndPoints();
  if (i === null) return;
  const [a, l] = i, s = r - 1;
  let c = n[0], d = n[s];
  if (e.isCollapsed() && ie(e)) return void ud(e, t);
  const o = c.getTextContent().length, u = l.offset;
  let h = a.offset;
  const f = a.isBefore(l);
  let p = f ? h : u, g = f ? u : h;
  const b = f ? a.type : l.type, v = f ? l.type : a.type, U = f ? l.key : a.key;
  if (ce(c) && p === o) {
    const y = c.getNextSibling();
    ce(y) && (h = 0, p = 0, c = y);
  }
  if (n.length === 1) {
    if (ce(c) && c.canHaveFormat()) {
      if (p = b === "element" ? 0 : h > u ? u : h, g = v === "element" ? o : h > u ? h : u, p === g) return;
      if (al(c) || p === 0 && g === o) ud(c, t), c.select(p, g);
      else {
        const y = c.splitText(p, g), w = p === 0 ? y[0] : y[1];
        ud(w, t), w.select(0, g - p);
      }
    }
  } else {
    if (ce(c) && p < c.getTextContentSize() && c.canHaveFormat() && (p === 0 || al(c) || (c = c.splitText(p)[1], p = 0, f ? a.set(c.getKey(), p, "text") : l.set(c.getKey(), p, "text")), ud(c, t)), ce(d) && d.canHaveFormat()) {
      const y = d.getTextContent().length;
      d.__key !== U && g !== 0 && (g = y), g === y || al(d) || ([d] = d.splitText(g)), g === 0 && v !== "element" || ud(d, t);
    }
    for (let y = 1; y < s; y++) {
      const w = n[y], x = w.getKey();
      ce(w) && w.canHaveFormat() && x !== c.getKey() && x !== d.getKey() && !w.isToken() && ud(w, t);
    }
  }
}
function oc(e, t) {
  if (e === null) return;
  const n = e.getStartEndPoints(), r = n ? n[0] : null;
  if (r !== null && r.key === "root") {
    const l = t(), s = Bt(), c = s.getFirstChild();
    return void (c ? c.replace(l, !0) : s.append(l));
  }
  const i = e.getNodes(), a = r !== null && function(l, s) {
    let c = l;
    for (; c !== null && c.getParent() !== null && !s(c); ) c = c.getParentOrThrow();
    return s(c) ? c : null;
  }(r.getNode(), ov);
  a && i.indexOf(a) === -1 && i.push(a);
  for (let l = 0; l < i.length; l++) {
    const s = i[l];
    if (!ov(s)) continue;
    re(s) || hC(178);
    const c = t();
    c.setFormat(s.getFormatType()), c.setIndent(s.getIndent()), s.replace(c, !0);
  }
}
function lv(e, t) {
  const n = Ch(e.focus, t);
  return Ft(n) && !n.isIsolated() || re(n) && !n.isInline() && !n.canBeEmpty();
}
function Y$(e, t, n, r) {
  e.modify(t ? "extend" : "move", n, r);
}
function mC(e) {
  const t = e.anchor.getNode();
  return (Xr(t) ? t : t.getParentOrThrow()).getDirection() === "rtl";
}
function sv(e, t, n) {
  const r = mC(e);
  Y$(e, t, n ? !r : r, "character");
}
function q$(e, t, n) {
  const r = q3(e.getStyle());
  return r !== null && r[t] || n;
}
function l1(e, t, n = "") {
  let r = null;
  const i = e.getNodes(), a = e.anchor, l = e.focus, s = e.isBackward(), c = s ? l.offset : a.offset, d = s ? l.getNode() : a.getNode();
  if (ie(e) && e.isCollapsed() && e.style !== "") {
    const o = q3(e.style);
    if (o !== null && t in o) return o[t];
  }
  for (let o = 0; o < i.length; o++) {
    const u = i[o];
    if ((o === 0 || c !== 0 || !u.is(d)) && ce(u)) {
      const h = q$(u, t, n);
      if (r === null) r = h;
      else if (r !== h) {
        r = "";
        break;
      }
    }
  }
  return r === null ? n : r;
}
function ov(e) {
  if (Ft(e) || !re(e) || er(e)) return !1;
  const t = e.getFirstChild(), n = t === null || Ca(t) || ce(t) || t.isInline();
  return !e.isInline() && e.canBeEmpty() !== !1 && n;
}
function Z$(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var J$ = Z$(function(e) {
  const t = new URLSearchParams();
  t.append("code", e);
  for (let n = 1; n < arguments.length; n++) t.append("v", arguments[n]);
  throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
});
const J3 = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, Q$ = J3 && "documentMode" in document ? document.documentMode : null, eF = J3 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
!(!J3 || !("InputEvent" in window) || Q$) && "getTargetRanges" in new window.InputEvent("input");
function gC(...e) {
  const t = [];
  for (const n of e) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) t.push(r);
  return t;
}
function Pt(...e) {
  return () => {
    for (let t = e.length - 1; t >= 0; t--) e[t]();
    e.length = 0;
  };
}
const tF = eF;
function zn(e, ...t) {
  const n = gC(...t);
  n.length > 0 && e.classList.add(...n);
}
function id(e, ...t) {
  const n = gC(...t);
  n.length > 0 && e.classList.remove(...n);
}
function bC(e, t) {
  for (const n of t) if (e.type.startsWith(n)) return !0;
  return !1;
}
function nF(e, t) {
  const n = e[Symbol.iterator]();
  return new Promise((r, i) => {
    const a = [], l = () => {
      const { done: s, value: c } = n.next();
      if (s) return r(a);
      const d = new FileReader();
      d.addEventListener("error", i), d.addEventListener("load", () => {
        const o = d.result;
        typeof o == "string" && a.push({ file: c, result: o }), l();
      }), bC(c, t) ? d.readAsDataURL(c) : l();
    };
    l();
  });
}
function cv(e) {
  let t = e;
  if (re(t) && t.getChildrenSize() > 0) t = t.getLastChild();
  else {
    let n = null;
    for (; n === null && t !== null; ) n = t.getPreviousSibling(), t = n === null ? t.getParent() : n;
  }
  return t;
}
function UC(e, t) {
  let n = e;
  for (; n != null; ) {
    if (n instanceof t) return n;
    n = n.getParent();
  }
  return null;
}
function Cg(e) {
  const t = Xe(e, (n) => re(n) && !n.isInline());
  return re(t) || J$(4, e.__key), t;
}
const Xe = (e, t) => {
  let n = e;
  for (; n !== Bt() && n != null; ) {
    if (t(n)) return n;
    n = n.getParent();
  }
  return null;
};
function Lo(e) {
  const t = se() || Do();
  if (ie(t)) {
    const { focus: n } = t, r = n.getNode(), i = n.offset;
    if (er(r)) {
      const a = r.getChildAtIndex(i);
      a == null ? r.append(e) : a.insertBefore(e), e.selectNext();
    } else {
      let a, l;
      ce(r) ? (a = r.getParentOrThrow(), l = r.getIndexWithinParent(), i > 0 && (l += 1, r.splitText(i))) : (a = r, l = i);
      const [, s] = w$(a, l);
      s.insertBefore(e), s.selectStart();
    }
  } else {
    if (t != null) {
      const r = t.getNodes();
      r[r.length - 1].getTopLevelElementOrThrow().insertAfter(e);
    } else
      Bt().append(e);
    const n = He();
    e.insertAfter(n), n.select();
  }
  return e.getLatest();
}
function xf(e, t) {
  const n = t();
  return e.replace(n), n.append(e), n;
}
function ns(e, t) {
  return e !== null && Object.getPrototypeOf(e).constructor.name === t.name;
}
function rF(e, t) {
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const i = t(e[r]);
    i !== null && n.push(i);
  }
  return n;
}
function iF(e, t) {
  const n = e.getFirstChild();
  n !== null ? n.insertBefore(t) : e.append(t);
}
function p4(e) {
  if (tF) return 1;
  let t = 1;
  for (; e; ) t *= Number(window.getComputedStyle(e).getPropertyValue("zoom")), e = e.parentElement;
  return t;
}
var ya = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ad(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var aF = { exports: {} };
(function(e) {
  var t = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */
  var n = function(r) {
    var i = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, a = 0, l = {}, s = {
      /**
       * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
       * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
       * additional languages or plugins yourself.
       *
       * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
       *
       * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.manual = true;
       * // add a new <script> to load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      manual: r.Prism && r.Prism.manual,
      /**
       * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
       * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
       * own worker, you don't want it to do this.
       *
       * By setting this value to `true`, Prism will not add its own listeners to the worker.
       *
       * You obviously have to change this value before Prism executes. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.disableWorkerMessageHandler = true;
       * // Load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      disableWorkerMessageHandler: r.Prism && r.Prism.disableWorkerMessageHandler,
      /**
       * A namespace for utility methods.
       *
       * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
       * change or disappear at any time.
       *
       * @namespace
       * @memberof Prism
       */
      util: {
        encode: function U(y) {
          return y instanceof c ? new c(y.type, U(y.content), y.alias) : Array.isArray(y) ? y.map(U) : y.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
        },
        /**
         * Returns the name of the type of the given value.
         *
         * @param {any} o
         * @returns {string}
         * @example
         * type(null)      === 'Null'
         * type(undefined) === 'Undefined'
         * type(123)       === 'Number'
         * type('foo')     === 'String'
         * type(true)      === 'Boolean'
         * type([1, 2])    === 'Array'
         * type({})        === 'Object'
         * type(String)    === 'Function'
         * type(/abc+/)    === 'RegExp'
         */
        type: function(U) {
          return Object.prototype.toString.call(U).slice(8, -1);
        },
        /**
         * Returns a unique number for the given object. Later calls will still return the same number.
         *
         * @param {Object} obj
         * @returns {number}
         */
        objId: function(U) {
          return U.__id || Object.defineProperty(U, "__id", { value: ++a }), U.__id;
        },
        /**
         * Creates a deep clone of the given object.
         *
         * The main intended use of this function is to clone language definitions.
         *
         * @param {T} o
         * @param {Record<number, any>} [visited]
         * @returns {T}
         * @template T
         */
        clone: function U(y, w) {
          w = w || {};
          var x, E;
          switch (s.util.type(y)) {
            case "Object":
              if (E = s.util.objId(y), w[E])
                return w[E];
              x = /** @type {Record<string, any>} */
              {}, w[E] = x;
              for (var S in y)
                y.hasOwnProperty(S) && (x[S] = U(y[S], w));
              return (
                /** @type {any} */
                x
              );
            case "Array":
              return E = s.util.objId(y), w[E] ? w[E] : (x = [], w[E] = x, /** @type {Array} */
              /** @type {any} */
              y.forEach(function(_, k) {
                x[k] = U(_, w);
              }), /** @type {any} */
              x);
            default:
              return y;
          }
        },
        /**
         * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
         *
         * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
         *
         * @param {Element} element
         * @returns {string}
         */
        getLanguage: function(U) {
          for (; U; ) {
            var y = i.exec(U.className);
            if (y)
              return y[1].toLowerCase();
            U = U.parentElement;
          }
          return "none";
        },
        /**
         * Sets the Prism `language-xxxx` class of the given element.
         *
         * @param {Element} element
         * @param {string} language
         * @returns {void}
         */
        setLanguage: function(U, y) {
          U.className = U.className.replace(RegExp(i, "gi"), ""), U.classList.add("language-" + y);
        },
        /**
         * Returns the script element that is currently executing.
         *
         * This does __not__ work for line script element.
         *
         * @returns {HTMLScriptElement | null}
         */
        currentScript: function() {
          if (typeof document > "u")
            return null;
          if (document.currentScript && document.currentScript.tagName === "SCRIPT")
            return (
              /** @type {any} */
              document.currentScript
            );
          try {
            throw new Error();
          } catch (x) {
            var U = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(x.stack) || [])[1];
            if (U) {
              var y = document.getElementsByTagName("script");
              for (var w in y)
                if (y[w].src == U)
                  return y[w];
            }
            return null;
          }
        },
        /**
         * Returns whether a given class is active for `element`.
         *
         * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
         * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
         * given class is just the given class with a `no-` prefix.
         *
         * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
         * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
         * ancestors have the given class or the negated version of it, then the default activation will be returned.
         *
         * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
         * version of it, the class is considered active.
         *
         * @param {Element} element
         * @param {string} className
         * @param {boolean} [defaultActivation=false]
         * @returns {boolean}
         */
        isActive: function(U, y, w) {
          for (var x = "no-" + y; U; ) {
            var E = U.classList;
            if (E.contains(y))
              return !0;
            if (E.contains(x))
              return !1;
            U = U.parentElement;
          }
          return !!w;
        }
      },
      /**
       * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
       *
       * @namespace
       * @memberof Prism
       * @public
       */
      languages: {
        /**
         * The grammar for plain, unformatted text.
         */
        plain: l,
        plaintext: l,
        text: l,
        txt: l,
        /**
         * Creates a deep copy of the language with the given id and appends the given tokens.
         *
         * If a token in `redef` also appears in the copied language, then the existing token in the copied language
         * will be overwritten at its original position.
         *
         * ## Best practices
         *
         * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
         * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
         * understand the language definition because, normally, the order of tokens matters in Prism grammars.
         *
         * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
         * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
         *
         * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
         * @param {Grammar} redef The new tokens to append.
         * @returns {Grammar} The new language created.
         * @public
         * @example
         * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
         *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
         *     // at its original position
         *     'comment': { ... },
         *     // CSS doesn't have a 'color' token, so this token will be appended
         *     'color': /\b(?:red|green|blue)\b/
         * });
         */
        extend: function(U, y) {
          var w = s.util.clone(s.languages[U]);
          for (var x in y)
            w[x] = y[x];
          return w;
        },
        /**
         * Inserts tokens _before_ another token in a language definition or any other grammar.
         *
         * ## Usage
         *
         * This helper method makes it easy to modify existing languages. For example, the CSS language definition
         * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
         * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
         * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
         * this:
         *
         * ```js
         * Prism.languages.markup.style = {
         *     // token
         * };
         * ```
         *
         * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
         * before existing tokens. For the CSS example above, you would use it like this:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'cdata', {
         *     'style': {
         *         // token
         *     }
         * });
         * ```
         *
         * ## Special cases
         *
         * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
         * will be ignored.
         *
         * This behavior can be used to insert tokens after `before`:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'comment', {
         *     'comment': Prism.languages.markup.comment,
         *     // tokens after 'comment'
         * });
         * ```
         *
         * ## Limitations
         *
         * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
         * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
         * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
         * deleting properties which is necessary to insert at arbitrary positions.
         *
         * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
         * Instead, it will create a new object and replace all references to the target object with the new one. This
         * can be done without temporarily deleting properties, so the iteration order is well-defined.
         *
         * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
         * you hold the target object in a variable, then the value of the variable will not change.
         *
         * ```js
         * var oldMarkup = Prism.languages.markup;
         * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
         *
         * assert(oldMarkup !== Prism.languages.markup);
         * assert(newMarkup === Prism.languages.markup);
         * ```
         *
         * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
         * object to be modified.
         * @param {string} before The key to insert before.
         * @param {Grammar} insert An object containing the key-value pairs to be inserted.
         * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
         * object to be modified.
         *
         * Defaults to `Prism.languages`.
         * @returns {Grammar} The new grammar object.
         * @public
         */
        insertBefore: function(U, y, w, x) {
          x = x || /** @type {any} */
          s.languages;
          var E = x[U], S = {};
          for (var _ in E)
            if (E.hasOwnProperty(_)) {
              if (_ == y)
                for (var k in w)
                  w.hasOwnProperty(k) && (S[k] = w[k]);
              w.hasOwnProperty(_) || (S[_] = E[_]);
            }
          var M = x[U];
          return x[U] = S, s.languages.DFS(s.languages, function(A, L) {
            L === M && A != U && (this[A] = S);
          }), S;
        },
        // Traverse a language definition with Depth First Search
        DFS: function U(y, w, x, E) {
          E = E || {};
          var S = s.util.objId;
          for (var _ in y)
            if (y.hasOwnProperty(_)) {
              w.call(y, _, y[_], x || _);
              var k = y[_], M = s.util.type(k);
              M === "Object" && !E[S(k)] ? (E[S(k)] = !0, U(k, w, null, E)) : M === "Array" && !E[S(k)] && (E[S(k)] = !0, U(k, w, _, E));
            }
        }
      },
      plugins: {},
      /**
       * This is the most high-level function in Prism’s API.
       * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
       * each one of them.
       *
       * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
       *
       * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
       * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
       * @memberof Prism
       * @public
       */
      highlightAll: function(U, y) {
        s.highlightAllUnder(document, U, y);
      },
      /**
       * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
       * {@link Prism.highlightElement} on each one of them.
       *
       * The following hooks will be run:
       * 1. `before-highlightall`
       * 2. `before-all-elements-highlight`
       * 3. All hooks of {@link Prism.highlightElement} for each element.
       *
       * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
       * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
       * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
       * @memberof Prism
       * @public
       */
      highlightAllUnder: function(U, y, w) {
        var x = {
          callback: w,
          container: U,
          selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
        };
        s.hooks.run("before-highlightall", x), x.elements = Array.prototype.slice.apply(x.container.querySelectorAll(x.selector)), s.hooks.run("before-all-elements-highlight", x);
        for (var E = 0, S; S = x.elements[E++]; )
          s.highlightElement(S, y === !0, x.callback);
      },
      /**
       * Highlights the code inside a single element.
       *
       * The following hooks will be run:
       * 1. `before-sanity-check`
       * 2. `before-highlight`
       * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
       * 4. `before-insert`
       * 5. `after-highlight`
       * 6. `complete`
       *
       * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
       * the element's language.
       *
       * @param {Element} element The element containing the code.
       * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
       * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
       * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
       * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
       *
       * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
       * asynchronous highlighting to work. You can build your own bundle on the
       * [Download page](https://prismjs.com/download.html).
       * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
       * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
       * @memberof Prism
       * @public
       */
      highlightElement: function(U, y, w) {
        var x = s.util.getLanguage(U), E = s.languages[x];
        s.util.setLanguage(U, x);
        var S = U.parentElement;
        S && S.nodeName.toLowerCase() === "pre" && s.util.setLanguage(S, x);
        var _ = U.textContent, k = {
          element: U,
          language: x,
          grammar: E,
          code: _
        };
        function M(L) {
          k.highlightedCode = L, s.hooks.run("before-insert", k), k.element.innerHTML = k.highlightedCode, s.hooks.run("after-highlight", k), s.hooks.run("complete", k), w && w.call(k.element);
        }
        if (s.hooks.run("before-sanity-check", k), S = k.element.parentElement, S && S.nodeName.toLowerCase() === "pre" && !S.hasAttribute("tabindex") && S.setAttribute("tabindex", "0"), !k.code) {
          s.hooks.run("complete", k), w && w.call(k.element);
          return;
        }
        if (s.hooks.run("before-highlight", k), !k.grammar) {
          M(s.util.encode(k.code));
          return;
        }
        if (y && r.Worker) {
          var A = new Worker(s.filename);
          A.onmessage = function(L) {
            M(L.data);
          }, A.postMessage(JSON.stringify({
            language: k.language,
            code: k.code,
            immediateClose: !0
          }));
        } else
          M(s.highlight(k.code, k.grammar, k.language));
      },
      /**
       * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
       * and the language definitions to use, and returns a string with the HTML produced.
       *
       * The following hooks will be run:
       * 1. `before-tokenize`
       * 2. `after-tokenize`
       * 3. `wrap`: On each {@link Token}.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @param {string} language The name of the language definition passed to `grammar`.
       * @returns {string} The highlighted HTML.
       * @memberof Prism
       * @public
       * @example
       * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
       */
      highlight: function(U, y, w) {
        var x = {
          code: U,
          grammar: y,
          language: w
        };
        if (s.hooks.run("before-tokenize", x), !x.grammar)
          throw new Error('The language "' + x.language + '" has no grammar.');
        return x.tokens = s.tokenize(x.code, x.grammar), s.hooks.run("after-tokenize", x), c.stringify(s.util.encode(x.tokens), x.language);
      },
      /**
       * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
       * and the language definitions to use, and returns an array with the tokenized code.
       *
       * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
       *
       * This method could be useful in other contexts as well, as a very crude parser.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @returns {TokenStream} An array of strings and tokens, a token stream.
       * @memberof Prism
       * @public
       * @example
       * let code = `var foo = 0;`;
       * let tokens = Prism.tokenize(code, Prism.languages.javascript);
       * tokens.forEach(token => {
       *     if (token instanceof Prism.Token && token.type === 'number') {
       *         console.log(`Found numeric literal: ${token.content}`);
       *     }
       * });
       */
      tokenize: function(U, y) {
        var w = y.rest;
        if (w) {
          for (var x in w)
            y[x] = w[x];
          delete y.rest;
        }
        var E = new u();
        return h(E, E.head, U), o(U, E, y, E.head, 0), p(E);
      },
      /**
       * @namespace
       * @memberof Prism
       * @public
       */
      hooks: {
        all: {},
        /**
         * Adds the given callback to the list of callbacks for the given hook.
         *
         * The callback will be invoked when the hook it is registered for is run.
         * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
         *
         * One callback function can be registered to multiple hooks and the same hook multiple times.
         *
         * @param {string} name The name of the hook.
         * @param {HookCallback} callback The callback function which is given environment variables.
         * @public
         */
        add: function(U, y) {
          var w = s.hooks.all;
          w[U] = w[U] || [], w[U].push(y);
        },
        /**
         * Runs a hook invoking all registered callbacks with the given environment variables.
         *
         * Callbacks will be invoked synchronously and in the order in which they were registered.
         *
         * @param {string} name The name of the hook.
         * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
         * @public
         */
        run: function(U, y) {
          var w = s.hooks.all[U];
          if (!(!w || !w.length))
            for (var x = 0, E; E = w[x++]; )
              E(y);
        }
      },
      Token: c
    };
    r.Prism = s;
    function c(U, y, w, x) {
      this.type = U, this.content = y, this.alias = w, this.length = (x || "").length | 0;
    }
    c.stringify = function U(y, w) {
      if (typeof y == "string")
        return y;
      if (Array.isArray(y)) {
        var x = "";
        return y.forEach(function(M) {
          x += U(M, w);
        }), x;
      }
      var E = {
        type: y.type,
        content: U(y.content, w),
        tag: "span",
        classes: ["token", y.type],
        attributes: {},
        language: w
      }, S = y.alias;
      S && (Array.isArray(S) ? Array.prototype.push.apply(E.classes, S) : E.classes.push(S)), s.hooks.run("wrap", E);
      var _ = "";
      for (var k in E.attributes)
        _ += " " + k + '="' + (E.attributes[k] || "").replace(/"/g, "&quot;") + '"';
      return "<" + E.tag + ' class="' + E.classes.join(" ") + '"' + _ + ">" + E.content + "</" + E.tag + ">";
    };
    function d(U, y, w, x) {
      U.lastIndex = y;
      var E = U.exec(w);
      if (E && x && E[1]) {
        var S = E[1].length;
        E.index += S, E[0] = E[0].slice(S);
      }
      return E;
    }
    function o(U, y, w, x, E, S) {
      for (var _ in w)
        if (!(!w.hasOwnProperty(_) || !w[_])) {
          var k = w[_];
          k = Array.isArray(k) ? k : [k];
          for (var M = 0; M < k.length; ++M) {
            if (S && S.cause == _ + "," + M)
              return;
            var A = k[M], L = A.inside, R = !!A.lookbehind, z = !!A.greedy, F = A.alias;
            if (z && !A.pattern.global) {
              var W = A.pattern.toString().match(/[imsuy]*$/)[0];
              A.pattern = RegExp(A.pattern.source, W + "g");
            }
            for (var B = A.pattern || A, j = x.next, V = E; j !== y.tail && !(S && V >= S.reach); V += j.value.length, j = j.next) {
              var q = j.value;
              if (y.length > U.length)
                return;
              if (!(q instanceof c)) {
                var oe = 1, Ue;
                if (z) {
                  if (Ue = d(B, V, U, R), !Ue || Ue.index >= U.length)
                    break;
                  var Oe = Ue.index, fe = Ue.index + Ue[0].length, Pe = V;
                  for (Pe += j.value.length; Oe >= Pe; )
                    j = j.next, Pe += j.value.length;
                  if (Pe -= j.value.length, V = Pe, j.value instanceof c)
                    continue;
                  for (var ze = j; ze !== y.tail && (Pe < fe || typeof ze.value == "string"); ze = ze.next)
                    oe++, Pe += ze.value.length;
                  oe--, q = U.slice(V, Pe), Ue.index -= V;
                } else if (Ue = d(B, 0, q, R), !Ue)
                  continue;
                var Oe = Ue.index, Be = Ue[0], qe = q.slice(0, Oe), At = q.slice(Oe + Be.length), Je = V + q.length;
                S && Je > S.reach && (S.reach = Je);
                var mt = j.prev;
                qe && (mt = h(y, mt, qe), V += qe.length), f(y, mt, oe);
                var jt = new c(_, L ? s.tokenize(Be, L) : Be, F, Be);
                if (j = h(y, mt, jt), At && h(y, j, At), oe > 1) {
                  var _e = {
                    cause: _ + "," + M,
                    reach: Je
                  };
                  o(U, y, w, j.prev, V, _e), S && _e.reach > S.reach && (S.reach = _e.reach);
                }
              }
            }
          }
        }
    }
    function u() {
      var U = { value: null, prev: null, next: null }, y = { value: null, prev: U, next: null };
      U.next = y, this.head = U, this.tail = y, this.length = 0;
    }
    function h(U, y, w) {
      var x = y.next, E = { value: w, prev: y, next: x };
      return y.next = E, x.prev = E, U.length++, E;
    }
    function f(U, y, w) {
      for (var x = y.next, E = 0; E < w && x !== U.tail; E++)
        x = x.next;
      y.next = x, x.prev = y, U.length -= E;
    }
    function p(U) {
      for (var y = [], w = U.head.next; w !== U.tail; )
        y.push(w.value), w = w.next;
      return y;
    }
    if (!r.document)
      return r.addEventListener && (s.disableWorkerMessageHandler || r.addEventListener("message", function(U) {
        var y = JSON.parse(U.data), w = y.language, x = y.code, E = y.immediateClose;
        r.postMessage(s.highlight(x, s.languages[w], w)), E && r.close();
      }, !1)), s;
    var g = s.util.currentScript();
    g && (s.filename = g.src, g.hasAttribute("data-manual") && (s.manual = !0));
    function b() {
      s.manual || s.highlightAll();
    }
    if (!s.manual) {
      var v = document.readyState;
      v === "loading" || v === "interactive" && g && g.defer ? document.addEventListener("DOMContentLoaded", b) : window.requestAnimationFrame ? window.requestAnimationFrame(b) : window.setTimeout(b, 16);
    }
    return s;
  }(t);
  e.exports && (e.exports = n), typeof ya < "u" && (ya.Prism = n), n.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: !0
              }
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  }, n.languages.markup.tag.inside["attr-value"].inside.entity = n.languages.markup.entity, n.languages.markup.doctype.inside["internal-subset"].inside = n.languages.markup, n.hooks.add("wrap", function(r) {
    r.type === "entity" && (r.attributes.title = r.content.replace(/&amp;/, "&"));
  }), Object.defineProperty(n.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function(i, a) {
      var l = {};
      l["language-" + a] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: n.languages[a]
      }, l.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var s = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: l
        }
      };
      s["language-" + a] = {
        pattern: /[\s\S]+/,
        inside: n.languages[a]
      };
      var c = {};
      c[i] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return i;
        }), "i"),
        lookbehind: !0,
        greedy: !0,
        inside: s
      }, n.languages.insertBefore("markup", "cdata", c);
    }
  }), Object.defineProperty(n.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(r, i) {
      n.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + r + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [i, "language-" + i],
                inside: n.languages[i]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  }), n.languages.html = n.languages.markup, n.languages.mathml = n.languages.markup, n.languages.svg = n.languages.markup, n.languages.xml = n.languages.extend("markup", {}), n.languages.ssml = n.languages.xml, n.languages.atom = n.languages.xml, n.languages.rss = n.languages.xml, function(r) {
    var i = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    r.languages.css = {
      comment: /\/\*[\s\S]*?\*\//,
      atrule: {
        pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + i.source + ")*?" + /(?:;|(?=\s*\{))/.source),
        inside: {
          rule: /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: !0,
            alias: "selector"
          },
          keyword: {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: !0
          }
          // See rest below
        }
      },
      url: {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp("\\burl\\((?:" + i.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: !0,
        inside: {
          function: /^url/i,
          punctuation: /^\(|\)$/,
          string: {
            pattern: RegExp("^" + i.source + "$"),
            alias: "url"
          }
        }
      },
      selector: {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + i.source + ")*(?=\\s*\\{)"),
        lookbehind: !0
      },
      string: {
        pattern: i,
        greedy: !0
      },
      property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: !0
      },
      important: /!important\b/i,
      function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: !0
      },
      punctuation: /[(){};:,]/
    }, r.languages.css.atrule.inside.rest = r.languages.css;
    var a = r.languages.markup;
    a && (a.tag.addInlined("style", "css"), a.tag.addAttribute("style", "css"));
  }(n), n.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: !0,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  }, n.languages.javascript = n.languages.extend("clike", {
    "class-name": [
      n.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: !0
      }
    ],
    keyword: [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: !0
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: !0
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  }), n.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, n.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: !0,
          alias: "language-regex",
          inside: n.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    parameter: [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: !0,
        inside: n.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: !0,
        inside: n.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: !0,
        inside: n.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: !0,
        inside: n.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  }), n.languages.insertBefore("javascript", "string", {
    hashbang: {
      pattern: /^#!.*/,
      greedy: !0,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: !0,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: n.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    }
  }), n.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: !0,
      alias: "property"
    }
  }), n.languages.markup && (n.languages.markup.tag.addInlined("script", "javascript"), n.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  )), n.languages.js = n.languages.javascript, function() {
    if (typeof n > "u" || typeof document > "u")
      return;
    Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
    var r = "Loading…", i = function(g, b) {
      return "✖ Error " + g + " while fetching file: " + b;
    }, a = "✖ Error: File does not exist or is empty", l = {
      js: "javascript",
      py: "python",
      rb: "ruby",
      ps1: "powershell",
      psm1: "powershell",
      sh: "bash",
      bat: "batch",
      h: "c",
      tex: "latex"
    }, s = "data-src-status", c = "loading", d = "loaded", o = "failed", u = "pre[data-src]:not([" + s + '="' + d + '"]):not([' + s + '="' + c + '"])';
    function h(g, b, v) {
      var U = new XMLHttpRequest();
      U.open("GET", g, !0), U.onreadystatechange = function() {
        U.readyState == 4 && (U.status < 400 && U.responseText ? b(U.responseText) : U.status >= 400 ? v(i(U.status, U.statusText)) : v(a));
      }, U.send(null);
    }
    function f(g) {
      var b = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(g || "");
      if (b) {
        var v = Number(b[1]), U = b[2], y = b[3];
        return U ? y ? [v, Number(y)] : [v, void 0] : [v, v];
      }
    }
    n.hooks.add("before-highlightall", function(g) {
      g.selector += ", " + u;
    }), n.hooks.add("before-sanity-check", function(g) {
      var b = (
        /** @type {HTMLPreElement} */
        g.element
      );
      if (b.matches(u)) {
        g.code = "", b.setAttribute(s, c);
        var v = b.appendChild(document.createElement("CODE"));
        v.textContent = r;
        var U = b.getAttribute("data-src"), y = g.language;
        if (y === "none") {
          var w = (/\.(\w+)$/.exec(U) || [, "none"])[1];
          y = l[w] || w;
        }
        n.util.setLanguage(v, y), n.util.setLanguage(b, y);
        var x = n.plugins.autoloader;
        x && x.loadLanguages(y), h(
          U,
          function(E) {
            b.setAttribute(s, d);
            var S = f(b.getAttribute("data-range"));
            if (S) {
              var _ = E.split(/\r\n?|\n/g), k = S[0], M = S[1] == null ? _.length : S[1];
              k < 0 && (k += _.length), k = Math.max(0, Math.min(k - 1, _.length)), M < 0 && (M += _.length), M = Math.max(0, Math.min(M, _.length)), E = _.slice(k, M).join(`
`), b.hasAttribute("data-start") || b.setAttribute("data-start", String(k + 1));
            }
            v.textContent = E, n.highlightElement(v);
          },
          function(E) {
            b.setAttribute(s, o), v.textContent = E;
          }
        );
      }
    }), n.plugins.fileHighlight = {
      /**
       * Executes the File Highlight plugin for all matching `pre` elements under the given container.
       *
       * Note: Elements which are already loaded or currently loading will not be touched by this method.
       *
       * @param {ParentNode} [container=document]
       */
      highlight: function(b) {
        for (var v = (b || document).querySelectorAll(u), U = 0, y; y = v[U++]; )
          n.highlightElement(y);
      }
    };
    var p = !1;
    n.fileHighlight = function() {
      p || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), p = !0), n.plugins.fileHighlight.highlight.apply(this, arguments);
    };
  }();
})(aF);
Prism.languages.clike = {
  comment: [
    {
      pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
      lookbehind: !0,
      greedy: !0
    },
    {
      pattern: /(^|[^\\:])\/\/.*/,
      lookbehind: !0,
      greedy: !0
    }
  ],
  string: {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: !0
  },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: !0,
    inside: {
      punctuation: /[.\\]/
    }
  },
  keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  boolean: /\b(?:false|true)\b/,
  function: /\b\w+(?=\()/,
  number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  punctuation: /[{}[\];(),.:]/
};
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [
    Prism.languages.clike["class-name"],
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
      lookbehind: !0
    }
  ],
  keyword: [
    {
      pattern: /((?:^|\})\s*)catch\b/,
      lookbehind: !0
    },
    {
      pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
      lookbehind: !0
    }
  ],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  number: {
    pattern: RegExp(
      /(^|[^\w$])/.source + "(?:" + // constant
      (/NaN|Infinity/.source + "|" + // binary integer
      /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
      /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
      /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
      /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
      /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
    ),
    lookbehind: !0
  },
  operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  regex: {
    pattern: RegExp(
      // lookbehind
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
      // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
      // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
      // with the only syntax, so we have to define 2 different regex patterns.
      /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
      /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
      /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: !0,
    greedy: !0,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: !0,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  "function-variable": {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  },
  parameter: [
    {
      pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
      lookbehind: !0,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
      lookbehind: !0,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
      lookbehind: !0,
      inside: Prism.languages.javascript
    },
    {
      pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
      lookbehind: !0,
      inside: Prism.languages.javascript
    }
  ],
  constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism.languages.insertBefore("javascript", "string", {
  hashbang: {
    pattern: /^#!.*/,
    greedy: !0,
    alias: "comment"
  },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: !0,
    inside: {
      "template-punctuation": {
        pattern: /^`|`$/,
        alias: "string"
      },
      interpolation: {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: !0,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          rest: Prism.languages.javascript
        }
      },
      string: /[\s\S]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: !0,
    greedy: !0,
    alias: "property"
  }
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: !0,
    alias: "property"
  }
});
Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), Prism.languages.markup.tag.addAttribute(
  /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
  "javascript"
));
Prism.languages.js = Prism.languages.javascript;
Prism.languages.markup = {
  comment: {
    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    greedy: !0
  },
  prolog: {
    pattern: /<\?[\s\S]+?\?>/,
    greedy: !0
  },
  doctype: {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: !0,
    inside: {
      "internal-subset": {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: !0,
        greedy: !0,
        inside: null
        // see below
      },
      string: {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: !0
      },
      punctuation: /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      name: /[^\s<>'"]+/
    }
  },
  cdata: {
    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    greedy: !0
  },
  tag: {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: !0,
    inside: {
      tag: {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          punctuation: /^<\/?/,
          namespace: /^[^\s>\/:]+:/
        }
      },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          punctuation: [
            {
              pattern: /^=/,
              alias: "attr-equals"
            },
            {
              pattern: /^(\s*)["']|["']$/,
              lookbehind: !0
            }
          ]
        }
      },
      punctuation: /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          namespace: /^[^\s>\/:]+:/
        }
      }
    }
  },
  entity: [
    {
      pattern: /&[\da-z]{1,8};/i,
      alias: "named-entity"
    },
    /&#x?[\da-f]{1,8};/i
  ]
};
Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity;
Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function(e) {
  e.type === "entity" && (e.attributes.title = e.content.replace(/&amp;/, "&"));
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function(t, n) {
    var r = {};
    r["language-" + n] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: !0,
      inside: Prism.languages[n]
    }, r.cdata = /^<!\[CDATA\[|\]\]>$/i;
    var i = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: r
      }
    };
    i["language-" + n] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[n]
    };
    var a = {};
    a[t] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return t;
      }), "i"),
      lookbehind: !0,
      greedy: !0,
      inside: i
    }, Prism.languages.insertBefore("markup", "cdata", a);
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function(e, t) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(
        /(^|["'\s])/.source + "(?:" + e + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
        "i"
      ),
      lookbehind: !0,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            value: {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: !0,
              alias: [t, "language-" + t],
              inside: Prism.languages[t]
            },
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              /"|'/
            ]
          }
        }
      }
    });
  }
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;
(function(e) {
  var t = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function n(o) {
    return o = o.replace(/<inner>/g, function() {
      return t;
    }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + o + ")");
  }
  var r = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, i = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return r;
  }), a = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  e.languages.markdown = e.languages.extend("markup", {}), e.languages.insertBefore("markdown", "prolog", {
    "front-matter-block": {
      pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        punctuation: /^---|---$/,
        "front-matter": {
          pattern: /\S+(?:\s+\S+)*/,
          alias: ["yaml", "language-yaml"],
          inside: e.languages.yaml
        }
      }
    },
    blockquote: {
      // > ...
      pattern: /^>(?:[\t ]*>)*/m,
      alias: "punctuation"
    },
    table: {
      pattern: RegExp("^" + i + a + "(?:" + i + ")*", "m"),
      inside: {
        "table-data-rows": {
          pattern: RegExp("^(" + i + a + ")(?:" + i + ")*$"),
          lookbehind: !0,
          inside: {
            "table-data": {
              pattern: RegExp(r),
              inside: e.languages.markdown
            },
            punctuation: /\|/
          }
        },
        "table-line": {
          pattern: RegExp("^(" + i + ")" + a + "$"),
          lookbehind: !0,
          inside: {
            punctuation: /\||:?-{3,}:?/
          }
        },
        "table-header-row": {
          pattern: RegExp("^" + i + "$"),
          inside: {
            "table-header": {
              pattern: RegExp(r),
              alias: "important",
              inside: e.languages.markdown
            },
            punctuation: /\|/
          }
        }
      }
    },
    code: [
      {
        // Prefixed by 4 spaces or 1 tab and preceded by an empty line
        pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
        lookbehind: !0,
        alias: "keyword"
      },
      {
        // ```optional language
        // code block
        // ```
        pattern: /^```[\s\S]*?^```$/m,
        greedy: !0,
        inside: {
          "code-block": {
            pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
            lookbehind: !0
          },
          "code-language": {
            pattern: /^(```).+/,
            lookbehind: !0
          },
          punctuation: /```/
        }
      }
    ],
    title: [
      {
        // title 1
        // =======
        // title 2
        // -------
        pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
        alias: "important",
        inside: {
          punctuation: /==+$|--+$/
        }
      },
      {
        // # title 1
        // ###### title 6
        pattern: /(^\s*)#.+/m,
        lookbehind: !0,
        alias: "important",
        inside: {
          punctuation: /^#+|#+$/
        }
      }
    ],
    hr: {
      // ***
      // ---
      // * * *
      // -----------
      pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
      lookbehind: !0,
      alias: "punctuation"
    },
    list: {
      // * item
      // + item
      // - item
      // 1. item
      pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
      lookbehind: !0,
      alias: "punctuation"
    },
    "url-reference": {
      // [id]: http://example.com "Optional title"
      // [id]: http://example.com 'Optional title'
      // [id]: http://example.com (Optional title)
      // [id]: <http://example.com> "Optional title"
      pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
      inside: {
        variable: {
          pattern: /^(!?\[)[^\]]+/,
          lookbehind: !0
        },
        string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
        punctuation: /^[\[\]!:]|[<>]/
      },
      alias: "url"
    },
    bold: {
      // **strong**
      // __strong__
      // allow one nested instance of italic text using the same delimiter
      pattern: n(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
      lookbehind: !0,
      greedy: !0,
      inside: {
        content: {
          pattern: /(^..)[\s\S]+(?=..$)/,
          lookbehind: !0,
          inside: {}
          // see below
        },
        punctuation: /\*\*|__/
      }
    },
    italic: {
      // *em*
      // _em_
      // allow one nested instance of bold text using the same delimiter
      pattern: n(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
      lookbehind: !0,
      greedy: !0,
      inside: {
        content: {
          pattern: /(^.)[\s\S]+(?=.$)/,
          lookbehind: !0,
          inside: {}
          // see below
        },
        punctuation: /[*_]/
      }
    },
    strike: {
      // ~~strike through~~
      // ~strike~
      // eslint-disable-next-line regexp/strict
      pattern: n(/(~~?)(?:(?!~)<inner>)+\2/.source),
      lookbehind: !0,
      greedy: !0,
      inside: {
        content: {
          pattern: /(^~~?)[\s\S]+(?=\1$)/,
          lookbehind: !0,
          inside: {}
          // see below
        },
        punctuation: /~~?/
      }
    },
    "code-snippet": {
      // `code`
      // ``code``
      pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
      lookbehind: !0,
      greedy: !0,
      alias: ["code", "keyword"]
    },
    url: {
      // [example](http://example.com "Optional title")
      // [example][id]
      // [example] [id]
      pattern: n(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
      lookbehind: !0,
      greedy: !0,
      inside: {
        operator: /^!/,
        content: {
          pattern: /(^\[)[^\]]+(?=\])/,
          lookbehind: !0,
          inside: {}
          // see below
        },
        variable: {
          pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
          lookbehind: !0
        },
        url: {
          pattern: /(^\]\()[^\s)]+/,
          lookbehind: !0
        },
        string: {
          pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
          lookbehind: !0
        }
      }
    }
  }), ["url", "bold", "italic", "strike"].forEach(function(o) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(u) {
      o !== u && (e.languages.markdown[o].inside.content.inside[u] = e.languages.markdown[u]);
    });
  }), e.hooks.add("after-tokenize", function(o) {
    if (o.language !== "markdown" && o.language !== "md")
      return;
    function u(h) {
      if (!(!h || typeof h == "string"))
        for (var f = 0, p = h.length; f < p; f++) {
          var g = h[f];
          if (g.type !== "code") {
            u(g.content);
            continue;
          }
          var b = g.content[1], v = g.content[3];
          if (b && v && b.type === "code-language" && v.type === "code-block" && typeof b.content == "string") {
            var U = b.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
            U = (/[a-z][\w-]*/i.exec(U) || [""])[0].toLowerCase();
            var y = "language-" + U;
            v.alias ? typeof v.alias == "string" ? v.alias = [v.alias, y] : v.alias.push(y) : v.alias = [y];
          }
        }
    }
    u(o.tokens);
  }), e.hooks.add("wrap", function(o) {
    if (o.type === "code-block") {
      for (var u = "", h = 0, f = o.classes.length; h < f; h++) {
        var p = o.classes[h], g = /language-(.+)/.exec(p);
        if (g) {
          u = g[1];
          break;
        }
      }
      var b = e.languages[u];
      if (b)
        o.content = e.highlight(d(o.content), b, u);
      else if (u && u !== "none" && e.plugins.autoloader) {
        var v = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
        o.attributes.id = v, e.plugins.autoloader.loadLanguages(u, function() {
          var U = document.getElementById(v);
          U && (U.innerHTML = e.highlight(U.textContent, e.languages[u], u));
        });
      }
    }
  });
  var l = RegExp(e.languages.markup.tag.pattern.source, "gi"), s = {
    amp: "&",
    lt: "<",
    gt: ">",
    quot: '"'
  }, c = String.fromCodePoint || String.fromCharCode;
  function d(o) {
    var u = o.replace(l, "");
    return u = u.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(h, f) {
      if (f = f.toLowerCase(), f[0] === "#") {
        var p;
        return f[1] === "x" ? p = parseInt(f.slice(2), 16) : p = Number(f.slice(1)), c(p);
      } else {
        var g = s[f];
        return g || h;
      }
    }), u;
  }
  e.languages.md = e.languages.markdown;
})(Prism);
Prism.languages.c = Prism.languages.extend("clike", {
  comment: {
    pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: !0
  },
  string: {
    // https://en.cppreference.com/w/c/language/string_literal
    pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: !0
  },
  "class-name": {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: !0
  },
  keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
});
Prism.languages.insertBefore("c", "string", {
  char: {
    // https://en.cppreference.com/w/c/language/character_constant
    pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
    greedy: !0
  }
});
Prism.languages.insertBefore("c", "string", {
  macro: {
    // allow for multiline macro definitions
    // spaces after the # character compile fine with gcc
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: !0,
    greedy: !0,
    alias: "property",
    inside: {
      string: [
        {
          // highlight the path of the include statement as a string
          pattern: /^(#\s*include\s*)<[^>]+>/,
          lookbehind: !0
        },
        Prism.languages.c.string
      ],
      char: Prism.languages.c.char,
      comment: Prism.languages.c.comment,
      "macro-name": [
        {
          pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
          lookbehind: !0
        },
        {
          pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
          lookbehind: !0,
          alias: "function"
        }
      ],
      // highlight macro directives as keywords
      directive: {
        pattern: /^(#\s*)[a-z]+/,
        lookbehind: !0,
        alias: "keyword"
      },
      "directive-hash": /^#/,
      punctuation: /##|\\(?=[\r\n])/,
      expression: {
        pattern: /\S[\s\S]*/,
        inside: Prism.languages.c
      }
    }
  }
});
Prism.languages.insertBefore("c", "function", {
  // highlight predefined macros as constants
  constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
});
delete Prism.languages.c.boolean;
(function(e) {
  var t = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  e.languages.css = {
    comment: /\/\*[\s\S]*?\*\//,
    atrule: {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + t.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        rule: /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: !0,
          alias: "selector"
        },
        keyword: {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: !0
        }
        // See rest below
      }
    },
    url: {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp("\\burl\\((?:" + t.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: !0,
      inside: {
        function: /^url/i,
        punctuation: /^\(|\)$/,
        string: {
          pattern: RegExp("^" + t.source + "$"),
          alias: "url"
        }
      }
    },
    selector: {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + t.source + ")*(?=\\s*\\{)"),
      lookbehind: !0
    },
    string: {
      pattern: t,
      greedy: !0
    },
    property: {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: !0
    },
    important: /!important\b/i,
    function: {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: !0
    },
    punctuation: /[(){};:,]/
  }, e.languages.css.atrule.inside.rest = e.languages.css;
  var n = e.languages.markup;
  n && (n.tag.addInlined("style", "css"), n.tag.addAttribute("style", "css"));
})(Prism);
Prism.languages.objectivec = Prism.languages.extend("c", {
  string: {
    pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: !0
  },
  keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
  operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
});
delete Prism.languages.objectivec["class-name"];
Prism.languages.objc = Prism.languages.objectivec;
Prism.languages.sql = {
  comment: {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
    lookbehind: !0
  },
  variable: [
    {
      pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
      greedy: !0
    },
    /@[\w.$]+/
  ],
  string: {
    pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
    greedy: !0,
    lookbehind: !0
  },
  identifier: {
    pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    greedy: !0,
    lookbehind: !0,
    inside: {
      punctuation: /^`|`$/
    }
  },
  function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  // Should we highlight user defined functions too?
  keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
  number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  punctuation: /[;[\]()`,.]/
};
(function(e) {
  var t = e.languages.powershell = {
    comment: [
      {
        pattern: /(^|[^`])<#[\s\S]*?#>/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^`])#.*/,
        lookbehind: !0
      }
    ],
    string: [
      {
        pattern: /"(?:`[\s\S]|[^`"])*"/,
        greedy: !0,
        inside: null
        // see below
      },
      {
        pattern: /'(?:[^']|'')*'/,
        greedy: !0
      }
    ],
    // Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
    // Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
    namespace: /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
    boolean: /\$(?:false|true)\b/i,
    variable: /\$\w+\b/,
    // Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
    // Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
    // Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
    function: [
      /\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
      /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
    ],
    // per http://technet.microsoft.com/en-us/library/hh847744.aspx
    keyword: /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
    operator: {
      pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
      lookbehind: !0
    },
    punctuation: /[|{}[\];(),.]/
  };
  t.string[0].inside = {
    function: {
      // Allow for one level of nesting
      pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
      lookbehind: !0,
      inside: t
    },
    boolean: t.boolean,
    variable: t.variable
  };
})(Prism);
Prism.languages.python = {
  comment: {
    pattern: /(^|[^\\])#.*/,
    lookbehind: !0,
    greedy: !0
  },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: !0,
    inside: {
      interpolation: {
        // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: !0,
        inside: {
          "format-spec": {
            pattern: /(:)[^:(){}]+(?=\}$)/,
            lookbehind: !0
          },
          "conversion-option": {
            pattern: /![sra](?=[:}]$)/,
            alias: "punctuation"
          },
          rest: null
        }
      },
      string: /[\s\S]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: !0,
    alias: "string"
  },
  string: {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: !0
  },
  function: {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: !0
  },
  "class-name": {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: !0
  },
  decorator: {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: !0,
    alias: ["annotation", "punctuation"],
    inside: {
      punctuation: /\./
    }
  },
  keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  boolean: /\b(?:False|None|True)\b/,
  number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  punctuation: /[{}[\];(),.:]/
};
Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;
(function(e) {
  for (var t = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, n = 0; n < 2; n++)
    t = t.replace(/<self>/g, function() {
      return t;
    });
  t = t.replace(/<self>/g, function() {
    return /[^\s\S]/.source;
  }), e.languages.rust = {
    comment: [
      {
        pattern: RegExp(/(^|[^\\])/.source + t),
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
      greedy: !0
    },
    char: {
      pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
      greedy: !0
    },
    attribute: {
      pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
      greedy: !0,
      alias: "attr-name",
      inside: {
        string: null
        // see below
      }
    },
    // Closure params should not be confused with bitwise OR |
    "closure-params": {
      pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        "closure-punctuation": {
          pattern: /^\||\|$/,
          alias: "punctuation"
        },
        rest: null
        // see below
      }
    },
    "lifetime-annotation": {
      pattern: /'\w+/,
      alias: "symbol"
    },
    "fragment-specifier": {
      pattern: /(\$\w+:)[a-z]+/,
      lookbehind: !0,
      alias: "punctuation"
    },
    variable: /\$\w+/,
    "function-definition": {
      pattern: /(\bfn\s+)\w+/,
      lookbehind: !0,
      alias: "function"
    },
    "type-definition": {
      pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
      lookbehind: !0,
      alias: "class-name"
    },
    "module-declaration": [
      {
        pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
        lookbehind: !0,
        alias: "namespace"
      },
      {
        pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
        lookbehind: !0,
        alias: "namespace",
        inside: {
          punctuation: /::/
        }
      }
    ],
    keyword: [
      // https://github.com/rust-lang/reference/blob/master/src/keywords.md
      /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
      // primitives and str
      // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
      /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
    ],
    // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
    // and Rust's naming conventions recommend snake_case anyway.
    // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
    function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
    macro: {
      pattern: /\b\w+!/,
      alias: "property"
    },
    constant: /\b[A-Z_][A-Z_\d]+\b/,
    "class-name": /\b[A-Z]\w*\b/,
    namespace: {
      pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
      inside: {
        punctuation: /::/
      }
    },
    // Hex, oct, bin, dec numbers with visual separators and type suffix
    number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
    boolean: /\b(?:false|true)\b/,
    punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
    operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
  }, e.languages.rust["closure-params"].inside.rest = e.languages.rust, e.languages.rust.attribute.inside.string = e.languages.rust.string;
})(Prism);
Prism.languages.swift = {
  comment: {
    // Nested comments are supported up to 2 levels
    pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
    lookbehind: !0,
    greedy: !0
  },
  "string-literal": [
    // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
    {
      pattern: RegExp(
        /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: !0,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\\($/,
          alias: "punctuation"
        },
        punctuation: /\\(?=[\r\n])/,
        string: /[\s\S]+/
      }
    },
    {
      pattern: RegExp(
        /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: !0,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\#+\($/,
          alias: "punctuation"
        },
        string: /[\s\S]+/
      }
    }
  ],
  directive: {
    // directives with conditions
    pattern: RegExp(
      /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
    ),
    alias: "property",
    inside: {
      "directive-name": /^#\w+/,
      boolean: /\b(?:false|true)\b/,
      number: /\b\d+(?:\.\d+)*\b/,
      operator: /!|&&|\|\||[<>]=?/,
      punctuation: /[(),]/
    }
  },
  literal: {
    pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
    alias: "constant"
  },
  "other-directive": {
    pattern: /#\w+\b/,
    alias: "property"
  },
  attribute: {
    pattern: /@\w+/,
    alias: "atrule"
  },
  "function-definition": {
    pattern: /(\bfunc\s+)\w+/,
    lookbehind: !0,
    alias: "function"
  },
  label: {
    // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
    pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
    lookbehind: !0,
    alias: "important"
  },
  keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
  boolean: /\b(?:false|true)\b/,
  nil: {
    pattern: /\bnil\b/,
    alias: "constant"
  },
  "short-argument": /\$\d+\b/,
  omit: {
    pattern: /\b_\b/,
    alias: "keyword"
  },
  number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
  // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
  "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
  // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
  // This regex only supports ASCII operators.
  operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
  punctuation: /[{}[\]();,.:\\]/
};
Prism.languages.swift["string-literal"].forEach(function(e) {
  e.inside.interpolation.inside = Prism.languages.swift;
});
(function(e) {
  e.languages.typescript = e.languages.extend("javascript", {
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: !0,
      greedy: !0,
      inside: null
      // see below
    },
    builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
  }), e.languages.typescript.keyword.push(
    /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
    // keywords that have to be followed by an identifier
    /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
    // This is for `import type *, {}`
    /\btype\b(?=\s*(?:[\{*]|$))/
  ), delete e.languages.typescript.parameter, delete e.languages.typescript["literal-property"];
  var t = e.languages.extend("typescript", {});
  delete t["class-name"], e.languages.typescript["class-name"].inside = t, e.languages.insertBefore("typescript", "function", {
    decorator: {
      pattern: /@[$\w\xA0-\uFFFF]+/,
      inside: {
        at: {
          pattern: /^@/,
          alias: "operator"
        },
        function: /^[\s\S]+/
      }
    },
    "generic-function": {
      // e.g. foo<T extends "bar" | "baz">( ...
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
      greedy: !0,
      inside: {
        function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
        generic: {
          pattern: /<[\s\S]+/,
          // everything after the first <
          alias: "class-name",
          inside: t
        }
      }
    }
  }), e.languages.ts = e.languages.typescript;
})(Prism);
(function(e) {
  var t = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/, n = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, r = {
    pattern: RegExp(/(^|[^\w.])/.source + n + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
    lookbehind: !0,
    inside: {
      namespace: {
        pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
        inside: {
          punctuation: /\./
        }
      },
      punctuation: /\./
    }
  };
  e.languages.java = e.languages.extend("clike", {
    string: {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
      lookbehind: !0,
      greedy: !0
    },
    "class-name": [
      r,
      {
        // variables, parameters, and constructor references
        // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
        pattern: RegExp(/(^|[^\w.])/.source + n + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
        lookbehind: !0,
        inside: r.inside
      },
      {
        // class names based on keyword
        // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
        pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + n + /[A-Z]\w*\b/.source),
        lookbehind: !0,
        inside: r.inside
      }
    ],
    keyword: t,
    function: [
      e.languages.clike.function,
      {
        pattern: /(::\s*)[a-z_]\w*/,
        lookbehind: !0
      }
    ],
    number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    operator: {
      pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
      lookbehind: !0
    },
    constant: /\b[A-Z][A-Z_\d]+\b/
  }), e.languages.insertBefore("java", "string", {
    "triple-quoted-string": {
      // http://openjdk.java.net/jeps/355#Description
      pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
      greedy: !0,
      alias: "string"
    },
    char: {
      pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
      greedy: !0
    }
  }), e.languages.insertBefore("java", "class-name", {
    annotation: {
      pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
      lookbehind: !0,
      alias: "punctuation"
    },
    generics: {
      pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
      inside: {
        "class-name": r,
        keyword: t,
        punctuation: /[<>(),.:]/,
        operator: /[?&|]/
      }
    },
    import: [
      {
        pattern: RegExp(/(\bimport\s+)/.source + n + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
        lookbehind: !0,
        inside: {
          namespace: r.inside.namespace,
          punctuation: /\./,
          operator: /\*/,
          "class-name": /\w+/
        }
      },
      {
        pattern: RegExp(/(\bimport\s+static\s+)/.source + n + /(?:\w+|\*)(?=\s*;)/.source),
        lookbehind: !0,
        alias: "static",
        inside: {
          namespace: r.inside.namespace,
          static: /\b\w+$/,
          punctuation: /\./,
          operator: /\*/,
          "class-name": /\w+/
        }
      }
    ],
    namespace: {
      pattern: RegExp(
        /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
          return t.source;
        })
      ),
      lookbehind: !0,
      inside: {
        punctuation: /\./
      }
    }
  });
})(Prism);
(function(e) {
  var t = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, n = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return t.source;
  });
  e.languages.cpp = e.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
          return t.source;
        })),
        lookbehind: !0
      },
      // This is intended to capture the class name of method implementations like:
      //   void foo::bar() const {}
      // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
      // it starts with an uppercase letter. This approximation should give decent results.
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      // This will capture the class name before destructors like:
      //   Foo::~Foo() {}
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      // This also intends to capture the class name of method implementations but here the class has template
      // parameters, so it can't be a namespace (until C++ adds generic namespaces).
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
    ],
    keyword: t,
    number: {
      pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: !0
    },
    operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    boolean: /\b(?:false|true)\b/
  }), e.languages.insertBefore("cpp", "string", {
    module: {
      // https://en.cppreference.com/w/cpp/language/modules
      pattern: RegExp(
        /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
        /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
        /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
          return n;
        }) + ")"
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        string: /^[<"][\s\S]+/,
        operator: /:/,
        punctuation: /\./
      }
    },
    "raw-string": {
      pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
      alias: "string",
      greedy: !0
    }
  }), e.languages.insertBefore("cpp", "keyword", {
    "generic-function": {
      pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
      inside: {
        function: /^\w+/,
        generic: {
          pattern: /<[\s\S]+/,
          alias: "class-name",
          inside: e.languages.cpp
        }
      }
    }
  }), e.languages.insertBefore("cpp", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  }), e.languages.insertBefore("cpp", "class-name", {
    // the base clause is an optional list of parent classes
    // https://en.cppreference.com/w/cpp/language/class
    "base-clause": {
      pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
      lookbehind: !0,
      greedy: !0,
      inside: e.languages.extend("cpp", {})
    }
  }), e.languages.insertBefore("inside", "double-colon", {
    // All untokenized words that are not namespaces should be class names
    "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
  }, e.languages.cpp["base-clause"]);
})(Prism);
function lF(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
lF(function(e) {
  const t = new URLSearchParams();
  t.append("code", e);
  for (let n = 1; n < arguments.length; n++) t.append("v", arguments[n]);
  throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
});
const sF = globalThis.Prism || window.Prism, dv = (e) => {
  try {
    return !!e && sF.languages.hasOwnProperty(e);
  } catch {
    return !1;
  }
};
function vC(e, t) {
  for (const n of e.childNodes) {
    if (Ti(n) && n.tagName === t) return !0;
    vC(n, t);
  }
  return !1;
}
const Fu = "data-language", s1 = "data-highlight-language";
let Q3 = class yC extends tr {
  static getType() {
    return "code";
  }
  static clone(t) {
    return new yC(t.__language, t.__key);
  }
  constructor(t, n) {
    super(n), this.__language = t, this.__isSyntaxHighlightSupported = dv(t);
  }
  createDOM(t) {
    const n = document.createElement("code");
    zn(n, t.theme.code), n.setAttribute("spellcheck", "false");
    const r = this.getLanguage();
    return r && (n.setAttribute(Fu, r), this.getIsSyntaxHighlightSupported() && n.setAttribute(s1, r)), n;
  }
  updateDOM(t, n, r) {
    const i = this.__language, a = t.__language;
    return i ? i !== a && (n.setAttribute(Fu, i), this.__isSyntaxHighlightSupported && n.setAttribute(s1, i)) : a && (n.removeAttribute(Fu), t.__isSyntaxHighlightSupported && n.removeAttribute(s1)), !1;
  }
  exportDOM(t) {
    const n = document.createElement("pre");
    zn(n, t._config.theme.code), n.setAttribute("spellcheck", "false");
    const r = this.getLanguage();
    return r && (n.setAttribute(Fu, r), this.getIsSyntaxHighlightSupported() && n.setAttribute(s1, r)), { element: n };
  }
  static importDOM() {
    return { code: (t) => t.textContent != null && (/\r?\n/.test(t.textContent) || vC(t, "BR")) ? { conversion: uv, priority: 1 } : null, div: () => ({ conversion: cF, priority: 1 }), pre: () => ({ conversion: uv, priority: 0 }), table: (t) => q2(t) ? { conversion: dF, priority: 3 } : null, td: (t) => {
      const n = t, r = n.closest("table");
      return n.classList.contains("js-file-line") || r && q2(r) ? { conversion: hv, priority: 3 } : null;
    }, tr: (t) => {
      const n = t.closest("table");
      return n && q2(n) ? { conversion: hv, priority: 3 } : null;
    } };
  }
  static importJSON(t) {
    const n = Ic(t.language);
    return n.setFormat(t.format), n.setIndent(t.indent), n.setDirection(t.direction), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), language: this.getLanguage(), type: "code", version: 1 };
  }
  insertNewAfter(t, n = !0) {
    const r = this.getChildren(), i = r.length;
    if (i >= 2 && r[i - 1].getTextContent() === `
` && r[i - 2].getTextContent() === `
` && t.isCollapsed() && t.anchor.key === this.__key && t.anchor.offset === i) {
      r[i - 1].remove(), r[i - 2].remove();
      const c = He();
      return this.insertAfter(c, n), c;
    }
    const { anchor: a, focus: l } = t, s = (a.isBefore(l) ? a : l).getNode();
    if (ce(s)) {
      let c = uF(s);
      const d = [];
      for (; ; ) if (V3(c)) d.push($0()), c = c.getNextSibling();
      else {
        if (!eb(c)) break;
        {
          let b = 0;
          const v = c.getTextContent(), U = c.getTextContentSize();
          for (; b < U && v[b] === " "; ) b++;
          if (b !== 0 && d.push(EC(" ".repeat(b))), b !== U) break;
          c = c.getNextSibling();
        }
      }
      const o = s.splitText(a.offset)[0], u = a.offset === 0 ? 0 : 1, h = o.getIndexWithinParent() + u, f = s.getParentOrThrow(), p = [hs(), ...d];
      f.splice(h, 0, p);
      const g = d[d.length - 1];
      g ? g.select() : a.offset === 0 ? o.selectPrevious() : o.getNextSibling().selectNext(0, 0);
    }
    if (oF(s)) {
      const { offset: c } = t.anchor;
      s.splice(c, 0, [hs()]), s.select(c + 1, c + 1);
    }
    return null;
  }
  canIndent() {
    return !1;
  }
  collapseAtStart() {
    const t = He();
    return this.getChildren().forEach((n) => t.append(n)), this.replace(t), !0;
  }
  setLanguage(t) {
    const n = this.getWritable();
    n.__language = t, n.__isSyntaxHighlightSupported = dv(t);
  }
  getLanguage() {
    return this.getLatest().__language;
  }
  getIsSyntaxHighlightSupported() {
    return this.getLatest().__isSyntaxHighlightSupported;
  }
};
function Ic(e) {
  return En(new Q3(e));
}
function oF(e) {
  return e instanceof Q3;
}
function uv(e) {
  return { node: Ic(e.getAttribute(Fu)) };
}
function cF(e) {
  const t = e, n = fv(t);
  return n || function(r) {
    let i = r.parentElement;
    for (; i !== null; ) {
      if (fv(i)) return !0;
      i = i.parentElement;
    }
    return !1;
  }(t) ? { node: n ? Ic() : null } : { node: null };
}
function dF() {
  return { node: Ic() };
}
function hv() {
  return { node: null };
}
function fv(e) {
  return e.style.fontFamily.match("monospace") !== null;
}
function q2(e) {
  return e.classList.contains("js-file-line-container");
}
let wC = class xC extends aa {
  constructor(t, n, r) {
    super(t, r), this.__highlightType = n;
  }
  static getType() {
    return "code-highlight";
  }
  static clone(t) {
    return new xC(t.__text, t.__highlightType || void 0, t.__key);
  }
  getHighlightType() {
    return this.getLatest().__highlightType;
  }
  canHaveFormat() {
    return !1;
  }
  createDOM(t) {
    const n = super.createDOM(t), r = Z2(t.theme, this.__highlightType);
    return zn(n, r), n;
  }
  updateDOM(t, n, r) {
    const i = super.updateDOM(t, n, r), a = Z2(r.theme, t.__highlightType), l = Z2(r.theme, this.__highlightType);
    return a !== l && (a && id(n, a), l && zn(n, l)), i;
  }
  static importJSON(t) {
    const n = EC(t.text, t.highlightType);
    return n.setFormat(t.format), n.setDetail(t.detail), n.setMode(t.mode), n.setStyle(t.style), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), highlightType: this.getHighlightType(), type: "code-highlight", version: 1 };
  }
  setFormat(t) {
    return this;
  }
  isParentRequired() {
    return !0;
  }
  createParentElementNode() {
    return Ic();
  }
};
function Z2(e, t) {
  return t && e && e.codeHighlight && e.codeHighlight[t];
}
function EC(e, t) {
  return En(new wC(e, t));
}
function eb(e) {
  return e instanceof wC;
}
function uF(e) {
  let t = e, n = e;
  for (; eb(n) || V3(n); ) t = n, n = n.getPreviousSibling();
  return t;
}
let SC = class _C extends aa {
  static getType() {
    return "hashtag";
  }
  static clone(t) {
    return new _C(t.__text, t.__key);
  }
  constructor(t, n) {
    super(t, n);
  }
  createDOM(t) {
    const n = super.createDOM(t);
    return zn(n, t.theme.hashtag), n;
  }
  static importJSON(t) {
    const n = hF(t.text);
    return n.setFormat(t.format), n.setDetail(t.detail), n.setMode(t.mode), n.setStyle(t.style), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), type: "hashtag" };
  }
  canInsertTextBefore() {
    return !1;
  }
  isTextEntity() {
    return !0;
  }
};
function hF(e = "") {
  return En(new SC(e));
}
const fF = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
let H0 = class kC extends tr {
  static getType() {
    return "link";
  }
  static clone(t) {
    return new kC(t.__url, { rel: t.__rel, target: t.__target, title: t.__title }, t.__key);
  }
  constructor(t, n = {}, r) {
    super(r);
    const { target: i = null, rel: a = null, title: l = null } = n;
    this.__url = t, this.__target = i, this.__rel = a, this.__title = l;
  }
  createDOM(t) {
    const n = document.createElement("a");
    return n.href = this.sanitizeUrl(this.__url), this.__target !== null && (n.target = this.__target), this.__rel !== null && (n.rel = this.__rel), this.__title !== null && (n.title = this.__title), zn(n, t.theme.link), n;
  }
  updateDOM(t, n, r) {
    if (n instanceof HTMLAnchorElement) {
      const i = this.__url, a = this.__target, l = this.__rel, s = this.__title;
      i !== t.__url && (n.href = i), a !== t.__target && (a ? n.target = a : n.removeAttribute("target")), l !== t.__rel && (l ? n.rel = l : n.removeAttribute("rel")), s !== t.__title && (s ? n.title = s : n.removeAttribute("title"));
    }
    return !1;
  }
  static importDOM() {
    return { a: (t) => ({ conversion: pF, priority: 1 }) };
  }
  static importJSON(t) {
    const n = Ah(t.url, { rel: t.rel, target: t.target, title: t.title });
    return n.setFormat(t.format), n.setIndent(t.indent), n.setDirection(t.direction), n;
  }
  sanitizeUrl(t) {
    try {
      const n = new URL(t);
      if (!fF.has(n.protocol)) return "about:blank";
    } catch {
      return t;
    }
    return t;
  }
  exportJSON() {
    return { ...super.exportJSON(), rel: this.getRel(), target: this.getTarget(), title: this.getTitle(), type: "link", url: this.getURL(), version: 1 };
  }
  getURL() {
    return this.getLatest().__url;
  }
  setURL(t) {
    this.getWritable().__url = t;
  }
  getTarget() {
    return this.getLatest().__target;
  }
  setTarget(t) {
    this.getWritable().__target = t;
  }
  getRel() {
    return this.getLatest().__rel;
  }
  setRel(t) {
    this.getWritable().__rel = t;
  }
  getTitle() {
    return this.getLatest().__title;
  }
  setTitle(t) {
    this.getWritable().__title = t;
  }
  insertNewAfter(t, n = !0) {
    const r = Ah(this.__url, { rel: this.__rel, target: this.__target, title: this.__title });
    return this.insertAfter(r, n), r;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
  canBeEmpty() {
    return !1;
  }
  isInline() {
    return !0;
  }
  extractWithChild(t, n, r) {
    if (!ie(n)) return !1;
    const i = n.anchor.getNode(), a = n.focus.getNode();
    return this.isParentOf(i) && this.isParentOf(a) && n.getTextContent().length > 0;
  }
  isEmailURI() {
    return this.__url.startsWith("mailto:");
  }
  isWebSiteURI() {
    return this.__url.startsWith("https://") || this.__url.startsWith("http://");
  }
};
function pF(e) {
  let t = null;
  if (x$(e)) {
    const n = e.textContent;
    (n !== null && n !== "" || e.children.length > 0) && (t = Ah(e.getAttribute("href") || "", { rel: e.getAttribute("rel"), target: e.getAttribute("target"), title: e.getAttribute("title") }));
  }
  return { node: t };
}
function Ah(e, t) {
  return En(new H0(e, t));
}
function qn(e) {
  return e instanceof H0;
}
let Ef = class CC extends H0 {
  constructor(t, n = {}, r) {
    super(t, n, r), this.__isUnlinked = n.isUnlinked !== void 0 && n.isUnlinked !== null && n.isUnlinked;
  }
  static getType() {
    return "autolink";
  }
  static clone(t) {
    return new CC(t.__url, { isUnlinked: t.__isUnlinked, rel: t.__rel, target: t.__target, title: t.__title }, t.__key);
  }
  getIsUnlinked() {
    return this.__isUnlinked;
  }
  setIsUnlinked(t) {
    const n = this.getWritable();
    return n.__isUnlinked = t, n;
  }
  createDOM(t) {
    return this.__isUnlinked ? document.createElement("span") : super.createDOM(t);
  }
  updateDOM(t, n, r) {
    return super.updateDOM(t, n, r) || t.__isUnlinked !== this.__isUnlinked;
  }
  static importJSON(t) {
    const n = m4(t.url, { isUnlinked: t.isUnlinked, rel: t.rel, target: t.target, title: t.title });
    return n.setFormat(t.format), n.setIndent(t.indent), n.setDirection(t.direction), n;
  }
  static importDOM() {
    return null;
  }
  exportJSON() {
    return { ...super.exportJSON(), isUnlinked: this.__isUnlinked, type: "autolink", version: 1 };
  }
  insertNewAfter(t, n = !0) {
    const r = this.getParentOrThrow().insertNewAfter(t, n);
    if (re(r)) {
      const i = m4(this.__url, { isUnlinked: this.__isUnlinked, rel: this.__rel, target: this.__target, title: this.__title });
      return r.append(i), i;
    }
    return null;
  }
};
function m4(e, t) {
  return En(new Ef(e, t));
}
function Ql(e) {
  return e instanceof Ef;
}
const Ul = xn();
function J2(e, t = {}) {
  const { target: n, title: r } = t, i = t.rel === void 0 ? "noreferrer" : t.rel, a = se();
  if (!ie(a)) return;
  const l = a.extract();
  if (e === null) l.forEach((s) => {
    const c = Xe(s, (d) => !Ql(d) && qn(d));
    if (c) {
      const d = c.getChildren();
      for (let o = 0; o < d.length; o++) c.insertBefore(d[o]);
      c.remove();
    }
  });
  else {
    if (l.length === 1) {
      const d = function(o, u) {
        let h = o;
        for (; h !== null && h.getParent() !== null && !u(h); ) h = h.getParentOrThrow();
        return u(h) ? h : null;
      }(l[0], qn);
      if (d !== null) return d.setURL(e), n !== void 0 && d.setTarget(n), i !== null && d.setRel(i), void (r !== void 0 && d.setTitle(r));
    }
    let s = null, c = null;
    l.forEach((d) => {
      const o = d.getParent();
      if (o !== c && o !== null && (!re(d) || d.isInline())) {
        if (qn(o)) return c = o, o.setURL(e), n !== void 0 && o.setTarget(n), i !== null && c.setRel(i), void (r !== void 0 && c.setTitle(r));
        if (o.is(s) || (s = o, c = Ah(e, { rel: i, target: n, title: r }), qn(o) ? d.getPreviousSibling() === null ? o.insertBefore(c) : o.insertAfter(c) : d.insertBefore(c)), qn(d)) {
          if (d.is(c)) return;
          if (c !== null) {
            const u = d.getChildren();
            for (let h = 0; h < u.length; h++) c.append(u[h]);
          }
          d.remove();
        } else c !== null && c.append(d);
      }
    });
  }
}
function mF(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ol = mF(function(e) {
  const t = new URLSearchParams();
  t.append("code", e);
  for (let n = 1; n < arguments.length; n++) t.append("v", arguments[n]);
  throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
});
function g4(e) {
  let t = 1, n = e.getParent();
  for (; n != null; ) {
    if (Gt(n)) {
      const r = n.getParent();
      if (vt(r)) {
        t++, n = r.getParent();
        continue;
      }
      ol(40);
    }
    return t;
  }
  return t;
}
function b4(e) {
  let t = e.getParent();
  vt(t) || ol(40);
  let n = t;
  for (; n !== null; ) n = n.getParent(), vt(n) && (t = n);
  return t;
}
function MC(e) {
  let t = [];
  const n = e.getChildren().filter(Gt);
  for (let r = 0; r < n.length; r++) {
    const i = n[r], a = i.getFirstChild();
    vt(a) ? t = t.concat(MC(a)) : t.push(i);
  }
  return t;
}
function cl(e) {
  return Gt(e) && vt(e.getFirstChild());
}
function pv(e) {
  return Ii().append(e);
}
function TC(e, t) {
  return Gt(e) && (t.length === 0 || t.length === 1 && e.is(t[0]) && e.getChildrenSize() === 0);
}
function U4(e, t) {
  e.update(() => {
    const n = se();
    if (n !== null) {
      const r = n.getNodes();
      if (ie(n)) {
        const a = n.getStartEndPoints();
        a === null && ol(143);
        const [l] = a, s = l.getNode(), c = s.getParent();
        if (TC(s, r)) {
          const d = di(t);
          if (er(c)) {
            s.replace(d);
            const o = Ii();
            re(s) && (o.setFormat(s.getFormatType()), o.setIndent(s.getIndent())), d.append(o);
          } else if (Gt(s)) {
            const o = s.getParentOrThrow();
            Ac(d, o.getChildren()), o.replace(d);
          }
          return;
        }
      }
      const i = /* @__PURE__ */ new Set();
      for (let a = 0; a < r.length; a++) {
        const l = r[a];
        if (!re(l) || !l.isEmpty() || Gt(l) || i.has(l.getKey())) {
          if (vk(l)) {
            let s = l.getParent();
            for (; s != null; ) {
              const c = s.getKey();
              if (vt(s)) {
                if (!i.has(c)) {
                  const d = di(t);
                  Ac(d, s.getChildren()), s.replace(d), i.add(c);
                }
                break;
              }
              {
                const d = s.getParent();
                if (er(d) && !i.has(c)) {
                  i.add(c), mv(s, t);
                  break;
                }
                s = d;
              }
            }
          }
        } else mv(l, t);
      }
    }
  });
}
function Ac(e, t) {
  e.splice(e.getChildrenSize(), 0, t);
}
function mv(e, t) {
  if (vt(e)) return e;
  const n = e.getPreviousSibling(), r = e.getNextSibling(), i = Ii();
  let a;
  if (Ac(i, e.getChildren()), vt(n) && t === n.getListType()) n.append(i), vt(r) && t === r.getListType() && (Ac(n, r.getChildren()), r.remove()), a = n;
  else if (vt(r) && t === r.getListType()) r.getFirstChildOrThrow().insertBefore(i), a = r;
  else {
    const l = di(t);
    l.append(i), e.replace(l), a = l;
  }
  return i.setFormat(e.getFormatType()), i.setIndent(e.getIndent()), e.remove(), a;
}
function tb(e, t) {
  const n = e.getLastChild(), r = t.getFirstChild();
  n && r && cl(n) && cl(r) && (tb(n.getFirstChild(), r.getFirstChild()), r.remove());
  const i = t.getChildren();
  i.length > 0 && e.append(...i), t.remove();
}
function gF(e) {
  e.update(() => {
    const t = se();
    if (ie(t)) {
      const n = /* @__PURE__ */ new Set(), r = t.getNodes(), i = t.anchor.getNode();
      if (TC(i, r)) n.add(b4(i));
      else for (let a = 0; a < r.length; a++) {
        const l = r[a];
        if (vk(l)) {
          const s = UC(l, Sf);
          s != null && n.add(b4(s));
        }
      }
      for (const a of n) {
        let l = a;
        const s = MC(a);
        for (const c of s) {
          const d = He();
          Ac(d, c.getChildren()), l.insertAfter(d), l = d, c.__key === t.anchor.key && t.anchor.set(d.getKey(), 0, "element"), c.__key === t.focus.key && t.focus.set(d.getKey(), 0, "element"), c.remove();
        }
        a.remove();
      }
    }
  });
}
function bF(e) {
  const t = /* @__PURE__ */ new Set();
  if (cl(e) || t.has(e.getKey())) return;
  const n = e.getParent(), r = e.getNextSibling(), i = e.getPreviousSibling();
  if (cl(r) && cl(i)) {
    const a = i.getFirstChild();
    if (vt(a)) {
      a.append(e);
      const l = r.getFirstChild();
      vt(l) && (Ac(a, l.getChildren()), r.remove(), t.add(r.getKey()));
    }
  } else if (cl(r)) {
    const a = r.getFirstChild();
    if (vt(a)) {
      const l = a.getFirstChild();
      l !== null && l.insertBefore(e);
    }
  } else if (cl(i)) {
    const a = i.getFirstChild();
    vt(a) && a.append(e);
  } else if (vt(n)) {
    const a = Ii(), l = di(n.getListType());
    a.append(l), l.append(e), i ? i.insertAfter(a) : r ? r.insertBefore(a) : n.append(a);
  }
}
function UF(e) {
  if (cl(e)) return;
  const t = e.getParent(), n = t ? t.getParent() : void 0;
  if (vt(n ? n.getParent() : void 0) && Gt(n) && vt(t)) {
    const r = t ? t.getFirstChild() : void 0, i = t ? t.getLastChild() : void 0;
    if (e.is(r)) n.insertBefore(e), t.isEmpty() && n.remove();
    else if (e.is(i)) n.insertAfter(e), t.isEmpty() && n.remove();
    else {
      const a = t.getListType(), l = Ii(), s = di(a);
      l.append(s), e.getPreviousSiblings().forEach((o) => s.append(o));
      const c = Ii(), d = di(a);
      c.append(d), Ac(d, e.getNextSiblings()), n.insertBefore(l), n.insertAfter(c), n.replace(e);
    }
  }
}
function vF() {
  const e = se();
  if (!ie(e) || !e.isCollapsed()) return !1;
  const t = e.anchor.getNode();
  if (!Gt(t) || t.getChildrenSize() !== 0) return !1;
  const n = b4(t), r = t.getParent();
  vt(r) || ol(40);
  const i = r.getParent();
  let a;
  if (er(i)) a = He(), n.insertAfter(a);
  else {
    if (!Gt(i)) return !1;
    a = Ii(), i.insertAfter(a);
  }
  a.select();
  const l = t.getNextSiblings();
  if (l.length > 0) {
    const s = di(r.getListType());
    if (La(a)) a.insertAfter(s);
    else {
      const c = Ii();
      c.append(s), a.insertAfter(c);
    }
    l.forEach((c) => {
      c.remove(), s.append(c);
    });
  }
  return function(s) {
    let c = s;
    for (; c.getNextSibling() == null && c.getPreviousSibling() == null; ) {
      const d = c.getParent();
      if (d == null || !Gt(c) && !vt(c)) break;
      c = d;
    }
    c.remove();
  }(t), !0;
}
function Jp(...e) {
  const t = [];
  for (const n of e) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) t.push(r);
  return t;
}
let Sf = class IC extends tr {
  static getType() {
    return "listitem";
  }
  static clone(t) {
    return new IC(t.__value, t.__checked, t.__key);
  }
  constructor(t, n, r) {
    super(r), this.__value = t === void 0 ? 1 : t, this.__checked = n;
  }
  createDOM(t) {
    const n = document.createElement("li"), r = this.getParent();
    return vt(r) && r.getListType() === "check" && bv(n, this, null), n.value = this.__value, gv(n, t.theme, this), n;
  }
  updateDOM(t, n, r) {
    const i = this.getParent();
    return vt(i) && i.getListType() === "check" && bv(n, this, t), n.value = this.__value, gv(n, r.theme, this), !1;
  }
  static transform() {
    return (t) => {
      if (Gt(t) || ol(144), t.__checked == null) return;
      const n = t.getParent();
      vt(n) && n.getListType() !== "check" && t.getChecked() != null && t.setChecked(void 0);
    };
  }
  static importDOM() {
    return { li: () => ({ conversion: yF, priority: 0 }) };
  }
  static importJSON(t) {
    const n = Ii();
    return n.setChecked(t.checked), n.setValue(t.value), n.setFormat(t.format), n.setDirection(t.direction), n;
  }
  exportDOM(t) {
    const n = this.createDOM(t._config);
    return n.style.textAlign = this.getFormatType(), { element: n };
  }
  exportJSON() {
    return { ...super.exportJSON(), checked: this.getChecked(), type: "listitem", value: this.getValue(), version: 1 };
  }
  append(...t) {
    for (let n = 0; n < t.length; n++) {
      const r = t[n];
      if (re(r) && this.canMergeWith(r)) {
        const i = r.getChildren();
        this.append(...i), r.remove();
      } else super.append(r);
    }
    return this;
  }
  replace(t, n) {
    if (Gt(t)) return super.replace(t);
    this.setIndent(0);
    const r = this.getParentOrThrow();
    if (!vt(r)) return t;
    if (r.__first === this.getKey()) r.insertBefore(t);
    else if (r.__last === this.getKey()) r.insertAfter(t);
    else {
      const i = di(r.getListType());
      let a = this.getNextSibling();
      for (; a; ) {
        const l = a;
        a = a.getNextSibling(), i.append(l);
      }
      r.insertAfter(t), t.insertAfter(i);
    }
    return n && (re(t) || ol(139), this.getChildren().forEach((i) => {
      t.append(i);
    })), this.remove(), r.getChildrenSize() === 0 && r.remove(), t;
  }
  insertAfter(t, n = !0) {
    const r = this.getParentOrThrow();
    if (vt(r) || ol(39), Gt(t)) return super.insertAfter(t, n);
    const i = this.getNextSiblings();
    if (r.insertAfter(t, n), i.length !== 0) {
      const a = di(r.getListType());
      i.forEach((l) => a.append(l)), t.insertAfter(a, n);
    }
    return t;
  }
  remove(t) {
    const n = this.getPreviousSibling(), r = this.getNextSibling();
    super.remove(t), n && r && cl(n) && cl(r) && (tb(n.getFirstChild(), r.getFirstChild()), r.remove());
  }
  insertNewAfter(t, n = !0) {
    const r = Ii(this.__checked == null && void 0);
    return this.insertAfter(r, n), r;
  }
  collapseAtStart(t) {
    const n = He();
    this.getChildren().forEach((l) => n.append(l));
    const r = this.getParentOrThrow(), i = r.getParentOrThrow(), a = Gt(i);
    if (r.getChildrenSize() === 1) if (a) r.remove(), i.select();
    else {
      r.insertBefore(n), r.remove();
      const l = t.anchor, s = t.focus, c = n.getKey();
      l.type === "element" && l.getNode().is(this) && l.set(c, l.offset, "element"), s.type === "element" && s.getNode().is(this) && s.set(c, s.offset, "element");
    }
    else r.insertBefore(n), this.remove();
    return !0;
  }
  getValue() {
    return this.getLatest().__value;
  }
  setValue(t) {
    this.getWritable().__value = t;
  }
  getChecked() {
    const t = this.getLatest();
    let n;
    const r = this.getParent();
    return vt(r) && (n = r.getListType()), n === "check" ? !!t.__checked : void 0;
  }
  setChecked(t) {
    this.getWritable().__checked = t;
  }
  toggleChecked() {
    this.setChecked(!this.__checked);
  }
  getIndent() {
    const t = this.getParent();
    if (t === null) return this.getLatest().__indent;
    let n = t.getParentOrThrow(), r = 0;
    for (; Gt(n); ) n = n.getParentOrThrow().getParentOrThrow(), r++;
    return r;
  }
  setIndent(t) {
    typeof t != "number" && ol(117), (t = Math.floor(t)) >= 0 || ol(199);
    let n = this.getIndent();
    for (; n !== t; ) n < t ? (bF(this), n++) : (UF(this), n--);
    return this;
  }
  canInsertAfter(t) {
    return Gt(t);
  }
  canReplaceWith(t) {
    return Gt(t);
  }
  canMergeWith(t) {
    return La(t) || Gt(t);
  }
  extractWithChild(t, n) {
    if (!ie(n)) return !1;
    const r = n.anchor.getNode(), i = n.focus.getNode();
    return this.isParentOf(r) && this.isParentOf(i) && this.getTextContent().length === n.getTextContent().length;
  }
  isParentRequired() {
    return !0;
  }
  createParentElementNode() {
    return di("bullet");
  }
  canMergeWhenEmpty() {
    return !0;
  }
};
function gv(e, t, n) {
  const r = [], i = [], a = t.list, l = a ? a.listitem : void 0;
  let s;
  if (a && a.nested && (s = a.nested.listitem), l !== void 0 && r.push(...Jp(l)), a) {
    const c = n.getParent(), d = vt(c) && c.getListType() === "check", o = n.getChecked();
    d && !o || i.push(a.listitemUnchecked), d && o || i.push(a.listitemChecked), d && r.push(o ? a.listitemChecked : a.listitemUnchecked);
  }
  if (s !== void 0) {
    const c = Jp(s);
    n.getChildren().some((d) => vt(d)) ? r.push(...c) : i.push(...c);
  }
  i.length > 0 && id(e, ...i), r.length > 0 && zn(e, ...r);
}
function bv(e, t, n, r) {
  vt(t.getFirstChild()) ? (e.removeAttribute("role"), e.removeAttribute("tabIndex"), e.removeAttribute("aria-checked")) : (e.setAttribute("role", "checkbox"), e.setAttribute("tabIndex", "-1"), n && t.__checked === n.__checked || e.setAttribute("aria-checked", t.getChecked() ? "true" : "false"));
}
function yF(e) {
  if (e.classList.contains("task-list-item")) {
    for (const n of e.children) if (n.tagName === "INPUT") return wF(n);
  }
  const t = e.getAttribute("aria-checked");
  return { node: Ii(t === "true" || t !== "false" && void 0) };
}
function wF(e) {
  return e.getAttribute("type") !== "checkbox" ? { node: null } : { node: Ii(e.hasAttribute("checked")) };
}
function Ii(e) {
  return En(new Sf(void 0, e));
}
function Gt(e) {
  return e instanceof Sf;
}
let _f = class AC extends tr {
  static getType() {
    return "list";
  }
  static clone(t) {
    const n = t.__listType || yv[t.__tag];
    return new AC(n, t.__start, t.__key);
  }
  constructor(t, n, r) {
    super(r);
    const i = yv[t] || t;
    this.__listType = i, this.__tag = i === "number" ? "ol" : "ul", this.__start = n;
  }
  getTag() {
    return this.__tag;
  }
  setListType(t) {
    const n = this.getWritable();
    n.__listType = t, n.__tag = t === "number" ? "ol" : "ul";
  }
  getListType() {
    return this.__listType;
  }
  getStart() {
    return this.__start;
  }
  createDOM(t, n) {
    const r = this.__tag, i = document.createElement(r);
    return this.__start !== 1 && i.setAttribute("start", String(this.__start)), i.__lexicalListType = this.__listType, Uv(i, t.theme, this), i;
  }
  updateDOM(t, n, r) {
    return t.__tag !== this.__tag || (Uv(n, r.theme, this), !1);
  }
  static transform() {
    return (t) => {
      vt(t) || ol(163), function(n) {
        const r = n.getNextSibling();
        vt(r) && n.getListType() === r.getListType() && tb(n, r);
      }(t), function(n) {
        const r = n.getListType() !== "check";
        let i = n.getStart();
        for (const a of n.getChildren()) Gt(a) && (a.getValue() !== i && a.setValue(i), r && a.getLatest().__checked != null && a.setChecked(void 0), vt(a.getFirstChild()) || i++);
      }(t);
    };
  }
  static importDOM() {
    return { ol: () => ({ conversion: vv, priority: 0 }), ul: () => ({ conversion: vv, priority: 0 }) };
  }
  static importJSON(t) {
    const n = di(t.listType, t.start);
    return n.setFormat(t.format), n.setIndent(t.indent), n.setDirection(t.direction), n;
  }
  exportDOM(t) {
    const n = this.createDOM(t._config, t);
    return n && Ti(n) && (this.__start !== 1 && n.setAttribute("start", String(this.__start)), this.__listType === "check" && n.setAttribute("__lexicalListType", "check")), { element: n };
  }
  exportJSON() {
    return { ...super.exportJSON(), listType: this.getListType(), start: this.getStart(), tag: this.getTag(), type: "list", version: 1 };
  }
  canBeEmpty() {
    return !1;
  }
  canIndent() {
    return !1;
  }
  append(...t) {
    for (let n = 0; n < t.length; n++) {
      const r = t[n];
      if (Gt(r)) super.append(r);
      else {
        const i = Ii();
        if (vt(r)) i.append(r);
        else if (re(r)) {
          const a = un(r.getTextContent());
          i.append(a);
        } else i.append(r);
        super.append(i);
      }
    }
    return this;
  }
  extractWithChild(t) {
    return Gt(t);
  }
};
function Uv(e, t, n) {
  const r = [], i = [], a = t.list;
  if (a !== void 0) {
    const l = a[`${n.__tag}Depth`] || [], s = g4(n) - 1, c = s % l.length, d = l[c], o = a[n.__tag];
    let u;
    const h = a.nested, f = a.checklist;
    if (h !== void 0 && h.list && (u = h.list), o !== void 0 && r.push(o), f !== void 0 && n.__listType === "check" && r.push(f), d !== void 0) {
      r.push(...Jp(d));
      for (let p = 0; p < l.length; p++) p !== c && i.push(n.__tag + p);
    }
    if (u !== void 0) {
      const p = Jp(u);
      s > 1 ? r.push(...p) : i.push(...p);
    }
  }
  i.length > 0 && id(e, ...i), r.length > 0 && zn(e, ...r);
}
function xF(e) {
  const t = [];
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    if (Gt(r)) {
      t.push(r);
      const i = r.getChildren();
      i.length > 1 && i.forEach((a) => {
        vt(a) && t.push(pv(a));
      });
    } else t.push(pv(r));
  }
  return t;
}
function vv(e) {
  const t = e.nodeName.toLowerCase();
  let n = null;
  return t === "ol" ? n = di("number", e.start) : t === "ul" && (n = function(r) {
    if (r.getAttribute("__lexicallisttype") === "check" || r.classList.contains("contains-task-list")) return !0;
    for (const i of r.childNodes) if (Ti(i) && i.hasAttribute("aria-checked")) return !0;
    return !1;
  }(e) ? di("check") : di("bullet")), { after: xF, node: n };
}
const yv = { ol: "number", ul: "bullet" };
function di(e, t = 1) {
  return En(new _f(e, t));
}
function vt(e) {
  return e instanceof _f;
}
const nb = xn(), rb = xn(), ib = xn(), EF = xn();
function SF(e) {
  return Pt(e.registerCommand(rb, () => (U4(e, "number"), !0), ot), e.registerCommand(nb, () => (U4(e, "bullet"), !0), ot), e.registerCommand(EF, () => (gF(e), !0), ot), e.registerCommand(kc, () => !!vF(), ot));
}
let ab = class NC extends tr {
  static getType() {
    return "mark";
  }
  static clone(t) {
    return new NC(Array.from(t.__ids), t.__key);
  }
  static importDOM() {
    return null;
  }
  static importJSON(t) {
    const n = wv(t.ids);
    return n.setFormat(t.format), n.setIndent(t.indent), n.setDirection(t.direction), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), ids: this.getIDs(), type: "mark", version: 1 };
  }
  constructor(t, n) {
    super(n), this.__ids = t || [];
  }
  createDOM(t) {
    const n = document.createElement("mark");
    return zn(n, t.theme.mark), this.__ids.length > 1 && zn(n, t.theme.markOverlap), n;
  }
  updateDOM(t, n, r) {
    const i = t.__ids, a = this.__ids, l = i.length, s = a.length, c = r.theme.markOverlap;
    return l !== s && (l === 1 ? s === 2 && zn(n, c) : s === 1 && id(n, c)), !1;
  }
  hasID(t) {
    const n = this.getIDs();
    for (let r = 0; r < n.length; r++) if (t === n[r]) return !0;
    return !1;
  }
  getIDs() {
    const t = this.getLatest();
    return Q2(t) ? t.__ids : [];
  }
  addID(t) {
    const n = this.getWritable();
    if (Q2(n)) {
      const r = n.__ids;
      n.__ids = r;
      for (let i = 0; i < r.length; i++) if (t === r[i]) return;
      r.push(t);
    }
  }
  deleteID(t) {
    const n = this.getWritable();
    if (Q2(n)) {
      const r = n.__ids;
      n.__ids = r;
      for (let i = 0; i < r.length; i++) if (t === r[i]) return void r.splice(i, 1);
    }
  }
  insertNewAfter(t, n = !0) {
    const r = wv(this.__ids);
    return this.insertAfter(r, n), r;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
  canBeEmpty() {
    return !1;
  }
  isInline() {
    return !0;
  }
  extractWithChild(t, n, r) {
    if (!ie(n) || r === "html") return !1;
    const i = n.anchor, a = n.focus, l = i.getNode(), s = a.getNode(), c = n.isBackward() ? i.offset - a.offset : a.offset - i.offset;
    return this.isParentOf(l) && this.isParentOf(s) && this.getTextContent().length === c;
  }
  excludeFromCopy(t) {
    return t !== "clone";
  }
};
function wv(e) {
  return En(new ab(e));
}
function Q2(e) {
  return e instanceof ab;
}
function _F(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var kF = _F(function(e) {
  const t = new URLSearchParams();
  t.append("code", e);
  for (let n = 1; n < arguments.length; n++) t.append("v", arguments[n]);
  throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
});
let lb = class DC extends tr {
  static getType() {
    return "overflow";
  }
  static clone(t) {
    return new DC(t.__key);
  }
  static importJSON(t) {
    return CF();
  }
  static importDOM() {
    return null;
  }
  constructor(t) {
    super(t), this.__type = "overflow";
  }
  exportJSON() {
    return { ...super.exportJSON(), type: "overflow" };
  }
  createDOM(t) {
    const n = document.createElement("span"), r = t.theme.characterLimit;
    return typeof r == "string" && (n.className = r), n;
  }
  updateDOM(t, n) {
    return !1;
  }
  insertNewAfter(t, n = !0) {
    return this.getParentOrThrow().insertNewAfter(t, n);
  }
  excludeFromCopy() {
    return !0;
  }
  static transform() {
    return (t) => {
      MF(t) || kF(204), t.isEmpty() && t.remove();
    };
  }
};
function CF() {
  return En(new lb());
}
function MF(e) {
  return e instanceof lb;
}
function xv(e, t) {
  return e.getEditorState().read(() => {
    const n = Rt(t);
    return n !== null && n.isSelected();
  });
}
function sb(e) {
  const [t] = Fe(), [n, r] = Q(() => xv(t, e));
  return Y(() => {
    let i = !0;
    const a = t.registerUpdateListener(() => {
      i && r(xv(t, e));
    });
    return () => {
      i = !1, a();
    };
  }, [t, e]), [n, he((i) => {
    t.update(() => {
      let a = se();
      Xn(a) || (a = f4(), pn(a)), Xn(a) && (i ? a.add(e) : a.delete(e));
    });
  }, [t, e]), he(() => {
    t.update(() => {
      const i = se();
      Xn(i) && i.clear();
    });
  }, [t])];
}
const ob = xn();
function TF({ nodeKey: e }) {
  const [t] = Fe(), [n, r, i] = sb(e), a = he((l) => {
    const s = se();
    return n && Xn(s) && (l.preventDefault(), t.update(() => {
      s.getNodes().forEach((c) => {
        AF(c) && c.remove();
      });
    })), !1;
  }, [t, n]);
  return Y(() => Pt(t.registerCommand(L0, (l) => {
    const s = t.getElementByKey(e);
    return l.target === s && (l.shiftKey || i(), r(!n), !0);
  }, ot), t.registerCommand(O0, a, ot), t.registerCommand(P0, a, ot)), [i, t, n, e, a, r]), Y(() => {
    const l = t.getElementByKey(e), s = "selected";
    l !== null && (n ? zn(l, s) : id(l, s));
  }, [t, n, e]), null;
}
let cb = class LC extends Ha {
  static getType() {
    return "horizontalrule";
  }
  static clone(t) {
    return new LC(t.__key);
  }
  static importJSON(t) {
    return db();
  }
  static importDOM() {
    return { hr: () => ({ conversion: IF, priority: 0 }) };
  }
  exportJSON() {
    return { type: "horizontalrule", version: 1 };
  }
  exportDOM() {
    return { element: document.createElement("hr") };
  }
  createDOM(t) {
    const n = document.createElement("hr");
    return zn(n, t.theme.hr), n;
  }
  getTextContent() {
    return `
`;
  }
  isInline() {
    return !1;
  }
  updateDOM() {
    return !1;
  }
  decorate() {
    return m(TF, { nodeKey: this.__key });
  }
};
function IF() {
  return { node: db() };
}
function db() {
  return En(new cb());
}
function AF(e) {
  return e instanceof cb;
}
function NF(e, t) {
  const n = t.body ? t.body.childNodes : [];
  let r = [];
  const i = [];
  for (let a = 0; a < n.length; a++) {
    const l = n[a];
    if (!PC.has(l.nodeName)) {
      const s = OC(l, e, i, !1);
      s !== null && (r = r.concat(s));
    }
  }
  return function(a) {
    for (const l of a) l.getNextSibling() instanceof Y3 && l.insertAfter(hs());
    for (const l of a) {
      const s = l.getChildren();
      for (const c of s) l.insertBefore(c);
      l.remove();
    }
  }(i), r;
}
function Qp(e, t) {
  if (typeof document > "u" || typeof window > "u" && global.window === void 0) throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
  const n = document.createElement("div"), r = Bt().getChildren();
  for (let i = 0; i < r.length; i++)
    RC(e, r[i], n, t);
  return n.innerHTML;
}
function RC(e, t, n, r = null) {
  let i = r === null || t.isSelected(r);
  const a = re(t) && t.excludeFromCopy("html");
  let l = t;
  if (r !== null) {
    let f = z3(t);
    f = ce(f) && r !== null ? pC(r, f) : f, l = f;
  }
  const s = re(l) ? l.getChildren() : [], c = e._nodes.get(l.getType());
  let d;
  d = c && c.exportDOM !== void 0 ? c.exportDOM(e, l) : l.exportDOM(e);
  const { element: o, after: u } = d;
  if (!o) return !1;
  const h = document.createDocumentFragment();
  for (let f = 0; f < s.length; f++) {
    const p = s[f], g = RC(e, p, h, r);
    !i && re(t) && g && t.extractWithChild(p, r, "html") && (i = !0);
  }
  if (i && !a) {
    if ((Ti(o) || P9(o)) && o.append(h), n.append(o), u) {
      const f = u.call(l, o);
      f && (P9(o) ? o.replaceChildren(f) : o.replaceWith(f));
    }
  } else n.append(h);
  return i;
}
const PC = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
function OC(e, t, n, r, i = /* @__PURE__ */ new Map(), a) {
  let l = [];
  if (PC.has(e.nodeName)) return l;
  let s = null;
  const c = function(p, g) {
    const { nodeName: b } = p, v = g._htmlConversions.get(b.toLowerCase());
    let U = null;
    if (v !== void 0) for (const y of v) {
      const w = y(p);
      w !== null && (U === null || (U.priority || 0) <= (w.priority || 0)) && (U = w);
    }
    return U !== null ? U.conversion : null;
  }(e, t), d = c ? c(e) : null;
  let o = null;
  if (d !== null) {
    o = d.after;
    const p = d.node;
    if (s = Array.isArray(p) ? p[p.length - 1] : p, s !== null) {
      for (const [, g] of i) if (s = g(s, a), !s) break;
      s && l.push(...Array.isArray(p) ? p : [s]);
    }
    d.forChild != null && i.set(e.nodeName, d.forChild);
  }
  const u = e.childNodes;
  let h = [];
  const f = (s == null || !er(s)) && (s != null && Kp(s) || r);
  for (let p = 0; p < u.length; p++) h.push(...OC(u[p], t, n, f, new Map(i), s));
  return o != null && (h = o(h)), Wp(e) && (h = DF(e, h, f ? () => {
    const p = new Y3();
    return n.push(p), p;
  } : He)), s == null ? h.length > 0 ? l = l.concat(h) : Wp(e) && function(p) {
    return p.nextSibling == null || p.previousSibling == null ? !1 : e4(p.nextSibling) && e4(p.previousSibling);
  }(e) && (l = l.concat(hs())) : re(s) && s.append(...h), l;
}
function DF(e, t, n) {
  const r = e.style.textAlign, i = [];
  let a = [];
  for (let l = 0; l < t.length; l++) {
    const s = t[l];
    if (Kp(s)) r && !s.getFormat() && s.setFormat(r), i.push(s);
    else if (a.push(s), l === t.length - 1 || l < t.length - 1 && Kp(t[l + 1])) {
      const c = n();
      c.setFormat(r), c.append(...a), i.push(c), a = [];
    }
  }
  return i;
}
function LF(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var em = LF(function(e) {
  const t = new URLSearchParams();
  t.append("code", e);
  for (let n = 1; n < arguments.length; n++) t.append("v", arguments[n]);
  throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
});
const RF = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, $C = (e) => RF ? (e || window).getSelection() : null;
function PF(e, t = se()) {
  return t == null && em(166), ie(t) && t.isCollapsed() || t.getNodes().length === 0 ? "" : Qp(e, t);
}
function OF(e, t = se()) {
  return t == null && em(166), ie(t) && t.isCollapsed() || t.getNodes().length === 0 ? null : JSON.stringify($F(e, t));
}
function s4e(e, t) {
  const n = e.getData("text/plain") || e.getData("text/uri-list");
  n != null && t.insertRawText(n);
}
function Ev(e, t, n) {
  const r = e.getData("application/x-lexical-editor");
  if (r) try {
    const l = JSON.parse(r);
    if (l.namespace === n._config.namespace && Array.isArray(l.nodes))
      return Sv(n, FF(l.nodes), t);
  } catch {
  }
  const i = e.getData("text/html");
  if (i) try {
    const l = new DOMParser().parseFromString(function(s) {
      return window.trustedTypes && window.trustedTypes.createPolicy ? window.trustedTypes.createPolicy("lexical", { createHTML: (c) => c }).createHTML(s) : s;
    }(i), "text/html");
    return Sv(n, NF(n, l), t);
  } catch {
  }
  const a = e.getData("text/plain") || e.getData("text/uri-list");
  if (a != null) if (ie(t)) {
    const l = a.split(/(\r?\n|\t)/);
    l[l.length - 1] === "" && l.pop();
    for (let s = 0; s < l.length; s++) {
      const c = se();
      if (ie(c)) {
        const d = l[s];
        d === `
` || d === `\r
` ? c.insertParagraph() : d === "	" ? c.insertNodes([$0()]) : c.insertText(d);
      }
    }
  } else t.insertRawText(a);
}
function Sv(e, t, n) {
  e.dispatchCommand(ok, { nodes: t, selection: n }) || n.insertNodes(t);
}
function FC(e, t, n, r = []) {
  let i = t === null || n.isSelected(t);
  const a = re(n) && n.excludeFromCopy("html");
  let l = n;
  if (t !== null) {
    let d = z3(n);
    d = ce(d) && t !== null ? pC(t, d) : d, l = d;
  }
  const s = re(l) ? l.getChildren() : [], c = function(d) {
    const o = d.exportJSON(), u = d.constructor;
    if (o.type !== u.getType() && em(58, u.name), re(d)) {
      const h = o.children;
      Array.isArray(h) || em(59, u.name);
    }
    return o;
  }(l);
  if (ce(l)) {
    const d = l.__text;
    d.length > 0 ? c.text = d : i = !1;
  }
  for (let d = 0; d < s.length; d++) {
    const o = s[d], u = FC(e, t, o, c.children);
    !i && re(n) && u && n.extractWithChild(o, t, "clone") && (i = !0);
  }
  if (i && !a) r.push(c);
  else if (Array.isArray(c.children)) for (let d = 0; d < c.children.length; d++) {
    const o = c.children[d];
    r.push(o);
  }
  return i;
}
function $F(e, t) {
  const n = [], r = Bt().getChildren();
  for (let i = 0; i < r.length; i++)
    FC(e, t, r[i], n);
  return { namespace: e._config.namespace, nodes: n };
}
function FF(e) {
  const t = [];
  for (let n = 0; n < e.length; n++) {
    const r = e[n], i = z$(r);
    ce(i) && K$(i), t.push(i);
  }
  return t;
}
let hd = null;
async function v4(e, t, n) {
  if (hd !== null) return !1;
  if (t !== null) return new Promise((c, d) => {
    e.update(() => {
      c(_v(e, t, n));
    });
  });
  const r = e.getRootElement(), i = e._window == null ? window.document : e._window.document, a = $C(e._window);
  if (r === null || a === null) return !1;
  const l = i.createElement("span");
  l.style.cssText = "position: fixed; top: -1000px;", l.append(i.createTextNode("#")), r.append(l);
  const s = new Range();
  return s.setStart(l, 0), s.setEnd(l, 1), a.removeAllRanges(), a.addRange(s), new Promise((c, d) => {
    const o = e.registerCommand(hg, (u) => (ns(u, ClipboardEvent) && (o(), hd !== null && (window.clearTimeout(hd), hd = null), c(_v(e, u, n))), !0), mr);
    hd = window.setTimeout(() => {
      o(), hd = null, c(!1);
    }, 50), i.execCommand("copy"), l.remove();
  });
}
function _v(e, t, n) {
  if (n === void 0) {
    const i = $C(e._window);
    if (!i) return !1;
    const a = i.anchorNode, l = i.focusNode;
    if (a !== null && l !== null && !vf(e, a, l)) return !1;
    const s = se();
    if (s === null) return !1;
    n = zC(s);
  }
  t.preventDefault();
  const r = t.clipboardData;
  return r !== null && (BF(r, n), !0);
}
const zF = [["text/html", PF], ["application/x-lexical-editor", OF]];
function zC(e = se()) {
  const t = { "text/plain": e ? e.getTextContent() : "" };
  if (e) {
    const n = E$();
    for (const [r, i] of zF) {
      const a = i(n, e);
      a !== null && (t[r] = a);
    }
  }
  return t;
}
function BF(e, t) {
  for (const n in t) {
    const r = t[n];
    r !== void 0 && e.setData(n, r);
  }
}
function kv(e, t) {
  if (document.caretRangeFromPoint !== void 0) {
    const n = document.caretRangeFromPoint(e, t);
    return n === null ? null : { node: n.startContainer, offset: n.startOffset };
  }
  if (document.caretPositionFromPoint !== "undefined") {
    const n = document.caretPositionFromPoint(e, t);
    return n === null ? null : { node: n.offsetNode, offset: n.offset };
  }
  return null;
}
const W0 = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, HF = W0 && "documentMode" in document ? document.documentMode : null, WF = !(!W0 || !("InputEvent" in window) || HF) && "getTargetRanges" in new window.InputEvent("input"), XF = W0 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), VF = W0 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, GF = W0 && /^(?=.*Chrome).*/i.test(navigator.userAgent), jF = W0 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !GF, y4 = xn();
let ub = class BC extends tr {
  static getType() {
    return "quote";
  }
  static clone(t) {
    return new BC(t.__key);
  }
  constructor(t) {
    super(t);
  }
  createDOM(t) {
    const n = document.createElement("blockquote");
    return zn(n, t.theme.quote), n;
  }
  updateDOM(t, n) {
    return !1;
  }
  static importDOM() {
    return { blockquote: (t) => ({ conversion: YF, priority: 0 }) };
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    if (n && Ti(n)) {
      this.isEmpty() && n.append(document.createElement("br"));
      const r = this.getFormatType();
      n.style.textAlign = r;
      const i = this.getDirection();
      i && (n.dir = i);
    }
    return { element: n };
  }
  static importJSON(t) {
    const n = Mg();
    return n.setFormat(t.format), n.setIndent(t.indent), n.setDirection(t.direction), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), type: "quote" };
  }
  insertNewAfter(t, n) {
    const r = He(), i = this.getDirection();
    return r.setDirection(i), this.insertAfter(r, n), r;
  }
  collapseAtStart() {
    const t = He();
    return this.getChildren().forEach((n) => t.append(n)), this.replace(t), !0;
  }
  canMergeWhenEmpty() {
    return !0;
  }
};
function Mg() {
  return En(new ub());
}
function KF(e) {
  return e instanceof ub;
}
let Tg = class HC extends tr {
  static getType() {
    return "heading";
  }
  static clone(t) {
    return new HC(t.__tag, t.__key);
  }
  constructor(t, n) {
    super(n), this.__tag = t;
  }
  getTag() {
    return this.__tag;
  }
  createDOM(t) {
    const n = this.__tag, r = document.createElement(n), i = t.theme.heading;
    if (i !== void 0) {
      const a = i[n];
      zn(r, a);
    }
    return r;
  }
  updateDOM(t, n) {
    return !1;
  }
  static importDOM() {
    return { h1: (t) => ({ conversion: fd, priority: 0 }), h2: (t) => ({ conversion: fd, priority: 0 }), h3: (t) => ({ conversion: fd, priority: 0 }), h4: (t) => ({ conversion: fd, priority: 0 }), h5: (t) => ({ conversion: fd, priority: 0 }), h6: (t) => ({ conversion: fd, priority: 0 }), p: (t) => {
      const n = t.firstChild;
      return n !== null && Cv(n) ? { conversion: () => ({ node: null }), priority: 3 } : null;
    }, span: (t) => Cv(t) ? { conversion: (n) => ({ node: cc("h1") }), priority: 3 } : null };
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    if (n && Ti(n)) {
      this.isEmpty() && n.append(document.createElement("br"));
      const r = this.getFormatType();
      n.style.textAlign = r;
      const i = this.getDirection();
      i && (n.dir = i);
    }
    return { element: n };
  }
  static importJSON(t) {
    const n = cc(t.tag);
    return n.setFormat(t.format), n.setIndent(t.indent), n.setDirection(t.direction), n;
  }
  exportJSON() {
    return { ...super.exportJSON(), tag: this.getTag(), type: "heading", version: 1 };
  }
  insertNewAfter(t, n = !0) {
    const r = t ? t.anchor.offset : 0, i = this.getLastDescendant(), a = !i || t && t.anchor.key === i.getKey() && r === i.getTextContentSize() || !t ? He() : cc(this.getTag()), l = this.getDirection();
    if (a.setDirection(l), this.insertAfter(a, n), r === 0 && !this.isEmpty() && t) {
      const s = He();
      s.select(), this.replace(s, !0);
    }
    return a;
  }
  collapseAtStart() {
    const t = this.isEmpty() ? He() : cc(this.getTag());
    return this.getChildren().forEach((n) => t.append(n)), this.replace(t), !0;
  }
  extractWithChild() {
    return !0;
  }
};
function Cv(e) {
  return e.nodeName.toLowerCase() === "span" && e.style.fontSize === "26pt";
}
function fd(e) {
  const t = e.nodeName.toLowerCase();
  let n = null;
  return t !== "h1" && t !== "h2" && t !== "h3" && t !== "h4" && t !== "h5" && t !== "h6" || (n = cc(t), e.style !== null && (B3(e, n), n.setFormat(e.style.textAlign))), { node: n };
}
function YF(e) {
  const t = Mg();
  return e.style !== null && (t.setFormat(e.style.textAlign), B3(e, t)), { node: t };
}
function cc(e) {
  return En(new Tg(e));
}
function Kd(e) {
  return e instanceof Tg;
}
function Ld(e) {
  let t = null;
  if (ns(e, DragEvent) ? t = e.dataTransfer : ns(e, ClipboardEvent) && (t = e.clipboardData), t === null) return [!1, [], !1];
  const n = t.types, r = n.includes("Files"), i = n.includes("text/html") || n.includes("text/plain");
  return [r, Array.from(t.files), i];
}
function Mv(e) {
  const t = se();
  if (!ie(t)) return !1;
  const n = /* @__PURE__ */ new Set(), r = t.getNodes();
  for (let i = 0; i < r.length; i++) {
    const a = r[i], l = a.getKey();
    if (n.has(l)) continue;
    const s = Xe(a, (d) => re(d) && !d.isInline());
    if (s === null) continue;
    const c = s.getKey();
    s.canIndent() && !n.has(c) && (n.add(c), e(s));
  }
  return n.size > 0;
}
function o1(e) {
  const t = on(e);
  return Ft(t);
}
function qF(e) {
  return Pt(e.registerCommand(L0, (t) => {
    const n = se();
    return !!Xn(n) && (n.clear(), !0);
  }, 0), e.registerCommand(ls, (t) => {
    const n = se();
    return !!ie(n) && (n.deleteCharacter(t), !0);
  }, it), e.registerCommand(i0, (t) => {
    const n = se();
    return !!ie(n) && (n.deleteWord(t), !0);
  }, it), e.registerCommand(Cc, (t) => {
    const n = se();
    return !!ie(n) && (n.deleteLine(t), !0);
  }, it), e.registerCommand(gc, (t) => {
    const n = se();
    if (typeof t == "string") n !== null && n.insertText(t);
    else {
      if (n === null) return !1;
      const r = t.dataTransfer;
      if (r != null) Ev(r, n, e);
      else if (ie(n)) {
        const i = t.data;
        return i && n.insertText(i), !0;
      }
    }
    return !0;
  }, it), e.registerCommand(Z5, () => {
    const t = se();
    return !!ie(t) && (t.removeText(), !0);
  }, it), e.registerCommand(Mn, (t) => {
    const n = se();
    return !!ie(n) && (n.formatText(t), !0);
  }, it), e.registerCommand(il, (t) => {
    const n = se();
    if (!ie(n) && !Xn(n)) return !1;
    const r = n.getNodes();
    for (const i of r) {
      const a = Xe(i, (l) => re(l) && !l.isInline());
      a !== null && a.setFormat(t);
    }
    return !0;
  }, it), e.registerCommand(Gd, (t) => {
    const n = se();
    return !!ie(n) && (n.insertLineBreak(t), !0);
  }, it), e.registerCommand(kc, () => {
    const t = se();
    return !!ie(t) && (t.insertParagraph(), !0);
  }, it), e.registerCommand(dk, () => (z0([$0()]), !0), it), e.registerCommand(dg, () => Mv((t) => {
    const n = t.getIndent();
    t.setIndent(n + 1);
  }), it), e.registerCommand(Pp, () => Mv((t) => {
    const n = t.getIndent();
    n > 0 && t.setIndent(n - 1);
  }), it), e.registerCommand(Io, (t) => {
    const n = se();
    if (Xn(n) && !o1(t.target)) {
      const r = n.getNodes();
      if (r.length > 0) return r[0].selectPrevious(), !0;
    } else if (ie(n)) {
      const r = Ch(n.focus, !0);
      if (!t.shiftKey && Ft(r) && !r.isIsolated() && !r.isInline()) return r.selectPrevious(), t.preventDefault(), !0;
    }
    return !1;
  }, it), e.registerCommand(Ao, (t) => {
    const n = se();
    if (Xn(n)) {
      const r = n.getNodes();
      if (r.length > 0) return r[0].selectNext(0, 0), !0;
    } else if (ie(n)) {
      if (function(i) {
        const a = i.focus;
        return a.key === "root" && a.offset === Bt().getChildrenSize();
      }(n)) return t.preventDefault(), !0;
      const r = Ch(n.focus, !1);
      if (!t.shiftKey && Ft(r) && !r.isIsolated() && !r.isInline()) return r.selectNext(), t.preventDefault(), !0;
    }
    return !1;
  }, it), e.registerCommand(R0, (t) => {
    const n = se();
    if (Xn(n)) {
      const r = n.getNodes();
      if (r.length > 0) return t.preventDefault(), r[0].selectPrevious(), !0;
    }
    if (!ie(n)) return !1;
    if (lv(n, !0)) {
      const r = t.shiftKey;
      return t.preventDefault(), sv(n, r, !0), !0;
    }
    return !1;
  }, it), e.registerCommand(pf, (t) => {
    const n = se();
    if (Xn(n) && !o1(t.target)) {
      const i = n.getNodes();
      if (i.length > 0) return t.preventDefault(), i[0].selectNext(0, 0), !0;
    }
    if (!ie(n)) return !1;
    const r = t.shiftKey;
    return !!lv(n, !1) && (t.preventDefault(), sv(n, r, !1), !0);
  }, it), e.registerCommand(P0, (t) => {
    if (o1(t.target)) return !1;
    const n = se();
    if (!ie(n)) return !1;
    t.preventDefault();
    const { anchor: r } = n, i = r.getNode();
    return n.isCollapsed() && r.offset === 0 && !Xr(i) && Cg(i).getIndent() > 0 ? e.dispatchCommand(Pp, void 0) : e.dispatchCommand(ls, !0);
  }, it), e.registerCommand(O0, (t) => {
    if (o1(t.target)) return !1;
    const n = se();
    return !!ie(n) && (t.preventDefault(), e.dispatchCommand(ls, !1));
  }, it), e.registerCommand(a0, (t) => {
    const n = se();
    if (!ie(n)) return !1;
    if (t !== null) {
      if ((VF || XF || jF) && WF) return !1;
      if (t.preventDefault(), t.shiftKey) return e.dispatchCommand(Gd, !1);
    }
    return e.dispatchCommand(kc, void 0);
  }, it), e.registerCommand(rd, () => {
    const t = se();
    return !!ie(t) && (e.blur(), !0);
  }, it), e.registerCommand(gf, (t) => {
    const [, n] = Ld(t);
    if (n.length > 0) {
      const i = kv(t.clientX, t.clientY);
      if (i !== null) {
        const { offset: a, node: l } = i, s = on(l);
        if (s !== null) {
          const c = yf();
          if (ce(s)) c.anchor.set(s.getKey(), a, "text"), c.focus.set(s.getKey(), a, "text");
          else {
            const o = s.getParentOrThrow().getKey(), u = s.getIndexWithinParent() + 1;
            c.anchor.set(o, u, "element"), c.focus.set(o, u, "element");
          }
          const d = bg(c);
          pn(d);
        }
        e.dispatchCommand(y4, n);
      }
      return t.preventDefault(), !0;
    }
    const r = se();
    return !!ie(r);
  }, it), e.registerCommand(ug, (t) => {
    const [n] = Ld(t), r = se();
    return !(n && !ie(r));
  }, it), e.registerCommand(bf, (t) => {
    const [n] = Ld(t), r = se();
    if (n && !ie(r)) return !1;
    const i = kv(t.clientX, t.clientY);
    if (i !== null) {
      const a = on(i.node);
      Ft(a) && t.preventDefault();
    }
    return !0;
  }, it), e.registerCommand(J5, () => (g$(), !0), it), e.registerCommand(hg, (t) => (v4(e, ns(t, ClipboardEvent) ? t : null), !0), it), e.registerCommand(fg, (t) => (async function(n, r) {
    await v4(r, ns(n, ClipboardEvent) ? n : null), r.update(() => {
      const i = se();
      ie(i) ? i.removeText() : Xn(i) && i.getNodes().forEach((a) => a.remove());
    });
  }(t, e), !0), it), e.registerCommand(sg, (t) => {
    const [, n, r] = Ld(t);
    return n.length > 0 && !r ? (e.dispatchCommand(y4, n), !0) : N3(t.target) ? !1 : se() !== null && (function(i, a) {
      i.preventDefault(), a.update(() => {
        const l = se(), s = ns(i, InputEvent) || ns(i, KeyboardEvent) ? null : i.clipboardData;
        s != null && l !== null && Ev(s, l, a);
      }, { tag: "paste" });
    }(t, e), !0);
  }, it));
}
const hb = /^(\d+(?:\.\d+)?)px$/, an = { BOTH: 3, COLUMN: 2, NO_STATUS: 0, ROW: 1 };
let oo = class WC extends tr {
  static getType() {
    return "tablecell";
  }
  static clone(t) {
    return new WC(t.__headerState, t.__colSpan, t.__width, t.__key);
  }
  afterCloneFrom(t) {
    super.afterCloneFrom(t), this.__rowSpan = t.__rowSpan, this.__backgroundColor = t.__backgroundColor;
  }
  static importDOM() {
    return { td: (t) => ({ conversion: Tv, priority: 0 }), th: (t) => ({ conversion: Tv, priority: 0 }) };
  }
  static importJSON(t) {
    const n = t.colSpan || 1, r = t.rowSpan || 1;
    return Ma(t.headerState, n, t.width || void 0).setRowSpan(r).setBackgroundColor(t.backgroundColor || null);
  }
  constructor(t = an.NO_STATUS, n = 1, r, i) {
    super(i), this.__colSpan = n, this.__rowSpan = 1, this.__headerState = t, this.__width = r, this.__backgroundColor = null;
  }
  createDOM(t) {
    const n = document.createElement(this.getTag());
    return this.__width && (n.style.width = `${this.__width}px`), this.__colSpan > 1 && (n.colSpan = this.__colSpan), this.__rowSpan > 1 && (n.rowSpan = this.__rowSpan), this.__backgroundColor !== null && (n.style.backgroundColor = this.__backgroundColor), zn(n, t.theme.tableCell, this.hasHeader() && t.theme.tableCellHeader), n;
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    if (n) {
      const r = n;
      r.style.border = "1px solid black", this.__colSpan > 1 && (r.colSpan = this.__colSpan), this.__rowSpan > 1 && (r.rowSpan = this.__rowSpan), r.style.width = `${this.getWidth() || 75}px`, r.style.verticalAlign = "top", r.style.textAlign = "start";
      const i = this.getBackgroundColor();
      i !== null ? r.style.backgroundColor = i : this.hasHeader() && (r.style.backgroundColor = "#f2f3f5");
    }
    return { element: n };
  }
  exportJSON() {
    return { ...super.exportJSON(), backgroundColor: this.getBackgroundColor(), colSpan: this.__colSpan, headerState: this.__headerState, rowSpan: this.__rowSpan, type: "tablecell", width: this.getWidth() };
  }
  getColSpan() {
    return this.getLatest().__colSpan;
  }
  setColSpan(t) {
    const n = this.getWritable();
    return n.__colSpan = t, n;
  }
  getRowSpan() {
    return this.getLatest().__rowSpan;
  }
  setRowSpan(t) {
    const n = this.getWritable();
    return n.__rowSpan = t, n;
  }
  getTag() {
    return this.hasHeader() ? "th" : "td";
  }
  setHeaderStyles(t, n = an.BOTH) {
    const r = this.getWritable();
    return r.__headerState = t & n | r.__headerState & ~n, r;
  }
  getHeaderStyles() {
    return this.getLatest().__headerState;
  }
  setWidth(t) {
    const n = this.getWritable();
    return n.__width = t, n;
  }
  getWidth() {
    return this.getLatest().__width;
  }
  getBackgroundColor() {
    return this.getLatest().__backgroundColor;
  }
  setBackgroundColor(t) {
    const n = this.getWritable();
    return n.__backgroundColor = t, n;
  }
  toggleHeaderStyle(t) {
    const n = this.getWritable();
    return (n.__headerState & t) === t ? n.__headerState -= t : n.__headerState += t, n;
  }
  hasHeaderState(t) {
    return (this.getHeaderStyles() & t) === t;
  }
  hasHeader() {
    return this.getLatest().__headerState !== an.NO_STATUS;
  }
  updateDOM(t) {
    return t.__headerState !== this.__headerState || t.__width !== this.__width || t.__colSpan !== this.__colSpan || t.__rowSpan !== this.__rowSpan || t.__backgroundColor !== this.__backgroundColor;
  }
  isShadowRoot() {
    return !0;
  }
  collapseAtStart() {
    return !0;
  }
  canBeEmpty() {
    return !1;
  }
  canIndent() {
    return !1;
  }
};
function Tv(e) {
  const t = e, n = e.nodeName.toLowerCase();
  let r;
  hb.test(t.style.width) && (r = parseFloat(t.style.width));
  const i = Ma(n === "th" ? an.ROW : an.NO_STATUS, t.colSpan, r);
  i.__rowSpan = t.rowSpan;
  const a = t.style.backgroundColor;
  a !== "" && (i.__backgroundColor = a);
  const l = t.style, s = (l && l.textDecoration || "").split(" "), c = l.fontWeight === "700" || l.fontWeight === "bold", d = s.includes("line-through"), o = l.fontStyle === "italic", u = s.includes("underline");
  return { after: (h) => (h.length === 0 && h.push(He()), h), forChild: (h, f) => {
    if (De(f) && !re(h)) {
      const p = He();
      return Ca(h) && h.getTextContent() === `
` ? null : (ce(h) && (c && h.toggleFormat("bold"), d && h.toggleFormat("strikethrough"), o && h.toggleFormat("italic"), u && h.toggleFormat("underline")), p.append(h), p);
    }
    return h;
  }, node: i };
}
function Ma(e, t = 1, n) {
  return En(new oo(e, t, n));
}
function De(e) {
  return e instanceof oo;
}
const fb = xn();
function ZF(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ut = ZF(function(e) {
  const t = new URLSearchParams();
  t.append("code", e);
  for (let n = 1; n < arguments.length; n++) t.append("v", arguments[n]);
  throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
});
const JF = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0;
let Ig = class XC extends tr {
  static getType() {
    return "tablerow";
  }
  static clone(t) {
    return new XC(t.__height, t.__key);
  }
  static importDOM() {
    return { tr: (t) => ({ conversion: QF, priority: 0 }) };
  }
  static importJSON(t) {
    return Nh(t.height);
  }
  constructor(t, n) {
    super(n), this.__height = t;
  }
  exportJSON() {
    return { ...super.exportJSON(), ...this.getHeight() && { height: this.getHeight() }, type: "tablerow", version: 1 };
  }
  createDOM(t) {
    const n = document.createElement("tr");
    return this.__height && (n.style.height = `${this.__height}px`), zn(n, t.theme.tableRow), n;
  }
  isShadowRoot() {
    return !0;
  }
  setHeight(t) {
    return this.getWritable().__height = t, this.__height;
  }
  getHeight() {
    return this.getLatest().__height;
  }
  updateDOM(t) {
    return t.__height !== this.__height;
  }
  canBeEmpty() {
    return !1;
  }
  canIndent() {
    return !1;
  }
};
function QF(e) {
  const t = e;
  let n;
  return hb.test(t.style.height) && (n = parseFloat(t.style.height)), { node: Nh(n) };
}
function Nh(e) {
  return En(new Ig(e));
}
function Vn(e) {
  return e instanceof Ig;
}
function ez(e, t, n = !0) {
  const r = Ub();
  for (let i = 0; i < e; i++) {
    const a = Nh();
    for (let l = 0; l < t; l++) {
      let s = an.NO_STATUS;
      typeof n == "object" ? (i === 0 && n.rows && (s |= an.ROW), l === 0 && n.columns && (s |= an.COLUMN)) : n && (i === 0 && (s |= an.ROW), l === 0 && (s |= an.COLUMN));
      const c = Ma(s), d = He();
      d.append(un()), c.append(d), a.append(c);
    }
    r.append(a);
  }
  return r;
}
function tz(e) {
  const t = Xe(e, (n) => De(n));
  return De(t) ? t : null;
}
function VC(e) {
  const t = Xe(e, (n) => Vn(n));
  if (Vn(t)) return t;
  throw new Error("Expected table cell to be inside of table row.");
}
function es(e) {
  const t = Xe(e, (n) => fn(n));
  if (fn(t)) return t;
  throw new Error("Expected table cell to be inside of table.");
}
function pb(e) {
  const t = VC(e);
  return es(t).getChildren().findIndex((n) => n.is(t));
}
function GC(e) {
  return VC(e).getChildren().findIndex((t) => t.is(e));
}
const w4 = (e, t) => e === an.BOTH || e === t ? t : an.NO_STATUS;
function jC(e = !0) {
  const t = se();
  ie(t) || Ct(t) || Ut(188);
  const n = t.focus.getNode(), [r, , i] = Cr(n), [a, l] = Xi(i, r, r), s = a[0].length, { startRow: c } = l;
  let d = null;
  if (e) {
    const o = c + r.__rowSpan - 1, u = a[o], h = Nh();
    for (let p = 0; p < s; p++) {
      const { cell: g, startRow: b } = u[p];
      if (b + g.__rowSpan - 1 <= o) {
        const v = u[p].cell.__headerState, U = w4(v, an.COLUMN);
        h.append(Ma(U).append(He()));
      } else g.setRowSpan(g.__rowSpan + 1);
    }
    const f = i.getChildAtIndex(o);
    Vn(f) || Ut(145), f.insertAfter(h), d = h;
  } else {
    const o = a[c], u = Nh();
    for (let f = 0; f < s; f++) {
      const { cell: p, startRow: g } = o[f];
      if (g === c) {
        const b = o[f].cell.__headerState, v = w4(b, an.COLUMN);
        u.append(Ma(v).append(He()));
      } else p.setRowSpan(p.__rowSpan + 1);
    }
    const h = i.getChildAtIndex(c);
    Vn(h) || Ut(145), h.insertBefore(u), d = u;
  }
  return d;
}
function KC(e = !0) {
  const t = se();
  ie(t) || Ct(t) || Ut(188);
  const n = t.anchor.getNode(), r = t.focus.getNode(), [i] = Cr(n), [a, , l] = Cr(r), [s, c, d] = Xi(l, a, i), o = s.length, u = e ? Math.max(c.startColumn, d.startColumn) : Math.min(c.startColumn, d.startColumn), h = e ? u + a.__colSpan - 1 : u - 1, f = l.getFirstChild();
  Vn(f) || Ut(120);
  let p = null;
  function g(U = an.NO_STATUS) {
    const y = Ma(U).append(He());
    return p === null && (p = y), y;
  }
  let b = f;
  e: for (let U = 0; U < o; U++) {
    if (U !== 0) {
      const k = b.getNextSibling();
      Vn(k) || Ut(121), b = k;
    }
    const y = s[U], w = y[h < 0 ? 0 : h].cell.__headerState, x = w4(w, an.ROW);
    if (h < 0) {
      mb(b, g(x));
      continue;
    }
    const { cell: E, startColumn: S, startRow: _ } = y[h];
    if (S + E.__colSpan - 1 <= h) {
      let k = E, M = _, A = h;
      for (; M !== U && k.__rowSpan > 1; ) {
        if (A -= E.__colSpan, !(A >= 0)) {
          b.append(g(x));
          continue e;
        }
        {
          const { cell: L, startRow: R } = y[A];
          k = L, M = R;
        }
      }
      k.insertAfter(g(x));
    } else E.setColSpan(E.__colSpan + 1);
  }
  p !== null && Dh(p);
  const v = l.getColWidths();
  if (v) {
    const U = [...v], y = h < 0 ? 0 : h, w = U[y];
    U.splice(y, 0, w), l.setColWidths(U);
  }
  return p;
}
function nz() {
  const e = se();
  ie(e) || Ct(e) || Ut(188);
  const [t, n] = e.isBackward() ? [e.focus.getNode(), e.anchor.getNode()] : [e.anchor.getNode(), e.focus.getNode()], [r, , i] = Cr(t), [a] = Cr(n), [l, s, c] = Xi(i, r, a), { startRow: d } = s, { startRow: o } = c, u = o + a.__rowSpan - 1;
  if (l.length === u - d + 1) return void i.remove();
  const h = l[0].length, f = l[u + 1], p = i.getChildAtIndex(u + 1);
  for (let g = u; g >= d; g--) {
    for (let v = h - 1; v >= 0; v--) {
      const { cell: U, startRow: y, startColumn: w } = l[g][v];
      if (w === v && (g === d && y < d && U.setRowSpan(U.__rowSpan - (y - d)), y >= d && y + U.__rowSpan - 1 > u)) if (U.setRowSpan(U.__rowSpan - (u - y + 1)), p === null && Ut(122), v === 0) mb(p, U);
      else {
        const { cell: x } = f[v - 1];
        x.insertAfter(U);
      }
    }
    const b = i.getChildAtIndex(g);
    Vn(b) || Ut(206, String(g)), b.remove();
  }
  if (f !== void 0) {
    const { cell: g } = f[0];
    Dh(g);
  } else {
    const g = l[d - 1], { cell: b } = g[0];
    Dh(b);
  }
}
function rz() {
  const e = se();
  ie(e) || Ct(e) || Ut(188);
  const t = e.anchor.getNode(), n = e.focus.getNode(), [r, , i] = Cr(t), [a] = Cr(n), [l, s, c] = Xi(i, r, a), { startColumn: d } = s, { startRow: o, startColumn: u } = c, h = Math.min(d, u), f = Math.max(d + r.__colSpan - 1, u + a.__colSpan - 1), p = f - h + 1;
  if (l[0].length === f - h + 1) return i.selectPrevious(), void i.remove();
  const g = l.length;
  for (let y = 0; y < g; y++) for (let w = h; w <= f; w++) {
    const { cell: x, startColumn: E } = l[y][w];
    if (E < h) {
      if (w === h) {
        const S = h - E;
        x.setColSpan(x.__colSpan - Math.min(p, x.__colSpan - S));
      }
    } else if (E + x.__colSpan - 1 > f) {
      if (w === f) {
        const S = f - E + 1;
        x.setColSpan(x.__colSpan - S);
      }
    } else x.remove();
  }
  const b = l[o], v = d > u ? b[d + r.__colSpan] : b[u + a.__colSpan];
  if (v !== void 0) {
    const { cell: y } = v;
    Dh(y);
  } else {
    const y = u < d ? b[u - 1] : b[d - 1], { cell: w } = y;
    Dh(w);
  }
  const U = i.getColWidths();
  if (U) {
    const y = [...U];
    y.splice(h, p), i.setColWidths(y);
  }
}
function Dh(e) {
  const t = e.getFirstDescendant();
  t == null ? e.selectStart() : t.getParentOrThrow().selectStart();
}
function mb(e, t) {
  const n = e.getFirstChild();
  n !== null ? n.insertBefore(t) : e.append(t);
}
function iz() {
  const e = se();
  ie(e) || Ct(e) || Ut(188);
  const t = e.anchor.getNode(), [n, r, i] = Cr(t), a = n.__colSpan, l = n.__rowSpan;
  if (a === 1 && l === 1) return;
  const [s, c] = Xi(i, n, n), { startColumn: d, startRow: o } = c, u = n.__headerState & an.COLUMN, h = Array.from({ length: a }, (g, b) => {
    let v = u;
    for (let U = 0; v !== 0 && U < s.length; U++) v &= s[U][b + d].cell.__headerState;
    return v;
  }), f = n.__headerState & an.ROW, p = Array.from({ length: l }, (g, b) => {
    let v = f;
    for (let U = 0; v !== 0 && U < s[0].length; U++) v &= s[b + o][U].cell.__headerState;
    return v;
  });
  if (a > 1) {
    for (let g = 1; g < a; g++) n.insertAfter(Ma(h[g] | p[0]).append(He()));
    n.setColSpan(1);
  }
  if (l > 1) {
    let g;
    for (let b = 1; b < l; b++) {
      const v = o + b, U = s[v];
      g = (g || r).getNextSibling(), Vn(g) || Ut(125);
      let y = null;
      for (let w = 0; w < d; w++) {
        const x = U[w], E = x.cell;
        x.startRow === v && (y = E), E.__colSpan > 1 && (w += E.__colSpan - 1);
      }
      if (y === null) for (let w = a - 1; w >= 0; w--) mb(g, Ma(h[w] | p[b]).append(He()));
      else for (let w = a - 1; w >= 0; w--) y.insertAfter(Ma(h[w] | p[b]).append(He()));
    }
    n.setRowSpan(1);
  }
}
function Xi(e, t, n) {
  const [r, i, a] = gb(e, t, n);
  return i === null && Ut(207), a === null && Ut(208), [r, i, a];
}
function gb(e, t, n) {
  const r = [];
  let i = null, a = null;
  function l(c) {
    let d = r[c];
    return d === void 0 && (r[c] = d = []), d;
  }
  const s = e.getChildren();
  for (let c = 0; c < s.length; c++) {
    const d = s[c];
    Vn(d) || Ut(209);
    for (let o = d.getFirstChild(), u = 0; o != null; o = o.getNextSibling()) {
      De(o) || Ut(147);
      const h = l(c);
      for (; h[u] !== void 0; ) u++;
      const f = { cell: o, startColumn: u, startRow: c }, { __rowSpan: p, __colSpan: g } = o;
      for (let b = 0; b < p && !(c + b >= s.length); b++) {
        const v = l(c + b);
        for (let U = 0; U < g; U++) v[u + U] = f;
      }
      t !== null && i === null && t.is(o) && (i = f), n !== null && a === null && n.is(o) && (a = f);
    }
  }
  return [r, i, a];
}
function Cr(e) {
  let t;
  if (e instanceof oo) t = e;
  else if ("__type" in e) {
    const i = Xe(e, De);
    De(i) || Ut(148), t = i;
  } else {
    const i = Xe(e.getNode(), De);
    De(i) || Ut(148), t = i;
  }
  const n = t.getParent();
  Vn(n) || Ut(149);
  const r = n.getParent();
  return fn(r) || Ut(210), [t, n, r];
}
function Iv(e) {
  const [t, , n] = Cr(e), r = n.getChildren(), i = r.length, a = r[0].getChildren().length, l = new Array(i);
  for (let s = 0; s < i; s++) l[s] = new Array(a);
  for (let s = 0; s < i; s++) {
    const c = r[s].getChildren();
    let d = 0;
    for (let o = 0; o < c.length; o++) {
      for (; l[s][d]; ) d++;
      const u = c[o], h = u.__rowSpan || 1, f = u.__colSpan || 1;
      for (let p = 0; p < h; p++) for (let g = 0; g < f; g++) l[s + p][d + g] = u;
      if (t === u) return { colSpan: f, columnIndex: d, rowIndex: s, rowSpan: h };
      d += f;
    }
  }
  return null;
}
let YC = class qC {
  constructor(t, n, r) {
    this.anchor = n, this.focus = r, n._selection = this, r._selection = this, this._cachedNodes = null, this.dirty = !1, this.tableKey = t;
  }
  getStartEndPoints() {
    return [this.anchor, this.focus];
  }
  isBackward() {
    return this.focus.isBefore(this.anchor);
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(t) {
    this._cachedNodes = t;
  }
  is(t) {
    return !!Ct(t) && this.tableKey === t.tableKey && this.anchor.is(t.anchor) && this.focus.is(t.focus);
  }
  set(t, n, r) {
    this.dirty = !0, this.tableKey = t, this.anchor.key = n, this.focus.key = r, this._cachedNodes = null;
  }
  clone() {
    return new qC(this.tableKey, this.anchor, this.focus);
  }
  isCollapsed() {
    return !1;
  }
  extract() {
    return this.getNodes();
  }
  insertRawText(t) {
  }
  insertText() {
  }
  hasFormat(t) {
    let n = 0;
    this.getNodes().filter(De).forEach((i) => {
      const a = i.getFirstChild();
      La(a) && (n |= a.getTextFormat());
    });
    const r = Mi[t];
    return !!(n & r);
  }
  insertNodes(t) {
    const n = this.focus.getNode();
    re(n) || Ut(151), bg(n.select(0, n.getChildrenSize())).insertNodes(t);
  }
  getShape() {
    const t = Rt(this.anchor.key);
    De(t) || Ut(152);
    const n = Iv(t);
    n === null && Ut(153);
    const r = Rt(this.focus.key);
    De(r) || Ut(154);
    const i = Iv(r);
    i === null && Ut(155);
    const a = Math.min(n.columnIndex, i.columnIndex), l = Math.max(n.columnIndex + n.colSpan - 1, i.columnIndex + i.colSpan - 1), s = Math.min(n.rowIndex, i.rowIndex), c = Math.max(n.rowIndex + n.rowSpan - 1, i.rowIndex + i.rowSpan - 1);
    return { fromX: Math.min(a, l), fromY: Math.min(s, c), toX: Math.max(a, l), toY: Math.max(s, c) };
  }
  getNodes() {
    const t = this._cachedNodes;
    if (t !== null) return t;
    const n = this.anchor.getNode(), r = this.focus.getNode(), i = Xe(n, De), a = Xe(r, De);
    De(i) || Ut(152), De(a) || Ut(154);
    const l = i.getParent();
    Vn(l) || Ut(156);
    const s = l.getParent();
    fn(s) || Ut(157);
    const c = a.getParents()[1];
    if (c !== s) {
      if (s.isParentOf(a)) {
        const _ = c.getParent();
        _ == null && Ut(159), this.set(this.tableKey, a.getKey(), _.getKey());
      } else {
        const _ = s.getParent();
        _ == null && Ut(158), this.set(this.tableKey, _.getKey(), a.getKey());
      }
      return this.getNodes();
    }
    const [d, o, u] = Xi(s, i, a);
    let h = Math.min(o.startColumn, u.startColumn), f = Math.min(o.startRow, u.startRow), p = Math.max(o.startColumn + o.cell.__colSpan - 1, u.startColumn + u.cell.__colSpan - 1), g = Math.max(o.startRow + o.cell.__rowSpan - 1, u.startRow + u.cell.__rowSpan - 1), b = h, v = f, U = h, y = f;
    function w(_) {
      const { cell: k, startColumn: M, startRow: A } = _;
      h = Math.min(h, M), f = Math.min(f, A), p = Math.max(p, M + k.__colSpan - 1), g = Math.max(g, A + k.__rowSpan - 1);
    }
    for (; h < b || f < v || p > U || g > y; ) {
      if (h < b) {
        const _ = y - v, k = b - 1;
        for (let M = 0; M <= _; M++) w(d[v + M][k]);
        b = k;
      }
      if (f < v) {
        const _ = U - b, k = v - 1;
        for (let M = 0; M <= _; M++) w(d[k][b + M]);
        v = k;
      }
      if (p > U) {
        const _ = y - v, k = U + 1;
        for (let M = 0; M <= _; M++) w(d[v + M][k]);
        U = k;
      }
      if (g > y) {
        const _ = U - b, k = y + 1;
        for (let M = 0; M <= _; M++) w(d[k][b + M]);
        y = k;
      }
    }
    const x = /* @__PURE__ */ new Map([[s.getKey(), s]]);
    let E = null;
    for (let _ = f; _ <= g; _++) for (let k = h; k <= p; k++) {
      const { cell: M } = d[_][k], A = M.getParent();
      Vn(A) || Ut(160), A !== E && x.set(A.getKey(), A), x.set(M.getKey(), M);
      for (const L of az(M)) x.set(L.getKey(), L);
      E = A;
    }
    const S = Array.from(x.values());
    return B0() || (this._cachedNodes = S), S;
  }
  getTextContent() {
    const t = this.getNodes().filter((r) => De(r));
    let n = "";
    for (let r = 0; r < t.length; r++) {
      const i = t[r], a = i.__parent, l = (t[r + 1] || {}).__parent;
      n += i.getTextContent() + (l !== a ? `
` : "	");
    }
    return n;
  }
};
function Ct(e) {
  return e instanceof YC;
}
function Av() {
  const e = qi("root", 0, "element"), t = qi("root", 0, "element");
  return new YC("root", e, t);
}
function az(e) {
  const t = [], n = [e];
  for (; n.length > 0; ) {
    const r = n.pop();
    r === void 0 && Ut(112), re(r) && n.unshift(...r.getChildren()), r !== e && t.push(r);
  }
  return t;
}
let lz = class {
  constructor(t, n) {
    this.isHighlightingCells = !1, this.anchorX = -1, this.anchorY = -1, this.focusX = -1, this.focusY = -1, this.listenersToRemove = /* @__PURE__ */ new Set(), this.tableNodeKey = n, this.editor = t, this.table = { columns: 0, domRows: [], rows: 0 }, this.tableSelection = null, this.anchorCellNodeKey = null, this.focusCellNodeKey = null, this.anchorCell = null, this.focusCell = null, this.hasHijackedSelectionStyles = !1, this.trackTable(), this.isSelecting = !1, this.abortController = new AbortController(), this.listenerOptions = { signal: this.abortController.signal };
  }
  getTable() {
    return this.table;
  }
  removeListeners() {
    this.abortController.abort("removeListeners"), Array.from(this.listenersToRemove).forEach((t) => t()), this.listenersToRemove.clear();
  }
  trackTable() {
    const t = new MutationObserver((n) => {
      this.editor.update(() => {
        let r = !1;
        for (let a = 0; a < n.length; a++) {
          const l = n[a].target.nodeName;
          if (l === "TABLE" || l === "TBODY" || l === "THEAD" || l === "TR") {
            r = !0;
            break;
          }
        }
        if (!r) return;
        const i = this.editor.getElementByKey(this.tableNodeKey);
        if (!i) throw new Error("Expected to find TableElement in DOM");
        this.table = lh(i);
      });
    });
    this.editor.update(() => {
      const n = this.editor.getElementByKey(this.tableNodeKey);
      if (!n) throw new Error("Expected to find TableElement in DOM");
      this.table = lh(n), t.observe(n, { attributes: !0, childList: !0, subtree: !0 });
    });
  }
  clearHighlight() {
    const t = this.editor;
    this.isHighlightingCells = !1, this.anchorX = -1, this.anchorY = -1, this.focusX = -1, this.focusY = -1, this.tableSelection = null, this.anchorCellNodeKey = null, this.focusCellNodeKey = null, this.anchorCell = null, this.focusCell = null, this.hasHijackedSelectionStyles = !1, this.enableHighlightStyle(), t.update(() => {
      if (!fn(Rt(this.tableNodeKey))) throw new Error("Expected TableNode.");
      const n = t.getElementByKey(this.tableNodeKey);
      if (!n) throw new Error("Expected to find TableElement in DOM");
      const r = lh(n);
      c1(t, r, null), pn(null), t.dispatchCommand(Ei, void 0);
    });
  }
  enableHighlightStyle() {
    const t = this.editor;
    t.update(() => {
      const n = t.getElementByKey(this.tableNodeKey);
      if (!n) throw new Error("Expected to find TableElement in DOM");
      id(n, t._config.theme.tableSelection), n.classList.remove("disable-selection"), this.hasHijackedSelectionStyles = !1;
    });
  }
  disableHighlightStyle() {
    const t = this.editor;
    t.update(() => {
      const n = t.getElementByKey(this.tableNodeKey);
      if (!n) throw new Error("Expected to find TableElement in DOM");
      zn(n, t._config.theme.tableSelection), this.hasHijackedSelectionStyles = !0;
    });
  }
  updateTableTableSelection(t) {
    if (t !== null && t.tableKey === this.tableNodeKey) {
      const n = this.editor;
      this.tableSelection = t, this.isHighlightingCells = !0, this.disableHighlightStyle(), c1(n, this.table, this.tableSelection);
    } else t == null ? this.clearHighlight() : (this.tableNodeKey = t.tableKey, this.updateTableTableSelection(t));
  }
  setFocusCellForSelection(t, n = !1) {
    const r = this.editor;
    r.update(() => {
      const i = Rt(this.tableNodeKey);
      if (!fn(i)) throw new Error("Expected TableNode.");
      if (!r.getElementByKey(this.tableNodeKey)) throw new Error("Expected to find TableElement in DOM");
      const a = t.x, l = t.y;
      if (this.focusCell = t, this.anchorCell !== null) {
        const s = ZC(r._window);
        s && s.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);
      }
      if (this.isHighlightingCells || this.anchorX === a && this.anchorY === l && !n) {
        if (a === this.focusX && l === this.focusY) return;
      } else this.isHighlightingCells = !0, this.disableHighlightStyle();
      if (this.focusX = a, this.focusY = l, this.isHighlightingCells) {
        const s = on(t.elem);
        if (this.tableSelection != null && this.anchorCellNodeKey != null && De(s) && i.is(Rd(s))) {
          const c = s.getKey();
          this.tableSelection = this.tableSelection.clone() || Av(), this.focusCellNodeKey = c, this.tableSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey), pn(this.tableSelection), r.dispatchCommand(Ei, void 0), c1(r, this.table, this.tableSelection);
        }
      }
    });
  }
  setAnchorCellForSelection(t) {
    this.isHighlightingCells = !1, this.anchorCell = t, this.anchorX = t.x, this.anchorY = t.y, this.editor.update(() => {
      const n = on(t.elem);
      if (De(n)) {
        const r = n.getKey();
        this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : Av(), this.anchorCellNodeKey = r;
      }
    });
  }
  formatCells(t) {
    this.editor.update(() => {
      const n = se();
      Ct(n) || Ut(11);
      const r = yf(), i = r.anchor, a = r.focus, l = n.getNodes().filter(De), s = l[0].getFirstChild(), c = La(s) ? s.getFormatFlags(t, null) : null;
      l.forEach((d) => {
        i.set(d.getKey(), 0, "element"), a.set(d.getKey(), d.getChildrenSize(), "element"), r.formatText(t, c);
      }), pn(n), this.editor.dispatchCommand(Ei, void 0);
    });
  }
  clearText() {
    const t = this.editor;
    t.update(() => {
      const n = Rt(this.tableNodeKey);
      if (!fn(n)) throw new Error("Expected TableNode.");
      const r = se();
      Ct(r) || Ut(11);
      const i = r.getNodes().filter(De);
      i.length !== this.table.columns * this.table.rows ? (i.forEach((a) => {
        if (re(a)) {
          const l = He(), s = un();
          l.append(s), a.append(l), a.getChildren().forEach((c) => {
            c !== l && c.remove();
          });
        }
      }), c1(t, this.table, null), pn(null), t.dispatchCommand(Ei, void 0)) : (n.selectPrevious(), n.remove(), Bt().selectStart());
    });
  }
};
const x4 = "__lexicalTableSelection", ZC = (e) => JF ? (e || window).getSelection() : null;
function sz(e, t, n, r) {
  const i = n.getRootElement();
  if (i === null) throw new Error("No root element.");
  const a = new lz(n, e.getKey()), l = n._window || window;
  (function(o, u) {
    E4(o) !== null && Ut(205), o[x4] = u;
  })(t, a), a.listenersToRemove.add(() => function(o, u) {
    E4(o) === u && delete o[x4];
  }(t, a));
  const s = () => {
    const o = () => {
      a.isSelecting = !1, l.removeEventListener("mouseup", o), l.removeEventListener("mousemove", u);
    }, u = (h) => {
      setTimeout(() => {
        if (1 & ~h.buttons && a.isSelecting) return a.isSelecting = !1, l.removeEventListener("mouseup", o), void l.removeEventListener("mousemove", u);
        const f = S4(h.target);
        f === null || a.anchorX === f.x && a.anchorY === f.y || (h.preventDefault(), a.setFocusCellForSelection(f));
      }, 0);
    };
    return { onMouseMove: u, onMouseUp: o };
  };
  t.addEventListener("mousedown", (o) => {
    setTimeout(() => {
      if (o.button !== 0 || !l) return;
      const u = S4(o.target);
      u !== null && (Kl(o), a.setAnchorCellForSelection(u));
      const { onMouseUp: h, onMouseMove: f } = s();
      a.isSelecting = !0, l.addEventListener("mouseup", h, a.listenerOptions), l.addEventListener("mousemove", f, a.listenerOptions);
    }, 0);
  }, a.listenerOptions), l.addEventListener("mousedown", (o) => {
    o.button === 0 && n.update(() => {
      const u = se(), h = o.target;
      Ct(u) && u.tableKey === a.tableNodeKey && i.contains(h) && a.clearHighlight();
    });
  }, a.listenerOptions), a.listenersToRemove.add(n.registerCommand(Ao, (o) => zu(n, o, "down", e, a), vi)), a.listenersToRemove.add(n.registerCommand(Io, (o) => zu(n, o, "up", e, a), vi)), a.listenersToRemove.add(n.registerCommand(R0, (o) => zu(n, o, "backward", e, a), vi)), a.listenersToRemove.add(n.registerCommand(pf, (o) => zu(n, o, "forward", e, a), vi)), a.listenersToRemove.add(n.registerCommand(rd, (o) => {
    const u = se();
    if (Ct(u)) {
      const h = Xe(u.focus.getNode(), De);
      if (De(h)) return Kl(o), h.selectEnd(), !0;
    }
    return !1;
  }, vi)), [i0, Cc, ls].forEach((o) => {
    a.listenersToRemove.add(n.registerCommand(o, /* @__PURE__ */ ((u) => () => {
      const h = se();
      if (!qo(h, e)) return !1;
      if (Ct(h)) return a.clearText(), !0;
      if (ie(h)) {
        const f = Xe(h.anchor.getNode(), (w) => De(w));
        if (!De(f)) return !1;
        const p = h.anchor.getNode(), g = h.focus.getNode(), b = e.isParentOf(p), v = e.isParentOf(g);
        if (b && !v || v && !b) return a.clearText(), !0;
        const U = Xe(h.anchor.getNode(), (w) => re(w)), y = U && Xe(U, (w) => re(w) && De(w.getParent()));
        if (!re(y) || !re(U)) return !1;
        if (u === Cc && y.getPreviousSibling() === null) return !0;
      }
      return !1;
    })(o), mr));
  });
  const c = (o) => {
    const u = se();
    if (!Ct(u) && !ie(u)) return !1;
    const h = e.isParentOf(u.anchor.getNode());
    if (h !== e.isParentOf(u.focus.getNode())) {
      const f = h ? "anchor" : "focus", p = h ? "focus" : "anchor", { key: g, offset: b, type: v } = u[p];
      return e[u[f].isBefore(u[p]) ? "selectPrevious" : "selectNext"]()[p].set(g, b, v), !1;
    }
    return !!Ct(u) && (o && (o.preventDefault(), o.stopPropagation()), a.clearText(), !0);
  };
  function d(o) {
    const u = e.getCordsFromCellNode(o, a.table);
    return e.getDOMCellFromCordsOrThrow(u.x, u.y, a.table);
  }
  return a.listenersToRemove.add(n.registerCommand(P0, c, mr)), a.listenersToRemove.add(n.registerCommand(O0, c, mr)), a.listenersToRemove.add(n.registerCommand(fg, (o) => {
    const u = se();
    if (u) {
      if (!Ct(u) && !ie(u)) return !1;
      v4(n, ns(o, ClipboardEvent) ? o : null, zC(u));
      const h = c(o);
      return ie(u) ? (u.removeText(), !0) : h;
    }
    return !1;
  }, mr)), a.listenersToRemove.add(n.registerCommand(Mn, (o) => {
    const u = se();
    if (!qo(u, e)) return !1;
    if (Ct(u)) return a.formatCells(o), !0;
    if (ie(u)) {
      const h = Xe(u.anchor.getNode(), (f) => De(f));
      if (!De(h)) return !1;
    }
    return !1;
  }, mr)), a.listenersToRemove.add(n.registerCommand(il, (o) => {
    const u = se();
    if (!Ct(u) || !qo(u, e)) return !1;
    const h = u.anchor.getNode(), f = u.focus.getNode();
    if (!De(h) || !De(f)) return !1;
    const [p, g, b] = Xi(e, h, f), v = Math.max(g.startRow, b.startRow), U = Math.max(g.startColumn, b.startColumn), y = Math.min(g.startRow, b.startRow), w = Math.min(g.startColumn, b.startColumn);
    for (let x = y; x <= v; x++) for (let E = w; E <= U; E++) {
      const S = p[x][E].cell;
      S.setFormat(o);
      const _ = S.getChildren();
      for (let k = 0; k < _.length; k++) {
        const M = _[k];
        re(M) && !M.isInline() && M.setFormat(o);
      }
    }
    return !0;
  }, mr)), a.listenersToRemove.add(n.registerCommand(gc, (o) => {
    const u = se();
    if (!qo(u, e)) return !1;
    if (Ct(u)) return a.clearHighlight(), !1;
    if (ie(u)) {
      const h = Xe(u.anchor.getNode(), (f) => De(f));
      if (!De(h)) return !1;
      if (typeof o == "string") {
        const f = Lv(n, u, e);
        if (f) return Dv(f, e, [un(o)]), !0;
      }
    }
    return !1;
  }, mr)), r && a.listenersToRemove.add(n.registerCommand(mf, (o) => {
    const u = se();
    if (!ie(u) || !u.isCollapsed() || !qo(u, e)) return !1;
    const h = t6(u.anchor.getNode());
    if (h === null) return !1;
    Kl(o);
    const f = e.getCordsFromCellNode(h, a.table);
    return JC(a, e, f.x, f.y, o.shiftKey ? "backward" : "forward"), !0;
  }, mr)), a.listenersToRemove.add(n.registerCommand(x3, (o) => e.isSelected(), vi)), a.listenersToRemove.add(n.registerCommand(ok, (o) => {
    const { nodes: u, selection: h } = o, f = h.getStartEndPoints(), p = Ct(h), g = ie(h) && Xe(h.anchor.getNode(), (j) => De(j)) !== null && Xe(h.focus.getNode(), (j) => De(j)) !== null || p;
    if (u.length !== 1 || !fn(u[0]) || !g || f === null) return !1;
    const [b] = f, v = u[0], U = v.getChildren(), y = v.getFirstChildOrThrow().getChildrenSize(), w = v.getChildrenSize(), x = Xe(b.getNode(), (j) => De(j)), E = x && Xe(x, (j) => Vn(j)), S = E && Xe(E, (j) => fn(j));
    if (!De(x) || !Vn(E) || !fn(S)) return !1;
    const _ = E.getIndexWithinParent(), k = Math.min(S.getChildrenSize() - 1, _ + w - 1), M = x.getIndexWithinParent(), A = Math.min(E.getChildrenSize() - 1, M + y - 1), L = Math.min(M, A), R = Math.min(_, k), z = Math.max(M, A), F = Math.max(_, k), W = S.getChildren();
    let B = 0;
    for (let j = R; j <= F; j++) {
      const V = W[j];
      if (!Vn(V)) return !1;
      const q = U[B];
      if (!Vn(q)) return !1;
      const oe = V.getChildren(), Ue = q.getChildren();
      let fe = 0;
      for (let Pe = L; Pe <= z; Pe++) {
        const ze = oe[Pe];
        if (!De(ze)) return !1;
        const Oe = Ue[fe];
        if (!De(Oe)) return !1;
        const Be = ze.getChildren();
        Oe.getChildren().forEach((qe) => {
          ce(qe) && He().append(qe), ze.append(qe);
        }), Be.forEach((qe) => qe.remove()), fe++;
      }
      B++;
    }
    return !0;
  }, mr)), a.listenersToRemove.add(n.registerCommand(Ei, () => {
    const o = se(), u = Do();
    if (ie(o)) {
      const { anchor: h, focus: f } = o, p = h.getNode(), g = f.getNode(), b = t6(p), v = t6(g), U = !(!b || !e.is(Rd(b))), y = !(!v || !e.is(Rd(v))), w = U !== y, x = U && y, E = o.isBackward();
      if (w) {
        const S = o.clone();
        if (y) {
          const [_] = Xi(e, v, v), k = _[0][0].cell, M = _[_.length - 1].at(-1).cell;
          S.focus.set(E ? k.getKey() : M.getKey(), E ? k.getChildrenSize() : M.getChildrenSize(), "element");
        } else if (U) {
          const [_] = Xi(e, b, b), k = _[0][0].cell, M = _[_.length - 1].at(-1).cell;
          S.anchor.set(E ? M.getKey() : k.getKey(), E ? M.getChildrenSize() : 0, "element");
        }
        pn(S), Nv(n, a);
      } else x && (b.is(v) || (a.setAnchorCellForSelection(d(b)), a.setFocusCellForSelection(d(v), !0), a.isSelecting || setTimeout(() => {
        const { onMouseUp: S, onMouseMove: _ } = s();
        a.isSelecting = !0, l.addEventListener("mouseup", S), l.addEventListener("mousemove", _);
      }, 0)));
    } else if (o && Ct(o) && o.is(u) && o.tableKey === e.getKey()) {
      const h = ZC(n._window);
      if (h && h.anchorNode && h.focusNode) {
        const f = on(h.focusNode), p = f && !e.is(Rd(f)), g = on(h.anchorNode), b = g && e.is(Rd(g));
        if (p && b && h.rangeCount > 0) {
          const v = P$(h, n);
          v && (v.anchor.set(e.getKey(), o.isBackward() ? e.getChildrenSize() : 0, "element"), h.removeAllRanges(), pn(v));
        }
      }
    }
    return o && !o.is(u) && (Ct(o) || Ct(u)) && a.tableSelection && !a.tableSelection.is(u) ? (Ct(o) && o.tableKey === a.tableNodeKey ? a.updateTableTableSelection(o) : !Ct(o) && Ct(u) && u.tableKey === a.tableNodeKey && a.updateTableTableSelection(null), !1) : (a.hasHijackedSelectionStyles && !e.isSelected() ? function(h, f) {
      f.enableHighlightStyle(), bb(f.table, (p) => {
        const g = p.elem;
        p.highlighted = !1, eM(h, p), g.getAttribute("style") || g.removeAttribute("style");
      });
    }(n, a) : !a.hasHijackedSelectionStyles && e.isSelected() && Nv(n, a), !1);
  }, mr)), a.listenersToRemove.add(n.registerCommand(kc, () => {
    const o = se();
    if (!ie(o) || !o.isCollapsed() || !qo(o, e)) return !1;
    const u = Lv(n, o, e);
    return !!u && (Dv(u, e), !0);
  }, mr)), a;
}
function E4(e) {
  return e[x4] || null;
}
function S4(e) {
  let t = e;
  for (; t != null; ) {
    const n = t.nodeName;
    if (n === "TD" || n === "TH") {
      const r = t._cell;
      return r === void 0 ? null : r;
    }
    t = t.parentNode;
  }
  return null;
}
function lh(e) {
  const t = [], n = { columns: 0, domRows: t, rows: 0 };
  let r = e.querySelector("tr"), i = 0, a = 0;
  for (t.length = 0; r != null; ) {
    const l = r.nodeName;
    if (l === "TD" || l === "TH") {
      const d = { elem: r, hasBackgroundColor: r.style.backgroundColor !== "", highlighted: !1, x: i, y: a };
      r._cell = d;
      let o = t[a];
      o === void 0 && (o = t[a] = []), o[i] = d;
    } else {
      const d = r.firstChild;
      if (d != null) {
        r = d;
        continue;
      }
    }
    const s = r.nextSibling;
    if (s != null) {
      i++, r = s;
      continue;
    }
    const c = r.parentNode;
    if (c != null) {
      const d = c.nextSibling;
      if (d == null) break;
      a++, i = 0, r = d;
    }
  }
  return n.columns = i + 1, n.rows = a + 1, n;
}
function c1(e, t, n) {
  const r = new Set(n ? n.getNodes() : []);
  bb(t, (i, a) => {
    const l = i.elem;
    r.has(a) ? (i.highlighted = !0, QC(e, i)) : (i.highlighted = !1, eM(e, i), l.getAttribute("style") || l.removeAttribute("style"));
  });
}
function bb(e, t) {
  const { domRows: n } = e;
  for (let r = 0; r < n.length; r++) {
    const i = n[r];
    if (i) for (let a = 0; a < i.length; a++) {
      const l = i[a];
      if (!l) continue;
      const s = on(l.elem);
      s !== null && t(l, s, { x: a, y: r });
    }
  }
}
function Nv(e, t) {
  t.disableHighlightStyle(), bb(t.table, (n) => {
    n.highlighted = !0, QC(e, n);
  });
}
const JC = (e, t, n, r, i) => {
  const a = i === "forward";
  switch (i) {
    case "backward":
    case "forward":
      return n !== (a ? e.table.columns - 1 : 0) ? d1(t.getCellNodeFromCordsOrThrow(n + (a ? 1 : -1), r, e.table), a) : r !== (a ? e.table.rows - 1 : 0) ? d1(t.getCellNodeFromCordsOrThrow(a ? 0 : e.table.columns - 1, r + (a ? 1 : -1), e.table), a) : a ? t.selectNext() : t.selectPrevious(), !0;
    case "up":
      return r !== 0 ? d1(t.getCellNodeFromCordsOrThrow(n, r - 1, e.table), !1) : t.selectPrevious(), !0;
    case "down":
      return r !== e.table.rows - 1 ? d1(t.getCellNodeFromCordsOrThrow(n, r + 1, e.table), !0) : t.selectNext(), !0;
    default:
      return !1;
  }
}, oz = (e, t, n, r, i) => {
  const a = i === "forward";
  switch (i) {
    case "backward":
    case "forward":
      return n !== (a ? e.table.columns - 1 : 0) && e.setFocusCellForSelection(t.getDOMCellFromCordsOrThrow(n + (a ? 1 : -1), r, e.table)), !0;
    case "up":
      return r !== 0 && (e.setFocusCellForSelection(t.getDOMCellFromCordsOrThrow(n, r - 1, e.table)), !0);
    case "down":
      return r !== e.table.rows - 1 && (e.setFocusCellForSelection(t.getDOMCellFromCordsOrThrow(n, r + 1, e.table)), !0);
    default:
      return !1;
  }
};
function qo(e, t) {
  if (ie(e) || Ct(e)) {
    const n = t.isParentOf(e.anchor.getNode()), r = t.isParentOf(e.focus.getNode());
    return n && r;
  }
  return !1;
}
function d1(e, t) {
  t ? e.selectStart() : e.selectEnd();
}
const e6 = "172,206,247";
function QC(e, t) {
  const n = t.elem, r = on(n);
  De(r) || Ut(131), r.getBackgroundColor() === null ? n.style.setProperty("background-color", `rgb(${e6})`) : n.style.setProperty("background-image", `linear-gradient(to right, rgba(${e6},0.85), rgba(${e6},0.85))`), n.style.setProperty("caret-color", "transparent");
}
function eM(e, t) {
  const n = t.elem, r = on(n);
  De(r) || Ut(131), r.getBackgroundColor() === null && n.style.removeProperty("background-color"), n.style.removeProperty("background-image"), n.style.removeProperty("caret-color");
}
function t6(e) {
  const t = Xe(e, De);
  return De(t) ? t : null;
}
function Rd(e) {
  const t = Xe(e, fn);
  return fn(t) ? t : null;
}
function zu(e, t, n, r, i) {
  if ((n === "up" || n === "down") && function(l) {
    const s = l.getRootElement();
    return s ? s.hasAttribute("aria-controls") && s.getAttribute("aria-controls") === "typeahead-menu" : !1;
  }(e)) return !1;
  const a = se();
  if (!qo(a, r)) {
    if (ie(a)) {
      if (a.isCollapsed() && n === "backward") {
        const l = a.anchor.type, s = a.anchor.offset;
        if (l !== "element" && (l !== "text" || s !== 0)) return !1;
        const c = a.anchor.getNode();
        if (!c) return !1;
        const d = Xe(c, (u) => re(u) && !u.isInline());
        if (!d) return !1;
        const o = d.getPreviousSibling();
        return !(!o || !fn(o)) && (Kl(t), o.selectEnd(), !0);
      }
      if (t.shiftKey && (n === "up" || n === "down")) {
        const l = a.focus.getNode();
        if (!a.isCollapsed() && (n === "up" && !a.isBackward() || n === "down" && a.isBackward())) {
          let s = Xe(l, (h) => fn(h));
          if (De(s) && (s = Xe(s, fn)), s !== r || !s) return !1;
          const c = n === "down" ? s.getNextSibling() : s.getPreviousSibling();
          if (!c) return !1;
          let d = 0;
          n === "up" && re(c) && (d = c.getChildrenSize());
          let o = c;
          n === "up" && re(c) && (o = c.getLastChild() || c, d = ce(o) ? o.getTextContentSize() : 0);
          const u = a.clone();
          return u.focus.set(o.getKey(), d, ce(o) ? "text" : "element"), pn(u), Kl(t), !0;
        }
        if (er(l)) {
          const s = n === "up" ? a.getNodes()[a.getNodes().length - 1] : a.getNodes()[0];
          if (s) {
            const c = Xe(s, De);
            if (c && r.isParentOf(c)) {
              const d = r.getFirstDescendant(), o = r.getLastDescendant();
              if (!d || !o) return !1;
              const [u] = Cr(d), [h] = Cr(o), f = r.getCordsFromCellNode(u, i.table), p = r.getCordsFromCellNode(h, i.table), g = r.getDOMCellFromCordsOrThrow(f.x, f.y, i.table), b = r.getDOMCellFromCordsOrThrow(p.x, p.y, i.table);
              return i.setAnchorCellForSelection(g), i.setFocusCellForSelection(b, !0), !0;
            }
          }
          return !1;
        }
        {
          let s = Xe(l, (d) => re(d) && !d.isInline());
          if (De(s) && (s = Xe(s, fn)), !s) return !1;
          const c = n === "down" ? s.getNextSibling() : s.getPreviousSibling();
          if (fn(c) && i.tableNodeKey === c.getKey()) {
            const d = c.getFirstDescendant(), o = c.getLastDescendant();
            if (!d || !o) return !1;
            const [u] = Cr(d), [h] = Cr(o), f = a.clone();
            return f.focus.set((n === "up" ? u : h).getKey(), n === "up" ? 0 : h.getChildrenSize(), "element"), Kl(t), pn(f), !0;
          }
        }
      }
    }
    return !1;
  }
  if (ie(a) && a.isCollapsed()) {
    const { anchor: l, focus: s } = a, c = Xe(l.getNode(), De), d = Xe(s.getNode(), De);
    if (!De(c) || !c.is(d)) return !1;
    const o = Rd(c);
    if (o !== r && o != null) {
      const v = e.getElementByKey(o.getKey());
      if (v != null) return i.table = lh(v), zu(e, t, n, o, i);
    }
    if (n === "backward" || n === "forward") {
      const v = l.type, U = l.offset, y = l.getNode();
      if (!y) return !1;
      const w = a.getNodes();
      return (w.length !== 1 || !Ft(w[0])) && !!function(x, E, S, _) {
        return function(k, M, A) {
          return k === "element" && (A === "backward" ? M.getPreviousSibling() === null : M.getNextSibling() === null);
        }(x, S, _) || function(k, M, A, L) {
          const R = Xe(A, (F) => re(F) && !F.isInline());
          if (!R) return !1;
          const z = L === "backward" ? M === 0 : M === A.getTextContentSize();
          return k === "text" && z && (L === "backward" ? R.getPreviousSibling() === null : R.getNextSibling() === null);
        }(x, E, S, _);
      }(v, U, y, n) && function(x, E, S, _) {
        const k = Xe(E, De);
        if (!De(k)) return !1;
        const [M, A] = Xi(S, k, k);
        if (!function(R, z, F) {
          const W = R[0][0], B = R[R.length - 1][R[0].length - 1], { startColumn: j, startRow: V } = z;
          return F === "backward" ? j === W.startColumn && V === W.startRow : j === B.startColumn && V === B.startRow;
        }(M, A, _)) return !1;
        const L = function(R, z, F) {
          const W = Xe(R, (j) => re(j) && !j.isInline());
          if (!W) return;
          const B = z === "backward" ? W.getPreviousSibling() : W.getNextSibling();
          return B && fn(B) ? B : z === "backward" ? F.getPreviousSibling() : F.getNextSibling();
        }(E, _, S);
        return !L || fn(L) ? !1 : (Kl(x), _ === "backward" ? L.selectEnd() : L.selectStart(), !0);
      }(t, y, r, n);
    }
    const u = e.getElementByKey(c.__key), h = e.getElementByKey(l.key);
    if (h == null || u == null) return !1;
    let f;
    if (l.type === "element") f = h.getBoundingClientRect();
    else {
      const v = window.getSelection();
      if (v === null || v.rangeCount === 0) return !1;
      f = v.getRangeAt(0).getBoundingClientRect();
    }
    const p = n === "up" ? c.getFirstChild() : c.getLastChild();
    if (p == null) return !1;
    const g = e.getElementByKey(p.__key);
    if (g == null) return !1;
    const b = g.getBoundingClientRect();
    if (n === "up" ? b.top > f.top - f.height : f.bottom + f.height > b.bottom) {
      Kl(t);
      const v = r.getCordsFromCellNode(c, i.table);
      if (!t.shiftKey) return JC(i, r, v.x, v.y, n);
      {
        const U = r.getDOMCellFromCordsOrThrow(v.x, v.y, i.table);
        i.setAnchorCellForSelection(U), i.setFocusCellForSelection(U, !0);
      }
      return !0;
    }
  } else if (Ct(a)) {
    const { anchor: l, focus: s } = a, c = Xe(l.getNode(), De), d = Xe(s.getNode(), De), [o] = a.getNodes(), u = e.getElementByKey(o.getKey());
    if (!De(c) || !De(d) || !fn(o) || u == null) return !1;
    i.updateTableTableSelection(a);
    const h = lh(u), f = r.getCordsFromCellNode(c, h), p = r.getDOMCellFromCordsOrThrow(f.x, f.y, h);
    if (i.setAnchorCellForSelection(p), Kl(t), t.shiftKey) {
      const g = r.getCordsFromCellNode(d, h);
      return oz(i, o, g.x, g.y, n);
    }
    return d.selectEnd(), !0;
  }
  return !1;
}
function Kl(e) {
  e.preventDefault(), e.stopImmediatePropagation(), e.stopPropagation();
}
function Dv(e, t, n) {
  const r = He();
  e === "first" ? t.insertBefore(r) : t.insertAfter(r), r.append(...n || []), r.selectEnd();
}
function Lv(e, t, n) {
  const r = n.getParent();
  if (!r) return;
  const i = e.getElementByKey(r.getKey());
  if (!i) return;
  const a = window.getSelection();
  if (!a || a.anchorNode !== i) return;
  const l = Xe(t.anchor.getNode(), (b) => De(b));
  if (!l) return;
  const s = Xe(l, (b) => fn(b));
  if (!fn(s) || !s.is(n)) return;
  const [c, d] = Xi(n, l, l), o = c[0][0], u = c[c.length - 1][c[0].length - 1], { startRow: h, startColumn: f } = d, p = h === o.startRow && f === o.startColumn, g = h === u.startRow && f === u.startColumn;
  return p ? "first" : g ? "last" : void 0;
}
function Rv(e, t, n, r) {
  const i = e.querySelector("colgroup");
  if (!i) return;
  const a = [];
  for (let l = 0; l < n; l++) {
    const s = document.createElement("col"), c = r && r[l];
    c && (s.style.width = `${c}px`), a.push(s);
  }
  i.replaceChildren(...a);
}
function Pv(e, t, n) {
  n ? (zn(e, t.theme.tableRowStriping), e.setAttribute("data-lexical-row-striping", "true")) : (id(e, t.theme.tableRowStriping), e.removeAttribute("data-lexical-row-striping"));
}
let co = class tM extends tr {
  static getType() {
    return "table";
  }
  getColWidths() {
    return this.getLatest().__colWidths;
  }
  setColWidths(t) {
    const n = this.getWritable();
    return n.__colWidths = t, n;
  }
  static clone(t) {
    return new tM(t.__key);
  }
  afterCloneFrom(t) {
    super.afterCloneFrom(t), this.__colWidths = t.__colWidths, this.__rowStriping = t.__rowStriping;
  }
  static importDOM() {
    return { table: (t) => ({ conversion: cz, priority: 1 }) };
  }
  static importJSON(t) {
    const n = Ub();
    return n.__rowStriping = t.rowStriping || !1, n.__colWidths = t.colWidths, n;
  }
  constructor(t) {
    super(t), this.__rowStriping = !1;
  }
  exportJSON() {
    return { ...super.exportJSON(), colWidths: this.getColWidths(), rowStriping: this.__rowStriping ? this.__rowStriping : void 0, type: "table", version: 1 };
  }
  createDOM(t, n) {
    const r = document.createElement("table"), i = document.createElement("colgroup");
    return r.appendChild(i), Rv(r, 0, this.getColumnCount(), this.getColWidths()), zn(r, t.theme.table), this.__rowStriping && Pv(r, t, !0), r;
  }
  updateDOM(t, n, r) {
    return t.__rowStriping !== this.__rowStriping && Pv(n, r, this.__rowStriping), Rv(n, 0, this.getColumnCount(), this.getColWidths()), !1;
  }
  exportDOM(t) {
    return { ...super.exportDOM(t), after: (n) => {
      if (n) {
        const r = n.cloneNode(), i = document.createElement("colgroup"), a = document.createElement("tbody");
        if (Ti(n)) {
          const l = n.querySelectorAll("col");
          i.append(...l);
          const s = n.querySelectorAll("tr");
          a.append(...s);
        }
        return r.replaceChildren(i, a), r;
      }
    } };
  }
  canBeEmpty() {
    return !1;
  }
  isShadowRoot() {
    return !0;
  }
  getCordsFromCellNode(t, n) {
    const { rows: r, domRows: i } = n;
    for (let a = 0; a < r; a++) {
      const l = i[a];
      if (l == null) continue;
      const s = l.findIndex((c) => {
        if (!c) return;
        const { elem: d } = c;
        return on(d) === t;
      });
      if (s !== -1) return { x: s, y: a };
    }
    throw new Error("Cell not found in table.");
  }
  getDOMCellFromCords(t, n, r) {
    const { domRows: i } = r, a = i[n];
    if (a == null) return null;
    const l = a[t < a.length ? t : a.length - 1];
    return l ?? null;
  }
  getDOMCellFromCordsOrThrow(t, n, r) {
    const i = this.getDOMCellFromCords(t, n, r);
    if (!i) throw new Error("Cell not found at cords.");
    return i;
  }
  getCellNodeFromCords(t, n, r) {
    const i = this.getDOMCellFromCords(t, n, r);
    if (i == null) return null;
    const a = on(i.elem);
    return De(a) ? a : null;
  }
  getCellNodeFromCordsOrThrow(t, n, r) {
    const i = this.getCellNodeFromCords(t, n, r);
    if (!i) throw new Error("Node at cords not TableCellNode.");
    return i;
  }
  getRowStriping() {
    return !!this.getLatest().__rowStriping;
  }
  setRowStriping(t) {
    this.getWritable().__rowStriping = t;
  }
  canSelectBefore() {
    return !0;
  }
  canIndent() {
    return !1;
  }
  getColumnCount() {
    const t = this.getFirstChild();
    if (!t) return 0;
    let n = 0;
    return t.getChildren().forEach((r) => {
      De(r) && (n += r.getColSpan());
    }), n;
  }
};
function cz(e) {
  const t = Ub();
  e.hasAttribute("data-lexical-row-striping") && t.setRowStriping(!0);
  const n = e.querySelector(":scope > colgroup");
  if (n) {
    let r = [];
    for (const i of n.querySelectorAll(":scope > col")) {
      const a = i.style.width;
      if (!a || !hb.test(a)) {
        r = void 0;
        break;
      }
      r.push(parseFloat(a));
    }
    r && t.setColWidths(r);
  }
  return { node: t };
}
function Ub() {
  return En(new co());
}
function fn(e) {
  return e instanceof co;
}
function dz({ nodeKey: e }) {
  const [t] = Fe(), [n, r, i] = sb(e), a = he(
    (l) => {
      if (l.preventDefault(), n && Xn(se())) {
        const s = Rt(e);
        if (hz(s))
          return s.remove(), !0;
      }
      return !1;
    },
    [n, e]
  );
  return Y(() => Pt(
    t.registerCommand(
      L0,
      (l) => {
        const s = t.getElementByKey(e);
        return l.target === s ? (l.shiftKey || i(), r(!n), !0) : !1;
      },
      ot
    ),
    t.registerCommand(
      O0,
      a,
      ot
    ),
    t.registerCommand(
      P0,
      a,
      ot
    )
  ), [i, t, n, e, a, r]), Y(() => {
    const l = t.getElementByKey(e);
    l !== null && (l.className = n ? "selected" : "");
  }, [t, n, e]), null;
}
class X0 extends Ha {
  static getType() {
    return "page-break";
  }
  static clone(t) {
    return new X0(t.__key);
  }
  static importJSON() {
    return vb();
  }
  static importDOM() {
    return {
      figure: (t) => t.getAttribute("type") !== this.getType() ? null : {
        conversion: uz,
        priority: vi
      }
    };
  }
  exportJSON() {
    return {
      type: this.getType(),
      version: 1
    };
  }
  createDOM() {
    const t = document.createElement("figure");
    return t.style.pageBreakAfter = "always", t.setAttribute("type", this.getType()), t;
  }
  getTextContent() {
    return `
`;
  }
  isInline() {
    return !1;
  }
  updateDOM() {
    return !1;
  }
  decorate() {
    return /* @__PURE__ */ m(dz, { nodeKey: this.__key });
  }
}
function uz() {
  return { node: vb() };
}
function vb() {
  return new X0();
}
function hz(e) {
  return e instanceof X0;
}
class kf extends aa {
  constructor(n, r, i) {
    super(r, i);
    Ne(this, "__className");
    this.__className = n;
  }
  static getType() {
    return "emoji";
  }
  static clone(n) {
    return new kf(n.__className, n.__text, n.__key);
  }
  createDOM(n) {
    const r = document.createElement("span"), i = super.createDOM(n);
    return r.className = this.__className, i.className = "emoji-inner", r.appendChild(i), r;
  }
  updateDOM(n, r, i) {
    const a = r.firstChild;
    return a === null ? !0 : (super.updateDOM(n, a, i), !1);
  }
  static importJSON(n) {
    const r = nM(
      n.className,
      n.text
    );
    return r.setFormat(n.format), r.setDetail(n.detail), r.setMode(n.mode), r.setStyle(n.style), r;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      className: this.getClassName(),
      type: "emoji"
    };
  }
  getClassName() {
    return this.getLatest().__className;
  }
}
function nM(e, t) {
  const n = new kf(e, t).setMode("token");
  return En(n);
}
const fz = J.lazy(() => import("./ImageComponent-DdUUwPhi.js"));
function pz(e) {
  const t = e;
  if (t.src.startsWith("file:///"))
    return null;
  const { alt: n, src: r, width: i, height: a } = t;
  return { node: yb({ altText: n, height: a, src: r, width: i }) };
}
class V0 extends Ha {
  constructor(n, r, i, a, l, s, c, d, o, u, h, f) {
    super(o);
    Ne(this, "__src");
    Ne(this, "__altText");
    Ne(this, "__width");
    Ne(this, "__height");
    Ne(this, "__maxWidth");
    Ne(this, "__showCaption");
    Ne(this, "__caption");
    // Captions cannot yet be used within editor cells
    Ne(this, "__captionsEnabled");
    Ne(this, "__isAbsolute");
    Ne(this, "__x");
    Ne(this, "__y");
    this.__src = n, this.__altText = r, this.__maxWidth = i, this.__width = a || "inherit", this.__height = l || "inherit", this.__showCaption = s || !1, this.__caption = c || wf(), this.__captionsEnabled = d || d === void 0, this.__isAbsolute = u || !1, this.__x = h || 0, this.__y = f || 0;
  }
  static getType() {
    return "image";
  }
  static clone(n) {
    return new V0(
      n.__src,
      n.__altText,
      n.__maxWidth,
      n.__width,
      n.__height,
      n.__showCaption,
      n.__caption,
      n.__captionsEnabled,
      n.__key,
      n.__isAbsolute,
      n.__x,
      n.__y
    );
  }
  static importJSON(n) {
    const {
      altText: r,
      height: i,
      width: a,
      maxWidth: l,
      caption: s,
      src: c,
      showCaption: d,
      isAbsolute: o,
      xOffset: u,
      yOffset: h
    } = n, f = yb({
      altText: r,
      height: i,
      maxWidth: l,
      showCaption: d,
      src: c,
      width: a,
      isAbsolute: o,
      xOffset: u,
      yOffset: h
    }), p = f.__caption, g = p.parseEditorState(s.editorState);
    return g.isEmpty() || p.setEditorState(g), f;
  }
  exportDOM() {
    const n = document.createElement("img");
    return n.setAttribute("src", this.__src), n.setAttribute("alt", this.__altText), n.setAttribute("width", this.__width.toString()), n.setAttribute("height", this.__height.toString()), n.setAttribute("style", "max-width: 100%; object-fit: contain;"), { element: n };
  }
  static importDOM() {
    return {
      img: () => ({
        conversion: pz,
        priority: 0
      })
    };
  }
  exportJSON() {
    return {
      altText: this.getAltText(),
      caption: this.__caption.toJSON(),
      height: this.__height === "inherit" ? 0 : this.__height,
      maxWidth: this.__maxWidth,
      showCaption: this.__showCaption,
      src: this.getSrc(),
      type: "image",
      version: 1,
      width: this.__width === "inherit" ? 0 : this.__width,
      isAbsolute: this.__isAbsolute,
      xOffset: this.__x,
      yOffset: this.__y
    };
  }
  setWidthAndHeight(n, r) {
    const i = this.getWritable();
    i.__width = n, i.__height = r;
  }
  setShowCaption(n) {
    const r = this.getWritable();
    r.__showCaption = n;
  }
  setAbsolute(n) {
    const r = this.getWritable();
    r.__isAbsolute = n;
  }
  setPosition(n, r) {
    const i = this.getWritable();
    i.__x = n, i.__y = r, pn(null);
  }
  // View
  createDOM(n) {
    const r = document.createElement("span"), a = n.theme.image;
    return a !== void 0 && (r.className = a), r;
  }
  updateDOM() {
    return !1;
  }
  getSrc() {
    return this.__src;
  }
  getAltText() {
    return this.__altText;
  }
  decorate() {
    return /* @__PURE__ */ m(td, { fallback: null, children: /* @__PURE__ */ m(
      fz,
      {
        src: this.__src,
        altText: this.__altText,
        width: this.__width,
        height: this.__height,
        maxWidth: this.__maxWidth,
        nodeKey: this.getKey(),
        showCaption: this.__showCaption,
        caption: this.__caption,
        captionsEnabled: this.__captionsEnabled,
        resizable: !0,
        isAbsolute: this.__isAbsolute,
        xOffset: this.__x,
        yOffset: this.__y
      }
    ) });
  }
}
function yb({
  altText: e,
  height: t,
  maxWidth: n = 500,
  captionsEnabled: r,
  src: i,
  width: a,
  showCaption: l,
  caption: s,
  key: c,
  xOffset: d,
  yOffset: o,
  isAbsolute: u
}) {
  return En(
    new V0(
      i,
      e,
      n,
      a,
      t,
      l,
      s,
      r,
      c,
      u,
      d,
      o
    )
  );
}
function mz(e) {
  return e instanceof V0;
}
class c0 extends aa {
  static getType() {
    return "keyword";
  }
  static clone(t) {
    return new c0(t.__text, t.__key);
  }
  static importJSON(t) {
    const n = rM(t.text);
    return n.setFormat(t.format), n.setDetail(t.detail), n.setMode(t.mode), n.setStyle(t.style), n;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "keyword",
      version: 1
    };
  }
  createDOM(t) {
    const n = super.createDOM(t);
    return n.style.cursor = "default", n.className = "keyword", n;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
  isTextEntity() {
    return !0;
  }
}
function rM(e) {
  return new c0(e);
}
let Ag = class extends Ha {
  constructor(t, n) {
    super(n), this.__format = t || "";
  }
  exportJSON() {
    return { format: this.__format || "", type: "decorator-block", version: 1 };
  }
  canIndent() {
    return !1;
  }
  createDOM() {
    return document.createElement("div");
  }
  updateDOM() {
    return !1;
  }
  setFormat(t) {
    this.getWritable().__format = t;
  }
  isInline() {
    return !1;
  }
};
function _4(e) {
  return e instanceof Ag;
}
function wb({ children: e, format: t, nodeKey: n, className: r }) {
  const [i] = Fe(), [a, l, s] = sb(n), c = de(null), d = he((o) => {
    const u = se();
    return a && Xn(u) && (o.preventDefault(), i.update(() => {
      u.getNodes().forEach((h) => {
        Ft(h) && h.remove();
      });
    })), !1;
  }, [i, a]);
  return Y(() => Pt(i.registerCommand(il, (o) => {
    if (a) {
      const u = se();
      if (Xn(u)) {
        const h = Rt(n);
        _4(h) && h.setFormat(o);
      } else if (ie(u)) {
        const h = u.getNodes();
        for (const f of h) _4(f) ? f.setFormat(o) : Cg(f).setFormat(o);
      }
      return !0;
    }
    return !1;
  }, ot), i.registerCommand(L0, (o) => o.target === c.current && (o.preventDefault(), o.shiftKey || s(), l(!a), !0), ot), i.registerCommand(O0, d, ot), i.registerCommand(P0, d, ot)), [s, i, a, n, d, l]), m("div", { className: [r.base, a ? r.focus : null].filter(Boolean).join(" "), ref: c, style: { textAlign: t || void 0 }, children: e });
}
function gz({
  className: e,
  format: t,
  nodeKey: n,
  documentID: r
}) {
  return /* @__PURE__ */ m(
    wb,
    {
      className: e,
      format: t,
      nodeKey: n,
      children: /* @__PURE__ */ m(
        "iframe",
        {
          width: "560",
          height: "315",
          src: `https://www.figma.com/embed?embed_host=lexical&url=        https://www.figma.com/file/${r}`,
          allowFullScreen: !0
        }
      )
    }
  );
}
class Cf extends Ag {
  constructor(n, r, i) {
    super(r, i);
    Ne(this, "__id");
    this.__id = n;
  }
  static getType() {
    return "figma";
  }
  static clone(n) {
    return new Cf(n.__id, n.__format, n.__key);
  }
  static importJSON(n) {
    const r = iM(n.documentID);
    return r.setFormat(n.format), r;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      documentID: this.__id,
      type: "figma",
      version: 1
    };
  }
  updateDOM() {
    return !1;
  }
  getId() {
    return this.__id;
  }
  getTextContent() {
    return `https://www.figma.com/file/${this.__id}`;
  }
  decorate(n, r) {
    const i = r.theme.embedBlock || {}, a = {
      base: i.base || "",
      focus: i.focus || ""
    };
    return /* @__PURE__ */ m(
      gz,
      {
        className: a,
        format: this.__format,
        nodeKey: this.getKey(),
        documentID: this.__id
      }
    );
  }
}
function iM(e) {
  return new Cf(e);
}
const bz = "https://platform.twitter.com/widgets.js";
function Uz(e) {
  const t = e.getAttribute("data-lexical-tweet-id");
  return t ? { node: xb(t) } : null;
}
let Ov = !0;
function vz({
  className: e,
  format: t,
  loadingComponent: n,
  nodeKey: r,
  onError: i,
  onLoad: a,
  tweetID: l
}) {
  const s = de(null), c = de(""), [d, o] = Q(!1), u = he(async () => {
    try {
      await window.twttr.widgets.createTweet(l, s.current), o(!1), Ov = !1, a && a();
    } catch (h) {
      i && i(String(h));
    }
  }, [i, a, l]);
  return Y(() => {
    var h;
    if (l !== c.current) {
      if (o(!0), Ov) {
        const f = document.createElement("script");
        f.src = bz, f.async = !0, (h = document.body) == null || h.appendChild(f), f.onload = u, i && (f.onerror = i);
      } else
        u();
      c && (c.current = l);
    }
  }, [u, i, l]), /* @__PURE__ */ D(
    wb,
    {
      className: e,
      format: t,
      nodeKey: r,
      children: [
        d ? n : null,
        /* @__PURE__ */ m(
          "div",
          {
            style: { display: "inline-block", width: "550px" },
            ref: s
          }
        )
      ]
    }
  );
}
class Mf extends Ag {
  constructor(n, r, i) {
    super(r, i);
    Ne(this, "__id");
    this.__id = n;
  }
  static getType() {
    return "tweet";
  }
  static clone(n) {
    return new Mf(n.__id, n.__format, n.__key);
  }
  static importJSON(n) {
    const r = xb(n.id);
    return r.setFormat(n.format), r;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      id: this.getId(),
      type: "tweet",
      version: 1
    };
  }
  static importDOM() {
    return {
      div: (n) => n.hasAttribute("data-lexical-tweet-id") ? {
        conversion: Uz,
        priority: 2
      } : null
    };
  }
  exportDOM() {
    const n = document.createElement("div");
    n.setAttribute("data-lexical-tweet-id", this.__id);
    const r = document.createTextNode(this.getTextContent());
    return n.append(r), { element: n };
  }
  getId() {
    return this.__id;
  }
  getTextContent(n, r) {
    return `https://x.com/i/web/status/${this.__id}`;
  }
  decorate(n, r) {
    const i = r.theme.embedBlock || {}, a = {
      base: i.base || "",
      focus: i.focus || ""
    };
    return /* @__PURE__ */ m(
      vz,
      {
        className: a,
        format: this.__format,
        loadingComponent: "Loading...",
        nodeKey: this.getKey(),
        tweetID: this.__id
      }
    );
  }
}
function xb(e) {
  return new Mf(e);
}
function yz({
  className: e,
  format: t,
  nodeKey: n,
  videoID: r
}) {
  return /* @__PURE__ */ m(
    wb,
    {
      className: e,
      format: t,
      nodeKey: n,
      children: /* @__PURE__ */ m(
        "iframe",
        {
          width: "560",
          height: "315",
          src: `https://www.youtube-nocookie.com/embed/${r}`,
          frameBorder: "0",
          allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",
          allowFullScreen: !0,
          title: "YouTube video"
        }
      )
    }
  );
}
function wz(e) {
  const t = e.getAttribute("data-lexical-youtube");
  return t ? { node: Eb(t) } : null;
}
class Tf extends Ag {
  constructor(n, r, i) {
    super(r, i);
    Ne(this, "__id");
    this.__id = n;
  }
  static getType() {
    return "youtube";
  }
  static clone(n) {
    return new Tf(n.__id, n.__format, n.__key);
  }
  static importJSON(n) {
    const r = Eb(n.videoID);
    return r.setFormat(n.format), r;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "youtube",
      version: 1,
      videoID: this.__id
    };
  }
  exportDOM() {
    const n = document.createElement("iframe");
    return n.setAttribute("data-lexical-youtube", this.__id), n.setAttribute("width", "560"), n.setAttribute("height", "315"), n.setAttribute(
      "src",
      `https://www.youtube-nocookie.com/embed/${this.__id}`
    ), n.setAttribute("frameborder", "0"), n.setAttribute(
      "allow",
      "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    ), n.setAttribute("allowfullscreen", "true"), n.setAttribute("title", "YouTube video"), { element: n };
  }
  static importDOM() {
    return {
      iframe: (n) => n.hasAttribute("data-lexical-youtube") ? {
        conversion: wz,
        priority: 1
      } : null
    };
  }
  updateDOM() {
    return !1;
  }
  getId() {
    return this.__id;
  }
  getTextContent(n, r) {
    return `https://www.youtube.com/watch?v=${this.__id}`;
  }
  decorate(n, r) {
    const i = r.theme.embedBlock || {}, a = {
      base: i.base || "",
      focus: i.focus || ""
    };
    return /* @__PURE__ */ m(
      yz,
      {
        className: a,
        format: this.__format,
        nodeKey: this.getKey(),
        videoID: this.__id
      }
    );
  }
}
function Eb(e) {
  return new Tf(e);
}
function xz(e) {
  const t = e.open !== void 0 ? e.open : !0;
  return {
    node: Sb(t)
  };
}
class Nc extends tr {
  constructor(n, r) {
    super(r);
    Ne(this, "__open");
    this.__open = n;
  }
  static getType() {
    return "collapsible-container";
  }
  static clone(n) {
    return new Nc(n.__open, n.__key);
  }
  createDOM(n, r) {
    const i = document.createElement("details");
    return i.classList.add("Collapsible__container"), i.open = this.__open, i.addEventListener("toggle", () => {
      r.getEditorState().read(() => this.getOpen()) !== i.open && r.update(() => this.toggleOpen());
    }), i;
  }
  updateDOM(n, r) {
    return n.__open !== this.__open && (r.open = this.__open), !1;
  }
  static importDOM() {
    return {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      details: (n) => ({
        conversion: xz,
        priority: 1
      })
    };
  }
  static importJSON(n) {
    return Sb(n.open);
  }
  exportDOM() {
    const n = document.createElement("details");
    return n.setAttribute("open", this.__open.toString()), { element: n };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      open: this.__open,
      type: "collapsible-container",
      version: 1
    };
  }
  setOpen(n) {
    const r = this.getWritable();
    r.__open = n;
  }
  getOpen() {
    return this.getLatest().__open;
  }
  toggleOpen() {
    this.setOpen(!this.getOpen());
  }
}
function Sb(e) {
  return new Nc(e);
}
function Wl(e) {
  return e instanceof Nc;
}
function Ez(e) {
  return {
    node: _b()
  };
}
class Dc extends tr {
  static getType() {
    return "collapsible-content";
  }
  static clone(t) {
    return new Dc(t.__key);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createDOM(t) {
    const n = document.createElement("div");
    return n.classList.add("Collapsible__content"), n;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  updateDOM(t, n) {
    return !1;
  }
  static importDOM() {
    return {
      div: (t) => t.hasAttribute("data-lexical-collapsible-content") ? {
        conversion: Ez,
        priority: 2
      } : null
    };
  }
  exportDOM() {
    const t = document.createElement("div");
    return t.setAttribute("data-lexical-collapsible-content", "true"), { element: t };
  }
  static importJSON(t) {
    return _b();
  }
  isShadowRoot() {
    return !0;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "collapsible-content",
      version: 1
    };
  }
}
function _b() {
  return new Dc();
}
function aM(e) {
  return e instanceof Dc;
}
function Sz(e) {
  return {
    node: kb()
  };
}
class Lc extends tr {
  static getType() {
    return "collapsible-title";
  }
  static clone(t) {
    return new Lc(t.__key);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createDOM(t, n) {
    const r = document.createElement("summary");
    return r.classList.add("Collapsible__title"), r;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  updateDOM(t, n) {
    return !1;
  }
  static importDOM() {
    return {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      summary: (t) => ({
        conversion: Sz,
        priority: 1
      })
    };
  }
  static importJSON(t) {
    return kb();
  }
  exportDOM() {
    return { element: document.createElement("summary") };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "collapsible-title",
      version: 1
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  collapseAtStart(t) {
    return this.getParentOrThrow().insertBefore(this), !0;
  }
  insertNewAfter(t, n = !0) {
    const r = this.getParentOrThrow();
    if (!Wl(r))
      throw new Error(
        "CollapsibleTitleNode expects to be child of CollapsibleContainerNode"
      );
    if (r.getOpen()) {
      const i = this.getNextSibling();
      if (!aM(i))
        throw new Error(
          "CollapsibleTitleNode expects to have CollapsibleContentNode sibling"
        );
      const a = i.getFirstChild();
      if (re(a))
        return a;
      {
        const l = He();
        return i.append(l), l;
      }
    } else {
      const i = He();
      return r.insertAfter(i, n), i;
    }
  }
}
function kb() {
  return new Lc();
}
function $v(e) {
  return e instanceof Lc;
}
class Ui {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(t, n, r) {
    this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = t, this.start = n, this.end = r;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(t, n) {
    return n ? !t || !t.loc || !n.loc || t.loc.lexer !== n.loc.lexer ? null : new Ui(t.loc.lexer, t.loc.start, n.loc.end) : t && t.loc;
  }
}
class Vi {
  // don't expand the token
  // used in \noexpand
  constructor(t, n) {
    this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = t, this.loc = n;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(t, n) {
    return new Vi(n, Ui.range(this, t));
  }
}
class be {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(t, n) {
    this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
    var r = "KaTeX parse error: " + t, i, a, l = n && n.loc;
    if (l && l.start <= l.end) {
      var s = l.lexer.input;
      i = l.start, a = l.end, i === s.length ? r += " at end of input: " : r += " at position " + (i + 1) + ": ";
      var c = s.slice(i, a).replace(/[^]/g, "$&̲"), d;
      i > 15 ? d = "…" + s.slice(i - 15, i) : d = s.slice(0, i);
      var o;
      a + 15 < s.length ? o = s.slice(a, a + 15) + "…" : o = s.slice(a), r += d + c + o;
    }
    var u = new Error(r);
    return u.name = "ParseError", u.__proto__ = be.prototype, u.position = i, i != null && a != null && (u.length = a - i), u.rawMessage = t, u;
  }
}
be.prototype.__proto__ = Error.prototype;
var _z = function(t, n) {
  return t.indexOf(n) !== -1;
}, kz = function(t, n) {
  return t === void 0 ? n : t;
}, Cz = /([A-Z])/g, Mz = function(t) {
  return t.replace(Cz, "-$1").toLowerCase();
}, Tz = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
}, Iz = /[&><"']/g;
function Az(e) {
  return String(e).replace(Iz, (t) => Tz[t]);
}
var lM = function e(t) {
  return t.type === "ordgroup" || t.type === "color" ? t.body.length === 1 ? e(t.body[0]) : t : t.type === "font" ? e(t.body) : t;
}, Nz = function(t) {
  var n = lM(t);
  return n.type === "mathord" || n.type === "textord" || n.type === "atom";
}, Dz = function(t) {
  if (!t)
    throw new Error("Expected non-null, but got " + String(t));
  return t;
}, Lz = function(t) {
  var n = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(t);
  return n ? n[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(n[1]) ? null : n[1].toLowerCase() : "_relative";
}, We = {
  contains: _z,
  deflt: kz,
  escape: Az,
  hyphenate: Mz,
  getBaseElem: lM,
  isCharacterBox: Nz,
  protocolFromUrl: Lz
}, sh = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: !0,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (e) => "#" + e
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (e, t) => (t.push(e), t)
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (e) => Math.max(0, e),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: !1
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: 1 / 0,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (e) => Math.max(0, e),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (e) => Math.max(0, e),
    cli: "-e, --max-expand <n>",
    cliProcessor: (e) => e === "Infinity" ? 1 / 0 : parseInt(e)
  },
  globalGroup: {
    type: "boolean",
    cli: !1
  }
};
function Rz(e) {
  if (e.default)
    return e.default;
  var t = e.type, n = Array.isArray(t) ? t[0] : t;
  if (typeof n != "string")
    return n.enum[0];
  switch (n) {
    case "boolean":
      return !1;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
class Cb {
  constructor(t) {
    this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, t = t || {};
    for (var n in sh)
      if (sh.hasOwnProperty(n)) {
        var r = sh[n];
        this[n] = t[n] !== void 0 ? r.processor ? r.processor(t[n]) : t[n] : Rz(r);
      }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(t, n, r) {
    var i = this.strict;
    if (typeof i == "function" && (i = i(t, n, r)), !(!i || i === "ignore")) {
      if (i === !0 || i === "error")
        throw new be("LaTeX-incompatible input and strict mode is set to 'error': " + (n + " [" + t + "]"), r);
      i === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (n + " [" + t + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + n + " [" + t + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(t, n, r) {
    var i = this.strict;
    if (typeof i == "function")
      try {
        i = i(t, n, r);
      } catch {
        i = "error";
      }
    return !i || i === "ignore" ? !1 : i === !0 || i === "error" ? !0 : i === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (n + " [" + t + "]")), !1) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + n + " [" + t + "]")), !1);
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(t) {
    if (t.url && !t.protocol) {
      var n = We.protocolFromUrl(t.url);
      if (n == null)
        return !1;
      t.protocol = n;
    }
    var r = typeof this.trust == "function" ? this.trust(t) : this.trust;
    return !!r;
  }
}
let Ps = class {
  constructor(t, n, r) {
    this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = t, this.size = n, this.cramped = r;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return ll[Pz[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return ll[Oz[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return ll[$z[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return ll[Fz[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return ll[zz[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return ll[Bz[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
};
var Mb = 0, tm = 1, Yd = 2, ss = 3, Lh = 4, Hi = 5, d0 = 6, Vr = 7, ll = [new Ps(Mb, 0, !1), new Ps(tm, 0, !0), new Ps(Yd, 1, !1), new Ps(ss, 1, !0), new Ps(Lh, 2, !1), new Ps(Hi, 2, !0), new Ps(d0, 3, !1), new Ps(Vr, 3, !0)], Pz = [Lh, Hi, Lh, Hi, d0, Vr, d0, Vr], Oz = [Hi, Hi, Hi, Hi, Vr, Vr, Vr, Vr], $z = [Yd, ss, Lh, Hi, d0, Vr, d0, Vr], Fz = [ss, ss, Hi, Hi, Vr, Vr, Vr, Vr], zz = [tm, tm, ss, ss, Hi, Hi, Vr, Vr], Bz = [Mb, tm, Yd, ss, Yd, ss, Yd, ss], Ye = {
  DISPLAY: ll[Mb],
  TEXT: ll[Yd],
  SCRIPT: ll[Lh],
  SCRIPTSCRIPT: ll[d0]
}, k4 = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900–097F)
  // Bengali (0980–09FF)
  // Gurmukhi (0A00–0A7F)
  // Gujarati (0A80–0AFF)
  // Oriya (0B00–0B7F)
  // Tamil (0B80–0BFF)
  // Telugu (0C00–0C7F)
  // Kannada (0C80–0CFF)
  // Malayalam (0D00–0D7F)
  // Sinhala (0D80–0DFF)
  // Thai (0E00–0E7F)
  // Lao (0E80–0EFF)
  // Tibetan (0F00–0FFF)
  // Myanmar (1000–109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function Hz(e) {
  for (var t = 0; t < k4.length; t++)
    for (var n = k4[t], r = 0; r < n.blocks.length; r++) {
      var i = n.blocks[r];
      if (e >= i[0] && e <= i[1])
        return n.name;
    }
  return null;
}
var np = [];
k4.forEach((e) => e.blocks.forEach((t) => np.push(...t)));
function sM(e) {
  for (var t = 0; t < np.length; t += 2)
    if (e >= np[t] && e <= np[t + 1])
      return !0;
  return !1;
}
var pd = 80, Wz = function(t, n) {
  return "M95," + (622 + t + n) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + t / 2.075 + " -" + t + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + t) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + t) + " " + n + "h400000v" + (40 + t) + "h-400000z";
}, Xz = function(t, n) {
  return "M263," + (601 + t + n) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + t / 2.084 + " -" + t + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + t) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + t) + " " + n + "h400000v" + (40 + t) + "h-400000z";
}, Vz = function(t, n) {
  return "M983 " + (10 + t + n) + `
l` + t / 3.13 + " -" + t + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + t) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + t) + " " + n + "h400000v" + (40 + t) + "h-400000z";
}, Gz = function(t, n) {
  return "M424," + (2398 + t + n) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + t / 4.223 + " -" + t + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + t) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + t) + " " + n + `
h400000v` + (40 + t) + "h-400000z";
}, jz = function(t, n) {
  return "M473," + (2713 + t + n) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + t / 5.298 + " -" + t + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + t) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + t) + " " + n + "h400000v" + (40 + t) + "H1017.7z";
}, Kz = function(t) {
  var n = t / 2;
  return "M400000 " + t + " H0 L" + n + " 0 l65 45 L145 " + (t - 80) + " H400000z";
}, Yz = function(t, n, r) {
  var i = r - 54 - n - t;
  return "M702 " + (t + n) + "H400000" + (40 + t) + `
H742v` + i + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + n + "H400000v" + (40 + t) + "H742z";
}, qz = function(t, n, r) {
  n = 1e3 * n;
  var i = "";
  switch (t) {
    case "sqrtMain":
      i = Wz(n, pd);
      break;
    case "sqrtSize1":
      i = Xz(n, pd);
      break;
    case "sqrtSize2":
      i = Vz(n, pd);
      break;
    case "sqrtSize3":
      i = Gz(n, pd);
      break;
    case "sqrtSize4":
      i = jz(n, pd);
      break;
    case "sqrtTall":
      i = Yz(n, pd, r);
  }
  return i;
}, Zz = function(t, n) {
  switch (t) {
    case "⎜":
      return "M291 0 H417 V" + n + " H291z M291 0 H417 V" + n + " H291z";
    case "∣":
      return "M145 0 H188 V" + n + " H145z M145 0 H188 V" + n + " H145z";
    case "∥":
      return "M145 0 H188 V" + n + " H145z M145 0 H188 V" + n + " H145z" + ("M367 0 H410 V" + n + " H367z M367 0 H410 V" + n + " H367z");
    case "⎟":
      return "M457 0 H583 V" + n + " H457z M457 0 H583 V" + n + " H457z";
    case "⎢":
      return "M319 0 H403 V" + n + " H319z M319 0 H403 V" + n + " H319z";
    case "⎥":
      return "M263 0 H347 V" + n + " H263z M263 0 H347 V" + n + " H263z";
    case "⎪":
      return "M384 0 H504 V" + n + " H384z M384 0 H504 V" + n + " H384z";
    case "⏐":
      return "M312 0 H355 V" + n + " H312z M312 0 H355 V" + n + " H312z";
    case "‖":
      return "M257 0 H300 V" + n + " H257z M257 0 H300 V" + n + " H257z" + ("M478 0 H521 V" + n + " H478z M478 0 H521 V" + n + " H478z");
    default:
      return "";
  }
}, Fv = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
  leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
  leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
  leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
  leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
  leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
  leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
  leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
  longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
  midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
  midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
  oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
  oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
  oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
  oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
  rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
  rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
  rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
  rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
  rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
  rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
  rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
  rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
  rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
  righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
  rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
  rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
  twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
  // ditto tilde2, tilde3, & tilde4
  tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
  tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
  tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
  // ditto widehat2, widehat3, & widehat4
  widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  // widecheck paths are all inverted versions of widehat
  widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
  widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
  rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
  shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
  shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
}, Jz = function(t, n) {
  switch (t) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + n + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + n + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + n + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + n + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + n + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -n + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + n + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + n + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -n + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + n + ` v585 h43z
M367 15 v585 v` + n + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -n + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + n + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + n + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + n + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + n + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + n + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + n + ` v602 h84z
M403 1759 V0 H319 V1759 v` + n + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + n + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + n + " v602 h84z";
    case "lparen":
      return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (n + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (n + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
    case "rparen":
      return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (n + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (n + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
class If {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(t) {
    this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = t, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
  }
  hasClass(t) {
    return We.contains(this.classes, t);
  }
  /** Convert the fragment into a node. */
  toNode() {
    for (var t = document.createDocumentFragment(), n = 0; n < this.children.length; n++)
      t.appendChild(this.children[n].toNode());
    return t;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    for (var t = "", n = 0; n < this.children.length; n++)
      t += this.children[n].toMarkup();
    return t;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var t = (n) => n.toText();
    return this.children.map(t).join("");
  }
}
var pl = {
  "AMS-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68889, 0, 0, 0.72222],
    66: [0, 0.68889, 0, 0, 0.66667],
    67: [0, 0.68889, 0, 0, 0.72222],
    68: [0, 0.68889, 0, 0, 0.72222],
    69: [0, 0.68889, 0, 0, 0.66667],
    70: [0, 0.68889, 0, 0, 0.61111],
    71: [0, 0.68889, 0, 0, 0.77778],
    72: [0, 0.68889, 0, 0, 0.77778],
    73: [0, 0.68889, 0, 0, 0.38889],
    74: [0.16667, 0.68889, 0, 0, 0.5],
    75: [0, 0.68889, 0, 0, 0.77778],
    76: [0, 0.68889, 0, 0, 0.66667],
    77: [0, 0.68889, 0, 0, 0.94445],
    78: [0, 0.68889, 0, 0, 0.72222],
    79: [0.16667, 0.68889, 0, 0, 0.77778],
    80: [0, 0.68889, 0, 0, 0.61111],
    81: [0.16667, 0.68889, 0, 0, 0.77778],
    82: [0, 0.68889, 0, 0, 0.72222],
    83: [0, 0.68889, 0, 0, 0.55556],
    84: [0, 0.68889, 0, 0, 0.66667],
    85: [0, 0.68889, 0, 0, 0.72222],
    86: [0, 0.68889, 0, 0, 0.72222],
    87: [0, 0.68889, 0, 0, 1],
    88: [0, 0.68889, 0, 0, 0.72222],
    89: [0, 0.68889, 0, 0, 0.72222],
    90: [0, 0.68889, 0, 0, 0.66667],
    107: [0, 0.68889, 0, 0, 0.55556],
    160: [0, 0, 0, 0, 0.25],
    165: [0, 0.675, 0.025, 0, 0.75],
    174: [0.15559, 0.69224, 0, 0, 0.94666],
    240: [0, 0.68889, 0, 0, 0.55556],
    295: [0, 0.68889, 0, 0, 0.54028],
    710: [0, 0.825, 0, 0, 2.33334],
    732: [0, 0.9, 0, 0, 2.33334],
    770: [0, 0.825, 0, 0, 2.33334],
    771: [0, 0.9, 0, 0, 2.33334],
    989: [0.08167, 0.58167, 0, 0, 0.77778],
    1008: [0, 0.43056, 0.04028, 0, 0.66667],
    8245: [0, 0.54986, 0, 0, 0.275],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8487: [0, 0.68889, 0, 0, 0.72222],
    8498: [0, 0.68889, 0, 0, 0.55556],
    8502: [0, 0.68889, 0, 0, 0.66667],
    8503: [0, 0.68889, 0, 0, 0.44445],
    8504: [0, 0.68889, 0, 0, 0.66667],
    8513: [0, 0.68889, 0, 0, 0.63889],
    8592: [-0.03598, 0.46402, 0, 0, 0.5],
    8594: [-0.03598, 0.46402, 0, 0, 0.5],
    8602: [-0.13313, 0.36687, 0, 0, 1],
    8603: [-0.13313, 0.36687, 0, 0, 1],
    8606: [0.01354, 0.52239, 0, 0, 1],
    8608: [0.01354, 0.52239, 0, 0, 1],
    8610: [0.01354, 0.52239, 0, 0, 1.11111],
    8611: [0.01354, 0.52239, 0, 0, 1.11111],
    8619: [0, 0.54986, 0, 0, 1],
    8620: [0, 0.54986, 0, 0, 1],
    8621: [-0.13313, 0.37788, 0, 0, 1.38889],
    8622: [-0.13313, 0.36687, 0, 0, 1],
    8624: [0, 0.69224, 0, 0, 0.5],
    8625: [0, 0.69224, 0, 0, 0.5],
    8630: [0, 0.43056, 0, 0, 1],
    8631: [0, 0.43056, 0, 0, 1],
    8634: [0.08198, 0.58198, 0, 0, 0.77778],
    8635: [0.08198, 0.58198, 0, 0, 0.77778],
    8638: [0.19444, 0.69224, 0, 0, 0.41667],
    8639: [0.19444, 0.69224, 0, 0, 0.41667],
    8642: [0.19444, 0.69224, 0, 0, 0.41667],
    8643: [0.19444, 0.69224, 0, 0, 0.41667],
    8644: [0.1808, 0.675, 0, 0, 1],
    8646: [0.1808, 0.675, 0, 0, 1],
    8647: [0.1808, 0.675, 0, 0, 1],
    8648: [0.19444, 0.69224, 0, 0, 0.83334],
    8649: [0.1808, 0.675, 0, 0, 1],
    8650: [0.19444, 0.69224, 0, 0, 0.83334],
    8651: [0.01354, 0.52239, 0, 0, 1],
    8652: [0.01354, 0.52239, 0, 0, 1],
    8653: [-0.13313, 0.36687, 0, 0, 1],
    8654: [-0.13313, 0.36687, 0, 0, 1],
    8655: [-0.13313, 0.36687, 0, 0, 1],
    8666: [0.13667, 0.63667, 0, 0, 1],
    8667: [0.13667, 0.63667, 0, 0, 1],
    8669: [-0.13313, 0.37788, 0, 0, 1],
    8672: [-0.064, 0.437, 0, 0, 1.334],
    8674: [-0.064, 0.437, 0, 0, 1.334],
    8705: [0, 0.825, 0, 0, 0.5],
    8708: [0, 0.68889, 0, 0, 0.55556],
    8709: [0.08167, 0.58167, 0, 0, 0.77778],
    8717: [0, 0.43056, 0, 0, 0.42917],
    8722: [-0.03598, 0.46402, 0, 0, 0.5],
    8724: [0.08198, 0.69224, 0, 0, 0.77778],
    8726: [0.08167, 0.58167, 0, 0, 0.77778],
    8733: [0, 0.69224, 0, 0, 0.77778],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8737: [0, 0.69224, 0, 0, 0.72222],
    8738: [0.03517, 0.52239, 0, 0, 0.72222],
    8739: [0.08167, 0.58167, 0, 0, 0.22222],
    8740: [0.25142, 0.74111, 0, 0, 0.27778],
    8741: [0.08167, 0.58167, 0, 0, 0.38889],
    8742: [0.25142, 0.74111, 0, 0, 0.5],
    8756: [0, 0.69224, 0, 0, 0.66667],
    8757: [0, 0.69224, 0, 0, 0.66667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8765: [-0.13313, 0.37788, 0, 0, 0.77778],
    8769: [-0.13313, 0.36687, 0, 0, 0.77778],
    8770: [-0.03625, 0.46375, 0, 0, 0.77778],
    8774: [0.30274, 0.79383, 0, 0, 0.77778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8778: [0.08167, 0.58167, 0, 0, 0.77778],
    8782: [0.06062, 0.54986, 0, 0, 0.77778],
    8783: [0.06062, 0.54986, 0, 0, 0.77778],
    8785: [0.08198, 0.58198, 0, 0, 0.77778],
    8786: [0.08198, 0.58198, 0, 0, 0.77778],
    8787: [0.08198, 0.58198, 0, 0, 0.77778],
    8790: [0, 0.69224, 0, 0, 0.77778],
    8791: [0.22958, 0.72958, 0, 0, 0.77778],
    8796: [0.08198, 0.91667, 0, 0, 0.77778],
    8806: [0.25583, 0.75583, 0, 0, 0.77778],
    8807: [0.25583, 0.75583, 0, 0, 0.77778],
    8808: [0.25142, 0.75726, 0, 0, 0.77778],
    8809: [0.25142, 0.75726, 0, 0, 0.77778],
    8812: [0.25583, 0.75583, 0, 0, 0.5],
    8814: [0.20576, 0.70576, 0, 0, 0.77778],
    8815: [0.20576, 0.70576, 0, 0, 0.77778],
    8816: [0.30274, 0.79383, 0, 0, 0.77778],
    8817: [0.30274, 0.79383, 0, 0, 0.77778],
    8818: [0.22958, 0.72958, 0, 0, 0.77778],
    8819: [0.22958, 0.72958, 0, 0, 0.77778],
    8822: [0.1808, 0.675, 0, 0, 0.77778],
    8823: [0.1808, 0.675, 0, 0, 0.77778],
    8828: [0.13667, 0.63667, 0, 0, 0.77778],
    8829: [0.13667, 0.63667, 0, 0, 0.77778],
    8830: [0.22958, 0.72958, 0, 0, 0.77778],
    8831: [0.22958, 0.72958, 0, 0, 0.77778],
    8832: [0.20576, 0.70576, 0, 0, 0.77778],
    8833: [0.20576, 0.70576, 0, 0, 0.77778],
    8840: [0.30274, 0.79383, 0, 0, 0.77778],
    8841: [0.30274, 0.79383, 0, 0, 0.77778],
    8842: [0.13597, 0.63597, 0, 0, 0.77778],
    8843: [0.13597, 0.63597, 0, 0, 0.77778],
    8847: [0.03517, 0.54986, 0, 0, 0.77778],
    8848: [0.03517, 0.54986, 0, 0, 0.77778],
    8858: [0.08198, 0.58198, 0, 0, 0.77778],
    8859: [0.08198, 0.58198, 0, 0, 0.77778],
    8861: [0.08198, 0.58198, 0, 0, 0.77778],
    8862: [0, 0.675, 0, 0, 0.77778],
    8863: [0, 0.675, 0, 0, 0.77778],
    8864: [0, 0.675, 0, 0, 0.77778],
    8865: [0, 0.675, 0, 0, 0.77778],
    8872: [0, 0.69224, 0, 0, 0.61111],
    8873: [0, 0.69224, 0, 0, 0.72222],
    8874: [0, 0.69224, 0, 0, 0.88889],
    8876: [0, 0.68889, 0, 0, 0.61111],
    8877: [0, 0.68889, 0, 0, 0.61111],
    8878: [0, 0.68889, 0, 0, 0.72222],
    8879: [0, 0.68889, 0, 0, 0.72222],
    8882: [0.03517, 0.54986, 0, 0, 0.77778],
    8883: [0.03517, 0.54986, 0, 0, 0.77778],
    8884: [0.13667, 0.63667, 0, 0, 0.77778],
    8885: [0.13667, 0.63667, 0, 0, 0.77778],
    8888: [0, 0.54986, 0, 0, 1.11111],
    8890: [0.19444, 0.43056, 0, 0, 0.55556],
    8891: [0.19444, 0.69224, 0, 0, 0.61111],
    8892: [0.19444, 0.69224, 0, 0, 0.61111],
    8901: [0, 0.54986, 0, 0, 0.27778],
    8903: [0.08167, 0.58167, 0, 0, 0.77778],
    8905: [0.08167, 0.58167, 0, 0, 0.77778],
    8906: [0.08167, 0.58167, 0, 0, 0.77778],
    8907: [0, 0.69224, 0, 0, 0.77778],
    8908: [0, 0.69224, 0, 0, 0.77778],
    8909: [-0.03598, 0.46402, 0, 0, 0.77778],
    8910: [0, 0.54986, 0, 0, 0.76042],
    8911: [0, 0.54986, 0, 0, 0.76042],
    8912: [0.03517, 0.54986, 0, 0, 0.77778],
    8913: [0.03517, 0.54986, 0, 0, 0.77778],
    8914: [0, 0.54986, 0, 0, 0.66667],
    8915: [0, 0.54986, 0, 0, 0.66667],
    8916: [0, 0.69224, 0, 0, 0.66667],
    8918: [0.0391, 0.5391, 0, 0, 0.77778],
    8919: [0.0391, 0.5391, 0, 0, 0.77778],
    8920: [0.03517, 0.54986, 0, 0, 1.33334],
    8921: [0.03517, 0.54986, 0, 0, 1.33334],
    8922: [0.38569, 0.88569, 0, 0, 0.77778],
    8923: [0.38569, 0.88569, 0, 0, 0.77778],
    8926: [0.13667, 0.63667, 0, 0, 0.77778],
    8927: [0.13667, 0.63667, 0, 0, 0.77778],
    8928: [0.30274, 0.79383, 0, 0, 0.77778],
    8929: [0.30274, 0.79383, 0, 0, 0.77778],
    8934: [0.23222, 0.74111, 0, 0, 0.77778],
    8935: [0.23222, 0.74111, 0, 0, 0.77778],
    8936: [0.23222, 0.74111, 0, 0, 0.77778],
    8937: [0.23222, 0.74111, 0, 0, 0.77778],
    8938: [0.20576, 0.70576, 0, 0, 0.77778],
    8939: [0.20576, 0.70576, 0, 0, 0.77778],
    8940: [0.30274, 0.79383, 0, 0, 0.77778],
    8941: [0.30274, 0.79383, 0, 0, 0.77778],
    8994: [0.19444, 0.69224, 0, 0, 0.77778],
    8995: [0.19444, 0.69224, 0, 0, 0.77778],
    9416: [0.15559, 0.69224, 0, 0, 0.90222],
    9484: [0, 0.69224, 0, 0, 0.5],
    9488: [0, 0.69224, 0, 0, 0.5],
    9492: [0, 0.37788, 0, 0, 0.5],
    9496: [0, 0.37788, 0, 0, 0.5],
    9585: [0.19444, 0.68889, 0, 0, 0.88889],
    9586: [0.19444, 0.74111, 0, 0, 0.88889],
    9632: [0, 0.675, 0, 0, 0.77778],
    9633: [0, 0.675, 0, 0, 0.77778],
    9650: [0, 0.54986, 0, 0, 0.72222],
    9651: [0, 0.54986, 0, 0, 0.72222],
    9654: [0.03517, 0.54986, 0, 0, 0.77778],
    9660: [0, 0.54986, 0, 0, 0.72222],
    9661: [0, 0.54986, 0, 0, 0.72222],
    9664: [0.03517, 0.54986, 0, 0, 0.77778],
    9674: [0.11111, 0.69224, 0, 0, 0.66667],
    9733: [0.19444, 0.69224, 0, 0, 0.94445],
    10003: [0, 0.69224, 0, 0, 0.83334],
    10016: [0, 0.69224, 0, 0, 0.83334],
    10731: [0.11111, 0.69224, 0, 0, 0.66667],
    10846: [0.19444, 0.75583, 0, 0, 0.61111],
    10877: [0.13667, 0.63667, 0, 0, 0.77778],
    10878: [0.13667, 0.63667, 0, 0, 0.77778],
    10885: [0.25583, 0.75583, 0, 0, 0.77778],
    10886: [0.25583, 0.75583, 0, 0, 0.77778],
    10887: [0.13597, 0.63597, 0, 0, 0.77778],
    10888: [0.13597, 0.63597, 0, 0, 0.77778],
    10889: [0.26167, 0.75726, 0, 0, 0.77778],
    10890: [0.26167, 0.75726, 0, 0, 0.77778],
    10891: [0.48256, 0.98256, 0, 0, 0.77778],
    10892: [0.48256, 0.98256, 0, 0, 0.77778],
    10901: [0.13667, 0.63667, 0, 0, 0.77778],
    10902: [0.13667, 0.63667, 0, 0, 0.77778],
    10933: [0.25142, 0.75726, 0, 0, 0.77778],
    10934: [0.25142, 0.75726, 0, 0, 0.77778],
    10935: [0.26167, 0.75726, 0, 0, 0.77778],
    10936: [0.26167, 0.75726, 0, 0, 0.77778],
    10937: [0.26167, 0.75726, 0, 0, 0.77778],
    10938: [0.26167, 0.75726, 0, 0, 0.77778],
    10949: [0.25583, 0.75583, 0, 0, 0.77778],
    10950: [0.25583, 0.75583, 0, 0, 0.77778],
    10955: [0.28481, 0.79383, 0, 0, 0.77778],
    10956: [0.28481, 0.79383, 0, 0, 0.77778],
    57350: [0.08167, 0.58167, 0, 0, 0.22222],
    57351: [0.08167, 0.58167, 0, 0, 0.38889],
    57352: [0.08167, 0.58167, 0, 0, 0.77778],
    57353: [0, 0.43056, 0.04028, 0, 0.66667],
    57356: [0.25142, 0.75726, 0, 0, 0.77778],
    57357: [0.25142, 0.75726, 0, 0, 0.77778],
    57358: [0.41951, 0.91951, 0, 0, 0.77778],
    57359: [0.30274, 0.79383, 0, 0, 0.77778],
    57360: [0.30274, 0.79383, 0, 0, 0.77778],
    57361: [0.41951, 0.91951, 0, 0, 0.77778],
    57366: [0.25142, 0.75726, 0, 0, 0.77778],
    57367: [0.25142, 0.75726, 0, 0, 0.77778],
    57368: [0.25142, 0.75726, 0, 0, 0.77778],
    57369: [0.25142, 0.75726, 0, 0, 0.77778],
    57370: [0.13597, 0.63597, 0, 0, 0.77778],
    57371: [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68333, 0, 0.19445, 0.79847],
    66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
    67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
    68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
    69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
    70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
    71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    72: [0, 0.68333, 965e-5, 0.11111, 0.84452],
    73: [0, 0.68333, 0.07382, 0, 0.54452],
    74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
    76: [0, 0.68333, 0, 0.13889, 0.68972],
    77: [0, 0.68333, 0, 0.13889, 1.2009],
    78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
    79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
    80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
    81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
    82: [0, 0.68333, 0, 0.08334, 0.8475],
    83: [0, 0.68333, 0.075, 0.13889, 0.60556],
    84: [0, 0.68333, 0.25417, 0, 0.54464],
    85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
    86: [0, 0.68333, 0.08222, 0, 0.61278],
    87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
    88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
    89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
    160: [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69141, 0, 0, 0.29574],
    34: [0, 0.69141, 0, 0, 0.21471],
    38: [0, 0.69141, 0, 0, 0.73786],
    39: [0, 0.69141, 0, 0, 0.21201],
    40: [0.24982, 0.74947, 0, 0, 0.38865],
    41: [0.24982, 0.74947, 0, 0, 0.38865],
    42: [0, 0.62119, 0, 0, 0.27764],
    43: [0.08319, 0.58283, 0, 0, 0.75623],
    44: [0, 0.10803, 0, 0, 0.27764],
    45: [0.08319, 0.58283, 0, 0, 0.75623],
    46: [0, 0.10803, 0, 0, 0.27764],
    47: [0.24982, 0.74947, 0, 0, 0.50181],
    48: [0, 0.47534, 0, 0, 0.50181],
    49: [0, 0.47534, 0, 0, 0.50181],
    50: [0, 0.47534, 0, 0, 0.50181],
    51: [0.18906, 0.47534, 0, 0, 0.50181],
    52: [0.18906, 0.47534, 0, 0, 0.50181],
    53: [0.18906, 0.47534, 0, 0, 0.50181],
    54: [0, 0.69141, 0, 0, 0.50181],
    55: [0.18906, 0.47534, 0, 0, 0.50181],
    56: [0, 0.69141, 0, 0, 0.50181],
    57: [0.18906, 0.47534, 0, 0, 0.50181],
    58: [0, 0.47534, 0, 0, 0.21606],
    59: [0.12604, 0.47534, 0, 0, 0.21606],
    61: [-0.13099, 0.36866, 0, 0, 0.75623],
    63: [0, 0.69141, 0, 0, 0.36245],
    65: [0, 0.69141, 0, 0, 0.7176],
    66: [0, 0.69141, 0, 0, 0.88397],
    67: [0, 0.69141, 0, 0, 0.61254],
    68: [0, 0.69141, 0, 0, 0.83158],
    69: [0, 0.69141, 0, 0, 0.66278],
    70: [0.12604, 0.69141, 0, 0, 0.61119],
    71: [0, 0.69141, 0, 0, 0.78539],
    72: [0.06302, 0.69141, 0, 0, 0.7203],
    73: [0, 0.69141, 0, 0, 0.55448],
    74: [0.12604, 0.69141, 0, 0, 0.55231],
    75: [0, 0.69141, 0, 0, 0.66845],
    76: [0, 0.69141, 0, 0, 0.66602],
    77: [0, 0.69141, 0, 0, 1.04953],
    78: [0, 0.69141, 0, 0, 0.83212],
    79: [0, 0.69141, 0, 0, 0.82699],
    80: [0.18906, 0.69141, 0, 0, 0.82753],
    81: [0.03781, 0.69141, 0, 0, 0.82699],
    82: [0, 0.69141, 0, 0, 0.82807],
    83: [0, 0.69141, 0, 0, 0.82861],
    84: [0, 0.69141, 0, 0, 0.66899],
    85: [0, 0.69141, 0, 0, 0.64576],
    86: [0, 0.69141, 0, 0, 0.83131],
    87: [0, 0.69141, 0, 0, 1.04602],
    88: [0, 0.69141, 0, 0, 0.71922],
    89: [0.18906, 0.69141, 0, 0, 0.83293],
    90: [0.12604, 0.69141, 0, 0, 0.60201],
    91: [0.24982, 0.74947, 0, 0, 0.27764],
    93: [0.24982, 0.74947, 0, 0, 0.27764],
    94: [0, 0.69141, 0, 0, 0.49965],
    97: [0, 0.47534, 0, 0, 0.50046],
    98: [0, 0.69141, 0, 0, 0.51315],
    99: [0, 0.47534, 0, 0, 0.38946],
    100: [0, 0.62119, 0, 0, 0.49857],
    101: [0, 0.47534, 0, 0, 0.40053],
    102: [0.18906, 0.69141, 0, 0, 0.32626],
    103: [0.18906, 0.47534, 0, 0, 0.5037],
    104: [0.18906, 0.69141, 0, 0, 0.52126],
    105: [0, 0.69141, 0, 0, 0.27899],
    106: [0, 0.69141, 0, 0, 0.28088],
    107: [0, 0.69141, 0, 0, 0.38946],
    108: [0, 0.69141, 0, 0, 0.27953],
    109: [0, 0.47534, 0, 0, 0.76676],
    110: [0, 0.47534, 0, 0, 0.52666],
    111: [0, 0.47534, 0, 0, 0.48885],
    112: [0.18906, 0.52396, 0, 0, 0.50046],
    113: [0.18906, 0.47534, 0, 0, 0.48912],
    114: [0, 0.47534, 0, 0, 0.38919],
    115: [0, 0.47534, 0, 0, 0.44266],
    116: [0, 0.62119, 0, 0, 0.33301],
    117: [0, 0.47534, 0, 0, 0.5172],
    118: [0, 0.52396, 0, 0, 0.5118],
    119: [0, 0.52396, 0, 0, 0.77351],
    120: [0.18906, 0.47534, 0, 0, 0.38865],
    121: [0.18906, 0.47534, 0, 0, 0.49884],
    122: [0.18906, 0.47534, 0, 0, 0.39054],
    160: [0, 0, 0, 0, 0.25],
    8216: [0, 0.69141, 0, 0, 0.21471],
    8217: [0, 0.69141, 0, 0, 0.21471],
    58112: [0, 0.62119, 0, 0, 0.49749],
    58113: [0, 0.62119, 0, 0, 0.4983],
    58114: [0.18906, 0.69141, 0, 0, 0.33328],
    58115: [0.18906, 0.69141, 0, 0, 0.32923],
    58116: [0.18906, 0.47534, 0, 0, 0.50343],
    58117: [0, 0.69141, 0, 0, 0.33301],
    58118: [0, 0.62119, 0, 0, 0.33409],
    58119: [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.35],
    34: [0, 0.69444, 0, 0, 0.60278],
    35: [0.19444, 0.69444, 0, 0, 0.95833],
    36: [0.05556, 0.75, 0, 0, 0.575],
    37: [0.05556, 0.75, 0, 0, 0.95833],
    38: [0, 0.69444, 0, 0, 0.89444],
    39: [0, 0.69444, 0, 0, 0.31944],
    40: [0.25, 0.75, 0, 0, 0.44722],
    41: [0.25, 0.75, 0, 0, 0.44722],
    42: [0, 0.75, 0, 0, 0.575],
    43: [0.13333, 0.63333, 0, 0, 0.89444],
    44: [0.19444, 0.15556, 0, 0, 0.31944],
    45: [0, 0.44444, 0, 0, 0.38333],
    46: [0, 0.15556, 0, 0, 0.31944],
    47: [0.25, 0.75, 0, 0, 0.575],
    48: [0, 0.64444, 0, 0, 0.575],
    49: [0, 0.64444, 0, 0, 0.575],
    50: [0, 0.64444, 0, 0, 0.575],
    51: [0, 0.64444, 0, 0, 0.575],
    52: [0, 0.64444, 0, 0, 0.575],
    53: [0, 0.64444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0, 0.64444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0, 0.64444, 0, 0, 0.575],
    58: [0, 0.44444, 0, 0, 0.31944],
    59: [0.19444, 0.44444, 0, 0, 0.31944],
    60: [0.08556, 0.58556, 0, 0, 0.89444],
    61: [-0.10889, 0.39111, 0, 0, 0.89444],
    62: [0.08556, 0.58556, 0, 0, 0.89444],
    63: [0, 0.69444, 0, 0, 0.54305],
    64: [0, 0.69444, 0, 0, 0.89444],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0, 0, 0.81805],
    67: [0, 0.68611, 0, 0, 0.83055],
    68: [0, 0.68611, 0, 0, 0.88194],
    69: [0, 0.68611, 0, 0, 0.75555],
    70: [0, 0.68611, 0, 0, 0.72361],
    71: [0, 0.68611, 0, 0, 0.90416],
    72: [0, 0.68611, 0, 0, 0.9],
    73: [0, 0.68611, 0, 0, 0.43611],
    74: [0, 0.68611, 0, 0, 0.59444],
    75: [0, 0.68611, 0, 0, 0.90138],
    76: [0, 0.68611, 0, 0, 0.69166],
    77: [0, 0.68611, 0, 0, 1.09166],
    78: [0, 0.68611, 0, 0, 0.9],
    79: [0, 0.68611, 0, 0, 0.86388],
    80: [0, 0.68611, 0, 0, 0.78611],
    81: [0.19444, 0.68611, 0, 0, 0.86388],
    82: [0, 0.68611, 0, 0, 0.8625],
    83: [0, 0.68611, 0, 0, 0.63889],
    84: [0, 0.68611, 0, 0, 0.8],
    85: [0, 0.68611, 0, 0, 0.88472],
    86: [0, 0.68611, 0.01597, 0, 0.86944],
    87: [0, 0.68611, 0.01597, 0, 1.18888],
    88: [0, 0.68611, 0, 0, 0.86944],
    89: [0, 0.68611, 0.02875, 0, 0.86944],
    90: [0, 0.68611, 0, 0, 0.70277],
    91: [0.25, 0.75, 0, 0, 0.31944],
    92: [0.25, 0.75, 0, 0, 0.575],
    93: [0.25, 0.75, 0, 0, 0.31944],
    94: [0, 0.69444, 0, 0, 0.575],
    95: [0.31, 0.13444, 0.03194, 0, 0.575],
    97: [0, 0.44444, 0, 0, 0.55902],
    98: [0, 0.69444, 0, 0, 0.63889],
    99: [0, 0.44444, 0, 0, 0.51111],
    100: [0, 0.69444, 0, 0, 0.63889],
    101: [0, 0.44444, 0, 0, 0.52708],
    102: [0, 0.69444, 0.10903, 0, 0.35139],
    103: [0.19444, 0.44444, 0.01597, 0, 0.575],
    104: [0, 0.69444, 0, 0, 0.63889],
    105: [0, 0.69444, 0, 0, 0.31944],
    106: [0.19444, 0.69444, 0, 0, 0.35139],
    107: [0, 0.69444, 0, 0, 0.60694],
    108: [0, 0.69444, 0, 0, 0.31944],
    109: [0, 0.44444, 0, 0, 0.95833],
    110: [0, 0.44444, 0, 0, 0.63889],
    111: [0, 0.44444, 0, 0, 0.575],
    112: [0.19444, 0.44444, 0, 0, 0.63889],
    113: [0.19444, 0.44444, 0, 0, 0.60694],
    114: [0, 0.44444, 0, 0, 0.47361],
    115: [0, 0.44444, 0, 0, 0.45361],
    116: [0, 0.63492, 0, 0, 0.44722],
    117: [0, 0.44444, 0, 0, 0.63889],
    118: [0, 0.44444, 0.01597, 0, 0.60694],
    119: [0, 0.44444, 0.01597, 0, 0.83055],
    120: [0, 0.44444, 0, 0, 0.60694],
    121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
    122: [0, 0.44444, 0, 0, 0.51111],
    123: [0.25, 0.75, 0, 0, 0.575],
    124: [0.25, 0.75, 0, 0, 0.31944],
    125: [0.25, 0.75, 0, 0, 0.575],
    126: [0.35, 0.34444, 0, 0, 0.575],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.86853],
    168: [0, 0.69444, 0, 0, 0.575],
    172: [0, 0.44444, 0, 0, 0.76666],
    176: [0, 0.69444, 0, 0, 0.86944],
    177: [0.13333, 0.63333, 0, 0, 0.89444],
    184: [0.17014, 0, 0, 0, 0.51111],
    198: [0, 0.68611, 0, 0, 1.04166],
    215: [0.13333, 0.63333, 0, 0, 0.89444],
    216: [0.04861, 0.73472, 0, 0, 0.89444],
    223: [0, 0.69444, 0, 0, 0.59722],
    230: [0, 0.44444, 0, 0, 0.83055],
    247: [0.13333, 0.63333, 0, 0, 0.89444],
    248: [0.09722, 0.54167, 0, 0, 0.575],
    305: [0, 0.44444, 0, 0, 0.31944],
    338: [0, 0.68611, 0, 0, 1.16944],
    339: [0, 0.44444, 0, 0, 0.89444],
    567: [0.19444, 0.44444, 0, 0, 0.35139],
    710: [0, 0.69444, 0, 0, 0.575],
    711: [0, 0.63194, 0, 0, 0.575],
    713: [0, 0.59611, 0, 0, 0.575],
    714: [0, 0.69444, 0, 0, 0.575],
    715: [0, 0.69444, 0, 0, 0.575],
    728: [0, 0.69444, 0, 0, 0.575],
    729: [0, 0.69444, 0, 0, 0.31944],
    730: [0, 0.69444, 0, 0, 0.86944],
    732: [0, 0.69444, 0, 0, 0.575],
    733: [0, 0.69444, 0, 0, 0.575],
    915: [0, 0.68611, 0, 0, 0.69166],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0, 0, 0.89444],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0, 0, 0.76666],
    928: [0, 0.68611, 0, 0, 0.9],
    931: [0, 0.68611, 0, 0, 0.83055],
    933: [0, 0.68611, 0, 0, 0.89444],
    934: [0, 0.68611, 0, 0, 0.83055],
    936: [0, 0.68611, 0, 0, 0.89444],
    937: [0, 0.68611, 0, 0, 0.83055],
    8211: [0, 0.44444, 0.03194, 0, 0.575],
    8212: [0, 0.44444, 0.03194, 0, 1.14999],
    8216: [0, 0.69444, 0, 0, 0.31944],
    8217: [0, 0.69444, 0, 0, 0.31944],
    8220: [0, 0.69444, 0, 0, 0.60278],
    8221: [0, 0.69444, 0, 0, 0.60278],
    8224: [0.19444, 0.69444, 0, 0, 0.51111],
    8225: [0.19444, 0.69444, 0, 0, 0.51111],
    8242: [0, 0.55556, 0, 0, 0.34444],
    8407: [0, 0.72444, 0.15486, 0, 0.575],
    8463: [0, 0.69444, 0, 0, 0.66759],
    8465: [0, 0.69444, 0, 0, 0.83055],
    8467: [0, 0.69444, 0, 0, 0.47361],
    8472: [0.19444, 0.44444, 0, 0, 0.74027],
    8476: [0, 0.69444, 0, 0, 0.83055],
    8501: [0, 0.69444, 0, 0, 0.70277],
    8592: [-0.10889, 0.39111, 0, 0, 1.14999],
    8593: [0.19444, 0.69444, 0, 0, 0.575],
    8594: [-0.10889, 0.39111, 0, 0, 1.14999],
    8595: [0.19444, 0.69444, 0, 0, 0.575],
    8596: [-0.10889, 0.39111, 0, 0, 1.14999],
    8597: [0.25, 0.75, 0, 0, 0.575],
    8598: [0.19444, 0.69444, 0, 0, 1.14999],
    8599: [0.19444, 0.69444, 0, 0, 1.14999],
    8600: [0.19444, 0.69444, 0, 0, 1.14999],
    8601: [0.19444, 0.69444, 0, 0, 1.14999],
    8636: [-0.10889, 0.39111, 0, 0, 1.14999],
    8637: [-0.10889, 0.39111, 0, 0, 1.14999],
    8640: [-0.10889, 0.39111, 0, 0, 1.14999],
    8641: [-0.10889, 0.39111, 0, 0, 1.14999],
    8656: [-0.10889, 0.39111, 0, 0, 1.14999],
    8657: [0.19444, 0.69444, 0, 0, 0.70277],
    8658: [-0.10889, 0.39111, 0, 0, 1.14999],
    8659: [0.19444, 0.69444, 0, 0, 0.70277],
    8660: [-0.10889, 0.39111, 0, 0, 1.14999],
    8661: [0.25, 0.75, 0, 0, 0.70277],
    8704: [0, 0.69444, 0, 0, 0.63889],
    8706: [0, 0.69444, 0.06389, 0, 0.62847],
    8707: [0, 0.69444, 0, 0, 0.63889],
    8709: [0.05556, 0.75, 0, 0, 0.575],
    8711: [0, 0.68611, 0, 0, 0.95833],
    8712: [0.08556, 0.58556, 0, 0, 0.76666],
    8715: [0.08556, 0.58556, 0, 0, 0.76666],
    8722: [0.13333, 0.63333, 0, 0, 0.89444],
    8723: [0.13333, 0.63333, 0, 0, 0.89444],
    8725: [0.25, 0.75, 0, 0, 0.575],
    8726: [0.25, 0.75, 0, 0, 0.575],
    8727: [-0.02778, 0.47222, 0, 0, 0.575],
    8728: [-0.02639, 0.47361, 0, 0, 0.575],
    8729: [-0.02639, 0.47361, 0, 0, 0.575],
    8730: [0.18, 0.82, 0, 0, 0.95833],
    8733: [0, 0.44444, 0, 0, 0.89444],
    8734: [0, 0.44444, 0, 0, 1.14999],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.31944],
    8741: [0.25, 0.75, 0, 0, 0.575],
    8743: [0, 0.55556, 0, 0, 0.76666],
    8744: [0, 0.55556, 0, 0, 0.76666],
    8745: [0, 0.55556, 0, 0, 0.76666],
    8746: [0, 0.55556, 0, 0, 0.76666],
    8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
    8764: [-0.10889, 0.39111, 0, 0, 0.89444],
    8768: [0.19444, 0.69444, 0, 0, 0.31944],
    8771: [222e-5, 0.50222, 0, 0, 0.89444],
    8773: [0.027, 0.638, 0, 0, 0.894],
    8776: [0.02444, 0.52444, 0, 0, 0.89444],
    8781: [222e-5, 0.50222, 0, 0, 0.89444],
    8801: [222e-5, 0.50222, 0, 0, 0.89444],
    8804: [0.19667, 0.69667, 0, 0, 0.89444],
    8805: [0.19667, 0.69667, 0, 0, 0.89444],
    8810: [0.08556, 0.58556, 0, 0, 1.14999],
    8811: [0.08556, 0.58556, 0, 0, 1.14999],
    8826: [0.08556, 0.58556, 0, 0, 0.89444],
    8827: [0.08556, 0.58556, 0, 0, 0.89444],
    8834: [0.08556, 0.58556, 0, 0, 0.89444],
    8835: [0.08556, 0.58556, 0, 0, 0.89444],
    8838: [0.19667, 0.69667, 0, 0, 0.89444],
    8839: [0.19667, 0.69667, 0, 0, 0.89444],
    8846: [0, 0.55556, 0, 0, 0.76666],
    8849: [0.19667, 0.69667, 0, 0, 0.89444],
    8850: [0.19667, 0.69667, 0, 0, 0.89444],
    8851: [0, 0.55556, 0, 0, 0.76666],
    8852: [0, 0.55556, 0, 0, 0.76666],
    8853: [0.13333, 0.63333, 0, 0, 0.89444],
    8854: [0.13333, 0.63333, 0, 0, 0.89444],
    8855: [0.13333, 0.63333, 0, 0, 0.89444],
    8856: [0.13333, 0.63333, 0, 0, 0.89444],
    8857: [0.13333, 0.63333, 0, 0, 0.89444],
    8866: [0, 0.69444, 0, 0, 0.70277],
    8867: [0, 0.69444, 0, 0, 0.70277],
    8868: [0, 0.69444, 0, 0, 0.89444],
    8869: [0, 0.69444, 0, 0, 0.89444],
    8900: [-0.02639, 0.47361, 0, 0, 0.575],
    8901: [-0.02639, 0.47361, 0, 0, 0.31944],
    8902: [-0.02778, 0.47222, 0, 0, 0.575],
    8968: [0.25, 0.75, 0, 0, 0.51111],
    8969: [0.25, 0.75, 0, 0, 0.51111],
    8970: [0.25, 0.75, 0, 0, 0.51111],
    8971: [0.25, 0.75, 0, 0, 0.51111],
    8994: [-0.13889, 0.36111, 0, 0, 1.14999],
    8995: [-0.13889, 0.36111, 0, 0, 1.14999],
    9651: [0.19444, 0.69444, 0, 0, 1.02222],
    9657: [-0.02778, 0.47222, 0, 0, 0.575],
    9661: [0.19444, 0.69444, 0, 0, 1.02222],
    9667: [-0.02778, 0.47222, 0, 0, 0.575],
    9711: [0.19444, 0.69444, 0, 0, 1.14999],
    9824: [0.12963, 0.69444, 0, 0, 0.89444],
    9825: [0.12963, 0.69444, 0, 0, 0.89444],
    9826: [0.12963, 0.69444, 0, 0, 0.89444],
    9827: [0.12963, 0.69444, 0, 0, 0.89444],
    9837: [0, 0.75, 0, 0, 0.44722],
    9838: [0.19444, 0.69444, 0, 0, 0.44722],
    9839: [0.19444, 0.69444, 0, 0, 0.44722],
    10216: [0.25, 0.75, 0, 0, 0.44722],
    10217: [0.25, 0.75, 0, 0, 0.44722],
    10815: [0, 0.68611, 0, 0, 0.9],
    10927: [0.19667, 0.69667, 0, 0, 0.89444],
    10928: [0.19667, 0.69667, 0, 0, 0.89444],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.11417, 0, 0.38611],
    34: [0, 0.69444, 0.07939, 0, 0.62055],
    35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
    37: [0.05556, 0.75, 0.12861, 0, 0.94444],
    38: [0, 0.69444, 0.08528, 0, 0.88555],
    39: [0, 0.69444, 0.12945, 0, 0.35555],
    40: [0.25, 0.75, 0.15806, 0, 0.47333],
    41: [0.25, 0.75, 0.03306, 0, 0.47333],
    42: [0, 0.75, 0.14333, 0, 0.59111],
    43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
    44: [0.19444, 0.14722, 0, 0, 0.35555],
    45: [0, 0.44444, 0.02611, 0, 0.41444],
    46: [0, 0.14722, 0, 0, 0.35555],
    47: [0.25, 0.75, 0.15806, 0, 0.59111],
    48: [0, 0.64444, 0.13167, 0, 0.59111],
    49: [0, 0.64444, 0.13167, 0, 0.59111],
    50: [0, 0.64444, 0.13167, 0, 0.59111],
    51: [0, 0.64444, 0.13167, 0, 0.59111],
    52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    53: [0, 0.64444, 0.13167, 0, 0.59111],
    54: [0, 0.64444, 0.13167, 0, 0.59111],
    55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    56: [0, 0.64444, 0.13167, 0, 0.59111],
    57: [0, 0.64444, 0.13167, 0, 0.59111],
    58: [0, 0.44444, 0.06695, 0, 0.35555],
    59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
    61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    63: [0, 0.69444, 0.11472, 0, 0.59111],
    64: [0, 0.69444, 0.09208, 0, 0.88555],
    65: [0, 0.68611, 0, 0, 0.86555],
    66: [0, 0.68611, 0.0992, 0, 0.81666],
    67: [0, 0.68611, 0.14208, 0, 0.82666],
    68: [0, 0.68611, 0.09062, 0, 0.87555],
    69: [0, 0.68611, 0.11431, 0, 0.75666],
    70: [0, 0.68611, 0.12903, 0, 0.72722],
    71: [0, 0.68611, 0.07347, 0, 0.89527],
    72: [0, 0.68611, 0.17208, 0, 0.8961],
    73: [0, 0.68611, 0.15681, 0, 0.47166],
    74: [0, 0.68611, 0.145, 0, 0.61055],
    75: [0, 0.68611, 0.14208, 0, 0.89499],
    76: [0, 0.68611, 0, 0, 0.69777],
    77: [0, 0.68611, 0.17208, 0, 1.07277],
    78: [0, 0.68611, 0.17208, 0, 0.8961],
    79: [0, 0.68611, 0.09062, 0, 0.85499],
    80: [0, 0.68611, 0.0992, 0, 0.78721],
    81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
    82: [0, 0.68611, 0.02559, 0, 0.85944],
    83: [0, 0.68611, 0.11264, 0, 0.64999],
    84: [0, 0.68611, 0.12903, 0, 0.7961],
    85: [0, 0.68611, 0.17208, 0, 0.88083],
    86: [0, 0.68611, 0.18625, 0, 0.86555],
    87: [0, 0.68611, 0.18625, 0, 1.15999],
    88: [0, 0.68611, 0.15681, 0, 0.86555],
    89: [0, 0.68611, 0.19803, 0, 0.86555],
    90: [0, 0.68611, 0.14208, 0, 0.70888],
    91: [0.25, 0.75, 0.1875, 0, 0.35611],
    93: [0.25, 0.75, 0.09972, 0, 0.35611],
    94: [0, 0.69444, 0.06709, 0, 0.59111],
    95: [0.31, 0.13444, 0.09811, 0, 0.59111],
    97: [0, 0.44444, 0.09426, 0, 0.59111],
    98: [0, 0.69444, 0.07861, 0, 0.53222],
    99: [0, 0.44444, 0.05222, 0, 0.53222],
    100: [0, 0.69444, 0.10861, 0, 0.59111],
    101: [0, 0.44444, 0.085, 0, 0.53222],
    102: [0.19444, 0.69444, 0.21778, 0, 0.4],
    103: [0.19444, 0.44444, 0.105, 0, 0.53222],
    104: [0, 0.69444, 0.09426, 0, 0.59111],
    105: [0, 0.69326, 0.11387, 0, 0.35555],
    106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
    107: [0, 0.69444, 0.11111, 0, 0.53222],
    108: [0, 0.69444, 0.10861, 0, 0.29666],
    109: [0, 0.44444, 0.09426, 0, 0.94444],
    110: [0, 0.44444, 0.09426, 0, 0.64999],
    111: [0, 0.44444, 0.07861, 0, 0.59111],
    112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
    113: [0.19444, 0.44444, 0.105, 0, 0.53222],
    114: [0, 0.44444, 0.11111, 0, 0.50167],
    115: [0, 0.44444, 0.08167, 0, 0.48694],
    116: [0, 0.63492, 0.09639, 0, 0.385],
    117: [0, 0.44444, 0.09426, 0, 0.62055],
    118: [0, 0.44444, 0.11111, 0, 0.53222],
    119: [0, 0.44444, 0.11111, 0, 0.76777],
    120: [0, 0.44444, 0.12583, 0, 0.56055],
    121: [0.19444, 0.44444, 0.105, 0, 0.56166],
    122: [0, 0.44444, 0.13889, 0, 0.49055],
    126: [0.35, 0.34444, 0.11472, 0, 0.59111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0.11473, 0, 0.59111],
    176: [0, 0.69444, 0, 0, 0.94888],
    184: [0.17014, 0, 0, 0, 0.53222],
    198: [0, 0.68611, 0.11431, 0, 1.02277],
    216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
    223: [0.19444, 0.69444, 0.09736, 0, 0.665],
    230: [0, 0.44444, 0.085, 0, 0.82666],
    248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
    305: [0, 0.44444, 0.09426, 0, 0.35555],
    338: [0, 0.68611, 0.11431, 0, 1.14054],
    339: [0, 0.44444, 0.085, 0, 0.82666],
    567: [0.19444, 0.44444, 0.04611, 0, 0.385],
    710: [0, 0.69444, 0.06709, 0, 0.59111],
    711: [0, 0.63194, 0.08271, 0, 0.59111],
    713: [0, 0.59444, 0.10444, 0, 0.59111],
    714: [0, 0.69444, 0.08528, 0, 0.59111],
    715: [0, 0.69444, 0, 0, 0.59111],
    728: [0, 0.69444, 0.10333, 0, 0.59111],
    729: [0, 0.69444, 0.12945, 0, 0.35555],
    730: [0, 0.69444, 0, 0, 0.94888],
    732: [0, 0.69444, 0.11472, 0, 0.59111],
    733: [0, 0.69444, 0.11472, 0, 0.59111],
    915: [0, 0.68611, 0.12903, 0, 0.69777],
    916: [0, 0.68611, 0, 0, 0.94444],
    920: [0, 0.68611, 0.09062, 0, 0.88555],
    923: [0, 0.68611, 0, 0, 0.80666],
    926: [0, 0.68611, 0.15092, 0, 0.76777],
    928: [0, 0.68611, 0.17208, 0, 0.8961],
    931: [0, 0.68611, 0.11431, 0, 0.82666],
    933: [0, 0.68611, 0.10778, 0, 0.88555],
    934: [0, 0.68611, 0.05632, 0, 0.82666],
    936: [0, 0.68611, 0.10778, 0, 0.88555],
    937: [0, 0.68611, 0.0992, 0, 0.82666],
    8211: [0, 0.44444, 0.09811, 0, 0.59111],
    8212: [0, 0.44444, 0.09811, 0, 1.18221],
    8216: [0, 0.69444, 0.12945, 0, 0.35555],
    8217: [0, 0.69444, 0.12945, 0, 0.35555],
    8220: [0, 0.69444, 0.16772, 0, 0.62055],
    8221: [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.12417, 0, 0.30667],
    34: [0, 0.69444, 0.06961, 0, 0.51444],
    35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
    37: [0.05556, 0.75, 0.13639, 0, 0.81777],
    38: [0, 0.69444, 0.09694, 0, 0.76666],
    39: [0, 0.69444, 0.12417, 0, 0.30667],
    40: [0.25, 0.75, 0.16194, 0, 0.40889],
    41: [0.25, 0.75, 0.03694, 0, 0.40889],
    42: [0, 0.75, 0.14917, 0, 0.51111],
    43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
    44: [0.19444, 0.10556, 0, 0, 0.30667],
    45: [0, 0.43056, 0.02826, 0, 0.35778],
    46: [0, 0.10556, 0, 0, 0.30667],
    47: [0.25, 0.75, 0.16194, 0, 0.51111],
    48: [0, 0.64444, 0.13556, 0, 0.51111],
    49: [0, 0.64444, 0.13556, 0, 0.51111],
    50: [0, 0.64444, 0.13556, 0, 0.51111],
    51: [0, 0.64444, 0.13556, 0, 0.51111],
    52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    53: [0, 0.64444, 0.13556, 0, 0.51111],
    54: [0, 0.64444, 0.13556, 0, 0.51111],
    55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    56: [0, 0.64444, 0.13556, 0, 0.51111],
    57: [0, 0.64444, 0.13556, 0, 0.51111],
    58: [0, 0.43056, 0.0582, 0, 0.30667],
    59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
    61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    63: [0, 0.69444, 0.1225, 0, 0.51111],
    64: [0, 0.69444, 0.09597, 0, 0.76666],
    65: [0, 0.68333, 0, 0, 0.74333],
    66: [0, 0.68333, 0.10257, 0, 0.70389],
    67: [0, 0.68333, 0.14528, 0, 0.71555],
    68: [0, 0.68333, 0.09403, 0, 0.755],
    69: [0, 0.68333, 0.12028, 0, 0.67833],
    70: [0, 0.68333, 0.13305, 0, 0.65277],
    71: [0, 0.68333, 0.08722, 0, 0.77361],
    72: [0, 0.68333, 0.16389, 0, 0.74333],
    73: [0, 0.68333, 0.15806, 0, 0.38555],
    74: [0, 0.68333, 0.14028, 0, 0.525],
    75: [0, 0.68333, 0.14528, 0, 0.76888],
    76: [0, 0.68333, 0, 0, 0.62722],
    77: [0, 0.68333, 0.16389, 0, 0.89666],
    78: [0, 0.68333, 0.16389, 0, 0.74333],
    79: [0, 0.68333, 0.09403, 0, 0.76666],
    80: [0, 0.68333, 0.10257, 0, 0.67833],
    81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
    82: [0, 0.68333, 0.03868, 0, 0.72944],
    83: [0, 0.68333, 0.11972, 0, 0.56222],
    84: [0, 0.68333, 0.13305, 0, 0.71555],
    85: [0, 0.68333, 0.16389, 0, 0.74333],
    86: [0, 0.68333, 0.18361, 0, 0.74333],
    87: [0, 0.68333, 0.18361, 0, 0.99888],
    88: [0, 0.68333, 0.15806, 0, 0.74333],
    89: [0, 0.68333, 0.19383, 0, 0.74333],
    90: [0, 0.68333, 0.14528, 0, 0.61333],
    91: [0.25, 0.75, 0.1875, 0, 0.30667],
    93: [0.25, 0.75, 0.10528, 0, 0.30667],
    94: [0, 0.69444, 0.06646, 0, 0.51111],
    95: [0.31, 0.12056, 0.09208, 0, 0.51111],
    97: [0, 0.43056, 0.07671, 0, 0.51111],
    98: [0, 0.69444, 0.06312, 0, 0.46],
    99: [0, 0.43056, 0.05653, 0, 0.46],
    100: [0, 0.69444, 0.10333, 0, 0.51111],
    101: [0, 0.43056, 0.07514, 0, 0.46],
    102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
    103: [0.19444, 0.43056, 0.08847, 0, 0.46],
    104: [0, 0.69444, 0.07671, 0, 0.51111],
    105: [0, 0.65536, 0.1019, 0, 0.30667],
    106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
    107: [0, 0.69444, 0.10764, 0, 0.46],
    108: [0, 0.69444, 0.10333, 0, 0.25555],
    109: [0, 0.43056, 0.07671, 0, 0.81777],
    110: [0, 0.43056, 0.07671, 0, 0.56222],
    111: [0, 0.43056, 0.06312, 0, 0.51111],
    112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
    113: [0.19444, 0.43056, 0.08847, 0, 0.46],
    114: [0, 0.43056, 0.10764, 0, 0.42166],
    115: [0, 0.43056, 0.08208, 0, 0.40889],
    116: [0, 0.61508, 0.09486, 0, 0.33222],
    117: [0, 0.43056, 0.07671, 0, 0.53666],
    118: [0, 0.43056, 0.10764, 0, 0.46],
    119: [0, 0.43056, 0.10764, 0, 0.66444],
    120: [0, 0.43056, 0.12042, 0, 0.46389],
    121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
    122: [0, 0.43056, 0.12292, 0, 0.40889],
    126: [0.35, 0.31786, 0.11585, 0, 0.51111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.66786, 0.10474, 0, 0.51111],
    176: [0, 0.69444, 0, 0, 0.83129],
    184: [0.17014, 0, 0, 0, 0.46],
    198: [0, 0.68333, 0.12028, 0, 0.88277],
    216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
    223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
    230: [0, 0.43056, 0.07514, 0, 0.71555],
    248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
    338: [0, 0.68333, 0.12028, 0, 0.98499],
    339: [0, 0.43056, 0.07514, 0, 0.71555],
    710: [0, 0.69444, 0.06646, 0, 0.51111],
    711: [0, 0.62847, 0.08295, 0, 0.51111],
    713: [0, 0.56167, 0.10333, 0, 0.51111],
    714: [0, 0.69444, 0.09694, 0, 0.51111],
    715: [0, 0.69444, 0, 0, 0.51111],
    728: [0, 0.69444, 0.10806, 0, 0.51111],
    729: [0, 0.66786, 0.11752, 0, 0.30667],
    730: [0, 0.69444, 0, 0, 0.83129],
    732: [0, 0.66786, 0.11585, 0, 0.51111],
    733: [0, 0.69444, 0.1225, 0, 0.51111],
    915: [0, 0.68333, 0.13305, 0, 0.62722],
    916: [0, 0.68333, 0, 0, 0.81777],
    920: [0, 0.68333, 0.09403, 0, 0.76666],
    923: [0, 0.68333, 0, 0, 0.69222],
    926: [0, 0.68333, 0.15294, 0, 0.66444],
    928: [0, 0.68333, 0.16389, 0, 0.74333],
    931: [0, 0.68333, 0.12028, 0, 0.71555],
    933: [0, 0.68333, 0.11111, 0, 0.76666],
    934: [0, 0.68333, 0.05986, 0, 0.71555],
    936: [0, 0.68333, 0.11111, 0, 0.76666],
    937: [0, 0.68333, 0.10257, 0, 0.71555],
    8211: [0, 0.43056, 0.09208, 0, 0.51111],
    8212: [0, 0.43056, 0.09208, 0, 1.02222],
    8216: [0, 0.69444, 0.12417, 0, 0.30667],
    8217: [0, 0.69444, 0.12417, 0, 0.30667],
    8220: [0, 0.69444, 0.1685, 0, 0.51444],
    8221: [0, 0.69444, 0.06961, 0, 0.51444],
    8463: [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.27778],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.77778],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.19444, 0.10556, 0, 0, 0.27778],
    45: [0, 0.43056, 0, 0, 0.33333],
    46: [0, 0.10556, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.64444, 0, 0, 0.5],
    49: [0, 0.64444, 0, 0, 0.5],
    50: [0, 0.64444, 0, 0, 0.5],
    51: [0, 0.64444, 0, 0, 0.5],
    52: [0, 0.64444, 0, 0, 0.5],
    53: [0, 0.64444, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0, 0.64444, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0, 0.64444, 0, 0, 0.5],
    58: [0, 0.43056, 0, 0, 0.27778],
    59: [0.19444, 0.43056, 0, 0, 0.27778],
    60: [0.0391, 0.5391, 0, 0, 0.77778],
    61: [-0.13313, 0.36687, 0, 0, 0.77778],
    62: [0.0391, 0.5391, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.77778],
    65: [0, 0.68333, 0, 0, 0.75],
    66: [0, 0.68333, 0, 0, 0.70834],
    67: [0, 0.68333, 0, 0, 0.72222],
    68: [0, 0.68333, 0, 0, 0.76389],
    69: [0, 0.68333, 0, 0, 0.68056],
    70: [0, 0.68333, 0, 0, 0.65278],
    71: [0, 0.68333, 0, 0, 0.78472],
    72: [0, 0.68333, 0, 0, 0.75],
    73: [0, 0.68333, 0, 0, 0.36111],
    74: [0, 0.68333, 0, 0, 0.51389],
    75: [0, 0.68333, 0, 0, 0.77778],
    76: [0, 0.68333, 0, 0, 0.625],
    77: [0, 0.68333, 0, 0, 0.91667],
    78: [0, 0.68333, 0, 0, 0.75],
    79: [0, 0.68333, 0, 0, 0.77778],
    80: [0, 0.68333, 0, 0, 0.68056],
    81: [0.19444, 0.68333, 0, 0, 0.77778],
    82: [0, 0.68333, 0, 0, 0.73611],
    83: [0, 0.68333, 0, 0, 0.55556],
    84: [0, 0.68333, 0, 0, 0.72222],
    85: [0, 0.68333, 0, 0, 0.75],
    86: [0, 0.68333, 0.01389, 0, 0.75],
    87: [0, 0.68333, 0.01389, 0, 1.02778],
    88: [0, 0.68333, 0, 0, 0.75],
    89: [0, 0.68333, 0.025, 0, 0.75],
    90: [0, 0.68333, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.27778],
    92: [0.25, 0.75, 0, 0, 0.5],
    93: [0.25, 0.75, 0, 0, 0.27778],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.31, 0.12056, 0.02778, 0, 0.5],
    97: [0, 0.43056, 0, 0, 0.5],
    98: [0, 0.69444, 0, 0, 0.55556],
    99: [0, 0.43056, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.55556],
    101: [0, 0.43056, 0, 0, 0.44445],
    102: [0, 0.69444, 0.07778, 0, 0.30556],
    103: [0.19444, 0.43056, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.55556],
    105: [0, 0.66786, 0, 0, 0.27778],
    106: [0.19444, 0.66786, 0, 0, 0.30556],
    107: [0, 0.69444, 0, 0, 0.52778],
    108: [0, 0.69444, 0, 0, 0.27778],
    109: [0, 0.43056, 0, 0, 0.83334],
    110: [0, 0.43056, 0, 0, 0.55556],
    111: [0, 0.43056, 0, 0, 0.5],
    112: [0.19444, 0.43056, 0, 0, 0.55556],
    113: [0.19444, 0.43056, 0, 0, 0.52778],
    114: [0, 0.43056, 0, 0, 0.39167],
    115: [0, 0.43056, 0, 0, 0.39445],
    116: [0, 0.61508, 0, 0, 0.38889],
    117: [0, 0.43056, 0, 0, 0.55556],
    118: [0, 0.43056, 0.01389, 0, 0.52778],
    119: [0, 0.43056, 0.01389, 0, 0.72222],
    120: [0, 0.43056, 0, 0, 0.52778],
    121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
    122: [0, 0.43056, 0, 0, 0.44445],
    123: [0.25, 0.75, 0, 0, 0.5],
    124: [0.25, 0.75, 0, 0, 0.27778],
    125: [0.25, 0.75, 0, 0, 0.5],
    126: [0.35, 0.31786, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.76909],
    167: [0.19444, 0.69444, 0, 0, 0.44445],
    168: [0, 0.66786, 0, 0, 0.5],
    172: [0, 0.43056, 0, 0, 0.66667],
    176: [0, 0.69444, 0, 0, 0.75],
    177: [0.08333, 0.58333, 0, 0, 0.77778],
    182: [0.19444, 0.69444, 0, 0, 0.61111],
    184: [0.17014, 0, 0, 0, 0.44445],
    198: [0, 0.68333, 0, 0, 0.90278],
    215: [0.08333, 0.58333, 0, 0, 0.77778],
    216: [0.04861, 0.73194, 0, 0, 0.77778],
    223: [0, 0.69444, 0, 0, 0.5],
    230: [0, 0.43056, 0, 0, 0.72222],
    247: [0.08333, 0.58333, 0, 0, 0.77778],
    248: [0.09722, 0.52778, 0, 0, 0.5],
    305: [0, 0.43056, 0, 0, 0.27778],
    338: [0, 0.68333, 0, 0, 1.01389],
    339: [0, 0.43056, 0, 0, 0.77778],
    567: [0.19444, 0.43056, 0, 0, 0.30556],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.62847, 0, 0, 0.5],
    713: [0, 0.56778, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.66786, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.75],
    732: [0, 0.66786, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.68333, 0, 0, 0.625],
    916: [0, 0.68333, 0, 0, 0.83334],
    920: [0, 0.68333, 0, 0, 0.77778],
    923: [0, 0.68333, 0, 0, 0.69445],
    926: [0, 0.68333, 0, 0, 0.66667],
    928: [0, 0.68333, 0, 0, 0.75],
    931: [0, 0.68333, 0, 0, 0.72222],
    933: [0, 0.68333, 0, 0, 0.77778],
    934: [0, 0.68333, 0, 0, 0.72222],
    936: [0, 0.68333, 0, 0, 0.77778],
    937: [0, 0.68333, 0, 0, 0.72222],
    8211: [0, 0.43056, 0.02778, 0, 0.5],
    8212: [0, 0.43056, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5],
    8224: [0.19444, 0.69444, 0, 0, 0.44445],
    8225: [0.19444, 0.69444, 0, 0, 0.44445],
    8230: [0, 0.123, 0, 0, 1.172],
    8242: [0, 0.55556, 0, 0, 0.275],
    8407: [0, 0.71444, 0.15382, 0, 0.5],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8465: [0, 0.69444, 0, 0, 0.72222],
    8467: [0, 0.69444, 0, 0.11111, 0.41667],
    8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
    8476: [0, 0.69444, 0, 0, 0.72222],
    8501: [0, 0.69444, 0, 0, 0.61111],
    8592: [-0.13313, 0.36687, 0, 0, 1],
    8593: [0.19444, 0.69444, 0, 0, 0.5],
    8594: [-0.13313, 0.36687, 0, 0, 1],
    8595: [0.19444, 0.69444, 0, 0, 0.5],
    8596: [-0.13313, 0.36687, 0, 0, 1],
    8597: [0.25, 0.75, 0, 0, 0.5],
    8598: [0.19444, 0.69444, 0, 0, 1],
    8599: [0.19444, 0.69444, 0, 0, 1],
    8600: [0.19444, 0.69444, 0, 0, 1],
    8601: [0.19444, 0.69444, 0, 0, 1],
    8614: [0.011, 0.511, 0, 0, 1],
    8617: [0.011, 0.511, 0, 0, 1.126],
    8618: [0.011, 0.511, 0, 0, 1.126],
    8636: [-0.13313, 0.36687, 0, 0, 1],
    8637: [-0.13313, 0.36687, 0, 0, 1],
    8640: [-0.13313, 0.36687, 0, 0, 1],
    8641: [-0.13313, 0.36687, 0, 0, 1],
    8652: [0.011, 0.671, 0, 0, 1],
    8656: [-0.13313, 0.36687, 0, 0, 1],
    8657: [0.19444, 0.69444, 0, 0, 0.61111],
    8658: [-0.13313, 0.36687, 0, 0, 1],
    8659: [0.19444, 0.69444, 0, 0, 0.61111],
    8660: [-0.13313, 0.36687, 0, 0, 1],
    8661: [0.25, 0.75, 0, 0, 0.61111],
    8704: [0, 0.69444, 0, 0, 0.55556],
    8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
    8707: [0, 0.69444, 0, 0, 0.55556],
    8709: [0.05556, 0.75, 0, 0, 0.5],
    8711: [0, 0.68333, 0, 0, 0.83334],
    8712: [0.0391, 0.5391, 0, 0, 0.66667],
    8715: [0.0391, 0.5391, 0, 0, 0.66667],
    8722: [0.08333, 0.58333, 0, 0, 0.77778],
    8723: [0.08333, 0.58333, 0, 0, 0.77778],
    8725: [0.25, 0.75, 0, 0, 0.5],
    8726: [0.25, 0.75, 0, 0, 0.5],
    8727: [-0.03472, 0.46528, 0, 0, 0.5],
    8728: [-0.05555, 0.44445, 0, 0, 0.5],
    8729: [-0.05555, 0.44445, 0, 0, 0.5],
    8730: [0.2, 0.8, 0, 0, 0.83334],
    8733: [0, 0.43056, 0, 0, 0.77778],
    8734: [0, 0.43056, 0, 0, 1],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.27778],
    8741: [0.25, 0.75, 0, 0, 0.5],
    8743: [0, 0.55556, 0, 0, 0.66667],
    8744: [0, 0.55556, 0, 0, 0.66667],
    8745: [0, 0.55556, 0, 0, 0.66667],
    8746: [0, 0.55556, 0, 0, 0.66667],
    8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8768: [0.19444, 0.69444, 0, 0, 0.27778],
    8771: [-0.03625, 0.46375, 0, 0, 0.77778],
    8773: [-0.022, 0.589, 0, 0, 0.778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8781: [-0.03625, 0.46375, 0, 0, 0.77778],
    8784: [-0.133, 0.673, 0, 0, 0.778],
    8801: [-0.03625, 0.46375, 0, 0, 0.77778],
    8804: [0.13597, 0.63597, 0, 0, 0.77778],
    8805: [0.13597, 0.63597, 0, 0, 0.77778],
    8810: [0.0391, 0.5391, 0, 0, 1],
    8811: [0.0391, 0.5391, 0, 0, 1],
    8826: [0.0391, 0.5391, 0, 0, 0.77778],
    8827: [0.0391, 0.5391, 0, 0, 0.77778],
    8834: [0.0391, 0.5391, 0, 0, 0.77778],
    8835: [0.0391, 0.5391, 0, 0, 0.77778],
    8838: [0.13597, 0.63597, 0, 0, 0.77778],
    8839: [0.13597, 0.63597, 0, 0, 0.77778],
    8846: [0, 0.55556, 0, 0, 0.66667],
    8849: [0.13597, 0.63597, 0, 0, 0.77778],
    8850: [0.13597, 0.63597, 0, 0, 0.77778],
    8851: [0, 0.55556, 0, 0, 0.66667],
    8852: [0, 0.55556, 0, 0, 0.66667],
    8853: [0.08333, 0.58333, 0, 0, 0.77778],
    8854: [0.08333, 0.58333, 0, 0, 0.77778],
    8855: [0.08333, 0.58333, 0, 0, 0.77778],
    8856: [0.08333, 0.58333, 0, 0, 0.77778],
    8857: [0.08333, 0.58333, 0, 0, 0.77778],
    8866: [0, 0.69444, 0, 0, 0.61111],
    8867: [0, 0.69444, 0, 0, 0.61111],
    8868: [0, 0.69444, 0, 0, 0.77778],
    8869: [0, 0.69444, 0, 0, 0.77778],
    8872: [0.249, 0.75, 0, 0, 0.867],
    8900: [-0.05555, 0.44445, 0, 0, 0.5],
    8901: [-0.05555, 0.44445, 0, 0, 0.27778],
    8902: [-0.03472, 0.46528, 0, 0, 0.5],
    8904: [5e-3, 0.505, 0, 0, 0.9],
    8942: [0.03, 0.903, 0, 0, 0.278],
    8943: [-0.19, 0.313, 0, 0, 1.172],
    8945: [-0.1, 0.823, 0, 0, 1.282],
    8968: [0.25, 0.75, 0, 0, 0.44445],
    8969: [0.25, 0.75, 0, 0, 0.44445],
    8970: [0.25, 0.75, 0, 0, 0.44445],
    8971: [0.25, 0.75, 0, 0, 0.44445],
    8994: [-0.14236, 0.35764, 0, 0, 1],
    8995: [-0.14236, 0.35764, 0, 0, 1],
    9136: [0.244, 0.744, 0, 0, 0.412],
    9137: [0.244, 0.745, 0, 0, 0.412],
    9651: [0.19444, 0.69444, 0, 0, 0.88889],
    9657: [-0.03472, 0.46528, 0, 0, 0.5],
    9661: [0.19444, 0.69444, 0, 0, 0.88889],
    9667: [-0.03472, 0.46528, 0, 0, 0.5],
    9711: [0.19444, 0.69444, 0, 0, 1],
    9824: [0.12963, 0.69444, 0, 0, 0.77778],
    9825: [0.12963, 0.69444, 0, 0, 0.77778],
    9826: [0.12963, 0.69444, 0, 0, 0.77778],
    9827: [0.12963, 0.69444, 0, 0, 0.77778],
    9837: [0, 0.75, 0, 0, 0.38889],
    9838: [0.19444, 0.69444, 0, 0, 0.38889],
    9839: [0.19444, 0.69444, 0, 0, 0.38889],
    10216: [0.25, 0.75, 0, 0, 0.38889],
    10217: [0.25, 0.75, 0, 0, 0.38889],
    10222: [0.244, 0.744, 0, 0, 0.412],
    10223: [0.244, 0.745, 0, 0, 0.412],
    10229: [0.011, 0.511, 0, 0, 1.609],
    10230: [0.011, 0.511, 0, 0, 1.638],
    10231: [0.011, 0.511, 0, 0, 1.859],
    10232: [0.024, 0.525, 0, 0, 1.609],
    10233: [0.024, 0.525, 0, 0, 1.638],
    10234: [0.024, 0.525, 0, 0, 1.858],
    10236: [0.011, 0.511, 0, 0, 1.638],
    10815: [0, 0.68333, 0, 0, 0.75],
    10927: [0.13597, 0.63597, 0, 0, 0.77778],
    10928: [0.13597, 0.63597, 0, 0, 0.77778],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.44444, 0, 0, 0.575],
    49: [0, 0.44444, 0, 0, 0.575],
    50: [0, 0.44444, 0, 0, 0.575],
    51: [0.19444, 0.44444, 0, 0, 0.575],
    52: [0.19444, 0.44444, 0, 0, 0.575],
    53: [0.19444, 0.44444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0.19444, 0.44444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0.19444, 0.44444, 0, 0, 0.575],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0.04835, 0, 0.8664],
    67: [0, 0.68611, 0.06979, 0, 0.81694],
    68: [0, 0.68611, 0.03194, 0, 0.93812],
    69: [0, 0.68611, 0.05451, 0, 0.81007],
    70: [0, 0.68611, 0.15972, 0, 0.68889],
    71: [0, 0.68611, 0, 0, 0.88673],
    72: [0, 0.68611, 0.08229, 0, 0.98229],
    73: [0, 0.68611, 0.07778, 0, 0.51111],
    74: [0, 0.68611, 0.10069, 0, 0.63125],
    75: [0, 0.68611, 0.06979, 0, 0.97118],
    76: [0, 0.68611, 0, 0, 0.75555],
    77: [0, 0.68611, 0.11424, 0, 1.14201],
    78: [0, 0.68611, 0.11424, 0, 0.95034],
    79: [0, 0.68611, 0.03194, 0, 0.83666],
    80: [0, 0.68611, 0.15972, 0, 0.72309],
    81: [0.19444, 0.68611, 0, 0, 0.86861],
    82: [0, 0.68611, 421e-5, 0, 0.87235],
    83: [0, 0.68611, 0.05382, 0, 0.69271],
    84: [0, 0.68611, 0.15972, 0, 0.63663],
    85: [0, 0.68611, 0.11424, 0, 0.80027],
    86: [0, 0.68611, 0.25555, 0, 0.67778],
    87: [0, 0.68611, 0.15972, 0, 1.09305],
    88: [0, 0.68611, 0.07778, 0, 0.94722],
    89: [0, 0.68611, 0.25555, 0, 0.67458],
    90: [0, 0.68611, 0.06979, 0, 0.77257],
    97: [0, 0.44444, 0, 0, 0.63287],
    98: [0, 0.69444, 0, 0, 0.52083],
    99: [0, 0.44444, 0, 0, 0.51342],
    100: [0, 0.69444, 0, 0, 0.60972],
    101: [0, 0.44444, 0, 0, 0.55361],
    102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
    103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
    104: [0, 0.69444, 0, 0, 0.66759],
    105: [0, 0.69326, 0, 0, 0.4048],
    106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
    107: [0, 0.69444, 0.01852, 0, 0.6037],
    108: [0, 0.69444, 88e-4, 0, 0.34815],
    109: [0, 0.44444, 0, 0, 1.0324],
    110: [0, 0.44444, 0, 0, 0.71296],
    111: [0, 0.44444, 0, 0, 0.58472],
    112: [0.19444, 0.44444, 0, 0, 0.60092],
    113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
    114: [0, 0.44444, 0.03194, 0, 0.5287],
    115: [0, 0.44444, 0, 0, 0.53125],
    116: [0, 0.63492, 0, 0, 0.41528],
    117: [0, 0.44444, 0, 0, 0.68102],
    118: [0, 0.44444, 0.03704, 0, 0.56666],
    119: [0, 0.44444, 0.02778, 0, 0.83148],
    120: [0, 0.44444, 0, 0, 0.65903],
    121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
    122: [0, 0.44444, 0.04213, 0, 0.55509],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68611, 0.15972, 0, 0.65694],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0.03194, 0, 0.86722],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0.07458, 0, 0.84125],
    928: [0, 0.68611, 0.08229, 0, 0.98229],
    931: [0, 0.68611, 0.05451, 0, 0.88507],
    933: [0, 0.68611, 0.15972, 0, 0.67083],
    934: [0, 0.68611, 0, 0, 0.76666],
    936: [0, 0.68611, 0.11653, 0, 0.71402],
    937: [0, 0.68611, 0.04835, 0, 0.8789],
    945: [0, 0.44444, 0, 0, 0.76064],
    946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
    947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
    948: [0, 0.69444, 0.03819, 0, 0.52222],
    949: [0, 0.44444, 0, 0, 0.52882],
    950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
    951: [0.19444, 0.44444, 0.03704, 0, 0.6],
    952: [0, 0.69444, 0.03194, 0, 0.5618],
    953: [0, 0.44444, 0, 0, 0.41204],
    954: [0, 0.44444, 0, 0, 0.66759],
    955: [0, 0.69444, 0, 0, 0.67083],
    956: [0.19444, 0.44444, 0, 0, 0.70787],
    957: [0, 0.44444, 0.06898, 0, 0.57685],
    958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
    959: [0, 0.44444, 0, 0, 0.58472],
    960: [0, 0.44444, 0.03704, 0, 0.68241],
    961: [0.19444, 0.44444, 0, 0, 0.6118],
    962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
    963: [0, 0.44444, 0.03704, 0, 0.68588],
    964: [0, 0.44444, 0.13472, 0, 0.52083],
    965: [0, 0.44444, 0.03704, 0, 0.63055],
    966: [0.19444, 0.44444, 0, 0, 0.74722],
    967: [0.19444, 0.44444, 0, 0, 0.71805],
    968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
    969: [0, 0.44444, 0.03704, 0, 0.71782],
    977: [0, 0.69444, 0, 0, 0.69155],
    981: [0.19444, 0.69444, 0, 0, 0.7125],
    982: [0, 0.44444, 0.03194, 0, 0.975],
    1009: [0.19444, 0.44444, 0, 0, 0.6118],
    1013: [0, 0.44444, 0, 0, 0.48333],
    57649: [0, 0.44444, 0, 0, 0.39352],
    57911: [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.43056, 0, 0, 0.5],
    49: [0, 0.43056, 0, 0, 0.5],
    50: [0, 0.43056, 0, 0, 0.5],
    51: [0.19444, 0.43056, 0, 0, 0.5],
    52: [0.19444, 0.43056, 0, 0, 0.5],
    53: [0.19444, 0.43056, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0.19444, 0.43056, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0.19444, 0.43056, 0, 0, 0.5],
    65: [0, 0.68333, 0, 0.13889, 0.75],
    66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
    67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
    68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
    69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
    70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
    71: [0, 0.68333, 0, 0.08334, 0.78625],
    72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
    74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
    75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
    76: [0, 0.68333, 0, 0.02778, 0.68056],
    77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
    78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
    79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
    81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
    82: [0, 0.68333, 773e-5, 0.08334, 0.75929],
    83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
    84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
    85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
    86: [0, 0.68333, 0.22222, 0, 0.58333],
    87: [0, 0.68333, 0.13889, 0, 0.94445],
    88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
    89: [0, 0.68333, 0.22222, 0, 0.58056],
    90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
    97: [0, 0.43056, 0, 0, 0.52859],
    98: [0, 0.69444, 0, 0, 0.42917],
    99: [0, 0.43056, 0, 0.05556, 0.43276],
    100: [0, 0.69444, 0, 0.16667, 0.52049],
    101: [0, 0.43056, 0, 0.05556, 0.46563],
    102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    104: [0, 0.69444, 0, 0, 0.57616],
    105: [0, 0.65952, 0, 0, 0.34451],
    106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
    107: [0, 0.69444, 0.03148, 0, 0.5206],
    108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
    109: [0, 0.43056, 0, 0, 0.87801],
    110: [0, 0.43056, 0, 0, 0.60023],
    111: [0, 0.43056, 0, 0.05556, 0.48472],
    112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
    113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
    115: [0, 0.43056, 0, 0.05556, 0.46875],
    116: [0, 0.61508, 0, 0.08334, 0.36111],
    117: [0, 0.43056, 0, 0.02778, 0.57246],
    118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
    119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
    120: [0, 0.43056, 0, 0.02778, 0.57153],
    121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
    916: [0, 0.68333, 0, 0.16667, 0.83334],
    920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    923: [0, 0.68333, 0, 0.16667, 0.69445],
    926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
    928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
    933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
    934: [0, 0.68333, 0, 0.08334, 0.66667],
    936: [0, 0.68333, 0.11, 0.05556, 0.61222],
    937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
    945: [0, 0.43056, 37e-4, 0.02778, 0.6397],
    946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
    948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
    949: [0, 0.43056, 0, 0.08334, 0.46632],
    950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
    953: [0, 0.43056, 0, 0.05556, 0.35394],
    954: [0, 0.43056, 0, 0, 0.57616],
    955: [0, 0.69444, 0, 0, 0.58334],
    956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
    957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
    958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    959: [0, 0.43056, 0, 0.05556, 0.48472],
    960: [0, 0.43056, 0.03588, 0, 0.57003],
    961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    963: [0, 0.43056, 0.03588, 0, 0.57141],
    964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
    965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
    966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
    967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
    968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    969: [0, 0.43056, 0.03588, 0, 0.62245],
    977: [0, 0.69444, 0, 0.08334, 0.59144],
    981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
    982: [0, 0.43056, 0.02778, 0, 0.82813],
    1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    1013: [0, 0.43056, 0, 0.05556, 0.4059],
    57649: [0, 0.43056, 0, 0.02778, 0.32246],
    57911: [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.36667],
    34: [0, 0.69444, 0, 0, 0.55834],
    35: [0.19444, 0.69444, 0, 0, 0.91667],
    36: [0.05556, 0.75, 0, 0, 0.55],
    37: [0.05556, 0.75, 0, 0, 1.02912],
    38: [0, 0.69444, 0, 0, 0.83056],
    39: [0, 0.69444, 0, 0, 0.30556],
    40: [0.25, 0.75, 0, 0, 0.42778],
    41: [0.25, 0.75, 0, 0, 0.42778],
    42: [0, 0.75, 0, 0, 0.55],
    43: [0.11667, 0.61667, 0, 0, 0.85556],
    44: [0.10556, 0.13056, 0, 0, 0.30556],
    45: [0, 0.45833, 0, 0, 0.36667],
    46: [0, 0.13056, 0, 0, 0.30556],
    47: [0.25, 0.75, 0, 0, 0.55],
    48: [0, 0.69444, 0, 0, 0.55],
    49: [0, 0.69444, 0, 0, 0.55],
    50: [0, 0.69444, 0, 0, 0.55],
    51: [0, 0.69444, 0, 0, 0.55],
    52: [0, 0.69444, 0, 0, 0.55],
    53: [0, 0.69444, 0, 0, 0.55],
    54: [0, 0.69444, 0, 0, 0.55],
    55: [0, 0.69444, 0, 0, 0.55],
    56: [0, 0.69444, 0, 0, 0.55],
    57: [0, 0.69444, 0, 0, 0.55],
    58: [0, 0.45833, 0, 0, 0.30556],
    59: [0.10556, 0.45833, 0, 0, 0.30556],
    61: [-0.09375, 0.40625, 0, 0, 0.85556],
    63: [0, 0.69444, 0, 0, 0.51945],
    64: [0, 0.69444, 0, 0, 0.73334],
    65: [0, 0.69444, 0, 0, 0.73334],
    66: [0, 0.69444, 0, 0, 0.73334],
    67: [0, 0.69444, 0, 0, 0.70278],
    68: [0, 0.69444, 0, 0, 0.79445],
    69: [0, 0.69444, 0, 0, 0.64167],
    70: [0, 0.69444, 0, 0, 0.61111],
    71: [0, 0.69444, 0, 0, 0.73334],
    72: [0, 0.69444, 0, 0, 0.79445],
    73: [0, 0.69444, 0, 0, 0.33056],
    74: [0, 0.69444, 0, 0, 0.51945],
    75: [0, 0.69444, 0, 0, 0.76389],
    76: [0, 0.69444, 0, 0, 0.58056],
    77: [0, 0.69444, 0, 0, 0.97778],
    78: [0, 0.69444, 0, 0, 0.79445],
    79: [0, 0.69444, 0, 0, 0.79445],
    80: [0, 0.69444, 0, 0, 0.70278],
    81: [0.10556, 0.69444, 0, 0, 0.79445],
    82: [0, 0.69444, 0, 0, 0.70278],
    83: [0, 0.69444, 0, 0, 0.61111],
    84: [0, 0.69444, 0, 0, 0.73334],
    85: [0, 0.69444, 0, 0, 0.76389],
    86: [0, 0.69444, 0.01528, 0, 0.73334],
    87: [0, 0.69444, 0.01528, 0, 1.03889],
    88: [0, 0.69444, 0, 0, 0.73334],
    89: [0, 0.69444, 0.0275, 0, 0.73334],
    90: [0, 0.69444, 0, 0, 0.67223],
    91: [0.25, 0.75, 0, 0, 0.34306],
    93: [0.25, 0.75, 0, 0, 0.34306],
    94: [0, 0.69444, 0, 0, 0.55],
    95: [0.35, 0.10833, 0.03056, 0, 0.55],
    97: [0, 0.45833, 0, 0, 0.525],
    98: [0, 0.69444, 0, 0, 0.56111],
    99: [0, 0.45833, 0, 0, 0.48889],
    100: [0, 0.69444, 0, 0, 0.56111],
    101: [0, 0.45833, 0, 0, 0.51111],
    102: [0, 0.69444, 0.07639, 0, 0.33611],
    103: [0.19444, 0.45833, 0.01528, 0, 0.55],
    104: [0, 0.69444, 0, 0, 0.56111],
    105: [0, 0.69444, 0, 0, 0.25556],
    106: [0.19444, 0.69444, 0, 0, 0.28611],
    107: [0, 0.69444, 0, 0, 0.53056],
    108: [0, 0.69444, 0, 0, 0.25556],
    109: [0, 0.45833, 0, 0, 0.86667],
    110: [0, 0.45833, 0, 0, 0.56111],
    111: [0, 0.45833, 0, 0, 0.55],
    112: [0.19444, 0.45833, 0, 0, 0.56111],
    113: [0.19444, 0.45833, 0, 0, 0.56111],
    114: [0, 0.45833, 0.01528, 0, 0.37222],
    115: [0, 0.45833, 0, 0, 0.42167],
    116: [0, 0.58929, 0, 0, 0.40417],
    117: [0, 0.45833, 0, 0, 0.56111],
    118: [0, 0.45833, 0.01528, 0, 0.5],
    119: [0, 0.45833, 0.01528, 0, 0.74445],
    120: [0, 0.45833, 0, 0, 0.5],
    121: [0.19444, 0.45833, 0.01528, 0, 0.5],
    122: [0, 0.45833, 0, 0, 0.47639],
    126: [0.35, 0.34444, 0, 0, 0.55],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0, 0, 0.55],
    176: [0, 0.69444, 0, 0, 0.73334],
    180: [0, 0.69444, 0, 0, 0.55],
    184: [0.17014, 0, 0, 0, 0.48889],
    305: [0, 0.45833, 0, 0, 0.25556],
    567: [0.19444, 0.45833, 0, 0, 0.28611],
    710: [0, 0.69444, 0, 0, 0.55],
    711: [0, 0.63542, 0, 0, 0.55],
    713: [0, 0.63778, 0, 0, 0.55],
    728: [0, 0.69444, 0, 0, 0.55],
    729: [0, 0.69444, 0, 0, 0.30556],
    730: [0, 0.69444, 0, 0, 0.73334],
    732: [0, 0.69444, 0, 0, 0.55],
    733: [0, 0.69444, 0, 0, 0.55],
    915: [0, 0.69444, 0, 0, 0.58056],
    916: [0, 0.69444, 0, 0, 0.91667],
    920: [0, 0.69444, 0, 0, 0.85556],
    923: [0, 0.69444, 0, 0, 0.67223],
    926: [0, 0.69444, 0, 0, 0.73334],
    928: [0, 0.69444, 0, 0, 0.79445],
    931: [0, 0.69444, 0, 0, 0.79445],
    933: [0, 0.69444, 0, 0, 0.85556],
    934: [0, 0.69444, 0, 0, 0.79445],
    936: [0, 0.69444, 0, 0, 0.85556],
    937: [0, 0.69444, 0, 0, 0.79445],
    8211: [0, 0.45833, 0.03056, 0, 0.55],
    8212: [0, 0.45833, 0.03056, 0, 1.10001],
    8216: [0, 0.69444, 0, 0, 0.30556],
    8217: [0, 0.69444, 0, 0, 0.30556],
    8220: [0, 0.69444, 0, 0, 0.55834],
    8221: [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.05733, 0, 0.31945],
    34: [0, 0.69444, 316e-5, 0, 0.5],
    35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
    36: [0.05556, 0.75, 0.11156, 0, 0.5],
    37: [0.05556, 0.75, 0.03126, 0, 0.83334],
    38: [0, 0.69444, 0.03058, 0, 0.75834],
    39: [0, 0.69444, 0.07816, 0, 0.27778],
    40: [0.25, 0.75, 0.13164, 0, 0.38889],
    41: [0.25, 0.75, 0.02536, 0, 0.38889],
    42: [0, 0.75, 0.11775, 0, 0.5],
    43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0.01946, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0.13164, 0, 0.5],
    48: [0, 0.65556, 0.11156, 0, 0.5],
    49: [0, 0.65556, 0.11156, 0, 0.5],
    50: [0, 0.65556, 0.11156, 0, 0.5],
    51: [0, 0.65556, 0.11156, 0, 0.5],
    52: [0, 0.65556, 0.11156, 0, 0.5],
    53: [0, 0.65556, 0.11156, 0, 0.5],
    54: [0, 0.65556, 0.11156, 0, 0.5],
    55: [0, 0.65556, 0.11156, 0, 0.5],
    56: [0, 0.65556, 0.11156, 0, 0.5],
    57: [0, 0.65556, 0.11156, 0, 0.5],
    58: [0, 0.44444, 0.02502, 0, 0.27778],
    59: [0.125, 0.44444, 0.02502, 0, 0.27778],
    61: [-0.13, 0.37, 0.05087, 0, 0.77778],
    63: [0, 0.69444, 0.11809, 0, 0.47222],
    64: [0, 0.69444, 0.07555, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0.08293, 0, 0.66667],
    67: [0, 0.69444, 0.11983, 0, 0.63889],
    68: [0, 0.69444, 0.07555, 0, 0.72223],
    69: [0, 0.69444, 0.11983, 0, 0.59722],
    70: [0, 0.69444, 0.13372, 0, 0.56945],
    71: [0, 0.69444, 0.11983, 0, 0.66667],
    72: [0, 0.69444, 0.08094, 0, 0.70834],
    73: [0, 0.69444, 0.13372, 0, 0.27778],
    74: [0, 0.69444, 0.08094, 0, 0.47222],
    75: [0, 0.69444, 0.11983, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0.08094, 0, 0.875],
    78: [0, 0.69444, 0.08094, 0, 0.70834],
    79: [0, 0.69444, 0.07555, 0, 0.73611],
    80: [0, 0.69444, 0.08293, 0, 0.63889],
    81: [0.125, 0.69444, 0.07555, 0, 0.73611],
    82: [0, 0.69444, 0.08293, 0, 0.64584],
    83: [0, 0.69444, 0.09205, 0, 0.55556],
    84: [0, 0.69444, 0.13372, 0, 0.68056],
    85: [0, 0.69444, 0.08094, 0, 0.6875],
    86: [0, 0.69444, 0.1615, 0, 0.66667],
    87: [0, 0.69444, 0.1615, 0, 0.94445],
    88: [0, 0.69444, 0.13372, 0, 0.66667],
    89: [0, 0.69444, 0.17261, 0, 0.66667],
    90: [0, 0.69444, 0.11983, 0, 0.61111],
    91: [0.25, 0.75, 0.15942, 0, 0.28889],
    93: [0.25, 0.75, 0.08719, 0, 0.28889],
    94: [0, 0.69444, 0.0799, 0, 0.5],
    95: [0.35, 0.09444, 0.08616, 0, 0.5],
    97: [0, 0.44444, 981e-5, 0, 0.48056],
    98: [0, 0.69444, 0.03057, 0, 0.51667],
    99: [0, 0.44444, 0.08336, 0, 0.44445],
    100: [0, 0.69444, 0.09483, 0, 0.51667],
    101: [0, 0.44444, 0.06778, 0, 0.44445],
    102: [0, 0.69444, 0.21705, 0, 0.30556],
    103: [0.19444, 0.44444, 0.10836, 0, 0.5],
    104: [0, 0.69444, 0.01778, 0, 0.51667],
    105: [0, 0.67937, 0.09718, 0, 0.23889],
    106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
    107: [0, 0.69444, 0.08336, 0, 0.48889],
    108: [0, 0.69444, 0.09483, 0, 0.23889],
    109: [0, 0.44444, 0.01778, 0, 0.79445],
    110: [0, 0.44444, 0.01778, 0, 0.51667],
    111: [0, 0.44444, 0.06613, 0, 0.5],
    112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
    113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
    114: [0, 0.44444, 0.10836, 0, 0.34167],
    115: [0, 0.44444, 0.0778, 0, 0.38333],
    116: [0, 0.57143, 0.07225, 0, 0.36111],
    117: [0, 0.44444, 0.04169, 0, 0.51667],
    118: [0, 0.44444, 0.10836, 0, 0.46111],
    119: [0, 0.44444, 0.10836, 0, 0.68334],
    120: [0, 0.44444, 0.09169, 0, 0.46111],
    121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
    122: [0, 0.44444, 0.08752, 0, 0.43472],
    126: [0.35, 0.32659, 0.08826, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0.06385, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.73752],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0.04169, 0, 0.23889],
    567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
    710: [0, 0.69444, 0.0799, 0, 0.5],
    711: [0, 0.63194, 0.08432, 0, 0.5],
    713: [0, 0.60889, 0.08776, 0, 0.5],
    714: [0, 0.69444, 0.09205, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0.09483, 0, 0.5],
    729: [0, 0.67937, 0.07774, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.73752],
    732: [0, 0.67659, 0.08826, 0, 0.5],
    733: [0, 0.69444, 0.09205, 0, 0.5],
    915: [0, 0.69444, 0.13372, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0.07555, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0.12816, 0, 0.66667],
    928: [0, 0.69444, 0.08094, 0, 0.70834],
    931: [0, 0.69444, 0.11983, 0, 0.72222],
    933: [0, 0.69444, 0.09031, 0, 0.77778],
    934: [0, 0.69444, 0.04603, 0, 0.72222],
    936: [0, 0.69444, 0.09031, 0, 0.77778],
    937: [0, 0.69444, 0.08293, 0, 0.72222],
    8211: [0, 0.44444, 0.08616, 0, 0.5],
    8212: [0, 0.44444, 0.08616, 0, 1],
    8216: [0, 0.69444, 0.07816, 0, 0.27778],
    8217: [0, 0.69444, 0.07816, 0, 0.27778],
    8220: [0, 0.69444, 0.14205, 0, 0.5],
    8221: [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.31945],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.75834],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.65556, 0, 0, 0.5],
    49: [0, 0.65556, 0, 0, 0.5],
    50: [0, 0.65556, 0, 0, 0.5],
    51: [0, 0.65556, 0, 0, 0.5],
    52: [0, 0.65556, 0, 0, 0.5],
    53: [0, 0.65556, 0, 0, 0.5],
    54: [0, 0.65556, 0, 0, 0.5],
    55: [0, 0.65556, 0, 0, 0.5],
    56: [0, 0.65556, 0, 0, 0.5],
    57: [0, 0.65556, 0, 0, 0.5],
    58: [0, 0.44444, 0, 0, 0.27778],
    59: [0.125, 0.44444, 0, 0, 0.27778],
    61: [-0.13, 0.37, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0, 0, 0.66667],
    67: [0, 0.69444, 0, 0, 0.63889],
    68: [0, 0.69444, 0, 0, 0.72223],
    69: [0, 0.69444, 0, 0, 0.59722],
    70: [0, 0.69444, 0, 0, 0.56945],
    71: [0, 0.69444, 0, 0, 0.66667],
    72: [0, 0.69444, 0, 0, 0.70834],
    73: [0, 0.69444, 0, 0, 0.27778],
    74: [0, 0.69444, 0, 0, 0.47222],
    75: [0, 0.69444, 0, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0, 0, 0.875],
    78: [0, 0.69444, 0, 0, 0.70834],
    79: [0, 0.69444, 0, 0, 0.73611],
    80: [0, 0.69444, 0, 0, 0.63889],
    81: [0.125, 0.69444, 0, 0, 0.73611],
    82: [0, 0.69444, 0, 0, 0.64584],
    83: [0, 0.69444, 0, 0, 0.55556],
    84: [0, 0.69444, 0, 0, 0.68056],
    85: [0, 0.69444, 0, 0, 0.6875],
    86: [0, 0.69444, 0.01389, 0, 0.66667],
    87: [0, 0.69444, 0.01389, 0, 0.94445],
    88: [0, 0.69444, 0, 0, 0.66667],
    89: [0, 0.69444, 0.025, 0, 0.66667],
    90: [0, 0.69444, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.28889],
    93: [0.25, 0.75, 0, 0, 0.28889],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.35, 0.09444, 0.02778, 0, 0.5],
    97: [0, 0.44444, 0, 0, 0.48056],
    98: [0, 0.69444, 0, 0, 0.51667],
    99: [0, 0.44444, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.51667],
    101: [0, 0.44444, 0, 0, 0.44445],
    102: [0, 0.69444, 0.06944, 0, 0.30556],
    103: [0.19444, 0.44444, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.51667],
    105: [0, 0.67937, 0, 0, 0.23889],
    106: [0.19444, 0.67937, 0, 0, 0.26667],
    107: [0, 0.69444, 0, 0, 0.48889],
    108: [0, 0.69444, 0, 0, 0.23889],
    109: [0, 0.44444, 0, 0, 0.79445],
    110: [0, 0.44444, 0, 0, 0.51667],
    111: [0, 0.44444, 0, 0, 0.5],
    112: [0.19444, 0.44444, 0, 0, 0.51667],
    113: [0.19444, 0.44444, 0, 0, 0.51667],
    114: [0, 0.44444, 0.01389, 0, 0.34167],
    115: [0, 0.44444, 0, 0, 0.38333],
    116: [0, 0.57143, 0, 0, 0.36111],
    117: [0, 0.44444, 0, 0, 0.51667],
    118: [0, 0.44444, 0.01389, 0, 0.46111],
    119: [0, 0.44444, 0.01389, 0, 0.68334],
    120: [0, 0.44444, 0, 0, 0.46111],
    121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
    122: [0, 0.44444, 0, 0, 0.43472],
    126: [0.35, 0.32659, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.66667],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0, 0, 0.23889],
    567: [0.19444, 0.44444, 0, 0, 0.26667],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.63194, 0, 0, 0.5],
    713: [0, 0.60889, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.67937, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.66667],
    732: [0, 0.67659, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.69444, 0, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0, 0, 0.66667],
    928: [0, 0.69444, 0, 0, 0.70834],
    931: [0, 0.69444, 0, 0, 0.72222],
    933: [0, 0.69444, 0, 0, 0.77778],
    934: [0, 0.69444, 0, 0, 0.72222],
    936: [0, 0.69444, 0, 0, 0.77778],
    937: [0, 0.69444, 0, 0, 0.72222],
    8211: [0, 0.44444, 0.02778, 0, 0.5],
    8212: [0, 0.44444, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.7, 0.22925, 0, 0.80253],
    66: [0, 0.7, 0.04087, 0, 0.90757],
    67: [0, 0.7, 0.1689, 0, 0.66619],
    68: [0, 0.7, 0.09371, 0, 0.77443],
    69: [0, 0.7, 0.18583, 0, 0.56162],
    70: [0, 0.7, 0.13634, 0, 0.89544],
    71: [0, 0.7, 0.17322, 0, 0.60961],
    72: [0, 0.7, 0.29694, 0, 0.96919],
    73: [0, 0.7, 0.19189, 0, 0.80907],
    74: [0.27778, 0.7, 0.19189, 0, 1.05159],
    75: [0, 0.7, 0.31259, 0, 0.91364],
    76: [0, 0.7, 0.19189, 0, 0.87373],
    77: [0, 0.7, 0.15981, 0, 1.08031],
    78: [0, 0.7, 0.3525, 0, 0.9015],
    79: [0, 0.7, 0.08078, 0, 0.73787],
    80: [0, 0.7, 0.08078, 0, 1.01262],
    81: [0, 0.7, 0.03305, 0, 0.88282],
    82: [0, 0.7, 0.06259, 0, 0.85],
    83: [0, 0.7, 0.19189, 0, 0.86767],
    84: [0, 0.7, 0.29087, 0, 0.74697],
    85: [0, 0.7, 0.25815, 0, 0.79996],
    86: [0, 0.7, 0.27523, 0, 0.62204],
    87: [0, 0.7, 0.27523, 0, 0.80532],
    88: [0, 0.7, 0.26006, 0, 0.94445],
    89: [0, 0.7, 0.2939, 0, 0.70961],
    90: [0, 0.7, 0.24037, 0, 0.8212],
    160: [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.35001, 0.85, 0, 0, 0.45834],
    41: [0.35001, 0.85, 0, 0, 0.45834],
    47: [0.35001, 0.85, 0, 0, 0.57778],
    91: [0.35001, 0.85, 0, 0, 0.41667],
    92: [0.35001, 0.85, 0, 0, 0.57778],
    93: [0.35001, 0.85, 0, 0, 0.41667],
    123: [0.35001, 0.85, 0, 0, 0.58334],
    125: [0.35001, 0.85, 0, 0, 0.58334],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.72222, 0, 0, 0.55556],
    732: [0, 0.72222, 0, 0, 0.55556],
    770: [0, 0.72222, 0, 0, 0.55556],
    771: [0, 0.72222, 0, 0, 0.55556],
    8214: [-99e-5, 0.601, 0, 0, 0.77778],
    8593: [1e-5, 0.6, 0, 0, 0.66667],
    8595: [1e-5, 0.6, 0, 0, 0.66667],
    8657: [1e-5, 0.6, 0, 0, 0.77778],
    8659: [1e-5, 0.6, 0, 0, 0.77778],
    8719: [0.25001, 0.75, 0, 0, 0.94445],
    8720: [0.25001, 0.75, 0, 0, 0.94445],
    8721: [0.25001, 0.75, 0, 0, 1.05556],
    8730: [0.35001, 0.85, 0, 0, 1],
    8739: [-599e-5, 0.606, 0, 0, 0.33333],
    8741: [-599e-5, 0.606, 0, 0, 0.55556],
    8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8748: [0.306, 0.805, 0.19445, 0, 0.47222],
    8749: [0.306, 0.805, 0.19445, 0, 0.47222],
    8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8896: [0.25001, 0.75, 0, 0, 0.83334],
    8897: [0.25001, 0.75, 0, 0, 0.83334],
    8898: [0.25001, 0.75, 0, 0, 0.83334],
    8899: [0.25001, 0.75, 0, 0, 0.83334],
    8968: [0.35001, 0.85, 0, 0, 0.47222],
    8969: [0.35001, 0.85, 0, 0, 0.47222],
    8970: [0.35001, 0.85, 0, 0, 0.47222],
    8971: [0.35001, 0.85, 0, 0, 0.47222],
    9168: [-99e-5, 0.601, 0, 0, 0.66667],
    10216: [0.35001, 0.85, 0, 0, 0.47222],
    10217: [0.35001, 0.85, 0, 0, 0.47222],
    10752: [0.25001, 0.75, 0, 0, 1.11111],
    10753: [0.25001, 0.75, 0, 0, 1.11111],
    10754: [0.25001, 0.75, 0, 0, 1.11111],
    10756: [0.25001, 0.75, 0, 0, 0.83334],
    10758: [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.65002, 1.15, 0, 0, 0.59722],
    41: [0.65002, 1.15, 0, 0, 0.59722],
    47: [0.65002, 1.15, 0, 0, 0.81111],
    91: [0.65002, 1.15, 0, 0, 0.47222],
    92: [0.65002, 1.15, 0, 0, 0.81111],
    93: [0.65002, 1.15, 0, 0, 0.47222],
    123: [0.65002, 1.15, 0, 0, 0.66667],
    125: [0.65002, 1.15, 0, 0, 0.66667],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1],
    732: [0, 0.75, 0, 0, 1],
    770: [0, 0.75, 0, 0, 1],
    771: [0, 0.75, 0, 0, 1],
    8719: [0.55001, 1.05, 0, 0, 1.27778],
    8720: [0.55001, 1.05, 0, 0, 1.27778],
    8721: [0.55001, 1.05, 0, 0, 1.44445],
    8730: [0.65002, 1.15, 0, 0, 1],
    8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8748: [0.862, 1.36, 0.44445, 0, 0.55556],
    8749: [0.862, 1.36, 0.44445, 0, 0.55556],
    8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8896: [0.55001, 1.05, 0, 0, 1.11111],
    8897: [0.55001, 1.05, 0, 0, 1.11111],
    8898: [0.55001, 1.05, 0, 0, 1.11111],
    8899: [0.55001, 1.05, 0, 0, 1.11111],
    8968: [0.65002, 1.15, 0, 0, 0.52778],
    8969: [0.65002, 1.15, 0, 0, 0.52778],
    8970: [0.65002, 1.15, 0, 0, 0.52778],
    8971: [0.65002, 1.15, 0, 0, 0.52778],
    10216: [0.65002, 1.15, 0, 0, 0.61111],
    10217: [0.65002, 1.15, 0, 0, 0.61111],
    10752: [0.55001, 1.05, 0, 0, 1.51112],
    10753: [0.55001, 1.05, 0, 0, 1.51112],
    10754: [0.55001, 1.05, 0, 0, 1.51112],
    10756: [0.55001, 1.05, 0, 0, 1.11111],
    10758: [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.95003, 1.45, 0, 0, 0.73611],
    41: [0.95003, 1.45, 0, 0, 0.73611],
    47: [0.95003, 1.45, 0, 0, 1.04445],
    91: [0.95003, 1.45, 0, 0, 0.52778],
    92: [0.95003, 1.45, 0, 0, 1.04445],
    93: [0.95003, 1.45, 0, 0, 0.52778],
    123: [0.95003, 1.45, 0, 0, 0.75],
    125: [0.95003, 1.45, 0, 0, 0.75],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1.44445],
    732: [0, 0.75, 0, 0, 1.44445],
    770: [0, 0.75, 0, 0, 1.44445],
    771: [0, 0.75, 0, 0, 1.44445],
    8730: [0.95003, 1.45, 0, 0, 1],
    8968: [0.95003, 1.45, 0, 0, 0.58334],
    8969: [0.95003, 1.45, 0, 0, 0.58334],
    8970: [0.95003, 1.45, 0, 0, 0.58334],
    8971: [0.95003, 1.45, 0, 0, 0.58334],
    10216: [0.95003, 1.45, 0, 0, 0.75],
    10217: [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [1.25003, 1.75, 0, 0, 0.79167],
    41: [1.25003, 1.75, 0, 0, 0.79167],
    47: [1.25003, 1.75, 0, 0, 1.27778],
    91: [1.25003, 1.75, 0, 0, 0.58334],
    92: [1.25003, 1.75, 0, 0, 1.27778],
    93: [1.25003, 1.75, 0, 0, 0.58334],
    123: [1.25003, 1.75, 0, 0, 0.80556],
    125: [1.25003, 1.75, 0, 0, 0.80556],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.825, 0, 0, 1.8889],
    732: [0, 0.825, 0, 0, 1.8889],
    770: [0, 0.825, 0, 0, 1.8889],
    771: [0, 0.825, 0, 0, 1.8889],
    8730: [1.25003, 1.75, 0, 0, 1],
    8968: [1.25003, 1.75, 0, 0, 0.63889],
    8969: [1.25003, 1.75, 0, 0, 0.63889],
    8970: [1.25003, 1.75, 0, 0, 0.63889],
    8971: [1.25003, 1.75, 0, 0, 0.63889],
    9115: [0.64502, 1.155, 0, 0, 0.875],
    9116: [1e-5, 0.6, 0, 0, 0.875],
    9117: [0.64502, 1.155, 0, 0, 0.875],
    9118: [0.64502, 1.155, 0, 0, 0.875],
    9119: [1e-5, 0.6, 0, 0, 0.875],
    9120: [0.64502, 1.155, 0, 0, 0.875],
    9121: [0.64502, 1.155, 0, 0, 0.66667],
    9122: [-99e-5, 0.601, 0, 0, 0.66667],
    9123: [0.64502, 1.155, 0, 0, 0.66667],
    9124: [0.64502, 1.155, 0, 0, 0.66667],
    9125: [-99e-5, 0.601, 0, 0, 0.66667],
    9126: [0.64502, 1.155, 0, 0, 0.66667],
    9127: [1e-5, 0.9, 0, 0, 0.88889],
    9128: [0.65002, 1.15, 0, 0, 0.88889],
    9129: [0.90001, 0, 0, 0, 0.88889],
    9130: [0, 0.3, 0, 0, 0.88889],
    9131: [1e-5, 0.9, 0, 0, 0.88889],
    9132: [0.65002, 1.15, 0, 0, 0.88889],
    9133: [0.90001, 0, 0, 0, 0.88889],
    9143: [0.88502, 0.915, 0, 0, 1.05556],
    10216: [1.25003, 1.75, 0, 0, 0.80556],
    10217: [1.25003, 1.75, 0, 0, 0.80556],
    57344: [-499e-5, 0.605, 0, 0, 1.05556],
    57345: [-499e-5, 0.605, 0, 0, 1.05556],
    57680: [0, 0.12, 0, 0, 0.45],
    57681: [0, 0.12, 0, 0, 0.45],
    57682: [0, 0.12, 0, 0, 0.45],
    57683: [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    32: [0, 0, 0, 0, 0.525],
    33: [0, 0.61111, 0, 0, 0.525],
    34: [0, 0.61111, 0, 0, 0.525],
    35: [0, 0.61111, 0, 0, 0.525],
    36: [0.08333, 0.69444, 0, 0, 0.525],
    37: [0.08333, 0.69444, 0, 0, 0.525],
    38: [0, 0.61111, 0, 0, 0.525],
    39: [0, 0.61111, 0, 0, 0.525],
    40: [0.08333, 0.69444, 0, 0, 0.525],
    41: [0.08333, 0.69444, 0, 0, 0.525],
    42: [0, 0.52083, 0, 0, 0.525],
    43: [-0.08056, 0.53055, 0, 0, 0.525],
    44: [0.13889, 0.125, 0, 0, 0.525],
    45: [-0.08056, 0.53055, 0, 0, 0.525],
    46: [0, 0.125, 0, 0, 0.525],
    47: [0.08333, 0.69444, 0, 0, 0.525],
    48: [0, 0.61111, 0, 0, 0.525],
    49: [0, 0.61111, 0, 0, 0.525],
    50: [0, 0.61111, 0, 0, 0.525],
    51: [0, 0.61111, 0, 0, 0.525],
    52: [0, 0.61111, 0, 0, 0.525],
    53: [0, 0.61111, 0, 0, 0.525],
    54: [0, 0.61111, 0, 0, 0.525],
    55: [0, 0.61111, 0, 0, 0.525],
    56: [0, 0.61111, 0, 0, 0.525],
    57: [0, 0.61111, 0, 0, 0.525],
    58: [0, 0.43056, 0, 0, 0.525],
    59: [0.13889, 0.43056, 0, 0, 0.525],
    60: [-0.05556, 0.55556, 0, 0, 0.525],
    61: [-0.19549, 0.41562, 0, 0, 0.525],
    62: [-0.05556, 0.55556, 0, 0, 0.525],
    63: [0, 0.61111, 0, 0, 0.525],
    64: [0, 0.61111, 0, 0, 0.525],
    65: [0, 0.61111, 0, 0, 0.525],
    66: [0, 0.61111, 0, 0, 0.525],
    67: [0, 0.61111, 0, 0, 0.525],
    68: [0, 0.61111, 0, 0, 0.525],
    69: [0, 0.61111, 0, 0, 0.525],
    70: [0, 0.61111, 0, 0, 0.525],
    71: [0, 0.61111, 0, 0, 0.525],
    72: [0, 0.61111, 0, 0, 0.525],
    73: [0, 0.61111, 0, 0, 0.525],
    74: [0, 0.61111, 0, 0, 0.525],
    75: [0, 0.61111, 0, 0, 0.525],
    76: [0, 0.61111, 0, 0, 0.525],
    77: [0, 0.61111, 0, 0, 0.525],
    78: [0, 0.61111, 0, 0, 0.525],
    79: [0, 0.61111, 0, 0, 0.525],
    80: [0, 0.61111, 0, 0, 0.525],
    81: [0.13889, 0.61111, 0, 0, 0.525],
    82: [0, 0.61111, 0, 0, 0.525],
    83: [0, 0.61111, 0, 0, 0.525],
    84: [0, 0.61111, 0, 0, 0.525],
    85: [0, 0.61111, 0, 0, 0.525],
    86: [0, 0.61111, 0, 0, 0.525],
    87: [0, 0.61111, 0, 0, 0.525],
    88: [0, 0.61111, 0, 0, 0.525],
    89: [0, 0.61111, 0, 0, 0.525],
    90: [0, 0.61111, 0, 0, 0.525],
    91: [0.08333, 0.69444, 0, 0, 0.525],
    92: [0.08333, 0.69444, 0, 0, 0.525],
    93: [0.08333, 0.69444, 0, 0, 0.525],
    94: [0, 0.61111, 0, 0, 0.525],
    95: [0.09514, 0, 0, 0, 0.525],
    96: [0, 0.61111, 0, 0, 0.525],
    97: [0, 0.43056, 0, 0, 0.525],
    98: [0, 0.61111, 0, 0, 0.525],
    99: [0, 0.43056, 0, 0, 0.525],
    100: [0, 0.61111, 0, 0, 0.525],
    101: [0, 0.43056, 0, 0, 0.525],
    102: [0, 0.61111, 0, 0, 0.525],
    103: [0.22222, 0.43056, 0, 0, 0.525],
    104: [0, 0.61111, 0, 0, 0.525],
    105: [0, 0.61111, 0, 0, 0.525],
    106: [0.22222, 0.61111, 0, 0, 0.525],
    107: [0, 0.61111, 0, 0, 0.525],
    108: [0, 0.61111, 0, 0, 0.525],
    109: [0, 0.43056, 0, 0, 0.525],
    110: [0, 0.43056, 0, 0, 0.525],
    111: [0, 0.43056, 0, 0, 0.525],
    112: [0.22222, 0.43056, 0, 0, 0.525],
    113: [0.22222, 0.43056, 0, 0, 0.525],
    114: [0, 0.43056, 0, 0, 0.525],
    115: [0, 0.43056, 0, 0, 0.525],
    116: [0, 0.55358, 0, 0, 0.525],
    117: [0, 0.43056, 0, 0, 0.525],
    118: [0, 0.43056, 0, 0, 0.525],
    119: [0, 0.43056, 0, 0, 0.525],
    120: [0, 0.43056, 0, 0, 0.525],
    121: [0.22222, 0.43056, 0, 0, 0.525],
    122: [0, 0.43056, 0, 0, 0.525],
    123: [0.08333, 0.69444, 0, 0, 0.525],
    124: [0.08333, 0.69444, 0, 0, 0.525],
    125: [0.08333, 0.69444, 0, 0, 0.525],
    126: [0, 0.61111, 0, 0, 0.525],
    127: [0, 0.61111, 0, 0, 0.525],
    160: [0, 0, 0, 0, 0.525],
    176: [0, 0.61111, 0, 0, 0.525],
    184: [0.19445, 0, 0, 0, 0.525],
    305: [0, 0.43056, 0, 0, 0.525],
    567: [0.22222, 0.43056, 0, 0, 0.525],
    711: [0, 0.56597, 0, 0, 0.525],
    713: [0, 0.56555, 0, 0, 0.525],
    714: [0, 0.61111, 0, 0, 0.525],
    715: [0, 0.61111, 0, 0, 0.525],
    728: [0, 0.61111, 0, 0, 0.525],
    730: [0, 0.61111, 0, 0, 0.525],
    770: [0, 0.61111, 0, 0, 0.525],
    771: [0, 0.61111, 0, 0, 0.525],
    776: [0, 0.61111, 0, 0, 0.525],
    915: [0, 0.61111, 0, 0, 0.525],
    916: [0, 0.61111, 0, 0, 0.525],
    920: [0, 0.61111, 0, 0, 0.525],
    923: [0, 0.61111, 0, 0, 0.525],
    926: [0, 0.61111, 0, 0, 0.525],
    928: [0, 0.61111, 0, 0, 0.525],
    931: [0, 0.61111, 0, 0, 0.525],
    933: [0, 0.61111, 0, 0, 0.525],
    934: [0, 0.61111, 0, 0, 0.525],
    936: [0, 0.61111, 0, 0, 0.525],
    937: [0, 0.61111, 0, 0, 0.525],
    8216: [0, 0.61111, 0, 0, 0.525],
    8217: [0, 0.61111, 0, 0, 0.525],
    8242: [0, 0.61111, 0, 0, 0.525],
    9251: [0.11111, 0.21944, 0, 0, 0.525]
  }
}, u1 = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.scss; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
}, zv = {
  // Latin-1
  Å: "A",
  Ð: "D",
  Þ: "o",
  å: "a",
  ð: "d",
  þ: "o",
  // Cyrillic
  А: "A",
  Б: "B",
  В: "B",
  Г: "F",
  Д: "A",
  Е: "E",
  Ж: "K",
  З: "3",
  И: "N",
  Й: "N",
  К: "K",
  Л: "N",
  М: "M",
  Н: "H",
  О: "O",
  П: "N",
  Р: "P",
  С: "C",
  Т: "T",
  У: "y",
  Ф: "O",
  Х: "X",
  Ц: "U",
  Ч: "h",
  Ш: "W",
  Щ: "W",
  Ъ: "B",
  Ы: "X",
  Ь: "B",
  Э: "3",
  Ю: "X",
  Я: "R",
  а: "a",
  б: "b",
  в: "a",
  г: "r",
  д: "y",
  е: "e",
  ж: "m",
  з: "e",
  и: "n",
  й: "n",
  к: "n",
  л: "n",
  м: "m",
  н: "n",
  о: "o",
  п: "n",
  р: "p",
  с: "c",
  т: "o",
  у: "y",
  ф: "b",
  х: "x",
  ц: "n",
  ч: "n",
  ш: "w",
  щ: "w",
  ъ: "a",
  ы: "m",
  ь: "a",
  э: "e",
  ю: "m",
  я: "r"
};
function oM(e, t) {
  pl[e] = t;
}
function Tb(e, t, n) {
  if (!pl[t])
    throw new Error("Font metrics not found for font: " + t + ".");
  var r = e.charCodeAt(0), i = pl[t][r];
  if (!i && e[0] in zv && (r = zv[e[0]].charCodeAt(0), i = pl[t][r]), !i && n === "text" && sM(r) && (i = pl[t][77]), i)
    return {
      depth: i[0],
      height: i[1],
      italic: i[2],
      skew: i[3],
      width: i[4]
    };
}
var n6 = {};
function Qz(e) {
  var t;
  if (e >= 5 ? t = 0 : e >= 3 ? t = 1 : t = 2, !n6[t]) {
    var n = n6[t] = {
      cssEmPerMu: u1.quad[t] / 18
    };
    for (var r in u1)
      u1.hasOwnProperty(r) && (n[r] = u1[r][t]);
  }
  return n6[t];
}
var eB = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
], Bv = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
], Hv = function(t, n) {
  return n.size < 2 ? t : eB[t - 1][n.size - 1];
};
class Yl {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(t) {
    this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = t.style, this.color = t.color, this.size = t.size || Yl.BASESIZE, this.textSize = t.textSize || this.size, this.phantom = !!t.phantom, this.font = t.font || "", this.fontFamily = t.fontFamily || "", this.fontWeight = t.fontWeight || "", this.fontShape = t.fontShape || "", this.sizeMultiplier = Bv[this.size - 1], this.maxSize = t.maxSize, this.minRuleThickness = t.minRuleThickness, this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(t) {
    var n = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var r in t)
      t.hasOwnProperty(r) && (n[r] = t[r]);
    return new Yl(n);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(t) {
    return this.style === t ? this : this.extend({
      style: t,
      size: Hv(this.textSize, t)
    });
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(t) {
    return this.size === t && this.textSize === t ? this : this.extend({
      style: this.style.text(),
      size: t,
      textSize: t,
      sizeMultiplier: Bv[t - 1]
    });
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(t) {
    t = t || this.style.text();
    var n = Hv(Yl.BASESIZE, t);
    return this.size === n && this.textSize === Yl.BASESIZE && this.style === t ? this : this.extend({
      style: t,
      size: n
    });
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var t;
    switch (this.style.id) {
      case 4:
      case 5:
        t = 3;
        break;
      case 6:
      case 7:
        t = 1;
        break;
      default:
        t = 6;
    }
    return this.extend({
      style: this.style.text(),
      size: t
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(t) {
    return this.extend({
      color: t
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: !0
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(t) {
    return this.extend({
      font: t
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(t) {
    return this.extend({
      fontFamily: t,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(t) {
    return this.extend({
      fontWeight: t,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(t) {
    return this.extend({
      fontShape: t,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(t) {
    return t.size !== this.size ? ["sizing", "reset-size" + t.size, "size" + this.size] : [];
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    return this.size !== Yl.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + Yl.BASESIZE] : [];
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    return this._fontMetrics || (this._fontMetrics = Qz(this.size)), this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    return this.phantom ? "transparent" : this.color;
  }
}
Yl.BASESIZE = 6;
var C4 = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 1,
  // TeX point
  mm: 7227 / 2540,
  // millimeter
  cm: 7227 / 254,
  // centimeter
  in: 72.27,
  // inch
  bp: 803 / 800,
  // big (PostScript) points
  pc: 12,
  // pica
  dd: 1238 / 1157,
  // didot
  cc: 14856 / 1157,
  // cicero (12 didot)
  nd: 685 / 642,
  // new didot
  nc: 1370 / 107,
  // new cicero (12 new didot)
  sp: 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  px: 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
}, tB = {
  ex: !0,
  em: !0,
  mu: !0
}, cM = function(t) {
  return typeof t != "string" && (t = t.unit), t in C4 || t in tB || t === "ex";
}, Tn = function(t, n) {
  var r;
  if (t.unit in C4)
    r = C4[t.unit] / n.fontMetrics().ptPerEm / n.sizeMultiplier;
  else if (t.unit === "mu")
    r = n.fontMetrics().cssEmPerMu;
  else {
    var i;
    if (n.style.isTight() ? i = n.havingStyle(n.style.text()) : i = n, t.unit === "ex")
      r = i.fontMetrics().xHeight;
    else if (t.unit === "em")
      r = i.fontMetrics().quad;
    else
      throw new be("Invalid unit: '" + t.unit + "'");
    i !== n && (r *= i.sizeMultiplier / n.sizeMultiplier);
  }
  return Math.min(t.number * r, n.maxSize);
}, xe = function(t) {
  return +t.toFixed(4) + "em";
}, Uo = function(t) {
  return t.filter((n) => n).join(" ");
}, dM = function(t, n, r) {
  if (this.classes = t || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = r || {}, n) {
    n.style.isTight() && this.classes.push("mtight");
    var i = n.getColor();
    i && (this.style.color = i);
  }
}, uM = function(t) {
  var n = document.createElement(t);
  n.className = Uo(this.classes);
  for (var r in this.style)
    this.style.hasOwnProperty(r) && (n.style[r] = this.style[r]);
  for (var i in this.attributes)
    this.attributes.hasOwnProperty(i) && n.setAttribute(i, this.attributes[i]);
  for (var a = 0; a < this.children.length; a++)
    n.appendChild(this.children[a].toNode());
  return n;
}, nB = /[\s"'>/=\x00-\x1f]/, hM = function(t) {
  var n = "<" + t;
  this.classes.length && (n += ' class="' + We.escape(Uo(this.classes)) + '"');
  var r = "";
  for (var i in this.style)
    this.style.hasOwnProperty(i) && (r += We.hyphenate(i) + ":" + this.style[i] + ";");
  r && (n += ' style="' + We.escape(r) + '"');
  for (var a in this.attributes)
    if (this.attributes.hasOwnProperty(a)) {
      if (nB.test(a))
        throw new be("Invalid attribute name '" + a + "'");
      n += " " + a + '="' + We.escape(this.attributes[a]) + '"';
    }
  n += ">";
  for (var l = 0; l < this.children.length; l++)
    n += this.children[l].toMarkup();
  return n += "</" + t + ">", n;
};
class Af {
  constructor(t, n, r, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, dM.call(this, t, r, i), this.children = n || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(t, n) {
    this.attributes[t] = n;
  }
  hasClass(t) {
    return We.contains(this.classes, t);
  }
  toNode() {
    return uM.call(this, "span");
  }
  toMarkup() {
    return hM.call(this, "span");
  }
}
let Ib = class {
  constructor(t, n, r, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, dM.call(this, n, i), this.children = r || [], this.setAttribute("href", t);
  }
  setAttribute(t, n) {
    this.attributes[t] = n;
  }
  hasClass(t) {
    return We.contains(this.classes, t);
  }
  toNode() {
    return uM.call(this, "a");
  }
  toMarkup() {
    return hM.call(this, "a");
  }
};
class rB {
  constructor(t, n, r) {
    this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = n, this.src = t, this.classes = ["mord"], this.style = r;
  }
  hasClass(t) {
    return We.contains(this.classes, t);
  }
  toNode() {
    var t = document.createElement("img");
    t.src = this.src, t.alt = this.alt, t.className = "mord";
    for (var n in this.style)
      this.style.hasOwnProperty(n) && (t.style[n] = this.style[n]);
    return t;
  }
  toMarkup() {
    var t = '<img src="' + We.escape(this.src) + '"' + (' alt="' + We.escape(this.alt) + '"'), n = "";
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (n += We.hyphenate(r) + ":" + this.style[r] + ";");
    return n && (t += ' style="' + We.escape(n) + '"'), t += "'/>", t;
  }
}
var iB = {
  î: "ı̂",
  ï: "ı̈",
  í: "ı́",
  // 'ī': '\u0131\u0304', // enable when we add Extended Latin
  ì: "ı̀"
};
class Zi {
  constructor(t, n, r, i, a, l, s, c) {
    this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = t, this.height = n || 0, this.depth = r || 0, this.italic = i || 0, this.skew = a || 0, this.width = l || 0, this.classes = s || [], this.style = c || {}, this.maxFontSize = 0;
    var d = Hz(this.text.charCodeAt(0));
    d && this.classes.push(d + "_fallback"), /[îïíì]/.test(this.text) && (this.text = iB[this.text]);
  }
  hasClass(t) {
    return We.contains(this.classes, t);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var t = document.createTextNode(this.text), n = null;
    this.italic > 0 && (n = document.createElement("span"), n.style.marginRight = xe(this.italic)), this.classes.length > 0 && (n = n || document.createElement("span"), n.className = Uo(this.classes));
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (n = n || document.createElement("span"), n.style[r] = this.style[r]);
    return n ? (n.appendChild(t), n) : t;
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var t = !1, n = "<span";
    this.classes.length && (t = !0, n += ' class="', n += We.escape(Uo(this.classes)), n += '"');
    var r = "";
    this.italic > 0 && (r += "margin-right:" + this.italic + "em;");
    for (var i in this.style)
      this.style.hasOwnProperty(i) && (r += We.hyphenate(i) + ":" + this.style[i] + ";");
    r && (t = !0, n += ' style="' + We.escape(r) + '"');
    var a = We.escape(this.text);
    return t ? (n += ">", n += a, n += "</span>", n) : a;
  }
}
class fs {
  constructor(t, n) {
    this.children = void 0, this.attributes = void 0, this.children = t || [], this.attributes = n || {};
  }
  toNode() {
    var t = "http://www.w3.org/2000/svg", n = document.createElementNS(t, "svg");
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && n.setAttribute(r, this.attributes[r]);
    for (var i = 0; i < this.children.length; i++)
      n.appendChild(this.children[i].toNode());
    return n;
  }
  toMarkup() {
    var t = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && (t += " " + n + '="' + We.escape(this.attributes[n]) + '"');
    t += ">";
    for (var r = 0; r < this.children.length; r++)
      t += this.children[r].toMarkup();
    return t += "</svg>", t;
  }
}
class vo {
  constructor(t, n) {
    this.pathName = void 0, this.alternate = void 0, this.pathName = t, this.alternate = n;
  }
  toNode() {
    var t = "http://www.w3.org/2000/svg", n = document.createElementNS(t, "path");
    return this.alternate ? n.setAttribute("d", this.alternate) : n.setAttribute("d", Fv[this.pathName]), n;
  }
  toMarkup() {
    return this.alternate ? '<path d="' + We.escape(this.alternate) + '"/>' : '<path d="' + We.escape(Fv[this.pathName]) + '"/>';
  }
}
class M4 {
  constructor(t) {
    this.attributes = void 0, this.attributes = t || {};
  }
  toNode() {
    var t = "http://www.w3.org/2000/svg", n = document.createElementNS(t, "line");
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && n.setAttribute(r, this.attributes[r]);
    return n;
  }
  toMarkup() {
    var t = "<line";
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && (t += " " + n + '="' + We.escape(this.attributes[n]) + '"');
    return t += "/>", t;
  }
}
function Wv(e) {
  if (e instanceof Zi)
    return e;
  throw new Error("Expected symbolNode but got " + String(e) + ".");
}
function aB(e) {
  if (e instanceof Af)
    return e;
  throw new Error("Expected span<HtmlDomNode> but got " + String(e) + ".");
}
var lB = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
}, sB = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
}, cn = {
  math: {},
  text: {}
};
function C(e, t, n, r, i, a) {
  cn[e][i] = {
    font: t,
    group: n,
    replace: r
  }, a && r && (cn[e][r] = cn[e][i]);
}
var I = "math", ue = "text", P = "main", X = "ams", Sn = "accent-token", Ae = "bin", qr = "close", G0 = "inner", je = "mathord", nr = "op-token", Di = "open", Ng = "punct", G = "rel", Ts = "spacing", K = "textord";
C(I, P, G, "≡", "\\equiv", !0);
C(I, P, G, "≺", "\\prec", !0);
C(I, P, G, "≻", "\\succ", !0);
C(I, P, G, "∼", "\\sim", !0);
C(I, P, G, "⊥", "\\perp");
C(I, P, G, "⪯", "\\preceq", !0);
C(I, P, G, "⪰", "\\succeq", !0);
C(I, P, G, "≃", "\\simeq", !0);
C(I, P, G, "∣", "\\mid", !0);
C(I, P, G, "≪", "\\ll", !0);
C(I, P, G, "≫", "\\gg", !0);
C(I, P, G, "≍", "\\asymp", !0);
C(I, P, G, "∥", "\\parallel");
C(I, P, G, "⋈", "\\bowtie", !0);
C(I, P, G, "⌣", "\\smile", !0);
C(I, P, G, "⊑", "\\sqsubseteq", !0);
C(I, P, G, "⊒", "\\sqsupseteq", !0);
C(I, P, G, "≐", "\\doteq", !0);
C(I, P, G, "⌢", "\\frown", !0);
C(I, P, G, "∋", "\\ni", !0);
C(I, P, G, "∝", "\\propto", !0);
C(I, P, G, "⊢", "\\vdash", !0);
C(I, P, G, "⊣", "\\dashv", !0);
C(I, P, G, "∋", "\\owns");
C(I, P, Ng, ".", "\\ldotp");
C(I, P, Ng, "⋅", "\\cdotp");
C(I, P, K, "#", "\\#");
C(ue, P, K, "#", "\\#");
C(I, P, K, "&", "\\&");
C(ue, P, K, "&", "\\&");
C(I, P, K, "ℵ", "\\aleph", !0);
C(I, P, K, "∀", "\\forall", !0);
C(I, P, K, "ℏ", "\\hbar", !0);
C(I, P, K, "∃", "\\exists", !0);
C(I, P, K, "∇", "\\nabla", !0);
C(I, P, K, "♭", "\\flat", !0);
C(I, P, K, "ℓ", "\\ell", !0);
C(I, P, K, "♮", "\\natural", !0);
C(I, P, K, "♣", "\\clubsuit", !0);
C(I, P, K, "℘", "\\wp", !0);
C(I, P, K, "♯", "\\sharp", !0);
C(I, P, K, "♢", "\\diamondsuit", !0);
C(I, P, K, "ℜ", "\\Re", !0);
C(I, P, K, "♡", "\\heartsuit", !0);
C(I, P, K, "ℑ", "\\Im", !0);
C(I, P, K, "♠", "\\spadesuit", !0);
C(I, P, K, "§", "\\S", !0);
C(ue, P, K, "§", "\\S");
C(I, P, K, "¶", "\\P", !0);
C(ue, P, K, "¶", "\\P");
C(I, P, K, "†", "\\dag");
C(ue, P, K, "†", "\\dag");
C(ue, P, K, "†", "\\textdagger");
C(I, P, K, "‡", "\\ddag");
C(ue, P, K, "‡", "\\ddag");
C(ue, P, K, "‡", "\\textdaggerdbl");
C(I, P, qr, "⎱", "\\rmoustache", !0);
C(I, P, Di, "⎰", "\\lmoustache", !0);
C(I, P, qr, "⟯", "\\rgroup", !0);
C(I, P, Di, "⟮", "\\lgroup", !0);
C(I, P, Ae, "∓", "\\mp", !0);
C(I, P, Ae, "⊖", "\\ominus", !0);
C(I, P, Ae, "⊎", "\\uplus", !0);
C(I, P, Ae, "⊓", "\\sqcap", !0);
C(I, P, Ae, "∗", "\\ast");
C(I, P, Ae, "⊔", "\\sqcup", !0);
C(I, P, Ae, "◯", "\\bigcirc", !0);
C(I, P, Ae, "∙", "\\bullet", !0);
C(I, P, Ae, "‡", "\\ddagger");
C(I, P, Ae, "≀", "\\wr", !0);
C(I, P, Ae, "⨿", "\\amalg");
C(I, P, Ae, "&", "\\And");
C(I, P, G, "⟵", "\\longleftarrow", !0);
C(I, P, G, "⇐", "\\Leftarrow", !0);
C(I, P, G, "⟸", "\\Longleftarrow", !0);
C(I, P, G, "⟶", "\\longrightarrow", !0);
C(I, P, G, "⇒", "\\Rightarrow", !0);
C(I, P, G, "⟹", "\\Longrightarrow", !0);
C(I, P, G, "↔", "\\leftrightarrow", !0);
C(I, P, G, "⟷", "\\longleftrightarrow", !0);
C(I, P, G, "⇔", "\\Leftrightarrow", !0);
C(I, P, G, "⟺", "\\Longleftrightarrow", !0);
C(I, P, G, "↦", "\\mapsto", !0);
C(I, P, G, "⟼", "\\longmapsto", !0);
C(I, P, G, "↗", "\\nearrow", !0);
C(I, P, G, "↩", "\\hookleftarrow", !0);
C(I, P, G, "↪", "\\hookrightarrow", !0);
C(I, P, G, "↘", "\\searrow", !0);
C(I, P, G, "↼", "\\leftharpoonup", !0);
C(I, P, G, "⇀", "\\rightharpoonup", !0);
C(I, P, G, "↙", "\\swarrow", !0);
C(I, P, G, "↽", "\\leftharpoondown", !0);
C(I, P, G, "⇁", "\\rightharpoondown", !0);
C(I, P, G, "↖", "\\nwarrow", !0);
C(I, P, G, "⇌", "\\rightleftharpoons", !0);
C(I, X, G, "≮", "\\nless", !0);
C(I, X, G, "", "\\@nleqslant");
C(I, X, G, "", "\\@nleqq");
C(I, X, G, "⪇", "\\lneq", !0);
C(I, X, G, "≨", "\\lneqq", !0);
C(I, X, G, "", "\\@lvertneqq");
C(I, X, G, "⋦", "\\lnsim", !0);
C(I, X, G, "⪉", "\\lnapprox", !0);
C(I, X, G, "⊀", "\\nprec", !0);
C(I, X, G, "⋠", "\\npreceq", !0);
C(I, X, G, "⋨", "\\precnsim", !0);
C(I, X, G, "⪹", "\\precnapprox", !0);
C(I, X, G, "≁", "\\nsim", !0);
C(I, X, G, "", "\\@nshortmid");
C(I, X, G, "∤", "\\nmid", !0);
C(I, X, G, "⊬", "\\nvdash", !0);
C(I, X, G, "⊭", "\\nvDash", !0);
C(I, X, G, "⋪", "\\ntriangleleft");
C(I, X, G, "⋬", "\\ntrianglelefteq", !0);
C(I, X, G, "⊊", "\\subsetneq", !0);
C(I, X, G, "", "\\@varsubsetneq");
C(I, X, G, "⫋", "\\subsetneqq", !0);
C(I, X, G, "", "\\@varsubsetneqq");
C(I, X, G, "≯", "\\ngtr", !0);
C(I, X, G, "", "\\@ngeqslant");
C(I, X, G, "", "\\@ngeqq");
C(I, X, G, "⪈", "\\gneq", !0);
C(I, X, G, "≩", "\\gneqq", !0);
C(I, X, G, "", "\\@gvertneqq");
C(I, X, G, "⋧", "\\gnsim", !0);
C(I, X, G, "⪊", "\\gnapprox", !0);
C(I, X, G, "⊁", "\\nsucc", !0);
C(I, X, G, "⋡", "\\nsucceq", !0);
C(I, X, G, "⋩", "\\succnsim", !0);
C(I, X, G, "⪺", "\\succnapprox", !0);
C(I, X, G, "≆", "\\ncong", !0);
C(I, X, G, "", "\\@nshortparallel");
C(I, X, G, "∦", "\\nparallel", !0);
C(I, X, G, "⊯", "\\nVDash", !0);
C(I, X, G, "⋫", "\\ntriangleright");
C(I, X, G, "⋭", "\\ntrianglerighteq", !0);
C(I, X, G, "", "\\@nsupseteqq");
C(I, X, G, "⊋", "\\supsetneq", !0);
C(I, X, G, "", "\\@varsupsetneq");
C(I, X, G, "⫌", "\\supsetneqq", !0);
C(I, X, G, "", "\\@varsupsetneqq");
C(I, X, G, "⊮", "\\nVdash", !0);
C(I, X, G, "⪵", "\\precneqq", !0);
C(I, X, G, "⪶", "\\succneqq", !0);
C(I, X, G, "", "\\@nsubseteqq");
C(I, X, Ae, "⊴", "\\unlhd");
C(I, X, Ae, "⊵", "\\unrhd");
C(I, X, G, "↚", "\\nleftarrow", !0);
C(I, X, G, "↛", "\\nrightarrow", !0);
C(I, X, G, "⇍", "\\nLeftarrow", !0);
C(I, X, G, "⇏", "\\nRightarrow", !0);
C(I, X, G, "↮", "\\nleftrightarrow", !0);
C(I, X, G, "⇎", "\\nLeftrightarrow", !0);
C(I, X, G, "△", "\\vartriangle");
C(I, X, K, "ℏ", "\\hslash");
C(I, X, K, "▽", "\\triangledown");
C(I, X, K, "◊", "\\lozenge");
C(I, X, K, "Ⓢ", "\\circledS");
C(I, X, K, "®", "\\circledR");
C(ue, X, K, "®", "\\circledR");
C(I, X, K, "∡", "\\measuredangle", !0);
C(I, X, K, "∄", "\\nexists");
C(I, X, K, "℧", "\\mho");
C(I, X, K, "Ⅎ", "\\Finv", !0);
C(I, X, K, "⅁", "\\Game", !0);
C(I, X, K, "‵", "\\backprime");
C(I, X, K, "▲", "\\blacktriangle");
C(I, X, K, "▼", "\\blacktriangledown");
C(I, X, K, "■", "\\blacksquare");
C(I, X, K, "⧫", "\\blacklozenge");
C(I, X, K, "★", "\\bigstar");
C(I, X, K, "∢", "\\sphericalangle", !0);
C(I, X, K, "∁", "\\complement", !0);
C(I, X, K, "ð", "\\eth", !0);
C(ue, P, K, "ð", "ð");
C(I, X, K, "╱", "\\diagup");
C(I, X, K, "╲", "\\diagdown");
C(I, X, K, "□", "\\square");
C(I, X, K, "□", "\\Box");
C(I, X, K, "◊", "\\Diamond");
C(I, X, K, "¥", "\\yen", !0);
C(ue, X, K, "¥", "\\yen", !0);
C(I, X, K, "✓", "\\checkmark", !0);
C(ue, X, K, "✓", "\\checkmark");
C(I, X, K, "ℶ", "\\beth", !0);
C(I, X, K, "ℸ", "\\daleth", !0);
C(I, X, K, "ℷ", "\\gimel", !0);
C(I, X, K, "ϝ", "\\digamma", !0);
C(I, X, K, "ϰ", "\\varkappa");
C(I, X, Di, "┌", "\\@ulcorner", !0);
C(I, X, qr, "┐", "\\@urcorner", !0);
C(I, X, Di, "└", "\\@llcorner", !0);
C(I, X, qr, "┘", "\\@lrcorner", !0);
C(I, X, G, "≦", "\\leqq", !0);
C(I, X, G, "⩽", "\\leqslant", !0);
C(I, X, G, "⪕", "\\eqslantless", !0);
C(I, X, G, "≲", "\\lesssim", !0);
C(I, X, G, "⪅", "\\lessapprox", !0);
C(I, X, G, "≊", "\\approxeq", !0);
C(I, X, Ae, "⋖", "\\lessdot");
C(I, X, G, "⋘", "\\lll", !0);
C(I, X, G, "≶", "\\lessgtr", !0);
C(I, X, G, "⋚", "\\lesseqgtr", !0);
C(I, X, G, "⪋", "\\lesseqqgtr", !0);
C(I, X, G, "≑", "\\doteqdot");
C(I, X, G, "≓", "\\risingdotseq", !0);
C(I, X, G, "≒", "\\fallingdotseq", !0);
C(I, X, G, "∽", "\\backsim", !0);
C(I, X, G, "⋍", "\\backsimeq", !0);
C(I, X, G, "⫅", "\\subseteqq", !0);
C(I, X, G, "⋐", "\\Subset", !0);
C(I, X, G, "⊏", "\\sqsubset", !0);
C(I, X, G, "≼", "\\preccurlyeq", !0);
C(I, X, G, "⋞", "\\curlyeqprec", !0);
C(I, X, G, "≾", "\\precsim", !0);
C(I, X, G, "⪷", "\\precapprox", !0);
C(I, X, G, "⊲", "\\vartriangleleft");
C(I, X, G, "⊴", "\\trianglelefteq");
C(I, X, G, "⊨", "\\vDash", !0);
C(I, X, G, "⊪", "\\Vvdash", !0);
C(I, X, G, "⌣", "\\smallsmile");
C(I, X, G, "⌢", "\\smallfrown");
C(I, X, G, "≏", "\\bumpeq", !0);
C(I, X, G, "≎", "\\Bumpeq", !0);
C(I, X, G, "≧", "\\geqq", !0);
C(I, X, G, "⩾", "\\geqslant", !0);
C(I, X, G, "⪖", "\\eqslantgtr", !0);
C(I, X, G, "≳", "\\gtrsim", !0);
C(I, X, G, "⪆", "\\gtrapprox", !0);
C(I, X, Ae, "⋗", "\\gtrdot");
C(I, X, G, "⋙", "\\ggg", !0);
C(I, X, G, "≷", "\\gtrless", !0);
C(I, X, G, "⋛", "\\gtreqless", !0);
C(I, X, G, "⪌", "\\gtreqqless", !0);
C(I, X, G, "≖", "\\eqcirc", !0);
C(I, X, G, "≗", "\\circeq", !0);
C(I, X, G, "≜", "\\triangleq", !0);
C(I, X, G, "∼", "\\thicksim");
C(I, X, G, "≈", "\\thickapprox");
C(I, X, G, "⫆", "\\supseteqq", !0);
C(I, X, G, "⋑", "\\Supset", !0);
C(I, X, G, "⊐", "\\sqsupset", !0);
C(I, X, G, "≽", "\\succcurlyeq", !0);
C(I, X, G, "⋟", "\\curlyeqsucc", !0);
C(I, X, G, "≿", "\\succsim", !0);
C(I, X, G, "⪸", "\\succapprox", !0);
C(I, X, G, "⊳", "\\vartriangleright");
C(I, X, G, "⊵", "\\trianglerighteq");
C(I, X, G, "⊩", "\\Vdash", !0);
C(I, X, G, "∣", "\\shortmid");
C(I, X, G, "∥", "\\shortparallel");
C(I, X, G, "≬", "\\between", !0);
C(I, X, G, "⋔", "\\pitchfork", !0);
C(I, X, G, "∝", "\\varpropto");
C(I, X, G, "◀", "\\blacktriangleleft");
C(I, X, G, "∴", "\\therefore", !0);
C(I, X, G, "∍", "\\backepsilon");
C(I, X, G, "▶", "\\blacktriangleright");
C(I, X, G, "∵", "\\because", !0);
C(I, X, G, "⋘", "\\llless");
C(I, X, G, "⋙", "\\gggtr");
C(I, X, Ae, "⊲", "\\lhd");
C(I, X, Ae, "⊳", "\\rhd");
C(I, X, G, "≂", "\\eqsim", !0);
C(I, P, G, "⋈", "\\Join");
C(I, X, G, "≑", "\\Doteq", !0);
C(I, X, Ae, "∔", "\\dotplus", !0);
C(I, X, Ae, "∖", "\\smallsetminus");
C(I, X, Ae, "⋒", "\\Cap", !0);
C(I, X, Ae, "⋓", "\\Cup", !0);
C(I, X, Ae, "⩞", "\\doublebarwedge", !0);
C(I, X, Ae, "⊟", "\\boxminus", !0);
C(I, X, Ae, "⊞", "\\boxplus", !0);
C(I, X, Ae, "⋇", "\\divideontimes", !0);
C(I, X, Ae, "⋉", "\\ltimes", !0);
C(I, X, Ae, "⋊", "\\rtimes", !0);
C(I, X, Ae, "⋋", "\\leftthreetimes", !0);
C(I, X, Ae, "⋌", "\\rightthreetimes", !0);
C(I, X, Ae, "⋏", "\\curlywedge", !0);
C(I, X, Ae, "⋎", "\\curlyvee", !0);
C(I, X, Ae, "⊝", "\\circleddash", !0);
C(I, X, Ae, "⊛", "\\circledast", !0);
C(I, X, Ae, "⋅", "\\centerdot");
C(I, X, Ae, "⊺", "\\intercal", !0);
C(I, X, Ae, "⋒", "\\doublecap");
C(I, X, Ae, "⋓", "\\doublecup");
C(I, X, Ae, "⊠", "\\boxtimes", !0);
C(I, X, G, "⇢", "\\dashrightarrow", !0);
C(I, X, G, "⇠", "\\dashleftarrow", !0);
C(I, X, G, "⇇", "\\leftleftarrows", !0);
C(I, X, G, "⇆", "\\leftrightarrows", !0);
C(I, X, G, "⇚", "\\Lleftarrow", !0);
C(I, X, G, "↞", "\\twoheadleftarrow", !0);
C(I, X, G, "↢", "\\leftarrowtail", !0);
C(I, X, G, "↫", "\\looparrowleft", !0);
C(I, X, G, "⇋", "\\leftrightharpoons", !0);
C(I, X, G, "↶", "\\curvearrowleft", !0);
C(I, X, G, "↺", "\\circlearrowleft", !0);
C(I, X, G, "↰", "\\Lsh", !0);
C(I, X, G, "⇈", "\\upuparrows", !0);
C(I, X, G, "↿", "\\upharpoonleft", !0);
C(I, X, G, "⇃", "\\downharpoonleft", !0);
C(I, P, G, "⊶", "\\origof", !0);
C(I, P, G, "⊷", "\\imageof", !0);
C(I, X, G, "⊸", "\\multimap", !0);
C(I, X, G, "↭", "\\leftrightsquigarrow", !0);
C(I, X, G, "⇉", "\\rightrightarrows", !0);
C(I, X, G, "⇄", "\\rightleftarrows", !0);
C(I, X, G, "↠", "\\twoheadrightarrow", !0);
C(I, X, G, "↣", "\\rightarrowtail", !0);
C(I, X, G, "↬", "\\looparrowright", !0);
C(I, X, G, "↷", "\\curvearrowright", !0);
C(I, X, G, "↻", "\\circlearrowright", !0);
C(I, X, G, "↱", "\\Rsh", !0);
C(I, X, G, "⇊", "\\downdownarrows", !0);
C(I, X, G, "↾", "\\upharpoonright", !0);
C(I, X, G, "⇂", "\\downharpoonright", !0);
C(I, X, G, "⇝", "\\rightsquigarrow", !0);
C(I, X, G, "⇝", "\\leadsto");
C(I, X, G, "⇛", "\\Rrightarrow", !0);
C(I, X, G, "↾", "\\restriction");
C(I, P, K, "‘", "`");
C(I, P, K, "$", "\\$");
C(ue, P, K, "$", "\\$");
C(ue, P, K, "$", "\\textdollar");
C(I, P, K, "%", "\\%");
C(ue, P, K, "%", "\\%");
C(I, P, K, "_", "\\_");
C(ue, P, K, "_", "\\_");
C(ue, P, K, "_", "\\textunderscore");
C(I, P, K, "∠", "\\angle", !0);
C(I, P, K, "∞", "\\infty", !0);
C(I, P, K, "′", "\\prime");
C(I, P, K, "△", "\\triangle");
C(I, P, K, "Γ", "\\Gamma", !0);
C(I, P, K, "Δ", "\\Delta", !0);
C(I, P, K, "Θ", "\\Theta", !0);
C(I, P, K, "Λ", "\\Lambda", !0);
C(I, P, K, "Ξ", "\\Xi", !0);
C(I, P, K, "Π", "\\Pi", !0);
C(I, P, K, "Σ", "\\Sigma", !0);
C(I, P, K, "Υ", "\\Upsilon", !0);
C(I, P, K, "Φ", "\\Phi", !0);
C(I, P, K, "Ψ", "\\Psi", !0);
C(I, P, K, "Ω", "\\Omega", !0);
C(I, P, K, "A", "Α");
C(I, P, K, "B", "Β");
C(I, P, K, "E", "Ε");
C(I, P, K, "Z", "Ζ");
C(I, P, K, "H", "Η");
C(I, P, K, "I", "Ι");
C(I, P, K, "K", "Κ");
C(I, P, K, "M", "Μ");
C(I, P, K, "N", "Ν");
C(I, P, K, "O", "Ο");
C(I, P, K, "P", "Ρ");
C(I, P, K, "T", "Τ");
C(I, P, K, "X", "Χ");
C(I, P, K, "¬", "\\neg", !0);
C(I, P, K, "¬", "\\lnot");
C(I, P, K, "⊤", "\\top");
C(I, P, K, "⊥", "\\bot");
C(I, P, K, "∅", "\\emptyset");
C(I, X, K, "∅", "\\varnothing");
C(I, P, je, "α", "\\alpha", !0);
C(I, P, je, "β", "\\beta", !0);
C(I, P, je, "γ", "\\gamma", !0);
C(I, P, je, "δ", "\\delta", !0);
C(I, P, je, "ϵ", "\\epsilon", !0);
C(I, P, je, "ζ", "\\zeta", !0);
C(I, P, je, "η", "\\eta", !0);
C(I, P, je, "θ", "\\theta", !0);
C(I, P, je, "ι", "\\iota", !0);
C(I, P, je, "κ", "\\kappa", !0);
C(I, P, je, "λ", "\\lambda", !0);
C(I, P, je, "μ", "\\mu", !0);
C(I, P, je, "ν", "\\nu", !0);
C(I, P, je, "ξ", "\\xi", !0);
C(I, P, je, "ο", "\\omicron", !0);
C(I, P, je, "π", "\\pi", !0);
C(I, P, je, "ρ", "\\rho", !0);
C(I, P, je, "σ", "\\sigma", !0);
C(I, P, je, "τ", "\\tau", !0);
C(I, P, je, "υ", "\\upsilon", !0);
C(I, P, je, "ϕ", "\\phi", !0);
C(I, P, je, "χ", "\\chi", !0);
C(I, P, je, "ψ", "\\psi", !0);
C(I, P, je, "ω", "\\omega", !0);
C(I, P, je, "ε", "\\varepsilon", !0);
C(I, P, je, "ϑ", "\\vartheta", !0);
C(I, P, je, "ϖ", "\\varpi", !0);
C(I, P, je, "ϱ", "\\varrho", !0);
C(I, P, je, "ς", "\\varsigma", !0);
C(I, P, je, "φ", "\\varphi", !0);
C(I, P, Ae, "∗", "*", !0);
C(I, P, Ae, "+", "+");
C(I, P, Ae, "−", "-", !0);
C(I, P, Ae, "⋅", "\\cdot", !0);
C(I, P, Ae, "∘", "\\circ", !0);
C(I, P, Ae, "÷", "\\div", !0);
C(I, P, Ae, "±", "\\pm", !0);
C(I, P, Ae, "×", "\\times", !0);
C(I, P, Ae, "∩", "\\cap", !0);
C(I, P, Ae, "∪", "\\cup", !0);
C(I, P, Ae, "∖", "\\setminus", !0);
C(I, P, Ae, "∧", "\\land");
C(I, P, Ae, "∨", "\\lor");
C(I, P, Ae, "∧", "\\wedge", !0);
C(I, P, Ae, "∨", "\\vee", !0);
C(I, P, K, "√", "\\surd");
C(I, P, Di, "⟨", "\\langle", !0);
C(I, P, Di, "∣", "\\lvert");
C(I, P, Di, "∥", "\\lVert");
C(I, P, qr, "?", "?");
C(I, P, qr, "!", "!");
C(I, P, qr, "⟩", "\\rangle", !0);
C(I, P, qr, "∣", "\\rvert");
C(I, P, qr, "∥", "\\rVert");
C(I, P, G, "=", "=");
C(I, P, G, ":", ":");
C(I, P, G, "≈", "\\approx", !0);
C(I, P, G, "≅", "\\cong", !0);
C(I, P, G, "≥", "\\ge");
C(I, P, G, "≥", "\\geq", !0);
C(I, P, G, "←", "\\gets");
C(I, P, G, ">", "\\gt", !0);
C(I, P, G, "∈", "\\in", !0);
C(I, P, G, "", "\\@not");
C(I, P, G, "⊂", "\\subset", !0);
C(I, P, G, "⊃", "\\supset", !0);
C(I, P, G, "⊆", "\\subseteq", !0);
C(I, P, G, "⊇", "\\supseteq", !0);
C(I, X, G, "⊈", "\\nsubseteq", !0);
C(I, X, G, "⊉", "\\nsupseteq", !0);
C(I, P, G, "⊨", "\\models");
C(I, P, G, "←", "\\leftarrow", !0);
C(I, P, G, "≤", "\\le");
C(I, P, G, "≤", "\\leq", !0);
C(I, P, G, "<", "\\lt", !0);
C(I, P, G, "→", "\\rightarrow", !0);
C(I, P, G, "→", "\\to");
C(I, X, G, "≱", "\\ngeq", !0);
C(I, X, G, "≰", "\\nleq", !0);
C(I, P, Ts, " ", "\\ ");
C(I, P, Ts, " ", "\\space");
C(I, P, Ts, " ", "\\nobreakspace");
C(ue, P, Ts, " ", "\\ ");
C(ue, P, Ts, " ", " ");
C(ue, P, Ts, " ", "\\space");
C(ue, P, Ts, " ", "\\nobreakspace");
C(I, P, Ts, null, "\\nobreak");
C(I, P, Ts, null, "\\allowbreak");
C(I, P, Ng, ",", ",");
C(I, P, Ng, ";", ";");
C(I, X, Ae, "⊼", "\\barwedge", !0);
C(I, X, Ae, "⊻", "\\veebar", !0);
C(I, P, Ae, "⊙", "\\odot", !0);
C(I, P, Ae, "⊕", "\\oplus", !0);
C(I, P, Ae, "⊗", "\\otimes", !0);
C(I, P, K, "∂", "\\partial", !0);
C(I, P, Ae, "⊘", "\\oslash", !0);
C(I, X, Ae, "⊚", "\\circledcirc", !0);
C(I, X, Ae, "⊡", "\\boxdot", !0);
C(I, P, Ae, "△", "\\bigtriangleup");
C(I, P, Ae, "▽", "\\bigtriangledown");
C(I, P, Ae, "†", "\\dagger");
C(I, P, Ae, "⋄", "\\diamond");
C(I, P, Ae, "⋆", "\\star");
C(I, P, Ae, "◃", "\\triangleleft");
C(I, P, Ae, "▹", "\\triangleright");
C(I, P, Di, "{", "\\{");
C(ue, P, K, "{", "\\{");
C(ue, P, K, "{", "\\textbraceleft");
C(I, P, qr, "}", "\\}");
C(ue, P, K, "}", "\\}");
C(ue, P, K, "}", "\\textbraceright");
C(I, P, Di, "{", "\\lbrace");
C(I, P, qr, "}", "\\rbrace");
C(I, P, Di, "[", "\\lbrack", !0);
C(ue, P, K, "[", "\\lbrack", !0);
C(I, P, qr, "]", "\\rbrack", !0);
C(ue, P, K, "]", "\\rbrack", !0);
C(I, P, Di, "(", "\\lparen", !0);
C(I, P, qr, ")", "\\rparen", !0);
C(ue, P, K, "<", "\\textless", !0);
C(ue, P, K, ">", "\\textgreater", !0);
C(I, P, Di, "⌊", "\\lfloor", !0);
C(I, P, qr, "⌋", "\\rfloor", !0);
C(I, P, Di, "⌈", "\\lceil", !0);
C(I, P, qr, "⌉", "\\rceil", !0);
C(I, P, K, "\\", "\\backslash");
C(I, P, K, "∣", "|");
C(I, P, K, "∣", "\\vert");
C(ue, P, K, "|", "\\textbar", !0);
C(I, P, K, "∥", "\\|");
C(I, P, K, "∥", "\\Vert");
C(ue, P, K, "∥", "\\textbardbl");
C(ue, P, K, "~", "\\textasciitilde");
C(ue, P, K, "\\", "\\textbackslash");
C(ue, P, K, "^", "\\textasciicircum");
C(I, P, G, "↑", "\\uparrow", !0);
C(I, P, G, "⇑", "\\Uparrow", !0);
C(I, P, G, "↓", "\\downarrow", !0);
C(I, P, G, "⇓", "\\Downarrow", !0);
C(I, P, G, "↕", "\\updownarrow", !0);
C(I, P, G, "⇕", "\\Updownarrow", !0);
C(I, P, nr, "∐", "\\coprod");
C(I, P, nr, "⋁", "\\bigvee");
C(I, P, nr, "⋀", "\\bigwedge");
C(I, P, nr, "⨄", "\\biguplus");
C(I, P, nr, "⋂", "\\bigcap");
C(I, P, nr, "⋃", "\\bigcup");
C(I, P, nr, "∫", "\\int");
C(I, P, nr, "∫", "\\intop");
C(I, P, nr, "∬", "\\iint");
C(I, P, nr, "∭", "\\iiint");
C(I, P, nr, "∏", "\\prod");
C(I, P, nr, "∑", "\\sum");
C(I, P, nr, "⨂", "\\bigotimes");
C(I, P, nr, "⨁", "\\bigoplus");
C(I, P, nr, "⨀", "\\bigodot");
C(I, P, nr, "∮", "\\oint");
C(I, P, nr, "∯", "\\oiint");
C(I, P, nr, "∰", "\\oiiint");
C(I, P, nr, "⨆", "\\bigsqcup");
C(I, P, nr, "∫", "\\smallint");
C(ue, P, G0, "…", "\\textellipsis");
C(I, P, G0, "…", "\\mathellipsis");
C(ue, P, G0, "…", "\\ldots", !0);
C(I, P, G0, "…", "\\ldots", !0);
C(I, P, G0, "⋯", "\\@cdots", !0);
C(I, P, G0, "⋱", "\\ddots", !0);
C(I, P, K, "⋮", "\\varvdots");
C(ue, P, K, "⋮", "\\varvdots");
C(I, P, Sn, "ˊ", "\\acute");
C(I, P, Sn, "ˋ", "\\grave");
C(I, P, Sn, "¨", "\\ddot");
C(I, P, Sn, "~", "\\tilde");
C(I, P, Sn, "ˉ", "\\bar");
C(I, P, Sn, "˘", "\\breve");
C(I, P, Sn, "ˇ", "\\check");
C(I, P, Sn, "^", "\\hat");
C(I, P, Sn, "⃗", "\\vec");
C(I, P, Sn, "˙", "\\dot");
C(I, P, Sn, "˚", "\\mathring");
C(I, P, je, "", "\\@imath");
C(I, P, je, "", "\\@jmath");
C(I, P, K, "ı", "ı");
C(I, P, K, "ȷ", "ȷ");
C(ue, P, K, "ı", "\\i", !0);
C(ue, P, K, "ȷ", "\\j", !0);
C(ue, P, K, "ß", "\\ss", !0);
C(ue, P, K, "æ", "\\ae", !0);
C(ue, P, K, "œ", "\\oe", !0);
C(ue, P, K, "ø", "\\o", !0);
C(ue, P, K, "Æ", "\\AE", !0);
C(ue, P, K, "Œ", "\\OE", !0);
C(ue, P, K, "Ø", "\\O", !0);
C(ue, P, Sn, "ˊ", "\\'");
C(ue, P, Sn, "ˋ", "\\`");
C(ue, P, Sn, "ˆ", "\\^");
C(ue, P, Sn, "˜", "\\~");
C(ue, P, Sn, "ˉ", "\\=");
C(ue, P, Sn, "˘", "\\u");
C(ue, P, Sn, "˙", "\\.");
C(ue, P, Sn, "¸", "\\c");
C(ue, P, Sn, "˚", "\\r");
C(ue, P, Sn, "ˇ", "\\v");
C(ue, P, Sn, "¨", '\\"');
C(ue, P, Sn, "˝", "\\H");
C(ue, P, Sn, "◯", "\\textcircled");
var fM = {
  "--": !0,
  "---": !0,
  "``": !0,
  "''": !0
};
C(ue, P, K, "–", "--", !0);
C(ue, P, K, "–", "\\textendash");
C(ue, P, K, "—", "---", !0);
C(ue, P, K, "—", "\\textemdash");
C(ue, P, K, "‘", "`", !0);
C(ue, P, K, "‘", "\\textquoteleft");
C(ue, P, K, "’", "'", !0);
C(ue, P, K, "’", "\\textquoteright");
C(ue, P, K, "“", "``", !0);
C(ue, P, K, "“", "\\textquotedblleft");
C(ue, P, K, "”", "''", !0);
C(ue, P, K, "”", "\\textquotedblright");
C(I, P, K, "°", "\\degree", !0);
C(ue, P, K, "°", "\\degree");
C(ue, P, K, "°", "\\textdegree", !0);
C(I, P, K, "£", "\\pounds");
C(I, P, K, "£", "\\mathsterling", !0);
C(ue, P, K, "£", "\\pounds");
C(ue, P, K, "£", "\\textsterling", !0);
C(I, X, K, "✠", "\\maltese");
C(ue, X, K, "✠", "\\maltese");
var Xv = '0123456789/@."';
for (var r6 = 0; r6 < Xv.length; r6++) {
  var Vv = Xv.charAt(r6);
  C(I, P, K, Vv, Vv);
}
var Gv = '0123456789!@*()-=+";:?/.,';
for (var i6 = 0; i6 < Gv.length; i6++) {
  var jv = Gv.charAt(i6);
  C(ue, P, K, jv, jv);
}
var nm = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var a6 = 0; a6 < nm.length; a6++) {
  var h1 = nm.charAt(a6);
  C(I, P, je, h1, h1), C(ue, P, K, h1, h1);
}
C(I, X, K, "C", "ℂ");
C(ue, X, K, "C", "ℂ");
C(I, X, K, "H", "ℍ");
C(ue, X, K, "H", "ℍ");
C(I, X, K, "N", "ℕ");
C(ue, X, K, "N", "ℕ");
C(I, X, K, "P", "ℙ");
C(ue, X, K, "P", "ℙ");
C(I, X, K, "Q", "ℚ");
C(ue, X, K, "Q", "ℚ");
C(I, X, K, "R", "ℝ");
C(ue, X, K, "R", "ℝ");
C(I, X, K, "Z", "ℤ");
C(ue, X, K, "Z", "ℤ");
C(I, P, je, "h", "ℎ");
C(ue, P, je, "h", "ℎ");
var Qe = "";
for (var zr = 0; zr < nm.length; zr++) {
  var Ln = nm.charAt(zr);
  Qe = String.fromCharCode(55349, 56320 + zr), C(I, P, je, Ln, Qe), C(ue, P, K, Ln, Qe), Qe = String.fromCharCode(55349, 56372 + zr), C(I, P, je, Ln, Qe), C(ue, P, K, Ln, Qe), Qe = String.fromCharCode(55349, 56424 + zr), C(I, P, je, Ln, Qe), C(ue, P, K, Ln, Qe), Qe = String.fromCharCode(55349, 56580 + zr), C(I, P, je, Ln, Qe), C(ue, P, K, Ln, Qe), Qe = String.fromCharCode(55349, 56684 + zr), C(I, P, je, Ln, Qe), C(ue, P, K, Ln, Qe), Qe = String.fromCharCode(55349, 56736 + zr), C(I, P, je, Ln, Qe), C(ue, P, K, Ln, Qe), Qe = String.fromCharCode(55349, 56788 + zr), C(I, P, je, Ln, Qe), C(ue, P, K, Ln, Qe), Qe = String.fromCharCode(55349, 56840 + zr), C(I, P, je, Ln, Qe), C(ue, P, K, Ln, Qe), Qe = String.fromCharCode(55349, 56944 + zr), C(I, P, je, Ln, Qe), C(ue, P, K, Ln, Qe), zr < 26 && (Qe = String.fromCharCode(55349, 56632 + zr), C(I, P, je, Ln, Qe), C(ue, P, K, Ln, Qe), Qe = String.fromCharCode(55349, 56476 + zr), C(I, P, je, Ln, Qe), C(ue, P, K, Ln, Qe));
}
Qe = "𝕜";
C(I, P, je, "k", Qe);
C(ue, P, K, "k", Qe);
for (var Ho = 0; Ho < 10; Ho++) {
  var Os = Ho.toString();
  Qe = String.fromCharCode(55349, 57294 + Ho), C(I, P, je, Os, Qe), C(ue, P, K, Os, Qe), Qe = String.fromCharCode(55349, 57314 + Ho), C(I, P, je, Os, Qe), C(ue, P, K, Os, Qe), Qe = String.fromCharCode(55349, 57324 + Ho), C(I, P, je, Os, Qe), C(ue, P, K, Os, Qe), Qe = String.fromCharCode(55349, 57334 + Ho), C(I, P, je, Os, Qe), C(ue, P, K, Os, Qe);
}
var T4 = "ÐÞþ";
for (var l6 = 0; l6 < T4.length; l6++) {
  var f1 = T4.charAt(l6);
  C(I, P, je, f1, f1), C(ue, P, K, f1, f1);
}
var p1 = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
], Kv = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
], oB = function(t, n) {
  var r = t.charCodeAt(0), i = t.charCodeAt(1), a = (r - 55296) * 1024 + (i - 56320) + 65536, l = n === "math" ? 0 : 1;
  if (119808 <= a && a < 120484) {
    var s = Math.floor((a - 119808) / 26);
    return [p1[s][2], p1[s][l]];
  } else if (120782 <= a && a <= 120831) {
    var c = Math.floor((a - 120782) / 10);
    return [Kv[c][2], Kv[c][l]];
  } else {
    if (a === 120485 || a === 120486)
      return [p1[0][2], p1[0][l]];
    if (120486 < a && a < 120782)
      return ["", ""];
    throw new be("Unsupported character: " + t);
  }
}, Dg = function(t, n, r) {
  return cn[r][t] && cn[r][t].replace && (t = cn[r][t].replace), {
    value: t,
    metrics: Tb(t, n, r)
  };
}, ba = function(t, n, r, i, a) {
  var l = Dg(t, n, r), s = l.metrics;
  t = l.value;
  var c;
  if (s) {
    var d = s.italic;
    (r === "text" || i && i.font === "mathit") && (d = 0), c = new Zi(t, s.height, s.depth, d, s.skew, s.width, a);
  } else
    typeof console < "u" && console.warn("No character metrics " + ("for '" + t + "' in style '" + n + "' and mode '" + r + "'")), c = new Zi(t, 0, 0, 0, 0, 0, a);
  if (i) {
    c.maxFontSize = i.sizeMultiplier, i.style.isTight() && c.classes.push("mtight");
    var o = i.getColor();
    o && (c.style.color = o);
  }
  return c;
}, cB = function(t, n, r, i) {
  return i === void 0 && (i = []), r.font === "boldsymbol" && Dg(t, "Main-Bold", n).metrics ? ba(t, "Main-Bold", n, r, i.concat(["mathbf"])) : t === "\\" || cn[n][t].font === "main" ? ba(t, "Main-Regular", n, r, i) : ba(t, "AMS-Regular", n, r, i.concat(["amsrm"]));
}, dB = function(t, n, r, i, a) {
  return a !== "textord" && Dg(t, "Math-BoldItalic", n).metrics ? {
    fontName: "Math-BoldItalic",
    fontClass: "boldsymbol"
  } : {
    fontName: "Main-Bold",
    fontClass: "mathbf"
  };
}, uB = function(t, n, r) {
  var i = t.mode, a = t.text, l = ["mord"], s = i === "math" || i === "text" && n.font, c = s ? n.font : n.fontFamily, d = "", o = "";
  if (a.charCodeAt(0) === 55349 && ([d, o] = oB(a, i)), d.length > 0)
    return ba(a, d, i, n, l.concat(o));
  if (c) {
    var u, h;
    if (c === "boldsymbol") {
      var f = dB(a, i, n, l, r);
      u = f.fontName, h = [f.fontClass];
    } else s ? (u = gM[c].fontName, h = [c]) : (u = m1(c, n.fontWeight, n.fontShape), h = [c, n.fontWeight, n.fontShape]);
    if (Dg(a, u, i).metrics)
      return ba(a, u, i, n, l.concat(h));
    if (fM.hasOwnProperty(a) && u.slice(0, 10) === "Typewriter") {
      for (var p = [], g = 0; g < a.length; g++)
        p.push(ba(a[g], u, i, n, l.concat(h)));
      return mM(p);
    }
  }
  if (r === "mathord")
    return ba(a, "Math-Italic", i, n, l.concat(["mathnormal"]));
  if (r === "textord") {
    var b = cn[i][a] && cn[i][a].font;
    if (b === "ams") {
      var v = m1("amsrm", n.fontWeight, n.fontShape);
      return ba(a, v, i, n, l.concat("amsrm", n.fontWeight, n.fontShape));
    } else if (b === "main" || !b) {
      var U = m1("textrm", n.fontWeight, n.fontShape);
      return ba(a, U, i, n, l.concat(n.fontWeight, n.fontShape));
    } else {
      var y = m1(b, n.fontWeight, n.fontShape);
      return ba(a, y, i, n, l.concat(y, n.fontWeight, n.fontShape));
    }
  } else
    throw new Error("unexpected type: " + r + " in makeOrd");
}, hB = (e, t) => {
  if (Uo(e.classes) !== Uo(t.classes) || e.skew !== t.skew || e.maxFontSize !== t.maxFontSize)
    return !1;
  if (e.classes.length === 1) {
    var n = e.classes[0];
    if (n === "mbin" || n === "mord")
      return !1;
  }
  for (var r in e.style)
    if (e.style.hasOwnProperty(r) && e.style[r] !== t.style[r])
      return !1;
  for (var i in t.style)
    if (t.style.hasOwnProperty(i) && e.style[i] !== t.style[i])
      return !1;
  return !0;
}, fB = (e) => {
  for (var t = 0; t < e.length - 1; t++) {
    var n = e[t], r = e[t + 1];
    n instanceof Zi && r instanceof Zi && hB(n, r) && (n.text += r.text, n.height = Math.max(n.height, r.height), n.depth = Math.max(n.depth, r.depth), n.italic = r.italic, e.splice(t + 1, 1), t--);
  }
  return e;
}, Ab = function(t) {
  for (var n = 0, r = 0, i = 0, a = 0; a < t.children.length; a++) {
    var l = t.children[a];
    l.height > n && (n = l.height), l.depth > r && (r = l.depth), l.maxFontSize > i && (i = l.maxFontSize);
  }
  t.height = n, t.depth = r, t.maxFontSize = i;
}, ni = function(t, n, r, i) {
  var a = new Af(t, n, r, i);
  return Ab(a), a;
}, pM = (e, t, n, r) => new Af(e, t, n, r), pB = function(t, n, r) {
  var i = ni([t], [], n);
  return i.height = Math.max(r || n.fontMetrics().defaultRuleThickness, n.minRuleThickness), i.style.borderBottomWidth = xe(i.height), i.maxFontSize = 1, i;
}, mB = function(t, n, r, i) {
  var a = new Ib(t, n, r, i);
  return Ab(a), a;
}, mM = function(t) {
  var n = new If(t);
  return Ab(n), n;
}, gB = function(t, n) {
  return t instanceof If ? ni([], [t], n) : t;
}, bB = function(t) {
  if (t.positionType === "individualShift") {
    for (var n = t.children, r = [n[0]], i = -n[0].shift - n[0].elem.depth, a = i, l = 1; l < n.length; l++) {
      var s = -n[l].shift - a - n[l].elem.depth, c = s - (n[l - 1].elem.height + n[l - 1].elem.depth);
      a = a + s, r.push({
        type: "kern",
        size: c
      }), r.push(n[l]);
    }
    return {
      children: r,
      depth: i
    };
  }
  var d;
  if (t.positionType === "top") {
    for (var o = t.positionData, u = 0; u < t.children.length; u++) {
      var h = t.children[u];
      o -= h.type === "kern" ? h.size : h.elem.height + h.elem.depth;
    }
    d = o;
  } else if (t.positionType === "bottom")
    d = -t.positionData;
  else {
    var f = t.children[0];
    if (f.type !== "elem")
      throw new Error('First child must have type "elem".');
    if (t.positionType === "shift")
      d = -f.elem.depth - t.positionData;
    else if (t.positionType === "firstBaseline")
      d = -f.elem.depth;
    else
      throw new Error("Invalid positionType " + t.positionType + ".");
  }
  return {
    children: t.children,
    depth: d
  };
}, UB = function(t, n) {
  for (var {
    children: r,
    depth: i
  } = bB(t), a = 0, l = 0; l < r.length; l++) {
    var s = r[l];
    if (s.type === "elem") {
      var c = s.elem;
      a = Math.max(a, c.maxFontSize, c.height);
    }
  }
  a += 2;
  var d = ni(["pstrut"], []);
  d.style.height = xe(a);
  for (var o = [], u = i, h = i, f = i, p = 0; p < r.length; p++) {
    var g = r[p];
    if (g.type === "kern")
      f += g.size;
    else {
      var b = g.elem, v = g.wrapperClasses || [], U = g.wrapperStyle || {}, y = ni(v, [d, b], void 0, U);
      y.style.top = xe(-a - f - b.depth), g.marginLeft && (y.style.marginLeft = g.marginLeft), g.marginRight && (y.style.marginRight = g.marginRight), o.push(y), f += b.height + b.depth;
    }
    u = Math.min(u, f), h = Math.max(h, f);
  }
  var w = ni(["vlist"], o);
  w.style.height = xe(h);
  var x;
  if (u < 0) {
    var E = ni([], []), S = ni(["vlist"], [E]);
    S.style.height = xe(-u);
    var _ = ni(["vlist-s"], [new Zi("​")]);
    x = [ni(["vlist-r"], [w, _]), ni(["vlist-r"], [S])];
  } else
    x = [ni(["vlist-r"], [w])];
  var k = ni(["vlist-t"], x);
  return x.length === 2 && k.classes.push("vlist-t2"), k.height = h, k.depth = -u, k;
}, vB = (e, t) => {
  var n = ni(["mspace"], [], t), r = Tn(e, t);
  return n.style.marginRight = xe(r), n;
}, m1 = function(t, n, r) {
  var i = "";
  switch (t) {
    case "amsrm":
      i = "AMS";
      break;
    case "textrm":
      i = "Main";
      break;
    case "textsf":
      i = "SansSerif";
      break;
    case "texttt":
      i = "Typewriter";
      break;
    default:
      i = t;
  }
  var a;
  return n === "textbf" && r === "textit" ? a = "BoldItalic" : n === "textbf" ? a = "Bold" : n === "textit" ? a = "Italic" : a = "Regular", i + "-" + a;
}, gM = {
  // styles
  mathbf: {
    variant: "bold",
    fontName: "Main-Bold"
  },
  mathrm: {
    variant: "normal",
    fontName: "Main-Regular"
  },
  textit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathnormal: {
    variant: "italic",
    fontName: "Math-Italic"
  },
  mathsfit: {
    variant: "sans-serif-italic",
    fontName: "SansSerif-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  mathbb: {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  mathcal: {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  mathfrak: {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  mathscr: {
    variant: "script",
    fontName: "Script-Regular"
  },
  mathsf: {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  mathtt: {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
}, bM = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
}, yB = function(t, n) {
  var [r, i, a] = bM[t], l = new vo(r), s = new fs([l], {
    width: xe(i),
    height: xe(a),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + xe(i),
    viewBox: "0 0 " + 1e3 * i + " " + 1e3 * a,
    preserveAspectRatio: "xMinYMin"
  }), c = pM(["overlay"], [s], n);
  return c.height = a, c.style.height = xe(a), c.style.width = xe(i), c;
}, ee = {
  fontMap: gM,
  makeSymbol: ba,
  mathsym: cB,
  makeSpan: ni,
  makeSvgSpan: pM,
  makeLineSpan: pB,
  makeAnchor: mB,
  makeFragment: mM,
  wrapFragment: gB,
  makeVList: UB,
  makeOrd: uB,
  makeGlue: vB,
  staticSvg: yB,
  svgData: bM,
  tryCombineChars: fB
}, kn = {
  number: 3,
  unit: "mu"
}, Wo = {
  number: 4,
  unit: "mu"
}, Fl = {
  number: 5,
  unit: "mu"
}, wB = {
  mord: {
    mop: kn,
    mbin: Wo,
    mrel: Fl,
    minner: kn
  },
  mop: {
    mord: kn,
    mop: kn,
    mrel: Fl,
    minner: kn
  },
  mbin: {
    mord: Wo,
    mop: Wo,
    mopen: Wo,
    minner: Wo
  },
  mrel: {
    mord: Fl,
    mop: Fl,
    mopen: Fl,
    minner: Fl
  },
  mopen: {},
  mclose: {
    mop: kn,
    mbin: Wo,
    mrel: Fl,
    minner: kn
  },
  mpunct: {
    mord: kn,
    mop: kn,
    mrel: Fl,
    mopen: kn,
    mclose: kn,
    mpunct: kn,
    minner: kn
  },
  minner: {
    mord: kn,
    mop: kn,
    mbin: Wo,
    mrel: Fl,
    mopen: kn,
    mpunct: kn,
    minner: kn
  }
}, xB = {
  mord: {
    mop: kn
  },
  mop: {
    mord: kn,
    mop: kn
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: kn
  },
  mpunct: {},
  minner: {
    mop: kn
  }
}, UM = {}, rm = {}, im = {};
function Te(e) {
  for (var {
    type: t,
    names: n,
    props: r,
    handler: i,
    htmlBuilder: a,
    mathmlBuilder: l
  } = e, s = {
    type: t,
    numArgs: r.numArgs,
    argTypes: r.argTypes,
    allowedInArgument: !!r.allowedInArgument,
    allowedInText: !!r.allowedInText,
    allowedInMath: r.allowedInMath === void 0 ? !0 : r.allowedInMath,
    numOptionalArgs: r.numOptionalArgs || 0,
    infix: !!r.infix,
    primitive: !!r.primitive,
    handler: i
  }, c = 0; c < n.length; ++c)
    UM[n[c]] = s;
  t && (a && (rm[t] = a), l && (im[t] = l));
}
function ld(e) {
  var {
    type: t,
    htmlBuilder: n,
    mathmlBuilder: r
  } = e;
  Te({
    type: t,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: n,
    mathmlBuilder: r
  });
}
var am = function(t) {
  return t.type === "ordgroup" && t.body.length === 1 ? t.body[0] : t;
}, Gn = function(t) {
  return t.type === "ordgroup" ? t.body : [t];
}, ps = ee.makeSpan, EB = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], SB = ["rightmost", "mrel", "mclose", "mpunct"], _B = {
  display: Ye.DISPLAY,
  text: Ye.TEXT,
  script: Ye.SCRIPT,
  scriptscript: Ye.SCRIPTSCRIPT
}, kB = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
}, cr = function(t, n, r, i) {
  i === void 0 && (i = [null, null]);
  for (var a = [], l = 0; l < t.length; l++) {
    var s = It(t[l], n);
    if (s instanceof If) {
      var c = s.children;
      a.push(...c);
    } else
      a.push(s);
  }
  if (ee.tryCombineChars(a), !r)
    return a;
  var d = n;
  if (t.length === 1) {
    var o = t[0];
    o.type === "sizing" ? d = n.havingSize(o.size) : o.type === "styling" && (d = n.havingStyle(_B[o.style]));
  }
  var u = ps([i[0] || "leftmost"], [], n), h = ps([i[1] || "rightmost"], [], n), f = r === "root";
  return Yv(a, (p, g) => {
    var b = g.classes[0], v = p.classes[0];
    b === "mbin" && We.contains(SB, v) ? g.classes[0] = "mord" : v === "mbin" && We.contains(EB, b) && (p.classes[0] = "mord");
  }, {
    node: u
  }, h, f), Yv(a, (p, g) => {
    var b = I4(g), v = I4(p), U = b && v ? p.hasClass("mtight") ? xB[b][v] : wB[b][v] : null;
    if (U)
      return ee.makeGlue(U, d);
  }, {
    node: u
  }, h, f), a;
}, Yv = function e(t, n, r, i, a) {
  i && t.push(i);
  for (var l = 0; l < t.length; l++) {
    var s = t[l], c = vM(s);
    if (c) {
      e(c.children, n, r, null, a);
      continue;
    }
    var d = !s.hasClass("mspace");
    if (d) {
      var o = n(s, r.node);
      o && (r.insertAfter ? r.insertAfter(o) : (t.unshift(o), l++));
    }
    d ? r.node = s : a && s.hasClass("newline") && (r.node = ps(["leftmost"])), r.insertAfter = /* @__PURE__ */ ((u) => (h) => {
      t.splice(u + 1, 0, h), l++;
    })(l);
  }
  i && t.pop();
}, vM = function(t) {
  return t instanceof If || t instanceof Ib || t instanceof Af && t.hasClass("enclosing") ? t : null;
}, CB = function e(t, n) {
  var r = vM(t);
  if (r) {
    var i = r.children;
    if (i.length) {
      if (n === "right")
        return e(i[i.length - 1], "right");
      if (n === "left")
        return e(i[0], "left");
    }
  }
  return t;
}, I4 = function(t, n) {
  return t ? (n && (t = CB(t, n)), kB[t.classes[0]] || null) : null;
}, Rh = function(t, n) {
  var r = ["nulldelimiter"].concat(t.baseSizingClasses());
  return ps(n.concat(r));
}, It = function(t, n, r) {
  if (!t)
    return ps();
  if (rm[t.type]) {
    var i = rm[t.type](t, n);
    if (r && n.size !== r.size) {
      i = ps(n.sizingClasses(r), [i], n);
      var a = n.sizeMultiplier / r.sizeMultiplier;
      i.height *= a, i.depth *= a;
    }
    return i;
  } else
    throw new be("Got group of unknown type: '" + t.type + "'");
};
function g1(e, t) {
  var n = ps(["base"], e, t), r = ps(["strut"]);
  return r.style.height = xe(n.height + n.depth), n.depth && (r.style.verticalAlign = xe(-n.depth)), n.children.unshift(r), n;
}
function A4(e, t) {
  var n = null;
  e.length === 1 && e[0].type === "tag" && (n = e[0].tag, e = e[0].body);
  var r = cr(e, t, "root"), i;
  r.length === 2 && r[1].hasClass("tag") && (i = r.pop());
  for (var a = [], l = [], s = 0; s < r.length; s++)
    if (l.push(r[s]), r[s].hasClass("mbin") || r[s].hasClass("mrel") || r[s].hasClass("allowbreak")) {
      for (var c = !1; s < r.length - 1 && r[s + 1].hasClass("mspace") && !r[s + 1].hasClass("newline"); )
        s++, l.push(r[s]), r[s].hasClass("nobreak") && (c = !0);
      c || (a.push(g1(l, t)), l = []);
    } else r[s].hasClass("newline") && (l.pop(), l.length > 0 && (a.push(g1(l, t)), l = []), a.push(r[s]));
  l.length > 0 && a.push(g1(l, t));
  var d;
  n ? (d = g1(cr(n, t, !0)), d.classes = ["tag"], a.push(d)) : i && a.push(i);
  var o = ps(["katex-html"], a);
  if (o.setAttribute("aria-hidden", "true"), d) {
    var u = d.children[0];
    u.style.height = xe(o.height + o.depth), o.depth && (u.style.verticalAlign = xe(-o.depth));
  }
  return o;
}
function yM(e) {
  return new If(e);
}
class xi {
  constructor(t, n, r) {
    this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = t, this.attributes = {}, this.children = n || [], this.classes = r || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(t, n) {
    this.attributes[t] = n;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(t) {
    return this.attributes[t];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var t = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && t.setAttribute(n, this.attributes[n]);
    this.classes.length > 0 && (t.className = Uo(this.classes));
    for (var r = 0; r < this.children.length; r++)
      if (this.children[r] instanceof ml && this.children[r + 1] instanceof ml) {
        for (var i = this.children[r].toText() + this.children[++r].toText(); this.children[r + 1] instanceof ml; )
          i += this.children[++r].toText();
        t.appendChild(new ml(i).toNode());
      } else
        t.appendChild(this.children[r].toNode());
    return t;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var t = "<" + this.type;
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && (t += " " + n + '="', t += We.escape(this.attributes[n]), t += '"');
    this.classes.length > 0 && (t += ' class ="' + We.escape(Uo(this.classes)) + '"'), t += ">";
    for (var r = 0; r < this.children.length; r++)
      t += this.children[r].toMarkup();
    return t += "</" + this.type + ">", t;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((t) => t.toText()).join("");
  }
}
class ml {
  constructor(t) {
    this.text = void 0, this.text = t;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return We.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}
class MB {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(t) {
    this.width = void 0, this.character = void 0, this.width = t, t >= 0.05555 && t <= 0.05556 ? this.character = " " : t >= 0.1666 && t <= 0.1667 ? this.character = " " : t >= 0.2222 && t <= 0.2223 ? this.character = " " : t >= 0.2777 && t <= 0.2778 ? this.character = "  " : t >= -0.05556 && t <= -0.05555 ? this.character = " ⁣" : t >= -0.1667 && t <= -0.1666 ? this.character = " ⁣" : t >= -0.2223 && t <= -0.2222 ? this.character = " ⁣" : t >= -0.2778 && t <= -0.2777 ? this.character = " ⁣" : this.character = null;
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character)
      return document.createTextNode(this.character);
    var t = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
    return t.setAttribute("width", xe(this.width)), t;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + xe(this.width) + '"/>';
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    return this.character ? this.character : " ";
  }
}
var me = {
  MathNode: xi,
  TextNode: ml,
  SpaceNode: MB,
  newDocumentFragment: yM
}, Ji = function(t, n, r) {
  return cn[n][t] && cn[n][t].replace && t.charCodeAt(0) !== 55349 && !(fM.hasOwnProperty(t) && r && (r.fontFamily && r.fontFamily.slice(4, 6) === "tt" || r.font && r.font.slice(4, 6) === "tt")) && (t = cn[n][t].replace), new me.TextNode(t);
}, Nb = function(t) {
  return t.length === 1 ? t[0] : new me.MathNode("mrow", t);
}, Db = function(t, n) {
  if (n.fontFamily === "texttt")
    return "monospace";
  if (n.fontFamily === "textsf")
    return n.fontShape === "textit" && n.fontWeight === "textbf" ? "sans-serif-bold-italic" : n.fontShape === "textit" ? "sans-serif-italic" : n.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
  if (n.fontShape === "textit" && n.fontWeight === "textbf")
    return "bold-italic";
  if (n.fontShape === "textit")
    return "italic";
  if (n.fontWeight === "textbf")
    return "bold";
  var r = n.font;
  if (!r || r === "mathnormal")
    return null;
  var i = t.mode;
  if (r === "mathit")
    return "italic";
  if (r === "boldsymbol")
    return t.type === "textord" ? "bold" : "bold-italic";
  if (r === "mathbf")
    return "bold";
  if (r === "mathbb")
    return "double-struck";
  if (r === "mathsfit")
    return "sans-serif-italic";
  if (r === "mathfrak")
    return "fraktur";
  if (r === "mathscr" || r === "mathcal")
    return "script";
  if (r === "mathsf")
    return "sans-serif";
  if (r === "mathtt")
    return "monospace";
  var a = t.text;
  if (We.contains(["\\imath", "\\jmath"], a))
    return null;
  cn[i][a] && cn[i][a].replace && (a = cn[i][a].replace);
  var l = ee.fontMap[r].fontName;
  return Tb(a, l, i) ? ee.fontMap[r].variant : null;
};
function s6(e) {
  if (!e)
    return !1;
  if (e.type === "mi" && e.children.length === 1) {
    var t = e.children[0];
    return t instanceof ml && t.text === ".";
  } else if (e.type === "mo" && e.children.length === 1 && e.getAttribute("separator") === "true" && e.getAttribute("lspace") === "0em" && e.getAttribute("rspace") === "0em") {
    var n = e.children[0];
    return n instanceof ml && n.text === ",";
  } else
    return !1;
}
var pi = function(t, n, r) {
  if (t.length === 1) {
    var i = nn(t[0], n);
    return r && i instanceof xi && i.type === "mo" && (i.setAttribute("lspace", "0em"), i.setAttribute("rspace", "0em")), [i];
  }
  for (var a = [], l, s = 0; s < t.length; s++) {
    var c = nn(t[s], n);
    if (c instanceof xi && l instanceof xi) {
      if (c.type === "mtext" && l.type === "mtext" && c.getAttribute("mathvariant") === l.getAttribute("mathvariant")) {
        l.children.push(...c.children);
        continue;
      } else if (c.type === "mn" && l.type === "mn") {
        l.children.push(...c.children);
        continue;
      } else if (s6(c) && l.type === "mn") {
        l.children.push(...c.children);
        continue;
      } else if (c.type === "mn" && s6(l))
        c.children = [...l.children, ...c.children], a.pop();
      else if ((c.type === "msup" || c.type === "msub") && c.children.length >= 1 && (l.type === "mn" || s6(l))) {
        var d = c.children[0];
        d instanceof xi && d.type === "mn" && (d.children = [...l.children, ...d.children], a.pop());
      } else if (l.type === "mi" && l.children.length === 1) {
        var o = l.children[0];
        if (o instanceof ml && o.text === "̸" && (c.type === "mo" || c.type === "mi" || c.type === "mn")) {
          var u = c.children[0];
          u instanceof ml && u.text.length > 0 && (u.text = u.text.slice(0, 1) + "̸" + u.text.slice(1), a.pop());
        }
      }
    }
    a.push(c), l = c;
  }
  return a;
}, yo = function(t, n, r) {
  return Nb(pi(t, n, r));
}, nn = function(t, n) {
  if (!t)
    return new me.MathNode("mrow");
  if (im[t.type]) {
    var r = im[t.type](t, n);
    return r;
  } else
    throw new be("Got group of unknown type: '" + t.type + "'");
};
function qv(e, t, n, r, i) {
  var a = pi(e, n), l;
  a.length === 1 && a[0] instanceof xi && We.contains(["mrow", "mtable"], a[0].type) ? l = a[0] : l = new me.MathNode("mrow", a);
  var s = new me.MathNode("annotation", [new me.TextNode(t)]);
  s.setAttribute("encoding", "application/x-tex");
  var c = new me.MathNode("semantics", [l, s]), d = new me.MathNode("math", [c]);
  d.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), r && d.setAttribute("display", "block");
  var o = i ? "katex" : "katex-mathml";
  return ee.makeSpan([o], [d]);
}
var wM = function(t) {
  return new Yl({
    style: t.displayMode ? Ye.DISPLAY : Ye.TEXT,
    maxSize: t.maxSize,
    minRuleThickness: t.minRuleThickness
  });
}, xM = function(t, n) {
  if (n.displayMode) {
    var r = ["katex-display"];
    n.leqno && r.push("leqno"), n.fleqn && r.push("fleqn"), t = ee.makeSpan(r, [t]);
  }
  return t;
}, TB = function(t, n, r) {
  var i = wM(r), a;
  if (r.output === "mathml")
    return qv(t, n, i, r.displayMode, !0);
  if (r.output === "html") {
    var l = A4(t, i);
    a = ee.makeSpan(["katex"], [l]);
  } else {
    var s = qv(t, n, i, r.displayMode, !1), c = A4(t, i);
    a = ee.makeSpan(["katex"], [s, c]);
  }
  return xM(a, r);
}, IB = function(t, n, r) {
  var i = wM(r), a = A4(t, i), l = ee.makeSpan(["katex"], [a]);
  return xM(l, r);
}, AB = {
  widehat: "^",
  widecheck: "ˇ",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "←",
  underleftarrow: "←",
  xleftarrow: "←",
  overrightarrow: "→",
  underrightarrow: "→",
  xrightarrow: "→",
  underbrace: "⏟",
  overbrace: "⏞",
  overgroup: "⏠",
  undergroup: "⏡",
  overleftrightarrow: "↔",
  underleftrightarrow: "↔",
  xleftrightarrow: "↔",
  Overrightarrow: "⇒",
  xRightarrow: "⇒",
  overleftharpoon: "↼",
  xleftharpoonup: "↼",
  overrightharpoon: "⇀",
  xrightharpoonup: "⇀",
  xLeftarrow: "⇐",
  xLeftrightarrow: "⇔",
  xhookleftarrow: "↩",
  xhookrightarrow: "↪",
  xmapsto: "↦",
  xrightharpoondown: "⇁",
  xleftharpoondown: "↽",
  xrightleftharpoons: "⇌",
  xleftrightharpoons: "⇋",
  xtwoheadleftarrow: "↞",
  xtwoheadrightarrow: "↠",
  xlongequal: "=",
  xtofrom: "⇄",
  xrightleftarrows: "⇄",
  xrightequilibrium: "⇌",
  // Not a perfect match.
  xleftequilibrium: "⇋",
  // None better available.
  "\\cdrightarrow": "→",
  "\\cdleftarrow": "←",
  "\\cdlongequal": "="
}, NB = function(t) {
  var n = new me.MathNode("mo", [new me.TextNode(AB[t.replace(/^\\/, "")])]);
  return n.setAttribute("stretchy", "true"), n;
}, DB = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
}, LB = function(t) {
  return t.type === "ordgroup" ? t.body.length : 1;
}, RB = function(t, n) {
  function r() {
    var s = 4e5, c = t.label.slice(1);
    if (We.contains(["widehat", "widecheck", "widetilde", "utilde"], c)) {
      var d = t, o = LB(d.base), u, h, f;
      if (o > 5)
        c === "widehat" || c === "widecheck" ? (u = 420, s = 2364, f = 0.42, h = c + "4") : (u = 312, s = 2340, f = 0.34, h = "tilde4");
      else {
        var p = [1, 1, 2, 2, 3, 3][o];
        c === "widehat" || c === "widecheck" ? (s = [0, 1062, 2364, 2364, 2364][p], u = [0, 239, 300, 360, 420][p], f = [0, 0.24, 0.3, 0.3, 0.36, 0.42][p], h = c + p) : (s = [0, 600, 1033, 2339, 2340][p], u = [0, 260, 286, 306, 312][p], f = [0, 0.26, 0.286, 0.3, 0.306, 0.34][p], h = "tilde" + p);
      }
      var g = new vo(h), b = new fs([g], {
        width: "100%",
        height: xe(f),
        viewBox: "0 0 " + s + " " + u,
        preserveAspectRatio: "none"
      });
      return {
        span: ee.makeSvgSpan([], [b], n),
        minWidth: 0,
        height: f
      };
    } else {
      var v = [], U = DB[c], [y, w, x] = U, E = x / 1e3, S = y.length, _, k;
      if (S === 1) {
        var M = U[3];
        _ = ["hide-tail"], k = [M];
      } else if (S === 2)
        _ = ["halfarrow-left", "halfarrow-right"], k = ["xMinYMin", "xMaxYMin"];
      else if (S === 3)
        _ = ["brace-left", "brace-center", "brace-right"], k = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      else
        throw new Error(`Correct katexImagesData or update code here to support
                    ` + S + " children.");
      for (var A = 0; A < S; A++) {
        var L = new vo(y[A]), R = new fs([L], {
          width: "400em",
          height: xe(E),
          viewBox: "0 0 " + s + " " + x,
          preserveAspectRatio: k[A] + " slice"
        }), z = ee.makeSvgSpan([_[A]], [R], n);
        if (S === 1)
          return {
            span: z,
            minWidth: w,
            height: E
          };
        z.style.height = xe(E), v.push(z);
      }
      return {
        span: ee.makeSpan(["stretchy"], v, n),
        minWidth: w,
        height: E
      };
    }
  }
  var {
    span: i,
    minWidth: a,
    height: l
  } = r();
  return i.height = l, i.style.height = xe(l), a > 0 && (i.style.minWidth = xe(a)), i;
}, PB = function(t, n, r, i, a) {
  var l, s = t.height + t.depth + r + i;
  if (/fbox|color|angl/.test(n)) {
    if (l = ee.makeSpan(["stretchy", n], [], a), n === "fbox") {
      var c = a.color && a.getColor();
      c && (l.style.borderColor = c);
    }
  } else {
    var d = [];
    /^[bx]cancel$/.test(n) && d.push(new M4({
      x1: "0",
      y1: "0",
      x2: "100%",
      y2: "100%",
      "stroke-width": "0.046em"
    })), /^x?cancel$/.test(n) && d.push(new M4({
      x1: "0",
      y1: "100%",
      x2: "100%",
      y2: "0",
      "stroke-width": "0.046em"
    }));
    var o = new fs(d, {
      width: "100%",
      height: xe(s)
    });
    l = ee.makeSvgSpan([], [o], a);
  }
  return l.height = s, l.style.height = xe(s), l;
}, ms = {
  encloseSpan: PB,
  mathMLnode: NB,
  svgSpan: RB
};
function bt(e, t) {
  if (!e || e.type !== t)
    throw new Error("Expected node of type " + t + ", but got " + (e ? "node of type " + e.type : String(e)));
  return e;
}
function Lb(e) {
  var t = Lg(e);
  if (!t)
    throw new Error("Expected node of symbol group type, but got " + (e ? "node of type " + e.type : String(e)));
  return t;
}
function Lg(e) {
  return e && (e.type === "atom" || sB.hasOwnProperty(e.type)) ? e : null;
}
var Rb = (e, t) => {
  var n, r, i;
  e && e.type === "supsub" ? (r = bt(e.base, "accent"), n = r.base, e.base = n, i = aB(It(e, t)), e.base = r) : (r = bt(e, "accent"), n = r.base);
  var a = It(n, t.havingCrampedStyle()), l = r.isShifty && We.isCharacterBox(n), s = 0;
  if (l) {
    var c = We.getBaseElem(n), d = It(c, t.havingCrampedStyle());
    s = Wv(d).skew;
  }
  var o = r.label === "\\c", u = o ? a.height + a.depth : Math.min(a.height, t.fontMetrics().xHeight), h;
  if (r.isStretchy)
    h = ms.svgSpan(r, t), h = ee.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: a
      }, {
        type: "elem",
        elem: h,
        wrapperClasses: ["svg-align"],
        wrapperStyle: s > 0 ? {
          width: "calc(100% - " + xe(2 * s) + ")",
          marginLeft: xe(2 * s)
        } : void 0
      }]
    }, t);
  else {
    var f, p;
    r.label === "\\vec" ? (f = ee.staticSvg("vec", t), p = ee.svgData.vec[1]) : (f = ee.makeOrd({
      mode: r.mode,
      text: r.label
    }, t, "textord"), f = Wv(f), f.italic = 0, p = f.width, o && (u += f.depth)), h = ee.makeSpan(["accent-body"], [f]);
    var g = r.label === "\\textcircled";
    g && (h.classes.push("accent-full"), u = a.height);
    var b = s;
    g || (b -= p / 2), h.style.left = xe(b), r.label === "\\textcircled" && (h.style.top = ".2em"), h = ee.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: -u
      }, {
        type: "elem",
        elem: h
      }]
    }, t);
  }
  var v = ee.makeSpan(["mord", "accent"], [h], t);
  return i ? (i.children[0] = v, i.height = Math.max(v.height, i.height), i.classes[0] = "mord", i) : v;
}, EM = (e, t) => {
  var n = e.isStretchy ? ms.mathMLnode(e.label) : new me.MathNode("mo", [Ji(e.label, e.mode)]), r = new me.MathNode("mover", [nn(e.base, t), n]);
  return r.setAttribute("accent", "true"), r;
}, OB = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((e) => "\\" + e).join("|"));
Te({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (e, t) => {
    var n = am(t[0]), r = !OB.test(e.funcName), i = !r || e.funcName === "\\widehat" || e.funcName === "\\widetilde" || e.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: e.parser.mode,
      label: e.funcName,
      isStretchy: r,
      isShifty: i,
      base: n
    };
  },
  htmlBuilder: Rb,
  mathmlBuilder: EM
});
Te({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (e, t) => {
    var n = t[0], r = e.parser.mode;
    return r === "math" && (e.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + e.funcName + " works only in text mode"), r = "text"), {
      type: "accent",
      mode: r,
      label: e.funcName,
      isStretchy: !1,
      isShifty: !0,
      base: n
    };
  },
  htmlBuilder: Rb,
  mathmlBuilder: EM
});
Te({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0];
    return {
      type: "accentUnder",
      mode: n.mode,
      label: r,
      base: i
    };
  },
  htmlBuilder: (e, t) => {
    var n = It(e.base, t), r = ms.svgSpan(e, t), i = e.label === "\\utilde" ? 0.12 : 0, a = ee.makeVList({
      positionType: "top",
      positionData: n.height,
      children: [{
        type: "elem",
        elem: r,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: n
      }]
    }, t);
    return ee.makeSpan(["mord", "accentunder"], [a], t);
  },
  mathmlBuilder: (e, t) => {
    var n = ms.mathMLnode(e.label), r = new me.MathNode("munder", [nn(e.base, t), n]);
    return r.setAttribute("accentunder", "true"), r;
  }
});
var b1 = (e) => {
  var t = new me.MathNode("mpadded", e ? [e] : []);
  return t.setAttribute("width", "+0.6em"), t.setAttribute("lspace", "0.3em"), t;
};
Te({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(e, t, n) {
    var {
      parser: r,
      funcName: i
    } = e;
    return {
      type: "xArrow",
      mode: r.mode,
      label: i,
      body: t[0],
      below: n[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(e, t) {
    var n = t.style, r = t.havingStyle(n.sup()), i = ee.wrapFragment(It(e.body, r, t), t), a = e.label.slice(0, 2) === "\\x" ? "x" : "cd";
    i.classes.push(a + "-arrow-pad");
    var l;
    e.below && (r = t.havingStyle(n.sub()), l = ee.wrapFragment(It(e.below, r, t), t), l.classes.push(a + "-arrow-pad"));
    var s = ms.svgSpan(e, t), c = -t.fontMetrics().axisHeight + 0.5 * s.height, d = -t.fontMetrics().axisHeight - 0.5 * s.height - 0.111;
    (i.depth > 0.25 || e.label === "\\xleftequilibrium") && (d -= i.depth);
    var o;
    if (l) {
      var u = -t.fontMetrics().axisHeight + l.height + 0.5 * s.height + 0.111;
      o = ee.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: d
        }, {
          type: "elem",
          elem: s,
          shift: c
        }, {
          type: "elem",
          elem: l,
          shift: u
        }]
      }, t);
    } else
      o = ee.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: d
        }, {
          type: "elem",
          elem: s,
          shift: c
        }]
      }, t);
    return o.children[0].children[0].children[1].classes.push("svg-align"), ee.makeSpan(["mrel", "x-arrow"], [o], t);
  },
  mathmlBuilder(e, t) {
    var n = ms.mathMLnode(e.label);
    n.setAttribute("minsize", e.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var r;
    if (e.body) {
      var i = b1(nn(e.body, t));
      if (e.below) {
        var a = b1(nn(e.below, t));
        r = new me.MathNode("munderover", [n, a, i]);
      } else
        r = new me.MathNode("mover", [n, i]);
    } else if (e.below) {
      var l = b1(nn(e.below, t));
      r = new me.MathNode("munder", [n, l]);
    } else
      r = b1(), r = new me.MathNode("mover", [n, r]);
    return r;
  }
});
var $B = ee.makeSpan;
function SM(e, t) {
  var n = cr(e.body, t, !0);
  return $B([e.mclass], n, t);
}
function _M(e, t) {
  var n, r = pi(e.body, t);
  return e.mclass === "minner" ? n = new me.MathNode("mpadded", r) : e.mclass === "mord" ? e.isCharacterBox ? (n = r[0], n.type = "mi") : n = new me.MathNode("mi", r) : (e.isCharacterBox ? (n = r[0], n.type = "mo") : n = new me.MathNode("mo", r), e.mclass === "mbin" ? (n.attributes.lspace = "0.22em", n.attributes.rspace = "0.22em") : e.mclass === "mpunct" ? (n.attributes.lspace = "0em", n.attributes.rspace = "0.17em") : e.mclass === "mopen" || e.mclass === "mclose" ? (n.attributes.lspace = "0em", n.attributes.rspace = "0em") : e.mclass === "minner" && (n.attributes.lspace = "0.0556em", n.attributes.width = "+0.1111em")), n;
}
Te({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0];
    return {
      type: "mclass",
      mode: n.mode,
      mclass: "m" + r.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: Gn(i),
      isCharacterBox: We.isCharacterBox(i)
    };
  },
  htmlBuilder: SM,
  mathmlBuilder: _M
});
var Rg = (e) => {
  var t = e.type === "ordgroup" && e.body.length ? e.body[0] : e;
  return t.type === "atom" && (t.family === "bin" || t.family === "rel") ? "m" + t.family : "mord";
};
Te({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(e, t) {
    var {
      parser: n
    } = e;
    return {
      type: "mclass",
      mode: n.mode,
      mclass: Rg(t[0]),
      body: Gn(t[1]),
      isCharacterBox: We.isCharacterBox(t[1])
    };
  }
});
Te({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r
    } = e, i = t[1], a = t[0], l;
    r !== "\\stackrel" ? l = Rg(i) : l = "mrel";
    var s = {
      type: "op",
      mode: i.mode,
      limits: !0,
      alwaysHandleSupSub: !0,
      parentIsSupSub: !1,
      symbol: !1,
      suppressBaseShift: r !== "\\stackrel",
      body: Gn(i)
    }, c = {
      type: "supsub",
      mode: a.mode,
      base: s,
      sup: r === "\\underset" ? null : a,
      sub: r === "\\underset" ? a : null
    };
    return {
      type: "mclass",
      mode: n.mode,
      mclass: l,
      body: [c],
      isCharacterBox: We.isCharacterBox(c)
    };
  },
  htmlBuilder: SM,
  mathmlBuilder: _M
});
Te({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: n
    } = e;
    return {
      type: "pmb",
      mode: n.mode,
      mclass: Rg(t[0]),
      body: Gn(t[0])
    };
  },
  htmlBuilder(e, t) {
    var n = cr(e.body, t, !0), r = ee.makeSpan([e.mclass], n, t);
    return r.style.textShadow = "0.02em 0.01em 0.04px", r;
  },
  mathmlBuilder(e, t) {
    var n = pi(e.body, t), r = new me.MathNode("mstyle", n);
    return r.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), r;
  }
});
var FB = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
}, Zv = () => ({
  type: "styling",
  body: [],
  mode: "math",
  style: "display"
}), Jv = (e) => e.type === "textord" && e.text === "@", zB = (e, t) => (e.type === "mathord" || e.type === "atom") && e.text === t;
function BB(e, t, n) {
  var r = FB[e];
  switch (r) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return n.callFunction(r, [t[0]], [t[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var i = n.callFunction("\\\\cdleft", [t[0]], []), a = {
        type: "atom",
        text: r,
        mode: "math",
        family: "rel"
      }, l = n.callFunction("\\Big", [a], []), s = n.callFunction("\\\\cdright", [t[1]], []), c = {
        type: "ordgroup",
        mode: "math",
        body: [i, l, s]
      };
      return n.callFunction("\\\\cdparent", [c], []);
    }
    case "\\\\cdlongequal":
      return n.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var d = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return n.callFunction("\\Big", [d], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function HB(e) {
  var t = [];
  for (e.gullet.beginGroup(), e.gullet.macros.set("\\cr", "\\\\\\relax"), e.gullet.beginGroup(); ; ) {
    t.push(e.parseExpression(!1, "\\\\")), e.gullet.endGroup(), e.gullet.beginGroup();
    var n = e.fetch().text;
    if (n === "&" || n === "\\\\")
      e.consume();
    else if (n === "\\end") {
      t[t.length - 1].length === 0 && t.pop();
      break;
    } else
      throw new be("Expected \\\\ or \\cr or \\end", e.nextToken);
  }
  for (var r = [], i = [r], a = 0; a < t.length; a++) {
    for (var l = t[a], s = Zv(), c = 0; c < l.length; c++)
      if (!Jv(l[c]))
        s.body.push(l[c]);
      else {
        r.push(s), c += 1;
        var d = Lb(l[c]).text, o = new Array(2);
        if (o[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, o[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, !("=|.".indexOf(d) > -1)) if ("<>AV".indexOf(d) > -1)
          for (var u = 0; u < 2; u++) {
            for (var h = !0, f = c + 1; f < l.length; f++) {
              if (zB(l[f], d)) {
                h = !1, c = f;
                break;
              }
              if (Jv(l[f]))
                throw new be("Missing a " + d + " character to complete a CD arrow.", l[f]);
              o[u].body.push(l[f]);
            }
            if (h)
              throw new be("Missing a " + d + " character to complete a CD arrow.", l[c]);
          }
        else
          throw new be('Expected one of "<>AV=|." after @', l[c]);
        var p = BB(d, o, e), g = {
          type: "styling",
          body: [p],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        r.push(g), s = Zv();
      }
    a % 2 === 0 ? r.push(s) : r.shift(), r = [], i.push(r);
  }
  e.gullet.endGroup(), e.gullet.endGroup();
  var b = new Array(i[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body: i,
    arraystretch: 1,
    addJot: !0,
    rowGaps: [null],
    cols: b,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(i.length + 1).fill([])
  };
}
Te({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r
    } = e;
    return {
      type: "cdlabel",
      mode: n.mode,
      side: r.slice(4),
      label: t[0]
    };
  },
  htmlBuilder(e, t) {
    var n = t.havingStyle(t.style.sup()), r = ee.wrapFragment(It(e.label, n, t), t);
    return r.classes.push("cd-label-" + e.side), r.style.bottom = xe(0.8 - r.depth), r.height = 0, r.depth = 0, r;
  },
  mathmlBuilder(e, t) {
    var n = new me.MathNode("mrow", [nn(e.label, t)]);
    return n = new me.MathNode("mpadded", [n]), n.setAttribute("width", "0"), e.side === "left" && n.setAttribute("lspace", "-1width"), n.setAttribute("voffset", "0.7em"), n = new me.MathNode("mstyle", [n]), n.setAttribute("displaystyle", "false"), n.setAttribute("scriptlevel", "1"), n;
  }
});
Te({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: n
    } = e;
    return {
      type: "cdlabelparent",
      mode: n.mode,
      fragment: t[0]
    };
  },
  htmlBuilder(e, t) {
    var n = ee.wrapFragment(It(e.fragment, t), t);
    return n.classes.push("cd-vert-arrow"), n;
  },
  mathmlBuilder(e, t) {
    return new me.MathNode("mrow", [nn(e.fragment, t)]);
  }
});
Te({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(e, t) {
    for (var {
      parser: n
    } = e, r = bt(t[0], "ordgroup"), i = r.body, a = "", l = 0; l < i.length; l++) {
      var s = bt(i[l], "textord");
      a += s.text;
    }
    var c = parseInt(a), d;
    if (isNaN(c))
      throw new be("\\@char has non-numeric argument " + a);
    if (c < 0 || c >= 1114111)
      throw new be("\\@char with invalid code point " + a);
    return c <= 65535 ? d = String.fromCharCode(c) : (c -= 65536, d = String.fromCharCode((c >> 10) + 55296, (c & 1023) + 56320)), {
      type: "textord",
      mode: n.mode,
      text: d
    };
  }
});
var kM = (e, t) => {
  var n = cr(e.body, t.withColor(e.color), !1);
  return ee.makeFragment(n);
}, CM = (e, t) => {
  var n = pi(e.body, t.withColor(e.color)), r = new me.MathNode("mstyle", n);
  return r.setAttribute("mathcolor", e.color), r;
};
Te({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "original"]
  },
  handler(e, t) {
    var {
      parser: n
    } = e, r = bt(t[0], "color-token").color, i = t[1];
    return {
      type: "color",
      mode: n.mode,
      color: r,
      body: Gn(i)
    };
  },
  htmlBuilder: kM,
  mathmlBuilder: CM
});
Te({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    argTypes: ["color"]
  },
  handler(e, t) {
    var {
      parser: n,
      breakOnTokenText: r
    } = e, i = bt(t[0], "color-token").color;
    n.gullet.macros.set("\\current@color", i);
    var a = n.parseExpression(!0, r);
    return {
      type: "color",
      mode: n.mode,
      color: i,
      body: a
    };
  },
  htmlBuilder: kM,
  mathmlBuilder: CM
});
Te({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: !0
  },
  handler(e, t, n) {
    var {
      parser: r
    } = e, i = r.gullet.future().text === "[" ? r.parseSizeGroup(!0) : null, a = !r.settings.displayMode || !r.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: r.mode,
      newLine: a,
      size: i && bt(i, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(e, t) {
    var n = ee.makeSpan(["mspace"], [], t);
    return e.newLine && (n.classes.push("newline"), e.size && (n.style.marginTop = xe(Tn(e.size, t)))), n;
  },
  mathmlBuilder(e, t) {
    var n = new me.MathNode("mspace");
    return e.newLine && (n.setAttribute("linebreak", "newline"), e.size && n.setAttribute("height", xe(Tn(e.size, t)))), n;
  }
});
var N4 = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
}, MM = (e) => {
  var t = e.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(t))
    throw new be("Expected a control sequence", e);
  return t;
}, WB = (e) => {
  var t = e.gullet.popToken();
  return t.text === "=" && (t = e.gullet.popToken(), t.text === " " && (t = e.gullet.popToken())), t;
}, TM = (e, t, n, r) => {
  var i = e.gullet.macros.get(n.text);
  i == null && (n.noexpand = !0, i = {
    tokens: [n],
    numArgs: 0,
    // reproduce the same behavior in expansion
    unexpandable: !e.gullet.isExpandable(n.text)
  }), e.gullet.macros.set(t, i, r);
};
Te({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: n
    } = e;
    t.consumeSpaces();
    var r = t.fetch();
    if (N4[r.text])
      return (n === "\\global" || n === "\\\\globallong") && (r.text = N4[r.text]), bt(t.parseFunction(), "internal");
    throw new be("Invalid token after macro prefix", r);
  }
});
Te({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: n
    } = e, r = t.gullet.popToken(), i = r.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(i))
      throw new be("Expected a control sequence", r);
    for (var a = 0, l, s = [[]]; t.gullet.future().text !== "{"; )
      if (r = t.gullet.popToken(), r.text === "#") {
        if (t.gullet.future().text === "{") {
          l = t.gullet.future(), s[a].push("{");
          break;
        }
        if (r = t.gullet.popToken(), !/^[1-9]$/.test(r.text))
          throw new be('Invalid argument number "' + r.text + '"');
        if (parseInt(r.text) !== a + 1)
          throw new be('Argument number "' + r.text + '" out of order');
        a++, s.push([]);
      } else {
        if (r.text === "EOF")
          throw new be("Expected a macro definition");
        s[a].push(r.text);
      }
    var {
      tokens: c
    } = t.gullet.consumeArg();
    return l && c.unshift(l), (n === "\\edef" || n === "\\xdef") && (c = t.gullet.expandTokens(c), c.reverse()), t.gullet.macros.set(i, {
      tokens: c,
      numArgs: a,
      delimiters: s
    }, n === N4[n]), {
      type: "internal",
      mode: t.mode
    };
  }
});
Te({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: n
    } = e, r = MM(t.gullet.popToken());
    t.gullet.consumeSpaces();
    var i = WB(t);
    return TM(t, r, i, n === "\\\\globallet"), {
      type: "internal",
      mode: t.mode
    };
  }
});
Te({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: n
    } = e, r = MM(t.gullet.popToken()), i = t.gullet.popToken(), a = t.gullet.popToken();
    return TM(t, r, a, n === "\\\\globalfuture"), t.gullet.pushToken(a), t.gullet.pushToken(i), {
      type: "internal",
      mode: t.mode
    };
  }
});
var Bu = function(t, n, r) {
  var i = cn.math[t] && cn.math[t].replace, a = Tb(i || t, n, r);
  if (!a)
    throw new Error("Unsupported symbol " + t + " and font size " + n + ".");
  return a;
}, Pb = function(t, n, r, i) {
  var a = r.havingBaseStyle(n), l = ee.makeSpan(i.concat(a.sizingClasses(r)), [t], r), s = a.sizeMultiplier / r.sizeMultiplier;
  return l.height *= s, l.depth *= s, l.maxFontSize = a.sizeMultiplier, l;
}, IM = function(t, n, r) {
  var i = n.havingBaseStyle(r), a = (1 - n.sizeMultiplier / i.sizeMultiplier) * n.fontMetrics().axisHeight;
  t.classes.push("delimcenter"), t.style.top = xe(a), t.height -= a, t.depth += a;
}, XB = function(t, n, r, i, a, l) {
  var s = ee.makeSymbol(t, "Main-Regular", a, i), c = Pb(s, n, i, l);
  return r && IM(c, i, n), c;
}, VB = function(t, n, r, i) {
  return ee.makeSymbol(t, "Size" + n + "-Regular", r, i);
}, AM = function(t, n, r, i, a, l) {
  var s = VB(t, n, a, i), c = Pb(ee.makeSpan(["delimsizing", "size" + n], [s], i), Ye.TEXT, i, l);
  return r && IM(c, i, Ye.TEXT), c;
}, o6 = function(t, n, r) {
  var i;
  n === "Size1-Regular" ? i = "delim-size1" : i = "delim-size4";
  var a = ee.makeSpan(["delimsizinginner", i], [ee.makeSpan([], [ee.makeSymbol(t, n, r)])]);
  return {
    type: "elem",
    elem: a
  };
}, c6 = function(t, n, r) {
  var i = pl["Size4-Regular"][t.charCodeAt(0)] ? pl["Size4-Regular"][t.charCodeAt(0)][4] : pl["Size1-Regular"][t.charCodeAt(0)][4], a = new vo("inner", Zz(t, Math.round(1e3 * n))), l = new fs([a], {
    width: xe(i),
    height: xe(n),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + xe(i),
    viewBox: "0 0 " + 1e3 * i + " " + Math.round(1e3 * n),
    preserveAspectRatio: "xMinYMin"
  }), s = ee.makeSvgSpan([], [l], r);
  return s.height = n, s.style.height = xe(n), s.style.width = xe(i), {
    type: "elem",
    elem: s
  };
}, D4 = 8e-3, U1 = {
  type: "kern",
  size: -1 * D4
}, GB = ["|", "\\lvert", "\\rvert", "\\vert"], jB = ["\\|", "\\lVert", "\\rVert", "\\Vert"], NM = function(t, n, r, i, a, l) {
  var s, c, d, o, u = "", h = 0;
  s = d = o = t, c = null;
  var f = "Size1-Regular";
  t === "\\uparrow" ? d = o = "⏐" : t === "\\Uparrow" ? d = o = "‖" : t === "\\downarrow" ? s = d = "⏐" : t === "\\Downarrow" ? s = d = "‖" : t === "\\updownarrow" ? (s = "\\uparrow", d = "⏐", o = "\\downarrow") : t === "\\Updownarrow" ? (s = "\\Uparrow", d = "‖", o = "\\Downarrow") : We.contains(GB, t) ? (d = "∣", u = "vert", h = 333) : We.contains(jB, t) ? (d = "∥", u = "doublevert", h = 556) : t === "[" || t === "\\lbrack" ? (s = "⎡", d = "⎢", o = "⎣", f = "Size4-Regular", u = "lbrack", h = 667) : t === "]" || t === "\\rbrack" ? (s = "⎤", d = "⎥", o = "⎦", f = "Size4-Regular", u = "rbrack", h = 667) : t === "\\lfloor" || t === "⌊" ? (d = s = "⎢", o = "⎣", f = "Size4-Regular", u = "lfloor", h = 667) : t === "\\lceil" || t === "⌈" ? (s = "⎡", d = o = "⎢", f = "Size4-Regular", u = "lceil", h = 667) : t === "\\rfloor" || t === "⌋" ? (d = s = "⎥", o = "⎦", f = "Size4-Regular", u = "rfloor", h = 667) : t === "\\rceil" || t === "⌉" ? (s = "⎤", d = o = "⎥", f = "Size4-Regular", u = "rceil", h = 667) : t === "(" || t === "\\lparen" ? (s = "⎛", d = "⎜", o = "⎝", f = "Size4-Regular", u = "lparen", h = 875) : t === ")" || t === "\\rparen" ? (s = "⎞", d = "⎟", o = "⎠", f = "Size4-Regular", u = "rparen", h = 875) : t === "\\{" || t === "\\lbrace" ? (s = "⎧", c = "⎨", o = "⎩", d = "⎪", f = "Size4-Regular") : t === "\\}" || t === "\\rbrace" ? (s = "⎫", c = "⎬", o = "⎭", d = "⎪", f = "Size4-Regular") : t === "\\lgroup" || t === "⟮" ? (s = "⎧", o = "⎩", d = "⎪", f = "Size4-Regular") : t === "\\rgroup" || t === "⟯" ? (s = "⎫", o = "⎭", d = "⎪", f = "Size4-Regular") : t === "\\lmoustache" || t === "⎰" ? (s = "⎧", o = "⎭", d = "⎪", f = "Size4-Regular") : (t === "\\rmoustache" || t === "⎱") && (s = "⎫", o = "⎩", d = "⎪", f = "Size4-Regular");
  var p = Bu(s, f, a), g = p.height + p.depth, b = Bu(d, f, a), v = b.height + b.depth, U = Bu(o, f, a), y = U.height + U.depth, w = 0, x = 1;
  if (c !== null) {
    var E = Bu(c, f, a);
    w = E.height + E.depth, x = 2;
  }
  var S = g + y + w, _ = Math.max(0, Math.ceil((n - S) / (x * v))), k = S + _ * x * v, M = i.fontMetrics().axisHeight;
  r && (M *= i.sizeMultiplier);
  var A = k / 2 - M, L = [];
  if (u.length > 0) {
    var R = k - g - y, z = Math.round(k * 1e3), F = Jz(u, Math.round(R * 1e3)), W = new vo(u, F), B = (h / 1e3).toFixed(3) + "em", j = (z / 1e3).toFixed(3) + "em", V = new fs([W], {
      width: B,
      height: j,
      viewBox: "0 0 " + h + " " + z
    }), q = ee.makeSvgSpan([], [V], i);
    q.height = z / 1e3, q.style.width = B, q.style.height = j, L.push({
      type: "elem",
      elem: q
    });
  } else {
    if (L.push(o6(o, f, a)), L.push(U1), c === null) {
      var oe = k - g - y + 2 * D4;
      L.push(c6(d, oe, i));
    } else {
      var Ue = (k - g - y - w) / 2 + 2 * D4;
      L.push(c6(d, Ue, i)), L.push(U1), L.push(o6(c, f, a)), L.push(U1), L.push(c6(d, Ue, i));
    }
    L.push(U1), L.push(o6(s, f, a));
  }
  var fe = i.havingBaseStyle(Ye.TEXT), Pe = ee.makeVList({
    positionType: "bottom",
    positionData: A,
    children: L
  }, fe);
  return Pb(ee.makeSpan(["delimsizing", "mult"], [Pe], fe), Ye.TEXT, i, l);
}, d6 = 80, u6 = 0.08, h6 = function(t, n, r, i, a) {
  var l = qz(t, i, r), s = new vo(t, l), c = new fs([s], {
    // Note: 1000:1 ratio of viewBox to document em width.
    width: "400em",
    height: xe(n),
    viewBox: "0 0 400000 " + r,
    preserveAspectRatio: "xMinYMin slice"
  });
  return ee.makeSvgSpan(["hide-tail"], [c], a);
}, KB = function(t, n) {
  var r = n.havingBaseSizing(), i = PM("\\surd", t * r.sizeMultiplier, RM, r), a = r.sizeMultiplier, l = Math.max(0, n.minRuleThickness - n.fontMetrics().sqrtRuleThickness), s, c = 0, d = 0, o = 0, u;
  return i.type === "small" ? (o = 1e3 + 1e3 * l + d6, t < 1 ? a = 1 : t < 1.4 && (a = 0.7), c = (1 + l + u6) / a, d = (1 + l) / a, s = h6("sqrtMain", c, o, l, n), s.style.minWidth = "0.853em", u = 0.833 / a) : i.type === "large" ? (o = (1e3 + d6) * oh[i.size], d = (oh[i.size] + l) / a, c = (oh[i.size] + l + u6) / a, s = h6("sqrtSize" + i.size, c, o, l, n), s.style.minWidth = "1.02em", u = 1 / a) : (c = t + l + u6, d = t + l, o = Math.floor(1e3 * t + l) + d6, s = h6("sqrtTall", c, o, l, n), s.style.minWidth = "0.742em", u = 1.056), s.height = d, s.style.height = xe(c), {
    span: s,
    advanceWidth: u,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (n.fontMetrics().sqrtRuleThickness + l) * a
  };
}, DM = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "\\surd"], YB = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱"], LM = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], oh = [0, 1.2, 1.8, 2.4, 3], qB = function(t, n, r, i, a) {
  if (t === "<" || t === "\\lt" || t === "⟨" ? t = "\\langle" : (t === ">" || t === "\\gt" || t === "⟩") && (t = "\\rangle"), We.contains(DM, t) || We.contains(LM, t))
    return AM(t, n, !1, r, i, a);
  if (We.contains(YB, t))
    return NM(t, oh[n], !1, r, i, a);
  throw new be("Illegal delimiter: '" + t + "'");
}, ZB = [{
  type: "small",
  style: Ye.SCRIPTSCRIPT
}, {
  type: "small",
  style: Ye.SCRIPT
}, {
  type: "small",
  style: Ye.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}], JB = [{
  type: "small",
  style: Ye.SCRIPTSCRIPT
}, {
  type: "small",
  style: Ye.SCRIPT
}, {
  type: "small",
  style: Ye.TEXT
}, {
  type: "stack"
}], RM = [{
  type: "small",
  style: Ye.SCRIPTSCRIPT
}, {
  type: "small",
  style: Ye.SCRIPT
}, {
  type: "small",
  style: Ye.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}], QB = function(t) {
  if (t.type === "small")
    return "Main-Regular";
  if (t.type === "large")
    return "Size" + t.size + "-Regular";
  if (t.type === "stack")
    return "Size4-Regular";
  throw new Error("Add support for delim type '" + t.type + "' here.");
}, PM = function(t, n, r, i) {
  for (var a = Math.min(2, 3 - i.style.size), l = a; l < r.length && r[l].type !== "stack"; l++) {
    var s = Bu(t, QB(r[l]), "math"), c = s.height + s.depth;
    if (r[l].type === "small") {
      var d = i.havingBaseStyle(r[l].style);
      c *= d.sizeMultiplier;
    }
    if (c > n)
      return r[l];
  }
  return r[r.length - 1];
}, OM = function(t, n, r, i, a, l) {
  t === "<" || t === "\\lt" || t === "⟨" ? t = "\\langle" : (t === ">" || t === "\\gt" || t === "⟩") && (t = "\\rangle");
  var s;
  We.contains(LM, t) ? s = ZB : We.contains(DM, t) ? s = RM : s = JB;
  var c = PM(t, n, s, i);
  return c.type === "small" ? XB(t, c.style, r, i, a, l) : c.type === "large" ? AM(t, c.size, r, i, a, l) : NM(t, n, r, i, a, l);
}, eH = function(t, n, r, i, a, l) {
  var s = i.fontMetrics().axisHeight * i.sizeMultiplier, c = 901, d = 5 / i.fontMetrics().ptPerEm, o = Math.max(n - s, r + s), u = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    o / 500 * c,
    2 * o - d
  );
  return OM(t, u, !0, i, a, l);
}, os = {
  sqrtImage: KB,
  sizedDelim: qB,
  sizeToMaxHeight: oh,
  customSizedDelim: OM,
  leftRightDelim: eH
}, Qv = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
}, tH = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "<", ">", "\\langle", "⟨", "\\rangle", "⟩", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function Pg(e, t) {
  var n = Lg(e);
  if (n && We.contains(tH, n.text))
    return n;
  throw n ? new be("Invalid delimiter '" + n.text + "' after '" + t.funcName + "'", e) : new be("Invalid delimiter type '" + e.type + "'", e);
}
Te({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (e, t) => {
    var n = Pg(t[0], e);
    return {
      type: "delimsizing",
      mode: e.parser.mode,
      size: Qv[e.funcName].size,
      mclass: Qv[e.funcName].mclass,
      delim: n.text
    };
  },
  htmlBuilder: (e, t) => e.delim === "." ? ee.makeSpan([e.mclass]) : os.sizedDelim(e.delim, e.size, t, e.mode, [e.mclass]),
  mathmlBuilder: (e) => {
    var t = [];
    e.delim !== "." && t.push(Ji(e.delim, e.mode));
    var n = new me.MathNode("mo", t);
    e.mclass === "mopen" || e.mclass === "mclose" ? n.setAttribute("fence", "true") : n.setAttribute("fence", "false"), n.setAttribute("stretchy", "true");
    var r = xe(os.sizeToMaxHeight[e.size]);
    return n.setAttribute("minsize", r), n.setAttribute("maxsize", r), n;
  }
});
function ey(e) {
  if (!e.body)
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
}
Te({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (e, t) => {
    var n = e.parser.gullet.macros.get("\\current@color");
    if (n && typeof n != "string")
      throw new be("\\current@color set to non-string in \\right");
    return {
      type: "leftright-right",
      mode: e.parser.mode,
      delim: Pg(t[0], e).text,
      color: n
      // undefined if not set via \color
    };
  }
});
Te({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (e, t) => {
    var n = Pg(t[0], e), r = e.parser;
    ++r.leftrightDepth;
    var i = r.parseExpression(!1);
    --r.leftrightDepth, r.expect("\\right", !1);
    var a = bt(r.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: r.mode,
      body: i,
      left: n.text,
      right: a.delim,
      rightColor: a.color
    };
  },
  htmlBuilder: (e, t) => {
    ey(e);
    for (var n = cr(e.body, t, !0, ["mopen", "mclose"]), r = 0, i = 0, a = !1, l = 0; l < n.length; l++)
      n[l].isMiddle ? a = !0 : (r = Math.max(n[l].height, r), i = Math.max(n[l].depth, i));
    r *= t.sizeMultiplier, i *= t.sizeMultiplier;
    var s;
    if (e.left === "." ? s = Rh(t, ["mopen"]) : s = os.leftRightDelim(e.left, r, i, t, e.mode, ["mopen"]), n.unshift(s), a)
      for (var c = 1; c < n.length; c++) {
        var d = n[c], o = d.isMiddle;
        o && (n[c] = os.leftRightDelim(o.delim, r, i, o.options, e.mode, []));
      }
    var u;
    if (e.right === ".")
      u = Rh(t, ["mclose"]);
    else {
      var h = e.rightColor ? t.withColor(e.rightColor) : t;
      u = os.leftRightDelim(e.right, r, i, h, e.mode, ["mclose"]);
    }
    return n.push(u), ee.makeSpan(["minner"], n, t);
  },
  mathmlBuilder: (e, t) => {
    ey(e);
    var n = pi(e.body, t);
    if (e.left !== ".") {
      var r = new me.MathNode("mo", [Ji(e.left, e.mode)]);
      r.setAttribute("fence", "true"), n.unshift(r);
    }
    if (e.right !== ".") {
      var i = new me.MathNode("mo", [Ji(e.right, e.mode)]);
      i.setAttribute("fence", "true"), e.rightColor && i.setAttribute("mathcolor", e.rightColor), n.push(i);
    }
    return Nb(n);
  }
});
Te({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (e, t) => {
    var n = Pg(t[0], e);
    if (!e.parser.leftrightDepth)
      throw new be("\\middle without preceding \\left", n);
    return {
      type: "middle",
      mode: e.parser.mode,
      delim: n.text
    };
  },
  htmlBuilder: (e, t) => {
    var n;
    if (e.delim === ".")
      n = Rh(t, []);
    else {
      n = os.sizedDelim(e.delim, 1, t, e.mode, []);
      var r = {
        delim: e.delim,
        options: t
      };
      n.isMiddle = r;
    }
    return n;
  },
  mathmlBuilder: (e, t) => {
    var n = e.delim === "\\vert" || e.delim === "|" ? Ji("|", "text") : Ji(e.delim, e.mode), r = new me.MathNode("mo", [n]);
    return r.setAttribute("fence", "true"), r.setAttribute("lspace", "0.05em"), r.setAttribute("rspace", "0.05em"), r;
  }
});
var Ob = (e, t) => {
  var n = ee.wrapFragment(It(e.body, t), t), r = e.label.slice(1), i = t.sizeMultiplier, a, l = 0, s = We.isCharacterBox(e.body);
  if (r === "sout")
    a = ee.makeSpan(["stretchy", "sout"]), a.height = t.fontMetrics().defaultRuleThickness / i, l = -0.5 * t.fontMetrics().xHeight;
  else if (r === "phase") {
    var c = Tn({
      number: 0.6,
      unit: "pt"
    }, t), d = Tn({
      number: 0.35,
      unit: "ex"
    }, t), o = t.havingBaseSizing();
    i = i / o.sizeMultiplier;
    var u = n.height + n.depth + c + d;
    n.style.paddingLeft = xe(u / 2 + c);
    var h = Math.floor(1e3 * u * i), f = Kz(h), p = new fs([new vo("phase", f)], {
      width: "400em",
      height: xe(h / 1e3),
      viewBox: "0 0 400000 " + h,
      preserveAspectRatio: "xMinYMin slice"
    });
    a = ee.makeSvgSpan(["hide-tail"], [p], t), a.style.height = xe(u), l = n.depth + c + d;
  } else {
    /cancel/.test(r) ? s || n.classes.push("cancel-pad") : r === "angl" ? n.classes.push("anglpad") : n.classes.push("boxpad");
    var g = 0, b = 0, v = 0;
    /box/.test(r) ? (v = Math.max(
      t.fontMetrics().fboxrule,
      // default
      t.minRuleThickness
      // User override.
    ), g = t.fontMetrics().fboxsep + (r === "colorbox" ? 0 : v), b = g) : r === "angl" ? (v = Math.max(t.fontMetrics().defaultRuleThickness, t.minRuleThickness), g = 4 * v, b = Math.max(0, 0.25 - n.depth)) : (g = s ? 0.2 : 0, b = g), a = ms.encloseSpan(n, r, g, b, t), /fbox|boxed|fcolorbox/.test(r) ? (a.style.borderStyle = "solid", a.style.borderWidth = xe(v)) : r === "angl" && v !== 0.049 && (a.style.borderTopWidth = xe(v), a.style.borderRightWidth = xe(v)), l = n.depth + b, e.backgroundColor && (a.style.backgroundColor = e.backgroundColor, e.borderColor && (a.style.borderColor = e.borderColor));
  }
  var U;
  if (e.backgroundColor)
    U = ee.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: a,
          shift: l
        },
        {
          type: "elem",
          elem: n,
          shift: 0
        }
      ]
    }, t);
  else {
    var y = /cancel|phase/.test(r) ? ["svg-align"] : [];
    U = ee.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: n,
          shift: 0
        },
        {
          type: "elem",
          elem: a,
          shift: l,
          wrapperClasses: y
        }
      ]
    }, t);
  }
  return /cancel/.test(r) && (U.height = n.height, U.depth = n.depth), /cancel/.test(r) && !s ? ee.makeSpan(["mord", "cancel-lap"], [U], t) : ee.makeSpan(["mord"], [U], t);
}, $b = (e, t) => {
  var n = 0, r = new me.MathNode(e.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [nn(e.body, t)]);
  switch (e.label) {
    case "\\cancel":
      r.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      r.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      r.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      r.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      r.setAttribute("notation", "box");
      break;
    case "\\angl":
      r.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      if (n = t.fontMetrics().fboxsep * t.fontMetrics().ptPerEm, r.setAttribute("width", "+" + 2 * n + "pt"), r.setAttribute("height", "+" + 2 * n + "pt"), r.setAttribute("lspace", n + "pt"), r.setAttribute("voffset", n + "pt"), e.label === "\\fcolorbox") {
        var i = Math.max(
          t.fontMetrics().fboxrule,
          // default
          t.minRuleThickness
          // user override
        );
        r.setAttribute("style", "border: " + i + "em solid " + String(e.borderColor));
      }
      break;
    case "\\xcancel":
      r.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  return e.backgroundColor && r.setAttribute("mathbackground", e.backgroundColor), r;
};
Te({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "text"]
  },
  handler(e, t, n) {
    var {
      parser: r,
      funcName: i
    } = e, a = bt(t[0], "color-token").color, l = t[1];
    return {
      type: "enclose",
      mode: r.mode,
      label: i,
      backgroundColor: a,
      body: l
    };
  },
  htmlBuilder: Ob,
  mathmlBuilder: $b
});
Te({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: !0,
    argTypes: ["color", "color", "text"]
  },
  handler(e, t, n) {
    var {
      parser: r,
      funcName: i
    } = e, a = bt(t[0], "color-token").color, l = bt(t[1], "color-token").color, s = t[2];
    return {
      type: "enclose",
      mode: r.mode,
      label: i,
      backgroundColor: l,
      borderColor: a,
      body: s
    };
  },
  htmlBuilder: Ob,
  mathmlBuilder: $b
});
Te({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: n
    } = e;
    return {
      type: "enclose",
      mode: n.mode,
      label: "\\fbox",
      body: t[0]
    };
  }
});
Te({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0];
    return {
      type: "enclose",
      mode: n.mode,
      label: r,
      body: i
    };
  },
  htmlBuilder: Ob,
  mathmlBuilder: $b
});
Te({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !1
  },
  handler(e, t) {
    var {
      parser: n
    } = e;
    return {
      type: "enclose",
      mode: n.mode,
      label: "\\angl",
      body: t[0]
    };
  }
});
var $M = {};
function Al(e) {
  for (var {
    type: t,
    names: n,
    props: r,
    handler: i,
    htmlBuilder: a,
    mathmlBuilder: l
  } = e, s = {
    type: t,
    numArgs: r.numArgs || 0,
    allowedInText: !1,
    numOptionalArgs: 0,
    handler: i
  }, c = 0; c < n.length; ++c)
    $M[n[c]] = s;
  a && (rm[t] = a), l && (im[t] = l);
}
var FM = {};
function O(e, t) {
  FM[e] = t;
}
function ty(e) {
  var t = [];
  e.consumeSpaces();
  var n = e.fetch().text;
  for (n === "\\relax" && (e.consume(), e.consumeSpaces(), n = e.fetch().text); n === "\\hline" || n === "\\hdashline"; )
    e.consume(), t.push(n === "\\hdashline"), e.consumeSpaces(), n = e.fetch().text;
  return t;
}
var Og = (e) => {
  var t = e.parser.settings;
  if (!t.displayMode)
    throw new be("{" + e.envName + "} can be used only in display mode.");
};
function Fb(e) {
  if (e.indexOf("ed") === -1)
    return e.indexOf("*") === -1;
}
function Ro(e, t, n) {
  var {
    hskipBeforeAndAfter: r,
    addJot: i,
    cols: a,
    arraystretch: l,
    colSeparationType: s,
    autoTag: c,
    singleRow: d,
    emptySingleRow: o,
    maxNumCols: u,
    leqno: h
  } = t;
  if (e.gullet.beginGroup(), d || e.gullet.macros.set("\\cr", "\\\\\\relax"), !l) {
    var f = e.gullet.expandMacroAsText("\\arraystretch");
    if (f == null)
      l = 1;
    else if (l = parseFloat(f), !l || l < 0)
      throw new be("Invalid \\arraystretch: " + f);
  }
  e.gullet.beginGroup();
  var p = [], g = [p], b = [], v = [], U = c != null ? [] : void 0;
  function y() {
    c && e.gullet.macros.set("\\@eqnsw", "1", !0);
  }
  function w() {
    U && (e.gullet.macros.get("\\df@tag") ? (U.push(e.subparse([new Vi("\\df@tag")])), e.gullet.macros.set("\\df@tag", void 0, !0)) : U.push(!!c && e.gullet.macros.get("\\@eqnsw") === "1"));
  }
  for (y(), v.push(ty(e)); ; ) {
    var x = e.parseExpression(!1, d ? "\\end" : "\\\\");
    e.gullet.endGroup(), e.gullet.beginGroup(), x = {
      type: "ordgroup",
      mode: e.mode,
      body: x
    }, n && (x = {
      type: "styling",
      mode: e.mode,
      style: n,
      body: [x]
    }), p.push(x);
    var E = e.fetch().text;
    if (E === "&") {
      if (u && p.length === u) {
        if (d || s)
          throw new be("Too many tab characters: &", e.nextToken);
        e.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
      }
      e.consume();
    } else if (E === "\\end") {
      w(), p.length === 1 && x.type === "styling" && x.body[0].body.length === 0 && (g.length > 1 || !o) && g.pop(), v.length < g.length + 1 && v.push([]);
      break;
    } else if (E === "\\\\") {
      e.consume();
      var S = void 0;
      e.gullet.future().text !== " " && (S = e.parseSizeGroup(!0)), b.push(S ? S.value : null), w(), v.push(ty(e)), p = [], g.push(p), y();
    } else
      throw new be("Expected & or \\\\ or \\cr or \\end", e.nextToken);
  }
  return e.gullet.endGroup(), e.gullet.endGroup(), {
    type: "array",
    mode: e.mode,
    addJot: i,
    arraystretch: l,
    body: g,
    cols: a,
    rowGaps: b,
    hskipBeforeAndAfter: r,
    hLinesBeforeRow: v,
    colSeparationType: s,
    tags: U,
    leqno: h
  };
}
function zb(e) {
  return e.slice(0, 1) === "d" ? "display" : "text";
}
var Nl = function(t, n) {
  var r, i, a = t.body.length, l = t.hLinesBeforeRow, s = 0, c = new Array(a), d = [], o = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    n.fontMetrics().arrayRuleWidth,
    n.minRuleThickness
    // User override.
  ), u = 1 / n.fontMetrics().ptPerEm, h = 5 * u;
  if (t.colSeparationType && t.colSeparationType === "small") {
    var f = n.havingStyle(Ye.SCRIPT).sizeMultiplier;
    h = 0.2778 * (f / n.sizeMultiplier);
  }
  var p = t.colSeparationType === "CD" ? Tn({
    number: 3,
    unit: "ex"
  }, n) : 12 * u, g = 3 * u, b = t.arraystretch * p, v = 0.7 * b, U = 0.3 * b, y = 0;
  function w(rr) {
    for (var Kt = 0; Kt < rr.length; ++Kt)
      Kt > 0 && (y += 0.25), d.push({
        pos: y,
        isDashed: rr[Kt]
      });
  }
  for (w(l[0]), r = 0; r < t.body.length; ++r) {
    var x = t.body[r], E = v, S = U;
    s < x.length && (s = x.length);
    var _ = new Array(x.length);
    for (i = 0; i < x.length; ++i) {
      var k = It(x[i], n);
      S < k.depth && (S = k.depth), E < k.height && (E = k.height), _[i] = k;
    }
    var M = t.rowGaps[r], A = 0;
    M && (A = Tn(M, n), A > 0 && (A += U, S < A && (S = A), A = 0)), t.addJot && (S += g), _.height = E, _.depth = S, y += E, _.pos = y, y += S + A, c[r] = _, w(l[r + 1]);
  }
  var L = y / 2 + n.fontMetrics().axisHeight, R = t.cols || [], z = [], F, W, B = [];
  if (t.tags && t.tags.some((rr) => rr))
    for (r = 0; r < a; ++r) {
      var j = c[r], V = j.pos - L, q = t.tags[r], oe = void 0;
      q === !0 ? oe = ee.makeSpan(["eqn-num"], [], n) : q === !1 ? oe = ee.makeSpan([], [], n) : oe = ee.makeSpan([], cr(q, n, !0), n), oe.depth = j.depth, oe.height = j.height, B.push({
        type: "elem",
        elem: oe,
        shift: V
      });
    }
  for (
    i = 0, W = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    i < s || W < R.length;
    ++i, ++W
  ) {
    for (var Ue = R[W] || {}, fe = !0; Ue.type === "separator"; ) {
      if (fe || (F = ee.makeSpan(["arraycolsep"], []), F.style.width = xe(n.fontMetrics().doubleRuleSep), z.push(F)), Ue.separator === "|" || Ue.separator === ":") {
        var Pe = Ue.separator === "|" ? "solid" : "dashed", ze = ee.makeSpan(["vertical-separator"], [], n);
        ze.style.height = xe(y), ze.style.borderRightWidth = xe(o), ze.style.borderRightStyle = Pe, ze.style.margin = "0 " + xe(-o / 2);
        var Oe = y - L;
        Oe && (ze.style.verticalAlign = xe(-Oe)), z.push(ze);
      } else
        throw new be("Invalid separator type: " + Ue.separator);
      W++, Ue = R[W] || {}, fe = !1;
    }
    if (!(i >= s)) {
      var Be = void 0;
      (i > 0 || t.hskipBeforeAndAfter) && (Be = We.deflt(Ue.pregap, h), Be !== 0 && (F = ee.makeSpan(["arraycolsep"], []), F.style.width = xe(Be), z.push(F)));
      var qe = [];
      for (r = 0; r < a; ++r) {
        var At = c[r], Je = At[i];
        if (Je) {
          var mt = At.pos - L;
          Je.depth = At.depth, Je.height = At.height, qe.push({
            type: "elem",
            elem: Je,
            shift: mt
          });
        }
      }
      qe = ee.makeVList({
        positionType: "individualShift",
        children: qe
      }, n), qe = ee.makeSpan(["col-align-" + (Ue.align || "c")], [qe]), z.push(qe), (i < s - 1 || t.hskipBeforeAndAfter) && (Be = We.deflt(Ue.postgap, h), Be !== 0 && (F = ee.makeSpan(["arraycolsep"], []), F.style.width = xe(Be), z.push(F)));
    }
  }
  if (c = ee.makeSpan(["mtable"], z), d.length > 0) {
    for (var jt = ee.makeLineSpan("hline", n, o), _e = ee.makeLineSpan("hdashline", n, o), rt = [{
      type: "elem",
      elem: c,
      shift: 0
    }]; d.length > 0; ) {
      var Xt = d.pop(), fr = Xt.pos - L;
      Xt.isDashed ? rt.push({
        type: "elem",
        elem: _e,
        shift: fr
      }) : rt.push({
        type: "elem",
        elem: jt,
        shift: fr
      });
    }
    c = ee.makeVList({
      positionType: "individualShift",
      children: rt
    }, n);
  }
  if (B.length === 0)
    return ee.makeSpan(["mord"], [c], n);
  var Qt = ee.makeVList({
    positionType: "individualShift",
    children: B
  }, n);
  return Qt = ee.makeSpan(["tag"], [Qt], n), ee.makeFragment([c, Qt]);
}, nH = {
  c: "center ",
  l: "left ",
  r: "right "
}, Dl = function(t, n) {
  for (var r = [], i = new me.MathNode("mtd", [], ["mtr-glue"]), a = new me.MathNode("mtd", [], ["mml-eqn-num"]), l = 0; l < t.body.length; l++) {
    for (var s = t.body[l], c = [], d = 0; d < s.length; d++)
      c.push(new me.MathNode("mtd", [nn(s[d], n)]));
    t.tags && t.tags[l] && (c.unshift(i), c.push(i), t.leqno ? c.unshift(a) : c.push(a)), r.push(new me.MathNode("mtr", c));
  }
  var o = new me.MathNode("mtable", r), u = t.arraystretch === 0.5 ? 0.1 : 0.16 + t.arraystretch - 1 + (t.addJot ? 0.09 : 0);
  o.setAttribute("rowspacing", xe(u));
  var h = "", f = "";
  if (t.cols && t.cols.length > 0) {
    var p = t.cols, g = "", b = !1, v = 0, U = p.length;
    p[0].type === "separator" && (h += "top ", v = 1), p[p.length - 1].type === "separator" && (h += "bottom ", U -= 1);
    for (var y = v; y < U; y++)
      p[y].type === "align" ? (f += nH[p[y].align], b && (g += "none "), b = !0) : p[y].type === "separator" && b && (g += p[y].separator === "|" ? "solid " : "dashed ", b = !1);
    o.setAttribute("columnalign", f.trim()), /[sd]/.test(g) && o.setAttribute("columnlines", g.trim());
  }
  if (t.colSeparationType === "align") {
    for (var w = t.cols || [], x = "", E = 1; E < w.length; E++)
      x += E % 2 ? "0em " : "1em ";
    o.setAttribute("columnspacing", x.trim());
  } else t.colSeparationType === "alignat" || t.colSeparationType === "gather" ? o.setAttribute("columnspacing", "0em") : t.colSeparationType === "small" ? o.setAttribute("columnspacing", "0.2778em") : t.colSeparationType === "CD" ? o.setAttribute("columnspacing", "0.5em") : o.setAttribute("columnspacing", "1em");
  var S = "", _ = t.hLinesBeforeRow;
  h += _[0].length > 0 ? "left " : "", h += _[_.length - 1].length > 0 ? "right " : "";
  for (var k = 1; k < _.length - 1; k++)
    S += _[k].length === 0 ? "none " : _[k][0] ? "dashed " : "solid ";
  return /[sd]/.test(S) && o.setAttribute("rowlines", S.trim()), h !== "" && (o = new me.MathNode("menclose", [o]), o.setAttribute("notation", h.trim())), t.arraystretch && t.arraystretch < 1 && (o = new me.MathNode("mstyle", [o]), o.setAttribute("scriptlevel", "1")), o;
}, zM = function(t, n) {
  t.envName.indexOf("ed") === -1 && Og(t);
  var r = [], i = t.envName.indexOf("at") > -1 ? "alignat" : "align", a = t.envName === "split", l = Ro(t.parser, {
    cols: r,
    addJot: !0,
    autoTag: a ? void 0 : Fb(t.envName),
    emptySingleRow: !0,
    colSeparationType: i,
    maxNumCols: a ? 2 : void 0,
    leqno: t.parser.settings.leqno
  }, "display"), s, c = 0, d = {
    type: "ordgroup",
    mode: t.mode,
    body: []
  };
  if (n[0] && n[0].type === "ordgroup") {
    for (var o = "", u = 0; u < n[0].body.length; u++) {
      var h = bt(n[0].body[u], "textord");
      o += h.text;
    }
    s = Number(o), c = s * 2;
  }
  var f = !c;
  l.body.forEach(function(v) {
    for (var U = 1; U < v.length; U += 2) {
      var y = bt(v[U], "styling"), w = bt(y.body[0], "ordgroup");
      w.body.unshift(d);
    }
    if (f)
      c < v.length && (c = v.length);
    else {
      var x = v.length / 2;
      if (s < x)
        throw new be("Too many math in a row: " + ("expected " + s + ", but got " + x), v[0]);
    }
  });
  for (var p = 0; p < c; ++p) {
    var g = "r", b = 0;
    p % 2 === 1 ? g = "l" : p > 0 && f && (b = 1), r[p] = {
      type: "align",
      align: g,
      pregap: b,
      postgap: 0
    };
  }
  return l.colSeparationType = f ? "align" : "alignat", l;
};
Al({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var n = Lg(t[0]), r = n ? [t[0]] : bt(t[0], "ordgroup").body, i = r.map(function(l) {
      var s = Lb(l), c = s.text;
      if ("lcr".indexOf(c) !== -1)
        return {
          type: "align",
          align: c
        };
      if (c === "|")
        return {
          type: "separator",
          separator: "|"
        };
      if (c === ":")
        return {
          type: "separator",
          separator: ":"
        };
      throw new be("Unknown column alignment: " + c, l);
    }), a = {
      cols: i,
      hskipBeforeAndAfter: !0,
      // \@preamble in lttab.dtx
      maxNumCols: i.length
    };
    return Ro(e.parser, a, zb(e.envName));
  },
  htmlBuilder: Nl,
  mathmlBuilder: Dl
});
Al({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var t = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[e.envName.replace("*", "")], n = "c", r = {
      hskipBeforeAndAfter: !1,
      cols: [{
        type: "align",
        align: n
      }]
    };
    if (e.envName.charAt(e.envName.length - 1) === "*") {
      var i = e.parser;
      if (i.consumeSpaces(), i.fetch().text === "[") {
        if (i.consume(), i.consumeSpaces(), n = i.fetch().text, "lcr".indexOf(n) === -1)
          throw new be("Expected l or c or r", i.nextToken);
        i.consume(), i.consumeSpaces(), i.expect("]"), i.consume(), r.cols = [{
          type: "align",
          align: n
        }];
      }
    }
    var a = Ro(e.parser, r, zb(e.envName)), l = Math.max(0, ...a.body.map((s) => s.length));
    return a.cols = new Array(l).fill({
      type: "align",
      align: n
    }), t ? {
      type: "leftright",
      mode: e.mode,
      body: [a],
      left: t[0],
      right: t[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : a;
  },
  htmlBuilder: Nl,
  mathmlBuilder: Dl
});
Al({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var t = {
      arraystretch: 0.5
    }, n = Ro(e.parser, t, "script");
    return n.colSeparationType = "small", n;
  },
  htmlBuilder: Nl,
  mathmlBuilder: Dl
});
Al({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var n = Lg(t[0]), r = n ? [t[0]] : bt(t[0], "ordgroup").body, i = r.map(function(l) {
      var s = Lb(l), c = s.text;
      if ("lc".indexOf(c) !== -1)
        return {
          type: "align",
          align: c
        };
      throw new be("Unknown column alignment: " + c, l);
    });
    if (i.length > 1)
      throw new be("{subarray} can contain only one column");
    var a = {
      cols: i,
      hskipBeforeAndAfter: !1,
      arraystretch: 0.5
    };
    if (a = Ro(e.parser, a, "script"), a.body.length > 0 && a.body[0].length > 1)
      throw new be("{subarray} can contain only one column");
    return a;
  },
  htmlBuilder: Nl,
  mathmlBuilder: Dl
});
Al({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var t = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    }, n = Ro(e.parser, t, zb(e.envName));
    return {
      type: "leftright",
      mode: e.mode,
      body: [n],
      left: e.envName.indexOf("r") > -1 ? "." : "\\{",
      right: e.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: Nl,
  mathmlBuilder: Dl
});
Al({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: zM,
  htmlBuilder: Nl,
  mathmlBuilder: Dl
});
Al({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(e) {
    We.contains(["gather", "gather*"], e.envName) && Og(e);
    var t = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: !0,
      colSeparationType: "gather",
      autoTag: Fb(e.envName),
      emptySingleRow: !0,
      leqno: e.parser.settings.leqno
    };
    return Ro(e.parser, t, "display");
  },
  htmlBuilder: Nl,
  mathmlBuilder: Dl
});
Al({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: zM,
  htmlBuilder: Nl,
  mathmlBuilder: Dl
});
Al({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(e) {
    Og(e);
    var t = {
      autoTag: Fb(e.envName),
      emptySingleRow: !0,
      singleRow: !0,
      maxNumCols: 1,
      leqno: e.parser.settings.leqno
    };
    return Ro(e.parser, t, "display");
  },
  htmlBuilder: Nl,
  mathmlBuilder: Dl
});
Al({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(e) {
    return Og(e), HB(e.parser);
  },
  htmlBuilder: Nl,
  mathmlBuilder: Dl
});
O("\\nonumber", "\\gdef\\@eqnsw{0}");
O("\\notag", "\\nonumber");
Te({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !0
  },
  handler(e, t) {
    throw new be(e.funcName + " valid only within array environment");
  }
});
var ny = $M;
Te({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0];
    if (i.type !== "ordgroup")
      throw new be("Invalid environment name", i);
    for (var a = "", l = 0; l < i.body.length; ++l)
      a += bt(i.body[l], "textord").text;
    if (r === "\\begin") {
      if (!ny.hasOwnProperty(a))
        throw new be("No such environment: " + a, i);
      var s = ny[a], {
        args: c,
        optArgs: d
      } = n.parseArguments("\\begin{" + a + "}", s), o = {
        mode: n.mode,
        envName: a,
        parser: n
      }, u = s.handler(o, c, d);
      n.expect("\\end", !1);
      var h = n.nextToken, f = bt(n.parseFunction(), "environment");
      if (f.name !== a)
        throw new be("Mismatch: \\begin{" + a + "} matched by \\end{" + f.name + "}", h);
      return u;
    }
    return {
      type: "environment",
      mode: n.mode,
      name: a,
      nameGroup: i
    };
  }
});
var BM = (e, t) => {
  var n = e.font, r = t.withFont(n);
  return It(e.body, r);
}, HM = (e, t) => {
  var n = e.font, r = t.withFont(n);
  return nn(e.body, r);
}, ry = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
Te({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\mathsfit",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: !0
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r
    } = e, i = am(t[0]), a = r;
    return a in ry && (a = ry[a]), {
      type: "font",
      mode: n.mode,
      font: a.slice(1),
      body: i
    };
  },
  htmlBuilder: BM,
  mathmlBuilder: HM
});
Te({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e, r = t[0], i = We.isCharacterBox(r);
    return {
      type: "mclass",
      mode: n.mode,
      mclass: Rg(r),
      body: [{
        type: "font",
        mode: n.mode,
        font: "boldsymbol",
        body: r
      }],
      isCharacterBox: i
    };
  }
});
Te({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r,
      breakOnTokenText: i
    } = e, {
      mode: a
    } = n, l = n.parseExpression(!0, i), s = "math" + r.slice(1);
    return {
      type: "font",
      mode: a,
      font: s,
      body: {
        type: "ordgroup",
        mode: n.mode,
        body: l
      }
    };
  },
  htmlBuilder: BM,
  mathmlBuilder: HM
});
var WM = (e, t) => {
  var n = t;
  return e === "display" ? n = n.id >= Ye.SCRIPT.id ? n.text() : Ye.DISPLAY : e === "text" && n.size === Ye.DISPLAY.size ? n = Ye.TEXT : e === "script" ? n = Ye.SCRIPT : e === "scriptscript" && (n = Ye.SCRIPTSCRIPT), n;
}, Bb = (e, t) => {
  var n = WM(e.size, t.style), r = n.fracNum(), i = n.fracDen(), a;
  a = t.havingStyle(r);
  var l = It(e.numer, a, t);
  if (e.continued) {
    var s = 8.5 / t.fontMetrics().ptPerEm, c = 3.5 / t.fontMetrics().ptPerEm;
    l.height = l.height < s ? s : l.height, l.depth = l.depth < c ? c : l.depth;
  }
  a = t.havingStyle(i);
  var d = It(e.denom, a, t), o, u, h;
  e.hasBarLine ? (e.barSize ? (u = Tn(e.barSize, t), o = ee.makeLineSpan("frac-line", t, u)) : o = ee.makeLineSpan("frac-line", t), u = o.height, h = o.height) : (o = null, u = 0, h = t.fontMetrics().defaultRuleThickness);
  var f, p, g;
  n.size === Ye.DISPLAY.size || e.size === "display" ? (f = t.fontMetrics().num1, u > 0 ? p = 3 * h : p = 7 * h, g = t.fontMetrics().denom1) : (u > 0 ? (f = t.fontMetrics().num2, p = h) : (f = t.fontMetrics().num3, p = 3 * h), g = t.fontMetrics().denom2);
  var b;
  if (o) {
    var U = t.fontMetrics().axisHeight;
    f - l.depth - (U + 0.5 * u) < p && (f += p - (f - l.depth - (U + 0.5 * u))), U - 0.5 * u - (d.height - g) < p && (g += p - (U - 0.5 * u - (d.height - g)));
    var y = -(U - 0.5 * u);
    b = ee.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: d,
        shift: g
      }, {
        type: "elem",
        elem: o,
        shift: y
      }, {
        type: "elem",
        elem: l,
        shift: -f
      }]
    }, t);
  } else {
    var v = f - l.depth - (d.height - g);
    v < p && (f += 0.5 * (p - v), g += 0.5 * (p - v)), b = ee.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: d,
        shift: g
      }, {
        type: "elem",
        elem: l,
        shift: -f
      }]
    }, t);
  }
  a = t.havingStyle(n), b.height *= a.sizeMultiplier / t.sizeMultiplier, b.depth *= a.sizeMultiplier / t.sizeMultiplier;
  var w;
  n.size === Ye.DISPLAY.size ? w = t.fontMetrics().delim1 : n.size === Ye.SCRIPTSCRIPT.size ? w = t.havingStyle(Ye.SCRIPT).fontMetrics().delim2 : w = t.fontMetrics().delim2;
  var x, E;
  return e.leftDelim == null ? x = Rh(t, ["mopen"]) : x = os.customSizedDelim(e.leftDelim, w, !0, t.havingStyle(n), e.mode, ["mopen"]), e.continued ? E = ee.makeSpan([]) : e.rightDelim == null ? E = Rh(t, ["mclose"]) : E = os.customSizedDelim(e.rightDelim, w, !0, t.havingStyle(n), e.mode, ["mclose"]), ee.makeSpan(["mord"].concat(a.sizingClasses(t)), [x, ee.makeSpan(["mfrac"], [b]), E], t);
}, Hb = (e, t) => {
  var n = new me.MathNode("mfrac", [nn(e.numer, t), nn(e.denom, t)]);
  if (!e.hasBarLine)
    n.setAttribute("linethickness", "0px");
  else if (e.barSize) {
    var r = Tn(e.barSize, t);
    n.setAttribute("linethickness", xe(r));
  }
  var i = WM(e.size, t.style);
  if (i.size !== t.style.size) {
    n = new me.MathNode("mstyle", [n]);
    var a = i.size === Ye.DISPLAY.size ? "true" : "false";
    n.setAttribute("displaystyle", a), n.setAttribute("scriptlevel", "0");
  }
  if (e.leftDelim != null || e.rightDelim != null) {
    var l = [];
    if (e.leftDelim != null) {
      var s = new me.MathNode("mo", [new me.TextNode(e.leftDelim.replace("\\", ""))]);
      s.setAttribute("fence", "true"), l.push(s);
    }
    if (l.push(n), e.rightDelim != null) {
      var c = new me.MathNode("mo", [new me.TextNode(e.rightDelim.replace("\\", ""))]);
      c.setAttribute("fence", "true"), l.push(c);
    }
    return Nb(l);
  }
  return n;
};
Te({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // can’t be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: !0
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0], a = t[1], l, s = null, c = null, d = "auto";
    switch (r) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        l = !0;
        break;
      case "\\\\atopfrac":
        l = !1;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        l = !1, s = "(", c = ")";
        break;
      case "\\\\bracefrac":
        l = !1, s = "\\{", c = "\\}";
        break;
      case "\\\\brackfrac":
        l = !1, s = "[", c = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (r) {
      case "\\dfrac":
      case "\\dbinom":
        d = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        d = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: n.mode,
      continued: !1,
      numer: i,
      denom: a,
      hasBarLine: l,
      leftDelim: s,
      rightDelim: c,
      size: d,
      barSize: null
    };
  },
  htmlBuilder: Bb,
  mathmlBuilder: Hb
});
Te({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0], a = t[1];
    return {
      type: "genfrac",
      mode: n.mode,
      continued: !0,
      numer: i,
      denom: a,
      hasBarLine: !0,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
Te({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: n,
      token: r
    } = e, i;
    switch (n) {
      case "\\over":
        i = "\\frac";
        break;
      case "\\choose":
        i = "\\binom";
        break;
      case "\\atop":
        i = "\\\\atopfrac";
        break;
      case "\\brace":
        i = "\\\\bracefrac";
        break;
      case "\\brack":
        i = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: t.mode,
      replaceWith: i,
      token: r
    };
  }
});
var iy = ["display", "text", "script", "scriptscript"], ay = function(t) {
  var n = null;
  return t.length > 0 && (n = t, n = n === "." ? null : n), n;
};
Te({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: !0,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(e, t) {
    var {
      parser: n
    } = e, r = t[4], i = t[5], a = am(t[0]), l = a.type === "atom" && a.family === "open" ? ay(a.text) : null, s = am(t[1]), c = s.type === "atom" && s.family === "close" ? ay(s.text) : null, d = bt(t[2], "size"), o, u = null;
    d.isBlank ? o = !0 : (u = d.value, o = u.number > 0);
    var h = "auto", f = t[3];
    if (f.type === "ordgroup") {
      if (f.body.length > 0) {
        var p = bt(f.body[0], "textord");
        h = iy[Number(p.text)];
      }
    } else
      f = bt(f, "textord"), h = iy[Number(f.text)];
    return {
      type: "genfrac",
      mode: n.mode,
      numer: r,
      denom: i,
      continued: !1,
      hasBarLine: o,
      barSize: u,
      leftDelim: l,
      rightDelim: c,
      size: h
    };
  },
  htmlBuilder: Bb,
  mathmlBuilder: Hb
});
Te({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: !0
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r,
      token: i
    } = e;
    return {
      type: "infix",
      mode: n.mode,
      replaceWith: "\\\\abovefrac",
      size: bt(t[0], "size").value,
      token: i
    };
  }
});
Te({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0], a = Dz(bt(t[1], "infix").size), l = t[2], s = a.number > 0;
    return {
      type: "genfrac",
      mode: n.mode,
      numer: i,
      denom: l,
      continued: !1,
      hasBarLine: s,
      barSize: a,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: Bb,
  mathmlBuilder: Hb
});
var XM = (e, t) => {
  var n = t.style, r, i;
  e.type === "supsub" ? (r = e.sup ? It(e.sup, t.havingStyle(n.sup()), t) : It(e.sub, t.havingStyle(n.sub()), t), i = bt(e.base, "horizBrace")) : i = bt(e, "horizBrace");
  var a = It(i.base, t.havingBaseStyle(Ye.DISPLAY)), l = ms.svgSpan(i, t), s;
  if (i.isOver ? (s = ee.makeVList({
    positionType: "firstBaseline",
    children: [{
      type: "elem",
      elem: a
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: l
    }]
  }, t), s.children[0].children[0].children[1].classes.push("svg-align")) : (s = ee.makeVList({
    positionType: "bottom",
    positionData: a.depth + 0.1 + l.height,
    children: [{
      type: "elem",
      elem: l
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: a
    }]
  }, t), s.children[0].children[0].children[0].classes.push("svg-align")), r) {
    var c = ee.makeSpan(["mord", i.isOver ? "mover" : "munder"], [s], t);
    i.isOver ? s = ee.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: c
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: r
      }]
    }, t) : s = ee.makeVList({
      positionType: "bottom",
      positionData: c.depth + 0.2 + r.height + r.depth,
      children: [{
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: c
      }]
    }, t);
  }
  return ee.makeSpan(["mord", i.isOver ? "mover" : "munder"], [s], t);
}, rH = (e, t) => {
  var n = ms.mathMLnode(e.label);
  return new me.MathNode(e.isOver ? "mover" : "munder", [nn(e.base, t), n]);
};
Te({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r
    } = e;
    return {
      type: "horizBrace",
      mode: n.mode,
      label: r,
      isOver: /^\\over/.test(r),
      base: t[0]
    };
  },
  htmlBuilder: XM,
  mathmlBuilder: rH
});
Te({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e, r = t[1], i = bt(t[0], "url").url;
    return n.settings.isTrusted({
      command: "\\href",
      url: i
    }) ? {
      type: "href",
      mode: n.mode,
      href: i,
      body: Gn(r)
    } : n.formatUnsupportedCmd("\\href");
  },
  htmlBuilder: (e, t) => {
    var n = cr(e.body, t, !1);
    return ee.makeAnchor(e.href, [], n, t);
  },
  mathmlBuilder: (e, t) => {
    var n = yo(e.body, t);
    return n instanceof xi || (n = new xi("mrow", [n])), n.setAttribute("href", e.href), n;
  }
});
Te({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e, r = bt(t[0], "url").url;
    if (!n.settings.isTrusted({
      command: "\\url",
      url: r
    }))
      return n.formatUnsupportedCmd("\\url");
    for (var i = [], a = 0; a < r.length; a++) {
      var l = r[a];
      l === "~" && (l = "\\textasciitilde"), i.push({
        type: "textord",
        mode: "text",
        text: l
      });
    }
    var s = {
      type: "text",
      mode: n.mode,
      font: "\\texttt",
      body: i
    };
    return {
      type: "href",
      mode: n.mode,
      href: r,
      body: Gn(s)
    };
  }
});
Te({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: !0,
    primitive: !0
  },
  handler(e, t) {
    var {
      parser: n
    } = e;
    return {
      type: "hbox",
      mode: n.mode,
      body: Gn(t[0])
    };
  },
  htmlBuilder(e, t) {
    var n = cr(e.body, t, !1);
    return ee.makeFragment(n);
  },
  mathmlBuilder(e, t) {
    return new me.MathNode("mrow", pi(e.body, t));
  }
});
Te({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r,
      token: i
    } = e, a = bt(t[0], "raw").string, l = t[1];
    n.settings.strict && n.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    var s, c = {};
    switch (r) {
      case "\\htmlClass":
        c.class = a, s = {
          command: "\\htmlClass",
          class: a
        };
        break;
      case "\\htmlId":
        c.id = a, s = {
          command: "\\htmlId",
          id: a
        };
        break;
      case "\\htmlStyle":
        c.style = a, s = {
          command: "\\htmlStyle",
          style: a
        };
        break;
      case "\\htmlData": {
        for (var d = a.split(","), o = 0; o < d.length; o++) {
          var u = d[o].split("=");
          if (u.length !== 2)
            throw new be("Error parsing key-value for \\htmlData");
          c["data-" + u[0].trim()] = u[1].trim();
        }
        s = {
          command: "\\htmlData",
          attributes: c
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    return n.settings.isTrusted(s) ? {
      type: "html",
      mode: n.mode,
      attributes: c,
      body: Gn(l)
    } : n.formatUnsupportedCmd(r);
  },
  htmlBuilder: (e, t) => {
    var n = cr(e.body, t, !1), r = ["enclosing"];
    e.attributes.class && r.push(...e.attributes.class.trim().split(/\s+/));
    var i = ee.makeSpan(r, n, t);
    for (var a in e.attributes)
      a !== "class" && e.attributes.hasOwnProperty(a) && i.setAttribute(a, e.attributes[a]);
    return i;
  },
  mathmlBuilder: (e, t) => yo(e.body, t)
});
Te({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e;
    return {
      type: "htmlmathml",
      mode: n.mode,
      html: Gn(t[0]),
      mathml: Gn(t[1])
    };
  },
  htmlBuilder: (e, t) => {
    var n = cr(e.html, t, !1);
    return ee.makeFragment(n);
  },
  mathmlBuilder: (e, t) => yo(e.mathml, t)
});
var f6 = function(t) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(t))
    return {
      number: +t,
      unit: "bp"
    };
  var n = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(t);
  if (!n)
    throw new be("Invalid size: '" + t + "' in \\includegraphics");
  var r = {
    number: +(n[1] + n[2]),
    // sign + magnitude, cast to number
    unit: n[3]
  };
  if (!cM(r))
    throw new be("Invalid unit: '" + r.unit + "' in \\includegraphics.");
  return r;
};
Te({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: !1
  },
  handler: (e, t, n) => {
    var {
      parser: r
    } = e, i = {
      number: 0,
      unit: "em"
    }, a = {
      number: 0.9,
      unit: "em"
    }, l = {
      number: 0,
      unit: "em"
    }, s = "";
    if (n[0])
      for (var c = bt(n[0], "raw").string, d = c.split(","), o = 0; o < d.length; o++) {
        var u = d[o].split("=");
        if (u.length === 2) {
          var h = u[1].trim();
          switch (u[0].trim()) {
            case "alt":
              s = h;
              break;
            case "width":
              i = f6(h);
              break;
            case "height":
              a = f6(h);
              break;
            case "totalheight":
              l = f6(h);
              break;
            default:
              throw new be("Invalid key: '" + u[0] + "' in \\includegraphics.");
          }
        }
      }
    var f = bt(t[0], "url").url;
    return s === "" && (s = f, s = s.replace(/^.*[\\/]/, ""), s = s.substring(0, s.lastIndexOf("."))), r.settings.isTrusted({
      command: "\\includegraphics",
      url: f
    }) ? {
      type: "includegraphics",
      mode: r.mode,
      alt: s,
      width: i,
      height: a,
      totalheight: l,
      src: f
    } : r.formatUnsupportedCmd("\\includegraphics");
  },
  htmlBuilder: (e, t) => {
    var n = Tn(e.height, t), r = 0;
    e.totalheight.number > 0 && (r = Tn(e.totalheight, t) - n);
    var i = 0;
    e.width.number > 0 && (i = Tn(e.width, t));
    var a = {
      height: xe(n + r)
    };
    i > 0 && (a.width = xe(i)), r > 0 && (a.verticalAlign = xe(-r));
    var l = new rB(e.src, e.alt, a);
    return l.height = n, l.depth = r, l;
  },
  mathmlBuilder: (e, t) => {
    var n = new me.MathNode("mglyph", []);
    n.setAttribute("alt", e.alt);
    var r = Tn(e.height, t), i = 0;
    if (e.totalheight.number > 0 && (i = Tn(e.totalheight, t) - r, n.setAttribute("valign", xe(-i))), n.setAttribute("height", xe(r + i)), e.width.number > 0) {
      var a = Tn(e.width, t);
      n.setAttribute("width", xe(a));
    }
    return n.setAttribute("src", e.src), n;
  }
});
Te({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: !0,
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r
    } = e, i = bt(t[0], "size");
    if (n.settings.strict) {
      var a = r[1] === "m", l = i.value.unit === "mu";
      a ? (l || n.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " supports only mu units, " + ("not " + i.value.unit + " units")), n.mode !== "math" && n.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " works only in math mode")) : l && n.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " doesn't support mu units");
    }
    return {
      type: "kern",
      mode: n.mode,
      dimension: i.value
    };
  },
  htmlBuilder(e, t) {
    return ee.makeGlue(e.dimension, t);
  },
  mathmlBuilder(e, t) {
    var n = Tn(e.dimension, t);
    return new me.SpaceNode(n);
  }
});
Te({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0];
    return {
      type: "lap",
      mode: n.mode,
      alignment: r.slice(5),
      body: i
    };
  },
  htmlBuilder: (e, t) => {
    var n;
    e.alignment === "clap" ? (n = ee.makeSpan([], [It(e.body, t)]), n = ee.makeSpan(["inner"], [n], t)) : n = ee.makeSpan(["inner"], [It(e.body, t)]);
    var r = ee.makeSpan(["fix"], []), i = ee.makeSpan([e.alignment], [n, r], t), a = ee.makeSpan(["strut"]);
    return a.style.height = xe(i.height + i.depth), i.depth && (a.style.verticalAlign = xe(-i.depth)), i.children.unshift(a), i = ee.makeSpan(["thinbox"], [i], t), ee.makeSpan(["mord", "vbox"], [i], t);
  },
  mathmlBuilder: (e, t) => {
    var n = new me.MathNode("mpadded", [nn(e.body, t)]);
    if (e.alignment !== "rlap") {
      var r = e.alignment === "llap" ? "-1" : "-0.5";
      n.setAttribute("lspace", r + "width");
    }
    return n.setAttribute("width", "0px"), n;
  }
});
Te({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(e, t) {
    var {
      funcName: n,
      parser: r
    } = e, i = r.mode;
    r.switchMode("math");
    var a = n === "\\(" ? "\\)" : "$", l = r.parseExpression(!1, a);
    return r.expect(a), r.switchMode(i), {
      type: "styling",
      mode: r.mode,
      style: "text",
      body: l
    };
  }
});
Te({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(e, t) {
    throw new be("Mismatched " + e.funcName);
  }
});
var ly = (e, t) => {
  switch (t.style.size) {
    case Ye.DISPLAY.size:
      return e.display;
    case Ye.TEXT.size:
      return e.text;
    case Ye.SCRIPT.size:
      return e.script;
    case Ye.SCRIPTSCRIPT.size:
      return e.scriptscript;
    default:
      return e.text;
  }
};
Te({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: !0
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e;
    return {
      type: "mathchoice",
      mode: n.mode,
      display: Gn(t[0]),
      text: Gn(t[1]),
      script: Gn(t[2]),
      scriptscript: Gn(t[3])
    };
  },
  htmlBuilder: (e, t) => {
    var n = ly(e, t), r = cr(n, t, !1);
    return ee.makeFragment(r);
  },
  mathmlBuilder: (e, t) => {
    var n = ly(e, t);
    return yo(n, t);
  }
});
var VM = (e, t, n, r, i, a, l) => {
  e = ee.makeSpan([], [e]);
  var s = n && We.isCharacterBox(n), c, d;
  if (t) {
    var o = It(t, r.havingStyle(i.sup()), r);
    d = {
      elem: o,
      kern: Math.max(r.fontMetrics().bigOpSpacing1, r.fontMetrics().bigOpSpacing3 - o.depth)
    };
  }
  if (n) {
    var u = It(n, r.havingStyle(i.sub()), r);
    c = {
      elem: u,
      kern: Math.max(r.fontMetrics().bigOpSpacing2, r.fontMetrics().bigOpSpacing4 - u.height)
    };
  }
  var h;
  if (d && c) {
    var f = r.fontMetrics().bigOpSpacing5 + c.elem.height + c.elem.depth + c.kern + e.depth + l;
    h = ee.makeVList({
      positionType: "bottom",
      positionData: f,
      children: [{
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: c.elem,
        marginLeft: xe(-a)
      }, {
        type: "kern",
        size: c.kern
      }, {
        type: "elem",
        elem: e
      }, {
        type: "kern",
        size: d.kern
      }, {
        type: "elem",
        elem: d.elem,
        marginLeft: xe(a)
      }, {
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }]
    }, r);
  } else if (c) {
    var p = e.height - l;
    h = ee.makeVList({
      positionType: "top",
      positionData: p,
      children: [{
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: c.elem,
        marginLeft: xe(-a)
      }, {
        type: "kern",
        size: c.kern
      }, {
        type: "elem",
        elem: e
      }]
    }, r);
  } else if (d) {
    var g = e.depth + l;
    h = ee.makeVList({
      positionType: "bottom",
      positionData: g,
      children: [{
        type: "elem",
        elem: e
      }, {
        type: "kern",
        size: d.kern
      }, {
        type: "elem",
        elem: d.elem,
        marginLeft: xe(a)
      }, {
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }]
    }, r);
  } else
    return e;
  var b = [h];
  if (c && a !== 0 && !s) {
    var v = ee.makeSpan(["mspace"], [], r);
    v.style.marginRight = xe(a), b.unshift(v);
  }
  return ee.makeSpan(["mop", "op-limits"], b, r);
}, GM = ["\\smallint"], j0 = (e, t) => {
  var n, r, i = !1, a;
  e.type === "supsub" ? (n = e.sup, r = e.sub, a = bt(e.base, "op"), i = !0) : a = bt(e, "op");
  var l = t.style, s = !1;
  l.size === Ye.DISPLAY.size && a.symbol && !We.contains(GM, a.name) && (s = !0);
  var c;
  if (a.symbol) {
    var d = s ? "Size2-Regular" : "Size1-Regular", o = "";
    if ((a.name === "\\oiint" || a.name === "\\oiiint") && (o = a.name.slice(1), a.name = o === "oiint" ? "\\iint" : "\\iiint"), c = ee.makeSymbol(a.name, d, "math", t, ["mop", "op-symbol", s ? "large-op" : "small-op"]), o.length > 0) {
      var u = c.italic, h = ee.staticSvg(o + "Size" + (s ? "2" : "1"), t);
      c = ee.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: c,
          shift: 0
        }, {
          type: "elem",
          elem: h,
          shift: s ? 0.08 : 0
        }]
      }, t), a.name = "\\" + o, c.classes.unshift("mop"), c.italic = u;
    }
  } else if (a.body) {
    var f = cr(a.body, t, !0);
    f.length === 1 && f[0] instanceof Zi ? (c = f[0], c.classes[0] = "mop") : c = ee.makeSpan(["mop"], f, t);
  } else {
    for (var p = [], g = 1; g < a.name.length; g++)
      p.push(ee.mathsym(a.name[g], a.mode, t));
    c = ee.makeSpan(["mop"], p, t);
  }
  var b = 0, v = 0;
  return (c instanceof Zi || a.name === "\\oiint" || a.name === "\\oiiint") && !a.suppressBaseShift && (b = (c.height - c.depth) / 2 - t.fontMetrics().axisHeight, v = c.italic), i ? VM(c, n, r, t, l, v, b) : (b && (c.style.position = "relative", c.style.top = xe(b)), c);
}, Nf = (e, t) => {
  var n;
  if (e.symbol)
    n = new xi("mo", [Ji(e.name, e.mode)]), We.contains(GM, e.name) && n.setAttribute("largeop", "false");
  else if (e.body)
    n = new xi("mo", pi(e.body, t));
  else {
    n = new xi("mi", [new ml(e.name.slice(1))]);
    var r = new xi("mo", [Ji("⁡", "text")]);
    e.parentIsSupSub ? n = new xi("mrow", [n, r]) : n = yM([n, r]);
  }
  return n;
}, iH = {
  "∏": "\\prod",
  "∐": "\\coprod",
  "∑": "\\sum",
  "⋀": "\\bigwedge",
  "⋁": "\\bigvee",
  "⋂": "\\bigcap",
  "⋃": "\\bigcup",
  "⨀": "\\bigodot",
  "⨁": "\\bigoplus",
  "⨂": "\\bigotimes",
  "⨄": "\\biguplus",
  "⨆": "\\bigsqcup"
};
Te({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "∏", "∐", "∑", "⋀", "⋁", "⋂", "⋃", "⨀", "⨁", "⨂", "⨄", "⨆"],
  props: {
    numArgs: 0
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r
    } = e, i = r;
    return i.length === 1 && (i = iH[i]), {
      type: "op",
      mode: n.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !0,
      name: i
    };
  },
  htmlBuilder: j0,
  mathmlBuilder: Nf
});
Te({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e, r = t[0];
    return {
      type: "op",
      mode: n.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      body: Gn(r)
    };
  },
  htmlBuilder: j0,
  mathmlBuilder: Nf
});
var aH = {
  "∫": "\\int",
  "∬": "\\iint",
  "∭": "\\iiint",
  "∮": "\\oint",
  "∯": "\\oiint",
  "∰": "\\oiiint"
};
Te({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var {
      parser: t,
      funcName: n
    } = e;
    return {
      type: "op",
      mode: t.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      name: n
    };
  },
  htmlBuilder: j0,
  mathmlBuilder: Nf
});
Te({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var {
      parser: t,
      funcName: n
    } = e;
    return {
      type: "op",
      mode: t.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !1,
      name: n
    };
  },
  htmlBuilder: j0,
  mathmlBuilder: Nf
});
Te({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "∫", "∬", "∭", "∮", "∯", "∰"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var {
      parser: t,
      funcName: n
    } = e, r = n;
    return r.length === 1 && (r = aH[r]), {
      type: "op",
      mode: t.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !0,
      name: r
    };
  },
  htmlBuilder: j0,
  mathmlBuilder: Nf
});
var jM = (e, t) => {
  var n, r, i = !1, a;
  e.type === "supsub" ? (n = e.sup, r = e.sub, a = bt(e.base, "operatorname"), i = !0) : a = bt(e, "operatorname");
  var l;
  if (a.body.length > 0) {
    for (var s = a.body.map((u) => {
      var h = u.text;
      return typeof h == "string" ? {
        type: "textord",
        mode: u.mode,
        text: h
      } : u;
    }), c = cr(s, t.withFont("mathrm"), !0), d = 0; d < c.length; d++) {
      var o = c[d];
      o instanceof Zi && (o.text = o.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
    }
    l = ee.makeSpan(["mop"], c, t);
  } else
    l = ee.makeSpan(["mop"], [], t);
  return i ? VM(l, n, r, t, t.style, 0, 0) : l;
}, lH = (e, t) => {
  for (var n = pi(e.body, t.withFont("mathrm")), r = !0, i = 0; i < n.length; i++) {
    var a = n[i];
    if (!(a instanceof me.SpaceNode)) if (a instanceof me.MathNode)
      switch (a.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        case "mo": {
          var l = a.children[0];
          a.children.length === 1 && l instanceof me.TextNode ? l.text = l.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : r = !1;
          break;
        }
        default:
          r = !1;
      }
    else
      r = !1;
  }
  if (r) {
    var s = n.map((o) => o.toText()).join("");
    n = [new me.TextNode(s)];
  }
  var c = new me.MathNode("mi", n);
  c.setAttribute("mathvariant", "normal");
  var d = new me.MathNode("mo", [Ji("⁡", "text")]);
  return e.parentIsSupSub ? new me.MathNode("mrow", [c, d]) : me.newDocumentFragment([c, d]);
};
Te({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (e, t) => {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0];
    return {
      type: "operatorname",
      mode: n.mode,
      body: Gn(i),
      alwaysHandleSupSub: r === "\\operatornamewithlimits",
      limits: !1,
      parentIsSupSub: !1
    };
  },
  htmlBuilder: jM,
  mathmlBuilder: lH
});
O("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
ld({
  type: "ordgroup",
  htmlBuilder(e, t) {
    return e.semisimple ? ee.makeFragment(cr(e.body, t, !1)) : ee.makeSpan(["mord"], cr(e.body, t, !0), t);
  },
  mathmlBuilder(e, t) {
    return yo(e.body, t, !0);
  }
});
Te({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: n
    } = e, r = t[0];
    return {
      type: "overline",
      mode: n.mode,
      body: r
    };
  },
  htmlBuilder(e, t) {
    var n = It(e.body, t.havingCrampedStyle()), r = ee.makeLineSpan("overline-line", t), i = t.fontMetrics().defaultRuleThickness, a = ee.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: i
      }]
    }, t);
    return ee.makeSpan(["mord", "overline"], [a], t);
  },
  mathmlBuilder(e, t) {
    var n = new me.MathNode("mo", [new me.TextNode("‾")]);
    n.setAttribute("stretchy", "true");
    var r = new me.MathNode("mover", [nn(e.body, t), n]);
    return r.setAttribute("accent", "true"), r;
  }
});
Te({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e, r = t[0];
    return {
      type: "phantom",
      mode: n.mode,
      body: Gn(r)
    };
  },
  htmlBuilder: (e, t) => {
    var n = cr(e.body, t.withPhantom(), !1);
    return ee.makeFragment(n);
  },
  mathmlBuilder: (e, t) => {
    var n = pi(e.body, t);
    return new me.MathNode("mphantom", n);
  }
});
Te({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e, r = t[0];
    return {
      type: "hphantom",
      mode: n.mode,
      body: r
    };
  },
  htmlBuilder: (e, t) => {
    var n = ee.makeSpan([], [It(e.body, t.withPhantom())]);
    if (n.height = 0, n.depth = 0, n.children)
      for (var r = 0; r < n.children.length; r++)
        n.children[r].height = 0, n.children[r].depth = 0;
    return n = ee.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: n
      }]
    }, t), ee.makeSpan(["mord"], [n], t);
  },
  mathmlBuilder: (e, t) => {
    var n = pi(Gn(e.body), t), r = new me.MathNode("mphantom", n), i = new me.MathNode("mpadded", [r]);
    return i.setAttribute("height", "0px"), i.setAttribute("depth", "0px"), i;
  }
});
Te({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: n
    } = e, r = t[0];
    return {
      type: "vphantom",
      mode: n.mode,
      body: r
    };
  },
  htmlBuilder: (e, t) => {
    var n = ee.makeSpan(["inner"], [It(e.body, t.withPhantom())]), r = ee.makeSpan(["fix"], []);
    return ee.makeSpan(["mord", "rlap"], [n, r], t);
  },
  mathmlBuilder: (e, t) => {
    var n = pi(Gn(e.body), t), r = new me.MathNode("mphantom", n), i = new me.MathNode("mpadded", [r]);
    return i.setAttribute("width", "0px"), i;
  }
});
Te({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: n
    } = e, r = bt(t[0], "size").value, i = t[1];
    return {
      type: "raisebox",
      mode: n.mode,
      dy: r,
      body: i
    };
  },
  htmlBuilder(e, t) {
    var n = It(e.body, t), r = Tn(e.dy, t);
    return ee.makeVList({
      positionType: "shift",
      positionData: -r,
      children: [{
        type: "elem",
        elem: n
      }]
    }, t);
  },
  mathmlBuilder(e, t) {
    var n = new me.MathNode("mpadded", [nn(e.body, t)]), r = e.dy.number + e.dy.unit;
    return n.setAttribute("voffset", r), n;
  }
});
Te({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInArgument: !0
  },
  handler(e) {
    var {
      parser: t
    } = e;
    return {
      type: "internal",
      mode: t.mode
    };
  }
});
Te({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    argTypes: ["size", "size", "size"]
  },
  handler(e, t, n) {
    var {
      parser: r
    } = e, i = n[0], a = bt(t[0], "size"), l = bt(t[1], "size");
    return {
      type: "rule",
      mode: r.mode,
      shift: i && bt(i, "size").value,
      width: a.value,
      height: l.value
    };
  },
  htmlBuilder(e, t) {
    var n = ee.makeSpan(["mord", "rule"], [], t), r = Tn(e.width, t), i = Tn(e.height, t), a = e.shift ? Tn(e.shift, t) : 0;
    return n.style.borderRightWidth = xe(r), n.style.borderTopWidth = xe(i), n.style.bottom = xe(a), n.width = r, n.height = i + a, n.depth = -a, n.maxFontSize = i * 1.125 * t.sizeMultiplier, n;
  },
  mathmlBuilder(e, t) {
    var n = Tn(e.width, t), r = Tn(e.height, t), i = e.shift ? Tn(e.shift, t) : 0, a = t.color && t.getColor() || "black", l = new me.MathNode("mspace");
    l.setAttribute("mathbackground", a), l.setAttribute("width", xe(n)), l.setAttribute("height", xe(r));
    var s = new me.MathNode("mpadded", [l]);
    return i >= 0 ? s.setAttribute("height", xe(i)) : (s.setAttribute("height", xe(i)), s.setAttribute("depth", xe(-i))), s.setAttribute("voffset", xe(i)), s;
  }
});
function KM(e, t, n) {
  for (var r = cr(e, t, !1), i = t.sizeMultiplier / n.sizeMultiplier, a = 0; a < r.length; a++) {
    var l = r[a].classes.indexOf("sizing");
    l < 0 ? Array.prototype.push.apply(r[a].classes, t.sizingClasses(n)) : r[a].classes[l + 1] === "reset-size" + t.size && (r[a].classes[l + 1] = "reset-size" + n.size), r[a].height *= i, r[a].depth *= i;
  }
  return ee.makeFragment(r);
}
var sy = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], sH = (e, t) => {
  var n = t.havingSize(e.size);
  return KM(e.body, n, t);
};
Te({
  type: "sizing",
  names: sy,
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      breakOnTokenText: n,
      funcName: r,
      parser: i
    } = e, a = i.parseExpression(!1, n);
    return {
      type: "sizing",
      mode: i.mode,
      // Figure out what size to use based on the list of functions above
      size: sy.indexOf(r) + 1,
      body: a
    };
  },
  htmlBuilder: sH,
  mathmlBuilder: (e, t) => {
    var n = t.havingSize(e.size), r = pi(e.body, n), i = new me.MathNode("mstyle", r);
    return i.setAttribute("mathsize", xe(n.sizeMultiplier)), i;
  }
});
Te({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: !0
  },
  handler: (e, t, n) => {
    var {
      parser: r
    } = e, i = !1, a = !1, l = n[0] && bt(n[0], "ordgroup");
    if (l)
      for (var s = "", c = 0; c < l.body.length; ++c) {
        var d = l.body[c];
        if (s = d.text, s === "t")
          i = !0;
        else if (s === "b")
          a = !0;
        else {
          i = !1, a = !1;
          break;
        }
      }
    else
      i = !0, a = !0;
    var o = t[0];
    return {
      type: "smash",
      mode: r.mode,
      body: o,
      smashHeight: i,
      smashDepth: a
    };
  },
  htmlBuilder: (e, t) => {
    var n = ee.makeSpan([], [It(e.body, t)]);
    if (!e.smashHeight && !e.smashDepth)
      return n;
    if (e.smashHeight && (n.height = 0, n.children))
      for (var r = 0; r < n.children.length; r++)
        n.children[r].height = 0;
    if (e.smashDepth && (n.depth = 0, n.children))
      for (var i = 0; i < n.children.length; i++)
        n.children[i].depth = 0;
    var a = ee.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: n
      }]
    }, t);
    return ee.makeSpan(["mord"], [a], t);
  },
  mathmlBuilder: (e, t) => {
    var n = new me.MathNode("mpadded", [nn(e.body, t)]);
    return e.smashHeight && n.setAttribute("height", "0px"), e.smashDepth && n.setAttribute("depth", "0px"), n;
  }
});
Te({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(e, t, n) {
    var {
      parser: r
    } = e, i = n[0], a = t[0];
    return {
      type: "sqrt",
      mode: r.mode,
      body: a,
      index: i
    };
  },
  htmlBuilder(e, t) {
    var n = It(e.body, t.havingCrampedStyle());
    n.height === 0 && (n.height = t.fontMetrics().xHeight), n = ee.wrapFragment(n, t);
    var r = t.fontMetrics(), i = r.defaultRuleThickness, a = i;
    t.style.id < Ye.TEXT.id && (a = t.fontMetrics().xHeight);
    var l = i + a / 4, s = n.height + n.depth + l + i, {
      span: c,
      ruleWidth: d,
      advanceWidth: o
    } = os.sqrtImage(s, t), u = c.height - d;
    u > n.height + n.depth + l && (l = (l + u - n.height - n.depth) / 2);
    var h = c.height - n.height - l - d;
    n.style.paddingLeft = xe(o);
    var f = ee.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: n,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(n.height + h)
      }, {
        type: "elem",
        elem: c
      }, {
        type: "kern",
        size: d
      }]
    }, t);
    if (e.index) {
      var p = t.havingStyle(Ye.SCRIPTSCRIPT), g = It(e.index, p, t), b = 0.6 * (f.height - f.depth), v = ee.makeVList({
        positionType: "shift",
        positionData: -b,
        children: [{
          type: "elem",
          elem: g
        }]
      }, t), U = ee.makeSpan(["root"], [v]);
      return ee.makeSpan(["mord", "sqrt"], [U, f], t);
    } else
      return ee.makeSpan(["mord", "sqrt"], [f], t);
  },
  mathmlBuilder(e, t) {
    var {
      body: n,
      index: r
    } = e;
    return r ? new me.MathNode("mroot", [nn(n, t), nn(r, t)]) : new me.MathNode("msqrt", [nn(n, t)]);
  }
});
var oy = {
  display: Ye.DISPLAY,
  text: Ye.TEXT,
  script: Ye.SCRIPT,
  scriptscript: Ye.SCRIPTSCRIPT
};
Te({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(e, t) {
    var {
      breakOnTokenText: n,
      funcName: r,
      parser: i
    } = e, a = i.parseExpression(!0, n), l = r.slice(1, r.length - 5);
    return {
      type: "styling",
      mode: i.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style: l,
      body: a
    };
  },
  htmlBuilder(e, t) {
    var n = oy[e.style], r = t.havingStyle(n).withFont("");
    return KM(e.body, r, t);
  },
  mathmlBuilder(e, t) {
    var n = oy[e.style], r = t.havingStyle(n), i = pi(e.body, r), a = new me.MathNode("mstyle", i), l = {
      display: ["0", "true"],
      text: ["0", "false"],
      script: ["1", "false"],
      scriptscript: ["2", "false"]
    }, s = l[e.style];
    return a.setAttribute("scriptlevel", s[0]), a.setAttribute("displaystyle", s[1]), a;
  }
});
var oH = function(t, n) {
  var r = t.base;
  if (r)
    if (r.type === "op") {
      var i = r.limits && (n.style.size === Ye.DISPLAY.size || r.alwaysHandleSupSub);
      return i ? j0 : null;
    } else if (r.type === "operatorname") {
      var a = r.alwaysHandleSupSub && (n.style.size === Ye.DISPLAY.size || r.limits);
      return a ? jM : null;
    } else {
      if (r.type === "accent")
        return We.isCharacterBox(r.base) ? Rb : null;
      if (r.type === "horizBrace") {
        var l = !t.sub;
        return l === r.isOver ? XM : null;
      } else
        return null;
    }
  else return null;
};
ld({
  type: "supsub",
  htmlBuilder(e, t) {
    var n = oH(e, t);
    if (n)
      return n(e, t);
    var {
      base: r,
      sup: i,
      sub: a
    } = e, l = It(r, t), s, c, d = t.fontMetrics(), o = 0, u = 0, h = r && We.isCharacterBox(r);
    if (i) {
      var f = t.havingStyle(t.style.sup());
      s = It(i, f, t), h || (o = l.height - f.fontMetrics().supDrop * f.sizeMultiplier / t.sizeMultiplier);
    }
    if (a) {
      var p = t.havingStyle(t.style.sub());
      c = It(a, p, t), h || (u = l.depth + p.fontMetrics().subDrop * p.sizeMultiplier / t.sizeMultiplier);
    }
    var g;
    t.style === Ye.DISPLAY ? g = d.sup1 : t.style.cramped ? g = d.sup3 : g = d.sup2;
    var b = t.sizeMultiplier, v = xe(0.5 / d.ptPerEm / b), U = null;
    if (c) {
      var y = e.base && e.base.type === "op" && e.base.name && (e.base.name === "\\oiint" || e.base.name === "\\oiiint");
      (l instanceof Zi || y) && (U = xe(-l.italic));
    }
    var w;
    if (s && c) {
      o = Math.max(o, g, s.depth + 0.25 * d.xHeight), u = Math.max(u, d.sub2);
      var x = d.defaultRuleThickness, E = 4 * x;
      if (o - s.depth - (c.height - u) < E) {
        u = E - (o - s.depth) + c.height;
        var S = 0.8 * d.xHeight - (o - s.depth);
        S > 0 && (o += S, u -= S);
      }
      var _ = [{
        type: "elem",
        elem: c,
        shift: u,
        marginRight: v,
        marginLeft: U
      }, {
        type: "elem",
        elem: s,
        shift: -o,
        marginRight: v
      }];
      w = ee.makeVList({
        positionType: "individualShift",
        children: _
      }, t);
    } else if (c) {
      u = Math.max(u, d.sub1, c.height - 0.8 * d.xHeight);
      var k = [{
        type: "elem",
        elem: c,
        marginLeft: U,
        marginRight: v
      }];
      w = ee.makeVList({
        positionType: "shift",
        positionData: u,
        children: k
      }, t);
    } else if (s)
      o = Math.max(o, g, s.depth + 0.25 * d.xHeight), w = ee.makeVList({
        positionType: "shift",
        positionData: -o,
        children: [{
          type: "elem",
          elem: s,
          marginRight: v
        }]
      }, t);
    else
      throw new Error("supsub must have either sup or sub.");
    var M = I4(l, "right") || "mord";
    return ee.makeSpan([M], [l, ee.makeSpan(["msupsub"], [w])], t);
  },
  mathmlBuilder(e, t) {
    var n = !1, r, i;
    e.base && e.base.type === "horizBrace" && (i = !!e.sup, i === e.base.isOver && (n = !0, r = e.base.isOver)), e.base && (e.base.type === "op" || e.base.type === "operatorname") && (e.base.parentIsSupSub = !0);
    var a = [nn(e.base, t)];
    e.sub && a.push(nn(e.sub, t)), e.sup && a.push(nn(e.sup, t));
    var l;
    if (n)
      l = r ? "mover" : "munder";
    else if (e.sub)
      if (e.sup) {
        var d = e.base;
        d && d.type === "op" && d.limits && t.style === Ye.DISPLAY || d && d.type === "operatorname" && d.alwaysHandleSupSub && (t.style === Ye.DISPLAY || d.limits) ? l = "munderover" : l = "msubsup";
      } else {
        var c = e.base;
        c && c.type === "op" && c.limits && (t.style === Ye.DISPLAY || c.alwaysHandleSupSub) || c && c.type === "operatorname" && c.alwaysHandleSupSub && (c.limits || t.style === Ye.DISPLAY) ? l = "munder" : l = "msub";
      }
    else {
      var s = e.base;
      s && s.type === "op" && s.limits && (t.style === Ye.DISPLAY || s.alwaysHandleSupSub) || s && s.type === "operatorname" && s.alwaysHandleSupSub && (s.limits || t.style === Ye.DISPLAY) ? l = "mover" : l = "msup";
    }
    return new me.MathNode(l, a);
  }
});
ld({
  type: "atom",
  htmlBuilder(e, t) {
    return ee.mathsym(e.text, e.mode, t, ["m" + e.family]);
  },
  mathmlBuilder(e, t) {
    var n = new me.MathNode("mo", [Ji(e.text, e.mode)]);
    if (e.family === "bin") {
      var r = Db(e, t);
      r === "bold-italic" && n.setAttribute("mathvariant", r);
    } else e.family === "punct" ? n.setAttribute("separator", "true") : (e.family === "open" || e.family === "close") && n.setAttribute("stretchy", "false");
    return n;
  }
});
var YM = {
  mi: "italic",
  mn: "normal",
  mtext: "normal"
};
ld({
  type: "mathord",
  htmlBuilder(e, t) {
    return ee.makeOrd(e, t, "mathord");
  },
  mathmlBuilder(e, t) {
    var n = new me.MathNode("mi", [Ji(e.text, e.mode, t)]), r = Db(e, t) || "italic";
    return r !== YM[n.type] && n.setAttribute("mathvariant", r), n;
  }
});
ld({
  type: "textord",
  htmlBuilder(e, t) {
    return ee.makeOrd(e, t, "textord");
  },
  mathmlBuilder(e, t) {
    var n = Ji(e.text, e.mode, t), r = Db(e, t) || "normal", i;
    return e.mode === "text" ? i = new me.MathNode("mtext", [n]) : /[0-9]/.test(e.text) ? i = new me.MathNode("mn", [n]) : e.text === "\\prime" ? i = new me.MathNode("mo", [n]) : i = new me.MathNode("mi", [n]), r !== YM[i.type] && i.setAttribute("mathvariant", r), i;
  }
});
var p6 = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
}, m6 = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
ld({
  type: "spacing",
  htmlBuilder(e, t) {
    if (m6.hasOwnProperty(e.text)) {
      var n = m6[e.text].className || "";
      if (e.mode === "text") {
        var r = ee.makeOrd(e, t, "textord");
        return r.classes.push(n), r;
      } else
        return ee.makeSpan(["mspace", n], [ee.mathsym(e.text, e.mode, t)], t);
    } else {
      if (p6.hasOwnProperty(e.text))
        return ee.makeSpan(["mspace", p6[e.text]], [], t);
      throw new be('Unknown type of space "' + e.text + '"');
    }
  },
  mathmlBuilder(e, t) {
    var n;
    if (m6.hasOwnProperty(e.text))
      n = new me.MathNode("mtext", [new me.TextNode(" ")]);
    else {
      if (p6.hasOwnProperty(e.text))
        return new me.MathNode("mspace");
      throw new be('Unknown type of space "' + e.text + '"');
    }
    return n;
  }
});
var cy = () => {
  var e = new me.MathNode("mtd", []);
  return e.setAttribute("width", "50%"), e;
};
ld({
  type: "tag",
  mathmlBuilder(e, t) {
    var n = new me.MathNode("mtable", [new me.MathNode("mtr", [cy(), new me.MathNode("mtd", [yo(e.body, t)]), cy(), new me.MathNode("mtd", [yo(e.tag, t)])])]);
    return n.setAttribute("width", "100%"), n;
  }
});
var dy = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
}, uy = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
}, cH = {
  "\\textit": "textit",
  "\\textup": "textup"
}, hy = (e, t) => {
  var n = e.font;
  if (n) {
    if (dy[n])
      return t.withTextFontFamily(dy[n]);
    if (uy[n])
      return t.withTextFontWeight(uy[n]);
    if (n === "\\emph")
      return t.fontShape === "textit" ? t.withTextFontShape("textup") : t.withTextFontShape("textit");
  } else return t;
  return t.withTextFontShape(cH[n]);
};
Te({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: !0,
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: n,
      funcName: r
    } = e, i = t[0];
    return {
      type: "text",
      mode: n.mode,
      body: Gn(i),
      font: r
    };
  },
  htmlBuilder(e, t) {
    var n = hy(e, t), r = cr(e.body, n, !0);
    return ee.makeSpan(["mord", "text"], r, n);
  },
  mathmlBuilder(e, t) {
    var n = hy(e, t);
    return yo(e.body, n);
  }
});
Te({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: n
    } = e;
    return {
      type: "underline",
      mode: n.mode,
      body: t[0]
    };
  },
  htmlBuilder(e, t) {
    var n = It(e.body, t), r = ee.makeLineSpan("underline-line", t), i = t.fontMetrics().defaultRuleThickness, a = ee.makeVList({
      positionType: "top",
      positionData: n.height,
      children: [{
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: n
      }]
    }, t);
    return ee.makeSpan(["mord", "underline"], [a], t);
  },
  mathmlBuilder(e, t) {
    var n = new me.MathNode("mo", [new me.TextNode("‾")]);
    n.setAttribute("stretchy", "true");
    var r = new me.MathNode("munder", [nn(e.body, t), n]);
    return r.setAttribute("accentunder", "true"), r;
  }
});
Te({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: !1
  },
  handler(e, t) {
    var {
      parser: n
    } = e;
    return {
      type: "vcenter",
      mode: n.mode,
      body: t[0]
    };
  },
  htmlBuilder(e, t) {
    var n = It(e.body, t), r = t.fontMetrics().axisHeight, i = 0.5 * (n.height - r - (n.depth + r));
    return ee.makeVList({
      positionType: "shift",
      positionData: i,
      children: [{
        type: "elem",
        elem: n
      }]
    }, t);
  },
  mathmlBuilder(e, t) {
    return new me.MathNode("mpadded", [nn(e.body, t)], ["vcenter"]);
  }
});
Te({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(e, t, n) {
    throw new be("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(e, t) {
    for (var n = fy(e), r = [], i = t.havingStyle(t.style.text()), a = 0; a < n.length; a++) {
      var l = n[a];
      l === "~" && (l = "\\textasciitilde"), r.push(ee.makeSymbol(l, "Typewriter-Regular", e.mode, i, ["mord", "texttt"]));
    }
    return ee.makeSpan(["mord", "text"].concat(i.sizingClasses(t)), ee.tryCombineChars(r), i);
  },
  mathmlBuilder(e, t) {
    var n = new me.TextNode(fy(e)), r = new me.MathNode("mtext", [n]);
    return r.setAttribute("mathvariant", "monospace"), r;
  }
});
var fy = (e) => e.body.replace(/ /g, e.star ? "␣" : " "), to = UM, qM = `[ \r
	]`, dH = "\\\\[a-zA-Z@]+", uH = "\\\\[^\uD800-\uDFFF]", hH = "(" + dH + ")" + qM + "*", fH = `\\\\(
|[ \r	]+
?)[ \r	]*`, L4 = "[̀-ͯ]", pH = new RegExp(L4 + "+$"), mH = "(" + qM + "+)|" + // whitespace
(fH + "|") + // \whitespace
"([!-\\[\\]-‧‪-퟿豈-￿]" + // single codepoint
(L4 + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(L4 + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + hH) + // \macroName + spaces
("|" + uH + ")");
class py {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(t, n) {
    this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = t, this.settings = n, this.tokenRegex = new RegExp(mH, "g"), this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(t, n) {
    this.catcodes[t] = n;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var t = this.input, n = this.tokenRegex.lastIndex;
    if (n === t.length)
      return new Vi("EOF", new Ui(this, n, n));
    var r = this.tokenRegex.exec(t);
    if (r === null || r.index !== n)
      throw new be("Unexpected character: '" + t[n] + "'", new Vi(t[n], new Ui(this, n, n + 1)));
    var i = r[6] || r[3] || (r[2] ? "\\ " : " ");
    if (this.catcodes[i] === 14) {
      var a = t.indexOf(`
`, this.tokenRegex.lastIndex);
      return a === -1 ? (this.tokenRegex.lastIndex = t.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = a + 1, this.lex();
    }
    return new Vi(i, new Ui(this, n, this.tokenRegex.lastIndex));
  }
}
class gH {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(t, n) {
    t === void 0 && (t = {}), n === void 0 && (n = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = n, this.builtins = t, this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0)
      throw new be("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    var t = this.undefStack.pop();
    for (var n in t)
      t.hasOwnProperty(n) && (t[n] == null ? delete this.current[n] : this.current[n] = t[n]);
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    for (; this.undefStack.length > 0; )
      this.endGroup();
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(t) {
    return this.current.hasOwnProperty(t) || this.builtins.hasOwnProperty(t);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(t) {
    return this.current.hasOwnProperty(t) ? this.current[t] : this.builtins[t];
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(t, n, r) {
    if (r === void 0 && (r = !1), r) {
      for (var i = 0; i < this.undefStack.length; i++)
        delete this.undefStack[i][t];
      this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][t] = n);
    } else {
      var a = this.undefStack[this.undefStack.length - 1];
      a && !a.hasOwnProperty(t) && (a[t] = this.current[t]);
    }
    n == null ? delete this.current[t] : this.current[t] = n;
  }
}
var bH = FM;
O("\\noexpand", function(e) {
  var t = e.popToken();
  return e.isExpandable(t.text) && (t.noexpand = !0, t.treatAsRelax = !0), {
    tokens: [t],
    numArgs: 0
  };
});
O("\\expandafter", function(e) {
  var t = e.popToken();
  return e.expandOnce(!0), {
    tokens: [t],
    numArgs: 0
  };
});
O("\\@firstoftwo", function(e) {
  var t = e.consumeArgs(2);
  return {
    tokens: t[0],
    numArgs: 0
  };
});
O("\\@secondoftwo", function(e) {
  var t = e.consumeArgs(2);
  return {
    tokens: t[1],
    numArgs: 0
  };
});
O("\\@ifnextchar", function(e) {
  var t = e.consumeArgs(3);
  e.consumeSpaces();
  var n = e.future();
  return t[0].length === 1 && t[0][0].text === n.text ? {
    tokens: t[1],
    numArgs: 0
  } : {
    tokens: t[2],
    numArgs: 0
  };
});
O("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
O("\\TextOrMath", function(e) {
  var t = e.consumeArgs(2);
  return e.mode === "text" ? {
    tokens: t[0],
    numArgs: 0
  } : {
    tokens: t[1],
    numArgs: 0
  };
});
var my = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
O("\\char", function(e) {
  var t = e.popToken(), n, r = "";
  if (t.text === "'")
    n = 8, t = e.popToken();
  else if (t.text === '"')
    n = 16, t = e.popToken();
  else if (t.text === "`")
    if (t = e.popToken(), t.text[0] === "\\")
      r = t.text.charCodeAt(1);
    else {
      if (t.text === "EOF")
        throw new be("\\char` missing argument");
      r = t.text.charCodeAt(0);
    }
  else
    n = 10;
  if (n) {
    if (r = my[t.text], r == null || r >= n)
      throw new be("Invalid base-" + n + " digit " + t.text);
    for (var i; (i = my[e.future().text]) != null && i < n; )
      r *= n, r += i, e.popToken();
  }
  return "\\@char{" + r + "}";
});
var Wb = (e, t, n, r) => {
  var i = e.consumeArg().tokens;
  if (i.length !== 1)
    throw new be("\\newcommand's first argument must be a macro name");
  var a = i[0].text, l = e.isDefined(a);
  if (l && !t)
    throw new be("\\newcommand{" + a + "} attempting to redefine " + (a + "; use \\renewcommand"));
  if (!l && !n)
    throw new be("\\renewcommand{" + a + "} when command " + a + " does not yet exist; use \\newcommand");
  var s = 0;
  if (i = e.consumeArg().tokens, i.length === 1 && i[0].text === "[") {
    for (var c = "", d = e.expandNextToken(); d.text !== "]" && d.text !== "EOF"; )
      c += d.text, d = e.expandNextToken();
    if (!c.match(/^\s*[0-9]+\s*$/))
      throw new be("Invalid number of arguments: " + c);
    s = parseInt(c), i = e.consumeArg().tokens;
  }
  return l && r || e.macros.set(a, {
    tokens: i,
    numArgs: s
  }), "";
};
O("\\newcommand", (e) => Wb(e, !1, !0, !1));
O("\\renewcommand", (e) => Wb(e, !0, !1, !1));
O("\\providecommand", (e) => Wb(e, !0, !0, !0));
O("\\message", (e) => {
  var t = e.consumeArgs(1)[0];
  return console.log(t.reverse().map((n) => n.text).join("")), "";
});
O("\\errmessage", (e) => {
  var t = e.consumeArgs(1)[0];
  return console.error(t.reverse().map((n) => n.text).join("")), "";
});
O("\\show", (e) => {
  var t = e.popToken(), n = t.text;
  return console.log(t, e.macros.get(n), to[n], cn.math[n], cn.text[n]), "";
});
O("\\bgroup", "{");
O("\\egroup", "}");
O("~", "\\nobreakspace");
O("\\lq", "`");
O("\\rq", "'");
O("\\aa", "\\r a");
O("\\AA", "\\r A");
O("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}");
O("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
O("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}");
O("ℬ", "\\mathscr{B}");
O("ℰ", "\\mathscr{E}");
O("ℱ", "\\mathscr{F}");
O("ℋ", "\\mathscr{H}");
O("ℐ", "\\mathscr{I}");
O("ℒ", "\\mathscr{L}");
O("ℳ", "\\mathscr{M}");
O("ℛ", "\\mathscr{R}");
O("ℭ", "\\mathfrak{C}");
O("ℌ", "\\mathfrak{H}");
O("ℨ", "\\mathfrak{Z}");
O("\\Bbbk", "\\Bbb{k}");
O("·", "\\cdotp");
O("\\llap", "\\mathllap{\\textrm{#1}}");
O("\\rlap", "\\mathrlap{\\textrm{#1}}");
O("\\clap", "\\mathclap{\\textrm{#1}}");
O("\\mathstrut", "\\vphantom{(}");
O("\\underbar", "\\underline{\\text{#1}}");
O("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
O("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}");
O("\\ne", "\\neq");
O("≠", "\\neq");
O("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`∉}}");
O("∉", "\\notin");
O("≘", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`≘}}");
O("≙", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`≘}}");
O("≚", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`≚}}");
O("≛", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`≛}}");
O("≝", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`≝}}");
O("≞", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`≞}}");
O("≟", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`≟}}");
O("⟂", "\\perp");
O("‼", "\\mathclose{!\\mkern-0.8mu!}");
O("∌", "\\notni");
O("⌜", "\\ulcorner");
O("⌝", "\\urcorner");
O("⌞", "\\llcorner");
O("⌟", "\\lrcorner");
O("©", "\\copyright");
O("®", "\\textregistered");
O("️", "\\textregistered");
O("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
O("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
O("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
O("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
O("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
O("⋮", "\\vdots");
O("\\varGamma", "\\mathit{\\Gamma}");
O("\\varDelta", "\\mathit{\\Delta}");
O("\\varTheta", "\\mathit{\\Theta}");
O("\\varLambda", "\\mathit{\\Lambda}");
O("\\varXi", "\\mathit{\\Xi}");
O("\\varPi", "\\mathit{\\Pi}");
O("\\varSigma", "\\mathit{\\Sigma}");
O("\\varUpsilon", "\\mathit{\\Upsilon}");
O("\\varPhi", "\\mathit{\\Phi}");
O("\\varPsi", "\\mathit{\\Psi}");
O("\\varOmega", "\\mathit{\\Omega}");
O("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
O("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
O("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
O("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
O("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
O("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
O("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
O("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
var gy = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
O("\\dots", function(e) {
  var t = "\\dotso", n = e.expandAfterFuture().text;
  return n in gy ? t = gy[n] : (n.slice(0, 4) === "\\not" || n in cn.math && We.contains(["bin", "rel"], cn.math[n].group)) && (t = "\\dotsb"), t;
});
var Xb = {
  // \rightdelim@ checks for the following:
  ")": !0,
  "]": !0,
  "\\rbrack": !0,
  "\\}": !0,
  "\\rbrace": !0,
  "\\rangle": !0,
  "\\rceil": !0,
  "\\rfloor": !0,
  "\\rgroup": !0,
  "\\rmoustache": !0,
  "\\right": !0,
  "\\bigr": !0,
  "\\biggr": !0,
  "\\Bigr": !0,
  "\\Biggr": !0,
  // \extra@ also tests for the following:
  $: !0,
  // \extrap@ checks for the following:
  ";": !0,
  ".": !0,
  ",": !0
};
O("\\dotso", function(e) {
  var t = e.future().text;
  return t in Xb ? "\\ldots\\," : "\\ldots";
});
O("\\dotsc", function(e) {
  var t = e.future().text;
  return t in Xb && t !== "," ? "\\ldots\\," : "\\ldots";
});
O("\\cdots", function(e) {
  var t = e.future().text;
  return t in Xb ? "\\@cdots\\," : "\\@cdots";
});
O("\\dotsb", "\\cdots");
O("\\dotsm", "\\cdots");
O("\\dotsi", "\\!\\cdots");
O("\\dotsx", "\\ldots\\,");
O("\\DOTSI", "\\relax");
O("\\DOTSB", "\\relax");
O("\\DOTSX", "\\relax");
O("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
O("\\,", "\\tmspace+{3mu}{.1667em}");
O("\\thinspace", "\\,");
O("\\>", "\\mskip{4mu}");
O("\\:", "\\tmspace+{4mu}{.2222em}");
O("\\medspace", "\\:");
O("\\;", "\\tmspace+{5mu}{.2777em}");
O("\\thickspace", "\\;");
O("\\!", "\\tmspace-{3mu}{.1667em}");
O("\\negthinspace", "\\!");
O("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
O("\\negthickspace", "\\tmspace-{5mu}{.277em}");
O("\\enspace", "\\kern.5em ");
O("\\enskip", "\\hskip.5em\\relax");
O("\\quad", "\\hskip1em\\relax");
O("\\qquad", "\\hskip2em\\relax");
O("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
O("\\tag@paren", "\\tag@literal{({#1})}");
O("\\tag@literal", (e) => {
  if (e.macros.get("\\df@tag"))
    throw new be("Multiple \\tag");
  return "\\gdef\\df@tag{\\text{#1}}";
});
O("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
O("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
O("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
O("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
O("\\newline", "\\\\\\relax");
O("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var ZM = xe(pl["Main-Regular"][84][1] - 0.7 * pl["Main-Regular"][65][1]);
O("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + ZM + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
O("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + ZM + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
O("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
O("\\@hspace", "\\hskip #1\\relax");
O("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
O("\\ordinarycolon", ":");
O("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
O("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
O("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
O("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
O("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
O("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
O("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
O("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
O("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
O("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
O("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
O("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
O("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
O("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
O("∷", "\\dblcolon");
O("∹", "\\eqcolon");
O("≔", "\\coloneqq");
O("≕", "\\eqqcolon");
O("⩴", "\\Coloneqq");
O("\\ratio", "\\vcentcolon");
O("\\coloncolon", "\\dblcolon");
O("\\colonequals", "\\coloneqq");
O("\\coloncolonequals", "\\Coloneqq");
O("\\equalscolon", "\\eqqcolon");
O("\\equalscoloncolon", "\\Eqqcolon");
O("\\colonminus", "\\coloneq");
O("\\coloncolonminus", "\\Coloneq");
O("\\minuscolon", "\\eqcolon");
O("\\minuscoloncolon", "\\Eqcolon");
O("\\coloncolonapprox", "\\Colonapprox");
O("\\coloncolonsim", "\\Colonsim");
O("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
O("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
O("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
O("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
O("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`∌}}");
O("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
O("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
O("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
O("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
O("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
O("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
O("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
O("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
O("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{≩}");
O("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{≨}");
O("\\ngeqq", "\\html@mathml{\\@ngeqq}{≱}");
O("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{≱}");
O("\\nleqq", "\\html@mathml{\\@nleqq}{≰}");
O("\\nleqslant", "\\html@mathml{\\@nleqslant}{≰}");
O("\\nshortmid", "\\html@mathml{\\@nshortmid}{∤}");
O("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{∦}");
O("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{⊈}");
O("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{⊉}");
O("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{⊊}");
O("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{⫋}");
O("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{⊋}");
O("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{⫌}");
O("\\imath", "\\html@mathml{\\@imath}{ı}");
O("\\jmath", "\\html@mathml{\\@jmath}{ȷ}");
O("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`⟦}}");
O("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`⟧}}");
O("⟦", "\\llbracket");
O("⟧", "\\rrbracket");
O("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`⦃}}");
O("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`⦄}}");
O("⦃", "\\lBrace");
O("⦄", "\\rBrace");
O("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`⦵}}");
O("⦵", "\\minuso");
O("\\darr", "\\downarrow");
O("\\dArr", "\\Downarrow");
O("\\Darr", "\\Downarrow");
O("\\lang", "\\langle");
O("\\rang", "\\rangle");
O("\\uarr", "\\uparrow");
O("\\uArr", "\\Uparrow");
O("\\Uarr", "\\Uparrow");
O("\\N", "\\mathbb{N}");
O("\\R", "\\mathbb{R}");
O("\\Z", "\\mathbb{Z}");
O("\\alef", "\\aleph");
O("\\alefsym", "\\aleph");
O("\\Alpha", "\\mathrm{A}");
O("\\Beta", "\\mathrm{B}");
O("\\bull", "\\bullet");
O("\\Chi", "\\mathrm{X}");
O("\\clubs", "\\clubsuit");
O("\\cnums", "\\mathbb{C}");
O("\\Complex", "\\mathbb{C}");
O("\\Dagger", "\\ddagger");
O("\\diamonds", "\\diamondsuit");
O("\\empty", "\\emptyset");
O("\\Epsilon", "\\mathrm{E}");
O("\\Eta", "\\mathrm{H}");
O("\\exist", "\\exists");
O("\\harr", "\\leftrightarrow");
O("\\hArr", "\\Leftrightarrow");
O("\\Harr", "\\Leftrightarrow");
O("\\hearts", "\\heartsuit");
O("\\image", "\\Im");
O("\\infin", "\\infty");
O("\\Iota", "\\mathrm{I}");
O("\\isin", "\\in");
O("\\Kappa", "\\mathrm{K}");
O("\\larr", "\\leftarrow");
O("\\lArr", "\\Leftarrow");
O("\\Larr", "\\Leftarrow");
O("\\lrarr", "\\leftrightarrow");
O("\\lrArr", "\\Leftrightarrow");
O("\\Lrarr", "\\Leftrightarrow");
O("\\Mu", "\\mathrm{M}");
O("\\natnums", "\\mathbb{N}");
O("\\Nu", "\\mathrm{N}");
O("\\Omicron", "\\mathrm{O}");
O("\\plusmn", "\\pm");
O("\\rarr", "\\rightarrow");
O("\\rArr", "\\Rightarrow");
O("\\Rarr", "\\Rightarrow");
O("\\real", "\\Re");
O("\\reals", "\\mathbb{R}");
O("\\Reals", "\\mathbb{R}");
O("\\Rho", "\\mathrm{P}");
O("\\sdot", "\\cdot");
O("\\sect", "\\S");
O("\\spades", "\\spadesuit");
O("\\sub", "\\subset");
O("\\sube", "\\subseteq");
O("\\supe", "\\supseteq");
O("\\Tau", "\\mathrm{T}");
O("\\thetasym", "\\vartheta");
O("\\weierp", "\\wp");
O("\\Zeta", "\\mathrm{Z}");
O("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
O("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
O("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
O("\\bra", "\\mathinner{\\langle{#1}|}");
O("\\ket", "\\mathinner{|{#1}\\rangle}");
O("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
O("\\Bra", "\\left\\langle#1\\right|");
O("\\Ket", "\\left|#1\\right\\rangle");
var JM = (e) => (t) => {
  var n = t.consumeArg().tokens, r = t.consumeArg().tokens, i = t.consumeArg().tokens, a = t.consumeArg().tokens, l = t.macros.get("|"), s = t.macros.get("\\|");
  t.macros.beginGroup();
  var c = (u) => (h) => {
    e && (h.macros.set("|", l), i.length && h.macros.set("\\|", s));
    var f = u;
    if (!u && i.length) {
      var p = h.future();
      p.text === "|" && (h.popToken(), f = !0);
    }
    return {
      tokens: f ? i : r,
      numArgs: 0
    };
  };
  t.macros.set("|", c(!1)), i.length && t.macros.set("\\|", c(!0));
  var d = t.consumeArg().tokens, o = t.expandTokens([
    ...a,
    ...d,
    ...n
    // reversed
  ]);
  return t.macros.endGroup(), {
    tokens: o.reverse(),
    numArgs: 0
  };
};
O("\\bra@ket", JM(!1));
O("\\bra@set", JM(!0));
O("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
O("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
O("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
O("\\angln", "{\\angl n}");
O("\\blue", "\\textcolor{##6495ed}{#1}");
O("\\orange", "\\textcolor{##ffa500}{#1}");
O("\\pink", "\\textcolor{##ff00af}{#1}");
O("\\red", "\\textcolor{##df0030}{#1}");
O("\\green", "\\textcolor{##28ae7b}{#1}");
O("\\gray", "\\textcolor{gray}{#1}");
O("\\purple", "\\textcolor{##9d38bd}{#1}");
O("\\blueA", "\\textcolor{##ccfaff}{#1}");
O("\\blueB", "\\textcolor{##80f6ff}{#1}");
O("\\blueC", "\\textcolor{##63d9ea}{#1}");
O("\\blueD", "\\textcolor{##11accd}{#1}");
O("\\blueE", "\\textcolor{##0c7f99}{#1}");
O("\\tealA", "\\textcolor{##94fff5}{#1}");
O("\\tealB", "\\textcolor{##26edd5}{#1}");
O("\\tealC", "\\textcolor{##01d1c1}{#1}");
O("\\tealD", "\\textcolor{##01a995}{#1}");
O("\\tealE", "\\textcolor{##208170}{#1}");
O("\\greenA", "\\textcolor{##b6ffb0}{#1}");
O("\\greenB", "\\textcolor{##8af281}{#1}");
O("\\greenC", "\\textcolor{##74cf70}{#1}");
O("\\greenD", "\\textcolor{##1fab54}{#1}");
O("\\greenE", "\\textcolor{##0d923f}{#1}");
O("\\goldA", "\\textcolor{##ffd0a9}{#1}");
O("\\goldB", "\\textcolor{##ffbb71}{#1}");
O("\\goldC", "\\textcolor{##ff9c39}{#1}");
O("\\goldD", "\\textcolor{##e07d10}{#1}");
O("\\goldE", "\\textcolor{##a75a05}{#1}");
O("\\redA", "\\textcolor{##fca9a9}{#1}");
O("\\redB", "\\textcolor{##ff8482}{#1}");
O("\\redC", "\\textcolor{##f9685d}{#1}");
O("\\redD", "\\textcolor{##e84d39}{#1}");
O("\\redE", "\\textcolor{##bc2612}{#1}");
O("\\maroonA", "\\textcolor{##ffbde0}{#1}");
O("\\maroonB", "\\textcolor{##ff92c6}{#1}");
O("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
O("\\maroonD", "\\textcolor{##ca337c}{#1}");
O("\\maroonE", "\\textcolor{##9e034e}{#1}");
O("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
O("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
O("\\purpleC", "\\textcolor{##aa87ff}{#1}");
O("\\purpleD", "\\textcolor{##7854ab}{#1}");
O("\\purpleE", "\\textcolor{##543b78}{#1}");
O("\\mintA", "\\textcolor{##f5f9e8}{#1}");
O("\\mintB", "\\textcolor{##edf2df}{#1}");
O("\\mintC", "\\textcolor{##e0e5cc}{#1}");
O("\\grayA", "\\textcolor{##f6f7f7}{#1}");
O("\\grayB", "\\textcolor{##f0f1f2}{#1}");
O("\\grayC", "\\textcolor{##e3e5e6}{#1}");
O("\\grayD", "\\textcolor{##d6d8da}{#1}");
O("\\grayE", "\\textcolor{##babec2}{#1}");
O("\\grayF", "\\textcolor{##888d93}{#1}");
O("\\grayG", "\\textcolor{##626569}{#1}");
O("\\grayH", "\\textcolor{##3b3e40}{#1}");
O("\\grayI", "\\textcolor{##21242c}{#1}");
O("\\kaBlue", "\\textcolor{##314453}{#1}");
O("\\kaGreen", "\\textcolor{##71B307}{#1}");
var QM = {
  "^": !0,
  // Parser.js
  _: !0,
  // Parser.js
  "\\limits": !0,
  // Parser.js
  "\\nolimits": !0
  // Parser.js
};
class UH {
  constructor(t, n, r) {
    this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = n, this.expansionCount = 0, this.feed(t), this.macros = new gH(bH, n.macros), this.mode = r, this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(t) {
    this.lexer = new py(t, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(t) {
    this.mode = t;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    return this.future(), this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(t) {
    this.stack.push(t);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(t) {
    this.stack.push(...t);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(t) {
    var n, r, i;
    if (t) {
      if (this.consumeSpaces(), this.future().text !== "[")
        return null;
      n = this.popToken(), {
        tokens: i,
        end: r
      } = this.consumeArg(["]"]);
    } else
      ({
        tokens: i,
        start: n,
        end: r
      } = this.consumeArg());
    return this.pushToken(new Vi("EOF", r.loc)), this.pushTokens(i), n.range(r, "");
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var t = this.future();
      if (t.text === " ")
        this.stack.pop();
      else
        break;
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(t) {
    var n = [], r = t && t.length > 0;
    r || this.consumeSpaces();
    var i = this.future(), a, l = 0, s = 0;
    do {
      if (a = this.popToken(), n.push(a), a.text === "{")
        ++l;
      else if (a.text === "}") {
        if (--l, l === -1)
          throw new be("Extra }", a);
      } else if (a.text === "EOF")
        throw new be("Unexpected end of input in a macro argument, expected '" + (t && r ? t[s] : "}") + "'", a);
      if (t && r)
        if ((l === 0 || l === 1 && t[s] === "{") && a.text === t[s]) {
          if (++s, s === t.length) {
            n.splice(-s, s);
            break;
          }
        } else
          s = 0;
    } while (l !== 0 || r);
    return i.text === "{" && n[n.length - 1].text === "}" && (n.pop(), n.shift()), n.reverse(), {
      tokens: n,
      start: i,
      end: a
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(t, n) {
    if (n) {
      if (n.length !== t + 1)
        throw new be("The length of delimiters doesn't match the number of args!");
      for (var r = n[0], i = 0; i < r.length; i++) {
        var a = this.popToken();
        if (r[i] !== a.text)
          throw new be("Use of the macro doesn't match its definition", a);
      }
    }
    for (var l = [], s = 0; s < t; s++)
      l.push(this.consumeArg(n && n[s + 1]).tokens);
    return l;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(t) {
    if (this.expansionCount += t, this.expansionCount > this.settings.maxExpand)
      throw new be("Too many expansions: infinite loop or need to increase maxExpand setting");
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(t) {
    var n = this.popToken(), r = n.text, i = n.noexpand ? null : this._getExpansion(r);
    if (i == null || t && i.unexpandable) {
      if (t && i == null && r[0] === "\\" && !this.isDefined(r))
        throw new be("Undefined control sequence: " + r);
      return this.pushToken(n), !1;
    }
    this.countExpansion(1);
    var a = i.tokens, l = this.consumeArgs(i.numArgs, i.delimiters);
    if (i.numArgs) {
      a = a.slice();
      for (var s = a.length - 1; s >= 0; --s) {
        var c = a[s];
        if (c.text === "#") {
          if (s === 0)
            throw new be("Incomplete placeholder at end of macro body", c);
          if (c = a[--s], c.text === "#")
            a.splice(s + 1, 1);
          else if (/^[1-9]$/.test(c.text))
            a.splice(s, 2, ...l[+c.text - 1]);
          else
            throw new be("Not a valid argument number", c);
        }
      }
    }
    return this.pushTokens(a), a.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    return this.expandOnce(), this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; )
      if (this.expandOnce() === !1) {
        var t = this.stack.pop();
        return t.treatAsRelax && (t.text = "\\relax"), t;
      }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(t) {
    return this.macros.has(t) ? this.expandTokens([new Vi(t)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(t) {
    var n = [], r = this.stack.length;
    for (this.pushTokens(t); this.stack.length > r; )
      if (this.expandOnce(!0) === !1) {
        var i = this.stack.pop();
        i.treatAsRelax && (i.noexpand = !1, i.treatAsRelax = !1), n.push(i);
      }
    return this.countExpansion(n.length), n;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(t) {
    var n = this.expandMacro(t);
    return n && n.map((r) => r.text).join("");
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(t) {
    var n = this.macros.get(t);
    if (n == null)
      return n;
    if (t.length === 1) {
      var r = this.lexer.catcodes[t];
      if (r != null && r !== 13)
        return;
    }
    var i = typeof n == "function" ? n(this) : n;
    if (typeof i == "string") {
      var a = 0;
      if (i.indexOf("#") !== -1)
        for (var l = i.replace(/##/g, ""); l.indexOf("#" + (a + 1)) !== -1; )
          ++a;
      for (var s = new py(i, this.settings), c = [], d = s.lex(); d.text !== "EOF"; )
        c.push(d), d = s.lex();
      c.reverse();
      var o = {
        tokens: c,
        numArgs: a
      };
      return o;
    }
    return i;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(t) {
    return this.macros.has(t) || to.hasOwnProperty(t) || cn.math.hasOwnProperty(t) || cn.text.hasOwnProperty(t) || QM.hasOwnProperty(t);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(t) {
    var n = this.macros.get(t);
    return n != null ? typeof n == "string" || typeof n == "function" || !n.unexpandable : to.hasOwnProperty(t) && !to[t].primitive;
  }
}
var by = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/, v1 = Object.freeze({
  "₊": "+",
  "₋": "-",
  "₌": "=",
  "₍": "(",
  "₎": ")",
  "₀": "0",
  "₁": "1",
  "₂": "2",
  "₃": "3",
  "₄": "4",
  "₅": "5",
  "₆": "6",
  "₇": "7",
  "₈": "8",
  "₉": "9",
  "ₐ": "a",
  "ₑ": "e",
  "ₕ": "h",
  "ᵢ": "i",
  "ⱼ": "j",
  "ₖ": "k",
  "ₗ": "l",
  "ₘ": "m",
  "ₙ": "n",
  "ₒ": "o",
  "ₚ": "p",
  "ᵣ": "r",
  "ₛ": "s",
  "ₜ": "t",
  "ᵤ": "u",
  "ᵥ": "v",
  "ₓ": "x",
  "ᵦ": "β",
  "ᵧ": "γ",
  "ᵨ": "ρ",
  "ᵩ": "ϕ",
  "ᵪ": "χ",
  "⁺": "+",
  "⁻": "-",
  "⁼": "=",
  "⁽": "(",
  "⁾": ")",
  "⁰": "0",
  "¹": "1",
  "²": "2",
  "³": "3",
  "⁴": "4",
  "⁵": "5",
  "⁶": "6",
  "⁷": "7",
  "⁸": "8",
  "⁹": "9",
  "ᴬ": "A",
  "ᴮ": "B",
  "ᴰ": "D",
  "ᴱ": "E",
  "ᴳ": "G",
  "ᴴ": "H",
  "ᴵ": "I",
  "ᴶ": "J",
  "ᴷ": "K",
  "ᴸ": "L",
  "ᴹ": "M",
  "ᴺ": "N",
  "ᴼ": "O",
  "ᴾ": "P",
  "ᴿ": "R",
  "ᵀ": "T",
  "ᵁ": "U",
  "ⱽ": "V",
  "ᵂ": "W",
  "ᵃ": "a",
  "ᵇ": "b",
  "ᶜ": "c",
  "ᵈ": "d",
  "ᵉ": "e",
  "ᶠ": "f",
  "ᵍ": "g",
  ʰ: "h",
  "ⁱ": "i",
  ʲ: "j",
  "ᵏ": "k",
  ˡ: "l",
  "ᵐ": "m",
  ⁿ: "n",
  "ᵒ": "o",
  "ᵖ": "p",
  ʳ: "r",
  ˢ: "s",
  "ᵗ": "t",
  "ᵘ": "u",
  "ᵛ": "v",
  ʷ: "w",
  ˣ: "x",
  ʸ: "y",
  "ᶻ": "z",
  "ᵝ": "β",
  "ᵞ": "γ",
  "ᵟ": "δ",
  "ᵠ": "ϕ",
  "ᵡ": "χ",
  "ᶿ": "θ"
}), g6 = {
  "́": {
    text: "\\'",
    math: "\\acute"
  },
  "̀": {
    text: "\\`",
    math: "\\grave"
  },
  "̈": {
    text: '\\"',
    math: "\\ddot"
  },
  "̃": {
    text: "\\~",
    math: "\\tilde"
  },
  "̄": {
    text: "\\=",
    math: "\\bar"
  },
  "̆": {
    text: "\\u",
    math: "\\breve"
  },
  "̌": {
    text: "\\v",
    math: "\\check"
  },
  "̂": {
    text: "\\^",
    math: "\\hat"
  },
  "̇": {
    text: "\\.",
    math: "\\dot"
  },
  "̊": {
    text: "\\r",
    math: "\\mathring"
  },
  "̋": {
    text: "\\H"
  },
  "̧": {
    text: "\\c"
  }
}, Uy = {
  á: "á",
  à: "à",
  ä: "ä",
  ǟ: "ǟ",
  ã: "ã",
  ā: "ā",
  ă: "ă",
  ắ: "ắ",
  ằ: "ằ",
  ẵ: "ẵ",
  ǎ: "ǎ",
  â: "â",
  ấ: "ấ",
  ầ: "ầ",
  ẫ: "ẫ",
  ȧ: "ȧ",
  ǡ: "ǡ",
  å: "å",
  ǻ: "ǻ",
  ḃ: "ḃ",
  ć: "ć",
  ḉ: "ḉ",
  č: "č",
  ĉ: "ĉ",
  ċ: "ċ",
  ç: "ç",
  ď: "ď",
  ḋ: "ḋ",
  ḑ: "ḑ",
  é: "é",
  è: "è",
  ë: "ë",
  ẽ: "ẽ",
  ē: "ē",
  ḗ: "ḗ",
  ḕ: "ḕ",
  ĕ: "ĕ",
  ḝ: "ḝ",
  ě: "ě",
  ê: "ê",
  ế: "ế",
  ề: "ề",
  ễ: "ễ",
  ė: "ė",
  ȩ: "ȩ",
  ḟ: "ḟ",
  ǵ: "ǵ",
  ḡ: "ḡ",
  ğ: "ğ",
  ǧ: "ǧ",
  ĝ: "ĝ",
  ġ: "ġ",
  ģ: "ģ",
  ḧ: "ḧ",
  ȟ: "ȟ",
  ĥ: "ĥ",
  ḣ: "ḣ",
  ḩ: "ḩ",
  í: "í",
  ì: "ì",
  ï: "ï",
  ḯ: "ḯ",
  ĩ: "ĩ",
  ī: "ī",
  ĭ: "ĭ",
  ǐ: "ǐ",
  î: "î",
  ǰ: "ǰ",
  ĵ: "ĵ",
  ḱ: "ḱ",
  ǩ: "ǩ",
  ķ: "ķ",
  ĺ: "ĺ",
  ľ: "ľ",
  ļ: "ļ",
  ḿ: "ḿ",
  ṁ: "ṁ",
  ń: "ń",
  ǹ: "ǹ",
  ñ: "ñ",
  ň: "ň",
  ṅ: "ṅ",
  ņ: "ņ",
  ó: "ó",
  ò: "ò",
  ö: "ö",
  ȫ: "ȫ",
  õ: "õ",
  ṍ: "ṍ",
  ṏ: "ṏ",
  ȭ: "ȭ",
  ō: "ō",
  ṓ: "ṓ",
  ṑ: "ṑ",
  ŏ: "ŏ",
  ǒ: "ǒ",
  ô: "ô",
  ố: "ố",
  ồ: "ồ",
  ỗ: "ỗ",
  ȯ: "ȯ",
  ȱ: "ȱ",
  ő: "ő",
  ṕ: "ṕ",
  ṗ: "ṗ",
  ŕ: "ŕ",
  ř: "ř",
  ṙ: "ṙ",
  ŗ: "ŗ",
  ś: "ś",
  ṥ: "ṥ",
  š: "š",
  ṧ: "ṧ",
  ŝ: "ŝ",
  ṡ: "ṡ",
  ş: "ş",
  ẗ: "ẗ",
  ť: "ť",
  ṫ: "ṫ",
  ţ: "ţ",
  ú: "ú",
  ù: "ù",
  ü: "ü",
  ǘ: "ǘ",
  ǜ: "ǜ",
  ǖ: "ǖ",
  ǚ: "ǚ",
  ũ: "ũ",
  ṹ: "ṹ",
  ū: "ū",
  ṻ: "ṻ",
  ŭ: "ŭ",
  ǔ: "ǔ",
  û: "û",
  ů: "ů",
  ű: "ű",
  ṽ: "ṽ",
  ẃ: "ẃ",
  ẁ: "ẁ",
  ẅ: "ẅ",
  ŵ: "ŵ",
  ẇ: "ẇ",
  ẘ: "ẘ",
  ẍ: "ẍ",
  ẋ: "ẋ",
  ý: "ý",
  ỳ: "ỳ",
  ÿ: "ÿ",
  ỹ: "ỹ",
  ȳ: "ȳ",
  ŷ: "ŷ",
  ẏ: "ẏ",
  ẙ: "ẙ",
  ź: "ź",
  ž: "ž",
  ẑ: "ẑ",
  ż: "ż",
  Á: "Á",
  À: "À",
  Ä: "Ä",
  Ǟ: "Ǟ",
  Ã: "Ã",
  Ā: "Ā",
  Ă: "Ă",
  Ắ: "Ắ",
  Ằ: "Ằ",
  Ẵ: "Ẵ",
  Ǎ: "Ǎ",
  Â: "Â",
  Ấ: "Ấ",
  Ầ: "Ầ",
  Ẫ: "Ẫ",
  Ȧ: "Ȧ",
  Ǡ: "Ǡ",
  Å: "Å",
  Ǻ: "Ǻ",
  Ḃ: "Ḃ",
  Ć: "Ć",
  Ḉ: "Ḉ",
  Č: "Č",
  Ĉ: "Ĉ",
  Ċ: "Ċ",
  Ç: "Ç",
  Ď: "Ď",
  Ḋ: "Ḋ",
  Ḑ: "Ḑ",
  É: "É",
  È: "È",
  Ë: "Ë",
  Ẽ: "Ẽ",
  Ē: "Ē",
  Ḗ: "Ḗ",
  Ḕ: "Ḕ",
  Ĕ: "Ĕ",
  Ḝ: "Ḝ",
  Ě: "Ě",
  Ê: "Ê",
  Ế: "Ế",
  Ề: "Ề",
  Ễ: "Ễ",
  Ė: "Ė",
  Ȩ: "Ȩ",
  Ḟ: "Ḟ",
  Ǵ: "Ǵ",
  Ḡ: "Ḡ",
  Ğ: "Ğ",
  Ǧ: "Ǧ",
  Ĝ: "Ĝ",
  Ġ: "Ġ",
  Ģ: "Ģ",
  Ḧ: "Ḧ",
  Ȟ: "Ȟ",
  Ĥ: "Ĥ",
  Ḣ: "Ḣ",
  Ḩ: "Ḩ",
  Í: "Í",
  Ì: "Ì",
  Ï: "Ï",
  Ḯ: "Ḯ",
  Ĩ: "Ĩ",
  Ī: "Ī",
  Ĭ: "Ĭ",
  Ǐ: "Ǐ",
  Î: "Î",
  İ: "İ",
  Ĵ: "Ĵ",
  Ḱ: "Ḱ",
  Ǩ: "Ǩ",
  Ķ: "Ķ",
  Ĺ: "Ĺ",
  Ľ: "Ľ",
  Ļ: "Ļ",
  Ḿ: "Ḿ",
  Ṁ: "Ṁ",
  Ń: "Ń",
  Ǹ: "Ǹ",
  Ñ: "Ñ",
  Ň: "Ň",
  Ṅ: "Ṅ",
  Ņ: "Ņ",
  Ó: "Ó",
  Ò: "Ò",
  Ö: "Ö",
  Ȫ: "Ȫ",
  Õ: "Õ",
  Ṍ: "Ṍ",
  Ṏ: "Ṏ",
  Ȭ: "Ȭ",
  Ō: "Ō",
  Ṓ: "Ṓ",
  Ṑ: "Ṑ",
  Ŏ: "Ŏ",
  Ǒ: "Ǒ",
  Ô: "Ô",
  Ố: "Ố",
  Ồ: "Ồ",
  Ỗ: "Ỗ",
  Ȯ: "Ȯ",
  Ȱ: "Ȱ",
  Ő: "Ő",
  Ṕ: "Ṕ",
  Ṗ: "Ṗ",
  Ŕ: "Ŕ",
  Ř: "Ř",
  Ṙ: "Ṙ",
  Ŗ: "Ŗ",
  Ś: "Ś",
  Ṥ: "Ṥ",
  Š: "Š",
  Ṧ: "Ṧ",
  Ŝ: "Ŝ",
  Ṡ: "Ṡ",
  Ş: "Ş",
  Ť: "Ť",
  Ṫ: "Ṫ",
  Ţ: "Ţ",
  Ú: "Ú",
  Ù: "Ù",
  Ü: "Ü",
  Ǘ: "Ǘ",
  Ǜ: "Ǜ",
  Ǖ: "Ǖ",
  Ǚ: "Ǚ",
  Ũ: "Ũ",
  Ṹ: "Ṹ",
  Ū: "Ū",
  Ṻ: "Ṻ",
  Ŭ: "Ŭ",
  Ǔ: "Ǔ",
  Û: "Û",
  Ů: "Ů",
  Ű: "Ű",
  Ṽ: "Ṽ",
  Ẃ: "Ẃ",
  Ẁ: "Ẁ",
  Ẅ: "Ẅ",
  Ŵ: "Ŵ",
  Ẇ: "Ẇ",
  Ẍ: "Ẍ",
  Ẋ: "Ẋ",
  Ý: "Ý",
  Ỳ: "Ỳ",
  Ÿ: "Ÿ",
  Ỹ: "Ỹ",
  Ȳ: "Ȳ",
  Ŷ: "Ŷ",
  Ẏ: "Ẏ",
  Ź: "Ź",
  Ž: "Ž",
  Ẑ: "Ẑ",
  Ż: "Ż",
  ά: "ά",
  ὰ: "ὰ",
  ᾱ: "ᾱ",
  ᾰ: "ᾰ",
  έ: "έ",
  ὲ: "ὲ",
  ή: "ή",
  ὴ: "ὴ",
  ί: "ί",
  ὶ: "ὶ",
  ϊ: "ϊ",
  ΐ: "ΐ",
  ῒ: "ῒ",
  ῑ: "ῑ",
  ῐ: "ῐ",
  ό: "ό",
  ὸ: "ὸ",
  ύ: "ύ",
  ὺ: "ὺ",
  ϋ: "ϋ",
  ΰ: "ΰ",
  ῢ: "ῢ",
  ῡ: "ῡ",
  ῠ: "ῠ",
  ώ: "ώ",
  ὼ: "ὼ",
  Ύ: "Ύ",
  Ὺ: "Ὺ",
  Ϋ: "Ϋ",
  Ῡ: "Ῡ",
  Ῠ: "Ῠ",
  Ώ: "Ώ",
  Ὼ: "Ὼ"
};
class $g {
  constructor(t, n) {
    this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new UH(t, n, this.mode), this.settings = n, this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(t, n) {
    if (n === void 0 && (n = !0), this.fetch().text !== t)
      throw new be("Expected '" + t + "', got '" + this.fetch().text + "'", this.fetch());
    n && this.consume();
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(t) {
    this.mode = t, this.gullet.switchMode(t);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
    try {
      var t = this.parseExpression(!1);
      return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), t;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(t) {
    var n = this.nextToken;
    this.consume(), this.gullet.pushToken(new Vi("}")), this.gullet.pushTokens(t);
    var r = this.parseExpression(!1);
    return this.expect("}"), this.nextToken = n, r;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(t, n) {
    for (var r = []; ; ) {
      this.mode === "math" && this.consumeSpaces();
      var i = this.fetch();
      if ($g.endOfExpression.indexOf(i.text) !== -1 || n && i.text === n || t && to[i.text] && to[i.text].infix)
        break;
      var a = this.parseAtom(n);
      if (a) {
        if (a.type === "internal")
          continue;
      } else break;
      r.push(a);
    }
    return this.mode === "text" && this.formLigatures(r), this.handleInfixNodes(r);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(t) {
    for (var n = -1, r, i = 0; i < t.length; i++)
      if (t[i].type === "infix") {
        if (n !== -1)
          throw new be("only one infix operator per group", t[i].token);
        n = i, r = t[i].replaceWith;
      }
    if (n !== -1 && r) {
      var a, l, s = t.slice(0, n), c = t.slice(n + 1);
      s.length === 1 && s[0].type === "ordgroup" ? a = s[0] : a = {
        type: "ordgroup",
        mode: this.mode,
        body: s
      }, c.length === 1 && c[0].type === "ordgroup" ? l = c[0] : l = {
        type: "ordgroup",
        mode: this.mode,
        body: c
      };
      var d;
      return r === "\\\\abovefrac" ? d = this.callFunction(r, [a, t[n], l], []) : d = this.callFunction(r, [a, l], []), [d];
    } else
      return t;
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(t) {
    var n = this.fetch(), r = n.text;
    this.consume(), this.consumeSpaces();
    var i;
    do {
      var a;
      i = this.parseGroup(t);
    } while (((a = i) == null ? void 0 : a.type) === "internal");
    if (!i)
      throw new be("Expected group after '" + r + "'", n);
    return i;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(t) {
    for (var n = [], r = 0; r < t.length; r++)
      n.push({
        type: "textord",
        mode: "text",
        text: t[r]
      });
    var i = {
      type: "text",
      mode: this.mode,
      body: n
    }, a = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [i]
    };
    return a;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(t) {
    var n = this.parseGroup("atom", t);
    if ((n == null ? void 0 : n.type) === "internal" || this.mode === "text")
      return n;
    for (var r, i; ; ) {
      this.consumeSpaces();
      var a = this.fetch();
      if (a.text === "\\limits" || a.text === "\\nolimits") {
        if (n && n.type === "op") {
          var l = a.text === "\\limits";
          n.limits = l, n.alwaysHandleSupSub = !0;
        } else if (n && n.type === "operatorname")
          n.alwaysHandleSupSub && (n.limits = a.text === "\\limits");
        else
          throw new be("Limit controls must follow a math operator", a);
        this.consume();
      } else if (a.text === "^") {
        if (r)
          throw new be("Double superscript", a);
        r = this.handleSupSubscript("superscript");
      } else if (a.text === "_") {
        if (i)
          throw new be("Double subscript", a);
        i = this.handleSupSubscript("subscript");
      } else if (a.text === "'") {
        if (r)
          throw new be("Double superscript", a);
        var s = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        }, c = [s];
        for (this.consume(); this.fetch().text === "'"; )
          c.push(s), this.consume();
        this.fetch().text === "^" && c.push(this.handleSupSubscript("superscript")), r = {
          type: "ordgroup",
          mode: this.mode,
          body: c
        };
      } else if (v1[a.text]) {
        var d = by.test(a.text), o = [];
        for (o.push(new Vi(v1[a.text])), this.consume(); ; ) {
          var u = this.fetch().text;
          if (!v1[u] || by.test(u) !== d)
            break;
          o.unshift(new Vi(v1[u])), this.consume();
        }
        var h = this.subparse(o);
        d ? i = {
          type: "ordgroup",
          mode: "math",
          body: h
        } : r = {
          type: "ordgroup",
          mode: "math",
          body: h
        };
      } else
        break;
    }
    return r || i ? {
      type: "supsub",
      mode: this.mode,
      base: n,
      sup: r,
      sub: i
    } : n;
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(t, n) {
    var r = this.fetch(), i = r.text, a = to[i];
    if (!a)
      return null;
    if (this.consume(), n && n !== "atom" && !a.allowedInArgument)
      throw new be("Got function '" + i + "' with no arguments" + (n ? " as " + n : ""), r);
    if (this.mode === "text" && !a.allowedInText)
      throw new be("Can't use function '" + i + "' in text mode", r);
    if (this.mode === "math" && a.allowedInMath === !1)
      throw new be("Can't use function '" + i + "' in math mode", r);
    var {
      args: l,
      optArgs: s
    } = this.parseArguments(i, a);
    return this.callFunction(i, l, s, r, t);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(t, n, r, i, a) {
    var l = {
      funcName: t,
      parser: this,
      token: i,
      breakOnTokenText: a
    }, s = to[t];
    if (s && s.handler)
      return s.handler(l, n, r);
    throw new be("No function handler for " + t);
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(t, n) {
    var r = n.numArgs + n.numOptionalArgs;
    if (r === 0)
      return {
        args: [],
        optArgs: []
      };
    for (var i = [], a = [], l = 0; l < r; l++) {
      var s = n.argTypes && n.argTypes[l], c = l < n.numOptionalArgs;
      (n.primitive && s == null || // \sqrt expands into primitive if optional argument doesn't exist
      n.type === "sqrt" && l === 1 && a[0] == null) && (s = "primitive");
      var d = this.parseGroupOfType("argument to '" + t + "'", s, c);
      if (c)
        a.push(d);
      else if (d != null)
        i.push(d);
      else
        throw new be("Null argument, please report this as a bug");
    }
    return {
      args: i,
      optArgs: a
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(t, n, r) {
    switch (n) {
      case "color":
        return this.parseColorGroup(r);
      case "size":
        return this.parseSizeGroup(r);
      case "url":
        return this.parseUrlGroup(r);
      case "math":
      case "text":
        return this.parseArgumentGroup(r, n);
      case "hbox": {
        var i = this.parseArgumentGroup(r, "text");
        return i != null ? {
          type: "styling",
          mode: i.mode,
          body: [i],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var a = this.parseStringGroup("raw", r);
        return a != null ? {
          type: "raw",
          mode: "text",
          string: a.text
        } : null;
      }
      case "primitive": {
        if (r)
          throw new be("A primitive argument cannot be optional");
        var l = this.parseGroup(t);
        if (l == null)
          throw new be("Expected group as " + t, this.fetch());
        return l;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(r);
      default:
        throw new be("Unknown group type as " + t, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    for (; this.fetch().text === " "; )
      this.consume();
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(t, n) {
    var r = this.gullet.scanArgument(n);
    if (r == null)
      return null;
    for (var i = "", a; (a = this.fetch()).text !== "EOF"; )
      i += a.text, this.consume();
    return this.consume(), r.text = i, r;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(t, n) {
    for (var r = this.fetch(), i = r, a = "", l; (l = this.fetch()).text !== "EOF" && t.test(a + l.text); )
      i = l, a += i.text, this.consume();
    if (a === "")
      throw new be("Invalid " + n + ": '" + r.text + "'", r);
    return r.range(i, a);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(t) {
    var n = this.parseStringGroup("color", t);
    if (n == null)
      return null;
    var r = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(n.text);
    if (!r)
      throw new be("Invalid color: '" + n.text + "'", n);
    var i = r[0];
    return /^[0-9a-f]{6}$/i.test(i) && (i = "#" + i), {
      type: "color-token",
      mode: this.mode,
      color: i
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(t) {
    var n, r = !1;
    if (this.gullet.consumeSpaces(), !t && this.gullet.future().text !== "{" ? n = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : n = this.parseStringGroup("size", t), !n)
      return null;
    !t && n.text.length === 0 && (n.text = "0pt", r = !0);
    var i = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(n.text);
    if (!i)
      throw new be("Invalid size: '" + n.text + "'", n);
    var a = {
      number: +(i[1] + i[2]),
      // sign + magnitude, cast to number
      unit: i[3]
    };
    if (!cM(a))
      throw new be("Invalid unit: '" + a.unit + "'", n);
    return {
      type: "size",
      mode: this.mode,
      value: a,
      isBlank: r
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(t) {
    this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
    var n = this.parseStringGroup("url", t);
    if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), n == null)
      return null;
    var r = n.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url: r
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(t, n) {
    var r = this.gullet.scanArgument(t);
    if (r == null)
      return null;
    var i = this.mode;
    n && this.switchMode(n), this.gullet.beginGroup();
    var a = this.parseExpression(!1, "EOF");
    this.expect("EOF"), this.gullet.endGroup();
    var l = {
      type: "ordgroup",
      mode: this.mode,
      loc: r.loc,
      body: a
    };
    return n && this.switchMode(i), l;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(t, n) {
    var r = this.fetch(), i = r.text, a;
    if (i === "{" || i === "\\begingroup") {
      this.consume();
      var l = i === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var s = this.parseExpression(!1, l), c = this.fetch();
      this.expect(l), this.gullet.endGroup(), a = {
        type: "ordgroup",
        mode: this.mode,
        loc: Ui.range(r, c),
        body: s,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: i === "\\begingroup" || void 0
      };
    } else if (a = this.parseFunction(n, t) || this.parseSymbol(), a == null && i[0] === "\\" && !QM.hasOwnProperty(i)) {
      if (this.settings.throwOnError)
        throw new be("Undefined control sequence: " + i, r);
      a = this.formatUnsupportedCmd(i), this.consume();
    }
    return a;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(t) {
    for (var n = t.length - 1, r = 0; r < n; ++r) {
      var i = t[r], a = i.text;
      a === "-" && t[r + 1].text === "-" && (r + 1 < n && t[r + 2].text === "-" ? (t.splice(r, 3, {
        type: "textord",
        mode: "text",
        loc: Ui.range(i, t[r + 2]),
        text: "---"
      }), n -= 2) : (t.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: Ui.range(i, t[r + 1]),
        text: "--"
      }), n -= 1)), (a === "'" || a === "`") && t[r + 1].text === a && (t.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: Ui.range(i, t[r + 1]),
        text: a + a
      }), n -= 1);
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var t = this.fetch(), n = t.text;
    if (/^\\verb[^a-zA-Z]/.test(n)) {
      this.consume();
      var r = n.slice(5), i = r.charAt(0) === "*";
      if (i && (r = r.slice(1)), r.length < 2 || r.charAt(0) !== r.slice(-1))
        throw new be(`\\verb assertion failed --
                    please report what input caused this bug`);
      return r = r.slice(1, -1), {
        type: "verb",
        mode: "text",
        body: r,
        star: i
      };
    }
    Uy.hasOwnProperty(n[0]) && !cn[this.mode][n[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + n[0] + '" used in math mode', t), n = Uy[n[0]] + n.slice(1));
    var a = pH.exec(n);
    a && (n = n.substring(0, a.index), n === "i" ? n = "ı" : n === "j" && (n = "ȷ"));
    var l;
    if (cn[this.mode][n]) {
      this.settings.strict && this.mode === "math" && T4.indexOf(n) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + n[0] + '" used in math mode', t);
      var s = cn[this.mode][n].group, c = Ui.range(t), d;
      if (lB.hasOwnProperty(s)) {
        var o = s;
        d = {
          type: "atom",
          mode: this.mode,
          family: o,
          loc: c,
          text: n
        };
      } else
        d = {
          type: s,
          mode: this.mode,
          loc: c,
          text: n
        };
      l = d;
    } else if (n.charCodeAt(0) >= 128)
      this.settings.strict && (sM(n.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + n[0] + '" used in math mode', t) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + n[0] + '"' + (" (" + n.charCodeAt(0) + ")"), t)), l = {
        type: "textord",
        mode: "text",
        loc: Ui.range(t),
        text: n
      };
    else
      return null;
    if (this.consume(), a)
      for (var u = 0; u < a[0].length; u++) {
        var h = a[0][u];
        if (!g6[h])
          throw new be("Unknown accent ' " + h + "'", t);
        var f = g6[h][this.mode] || g6[h].text;
        if (!f)
          throw new be("Accent " + h + " unsupported in " + this.mode + " mode", t);
        l = {
          type: "accent",
          mode: this.mode,
          loc: Ui.range(t),
          label: f,
          isStretchy: !1,
          isShifty: !0,
          // $FlowFixMe
          base: l
        };
      }
    return l;
  }
}
$g.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var Vb = function(t, n) {
  if (!(typeof t == "string" || t instanceof String))
    throw new TypeError("KaTeX can only parse string typed expression");
  var r = new $g(t, n);
  delete r.gullet.macros.current["\\df@tag"];
  var i = r.parse();
  if (delete r.gullet.macros.current["\\current@color"], delete r.gullet.macros.current["\\color"], r.gullet.macros.get("\\df@tag")) {
    if (!n.displayMode)
      throw new be("\\tag works only in display equations");
    i = [{
      type: "tag",
      mode: "text",
      body: i,
      tag: r.subparse([new Vi("\\df@tag")])
    }];
  }
  return i;
}, Gb = function(t, n, r) {
  n.textContent = "";
  var i = Fg(t, r).toNode();
  n.appendChild(i);
};
typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), Gb = function() {
  throw new be("KaTeX doesn't work in quirks mode.");
});
var eT = function(t, n) {
  var r = Fg(t, n).toMarkup();
  return r;
}, tT = function(t, n) {
  var r = new Cb(n);
  return Vb(t, r);
}, nT = function(t, n, r) {
  if (r.throwOnError || !(t instanceof be))
    throw t;
  var i = ee.makeSpan(["katex-error"], [new Zi(n)]);
  return i.setAttribute("title", t.toString()), i.setAttribute("style", "color:" + r.errorColor), i;
}, Fg = function(t, n) {
  var r = new Cb(n);
  try {
    var i = Vb(t, r);
    return TB(i, t, r);
  } catch (a) {
    return nT(a, t, r);
  }
}, rT = function(t, n) {
  var r = new Cb(n);
  try {
    var i = Vb(t, r);
    return IB(i, t, r);
  } catch (a) {
    return nT(a, t, r);
  }
}, iT = "0.16.22", aT = {
  Span: Af,
  Anchor: Ib,
  SymbolNode: Zi,
  SvgNode: fs,
  PathNode: vo,
  LineNode: M4
}, jb = {
  /**
   * Current KaTeX version
   */
  version: iT,
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render: Gb,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString: eT,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError: be,
  /**
   * The schema of Settings
   */
  SETTINGS_SCHEMA: sh,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: tT,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: Fg,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: rT,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: oM,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: C,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: Te,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: O,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: These methods are not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: aT
};
const h4e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ParseError: be,
  SETTINGS_SCHEMA: sh,
  __defineFunction: Te,
  __defineMacro: O,
  __defineSymbol: C,
  __domTree: aT,
  __parse: tT,
  __renderToDomTree: Fg,
  __renderToHTMLTree: rT,
  __setFontMetrics: oM,
  default: jb,
  get render() {
    return Gb;
  },
  renderToString: eT,
  version: iT
}, Symbol.toStringTag, { value: "Module" })), vH = J.lazy(() => import("./EquationComponent-Be2nMu0w.js"));
function vy(e) {
  let t = e.getAttribute("data-lexical-equation");
  const n = e.getAttribute("data-lexical-inline") === "true";
  return t = atob(t || ""), t ? { node: Kb(t, n) } : null;
}
class K0 extends Ha {
  constructor(n, r, i) {
    super(i);
    Ne(this, "__equation");
    Ne(this, "__inline");
    this.__equation = n, this.__inline = r ?? !1;
  }
  static getType() {
    return "equation";
  }
  static clone(n) {
    return new K0(n.__equation, n.__inline, n.__key);
  }
  static importJSON(n) {
    return Kb(
      n.equation,
      n.inline
    );
  }
  exportJSON() {
    return {
      equation: this.getEquation(),
      inline: this.__inline,
      type: "equation",
      version: 1
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createDOM(n) {
    const r = document.createElement(this.__inline ? "span" : "div");
    return r.className = "editor-equation", r;
  }
  exportDOM() {
    const n = document.createElement(this.__inline ? "span" : "div"), r = btoa(this.__equation);
    return n.setAttribute("data-lexical-equation", r), n.setAttribute("data-lexical-inline", `${this.__inline}`), jb.render(this.__equation, n, {
      displayMode: !this.__inline,
      // true === block display //
      errorColor: "#cc0000",
      output: "html",
      strict: "warn",
      throwOnError: !1,
      trust: !1
    }), { element: n };
  }
  static importDOM() {
    return {
      div: (n) => n.hasAttribute("data-lexical-equation") ? {
        conversion: vy,
        priority: 2
      } : null,
      span: (n) => n.hasAttribute("data-lexical-equation") ? {
        conversion: vy,
        priority: 1
      } : null
    };
  }
  updateDOM(n) {
    return this.__inline !== n.__inline;
  }
  getTextContent() {
    return this.__equation;
  }
  getEquation() {
    return this.__equation;
  }
  setEquation(n) {
    const r = this.getWritable();
    r.__equation = n;
  }
  decorate() {
    return /* @__PURE__ */ m(td, { fallback: null, children: /* @__PURE__ */ m(
      vH,
      {
        equation: this.__equation,
        inline: this.__inline,
        nodeKey: this.__key
      }
    ) });
  }
}
function Kb(e = "", t = !1) {
  const n = new K0(e, t);
  return En(n);
}
function f4e(e) {
  return e instanceof K0;
}
const yH = J.lazy(() => import("./ExcalidrawComponent-CddJBiHY.js"));
function wH(e) {
  const t = e.getAttribute("data-lexical-excalidraw-json"), n = window.getComputedStyle(e), r = n.getPropertyValue("height"), i = n.getPropertyValue("width"), a = !r || r === "inherit" ? "inherit" : parseInt(r, 10), l = !i || i === "inherit" ? "inherit" : parseInt(i, 10);
  return t ? {
    node: lT(t, l, a)
  } : null;
}
class Rc extends Ha {
  constructor(n = "[]", r = "inherit", i = "inherit", a) {
    super(a);
    Ne(this, "__data");
    Ne(this, "__width");
    Ne(this, "__height");
    this.__data = n, this.__width = r, this.__height = i;
  }
  static getType() {
    return "excalidraw";
  }
  static clone(n) {
    return new Rc(
      n.__data,
      n.__width,
      n.__height,
      n.__key
    );
  }
  static importJSON(n) {
    return new Rc(n.data, n.width, n.height);
  }
  exportJSON() {
    return {
      type: this.__type,
      version: 1,
      data: this.__data,
      height: this.__height === "inherit" ? void 0 : this.__height,
      width: this.__width === "inherit" ? void 0 : this.__width
    };
  }
  // View
  createDOM(n) {
    const r = document.createElement("span"), a = n.theme.image;
    return a !== void 0 && (r.className = a), r;
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return {
      span: (n) => n.hasAttribute("data-lexical-excalidraw-json") ? {
        conversion: wH,
        priority: 1
      } : null
    };
  }
  exportDOM(n) {
    const r = document.createElement("span");
    r.style.display = "inline-block";
    const i = n.getElementByKey(this.getKey());
    if (i !== null) {
      const a = i.querySelector("svg");
      a !== null && (r.innerHTML = a.outerHTML);
    }
    return r.style.width = this.__width === "inherit" ? "inherit" : `${this.__width}px`, r.style.height = this.__height === "inherit" ? "inherit" : `${this.__height}px`, r.setAttribute("data-lexical-excalidraw-json", this.__data), { element: r };
  }
  setData(n) {
    const r = this.getWritable();
    r.__data = n;
  }
  getWidth() {
    return this.getLatest().__width;
  }
  setWidth(n) {
    const r = this.getWritable();
    r.__width = n;
  }
  getHeight() {
    return this.getLatest().__height;
  }
  setHeight(n) {
    const r = this.getWritable();
    r.__height = n;
  }
  decorate() {
    return /* @__PURE__ */ m(
      yH,
      {
        nodeKey: this.getKey(),
        data: this.__data,
        width: this.__width,
        height: this.__height
      }
    );
  }
}
function lT(e = "[]", t = "inherit", n = "inherit") {
  return new Rc(e, t, n);
}
function p4e(e) {
  return e instanceof Rc;
}
class Pc extends tr {
  constructor(n, r) {
    super(r);
    Ne(this, "__templateColumns");
    this.__templateColumns = n;
  }
  static getType() {
    return "layout-container";
  }
  static clone(n) {
    return new Pc(n.__templateColumns, n.__key);
  }
  createDOM(n) {
    const r = document.createElement("div");
    return r.style.gridTemplateColumns = this.__templateColumns, typeof n.theme.layoutContainer == "string" && zn(r, n.theme.layoutContainer), r;
  }
  updateDOM(n, r) {
    return n.__templateColumns !== this.__templateColumns && (r.style.gridTemplateColumns = this.__templateColumns), !1;
  }
  static importDOM() {
    return {};
  }
  static importJSON(n) {
    return sT(n.templateColumns);
  }
  canBeEmpty() {
    return !1;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      templateColumns: this.__templateColumns,
      type: "layout-container",
      version: 1
    };
  }
  getTemplateColumns() {
    return this.getLatest().__templateColumns;
  }
  setTemplateColumns(n) {
    this.getWritable().__templateColumns = n;
  }
}
function sT(e) {
  return new Pc(e);
}
function y1(e) {
  return e instanceof Pc;
}
class Oc extends tr {
  static getType() {
    return "layout-item";
  }
  static clone(t) {
    return new Oc(t.__key);
  }
  createDOM(t) {
    const n = document.createElement("div");
    return typeof t.theme.layoutItem == "string" && zn(n, t.theme.layoutItem), n;
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return {};
  }
  static importJSON() {
    return R4();
  }
  isShadowRoot() {
    return !0;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "layout-item",
      version: 1
    };
  }
}
function R4() {
  return new Oc();
}
function yy(e) {
  return e instanceof Oc;
}
const xH = J.lazy(() => import("./PollComponent-BEWIDF01.js"));
function EH() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
}
function wy(e = "") {
  return {
    text: e,
    uid: EH(),
    votes: []
  };
}
function xy(e, t, n) {
  return {
    text: t,
    uid: e.uid,
    votes: n || Array.from(e.votes)
  };
}
function SH(e) {
  const t = e.getAttribute("data-lexical-poll-question"), n = e.getAttribute("data-lexical-poll-options");
  return t !== null && n !== null ? { node: Yb(t, JSON.parse(n)) } : null;
}
class Y0 extends Ha {
  constructor(n, r, i) {
    super(i);
    Ne(this, "__question");
    Ne(this, "__options");
    this.__question = n, this.__options = r;
  }
  static getType() {
    return "poll";
  }
  static clone(n) {
    return new Y0(n.__question, n.__options, n.__key);
  }
  static importJSON(n) {
    const r = Yb(
      n.question,
      n.options
    );
    return n.options.forEach(r.addOption), r;
  }
  exportJSON() {
    return {
      options: this.__options,
      question: this.__question,
      type: "poll",
      version: 1
    };
  }
  addOption(n) {
    const r = this.getWritable(), i = Array.from(r.__options);
    i.push(n), r.__options = i;
  }
  deleteOption(n) {
    const r = this.getWritable(), i = Array.from(r.__options), a = i.indexOf(n);
    i.splice(a, 1), r.__options = i;
  }
  setOptionText(n, r) {
    const i = this.getWritable(), a = xy(n, r), l = Array.from(i.__options), s = l.indexOf(n);
    l[s] = a, i.__options = l;
  }
  toggleVote(n, r) {
    const i = this.getWritable(), a = n.votes, l = Array.from(a), s = a.indexOf(r);
    s === -1 ? l.push(r) : l.splice(s, 1);
    const c = xy(n, n.text, l), d = Array.from(i.__options), o = d.indexOf(n);
    d[o] = c, i.__options = d;
  }
  static importDOM() {
    return {
      span: (n) => n.hasAttribute("data-lexical-poll-question") ? {
        conversion: SH,
        priority: 2
      } : null
    };
  }
  exportDOM() {
    const n = document.createElement("span");
    return n.setAttribute("data-lexical-poll-question", this.__question), n.setAttribute(
      "data-lexical-poll-options",
      JSON.stringify(this.__options)
    ), { element: n };
  }
  createDOM() {
    const n = document.createElement("span");
    return n.style.display = "inline-block", n;
  }
  updateDOM() {
    return !1;
  }
  decorate() {
    return /* @__PURE__ */ m(td, { fallback: null, children: /* @__PURE__ */ m(
      xH,
      {
        question: this.__question,
        options: this.__options,
        nodeKey: this.__key
      }
    ) });
  }
}
function Yb(e, t) {
  return new Y0(e, t);
}
function m4e(e) {
  return e instanceof Y0;
}
const _H = J.lazy(() => import("./InlineImageComponent-CPmfJ-Dh.js"));
function kH(e) {
  if (e instanceof HTMLImageElement) {
    const { alt: t, src: n, width: r, height: i } = e;
    return { node: qb({ altText: t, height: i, src: n, width: r }) };
  }
  return null;
}
class q0 extends Ha {
  constructor(n, r, i, a, l, s, c, d) {
    super(d);
    Ne(this, "__src");
    Ne(this, "__altText");
    Ne(this, "__width");
    Ne(this, "__height");
    Ne(this, "__showCaption");
    Ne(this, "__caption");
    Ne(this, "__position");
    this.__src = n, this.__altText = r, this.__width = a || "inherit", this.__height = l || "inherit", this.__showCaption = s || !1, this.__caption = c || wf(), this.__position = i;
  }
  static getType() {
    return "inline-image";
  }
  static clone(n) {
    return new q0(
      n.__src,
      n.__altText,
      n.__position,
      n.__width,
      n.__height,
      n.__showCaption,
      n.__caption,
      n.__key
    );
  }
  static importJSON(n) {
    const { altText: r, height: i, width: a, caption: l, src: s, showCaption: c, position: d } = n, o = qb({
      altText: r,
      height: i,
      position: d,
      showCaption: c,
      src: s,
      width: a
    }), u = o.__caption, h = u.parseEditorState(l.editorState);
    return h.isEmpty() || u.setEditorState(h), o;
  }
  static importDOM() {
    return {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      img: (n) => ({
        conversion: kH,
        priority: 0
      })
    };
  }
  exportDOM() {
    const n = document.createElement("span");
    n.className = `inline-editor-image position-${this.__position}`;
    const r = document.createElement("img");
    return r.setAttribute("src", this.__src), r.setAttribute("alt", this.__altText), r.setAttribute("width", this.__width.toString()), r.setAttribute("height", this.__height.toString()), n.appendChild(r), { element: n };
  }
  exportJSON() {
    return {
      altText: this.getAltText(),
      caption: this.__caption.toJSON(),
      height: this.__height === "inherit" ? 0 : this.__height,
      position: this.__position,
      showCaption: this.__showCaption,
      src: this.getSrc(),
      type: "inline-image",
      version: 1,
      width: this.__width === "inherit" ? 0 : this.__width
    };
  }
  getSrc() {
    return this.__src;
  }
  getAltText() {
    return this.__altText;
  }
  setAltText(n) {
    const r = this.getWritable();
    r.__altText = n;
  }
  setWidthAndHeight(n, r) {
    const i = this.getWritable();
    i.__width = n, i.__height = r;
  }
  getShowCaption() {
    return this.__showCaption;
  }
  setShowCaption(n) {
    const r = this.getWritable();
    r.__showCaption = n;
  }
  getPosition() {
    return this.__position;
  }
  setPosition(n) {
    const r = this.getWritable();
    r.__position = n;
  }
  update(n) {
    const r = this.getWritable(), { altText: i, showCaption: a, position: l } = n;
    i !== void 0 && (r.__altText = i), a !== void 0 && (r.__showCaption = a), l !== void 0 && (r.__position = l);
  }
  // View
  createDOM(n) {
    const r = document.createElement("span");
    return r.className = `${n.theme.inlineImage} position-${this.__position}`, r;
  }
  updateDOM(n, r, i) {
    const a = this.__position;
    return a !== n.__position && (r.className = `${i.theme.inlineImage} position-${a}`), !1;
  }
  decorate() {
    return /* @__PURE__ */ m(td, { fallback: null, children: /* @__PURE__ */ m(
      _H,
      {
        src: this.__src,
        altText: this.__altText,
        width: this.__width,
        height: this.__height,
        nodeKey: this.getKey(),
        showCaption: this.__showCaption,
        caption: this.__caption,
        position: this.__position
      }
    ) });
  }
}
function qb({
  altText: e,
  position: t,
  height: n,
  src: r,
  width: i,
  showCaption: a,
  caption: l,
  key: s
}) {
  return En(
    new q0(
      r,
      e,
      t,
      i,
      n,
      a,
      l,
      s
    )
  );
}
function CH(e) {
  return e instanceof q0;
}
const MH = J.lazy(() => import("./StickyComponent-DHEpG1pM.js"));
class u0 extends Ha {
  constructor(n, r, i, a, l) {
    super(l);
    Ne(this, "__x");
    Ne(this, "__y");
    Ne(this, "__color");
    Ne(this, "__caption");
    this.__x = n, this.__y = r, this.__caption = a || wf(), this.__color = i;
  }
  static getType() {
    return "sticky";
  }
  static clone(n) {
    return new u0(
      n.__x,
      n.__y,
      n.__color,
      n.__caption,
      n.__key
    );
  }
  static importJSON(n) {
    const r = new u0(
      n.xOffset,
      n.yOffset,
      n.color
    ), i = n.caption, a = r.__caption, l = a.parseEditorState(i.editorState);
    return l.isEmpty() || a.setEditorState(l), r;
  }
  exportJSON() {
    return {
      caption: this.__caption.toJSON(),
      color: this.__color,
      type: "sticky",
      version: 1,
      xOffset: this.__x,
      yOffset: this.__y
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createDOM(n) {
    const r = document.createElement("div");
    return r.style.display = "contents", r;
  }
  updateDOM() {
    return !1;
  }
  setPosition(n, r) {
    const i = this.getWritable();
    i.__x = n, i.__y = r, pn(null);
  }
  toggleColor() {
    const n = this.getWritable();
    n.__color = n.__color === "pink" ? "yellow" : "pink";
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  decorate(n, r) {
    return fi(
      /* @__PURE__ */ m(td, { fallback: null, children: /* @__PURE__ */ m(
        MH,
        {
          color: this.__color,
          x: this.__x,
          y: this.__y,
          nodeKey: this.getKey(),
          caption: this.__caption
        }
      ) }),
      document.body
    );
  }
  isIsolated() {
    return !0;
  }
}
function g4e(e) {
  return e instanceof u0;
}
function TH(e, t) {
  return new u0(e, t, "yellow");
}
const IH = [
  Q3,
  ab,
  Tg,
  ub,
  _f,
  Sf,
  Ef,
  H0,
  cb,
  X0,
  kf,
  V0,
  c0,
  Cf,
  Mf,
  Tf,
  Nc,
  Dc,
  Lc,
  K0,
  Rc,
  Pc,
  Oc,
  Y0,
  SC,
  q0,
  co,
  Ig,
  oo,
  u0,
  lb
], w1 = 0, P4 = 1, O4 = 2, pa = 0, AH = 1, Ey = 2, NH = 3, DH = 4;
function LH(e, t, n, r, i) {
  if (e === null || n.size === 0 && r.size === 0 && !i) return pa;
  const a = t._selection, l = e._selection;
  if (i) return AH;
  if (!(ie(a) && ie(l) && l.isCollapsed() && a.isCollapsed())) return pa;
  const s = function(v, U, y) {
    const w = v._nodeMap, x = [];
    for (const E of U) {
      const S = w.get(E);
      S !== void 0 && x.push(S);
    }
    for (const [E, S] of y) {
      if (!S) continue;
      const _ = w.get(E);
      _ === void 0 || Xr(_) || x.push(_);
    }
    return x;
  }(t, n, r);
  if (s.length === 0) return pa;
  if (s.length > 1) {
    const v = t._nodeMap, U = v.get(a.anchor.key), y = v.get(l.anchor.key);
    return U && y && !e._nodeMap.has(U.__key) && ce(U) && U.__text.length === 1 && a.anchor.offset === 1 ? Ey : pa;
  }
  const c = s[0], d = e._nodeMap.get(c.__key);
  if (!ce(d) || !ce(c) || d.__mode !== c.__mode) return pa;
  const o = d.__text, u = c.__text;
  if (o === u) return pa;
  const h = a.anchor, f = l.anchor;
  if (h.key !== f.key || h.type !== "text") return pa;
  const p = h.offset, g = f.offset, b = u.length - o.length;
  return b === 1 && g === p - 1 ? Ey : b === -1 && g === p + 1 ? NH : b === -1 && g === p ? DH : pa;
}
function RH(e, t) {
  let n = Date.now(), r = pa;
  return (i, a, l, s, c, d) => {
    const o = Date.now();
    if (d.has("historic")) return r = pa, n = o, O4;
    const u = LH(i, a, s, c, e.isComposing()), h = (() => {
      const f = l === null || l.editor === e, p = d.has("history-push");
      if (!p && f && d.has("history-merge")) return w1;
      if (i === null) return P4;
      const g = a._selection;
      return s.size > 0 || c.size > 0 ? p === !1 && u !== pa && u === r && o < n + t && f || s.size === 1 && function(b, v, U) {
        const y = v._nodeMap.get(b), w = U._nodeMap.get(b), x = v._selection, E = U._selection;
        return !(ie(x) && ie(E) && x.anchor.type === "element" && x.focus.type === "element" && E.anchor.type === "text" && E.focus.type === "text" || !ce(y) || !ce(w) || y.__parent !== w.__parent) && JSON.stringify(v.read(() => y.exportJSON())) === JSON.stringify(U.read(() => w.exportJSON()));
      }(Array.from(s)[0], i, a) ? w1 : P4 : g !== null ? w1 : O4;
    })();
    return n = o, r = u, h;
  };
}
function Sy(e) {
  e.undoStack = [], e.redoStack = [], e.current = null;
}
function PH(e, t, n) {
  const r = RH(e, n);
  return Pt(e.registerCommand(og, () => (function(a, l) {
    const s = l.redoStack, c = l.undoStack;
    if (c.length !== 0) {
      const d = l.current, o = c.pop();
      d !== null && (s.push(d), a.dispatchCommand(Ru, !0)), c.length === 0 && a.dispatchCommand(Pu, !1), l.current = o || null, o && o.editor.setEditorState(o.editorState, { tag: "historic" });
    }
  }(e, t), !0), it), e.registerCommand(cg, () => (function(a, l) {
    const s = l.redoStack, c = l.undoStack;
    if (s.length !== 0) {
      const d = l.current;
      d !== null && (c.push(d), a.dispatchCommand(Pu, !0));
      const o = s.pop();
      s.length === 0 && a.dispatchCommand(Ru, !1), l.current = o || null, o && o.editor.setEditorState(o.editorState, { tag: "historic" });
    }
  }(e, t), !0), it), e.registerCommand(FO, () => (Sy(t), !1), it), e.registerCommand(zO, () => (Sy(t), e.dispatchCommand(Ru, !1), e.dispatchCommand(Pu, !1), !0), it), e.registerUpdateListener(({ editorState: a, prevEditorState: l, dirtyLeaves: s, dirtyElements: c, tags: d }) => {
    const o = t.current, u = t.redoStack, h = t.undoStack, f = o === null ? null : o.editorState;
    if (o !== null && a === f) return;
    const p = r(l, a, o, s, c, d);
    if (p === P4) u.length !== 0 && (t.redoStack = [], e.dispatchCommand(Ru, !1)), o !== null && (h.push({ ...o }), e.dispatchCommand(Pu, !0));
    else if (p === O4) return;
    t.current = { editor: e, editorState: a };
  }));
}
function oT() {
  return { current: null, redoStack: [], undoStack: [] };
}
function OH({ delay: e, externalHistoryState: t }) {
  const [n] = Fe();
  return function(r, i, a = 1e3) {
    const l = Ke(() => i || oT(), [i]);
    Y(() => PH(r, l, a), [a, r, l]);
  }(n, t, e), null;
}
const cT = Ci({}), $H = ({
  children: e,
  initHistoryState: t
}) => {
  const n = Ke(
    () => ({ historyState: t || oT() }),
    []
  );
  return /* @__PURE__ */ m(cT.Provider, { value: n, children: e });
}, FH = () => Er(cT), zH = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? Bn : Y;
function BH(e) {
  return { initialValueFn: () => e.isEditable(), subscribe: (t) => e.registerEditableListener(t) };
}
function Df() {
  return function(e) {
    const [t] = Fe(), n = Ke(() => e(t), [t, e]), r = de(n.initialValueFn()), [i, a] = Q(r.current);
    return zH(() => {
      const { initialValueFn: l, subscribe: s } = n, c = l();
      return r.current !== c && (r.current = c, a(c)), s((d) => {
        r.current = d, a(d);
      });
    }, [n, e]), i;
  }(BH);
}
function HH() {
  return Bt().getTextContent();
}
function WH(e, t = !0) {
  if (e) return !1;
  let n = HH();
  return t && (n = n.trim()), n === "";
}
function XH(e) {
  if (!WH(e, !1)) return !1;
  const t = Bt().getChildren(), n = t.length;
  if (n > 1) return !1;
  for (let r = 0; r < n; r++) {
    const i = t[r];
    if (Ft(i)) return !1;
    if (re(i)) {
      if (!La(i) || i.__indent !== 0) return !1;
      const a = i.getChildren(), l = a.length;
      for (let s = 0; s < l; s++) {
        const c = a[r];
        if (!ce(c)) return !1;
      }
    }
  }
  return !0;
}
function dT(e) {
  return () => XH(e);
}
function VH(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var GH = VH(function(e) {
  const t = new URLSearchParams();
  t.append("code", e);
  for (let n = 1; n < arguments.length; n++) t.append("v", arguments[n]);
  throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
});
function jH(e, t, n, r) {
  const i = (l) => l instanceof n, a = (l) => {
    const s = un(l.getTextContent());
    s.setFormat(l.getFormat()), l.replace(s);
  };
  return [e.registerNodeTransform(aa, (l) => {
    if (!l.isSimpleText()) return;
    let s, c = l.getPreviousSibling(), d = l.getTextContent(), o = l;
    if (ce(c)) {
      const h = c.getTextContent(), f = t(h + d);
      if (i(c)) {
        if (f === null || ((p) => p.getLatest().__mode)(c) !== 0) return void a(c);
        {
          const p = f.end - h.length;
          if (p > 0) {
            const g = h + d.slice(0, p);
            if (c.select(), c.setTextContent(g), p === d.length) l.remove();
            else {
              const b = d.slice(p);
              l.setTextContent(b);
            }
            return;
          }
        }
      } else if (f === null || f.start < h.length) return;
    }
    let u = 0;
    for (; ; ) {
      s = t(d);
      let h, f = s === null ? "" : d.slice(s.end);
      if (d = f, f === "") {
        const g = o.getNextSibling();
        if (ce(g)) {
          f = o.getTextContent() + g.getTextContent();
          const b = t(f);
          if (b === null) return void (i(g) ? a(g) : g.markDirty());
          if (b.start !== 0) return;
        }
      }
      if (s === null) return;
      if (s.start === 0 && ce(c) && c.isTextEntity()) {
        u += s.end;
        continue;
      }
      s.start === 0 ? [h, o] = o.splitText(s.end) : [, h, o] = o.splitText(s.start + u, s.end + u), h === void 0 && GH(165, "nodeToReplace");
      const p = r(h);
      if (p.setFormat(h.getFormat()), h.replace(p), o == null) return;
      u = 0, c = p;
    }
  }), e.registerNodeTransform(n, (l) => {
    const s = l.getTextContent(), c = t(s);
    if (c === null || c.start !== 0) return void a(l);
    if (s.length > c.end) return void l.splitText(c.end);
    const d = l.getPreviousSibling();
    ce(d) && d.isTextEntity() && (a(d), a(l));
    const o = l.getNextSibling();
    ce(o) && o.isTextEntity() && (a(o), i(l) && a(l));
  })];
}
function KH(e) {
  const t = window.location.origin, n = (r) => {
    if (r.origin !== t) return;
    const i = e.getRootElement();
    if (document.activeElement !== i) return;
    const a = r.data;
    if (typeof a == "string") {
      let l;
      try {
        l = JSON.parse(a);
      } catch {
        return;
      }
      if (l && l.protocol === "nuanria_messaging" && l.type === "request") {
        const s = l.payload;
        if (s && s.functionId === "makeChanges") {
          const c = s.args;
          if (c) {
            const [d, o, u, h, f, p] = c;
            e.update(() => {
              const g = se();
              if (ie(g)) {
                const b = g.anchor;
                let v = b.getNode(), U = 0, y = 0;
                if (ce(v) && d >= 0 && o >= 0 && (U = d, y = d + o, g.setTextNodeRange(v, U, v, y)), U === y && u === "" || (g.insertRawText(u), v = b.getNode()), ce(v)) {
                  U = h, y = h + f;
                  const w = v.getTextContentSize();
                  U = U > w ? w : U, y = y > w ? w : y, g.setTextNodeRange(v, U, v, y);
                }
                r.stopImmediatePropagation();
              }
            });
          }
        }
      }
    }
  };
  return window.addEventListener("message", n, !0), () => {
    window.removeEventListener("message", n, !0);
  };
}
const $4 = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? Bn : Y;
function _y(e) {
  return e.getEditorState().read(dT(e.isComposing()));
}
function YH({ contentEditable: e, placeholder: t = null, ErrorBoundary: n }) {
  const [r] = Fe(), i = function(a, l) {
    const [s, c] = Q(() => a.getDecorators());
    return $4(() => a.registerDecoratorListener((d) => {
      ga(() => {
        c(d);
      });
    }), [a]), Y(() => {
      c(a.getDecorators());
    }, [a]), Ke(() => {
      const d = [], o = Object.keys(s);
      for (let u = 0; u < o.length; u++) {
        const h = o[u], f = m(l, { onError: (g) => a._onError(g), children: m(td, { fallback: null, children: s[h] }) }), p = a.getElementByKey(h);
        p !== null && d.push(fi(f, p, h));
      }
      return d;
    }, [l, s, a]);
  }(r, n);
  return function(a) {
    $4(() => Pt(qF(a), KH(a)), [a]);
  }(r), D(ge, { children: [e, m(qH, { content: t }), i] });
}
function qH({ content: e }) {
  const [t] = Fe(), n = function(i) {
    const [a, l] = Q(() => _y(i));
    return $4(() => {
      function s() {
        const c = _y(i);
        l(c);
      }
      return s(), Pt(i.registerUpdateListener(() => {
        s();
      }), i.registerEditableListener(() => {
        s();
      }));
    }, [i]), a;
  }(t), r = Df();
  return n ? typeof e == "function" ? e(r) : e : null;
}
function F4(e, t) {
  return F4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, F4(e, t);
}
var ky = { error: null }, ZH = function(e) {
  var t, n;
  function r() {
    for (var a, l = arguments.length, s = new Array(l), c = 0; c < l; c++) s[c] = arguments[c];
    return (a = e.call.apply(e, [this].concat(s)) || this).state = ky, a.resetErrorBoundary = function() {
      for (var d, o = arguments.length, u = new Array(o), h = 0; h < o; h++) u[h] = arguments[h];
      a.props.onReset == null || (d = a.props).onReset.apply(d, u), a.reset();
    }, a;
  }
  n = e, (t = r).prototype = Object.create(n.prototype), t.prototype.constructor = t, F4(t, n), r.getDerivedStateFromError = function(a) {
    return { error: a };
  };
  var i = r.prototype;
  return i.reset = function() {
    this.setState(ky);
  }, i.componentDidCatch = function(a, l) {
    var s, c;
    (s = (c = this.props).onError) == null || s.call(c, a, l);
  }, i.componentDidUpdate = function(a, l) {
    var s, c, d, o, u = this.state.error, h = this.props.resetKeys;
    u !== null && l.error !== null && ((d = a.resetKeys) === void 0 && (d = []), (o = h) === void 0 && (o = []), d.length !== o.length || d.some(function(f, p) {
      return !Object.is(f, o[p]);
    })) && ((s = (c = this.props).onResetKeysChange) == null || s.call(c, a.resetKeys, h), this.reset());
  }, i.render = function() {
    var a = this.state.error, l = this.props, s = l.fallbackRender, c = l.FallbackComponent, d = l.fallback;
    if (a !== null) {
      var o = { error: a, resetErrorBoundary: this.resetErrorBoundary };
      if (J.isValidElement(d)) return d;
      if (typeof s == "function") return s(o);
      if (c) return J.createElement(c, o);
      throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
    }
    return this.props.children;
  }, r;
}(J.Component);
function JH({ children: e, onError: t }) {
  return m(ZH, { fallback: m("div", { style: { border: "1px solid #f00", color: "#f00", padding: "8px" }, children: "An error was thrown." }), onError: t, children: e });
}
function QH({ defaultSelection: e }) {
  const [t] = Fe();
  return Y(() => {
    t.focus(() => {
      const n = document.activeElement, r = t.getRootElement();
      r === null || n !== null && r.contains(n) || r.focus({ preventScroll: !0 });
    }, { defaultSelection: e });
  }, [e, t]), null;
}
function eW(e) {
  return e.registerCommand(mf, (t) => {
    const n = se();
    if (!ie(n)) return !1;
    t.preventDefault();
    const r = function(i) {
      const a = i.getNodes();
      if (rF(a, (u) => Kp(u) && u.canIndent() ? u : null).length > 0) return !0;
      const l = i.anchor, s = i.focus, c = s.isBefore(l) ? s : l, d = c.getNode(), o = Cg(d);
      if (o.canIndent()) {
        const u = o.getKey();
        let h = yf();
        if (h.anchor.set(u, 0, "element"), h.focus.set(u, 0, "element"), h = bg(h), h.anchor.is(c)) return !0;
      }
      return !1;
    }(n) ? t.shiftKey ? Pp : dg : dk;
    return e.dispatchCommand(r, void 0);
  }, it);
}
function tW() {
  const [e] = Fe();
  return Y(() => eW(e)), null;
}
function nW() {
  const [e] = Fe();
  return Y(() => e.registerCommand(ob, (t) => {
    const n = se();
    if (!ie(n)) return !1;
    if (n.focus.getNode() !== null) {
      const r = db();
      Lo(r);
    }
    return !0;
  }, it), [e]), null;
}
function rW({
  children: e,
  className: t
}) {
  return /* @__PURE__ */ m("div", { className: t || "placeholder__root", children: e });
}
const uT = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? Bn : Y;
function iW({ editor: e, ariaActiveDescendant: t, ariaAutoComplete: n, ariaControls: r, ariaDescribedBy: i, ariaErrorMessage: a, ariaExpanded: l, ariaInvalid: s, ariaLabel: c, ariaLabelledBy: d, ariaMultiline: o, ariaOwns: u, ariaRequired: h, autoCapitalize: f, className: p, id: g, role: b = "textbox", spellCheck: v = !0, style: U, tabIndex: y, "data-testid": w, ...x }, E) {
  const [S, _] = Q(e.isEditable()), k = he((A) => {
    A && A.ownerDocument && A.ownerDocument.defaultView ? e.setRootElement(A) : e.setRootElement(null);
  }, [e]), M = Ke(() => /* @__PURE__ */ function(...A) {
    return (L) => {
      A.forEach((R) => {
        typeof R == "function" ? R(L) : R != null && (R.current = L);
      });
    };
  }(E, k), [k, E]);
  return uT(() => (_(e.isEditable()), e.registerEditableListener((A) => {
    _(A);
  })), [e]), m("div", { ...x, "aria-activedescendant": S ? t : void 0, "aria-autocomplete": S ? n : "none", "aria-controls": S ? r : void 0, "aria-describedby": i, ...a != null ? { "aria-errormessage": a } : {}, "aria-expanded": S && b === "combobox" ? !!l : void 0, ...s != null ? { "aria-invalid": s } : {}, "aria-label": c, "aria-labelledby": d, "aria-multiline": o, "aria-owns": S ? u : void 0, "aria-readonly": !S || void 0, "aria-required": h, autoCapitalize: f, className: p, contentEditable: S, "data-testid": w, id: g, ref: M, role: S ? b : void 0, spellCheck: v, style: U, tabIndex: y });
}
const aW = dn(iW);
function Cy(e) {
  return e.getEditorState().read(dT(e.isComposing()));
}
const lW = dn(sW);
function sW(e, t) {
  const { placeholder: n, ...r } = e, [i] = Fe();
  return D(ge, { children: [m(aW, { editor: i, ...r, ref: t }), n != null && m(oW, { editor: i, content: n })] });
}
function oW({ content: e, editor: t }) {
  const n = function(l) {
    const [s, c] = Q(() => Cy(l));
    return uT(() => {
      function d() {
        const o = Cy(l);
        c(o);
      }
      return d(), Pt(l.registerUpdateListener(() => {
        d();
      }), l.registerEditableListener(() => {
        d();
      }));
    }, [l]), s;
  }(t), [r, i] = Q(t.isEditable());
  if (Bn(() => (i(t.isEditable()), t.registerEditableListener((l) => {
    i(l);
  })), [t]), !n) return null;
  let a = null;
  return typeof e == "function" ? a = e(r) : e !== null && (a = e), a === null ? null : m("div", { "aria-hidden": !0, children: a });
}
function cW({
  className: e
}) {
  return /* @__PURE__ */ m(lW, { className: e || "content-editable__root" });
}
const Z0 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", dW = Z0 && "documentMode" in document ? document.documentMode : null, $s = Z0 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
Z0 && "InputEvent" in window && !dW && "getTargetRanges" in new window.InputEvent("input");
const hT = J.createContext(null), My = 4;
function St({
  children: e,
  className: t,
  onClick: n,
  title: r
}) {
  const i = de(null), a = J.useContext(hT);
  if (a === null)
    throw new Error("DropDownItem must be used within a DropDown");
  const { registerItem: l } = a;
  return Y(() => {
    i && i.current && l(i);
  }, [i, l]), /* @__PURE__ */ m(
    "button",
    {
      className: t,
      onClick: n,
      ref: i,
      title: r,
      type: "button",
      children: e
    }
  );
}
function uW({
  children: e,
  dropDownRef: t,
  onClose: n
}) {
  const [r, i] = Q(), [a, l] = Q(), s = he(
    (o) => {
      i((u) => u ? [...u, o] : [o]);
    },
    [i]
  ), c = (o) => {
    if (!r)
      return;
    const u = o.key;
    ["Escape", "ArrowUp", "ArrowDown", "Tab"].includes(u) && o.preventDefault(), u === "Escape" || u === "Tab" ? n() : u === "ArrowUp" ? l((h) => {
      if (!h)
        return r[0];
      const f = r.indexOf(h) - 1;
      return r[f === -1 ? r.length - 1 : f];
    }) : u === "ArrowDown" && l((h) => h ? r[r.indexOf(h) + 1] : r[0]);
  }, d = Ke(
    () => ({
      registerItem: s
    }),
    [s]
  );
  return Y(() => {
    r && !a && l(r[0]), a && a.current && a.current.focus();
  }, [r, a]), /* @__PURE__ */ m(hT.Provider, { value: d, children: /* @__PURE__ */ m("div", { className: "doc-editor-dropdown", ref: t, onKeyDown: c, children: e }) });
}
function $c({
  disabled: e = !1,
  buttonLabel: t,
  buttonAriaLabel: n,
  buttonClassName: r,
  buttonIconClassName: i,
  children: a,
  stopCloseOnClickSelf: l
}) {
  const s = de(null), c = de(null), [d, o] = Q(!1), u = () => {
    o(!1), c && c.current && c.current.focus();
  };
  return Y(() => {
    const h = c.current, f = s.current;
    if (d && h !== null && f !== null) {
      const { top: p, left: g } = h.getBoundingClientRect();
      f.style.top = `${p + h.offsetHeight + My}px`, f.style.left = `${Math.min(
        g,
        window.innerWidth - f.offsetWidth - 20
      )}px`;
    }
  }, [s, c, d]), Y(() => {
    const h = c.current;
    if (h !== null && d) {
      const f = (p) => {
        const g = p.target;
        l && s.current && s.current.contains(g) || h.contains(g) || o(!1);
      };
      return document.addEventListener("click", f), () => {
        document.removeEventListener("click", f);
      };
    }
  }, [s, c, d, l]), Y(() => {
    const h = () => {
      if (d) {
        const f = c.current, p = s.current;
        if (f !== null && p !== null) {
          const { top: g } = f.getBoundingClientRect(), b = g + f.offsetHeight + My;
          b !== p.getBoundingClientRect().top && (p.style.top = `${b}px`);
        }
      }
    };
    return document.addEventListener("scroll", h), () => {
      document.removeEventListener("scroll", h);
    };
  }, [c, s, d]), /* @__PURE__ */ D(ge, { children: [
    /* @__PURE__ */ D(
      "button",
      {
        type: "button",
        disabled: e,
        "aria-label": n || t,
        className: r,
        onClick: () => o(!d),
        ref: c,
        children: [
          i && /* @__PURE__ */ m("span", { className: i }),
          t && /* @__PURE__ */ m("span", { className: "text dropdown-button-text", children: t }),
          /* @__PURE__ */ m("i", { className: "doc-editor-icon chevron-down" })
        ]
      }
    ),
    d && fi(
      /* @__PURE__ */ m(uW, { dropDownRef: s, onClose: u, children: a }),
      document.body
    )
  ] });
}
function hW(...e) {
  const t = [];
  for (const n of e)
    if (n && typeof n == "string")
      for (const [r] of n.matchAll(/\S+/g))
        t.push(r);
  return t;
}
function fW(e, t, n) {
  const r = Mi[t];
  let i = e ^ r;
  return t === "subscript" ? i &= -65 : t === "superscript" && (i &= -33), i;
}
function b6(e, t) {
  e.__lexicalClassNameCache === void 0 && (e.__lexicalClassNameCache = {});
  const n = e.__lexicalClassNameCache, r = n[t];
  if (r !== void 0)
    return r;
  const i = e[t];
  if (typeof i == "string") {
    const a = hW(i);
    return n[t] = a, a;
  }
  return i;
}
function Ty(e, t, ...n) {
  throw new Error(
    "Internal Lexical error: invariant() is meant to be replaced at compile time. There is no runtime version. Error: " + t
  );
}
const pW = pe.lazy(() => import("./DataMentionComponent-CIOI8WO9.js"));
function mW(e) {
  const t = e.getAttribute("data-mention-data"), n = e.getAttribute("data-mention-type"), r = e.getAttribute("data-mention-field"), i = e.getAttribute("data-mention-label");
  return n !== null && r !== null && i !== null ? {
    node: Zb({ dataMention: n, fieldName: r, label: i, data: t })
  } : null;
}
function U6(e) {
  return e & qO ? "code" : e & mg ? "mark" : e & ZO ? "sub" : e & JO ? "sup" : null;
}
function v6(e) {
  return e & KO ? "strong" : e & YO ? "em" : "span";
}
function fT(e, t, n, r) {
  const i = n.classList;
  let a = b6(r, "base");
  a !== void 0 && i.add(...a), a = b6(
    r,
    "underlineStrikethrough"
  );
  let l = !1;
  const s = e & o0 && e & s0, c = t & o0 && t & s0;
  a !== void 0 && (c ? (l = !0, s || i.add(...a)) : s && i.remove(...a));
  for (const d in Mi) {
    const o = Mi[d];
    if (a = b6(r, d), a !== void 0)
      if (t & o) {
        if (l && (d === "underline" || d === "strikethrough")) {
          e & o && i.remove(...a);
          continue;
        }
        (!(e & o) || s && d === "underline" || d === "strikethrough") && i.add(...a);
      } else e & o && i.remove(...a);
  }
}
function Iy(e, t, n) {
  const i = n.theme.text;
  i !== void 0 && fT(0, t, e, i);
}
const gW = (e) => {
  var n;
  const t = e.parentElement;
  if (t) {
    if (t.hasAttribute("data-lexical-data-mention"))
      return;
    (n = t.parentElement) == null || n.appendChild(e);
  }
};
class wo extends Ha {
  constructor(n, r, i, a, l, s, c, d, o, u) {
    super(u);
    Ne(this, "__dataMention");
    Ne(this, "__fieldName");
    Ne(this, "__label");
    Ne(this, "__value");
    Ne(this, "__data");
    Ne(this, "__step");
    Ne(this, "__format");
    Ne(this, "__style");
    Ne(this, "__decoratorSpan");
    Ne(this, "__inputError", null);
    Ne(this, "defaultStep", 1);
    this.__dataMention = n, this.__fieldName = r, this.__label = i, this.__value = l, this.__data = a, this.__step = s || this.defaultStep, this.__format = c || 0, this.__style = d || "", this.__decoratorSpan = null, this.__inputError = o || null;
  }
  static getType() {
    return "data-mention";
  }
  static clone(n) {
    return new wo(
      n.__dataMention,
      n.__fieldName,
      n.__label,
      n.__data,
      n.__value,
      n.__step,
      n.__format,
      n.__style,
      n.__inputError,
      n.__key
    );
  }
  getDataMention() {
    return this.getLatest().__dataMention;
  }
  getFieldName() {
    return this.getLatest().__fieldName;
  }
  getLabel() {
    return this.getLatest().__label;
  }
  getValue() {
    return this.getLatest().__value;
  }
  getData() {
    return this.getLatest().__data;
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getStyle() {
    return this.getLatest().__style;
  }
  hasFormat(n) {
    const r = Mi[n];
    return (this.getFormat() & r) !== 0;
  }
  getStyleValue(n, r) {
    const i = this.getStyle(), a = new RegExp(`${n}:\\s*([^;]+)`), l = i.match(a);
    return l ? l[1] : r;
  }
  canHaveFormat() {
    return !0;
  }
  isInput() {
    return this.getDataMention() === "input";
  }
  createDOM(n) {
    var f;
    const r = this.__dataMention === "input", i = this.__format, a = U6(i), l = v6(i), s = a === null ? l : a, c = document.createElement(r ? "div" : s), o = n.theme.dataMention;
    if (c.setAttribute("data-mention-type", this.__dataMention), c.setAttribute("data-mention-field", this.__fieldName), c.setAttribute("data-mention-label", this.__label), c.setAttribute("data-lexical-data-mention", "true"), c.setAttribute("data-mention-data", ((f = this.__data) == null ? void 0 : f.toString()) || ""), o !== void 0 && (c.className = o), r)
      return c;
    let u = c;
    this.hasFormat("code") && c.setAttribute("spellcheck", "false"), a !== null && (u = document.createElement(l), c.appendChild(u)), Iy(u, i, n);
    const h = this.__style;
    return h !== "" && (c.style.cssText = h), c;
  }
  updateDOM(n, r, i) {
    if (this.__dataMention === "input")
      return !1;
    const a = n.__format, l = this.__format, s = U6(a), c = U6(l), d = v6(a), o = v6(l), u = s === null ? d : s, h = c === null ? o : c, f = r.firstChild;
    let p = f !== null ? f.firstChild : null;
    if (p && p.nodeType !== Node.TEXT_NODE ? r.appendChild(p) : p = null, u !== h)
      return !0;
    if (s === c && d !== o) {
      const w = r.firstChild;
      w == null && Ty(!1, "updateDOM: prevInnerDOM is null or undefined");
      const x = document.createElement(o);
      return Iy(
        x,
        l,
        i
      ), r.replaceChild(x, w), p && x.appendChild(p), !1;
    }
    let g = r;
    c !== null && s !== null && (g = r.firstChild, g == null && Ty(!1, "updateDOM: innerDOM is null or undefined"));
    const v = i.theme.text;
    v !== void 0 && a !== l && fT(
      a,
      l,
      g,
      v
    );
    const U = n.__style, y = this.__style;
    return U !== y && (r.style.cssText = y), p && g && g.appendChild(p), !1;
  }
  static importDOM() {
    return {
      span: (n) => n.hasAttribute("data-lexical-data-mention") ? {
        conversion: mW,
        priority: 1
      } : null
    };
  }
  static importJSON(n) {
    const {
      dataMention: r,
      fieldName: i,
      label: a,
      data: l,
      value: s,
      format: c,
      style: d
    } = n, o = Zb({
      dataMention: r,
      fieldName: i,
      label: a,
      data: l,
      step: this.prototype.defaultStep,
      format: c,
      style: d
    });
    if (r === "input" && o.__value) {
      const u = o.__value;
      if (s) {
        const h = u.parseEditorState(s.editorState);
        h.isEmpty() || u.setEditorState(h);
      }
    }
    return o;
  }
  exportDOM(n) {
    const { element: r, after: i } = super.exportDOM(n);
    if (r && r instanceof HTMLElement && (r == null || r.setAttribute("data-lexical-data-mention", "true")), this.__dataMention === "input" && this.__value) {
      const a = document.createElement("span");
      a.style.wordBreak = "break-word", a.style.whiteSpace = "pre-wrap", a.style.overflowWrap = "break-word", a.style.display = "inline-grid", this.__value.getEditorState().read(() => {
        a.innerHTML = Qp(this.__value);
      }), r == null || r.appendChild(a);
    } else r && (r.textContent = this.__data ? this.__data.toString() : `{{${this.__fieldName}}}`);
    return { element: r, after: i };
  }
  exportJSON() {
    const n = this.getValue();
    return {
      dataMention: this.getDataMention(),
      fieldName: this.getFieldName(),
      label: this.getLabel(),
      value: n && n.toJSON(),
      data: this.getData(),
      version: 1,
      type: "data-mention",
      format: this.getFormat(),
      style: this.getStyle()
    };
  }
  setData(n) {
    const r = this.getWritable();
    return r.__data = n, r;
  }
  setLabel(n) {
    const r = this.getWritable();
    return r.__label = n, r;
  }
  setValue(n) {
    const r = this.getWritable();
    return r.__value = n, r;
  }
  setFormat(n) {
    if (this.isInput())
      return this;
    const r = this.getWritable();
    return r.__format = typeof n == "string" ? Mi[n] : n, r;
  }
  setStyle(n) {
    if (this.isInput())
      return this;
    const r = this.getWritable();
    return r.__style = n, r;
  }
  setSpanRef(n) {
    if (this.__decoratorSpan) return;
    const r = this.getWritable();
    r.__decoratorSpan = n;
  }
  setError(n) {
    const r = this.getWritable();
    r.__inputError = n;
  }
  patchStyle(n) {
    if (this.isInput())
      return this;
    let r = this.getStyle();
    for (const i in n) {
      const a = n[i], l = new RegExp(`${i}:\\s*([^;]+)`);
      r.match(l) ? r = r.replace(l, `${i}: ${a}`) : r += `; ${i}: ${a}`;
    }
    return this.setStyle(r);
  }
  toggleFormat(n) {
    if (this.isInput())
      return this;
    const r = this.getFormat(), i = fW(r, n);
    return this.setFormat(i);
  }
  clearAllFormats() {
    if (this.isInput())
      return this;
    this.setFormat(0), this.setStyle("");
  }
  decorate() {
    return /* @__PURE__ */ m(td, { fallback: null, children: /* @__PURE__ */ m(
      pW,
      {
        dataMention: this.__dataMention,
        label: this.__label,
        value: this.__value,
        data: this.__data,
        step: this.__step,
        error: this.__inputError,
        nodeKey: this.__key
      }
    ) });
  }
  remove(n) {
    this.__data !== "input" && this.__decoratorSpan && gW(this.__decoratorSpan), super.remove(n);
  }
}
const Zb = ({
  dataMention: e,
  fieldName: t,
  label: n,
  data: r,
  value: i,
  step: a,
  format: l,
  style: s
}) => {
  !i && e === "input" && (i = wf());
  const c = new wo(e, t, n, r, i, a, l, s);
  return En(c);
}, bW = (e) => e instanceof wo, ch = (e) => e === null || e.getNodes().length !== 1 ? !1 : bW(e.getNodes()[0]), Xo = 8, Vo = 72, UW = 15;
function vW({
  selectionFontSize: e,
  disabled: t = !1,
  editor: n
}) {
  const [r, i] = J.useState(e), a = (d, o) => {
    if (!o)
      return d;
    let u = d;
    switch (o) {
      case 2:
        switch (!0) {
          case d > Vo:
            u = Vo;
            break;
          case d >= 48:
            u -= 12;
            break;
          case d >= 24:
            u -= 4;
            break;
          case d >= 14:
            u -= 2;
            break;
          case d >= 9:
            u -= 1;
            break;
          default:
            u = Xo;
            break;
        }
        break;
      case 1:
        switch (!0) {
          case d < Xo:
            u = Xo;
            break;
          case d < 12:
            u += 1;
            break;
          case d < 20:
            u += 2;
            break;
          case d < 36:
            u += 4;
            break;
          case d <= 60:
            u += 12;
            break;
          default:
            u = Vo;
            break;
        }
        break;
    }
    return u;
  }, l = J.useCallback(
    (d, o) => {
      const u = (h) => (h || (h = `${UW}px`), h = h.slice(0, -2), `${a(
        Number(h),
        o
      )}px`);
      n.update(() => {
        if (n.isEditable()) {
          const h = se();
          h !== null && (ch(h) ? h.getNodes()[0].patchStyle({ "font-size": d || "15px" }) : Z3(h, {
            "font-size": d || u
          }));
        }
      });
    },
    [n]
  ), s = (d) => {
    const o = Number(r);
    if (["e", "E", "+", "-"].includes(d.key) || isNaN(o)) {
      d.preventDefault(), i("");
      return;
    }
    if (d.key === "Enter") {
      d.preventDefault();
      let u = o;
      o > Vo ? u = Vo : o < Xo && (u = Xo), i(String(u)), l(String(u) + "px", null);
    }
  }, c = (d) => {
    if (r !== "") {
      const o = a(
        Number(r),
        d
      );
      l(String(o) + "px", null);
    } else
      l(null, d);
  };
  return J.useEffect(() => {
    i(e);
  }, [e]), /* @__PURE__ */ D(ge, { children: [
    /* @__PURE__ */ m(
      "button",
      {
        type: "button",
        disabled: t || e !== "" && Number(r) <= Xo,
        onClick: () => c(
          2
          /* decrement */
        ),
        className: "toolbar-item font-decrement",
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon format minus-icon" })
      }
    ),
    /* @__PURE__ */ m(
      "input",
      {
        type: "number",
        value: r,
        disabled: t,
        className: "toolbar-item font-size-input",
        min: Xo,
        max: Vo,
        onChange: (d) => i(d.target.value),
        onKeyDown: s
      }
    ),
    /* @__PURE__ */ m(
      "button",
      {
        type: "button",
        disabled: t || e !== "" && Number(r) >= Vo,
        onClick: () => c(
          1
          /* increment */
        ),
        className: "toolbar-item font-increment",
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon format add-icon" })
      }
    )
  ] });
}
const yW = /* @__PURE__ */ new Set([
  "http:",
  "https:",
  "mailto:",
  "sms:",
  "tel:"
]);
function lm(e) {
  try {
    const t = new URL(e);
    if (!yW.has(t.protocol))
      return "about:blank";
  } catch {
    return e;
  }
  return e;
}
const wW = new RegExp(
  /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=+$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=+$,\w]+@)[A-Za-z0-9.-]+)((?:\/[+~%/.\w-_]*)?\??(?:[-+=&;%@.\w_]*)#?(?:[\w]*))?)/
);
function xW(e) {
  return e === "https://" || wW.test(e);
}
function h0(e) {
  const t = e.anchor, n = e.focus, r = e.anchor.getNode(), i = e.focus.getNode();
  return r === i ? r : e.isBackward() ? av(n) ? r : i : av(t) ? r : i;
}
function xo({
  label: e,
  value: t,
  onChange: n,
  placeholder: r = "",
  "data-test-id": i,
  type: a = "text"
}) {
  return /* @__PURE__ */ D("div", { className: "Input__wrapper", children: [
    /* @__PURE__ */ m("label", { className: "Input__label", children: e }),
    /* @__PURE__ */ m(
      "input",
      {
        type: a,
        className: "Input__input",
        placeholder: r,
        value: t,
        onChange: (l) => {
          n(l.target.value);
        },
        "data-test-id": i
      }
    )
  ] });
}
let z4 = !1;
const EW = [
  "#d0021b",
  "#f5a623",
  "#f8e71c",
  "#8b572a",
  "#7ed321",
  "#417505",
  "#bd10e0",
  "#9013fe",
  "#4a90e2",
  "#50e3c2",
  "#b8e986",
  "#000000",
  "#4a4a4a",
  "#9b9b9b",
  "#ffffff"
], pu = 214, Ay = 150;
function pT({
  color: e,
  onChange: t
}) {
  const [n, r] = Q(md("hex", e)), [i, a] = Q(e), l = de(null), s = Ke(
    () => ({
      x: n.hsv.s / 100 * pu,
      y: (100 - n.hsv.v) / 100 * Ay
    }),
    [n.hsv.s, n.hsv.v]
  ), c = Ke(
    () => ({
      x: n.hsv.h / 360 * pu
    }),
    [n.hsv]
  ), d = (h) => {
    if (a(h), /^#[0-9A-Fa-f]{6}$/i.test(h)) {
      const f = md("hex", h);
      r(f);
    }
  }, o = ({ x: h, y: f }) => {
    const p = {
      ...n.hsv,
      s: h / pu * 100,
      v: 100 - f / Ay * 100
    }, g = md("hsv", p);
    r(g), a(g.hex);
  }, u = ({ x: h }) => {
    const f = { ...n.hsv, h: h / pu * 360 }, p = md("hsv", f);
    r(p), a(p.hex);
  };
  return Y(() => {
    l.current !== null && t && (t(n.hex, z4), a(n.hex));
  }, [n, t]), Y(() => {
    if (e === void 0)
      return;
    const h = md("hex", e);
    r(h), a(h.hex);
  }, [e]), /* @__PURE__ */ D(
    "div",
    {
      className: "color-picker-wrapper",
      style: { width: pu },
      ref: l,
      children: [
        /* @__PURE__ */ m(xo, { label: "Hex", onChange: d, value: i }),
        /* @__PURE__ */ m("div", { className: "color-picker-basic-color", children: EW.map((h) => /* @__PURE__ */ m(
          "button",
          {
            type: "button",
            className: h === n.hex ? " active" : "",
            style: { backgroundColor: h },
            onClick: () => {
              a(h), r(md("hex", h));
            }
          },
          h
        )) }),
        /* @__PURE__ */ m(
          Ny,
          {
            className: "color-picker-saturation",
            style: { backgroundColor: `hsl(${n.hsv.h}, 100%, 50%)` },
            onChange: o,
            children: /* @__PURE__ */ m(
              "div",
              {
                className: "color-picker-saturation_cursor",
                style: {
                  backgroundColor: n.hex,
                  left: s.x,
                  top: s.y
                }
              }
            )
          }
        ),
        /* @__PURE__ */ m(Ny, { className: "color-picker-hue", onChange: u, children: /* @__PURE__ */ m(
          "div",
          {
            className: "color-picker-hue_cursor",
            style: {
              backgroundColor: `hsl(${n.hsv.h}, 100%, 50%)`,
              left: c.x
            }
          }
        ) }),
        /* @__PURE__ */ m(
          "div",
          {
            className: "color-picker-color",
            style: { backgroundColor: n.hex }
          }
        )
      ]
    }
  );
}
function Ny({ className: e, style: t, onChange: n, children: r }) {
  const i = de(null), a = de(!1), l = (c) => {
    if (i.current) {
      const { current: d } = i, { width: o, height: u, left: h, top: f } = d.getBoundingClientRect(), p = Dy(c.clientX - h, o, 0), g = Dy(c.clientY - f, u, 0);
      n({ x: p, y: g });
    }
  };
  return /* @__PURE__ */ m(
    "div",
    {
      ref: i,
      className: e,
      style: t,
      onMouseDown: (c) => {
        if (c.button !== 0)
          return;
        l(c);
        const d = (u) => {
          a.current = !0, z4 = !0, l(u);
        }, o = (u) => {
          a.current && (z4 = !1), document.removeEventListener("mousemove", d, !1), document.removeEventListener("mouseup", o, !1), l(u), a.current = !1;
        };
        document.addEventListener("mousemove", d, !1), document.addEventListener("mouseup", o, !1);
      },
      children: r
    }
  );
}
function Dy(e, t, n) {
  return e > t ? t : e < n ? n : e;
}
function Ly(e) {
  if (e.startsWith("#")) {
    if (e.length === 4 || e.length === 5)
      return e = e.split("").map((t, n) => n ? t + t : "#").join(""), e;
    if (e.length === 7 || e.length === 9)
      return e;
  } else {
    const t = document.createElement("canvas").getContext("2d");
    if (!t)
      throw new Error("2d context not supported or canvas already initialized");
    return t.fillStyle = e, t.fillStyle;
  }
  return "#000000";
}
function Ry(e) {
  const t = (e.replace(
    /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
    (n, r, i, a) => "#" + r + r + i + i + a + a
  ).substring(1).match(/.{2}/g) || []).map((n) => parseInt(n, 16));
  return {
    b: t[2],
    g: t[1],
    r: t[0]
  };
}
function y6({ r: e, g: t, b: n }) {
  e /= 255, t /= 255, n /= 255;
  const r = Math.max(e, t, n), i = r - Math.min(e, t, n), a = i ? (r === e ? (t - n) / i + (t < n ? 6 : 0) : r === t ? 2 + (n - e) / i : 4 + (e - t) / i) * 60 : 0, l = r ? i / r * 100 : 0, s = r * 100;
  return { h: a, s: l, v: s };
}
function SW({ h: e, s: t, v: n }) {
  t /= 100, n /= 100;
  const r = ~~(e / 60), i = e / 60 - r, a = n * (1 - t), l = n * (1 - t * i), s = n * (1 - t * (1 - i)), c = r % 6, d = Math.round([n, l, a, a, s, n][c] * 255), o = Math.round([s, n, n, l, a, a][c] * 255);
  return { b: Math.round([a, a, s, n, n, l][c] * 255), g: o, r: d };
}
function Py({ b: e, g: t, r: n }) {
  return "#" + [n, t, e].map((r) => r.toString(16).padStart(2, "0")).join("");
}
function md(e, t) {
  let n = Ly("#121212"), r = Ry(n), i = y6(r);
  return e === "hex" ? (n = Ly(t), r = Ry(n), i = y6(r)) : e === "rgb" ? (r = t, n = Py(r), i = y6(r)) : e === "hsv" && (i = t, r = SW(i), n = Py(r)), { hex: n, hsv: i, rgb: r };
}
function Oy({
  disabled: e = !1,
  stopCloseOnClickSelf: t = !0,
  color: n,
  onChange: r,
  ...i
}) {
  return /* @__PURE__ */ m(
    $c,
    {
      ...i,
      disabled: e,
      stopCloseOnClickSelf: t,
      children: /* @__PURE__ */ m(pT, { color: n, onChange: r })
    }
  );
}
const Jb = xn();
function _W() {
  const [e] = Fe();
  return Y(() => {
    if (!e.hasNodes([X0]))
      throw new Error(
        "PageBreakPlugin: PageBreakNode is not registered on editor"
      );
    return Pt(
      e.registerCommand(
        Jb,
        () => {
          const t = se();
          if (!ie(t))
            return !1;
          if (t.focus.getNode() !== null) {
            const r = vb();
            Lo(r);
          }
          return !0;
        },
        it
      )
    );
  }, [e]), null;
}
function kW({ children: e }) {
  return /* @__PURE__ */ m("div", { className: "DialogButtonsList", children: e });
}
function J0({
  "data-test-id": e,
  children: t
}) {
  return /* @__PURE__ */ m("div", { className: "DialogActions", "data-test-id": e, children: t });
}
function CW(...e) {
  return e.filter(Boolean).join(" ");
}
function Qi({
  "data-test-id": e,
  children: t,
  className: n,
  onClick: r,
  disabled: i,
  small: a,
  title: l
}) {
  return /* @__PURE__ */ m(
    "button",
    {
      type: "button",
      disabled: i,
      className: CW(
        "Button__root",
        i && "Button__disabled",
        a && "Button__small",
        n
      ),
      onClick: r,
      title: l,
      "aria-label": l,
      ...e && { "data-test-id": e },
      children: t
    }
  );
}
function mT({
  accept: e,
  label: t,
  onChange: n,
  "data-test-id": r
}) {
  return /* @__PURE__ */ D("div", { className: "Input__wrapper", children: [
    /* @__PURE__ */ m("label", { className: "Input__label", children: t }),
    /* @__PURE__ */ m(
      "input",
      {
        type: "file",
        accept: e,
        className: "Input__input",
        onChange: (i) => n(i.target.files),
        "data-test-id": r
      }
    )
  ] });
}
const MW = (e) => Z0 ? (e || window).getSelection() : null, Lf = xn();
function TW({
  onClick: e
}) {
  const [t, n] = Q(""), [r, i] = Q("");
  return /* @__PURE__ */ D(ge, { children: [
    /* @__PURE__ */ m(
      xo,
      {
        label: "Image URL",
        placeholder: "i.e. https://source.unsplash.com/random",
        onChange: n,
        value: t,
        "data-test-id": "image-modal-url-input"
      }
    ),
    /* @__PURE__ */ m(
      xo,
      {
        label: "Alt Text",
        placeholder: "Random unsplash image",
        onChange: i,
        value: r,
        "data-test-id": "image-modal-alt-text-input"
      }
    ),
    /* @__PURE__ */ m(J0, { children: /* @__PURE__ */ m(
      Qi,
      {
        "data-test-id": "image-modal-confirm-btn",
        disabled: t === "",
        onClick: () => e({ altText: r, src: t }),
        children: "Confirm"
      }
    ) })
  ] });
}
function IW({
  onClick: e,
  imageUploadCallback: t
}) {
  const [n, r] = Q(""), [i, a] = Q(), [l, s] = Q("");
  return /* @__PURE__ */ D(ge, { children: [
    /* @__PURE__ */ m(
      mT,
      {
        label: "Image Upload",
        onChange: (u) => {
          const h = new FileReader();
          h.onload = function() {
            return typeof h.result == "string" && (r(h.result), a(u == null ? void 0 : u[0])), "";
          }, u !== null && h.readAsDataURL(u[0]);
        },
        accept: "image/*",
        "data-test-id": "image-modal-file-upload"
      }
    ),
    /* @__PURE__ */ m(
      xo,
      {
        label: "Alt Text",
        placeholder: "Descriptive alternative text",
        onChange: s,
        value: l,
        "data-test-id": "image-modal-alt-text-input"
      }
    ),
    /* @__PURE__ */ m(J0, { children: /* @__PURE__ */ m(
      Qi,
      {
        "data-test-id": "image-modal-file-upload-btn",
        disabled: n === "",
        onClick: () => {
          t && i ? t(i, n, (u) => {
            r(u), e({ altText: l, src: u });
          }) : e({ altText: l, src: n });
        },
        children: "Confirm"
      }
    ) })
  ] });
}
function gT({
  activeEditor: e,
  onClose: t,
  imageUploadCallback: n
}) {
  const [r, i] = Q(null), a = de(!1);
  Y(() => {
    a.current = !1;
    const s = (c) => {
      a.current = c.altKey;
    };
    return document.addEventListener("keydown", s), () => {
      document.removeEventListener("keydown", s);
    };
  }, [e]);
  const l = (s) => {
    e.dispatchCommand(Lf, s), t();
  };
  return /* @__PURE__ */ D(ge, { children: [
    !r && /* @__PURE__ */ D(kW, { children: [
      /* @__PURE__ */ m(
        Qi,
        {
          "data-test-id": "image-modal-option-url",
          onClick: () => i("url"),
          children: "URL"
        }
      ),
      /* @__PURE__ */ m(
        Qi,
        {
          "data-test-id": "image-modal-option-file",
          onClick: () => i("file"),
          children: "File"
        }
      )
    ] }),
    r === "url" && /* @__PURE__ */ m(TW, { onClick: l }),
    r === "file" && /* @__PURE__ */ m(IW, { onClick: l, imageUploadCallback: n })
  ] });
}
function AW({
  captionsEnabled: e
}) {
  const [t] = Fe();
  return Y(() => {
    if (!t.hasNodes([V0]))
      throw new Error("ImagesPlugin: ImageNode not registered on editor");
    return Pt(
      t.registerCommand(
        Lf,
        (n) => {
          const r = yb(n);
          return z0([r]), er(r.getParentOrThrow()) && xf(r, He).selectEnd(), !0;
        },
        it
      ),
      t.registerCommand(
        ug,
        (n) => DW(n),
        vi
      ),
      t.registerCommand(
        bf,
        (n) => LW(n),
        ot
      ),
      t.registerCommand(
        gf,
        (n) => RW(n, t),
        vi
      )
    );
  }, [e, t]), null;
}
const NW = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", bT = document.createElement("img");
bT.src = NW;
function DW(e) {
  const t = Qb();
  if (!t)
    return !1;
  const n = e.dataTransfer;
  return n ? (n.setData("text/plain", "_"), n.setDragImage(bT, 0, 0), n.setData(
    "application/x-lexical-drag",
    JSON.stringify({
      data: {
        altText: t.__altText,
        caption: t.__caption,
        height: t.__height,
        key: t.getKey(),
        maxWidth: t.__maxWidth,
        showCaption: t.__showCaption,
        src: t.__src,
        width: t.__width
      },
      type: "image"
    })
  ), !0) : !1;
}
function LW(e) {
  return Qb() ? (UT(e) || e.preventDefault(), !0) : !1;
}
function RW(e, t) {
  const n = Qb();
  if (!n)
    return !1;
  const r = PW(e);
  if (!r)
    return !1;
  if (e.preventDefault(), UT(e)) {
    const i = OW(e);
    n.remove();
    const a = yf();
    i != null && a.applyDOMRange(i), pn(a), t.dispatchCommand(Lf, r);
  }
  return !0;
}
function Qb() {
  const e = se();
  if (!Xn(e))
    return null;
  const n = e.getNodes()[0];
  return mz(n) ? n : null;
}
function PW(e) {
  var i;
  const t = (i = e.dataTransfer) == null ? void 0 : i.getData("application/x-lexical-drag");
  if (!t)
    return null;
  const { type: n, data: r } = JSON.parse(t);
  return n !== "image" ? null : r;
}
function UT(e) {
  const t = e.target;
  return !!(t && t instanceof HTMLElement && !t.closest("code, span.editor-image") && t.parentElement && t.parentElement.closest("div.content-editable__root"));
}
function OW(e) {
  let t;
  const n = e.target, r = n == null ? null : n.nodeType === 9 ? n.defaultView : n.ownerDocument.defaultView, i = MW(r);
  if (document.caretRangeFromPoint)
    t = document.caretRangeFromPoint(e.clientX, e.clientY);
  else if (e.rangeParent && i !== null)
    i.collapse(e.rangeParent, e.rangeOffset || 0), t = i.getRangeAt(0);
  else
    throw Error("Cannot get the selection when dragging");
  return t;
}
function $W({
  onClose: e,
  children: t,
  title: n,
  closeOnClickOutside: r
}) {
  const i = de(null);
  return Y(() => {
    i.current !== null && i.current.focus();
  }, []), Y(() => {
    let a = null;
    const l = (d) => {
      d.key === "Escape" && e();
    }, s = (d) => {
      const o = d.target;
      i.current !== null && !i.current.contains(o) && r && e();
    }, c = i.current;
    return c !== null && (a = c.parentElement, a !== null && a.addEventListener("click", s)), window.addEventListener("keydown", l), () => {
      window.removeEventListener("keydown", l), a !== null && (a == null || a.removeEventListener("click", s));
    };
  }, [r, e]), /* @__PURE__ */ m("div", { className: "Modal__overlay", role: "dialog", children: /* @__PURE__ */ D("div", { className: "Modal__modal", tabIndex: -1, ref: i, children: [
    /* @__PURE__ */ m("h2", { className: "Modal__title", children: n }),
    /* @__PURE__ */ m(
      "button",
      {
        className: "Modal__closeButton",
        "aria-label": "Close modal",
        type: "button",
        onClick: e,
        children: "X"
      }
    ),
    /* @__PURE__ */ m("div", { className: "Modal__content", children: t })
  ] }) });
}
function vT({
  onClose: e,
  children: t,
  title: n,
  closeOnClickOutside: r = !1
}) {
  return fi(
    /* @__PURE__ */ m(
      $W,
      {
        onClose: e,
        title: n,
        closeOnClickOutside: r,
        children: t
      }
    ),
    document.body
  );
}
function zg() {
  const [e, t] = Q(null), n = he(() => {
    t(null);
  }, []), r = Ke(() => {
    if (e === null)
      return null;
    const { title: a, content: l, closeOnClickOutside: s } = e;
    return /* @__PURE__ */ m(
      vT,
      {
        onClose: n,
        title: a,
        closeOnClickOutside: s,
        children: l
      }
    );
  }, [e, n]), i = he(
    (a, l, s = !1) => {
      t({
        closeOnClickOutside: s,
        content: l(n),
        title: a
      });
    },
    [n]
  );
  return [r, i];
}
function FW({
  children: e,
  label: t,
  className: n,
  ...r
}) {
  return /* @__PURE__ */ D("div", { className: "Input__wrapper", children: [
    /* @__PURE__ */ m("label", { style: { marginTop: "-1em" }, className: "Input__label", children: t }),
    /* @__PURE__ */ m("select", { ...r, className: n || "select", children: e })
  ] });
}
const zW = (e) => Z0 ? (e || window).getSelection() : null, sm = xn();
function BW({
  activeEditor: e,
  onClose: t,
  imageUploadCallback: n
}) {
  const r = de(!1), [i, a] = Q(""), [l, s] = Q(""), [c, d] = Q(), [o, u] = Q(!1), [h, f] = Q("left"), p = i === "", g = (y) => {
    u(y.target.checked);
  }, b = (y) => {
    f(y.target.value);
  }, v = (y) => {
    const w = new FileReader();
    w.onload = function() {
      return typeof w.result == "string" && (a(w.result), d(y == null ? void 0 : y[0])), "";
    }, y !== null && w.readAsDataURL(y[0]);
  };
  Y(() => {
    r.current = !1;
    const y = (w) => {
      r.current = w.altKey;
    };
    return document.addEventListener("keydown", y), () => {
      document.removeEventListener("keydown", y);
    };
  }, [e]);
  const U = () => {
    const y = { altText: l, position: h, showCaption: o, src: i };
    n && c ? n(c, i, (w) => {
      a(w), e.dispatchCommand(sm, { ...y, src: w });
    }) : e.dispatchCommand(sm, y), t();
  };
  return /* @__PURE__ */ D(ge, { children: [
    /* @__PURE__ */ m("div", { style: { marginBottom: "1em" }, children: /* @__PURE__ */ m(
      mT,
      {
        label: "Image Upload",
        onChange: v,
        accept: "image/*",
        "data-test-id": "image-modal-file-upload"
      }
    ) }),
    /* @__PURE__ */ m("div", { style: { marginBottom: "1em" }, children: /* @__PURE__ */ m(
      xo,
      {
        label: "Alt Text",
        placeholder: "Descriptive alternative text",
        onChange: s,
        value: l,
        "data-test-id": "image-modal-alt-text-input"
      }
    ) }),
    /* @__PURE__ */ D(
      FW,
      {
        style: { marginBottom: "1em", width: "290px" },
        label: "Position",
        name: "position",
        id: "position-select",
        onChange: b,
        children: [
          /* @__PURE__ */ m("option", { value: "left", children: "Left" }),
          /* @__PURE__ */ m("option", { value: "right", children: "Right" }),
          /* @__PURE__ */ m("option", { value: "full", children: "Full Width" })
        ]
      }
    ),
    /* @__PURE__ */ D("div", { className: "Input__wrapper", children: [
      /* @__PURE__ */ m(
        "input",
        {
          id: "caption",
          className: "InlineImageNode_Checkbox",
          type: "checkbox",
          checked: o,
          onChange: g
        }
      ),
      /* @__PURE__ */ m("label", { htmlFor: "caption", children: "Show Caption" })
    ] }),
    /* @__PURE__ */ m(J0, { children: /* @__PURE__ */ m(
      Qi,
      {
        "data-test-id": "image-modal-file-upload-btn",
        disabled: p,
        onClick: () => U(),
        children: "Confirm"
      }
    ) })
  ] });
}
function HW() {
  const [e] = Fe();
  return Y(() => {
    if (!e.hasNodes([q0]))
      throw new Error("ImagesPlugin: ImageNode not registered on editor");
    return Pt(
      e.registerCommand(
        sm,
        (t) => {
          const n = qb(t);
          return z0([n]), er(n.getParentOrThrow()) && xf(n, He).selectEnd(), !0;
        },
        it
      ),
      e.registerCommand(
        ug,
        (t) => XW(t),
        vi
      ),
      e.registerCommand(
        bf,
        (t) => VW(t),
        ot
      ),
      e.registerCommand(
        gf,
        (t) => GW(t, e),
        vi
      )
    );
  }, [e]), null;
}
const WW = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", yT = document.createElement("img");
yT.src = WW;
function XW(e) {
  const t = e8();
  if (!t)
    return !1;
  const n = e.dataTransfer;
  return n ? (n.setData("text/plain", "_"), n.setDragImage(yT, 0, 0), n.setData(
    "application/x-lexical-drag",
    JSON.stringify({
      data: {
        altText: t.__altText,
        caption: t.__caption,
        height: t.__height,
        key: t.getKey(),
        showCaption: t.__showCaption,
        src: t.__src,
        width: t.__width
      },
      type: "image"
    })
  ), !0) : !1;
}
function VW(e) {
  return e8() ? (wT(e) || e.preventDefault(), !0) : !1;
}
function GW(e, t) {
  const n = e8();
  if (!n)
    return !1;
  const r = jW(e);
  if (!r)
    return !1;
  if (e.preventDefault(), wT(e)) {
    const i = KW(e);
    n.remove();
    const a = yf();
    i != null && a.applyDOMRange(i), pn(a), t.dispatchCommand(sm, r);
  }
  return !0;
}
function e8() {
  const e = se();
  if (!Xn(e))
    return null;
  const n = e.getNodes()[0];
  return CH(n) ? n : null;
}
function jW(e) {
  var i;
  const t = (i = e.dataTransfer) == null ? void 0 : i.getData("application/x-lexical-drag");
  if (!t)
    return null;
  const { type: n, data: r } = JSON.parse(t);
  return n !== "image" ? null : r;
}
function wT(e) {
  const t = e.target;
  return !!(t && t instanceof HTMLElement && !t.closest("code, span.editor-image") && t.parentElement && t.parentElement.closest("div.content-editable__root"));
}
function KW(e) {
  let t;
  const n = e.target, r = n == null ? null : n.nodeType === 9 ? n.defaultView : n.ownerDocument.defaultView, i = zW(r);
  if (document.caretRangeFromPoint)
    t = document.caretRangeFromPoint(e.clientX, e.clientY);
  else if (e.rangeParent && i !== null)
    i.collapse(e.rangeParent, e.rangeOffset || 0), t = i.getRangeAt(0);
  else
    throw Error("Cannot get the selection when dragging");
  return t;
}
var st = { VITE_APP_BACKEND_V2_GET_URL: "https://json.excalidraw.com/api/v2/", VITE_APP_BACKEND_V2_POST_URL: "https://json.excalidraw.com/api/v2/post/", VITE_APP_LIBRARY_URL: "https://libraries.excalidraw.com", VITE_APP_LIBRARY_BACKEND: "https://us-central1-excalidraw-room-persistence.cloudfunctions.net/libraries", VITE_APP_PLUS_LP: "https://plus.excalidraw.com", VITE_APP_PLUS_APP: "https://app.excalidraw.com", VITE_APP_AI_BACKEND: "https://oss-ai.excalidraw.com", VITE_APP_WS_SERVER_URL: "https://oss-collab.excalidraw.com", VITE_APP_FIREBASE_CONFIG: '{"apiKey":"AIzaSyAd15pYlMci_xIp9ko6wkEsDzAAA0Dn0RU","authDomain":"excalidraw-room-persistence.firebaseapp.com","databaseURL":"https://excalidraw-room-persistence.firebaseio.com","projectId":"excalidraw-room-persistence","storageBucket":"excalidraw-room-persistence.appspot.com","messagingSenderId":"654800341332","appId":"1:654800341332:web:4a692de832b55bd57ce0c1"}', VITE_APP_ENABLE_TRACKING: "false", VITE_APP_PLUS_EXPORT_PUBLIC_KEY: `MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApQ0jM9Qz8TdFLzcuAZZX
/WvuKSOJxiw6AR/ZcE3eFQWM/mbFdhQgyK8eHGkKQifKzH1xUZjCxyXcxW6ZO02t
kPOPxhz+nxUrIoWCD/V4NGmUA1lxwHuO21HN1gzKrN3xHg5EGjyouR9vibT9VDGF
gq6+4Ic/kJX+AD2MM7Yre2+FsOdysrmuW2Fu3ahuC1uQE7pOe1j0k7auNP0y1q53
PrB8Ts2LUpepWC1l7zIXFm4ViDULuyWXTEpUcHSsEH8vpd1tckjypxCwkipfZsXx
iPszy0o0Dx2iArPfWMXlFAI9mvyFCyFC3+nSvfyAUb2C4uZgCwAuyFh/ydPF4DEE
PQIDAQAB`, VITE_APP_DEBUG_ENABLE_TEXT_CONTAINER_BOUNDING_BOX: "false", VITE_APP_COLLAPSE_OVERLAY: "false", VITE_APP_ENABLE_ESLINT: "false", PKG_NAME: "@excalidraw/excalidraw", PKG_VERSION: "0.18.0", PROD: !0 }, xT = Object.defineProperty, YW = (e, t, n) => t in e ? xT(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, b4e = ((e) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(e, { get: (t, n) => (typeof require < "u" ? require : t)[n] }) : e)(function(e) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + e + '" is not supported');
}), qW = (e) => (t) => {
  var n = e[t];
  if (n) return n();
  throw new Error("Module not found in bundle: " + t);
}, ET = (e, t) => {
  for (var n in t) xT(e, n, { get: t[n], enumerable: !0 });
}, $ = (e, t, n) => (YW(e, typeof t != "symbol" ? t + "" : t, n), n), t8 = {};
(function(e) {
  (function(t) {
    t(typeof DO_NOT_EXPORT_CRC > "u" ? e : {});
  })(function(t) {
    t.version = "0.3.0";
    function n() {
      for (var d = 0, o = new Array(256), u = 0; u != 256; ++u)
        d = u, d = d & 1 ? -306674912 ^ d >>> 1 : d >>> 1, d = d & 1 ? -306674912 ^ d >>> 1 : d >>> 1, d = d & 1 ? -306674912 ^ d >>> 1 : d >>> 1, d = d & 1 ? -306674912 ^ d >>> 1 : d >>> 1, d = d & 1 ? -306674912 ^ d >>> 1 : d >>> 1, d = d & 1 ? -306674912 ^ d >>> 1 : d >>> 1, d = d & 1 ? -306674912 ^ d >>> 1 : d >>> 1, d = d & 1 ? -306674912 ^ d >>> 1 : d >>> 1, o[u] = d;
      return typeof Int32Array < "u" ? new Int32Array(o) : o;
    }
    var r = n(), i = typeof Buffer < "u";
    function a(d) {
      if (d.length > 32768 && i) return s(new Buffer(d));
      for (var o = -1, u = d.length - 1, h = 0; h < u; )
        o = r[(o ^ d.charCodeAt(h++)) & 255] ^ o >>> 8, o = r[(o ^ d.charCodeAt(h++)) & 255] ^ o >>> 8;
      return h === u && (o = o >>> 8 ^ r[(o ^ d.charCodeAt(h)) & 255]), o ^ -1;
    }
    function l(d) {
      if (d.length > 1e4) return s(d);
      for (var o = -1, u = 0, h = d.length - 3; u < h; )
        o = o >>> 8 ^ r[(o ^ d[u++]) & 255], o = o >>> 8 ^ r[(o ^ d[u++]) & 255], o = o >>> 8 ^ r[(o ^ d[u++]) & 255], o = o >>> 8 ^ r[(o ^ d[u++]) & 255];
      for (; u < h + 3; ) o = o >>> 8 ^ r[(o ^ d[u++]) & 255];
      return o ^ -1;
    }
    function s(d) {
      for (var o = -1, u = 0, h = d.length - 7; u < h; )
        o = o >>> 8 ^ r[(o ^ d[u++]) & 255], o = o >>> 8 ^ r[(o ^ d[u++]) & 255], o = o >>> 8 ^ r[(o ^ d[u++]) & 255], o = o >>> 8 ^ r[(o ^ d[u++]) & 255], o = o >>> 8 ^ r[(o ^ d[u++]) & 255], o = o >>> 8 ^ r[(o ^ d[u++]) & 255], o = o >>> 8 ^ r[(o ^ d[u++]) & 255], o = o >>> 8 ^ r[(o ^ d[u++]) & 255];
      for (; u < h + 7; ) o = o >>> 8 ^ r[(o ^ d[u++]) & 255];
      return o ^ -1;
    }
    function c(d) {
      for (var o = -1, u = 0, h = d.length, f, p; u < h; )
        f = d.charCodeAt(u++), f < 128 ? o = o >>> 8 ^ r[(o ^ f) & 255] : f < 2048 ? (o = o >>> 8 ^ r[(o ^ (192 | f >> 6 & 31)) & 255], o = o >>> 8 ^ r[(o ^ (128 | f & 63)) & 255]) : f >= 55296 && f < 57344 ? (f = (f & 1023) + 64, p = d.charCodeAt(u++) & 1023, o = o >>> 8 ^ r[(o ^ (240 | f >> 8 & 7)) & 255], o = o >>> 8 ^ r[(o ^ (128 | f >> 2 & 63)) & 255], o = o >>> 8 ^ r[(o ^ (128 | p >> 6 & 15 | f & 3)) & 255], o = o >>> 8 ^ r[(o ^ (128 | p & 63)) & 255]) : (o = o >>> 8 ^ r[(o ^ (224 | f >> 12 & 15)) & 255], o = o >>> 8 ^ r[(o ^ (128 | f >> 6 & 63)) & 255], o = o >>> 8 ^ r[(o ^ (128 | f & 63)) & 255]);
      return o ^ -1;
    }
    t.table = r, t.bstr = a, t.buf = l, t.str = c;
  });
})(t8);
var ZW = t8, JW = tX, Za = new Uint8Array(4), QW = new Int32Array(Za.buffer), eX = new Uint32Array(Za.buffer);
function tX(e) {
  if (e[0] !== 137) throw new Error("Invalid .png file header");
  if (e[1] !== 80) throw new Error("Invalid .png file header");
  if (e[2] !== 78) throw new Error("Invalid .png file header");
  if (e[3] !== 71) throw new Error("Invalid .png file header");
  if (e[4] !== 13) throw new Error("Invalid .png file header: possibly caused by DOS-Unix line ending conversion?");
  if (e[5] !== 10) throw new Error("Invalid .png file header: possibly caused by DOS-Unix line ending conversion?");
  if (e[6] !== 26) throw new Error("Invalid .png file header");
  if (e[7] !== 10) throw new Error("Invalid .png file header: possibly caused by DOS-Unix line ending conversion?");
  for (var t = !1, n = [], r = 8; r < e.length; ) {
    Za[3] = e[r++], Za[2] = e[r++], Za[1] = e[r++], Za[0] = e[r++];
    var i = eX[0] + 4, a = new Uint8Array(i);
    a[0] = e[r++], a[1] = e[r++], a[2] = e[r++], a[3] = e[r++];
    var l = String.fromCharCode(a[0]) + String.fromCharCode(a[1]) + String.fromCharCode(a[2]) + String.fromCharCode(a[3]);
    if (!n.length && l !== "IHDR")
      throw new Error("IHDR header missing");
    if (l === "IEND") {
      t = !0, n.push({
        name: l,
        data: new Uint8Array(0)
      });
      break;
    }
    for (var s = 4; s < i; s++)
      a[s] = e[r++];
    Za[3] = e[r++], Za[2] = e[r++], Za[1] = e[r++], Za[0] = e[r++];
    var c = QW[0], d = ZW.buf(a);
    if (d !== c)
      throw new Error(
        "CRC values for " + l + " header do not match, PNG file is likely corrupted"
      );
    var o = new Uint8Array(a.buffer.slice(4));
    n.push({
      name: l,
      data: o
    });
  }
  if (!t)
    throw new Error(".png file ended prematurely: no IEND header was found");
  return n;
}
const ST = /* @__PURE__ */ ad(JW);
var Bg = {}, nX = rX;
function rX(e, t) {
  if (e = String(e), t = String(t), !/^[\x00-\xFF]+$/.test(e) || !/^[\x00-\xFF]+$/.test(t))
    throw new Error("Only Latin-1 characters are permitted in PNG tEXt chunks. You might want to consider base64 encoding and/or zEXt compression");
  if (e.length >= 80)
    throw new Error('Keyword "' + e + '" is longer than the 79-character limit imposed by the PNG specification');
  for (var n = e.length + t.length + 1, r = new Uint8Array(n), i = 0, a, l = 0; l < e.length; l++) {
    if (!(a = e.charCodeAt(l)))
      throw new Error("0x00 character is not permitted in tEXt keywords");
    r[i++] = a;
  }
  r[i++] = 0;
  for (var s = 0; s < t.length; s++) {
    if (!(a = t.charCodeAt(s)))
      throw new Error("0x00 character is not permitted in tEXt content");
    r[i++] = a;
  }
  return {
    name: "tEXt",
    data: r
  };
}
var iX = aX;
function aX(e) {
  e.data && e.name && (e = e.data);
  for (var t = !0, n = "", r = "", i = 0; i < e.length; i++) {
    var a = e[i];
    if (t)
      a ? r += String.fromCharCode(a) : t = !1;
    else if (a)
      n += String.fromCharCode(a);
    else
      throw new Error("Invalid NULL character found. 0x00 character is not permitted in tEXt content");
  }
  return {
    keyword: r,
    text: n
  };
}
Bg.encode = nX;
Bg.decode = iX;
var lX = function(e, t, n) {
  var r = [], i = e.length;
  if (i === 0) return r;
  var a = t < 0 ? Math.max(0, t + i) : t || 0;
  for (n !== void 0 && (i = n < 0 ? n + i : n); i-- > a; )
    r[i - a] = e[i];
  return r;
}, sX = lX, oX = t8, cX = hX, Ja = new Uint8Array(4), dX = new Int32Array(Ja.buffer), uX = new Uint32Array(Ja.buffer);
function hX(e) {
  var t = 8, n = t, r;
  for (r = 0; r < e.length; r++)
    t += e[r].data.length, t += 12;
  var i = new Uint8Array(t);
  for (i[0] = 137, i[1] = 80, i[2] = 78, i[3] = 71, i[4] = 13, i[5] = 10, i[6] = 26, i[7] = 10, r = 0; r < e.length; r++) {
    var a = e[r], l = a.name, s = a.data, c = s.length, d = [
      l.charCodeAt(0),
      l.charCodeAt(1),
      l.charCodeAt(2),
      l.charCodeAt(3)
    ];
    uX[0] = c, i[n++] = Ja[3], i[n++] = Ja[2], i[n++] = Ja[1], i[n++] = Ja[0], i[n++] = d[0], i[n++] = d[1], i[n++] = d[2], i[n++] = d[3];
    for (var o = 0; o < c; )
      i[n++] = s[o++];
    var u = d.concat(sX(s)), h = oX.buf(u);
    dX[0] = h, i[n++] = Ja[3], i[n++] = Ja[2], i[n++] = Ja[1], i[n++] = Ja[0];
  }
  return i;
}
const fX = /* @__PURE__ */ ad(cX);
/*! pako 2.0.3 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const pX = 4, $y = 0, Fy = 1, mX = 2;
function Q0(e) {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
}
const gX = 0, _T = 1, bX = 2, UX = 3, vX = 258, n8 = 29, Rf = 256, Ph = Rf + 1 + n8, qd = 30, r8 = 19, kT = 2 * Ph + 1, dc = 15, w6 = 16, yX = 7, i8 = 256, CT = 16, MT = 17, TT = 18, B4 = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
), rp = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
), wX = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
), IT = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), xX = 512, ql = new Array((Ph + 2) * 2);
Q0(ql);
const dh = new Array(qd * 2);
Q0(dh);
const Oh = new Array(xX);
Q0(Oh);
const $h = new Array(vX - UX + 1);
Q0($h);
const a8 = new Array(n8);
Q0(a8);
const om = new Array(qd);
Q0(om);
function x6(e, t, n, r, i) {
  this.static_tree = e, this.extra_bits = t, this.extra_base = n, this.elems = r, this.max_length = i, this.has_stree = e && e.length;
}
let AT, NT, DT;
function E6(e, t) {
  this.dyn_tree = e, this.max_code = 0, this.stat_desc = t;
}
const LT = (e) => e < 256 ? Oh[e] : Oh[256 + (e >>> 7)], Fh = (e, t) => {
  e.pending_buf[e.pending++] = t & 255, e.pending_buf[e.pending++] = t >>> 8 & 255;
}, si = (e, t, n) => {
  e.bi_valid > w6 - n ? (e.bi_buf |= t << e.bi_valid & 65535, Fh(e, e.bi_buf), e.bi_buf = t >> w6 - e.bi_valid, e.bi_valid += n - w6) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += n);
}, dl = (e, t, n) => {
  si(
    e,
    n[t * 2],
    n[t * 2 + 1]
    /*.Len*/
  );
}, RT = (e, t) => {
  let n = 0;
  do
    n |= e & 1, e >>>= 1, n <<= 1;
  while (--t > 0);
  return n >>> 1;
}, EX = (e) => {
  e.bi_valid === 16 ? (Fh(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = e.bi_buf & 255, e.bi_buf >>= 8, e.bi_valid -= 8);
}, SX = (e, t) => {
  const n = t.dyn_tree, r = t.max_code, i = t.stat_desc.static_tree, a = t.stat_desc.has_stree, l = t.stat_desc.extra_bits, s = t.stat_desc.extra_base, c = t.stat_desc.max_length;
  let d, o, u, h, f, p, g = 0;
  for (h = 0; h <= dc; h++)
    e.bl_count[h] = 0;
  for (n[e.heap[e.heap_max] * 2 + 1] = 0, d = e.heap_max + 1; d < kT; d++)
    o = e.heap[d], h = n[n[o * 2 + 1] * 2 + 1] + 1, h > c && (h = c, g++), n[o * 2 + 1] = h, !(o > r) && (e.bl_count[h]++, f = 0, o >= s && (f = l[o - s]), p = n[o * 2], e.opt_len += p * (h + f), a && (e.static_len += p * (i[o * 2 + 1] + f)));
  if (g !== 0) {
    do {
      for (h = c - 1; e.bl_count[h] === 0; )
        h--;
      e.bl_count[h]--, e.bl_count[h + 1] += 2, e.bl_count[c]--, g -= 2;
    } while (g > 0);
    for (h = c; h !== 0; h--)
      for (o = e.bl_count[h]; o !== 0; )
        u = e.heap[--d], !(u > r) && (n[u * 2 + 1] !== h && (e.opt_len += (h - n[u * 2 + 1]) * n[u * 2], n[u * 2 + 1] = h), o--);
  }
}, PT = (e, t, n) => {
  const r = new Array(dc + 1);
  let i = 0, a, l;
  for (a = 1; a <= dc; a++)
    r[a] = i = i + n[a - 1] << 1;
  for (l = 0; l <= t; l++) {
    let s = e[l * 2 + 1];
    s !== 0 && (e[l * 2] = RT(r[s]++, s));
  }
}, _X = () => {
  let e, t, n, r, i;
  const a = new Array(dc + 1);
  for (n = 0, r = 0; r < n8 - 1; r++)
    for (a8[r] = n, e = 0; e < 1 << B4[r]; e++)
      $h[n++] = r;
  for ($h[n - 1] = r, i = 0, r = 0; r < 16; r++)
    for (om[r] = i, e = 0; e < 1 << rp[r]; e++)
      Oh[i++] = r;
  for (i >>= 7; r < qd; r++)
    for (om[r] = i << 7, e = 0; e < 1 << rp[r] - 7; e++)
      Oh[256 + i++] = r;
  for (t = 0; t <= dc; t++)
    a[t] = 0;
  for (e = 0; e <= 143; )
    ql[e * 2 + 1] = 8, e++, a[8]++;
  for (; e <= 255; )
    ql[e * 2 + 1] = 9, e++, a[9]++;
  for (; e <= 279; )
    ql[e * 2 + 1] = 7, e++, a[7]++;
  for (; e <= 287; )
    ql[e * 2 + 1] = 8, e++, a[8]++;
  for (PT(ql, Ph + 1, a), e = 0; e < qd; e++)
    dh[e * 2 + 1] = 5, dh[e * 2] = RT(e, 5);
  AT = new x6(ql, B4, Rf + 1, Ph, dc), NT = new x6(dh, rp, 0, qd, dc), DT = new x6(new Array(0), wX, 0, r8, yX);
}, OT = (e) => {
  let t;
  for (t = 0; t < Ph; t++)
    e.dyn_ltree[t * 2] = 0;
  for (t = 0; t < qd; t++)
    e.dyn_dtree[t * 2] = 0;
  for (t = 0; t < r8; t++)
    e.bl_tree[t * 2] = 0;
  e.dyn_ltree[i8 * 2] = 1, e.opt_len = e.static_len = 0, e.last_lit = e.matches = 0;
}, $T = (e) => {
  e.bi_valid > 8 ? Fh(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
}, kX = (e, t, n, r) => {
  $T(e), Fh(e, n), Fh(e, ~n), e.pending_buf.set(e.window.subarray(t, t + n), e.pending), e.pending += n;
}, zy = (e, t, n, r) => {
  const i = t * 2, a = n * 2;
  return e[i] < e[a] || e[i] === e[a] && r[t] <= r[n];
}, S6 = (e, t, n) => {
  const r = e.heap[n];
  let i = n << 1;
  for (; i <= e.heap_len && (i < e.heap_len && zy(t, e.heap[i + 1], e.heap[i], e.depth) && i++, !zy(t, r, e.heap[i], e.depth)); )
    e.heap[n] = e.heap[i], n = i, i <<= 1;
  e.heap[n] = r;
}, By = (e, t, n) => {
  let r, i, a = 0, l, s;
  if (e.last_lit !== 0)
    do
      r = e.pending_buf[e.d_buf + a * 2] << 8 | e.pending_buf[e.d_buf + a * 2 + 1], i = e.pending_buf[e.l_buf + a], a++, r === 0 ? dl(e, i, t) : (l = $h[i], dl(e, l + Rf + 1, t), s = B4[l], s !== 0 && (i -= a8[l], si(e, i, s)), r--, l = LT(r), dl(e, l, n), s = rp[l], s !== 0 && (r -= om[l], si(e, r, s)));
    while (a < e.last_lit);
  dl(e, i8, t);
}, H4 = (e, t) => {
  const n = t.dyn_tree, r = t.stat_desc.static_tree, i = t.stat_desc.has_stree, a = t.stat_desc.elems;
  let l, s, c = -1, d;
  for (e.heap_len = 0, e.heap_max = kT, l = 0; l < a; l++)
    n[l * 2] !== 0 ? (e.heap[++e.heap_len] = c = l, e.depth[l] = 0) : n[l * 2 + 1] = 0;
  for (; e.heap_len < 2; )
    d = e.heap[++e.heap_len] = c < 2 ? ++c : 0, n[d * 2] = 1, e.depth[d] = 0, e.opt_len--, i && (e.static_len -= r[d * 2 + 1]);
  for (t.max_code = c, l = e.heap_len >> 1; l >= 1; l--)
    S6(e, n, l);
  d = a;
  do
    l = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[
      1
      /*SMALLEST*/
    ] = e.heap[e.heap_len--], S6(
      e,
      n,
      1
      /*SMALLEST*/
    ), s = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[--e.heap_max] = l, e.heap[--e.heap_max] = s, n[d * 2] = n[l * 2] + n[s * 2], e.depth[d] = (e.depth[l] >= e.depth[s] ? e.depth[l] : e.depth[s]) + 1, n[l * 2 + 1] = n[s * 2 + 1] = d, e.heap[
      1
      /*SMALLEST*/
    ] = d++, S6(
      e,
      n,
      1
      /*SMALLEST*/
    );
  while (e.heap_len >= 2);
  e.heap[--e.heap_max] = e.heap[
    1
    /*SMALLEST*/
  ], SX(e, t), PT(n, c, e.bl_count);
}, Hy = (e, t, n) => {
  let r, i = -1, a, l = t[0 * 2 + 1], s = 0, c = 7, d = 4;
  for (l === 0 && (c = 138, d = 3), t[(n + 1) * 2 + 1] = 65535, r = 0; r <= n; r++)
    a = l, l = t[(r + 1) * 2 + 1], !(++s < c && a === l) && (s < d ? e.bl_tree[a * 2] += s : a !== 0 ? (a !== i && e.bl_tree[a * 2]++, e.bl_tree[CT * 2]++) : s <= 10 ? e.bl_tree[MT * 2]++ : e.bl_tree[TT * 2]++, s = 0, i = a, l === 0 ? (c = 138, d = 3) : a === l ? (c = 6, d = 3) : (c = 7, d = 4));
}, Wy = (e, t, n) => {
  let r, i = -1, a, l = t[0 * 2 + 1], s = 0, c = 7, d = 4;
  for (l === 0 && (c = 138, d = 3), r = 0; r <= n; r++)
    if (a = l, l = t[(r + 1) * 2 + 1], !(++s < c && a === l)) {
      if (s < d)
        do
          dl(e, a, e.bl_tree);
        while (--s !== 0);
      else a !== 0 ? (a !== i && (dl(e, a, e.bl_tree), s--), dl(e, CT, e.bl_tree), si(e, s - 3, 2)) : s <= 10 ? (dl(e, MT, e.bl_tree), si(e, s - 3, 3)) : (dl(e, TT, e.bl_tree), si(e, s - 11, 7));
      s = 0, i = a, l === 0 ? (c = 138, d = 3) : a === l ? (c = 6, d = 3) : (c = 7, d = 4);
    }
}, CX = (e) => {
  let t;
  for (Hy(e, e.dyn_ltree, e.l_desc.max_code), Hy(e, e.dyn_dtree, e.d_desc.max_code), H4(e, e.bl_desc), t = r8 - 1; t >= 3 && e.bl_tree[IT[t] * 2 + 1] === 0; t--)
    ;
  return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
}, MX = (e, t, n, r) => {
  let i;
  for (si(e, t - 257, 5), si(e, n - 1, 5), si(e, r - 4, 4), i = 0; i < r; i++)
    si(e, e.bl_tree[IT[i] * 2 + 1], 3);
  Wy(e, e.dyn_ltree, t - 1), Wy(e, e.dyn_dtree, n - 1);
}, TX = (e) => {
  let t = 4093624447, n;
  for (n = 0; n <= 31; n++, t >>>= 1)
    if (t & 1 && e.dyn_ltree[n * 2] !== 0)
      return $y;
  if (e.dyn_ltree[9 * 2] !== 0 || e.dyn_ltree[10 * 2] !== 0 || e.dyn_ltree[13 * 2] !== 0)
    return Fy;
  for (n = 32; n < Rf; n++)
    if (e.dyn_ltree[n * 2] !== 0)
      return Fy;
  return $y;
};
let Xy = !1;
const IX = (e) => {
  Xy || (_X(), Xy = !0), e.l_desc = new E6(e.dyn_ltree, AT), e.d_desc = new E6(e.dyn_dtree, NT), e.bl_desc = new E6(e.bl_tree, DT), e.bi_buf = 0, e.bi_valid = 0, OT(e);
}, FT = (e, t, n, r) => {
  si(e, (gX << 1) + (r ? 1 : 0), 3), kX(e, t, n);
}, AX = (e) => {
  si(e, _T << 1, 3), dl(e, i8, ql), EX(e);
}, NX = (e, t, n, r) => {
  let i, a, l = 0;
  e.level > 0 ? (e.strm.data_type === mX && (e.strm.data_type = TX(e)), H4(e, e.l_desc), H4(e, e.d_desc), l = CX(e), i = e.opt_len + 3 + 7 >>> 3, a = e.static_len + 3 + 7 >>> 3, a <= i && (i = a)) : i = a = n + 5, n + 4 <= i && t !== -1 ? FT(e, t, n, r) : e.strategy === pX || a === i ? (si(e, (_T << 1) + (r ? 1 : 0), 3), By(e, ql, dh)) : (si(e, (bX << 1) + (r ? 1 : 0), 3), MX(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, l + 1), By(e, e.dyn_ltree, e.dyn_dtree)), OT(e), r && $T(e);
}, DX = (e, t, n) => (e.pending_buf[e.d_buf + e.last_lit * 2] = t >>> 8 & 255, e.pending_buf[e.d_buf + e.last_lit * 2 + 1] = t & 255, e.pending_buf[e.l_buf + e.last_lit] = n & 255, e.last_lit++, t === 0 ? e.dyn_ltree[n * 2]++ : (e.matches++, t--, e.dyn_ltree[($h[n] + Rf + 1) * 2]++, e.dyn_dtree[LT(t) * 2]++), e.last_lit === e.lit_bufsize - 1);
var LX = IX, RX = FT, PX = NX, OX = DX, $X = AX, FX = {
  _tr_init: LX,
  _tr_stored_block: RX,
  _tr_flush_block: PX,
  _tr_tally: OX,
  _tr_align: $X
};
const zX = (e, t, n, r) => {
  let i = e & 65535 | 0, a = e >>> 16 & 65535 | 0, l = 0;
  for (; n !== 0; ) {
    l = n > 2e3 ? 2e3 : n, n -= l;
    do
      i = i + t[r++] | 0, a = a + i | 0;
    while (--l);
    i %= 65521, a %= 65521;
  }
  return i | a << 16 | 0;
};
var zh = zX;
const BX = () => {
  let e, t = [];
  for (var n = 0; n < 256; n++) {
    e = n;
    for (var r = 0; r < 8; r++)
      e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
    t[n] = e;
  }
  return t;
}, HX = new Uint32Array(BX()), WX = (e, t, n, r) => {
  const i = HX, a = r + n;
  e ^= -1;
  for (let l = r; l < a; l++)
    e = e >>> 8 ^ i[(e ^ t[l]) & 255];
  return e ^ -1;
};
var gr = WX, Fc = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, Hg = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init: XX, _tr_stored_block: VX, _tr_flush_block: GX, _tr_tally: uo, _tr_align: jX } = FX, {
  Z_NO_FLUSH: sd,
  Z_PARTIAL_FLUSH: KX,
  Z_FULL_FLUSH: YX,
  Z_FINISH: ho,
  Z_BLOCK: Vy,
  Z_OK: ul,
  Z_STREAM_END: Gy,
  Z_STREAM_ERROR: Gi,
  Z_DATA_ERROR: qX,
  Z_BUF_ERROR: _6,
  Z_DEFAULT_COMPRESSION: ZX,
  Z_FILTERED: JX,
  Z_HUFFMAN_ONLY: x1,
  Z_RLE: QX,
  Z_FIXED: eV,
  Z_DEFAULT_STRATEGY: tV,
  Z_UNKNOWN: nV,
  Z_DEFLATED: Wg
} = Hg, rV = 9, iV = 15, aV = 8, lV = 29, sV = 256, W4 = sV + 1 + lV, oV = 30, cV = 19, dV = 2 * W4 + 1, uV = 15, wt = 3, no = 258, Ta = no + wt + 1, hV = 32, Xg = 42, X4 = 69, ip = 73, ap = 91, lp = 103, uc = 113, Hu = 666, or = 1, Pf = 2, zc = 3, eu = 4, fV = 3, ro = (e, t) => (e.msg = Fc[t], t), jy = (e) => (e << 1) - (e > 4 ? 9 : 0), Js = (e) => {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
};
let pV = (e, t, n) => (t << e.hash_shift ^ n) & e.hash_mask, fo = pV;
const Xs = (e) => {
  const t = e.state;
  let n = t.pending;
  n > e.avail_out && (n = e.avail_out), n !== 0 && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + n), e.next_out), e.next_out += n, t.pending_out += n, e.total_out += n, e.avail_out -= n, t.pending -= n, t.pending === 0 && (t.pending_out = 0));
}, Mr = (e, t) => {
  GX(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, Xs(e.strm);
}, Nt = (e, t) => {
  e.pending_buf[e.pending++] = t;
}, mu = (e, t) => {
  e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = t & 255;
}, mV = (e, t, n, r) => {
  let i = e.avail_in;
  return i > r && (i = r), i === 0 ? 0 : (e.avail_in -= i, t.set(e.input.subarray(e.next_in, e.next_in + i), n), e.state.wrap === 1 ? e.adler = zh(e.adler, t, i, n) : e.state.wrap === 2 && (e.adler = gr(e.adler, t, i, n)), e.next_in += i, e.total_in += i, i);
}, zT = (e, t) => {
  let n = e.max_chain_length, r = e.strstart, i, a, l = e.prev_length, s = e.nice_match;
  const c = e.strstart > e.w_size - Ta ? e.strstart - (e.w_size - Ta) : 0, d = e.window, o = e.w_mask, u = e.prev, h = e.strstart + no;
  let f = d[r + l - 1], p = d[r + l];
  e.prev_length >= e.good_match && (n >>= 2), s > e.lookahead && (s = e.lookahead);
  do
    if (i = t, !(d[i + l] !== p || d[i + l - 1] !== f || d[i] !== d[r] || d[++i] !== d[r + 1])) {
      r += 2, i++;
      do
        ;
      while (d[++r] === d[++i] && d[++r] === d[++i] && d[++r] === d[++i] && d[++r] === d[++i] && d[++r] === d[++i] && d[++r] === d[++i] && d[++r] === d[++i] && d[++r] === d[++i] && r < h);
      if (a = no - (h - r), r = h - no, a > l) {
        if (e.match_start = t, l = a, a >= s)
          break;
        f = d[r + l - 1], p = d[r + l];
      }
    }
  while ((t = u[t & o]) > c && --n !== 0);
  return l <= e.lookahead ? l : e.lookahead;
}, Bc = (e) => {
  const t = e.w_size;
  let n, r, i, a, l;
  do {
    if (a = e.window_size - e.lookahead - e.strstart, e.strstart >= t + (t - Ta)) {
      e.window.set(e.window.subarray(t, t + t), 0), e.match_start -= t, e.strstart -= t, e.block_start -= t, r = e.hash_size, n = r;
      do
        i = e.head[--n], e.head[n] = i >= t ? i - t : 0;
      while (--r);
      r = t, n = r;
      do
        i = e.prev[--n], e.prev[n] = i >= t ? i - t : 0;
      while (--r);
      a += t;
    }
    if (e.strm.avail_in === 0)
      break;
    if (r = mV(e.strm, e.window, e.strstart + e.lookahead, a), e.lookahead += r, e.lookahead + e.insert >= wt)
      for (l = e.strstart - e.insert, e.ins_h = e.window[l], e.ins_h = fo(e, e.ins_h, e.window[l + 1]); e.insert && (e.ins_h = fo(e, e.ins_h, e.window[l + wt - 1]), e.prev[l & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = l, l++, e.insert--, !(e.lookahead + e.insert < wt)); )
        ;
  } while (e.lookahead < Ta && e.strm.avail_in !== 0);
}, gV = (e, t) => {
  let n = 65535;
  for (n > e.pending_buf_size - 5 && (n = e.pending_buf_size - 5); ; ) {
    if (e.lookahead <= 1) {
      if (Bc(e), e.lookahead === 0 && t === sd)
        return or;
      if (e.lookahead === 0)
        break;
    }
    e.strstart += e.lookahead, e.lookahead = 0;
    const r = e.block_start + n;
    if ((e.strstart === 0 || e.strstart >= r) && (e.lookahead = e.strstart - r, e.strstart = r, Mr(e, !1), e.strm.avail_out === 0) || e.strstart - e.block_start >= e.w_size - Ta && (Mr(e, !1), e.strm.avail_out === 0))
      return or;
  }
  return e.insert = 0, t === ho ? (Mr(e, !0), e.strm.avail_out === 0 ? zc : eu) : (e.strstart > e.block_start && (Mr(e, !1), e.strm.avail_out === 0), or);
}, k6 = (e, t) => {
  let n, r;
  for (; ; ) {
    if (e.lookahead < Ta) {
      if (Bc(e), e.lookahead < Ta && t === sd)
        return or;
      if (e.lookahead === 0)
        break;
    }
    if (n = 0, e.lookahead >= wt && (e.ins_h = fo(e, e.ins_h, e.window[e.strstart + wt - 1]), n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), n !== 0 && e.strstart - n <= e.w_size - Ta && (e.match_length = zT(e, n)), e.match_length >= wt)
      if (r = uo(e, e.strstart - e.match_start, e.match_length - wt), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= wt) {
        e.match_length--;
        do
          e.strstart++, e.ins_h = fo(e, e.ins_h, e.window[e.strstart + wt - 1]), n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
        while (--e.match_length !== 0);
        e.strstart++;
      } else
        e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = fo(e, e.ins_h, e.window[e.strstart + 1]);
    else
      r = uo(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
    if (r && (Mr(e, !1), e.strm.avail_out === 0))
      return or;
  }
  return e.insert = e.strstart < wt - 1 ? e.strstart : wt - 1, t === ho ? (Mr(e, !0), e.strm.avail_out === 0 ? zc : eu) : e.last_lit && (Mr(e, !1), e.strm.avail_out === 0) ? or : Pf;
}, gd = (e, t) => {
  let n, r, i;
  for (; ; ) {
    if (e.lookahead < Ta) {
      if (Bc(e), e.lookahead < Ta && t === sd)
        return or;
      if (e.lookahead === 0)
        break;
    }
    if (n = 0, e.lookahead >= wt && (e.ins_h = fo(e, e.ins_h, e.window[e.strstart + wt - 1]), n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = wt - 1, n !== 0 && e.prev_length < e.max_lazy_match && e.strstart - n <= e.w_size - Ta && (e.match_length = zT(e, n), e.match_length <= 5 && (e.strategy === JX || e.match_length === wt && e.strstart - e.match_start > 4096) && (e.match_length = wt - 1)), e.prev_length >= wt && e.match_length <= e.prev_length) {
      i = e.strstart + e.lookahead - wt, r = uo(e, e.strstart - 1 - e.prev_match, e.prev_length - wt), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
      do
        ++e.strstart <= i && (e.ins_h = fo(e, e.ins_h, e.window[e.strstart + wt - 1]), n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
      while (--e.prev_length !== 0);
      if (e.match_available = 0, e.match_length = wt - 1, e.strstart++, r && (Mr(e, !1), e.strm.avail_out === 0))
        return or;
    } else if (e.match_available) {
      if (r = uo(e, 0, e.window[e.strstart - 1]), r && Mr(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0)
        return or;
    } else
      e.match_available = 1, e.strstart++, e.lookahead--;
  }
  return e.match_available && (r = uo(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < wt - 1 ? e.strstart : wt - 1, t === ho ? (Mr(e, !0), e.strm.avail_out === 0 ? zc : eu) : e.last_lit && (Mr(e, !1), e.strm.avail_out === 0) ? or : Pf;
}, bV = (e, t) => {
  let n, r, i, a;
  const l = e.window;
  for (; ; ) {
    if (e.lookahead <= no) {
      if (Bc(e), e.lookahead <= no && t === sd)
        return or;
      if (e.lookahead === 0)
        break;
    }
    if (e.match_length = 0, e.lookahead >= wt && e.strstart > 0 && (i = e.strstart - 1, r = l[i], r === l[++i] && r === l[++i] && r === l[++i])) {
      a = e.strstart + no;
      do
        ;
      while (r === l[++i] && r === l[++i] && r === l[++i] && r === l[++i] && r === l[++i] && r === l[++i] && r === l[++i] && r === l[++i] && i < a);
      e.match_length = no - (a - i), e.match_length > e.lookahead && (e.match_length = e.lookahead);
    }
    if (e.match_length >= wt ? (n = uo(e, 1, e.match_length - wt), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (n = uo(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), n && (Mr(e, !1), e.strm.avail_out === 0))
      return or;
  }
  return e.insert = 0, t === ho ? (Mr(e, !0), e.strm.avail_out === 0 ? zc : eu) : e.last_lit && (Mr(e, !1), e.strm.avail_out === 0) ? or : Pf;
}, UV = (e, t) => {
  let n;
  for (; ; ) {
    if (e.lookahead === 0 && (Bc(e), e.lookahead === 0)) {
      if (t === sd)
        return or;
      break;
    }
    if (e.match_length = 0, n = uo(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, n && (Mr(e, !1), e.strm.avail_out === 0))
      return or;
  }
  return e.insert = 0, t === ho ? (Mr(e, !0), e.strm.avail_out === 0 ? zc : eu) : e.last_lit && (Mr(e, !1), e.strm.avail_out === 0) ? or : Pf;
};
function Va(e, t, n, r, i) {
  this.good_length = e, this.max_lazy = t, this.nice_length = n, this.max_chain = r, this.func = i;
}
const Wu = [
  /*      good lazy nice chain */
  new Va(0, 0, 0, 0, gV),
  /* 0 store only */
  new Va(4, 4, 8, 4, k6),
  /* 1 max speed, no lazy matches */
  new Va(4, 5, 16, 8, k6),
  /* 2 */
  new Va(4, 6, 32, 32, k6),
  /* 3 */
  new Va(4, 4, 16, 16, gd),
  /* 4 lazy matches */
  new Va(8, 16, 32, 32, gd),
  /* 5 */
  new Va(8, 16, 128, 128, gd),
  /* 6 */
  new Va(8, 32, 128, 256, gd),
  /* 7 */
  new Va(32, 128, 258, 1024, gd),
  /* 8 */
  new Va(32, 258, 258, 4096, gd)
  /* 9 max compression */
], vV = (e) => {
  e.window_size = 2 * e.w_size, Js(e.head), e.max_lazy_match = Wu[e.level].max_lazy, e.good_match = Wu[e.level].good_length, e.nice_match = Wu[e.level].nice_length, e.max_chain_length = Wu[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = wt - 1, e.match_available = 0, e.ins_h = 0;
};
function yV() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Wg, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(dV * 2), this.dyn_dtree = new Uint16Array((2 * oV + 1) * 2), this.bl_tree = new Uint16Array((2 * cV + 1) * 2), Js(this.dyn_ltree), Js(this.dyn_dtree), Js(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(uV + 1), this.heap = new Uint16Array(2 * W4 + 1), Js(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * W4 + 1), Js(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const BT = (e) => {
  if (!e || !e.state)
    return ro(e, Gi);
  e.total_in = e.total_out = 0, e.data_type = nV;
  const t = e.state;
  return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = t.wrap ? Xg : uc, e.adler = t.wrap === 2 ? 0 : 1, t.last_flush = sd, XX(t), ul;
}, HT = (e) => {
  const t = BT(e);
  return t === ul && vV(e.state), t;
}, wV = (e, t) => !e || !e.state || e.state.wrap !== 2 ? Gi : (e.state.gzhead = t, ul), WT = (e, t, n, r, i, a) => {
  if (!e)
    return Gi;
  let l = 1;
  if (t === ZX && (t = 6), r < 0 ? (l = 0, r = -r) : r > 15 && (l = 2, r -= 16), i < 1 || i > rV || n !== Wg || r < 8 || r > 15 || t < 0 || t > 9 || a < 0 || a > eV)
    return ro(e, Gi);
  r === 8 && (r = 9);
  const s = new yV();
  return e.state = s, s.strm = e, s.wrap = l, s.gzhead = null, s.w_bits = r, s.w_size = 1 << s.w_bits, s.w_mask = s.w_size - 1, s.hash_bits = i + 7, s.hash_size = 1 << s.hash_bits, s.hash_mask = s.hash_size - 1, s.hash_shift = ~~((s.hash_bits + wt - 1) / wt), s.window = new Uint8Array(s.w_size * 2), s.head = new Uint16Array(s.hash_size), s.prev = new Uint16Array(s.w_size), s.lit_bufsize = 1 << i + 6, s.pending_buf_size = s.lit_bufsize * 4, s.pending_buf = new Uint8Array(s.pending_buf_size), s.d_buf = 1 * s.lit_bufsize, s.l_buf = 3 * s.lit_bufsize, s.level = t, s.strategy = a, s.method = n, HT(e);
}, xV = (e, t) => WT(e, t, Wg, iV, aV, tV), EV = (e, t) => {
  let n, r;
  if (!e || !e.state || t > Vy || t < 0)
    return e ? ro(e, Gi) : Gi;
  const i = e.state;
  if (!e.output || !e.input && e.avail_in !== 0 || i.status === Hu && t !== ho)
    return ro(e, e.avail_out === 0 ? _6 : Gi);
  i.strm = e;
  const a = i.last_flush;
  if (i.last_flush = t, i.status === Xg)
    if (i.wrap === 2)
      e.adler = 0, Nt(i, 31), Nt(i, 139), Nt(i, 8), i.gzhead ? (Nt(
        i,
        (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)
      ), Nt(i, i.gzhead.time & 255), Nt(i, i.gzhead.time >> 8 & 255), Nt(i, i.gzhead.time >> 16 & 255), Nt(i, i.gzhead.time >> 24 & 255), Nt(i, i.level === 9 ? 2 : i.strategy >= x1 || i.level < 2 ? 4 : 0), Nt(i, i.gzhead.os & 255), i.gzhead.extra && i.gzhead.extra.length && (Nt(i, i.gzhead.extra.length & 255), Nt(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (e.adler = gr(e.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = X4) : (Nt(i, 0), Nt(i, 0), Nt(i, 0), Nt(i, 0), Nt(i, 0), Nt(i, i.level === 9 ? 2 : i.strategy >= x1 || i.level < 2 ? 4 : 0), Nt(i, fV), i.status = uc);
    else {
      let l = Wg + (i.w_bits - 8 << 4) << 8, s = -1;
      i.strategy >= x1 || i.level < 2 ? s = 0 : i.level < 6 ? s = 1 : i.level === 6 ? s = 2 : s = 3, l |= s << 6, i.strstart !== 0 && (l |= hV), l += 31 - l % 31, i.status = uc, mu(i, l), i.strstart !== 0 && (mu(i, e.adler >>> 16), mu(i, e.adler & 65535)), e.adler = 1;
    }
  if (i.status === X4)
    if (i.gzhead.extra) {
      for (n = i.pending; i.gzindex < (i.gzhead.extra.length & 65535) && !(i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > n && (e.adler = gr(e.adler, i.pending_buf, i.pending - n, n)), Xs(e), n = i.pending, i.pending === i.pending_buf_size)); )
        Nt(i, i.gzhead.extra[i.gzindex] & 255), i.gzindex++;
      i.gzhead.hcrc && i.pending > n && (e.adler = gr(e.adler, i.pending_buf, i.pending - n, n)), i.gzindex === i.gzhead.extra.length && (i.gzindex = 0, i.status = ip);
    } else
      i.status = ip;
  if (i.status === ip)
    if (i.gzhead.name) {
      n = i.pending;
      do {
        if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > n && (e.adler = gr(e.adler, i.pending_buf, i.pending - n, n)), Xs(e), n = i.pending, i.pending === i.pending_buf_size)) {
          r = 1;
          break;
        }
        i.gzindex < i.gzhead.name.length ? r = i.gzhead.name.charCodeAt(i.gzindex++) & 255 : r = 0, Nt(i, r);
      } while (r !== 0);
      i.gzhead.hcrc && i.pending > n && (e.adler = gr(e.adler, i.pending_buf, i.pending - n, n)), r === 0 && (i.gzindex = 0, i.status = ap);
    } else
      i.status = ap;
  if (i.status === ap)
    if (i.gzhead.comment) {
      n = i.pending;
      do {
        if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > n && (e.adler = gr(e.adler, i.pending_buf, i.pending - n, n)), Xs(e), n = i.pending, i.pending === i.pending_buf_size)) {
          r = 1;
          break;
        }
        i.gzindex < i.gzhead.comment.length ? r = i.gzhead.comment.charCodeAt(i.gzindex++) & 255 : r = 0, Nt(i, r);
      } while (r !== 0);
      i.gzhead.hcrc && i.pending > n && (e.adler = gr(e.adler, i.pending_buf, i.pending - n, n)), r === 0 && (i.status = lp);
    } else
      i.status = lp;
  if (i.status === lp && (i.gzhead.hcrc ? (i.pending + 2 > i.pending_buf_size && Xs(e), i.pending + 2 <= i.pending_buf_size && (Nt(i, e.adler & 255), Nt(i, e.adler >> 8 & 255), e.adler = 0, i.status = uc)) : i.status = uc), i.pending !== 0) {
    if (Xs(e), e.avail_out === 0)
      return i.last_flush = -1, ul;
  } else if (e.avail_in === 0 && jy(t) <= jy(a) && t !== ho)
    return ro(e, _6);
  if (i.status === Hu && e.avail_in !== 0)
    return ro(e, _6);
  if (e.avail_in !== 0 || i.lookahead !== 0 || t !== sd && i.status !== Hu) {
    let l = i.strategy === x1 ? UV(i, t) : i.strategy === QX ? bV(i, t) : Wu[i.level].func(i, t);
    if ((l === zc || l === eu) && (i.status = Hu), l === or || l === zc)
      return e.avail_out === 0 && (i.last_flush = -1), ul;
    if (l === Pf && (t === KX ? jX(i) : t !== Vy && (VX(i, 0, 0, !1), t === YX && (Js(i.head), i.lookahead === 0 && (i.strstart = 0, i.block_start = 0, i.insert = 0))), Xs(e), e.avail_out === 0))
      return i.last_flush = -1, ul;
  }
  return t !== ho ? ul : i.wrap <= 0 ? Gy : (i.wrap === 2 ? (Nt(i, e.adler & 255), Nt(i, e.adler >> 8 & 255), Nt(i, e.adler >> 16 & 255), Nt(i, e.adler >> 24 & 255), Nt(i, e.total_in & 255), Nt(i, e.total_in >> 8 & 255), Nt(i, e.total_in >> 16 & 255), Nt(i, e.total_in >> 24 & 255)) : (mu(i, e.adler >>> 16), mu(i, e.adler & 65535)), Xs(e), i.wrap > 0 && (i.wrap = -i.wrap), i.pending !== 0 ? ul : Gy);
}, SV = (e) => {
  if (!e || !e.state)
    return Gi;
  const t = e.state.status;
  return t !== Xg && t !== X4 && t !== ip && t !== ap && t !== lp && t !== uc && t !== Hu ? ro(e, Gi) : (e.state = null, t === uc ? ro(e, qX) : ul);
}, _V = (e, t) => {
  let n = t.length;
  if (!e || !e.state)
    return Gi;
  const r = e.state, i = r.wrap;
  if (i === 2 || i === 1 && r.status !== Xg || r.lookahead)
    return Gi;
  if (i === 1 && (e.adler = zh(e.adler, t, n, 0)), r.wrap = 0, n >= r.w_size) {
    i === 0 && (Js(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0);
    let c = new Uint8Array(r.w_size);
    c.set(t.subarray(n - r.w_size, n), 0), t = c, n = r.w_size;
  }
  const a = e.avail_in, l = e.next_in, s = e.input;
  for (e.avail_in = n, e.next_in = 0, e.input = t, Bc(r); r.lookahead >= wt; ) {
    let c = r.strstart, d = r.lookahead - (wt - 1);
    do
      r.ins_h = fo(r, r.ins_h, r.window[c + wt - 1]), r.prev[c & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = c, c++;
    while (--d);
    r.strstart = c, r.lookahead = wt - 1, Bc(r);
  }
  return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = wt - 1, r.match_available = 0, e.next_in = l, e.input = s, e.avail_in = a, r.wrap = i, ul;
};
var kV = xV, CV = WT, MV = HT, TV = BT, IV = wV, AV = EV, NV = SV, DV = _V, LV = "pako deflate (from Nodeca project)", uh = {
  deflateInit: kV,
  deflateInit2: CV,
  deflateReset: MV,
  deflateResetKeep: TV,
  deflateSetHeader: IV,
  deflate: AV,
  deflateEnd: NV,
  deflateSetDictionary: DV,
  deflateInfo: LV
};
const RV = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
var PV = function(e) {
  const t = Array.prototype.slice.call(arguments, 1);
  for (; t.length; ) {
    const n = t.shift();
    if (n) {
      if (typeof n != "object")
        throw new TypeError(n + "must be non-object");
      for (const r in n)
        RV(n, r) && (e[r] = n[r]);
    }
  }
  return e;
}, OV = (e) => {
  let t = 0;
  for (let r = 0, i = e.length; r < i; r++)
    t += e[r].length;
  const n = new Uint8Array(t);
  for (let r = 0, i = 0, a = e.length; r < a; r++) {
    let l = e[r];
    n.set(l, i), i += l.length;
  }
  return n;
}, Vg = {
  assign: PV,
  flattenChunks: OV
};
let XT = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  XT = !1;
}
const Bh = new Uint8Array(256);
for (let e = 0; e < 256; e++)
  Bh[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
Bh[254] = Bh[254] = 1;
var $V = (e) => {
  let t, n, r, i, a, l = e.length, s = 0;
  for (i = 0; i < l; i++)
    n = e.charCodeAt(i), (n & 64512) === 55296 && i + 1 < l && (r = e.charCodeAt(i + 1), (r & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (r - 56320), i++)), s += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
  for (t = new Uint8Array(s), a = 0, i = 0; a < s; i++)
    n = e.charCodeAt(i), (n & 64512) === 55296 && i + 1 < l && (r = e.charCodeAt(i + 1), (r & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (r - 56320), i++)), n < 128 ? t[a++] = n : n < 2048 ? (t[a++] = 192 | n >>> 6, t[a++] = 128 | n & 63) : n < 65536 ? (t[a++] = 224 | n >>> 12, t[a++] = 128 | n >>> 6 & 63, t[a++] = 128 | n & 63) : (t[a++] = 240 | n >>> 18, t[a++] = 128 | n >>> 12 & 63, t[a++] = 128 | n >>> 6 & 63, t[a++] = 128 | n & 63);
  return t;
};
const FV = (e, t) => {
  if (t < 65534 && e.subarray && XT)
    return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
  let n = "";
  for (let r = 0; r < t; r++)
    n += String.fromCharCode(e[r]);
  return n;
};
var zV = (e, t) => {
  let n, r;
  const i = t || e.length, a = new Array(i * 2);
  for (r = 0, n = 0; n < i; ) {
    let l = e[n++];
    if (l < 128) {
      a[r++] = l;
      continue;
    }
    let s = Bh[l];
    if (s > 4) {
      a[r++] = 65533, n += s - 1;
      continue;
    }
    for (l &= s === 2 ? 31 : s === 3 ? 15 : 7; s > 1 && n < i; )
      l = l << 6 | e[n++] & 63, s--;
    if (s > 1) {
      a[r++] = 65533;
      continue;
    }
    l < 65536 ? a[r++] = l : (l -= 65536, a[r++] = 55296 | l >> 10 & 1023, a[r++] = 56320 | l & 1023);
  }
  return FV(a, r);
}, BV = (e, t) => {
  t = t || e.length, t > e.length && (t = e.length);
  let n = t - 1;
  for (; n >= 0 && (e[n] & 192) === 128; )
    n--;
  return n < 0 || n === 0 ? t : n + Bh[e[n]] > t ? n : t;
}, Hh = {
  string2buf: $V,
  buf2string: zV,
  utf8border: BV
};
function HV() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var VT = HV;
const GT = Object.prototype.toString, {
  Z_NO_FLUSH: WV,
  Z_SYNC_FLUSH: XV,
  Z_FULL_FLUSH: VV,
  Z_FINISH: GV,
  Z_OK: cm,
  Z_STREAM_END: jV,
  Z_DEFAULT_COMPRESSION: KV,
  Z_DEFAULT_STRATEGY: YV,
  Z_DEFLATED: qV
} = Hg;
function Gg(e) {
  this.options = Vg.assign({
    level: KV,
    method: qV,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: YV
  }, e || {});
  let t = this.options;
  t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new VT(), this.strm.avail_out = 0;
  let n = uh.deflateInit2(
    this.strm,
    t.level,
    t.method,
    t.windowBits,
    t.memLevel,
    t.strategy
  );
  if (n !== cm)
    throw new Error(Fc[n]);
  if (t.header && uh.deflateSetHeader(this.strm, t.header), t.dictionary) {
    let r;
    if (typeof t.dictionary == "string" ? r = Hh.string2buf(t.dictionary) : GT.call(t.dictionary) === "[object ArrayBuffer]" ? r = new Uint8Array(t.dictionary) : r = t.dictionary, n = uh.deflateSetDictionary(this.strm, r), n !== cm)
      throw new Error(Fc[n]);
    this._dict_set = !0;
  }
}
Gg.prototype.push = function(e, t) {
  const n = this.strm, r = this.options.chunkSize;
  let i, a;
  if (this.ended)
    return !1;
  for (t === ~~t ? a = t : a = t === !0 ? GV : WV, typeof e == "string" ? n.input = Hh.string2buf(e) : GT.call(e) === "[object ArrayBuffer]" ? n.input = new Uint8Array(e) : n.input = e, n.next_in = 0, n.avail_in = n.input.length; ; ) {
    if (n.avail_out === 0 && (n.output = new Uint8Array(r), n.next_out = 0, n.avail_out = r), (a === XV || a === VV) && n.avail_out <= 6) {
      this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
      continue;
    }
    if (i = uh.deflate(n, a), i === jV)
      return n.next_out > 0 && this.onData(n.output.subarray(0, n.next_out)), i = uh.deflateEnd(this.strm), this.onEnd(i), this.ended = !0, i === cm;
    if (n.avail_out === 0) {
      this.onData(n.output);
      continue;
    }
    if (a > 0 && n.next_out > 0) {
      this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
      continue;
    }
    if (n.avail_in === 0) break;
  }
  return !0;
};
Gg.prototype.onData = function(e) {
  this.chunks.push(e);
};
Gg.prototype.onEnd = function(e) {
  e === cm && (this.result = Vg.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function ZV(e, t) {
  const n = new Gg(t);
  if (n.push(e, !0), n.err)
    throw n.msg || Fc[n.err];
  return n.result;
}
var JV = ZV, QV = {
  deflate: JV
};
const E1 = 30, eG = 12;
var tG = function(t, n) {
  let r, i, a, l, s, c, d, o, u, h, f, p, g, b, v, U, y, w, x, E, S, _, k, M;
  const A = t.state;
  r = t.next_in, k = t.input, i = r + (t.avail_in - 5), a = t.next_out, M = t.output, l = a - (n - t.avail_out), s = a + (t.avail_out - 257), c = A.dmax, d = A.wsize, o = A.whave, u = A.wnext, h = A.window, f = A.hold, p = A.bits, g = A.lencode, b = A.distcode, v = (1 << A.lenbits) - 1, U = (1 << A.distbits) - 1;
  e:
    do {
      p < 15 && (f += k[r++] << p, p += 8, f += k[r++] << p, p += 8), y = g[f & v];
      t:
        for (; ; ) {
          if (w = y >>> 24, f >>>= w, p -= w, w = y >>> 16 & 255, w === 0)
            M[a++] = y & 65535;
          else if (w & 16) {
            x = y & 65535, w &= 15, w && (p < w && (f += k[r++] << p, p += 8), x += f & (1 << w) - 1, f >>>= w, p -= w), p < 15 && (f += k[r++] << p, p += 8, f += k[r++] << p, p += 8), y = b[f & U];
            n:
              for (; ; ) {
                if (w = y >>> 24, f >>>= w, p -= w, w = y >>> 16 & 255, w & 16) {
                  if (E = y & 65535, w &= 15, p < w && (f += k[r++] << p, p += 8, p < w && (f += k[r++] << p, p += 8)), E += f & (1 << w) - 1, E > c) {
                    t.msg = "invalid distance too far back", A.mode = E1;
                    break e;
                  }
                  if (f >>>= w, p -= w, w = a - l, E > w) {
                    if (w = E - w, w > o && A.sane) {
                      t.msg = "invalid distance too far back", A.mode = E1;
                      break e;
                    }
                    if (S = 0, _ = h, u === 0) {
                      if (S += d - w, w < x) {
                        x -= w;
                        do
                          M[a++] = h[S++];
                        while (--w);
                        S = a - E, _ = M;
                      }
                    } else if (u < w) {
                      if (S += d + u - w, w -= u, w < x) {
                        x -= w;
                        do
                          M[a++] = h[S++];
                        while (--w);
                        if (S = 0, u < x) {
                          w = u, x -= w;
                          do
                            M[a++] = h[S++];
                          while (--w);
                          S = a - E, _ = M;
                        }
                      }
                    } else if (S += u - w, w < x) {
                      x -= w;
                      do
                        M[a++] = h[S++];
                      while (--w);
                      S = a - E, _ = M;
                    }
                    for (; x > 2; )
                      M[a++] = _[S++], M[a++] = _[S++], M[a++] = _[S++], x -= 3;
                    x && (M[a++] = _[S++], x > 1 && (M[a++] = _[S++]));
                  } else {
                    S = a - E;
                    do
                      M[a++] = M[S++], M[a++] = M[S++], M[a++] = M[S++], x -= 3;
                    while (x > 2);
                    x && (M[a++] = M[S++], x > 1 && (M[a++] = M[S++]));
                  }
                } else if (w & 64) {
                  t.msg = "invalid distance code", A.mode = E1;
                  break e;
                } else {
                  y = b[(y & 65535) + (f & (1 << w) - 1)];
                  continue n;
                }
                break;
              }
          } else if (w & 64)
            if (w & 32) {
              A.mode = eG;
              break e;
            } else {
              t.msg = "invalid literal/length code", A.mode = E1;
              break e;
            }
          else {
            y = g[(y & 65535) + (f & (1 << w) - 1)];
            continue t;
          }
          break;
        }
    } while (r < i && a < s);
  x = p >> 3, r -= x, p -= x << 3, f &= (1 << p) - 1, t.next_in = r, t.next_out = a, t.avail_in = r < i ? 5 + (i - r) : 5 - (r - i), t.avail_out = a < s ? 257 + (s - a) : 257 - (a - s), A.hold = f, A.bits = p;
};
const bd = 15, Ky = 852, Yy = 592, qy = 0, C6 = 1, Zy = 2, nG = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), rG = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), iG = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), aG = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), lG = (e, t, n, r, i, a, l, s) => {
  const c = s.bits;
  let d = 0, o = 0, u = 0, h = 0, f = 0, p = 0, g = 0, b = 0, v = 0, U = 0, y, w, x, E, S, _ = null, k = 0, M;
  const A = new Uint16Array(bd + 1), L = new Uint16Array(bd + 1);
  let R = null, z = 0, F, W, B;
  for (d = 0; d <= bd; d++)
    A[d] = 0;
  for (o = 0; o < r; o++)
    A[t[n + o]]++;
  for (f = c, h = bd; h >= 1 && A[h] === 0; h--)
    ;
  if (f > h && (f = h), h === 0)
    return i[a++] = 1 << 24 | 64 << 16 | 0, i[a++] = 1 << 24 | 64 << 16 | 0, s.bits = 1, 0;
  for (u = 1; u < h && A[u] === 0; u++)
    ;
  for (f < u && (f = u), b = 1, d = 1; d <= bd; d++)
    if (b <<= 1, b -= A[d], b < 0)
      return -1;
  if (b > 0 && (e === qy || h !== 1))
    return -1;
  for (L[1] = 0, d = 1; d < bd; d++)
    L[d + 1] = L[d] + A[d];
  for (o = 0; o < r; o++)
    t[n + o] !== 0 && (l[L[t[n + o]]++] = o);
  if (e === qy ? (_ = R = l, M = 19) : e === C6 ? (_ = nG, k -= 257, R = rG, z -= 257, M = 256) : (_ = iG, R = aG, M = -1), U = 0, o = 0, d = u, S = a, p = f, g = 0, x = -1, v = 1 << f, E = v - 1, e === C6 && v > Ky || e === Zy && v > Yy)
    return 1;
  for (; ; ) {
    F = d - g, l[o] < M ? (W = 0, B = l[o]) : l[o] > M ? (W = R[z + l[o]], B = _[k + l[o]]) : (W = 96, B = 0), y = 1 << d - g, w = 1 << p, u = w;
    do
      w -= y, i[S + (U >> g) + w] = F << 24 | W << 16 | B | 0;
    while (w !== 0);
    for (y = 1 << d - 1; U & y; )
      y >>= 1;
    if (y !== 0 ? (U &= y - 1, U += y) : U = 0, o++, --A[d] === 0) {
      if (d === h)
        break;
      d = t[n + l[o]];
    }
    if (d > f && (U & E) !== x) {
      for (g === 0 && (g = f), S += u, p = d - g, b = 1 << p; p + g < h && (b -= A[p + g], !(b <= 0)); )
        p++, b <<= 1;
      if (v += 1 << p, e === C6 && v > Ky || e === Zy && v > Yy)
        return 1;
      x = U & E, i[x] = f << 24 | p << 16 | S - a | 0;
    }
  }
  return U !== 0 && (i[S + U] = d - g << 24 | 64 << 16 | 0), s.bits = f, 0;
};
var hh = lG;
const sG = 0, jT = 1, KT = 2, {
  Z_FINISH: Jy,
  Z_BLOCK: oG,
  Z_TREES: S1,
  Z_OK: Hc,
  Z_STREAM_END: cG,
  Z_NEED_DICT: dG,
  Z_STREAM_ERROR: ea,
  Z_DATA_ERROR: YT,
  Z_MEM_ERROR: qT,
  Z_BUF_ERROR: uG,
  Z_DEFLATED: Qy
} = Hg, ZT = 1, ew = 2, tw = 3, nw = 4, rw = 5, iw = 6, aw = 7, lw = 8, sw = 9, ow = 10, dm = 11, zl = 12, M6 = 13, cw = 14, T6 = 15, dw = 16, uw = 17, hw = 18, fw = 19, _1 = 20, k1 = 21, pw = 22, mw = 23, gw = 24, bw = 25, Uw = 26, I6 = 27, vw = 28, yw = 29, mn = 30, JT = 31, hG = 32, fG = 852, pG = 592, mG = 15, gG = mG, ww = (e) => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((e & 65280) << 8) + ((e & 255) << 24);
function bG() {
  this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const QT = (e) => {
  if (!e || !e.state)
    return ea;
  const t = e.state;
  return e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = t.wrap & 1), t.mode = ZT, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(fG), t.distcode = t.distdyn = new Int32Array(pG), t.sane = 1, t.back = -1, Hc;
}, eI = (e) => {
  if (!e || !e.state)
    return ea;
  const t = e.state;
  return t.wsize = 0, t.whave = 0, t.wnext = 0, QT(e);
}, tI = (e, t) => {
  let n;
  if (!e || !e.state)
    return ea;
  const r = e.state;
  return t < 0 ? (n = 0, t = -t) : (n = (t >> 4) + 1, t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? ea : (r.window !== null && r.wbits !== t && (r.window = null), r.wrap = n, r.wbits = t, eI(e));
}, nI = (e, t) => {
  if (!e)
    return ea;
  const n = new bG();
  e.state = n, n.window = null;
  const r = tI(e, t);
  return r !== Hc && (e.state = null), r;
}, UG = (e) => nI(e, gG);
let xw = !0, A6, N6;
const vG = (e) => {
  if (xw) {
    A6 = new Int32Array(512), N6 = new Int32Array(32);
    let t = 0;
    for (; t < 144; )
      e.lens[t++] = 8;
    for (; t < 256; )
      e.lens[t++] = 9;
    for (; t < 280; )
      e.lens[t++] = 7;
    for (; t < 288; )
      e.lens[t++] = 8;
    for (hh(jT, e.lens, 0, 288, A6, 0, e.work, { bits: 9 }), t = 0; t < 32; )
      e.lens[t++] = 5;
    hh(KT, e.lens, 0, 32, N6, 0, e.work, { bits: 5 }), xw = !1;
  }
  e.lencode = A6, e.lenbits = 9, e.distcode = N6, e.distbits = 5;
}, rI = (e, t, n, r) => {
  let i;
  const a = e.state;
  return a.window === null && (a.wsize = 1 << a.wbits, a.wnext = 0, a.whave = 0, a.window = new Uint8Array(a.wsize)), r >= a.wsize ? (a.window.set(t.subarray(n - a.wsize, n), 0), a.wnext = 0, a.whave = a.wsize) : (i = a.wsize - a.wnext, i > r && (i = r), a.window.set(t.subarray(n - r, n - r + i), a.wnext), r -= i, r ? (a.window.set(t.subarray(n - r, n), 0), a.wnext = r, a.whave = a.wsize) : (a.wnext += i, a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += i))), 0;
}, yG = (e, t) => {
  let n, r, i, a, l, s, c, d, o, u, h, f, p, g, b = 0, v, U, y, w, x, E, S, _;
  const k = new Uint8Array(4);
  let M, A;
  const L = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (!e || !e.state || !e.output || !e.input && e.avail_in !== 0)
    return ea;
  n = e.state, n.mode === zl && (n.mode = M6), l = e.next_out, i = e.output, c = e.avail_out, a = e.next_in, r = e.input, s = e.avail_in, d = n.hold, o = n.bits, u = s, h = c, _ = Hc;
  e:
    for (; ; )
      switch (n.mode) {
        case ZT:
          if (n.wrap === 0) {
            n.mode = M6;
            break;
          }
          for (; o < 16; ) {
            if (s === 0)
              break e;
            s--, d += r[a++] << o, o += 8;
          }
          if (n.wrap & 2 && d === 35615) {
            n.check = 0, k[0] = d & 255, k[1] = d >>> 8 & 255, n.check = gr(n.check, k, 2, 0), d = 0, o = 0, n.mode = ew;
            break;
          }
          if (n.flags = 0, n.head && (n.head.done = !1), !(n.wrap & 1) || /* check if zlib header allowed */
          (((d & 255) << 8) + (d >> 8)) % 31) {
            e.msg = "incorrect header check", n.mode = mn;
            break;
          }
          if ((d & 15) !== Qy) {
            e.msg = "unknown compression method", n.mode = mn;
            break;
          }
          if (d >>>= 4, o -= 4, S = (d & 15) + 8, n.wbits === 0)
            n.wbits = S;
          else if (S > n.wbits) {
            e.msg = "invalid window size", n.mode = mn;
            break;
          }
          n.dmax = 1 << n.wbits, e.adler = n.check = 1, n.mode = d & 512 ? ow : zl, d = 0, o = 0;
          break;
        case ew:
          for (; o < 16; ) {
            if (s === 0)
              break e;
            s--, d += r[a++] << o, o += 8;
          }
          if (n.flags = d, (n.flags & 255) !== Qy) {
            e.msg = "unknown compression method", n.mode = mn;
            break;
          }
          if (n.flags & 57344) {
            e.msg = "unknown header flags set", n.mode = mn;
            break;
          }
          n.head && (n.head.text = d >> 8 & 1), n.flags & 512 && (k[0] = d & 255, k[1] = d >>> 8 & 255, n.check = gr(n.check, k, 2, 0)), d = 0, o = 0, n.mode = tw;
        case tw:
          for (; o < 32; ) {
            if (s === 0)
              break e;
            s--, d += r[a++] << o, o += 8;
          }
          n.head && (n.head.time = d), n.flags & 512 && (k[0] = d & 255, k[1] = d >>> 8 & 255, k[2] = d >>> 16 & 255, k[3] = d >>> 24 & 255, n.check = gr(n.check, k, 4, 0)), d = 0, o = 0, n.mode = nw;
        case nw:
          for (; o < 16; ) {
            if (s === 0)
              break e;
            s--, d += r[a++] << o, o += 8;
          }
          n.head && (n.head.xflags = d & 255, n.head.os = d >> 8), n.flags & 512 && (k[0] = d & 255, k[1] = d >>> 8 & 255, n.check = gr(n.check, k, 2, 0)), d = 0, o = 0, n.mode = rw;
        case rw:
          if (n.flags & 1024) {
            for (; o < 16; ) {
              if (s === 0)
                break e;
              s--, d += r[a++] << o, o += 8;
            }
            n.length = d, n.head && (n.head.extra_len = d), n.flags & 512 && (k[0] = d & 255, k[1] = d >>> 8 & 255, n.check = gr(n.check, k, 2, 0)), d = 0, o = 0;
          } else n.head && (n.head.extra = null);
          n.mode = iw;
        case iw:
          if (n.flags & 1024 && (f = n.length, f > s && (f = s), f && (n.head && (S = n.head.extra_len - n.length, n.head.extra || (n.head.extra = new Uint8Array(n.head.extra_len)), n.head.extra.set(
            r.subarray(
              a,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              a + f
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            S
          )), n.flags & 512 && (n.check = gr(n.check, r, f, a)), s -= f, a += f, n.length -= f), n.length))
            break e;
          n.length = 0, n.mode = aw;
        case aw:
          if (n.flags & 2048) {
            if (s === 0)
              break e;
            f = 0;
            do
              S = r[a + f++], n.head && S && n.length < 65536 && (n.head.name += String.fromCharCode(S));
            while (S && f < s);
            if (n.flags & 512 && (n.check = gr(n.check, r, f, a)), s -= f, a += f, S)
              break e;
          } else n.head && (n.head.name = null);
          n.length = 0, n.mode = lw;
        case lw:
          if (n.flags & 4096) {
            if (s === 0)
              break e;
            f = 0;
            do
              S = r[a + f++], n.head && S && n.length < 65536 && (n.head.comment += String.fromCharCode(S));
            while (S && f < s);
            if (n.flags & 512 && (n.check = gr(n.check, r, f, a)), s -= f, a += f, S)
              break e;
          } else n.head && (n.head.comment = null);
          n.mode = sw;
        case sw:
          if (n.flags & 512) {
            for (; o < 16; ) {
              if (s === 0)
                break e;
              s--, d += r[a++] << o, o += 8;
            }
            if (d !== (n.check & 65535)) {
              e.msg = "header crc mismatch", n.mode = mn;
              break;
            }
            d = 0, o = 0;
          }
          n.head && (n.head.hcrc = n.flags >> 9 & 1, n.head.done = !0), e.adler = n.check = 0, n.mode = zl;
          break;
        case ow:
          for (; o < 32; ) {
            if (s === 0)
              break e;
            s--, d += r[a++] << o, o += 8;
          }
          e.adler = n.check = ww(d), d = 0, o = 0, n.mode = dm;
        case dm:
          if (n.havedict === 0)
            return e.next_out = l, e.avail_out = c, e.next_in = a, e.avail_in = s, n.hold = d, n.bits = o, dG;
          e.adler = n.check = 1, n.mode = zl;
        case zl:
          if (t === oG || t === S1)
            break e;
        case M6:
          if (n.last) {
            d >>>= o & 7, o -= o & 7, n.mode = I6;
            break;
          }
          for (; o < 3; ) {
            if (s === 0)
              break e;
            s--, d += r[a++] << o, o += 8;
          }
          switch (n.last = d & 1, d >>>= 1, o -= 1, d & 3) {
            case 0:
              n.mode = cw;
              break;
            case 1:
              if (vG(n), n.mode = _1, t === S1) {
                d >>>= 2, o -= 2;
                break e;
              }
              break;
            case 2:
              n.mode = uw;
              break;
            case 3:
              e.msg = "invalid block type", n.mode = mn;
          }
          d >>>= 2, o -= 2;
          break;
        case cw:
          for (d >>>= o & 7, o -= o & 7; o < 32; ) {
            if (s === 0)
              break e;
            s--, d += r[a++] << o, o += 8;
          }
          if ((d & 65535) !== (d >>> 16 ^ 65535)) {
            e.msg = "invalid stored block lengths", n.mode = mn;
            break;
          }
          if (n.length = d & 65535, d = 0, o = 0, n.mode = T6, t === S1)
            break e;
        case T6:
          n.mode = dw;
        case dw:
          if (f = n.length, f) {
            if (f > s && (f = s), f > c && (f = c), f === 0)
              break e;
            i.set(r.subarray(a, a + f), l), s -= f, a += f, c -= f, l += f, n.length -= f;
            break;
          }
          n.mode = zl;
          break;
        case uw:
          for (; o < 14; ) {
            if (s === 0)
              break e;
            s--, d += r[a++] << o, o += 8;
          }
          if (n.nlen = (d & 31) + 257, d >>>= 5, o -= 5, n.ndist = (d & 31) + 1, d >>>= 5, o -= 5, n.ncode = (d & 15) + 4, d >>>= 4, o -= 4, n.nlen > 286 || n.ndist > 30) {
            e.msg = "too many length or distance symbols", n.mode = mn;
            break;
          }
          n.have = 0, n.mode = hw;
        case hw:
          for (; n.have < n.ncode; ) {
            for (; o < 3; ) {
              if (s === 0)
                break e;
              s--, d += r[a++] << o, o += 8;
            }
            n.lens[L[n.have++]] = d & 7, d >>>= 3, o -= 3;
          }
          for (; n.have < 19; )
            n.lens[L[n.have++]] = 0;
          if (n.lencode = n.lendyn, n.lenbits = 7, M = { bits: n.lenbits }, _ = hh(sG, n.lens, 0, 19, n.lencode, 0, n.work, M), n.lenbits = M.bits, _) {
            e.msg = "invalid code lengths set", n.mode = mn;
            break;
          }
          n.have = 0, n.mode = fw;
        case fw:
          for (; n.have < n.nlen + n.ndist; ) {
            for (; b = n.lencode[d & (1 << n.lenbits) - 1], v = b >>> 24, U = b >>> 16 & 255, y = b & 65535, !(v <= o); ) {
              if (s === 0)
                break e;
              s--, d += r[a++] << o, o += 8;
            }
            if (y < 16)
              d >>>= v, o -= v, n.lens[n.have++] = y;
            else {
              if (y === 16) {
                for (A = v + 2; o < A; ) {
                  if (s === 0)
                    break e;
                  s--, d += r[a++] << o, o += 8;
                }
                if (d >>>= v, o -= v, n.have === 0) {
                  e.msg = "invalid bit length repeat", n.mode = mn;
                  break;
                }
                S = n.lens[n.have - 1], f = 3 + (d & 3), d >>>= 2, o -= 2;
              } else if (y === 17) {
                for (A = v + 3; o < A; ) {
                  if (s === 0)
                    break e;
                  s--, d += r[a++] << o, o += 8;
                }
                d >>>= v, o -= v, S = 0, f = 3 + (d & 7), d >>>= 3, o -= 3;
              } else {
                for (A = v + 7; o < A; ) {
                  if (s === 0)
                    break e;
                  s--, d += r[a++] << o, o += 8;
                }
                d >>>= v, o -= v, S = 0, f = 11 + (d & 127), d >>>= 7, o -= 7;
              }
              if (n.have + f > n.nlen + n.ndist) {
                e.msg = "invalid bit length repeat", n.mode = mn;
                break;
              }
              for (; f--; )
                n.lens[n.have++] = S;
            }
          }
          if (n.mode === mn)
            break;
          if (n.lens[256] === 0) {
            e.msg = "invalid code -- missing end-of-block", n.mode = mn;
            break;
          }
          if (n.lenbits = 9, M = { bits: n.lenbits }, _ = hh(jT, n.lens, 0, n.nlen, n.lencode, 0, n.work, M), n.lenbits = M.bits, _) {
            e.msg = "invalid literal/lengths set", n.mode = mn;
            break;
          }
          if (n.distbits = 6, n.distcode = n.distdyn, M = { bits: n.distbits }, _ = hh(KT, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, M), n.distbits = M.bits, _) {
            e.msg = "invalid distances set", n.mode = mn;
            break;
          }
          if (n.mode = _1, t === S1)
            break e;
        case _1:
          n.mode = k1;
        case k1:
          if (s >= 6 && c >= 258) {
            e.next_out = l, e.avail_out = c, e.next_in = a, e.avail_in = s, n.hold = d, n.bits = o, tG(e, h), l = e.next_out, i = e.output, c = e.avail_out, a = e.next_in, r = e.input, s = e.avail_in, d = n.hold, o = n.bits, n.mode === zl && (n.back = -1);
            break;
          }
          for (n.back = 0; b = n.lencode[d & (1 << n.lenbits) - 1], v = b >>> 24, U = b >>> 16 & 255, y = b & 65535, !(v <= o); ) {
            if (s === 0)
              break e;
            s--, d += r[a++] << o, o += 8;
          }
          if (U && !(U & 240)) {
            for (w = v, x = U, E = y; b = n.lencode[E + ((d & (1 << w + x) - 1) >> w)], v = b >>> 24, U = b >>> 16 & 255, y = b & 65535, !(w + v <= o); ) {
              if (s === 0)
                break e;
              s--, d += r[a++] << o, o += 8;
            }
            d >>>= w, o -= w, n.back += w;
          }
          if (d >>>= v, o -= v, n.back += v, n.length = y, U === 0) {
            n.mode = Uw;
            break;
          }
          if (U & 32) {
            n.back = -1, n.mode = zl;
            break;
          }
          if (U & 64) {
            e.msg = "invalid literal/length code", n.mode = mn;
            break;
          }
          n.extra = U & 15, n.mode = pw;
        case pw:
          if (n.extra) {
            for (A = n.extra; o < A; ) {
              if (s === 0)
                break e;
              s--, d += r[a++] << o, o += 8;
            }
            n.length += d & (1 << n.extra) - 1, d >>>= n.extra, o -= n.extra, n.back += n.extra;
          }
          n.was = n.length, n.mode = mw;
        case mw:
          for (; b = n.distcode[d & (1 << n.distbits) - 1], v = b >>> 24, U = b >>> 16 & 255, y = b & 65535, !(v <= o); ) {
            if (s === 0)
              break e;
            s--, d += r[a++] << o, o += 8;
          }
          if (!(U & 240)) {
            for (w = v, x = U, E = y; b = n.distcode[E + ((d & (1 << w + x) - 1) >> w)], v = b >>> 24, U = b >>> 16 & 255, y = b & 65535, !(w + v <= o); ) {
              if (s === 0)
                break e;
              s--, d += r[a++] << o, o += 8;
            }
            d >>>= w, o -= w, n.back += w;
          }
          if (d >>>= v, o -= v, n.back += v, U & 64) {
            e.msg = "invalid distance code", n.mode = mn;
            break;
          }
          n.offset = y, n.extra = U & 15, n.mode = gw;
        case gw:
          if (n.extra) {
            for (A = n.extra; o < A; ) {
              if (s === 0)
                break e;
              s--, d += r[a++] << o, o += 8;
            }
            n.offset += d & (1 << n.extra) - 1, d >>>= n.extra, o -= n.extra, n.back += n.extra;
          }
          if (n.offset > n.dmax) {
            e.msg = "invalid distance too far back", n.mode = mn;
            break;
          }
          n.mode = bw;
        case bw:
          if (c === 0)
            break e;
          if (f = h - c, n.offset > f) {
            if (f = n.offset - f, f > n.whave && n.sane) {
              e.msg = "invalid distance too far back", n.mode = mn;
              break;
            }
            f > n.wnext ? (f -= n.wnext, p = n.wsize - f) : p = n.wnext - f, f > n.length && (f = n.length), g = n.window;
          } else
            g = i, p = l - n.offset, f = n.length;
          f > c && (f = c), c -= f, n.length -= f;
          do
            i[l++] = g[p++];
          while (--f);
          n.length === 0 && (n.mode = k1);
          break;
        case Uw:
          if (c === 0)
            break e;
          i[l++] = n.length, c--, n.mode = k1;
          break;
        case I6:
          if (n.wrap) {
            for (; o < 32; ) {
              if (s === 0)
                break e;
              s--, d |= r[a++] << o, o += 8;
            }
            if (h -= c, e.total_out += h, n.total += h, h && (e.adler = n.check = /*UPDATE(state.check, put - _out, _out);*/
            n.flags ? gr(n.check, i, h, l - h) : zh(n.check, i, h, l - h)), h = c, (n.flags ? d : ww(d)) !== n.check) {
              e.msg = "incorrect data check", n.mode = mn;
              break;
            }
            d = 0, o = 0;
          }
          n.mode = vw;
        case vw:
          if (n.wrap && n.flags) {
            for (; o < 32; ) {
              if (s === 0)
                break e;
              s--, d += r[a++] << o, o += 8;
            }
            if (d !== (n.total & 4294967295)) {
              e.msg = "incorrect length check", n.mode = mn;
              break;
            }
            d = 0, o = 0;
          }
          n.mode = yw;
        case yw:
          _ = cG;
          break e;
        case mn:
          _ = YT;
          break e;
        case JT:
          return qT;
        case hG:
        default:
          return ea;
      }
  return e.next_out = l, e.avail_out = c, e.next_in = a, e.avail_in = s, n.hold = d, n.bits = o, (n.wsize || h !== e.avail_out && n.mode < mn && (n.mode < I6 || t !== Jy)) && rI(e, e.output, e.next_out, h - e.avail_out), u -= e.avail_in, h -= e.avail_out, e.total_in += u, e.total_out += h, n.total += h, n.wrap && h && (e.adler = n.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
  n.flags ? gr(n.check, i, h, e.next_out - h) : zh(n.check, i, h, e.next_out - h)), e.data_type = n.bits + (n.last ? 64 : 0) + (n.mode === zl ? 128 : 0) + (n.mode === _1 || n.mode === T6 ? 256 : 0), (u === 0 && h === 0 || t === Jy) && _ === Hc && (_ = uG), _;
}, wG = (e) => {
  if (!e || !e.state)
    return ea;
  let t = e.state;
  return t.window && (t.window = null), e.state = null, Hc;
}, xG = (e, t) => {
  if (!e || !e.state)
    return ea;
  const n = e.state;
  return n.wrap & 2 ? (n.head = t, t.done = !1, Hc) : ea;
}, EG = (e, t) => {
  const n = t.length;
  let r, i, a;
  return !e || !e.state || (r = e.state, r.wrap !== 0 && r.mode !== dm) ? ea : r.mode === dm && (i = 1, i = zh(i, t, n, 0), i !== r.check) ? YT : (a = rI(e, t, n, n), a ? (r.mode = JT, qT) : (r.havedict = 1, Hc));
};
var SG = eI, _G = tI, kG = QT, CG = UG, MG = nI, TG = yG, IG = wG, AG = xG, NG = EG, DG = "pako inflate (from Nodeca project)", Zl = {
  inflateReset: SG,
  inflateReset2: _G,
  inflateResetKeep: kG,
  inflateInit: CG,
  inflateInit2: MG,
  inflate: TG,
  inflateEnd: IG,
  inflateGetHeader: AG,
  inflateSetDictionary: NG,
  inflateInfo: DG
};
function LG() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var RG = LG;
const iI = Object.prototype.toString, {
  Z_NO_FLUSH: PG,
  Z_FINISH: OG,
  Z_OK: Wh,
  Z_STREAM_END: D6,
  Z_NEED_DICT: L6,
  Z_STREAM_ERROR: $G,
  Z_DATA_ERROR: Ew,
  Z_MEM_ERROR: FG
} = Hg;
function jg(e) {
  this.options = Vg.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, e || {});
  const t = this.options;
  t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, t.windowBits === 0 && (t.windowBits = -15)), t.windowBits >= 0 && t.windowBits < 16 && !(e && e.windowBits) && (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && (t.windowBits & 15 || (t.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new VT(), this.strm.avail_out = 0;
  let n = Zl.inflateInit2(
    this.strm,
    t.windowBits
  );
  if (n !== Wh)
    throw new Error(Fc[n]);
  if (this.header = new RG(), Zl.inflateGetHeader(this.strm, this.header), t.dictionary && (typeof t.dictionary == "string" ? t.dictionary = Hh.string2buf(t.dictionary) : iI.call(t.dictionary) === "[object ArrayBuffer]" && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (n = Zl.inflateSetDictionary(this.strm, t.dictionary), n !== Wh)))
    throw new Error(Fc[n]);
}
jg.prototype.push = function(e, t) {
  const n = this.strm, r = this.options.chunkSize, i = this.options.dictionary;
  let a, l, s;
  if (this.ended) return !1;
  for (t === ~~t ? l = t : l = t === !0 ? OG : PG, iI.call(e) === "[object ArrayBuffer]" ? n.input = new Uint8Array(e) : n.input = e, n.next_in = 0, n.avail_in = n.input.length; ; ) {
    for (n.avail_out === 0 && (n.output = new Uint8Array(r), n.next_out = 0, n.avail_out = r), a = Zl.inflate(n, l), a === L6 && i && (a = Zl.inflateSetDictionary(n, i), a === Wh ? a = Zl.inflate(n, l) : a === Ew && (a = L6)); n.avail_in > 0 && a === D6 && n.state.wrap > 0 && e[n.next_in] !== 0; )
      Zl.inflateReset(n), a = Zl.inflate(n, l);
    switch (a) {
      case $G:
      case Ew:
      case L6:
      case FG:
        return this.onEnd(a), this.ended = !0, !1;
    }
    if (s = n.avail_out, n.next_out && (n.avail_out === 0 || a === D6))
      if (this.options.to === "string") {
        let c = Hh.utf8border(n.output, n.next_out), d = n.next_out - c, o = Hh.buf2string(n.output, c);
        n.next_out = d, n.avail_out = r - d, d && n.output.set(n.output.subarray(c, c + d), 0), this.onData(o);
      } else
        this.onData(n.output.length === n.next_out ? n.output : n.output.subarray(0, n.next_out));
    if (!(a === Wh && s === 0)) {
      if (a === D6)
        return a = Zl.inflateEnd(this.strm), this.onEnd(a), this.ended = !0, !0;
      if (n.avail_in === 0) break;
    }
  }
  return !0;
};
jg.prototype.onData = function(e) {
  this.chunks.push(e);
};
jg.prototype.onEnd = function(e) {
  e === Wh && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = Vg.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function zG(e, t) {
  const n = new jg(t);
  if (n.push(e), n.err) throw n.msg || Fc[n.err];
  return n.result;
}
var BG = zG, HG = {
  inflate: BG
};
const { deflate: WG } = QV, { inflate: XG } = HG;
var VG = WG, GG = XG;
const jG = "#ffffff", KG = "#000000", YG = [
  "#f8f9fa",
  "#f1f3f5",
  "#e9ecef",
  "#dee2e6",
  "#ced4da",
  "#adb5bd",
  "#868e96",
  "#495057",
  "#343a40",
  "#212529"
], qG = [
  "#fff5f5",
  "#ffe3e3",
  "#ffc9c9",
  "#ffa8a8",
  "#ff8787",
  "#ff6b6b",
  "#fa5252",
  "#f03e3e",
  "#e03131",
  "#c92a2a"
], ZG = [
  "#fff0f6",
  "#ffdeeb",
  "#fcc2d7",
  "#faa2c1",
  "#f783ac",
  "#f06595",
  "#e64980",
  "#d6336c",
  "#c2255c",
  "#a61e4d"
], JG = [
  "#f8f0fc",
  "#f3d9fa",
  "#eebefa",
  "#e599f7",
  "#da77f2",
  "#cc5de8",
  "#be4bdb",
  "#ae3ec9",
  "#9c36b5",
  "#862e9c"
], QG = [
  "#f3f0ff",
  "#e5dbff",
  "#d0bfff",
  "#b197fc",
  "#9775fa",
  "#845ef7",
  "#7950f2",
  "#7048e8",
  "#6741d9",
  "#5f3dc4"
], ej = [
  "#edf2ff",
  "#dbe4ff",
  "#bac8ff",
  "#91a7ff",
  "#748ffc",
  "#5c7cfa",
  "#4c6ef5",
  "#4263eb",
  "#3b5bdb",
  "#364fc7"
], tj = [
  "#e7f5ff",
  "#d0ebff",
  "#a5d8ff",
  "#74c0fc",
  "#4dabf7",
  "#339af0",
  "#228be6",
  "#1c7ed6",
  "#1971c2",
  "#1864ab"
], nj = [
  "#e3fafc",
  "#c5f6fa",
  "#99e9f2",
  "#66d9e8",
  "#3bc9db",
  "#22b8cf",
  "#15aabf",
  "#1098ad",
  "#0c8599",
  "#0b7285"
], rj = [
  "#e6fcf5",
  "#c3fae8",
  "#96f2d7",
  "#63e6be",
  "#38d9a9",
  "#20c997",
  "#12b886",
  "#0ca678",
  "#099268",
  "#087f5b"
], ij = [
  "#ebfbee",
  "#d3f9d8",
  "#b2f2bb",
  "#8ce99a",
  "#69db7c",
  "#51cf66",
  "#40c057",
  "#37b24d",
  "#2f9e44",
  "#2b8a3e"
], aj = [
  "#f4fce3",
  "#e9fac8",
  "#d8f5a2",
  "#c0eb75",
  "#a9e34b",
  "#94d82d",
  "#82c91e",
  "#74b816",
  "#66a80f",
  "#5c940d"
], lj = [
  "#fff9db",
  "#fff3bf",
  "#ffec99",
  "#ffe066",
  "#ffd43b",
  "#fcc419",
  "#fab005",
  "#f59f00",
  "#f08c00",
  "#e67700"
], sj = [
  "#fff4e6",
  "#ffe8cc",
  "#ffd8a8",
  "#ffc078",
  "#ffa94d",
  "#ff922b",
  "#fd7e14",
  "#f76707",
  "#e8590c",
  "#d9480f"
], wr = {
  white: jG,
  black: KG,
  gray: YG,
  red: qG,
  pink: ZG,
  grape: JG,
  violet: QG,
  indigo: ej,
  blue: tj,
  cyan: nj,
  teal: rj,
  green: ij,
  lime: aj,
  yellow: lj,
  orange: sj
};
let l8 = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((t, n) => (n &= 63, n < 36 ? t += n.toString(36) : n < 62 ? t += (n - 26).toString(36).toUpperCase() : n > 62 ? t += "-" : t += "_", t), "");
var aI = "Expected a function", Sw = NaN, oj = "[object Symbol]", cj = /^\s+|\s+$/g, dj = /^[-+]0x[0-9a-f]+$/i, uj = /^0b[01]+$/i, hj = /^0o[0-7]+$/i, fj = parseInt, pj = typeof ya == "object" && ya && ya.Object === Object && ya, mj = typeof self == "object" && self && self.Object === Object && self, gj = pj || mj || Function("return this")(), bj = Object.prototype, Uj = bj.toString, vj = Math.max, yj = Math.min, R6 = function() {
  return gj.Date.now();
};
function wj(e, t, n) {
  var r, i, a, l, s, c, d = 0, o = !1, u = !1, h = !0;
  if (typeof e != "function")
    throw new TypeError(aI);
  t = _w(t) || 0, um(n) && (o = !!n.leading, u = "maxWait" in n, a = u ? vj(_w(n.maxWait) || 0, t) : a, h = "trailing" in n ? !!n.trailing : h);
  function f(E) {
    var S = r, _ = i;
    return r = i = void 0, d = E, l = e.apply(_, S), l;
  }
  function p(E) {
    return d = E, s = setTimeout(v, t), o ? f(E) : l;
  }
  function g(E) {
    var S = E - c, _ = E - d, k = t - S;
    return u ? yj(k, a - _) : k;
  }
  function b(E) {
    var S = E - c, _ = E - d;
    return c === void 0 || S >= t || S < 0 || u && _ >= a;
  }
  function v() {
    var E = R6();
    if (b(E))
      return U(E);
    s = setTimeout(v, g(E));
  }
  function U(E) {
    return s = void 0, h && r ? f(E) : (r = i = void 0, l);
  }
  function y() {
    s !== void 0 && clearTimeout(s), d = 0, r = c = i = s = void 0;
  }
  function w() {
    return s === void 0 ? l : U(R6());
  }
  function x() {
    var E = R6(), S = b(E);
    if (r = arguments, i = this, c = E, S) {
      if (s === void 0)
        return p(c);
      if (u)
        return s = setTimeout(v, t), f(c);
    }
    return s === void 0 && (s = setTimeout(v, t)), l;
  }
  return x.cancel = y, x.flush = w, x;
}
function xj(e, t, n) {
  var r = !0, i = !0;
  if (typeof e != "function")
    throw new TypeError(aI);
  return um(n) && (r = "leading" in n ? !!n.leading : r, i = "trailing" in n ? !!n.trailing : i), wj(e, t, {
    leading: r,
    maxWait: t,
    trailing: i
  });
}
function um(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function Ej(e) {
  return !!e && typeof e == "object";
}
function Sj(e) {
  return typeof e == "symbol" || Ej(e) && Uj.call(e) == oj;
}
function _w(e) {
  if (typeof e == "number")
    return e;
  if (Sj(e))
    return Sw;
  if (um(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = um(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(cj, "");
  var n = uj.test(e);
  return n || hj.test(e) ? fj(e.slice(2), n ? 2 : 8) : dj.test(e) ? Sw : +e;
}
var _j = xj;
const Of = /* @__PURE__ */ ad(_j);
var lI = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(ya, function() {
    var n = function() {
      this._listeners = {};
    };
    n.prototype.addEventListener = function(d, o) {
      this._listeners[d] = this._listeners[d] || [], this._listeners[d].indexOf(o) < 0 && this._listeners[d].push(o);
    }, n.prototype.removeEventListener = function(d, o) {
      if (this._listeners[d]) {
        var u = this._listeners[d].indexOf(o);
        u >= 0 && this._listeners[d].splice(u, 1);
      }
    }, n.prototype.dispatchEvent = function(d) {
      if (this._listeners[d.type] && this._listeners[d.type].length)
        for (var o = this._listeners[d.type].slice(), u = 0, h = o.length; u < h; ++u)
          o[u].call(this, d);
    };
    var r = function(d) {
      return typeof d.constructor == "function" && d.constructor.name === "GeneratorFunction";
    }, i = function(d) {
      return {
        next: function() {
          var o = d();
          return o ? { value: o } : { done: !0 };
        }
      };
    }, a = function(d) {
      var o = !1;
      return {
        next: function() {
          return o ? { done: !0 } : (o = !0, { value: d });
        }
      };
    }, l = function(d, o) {
      var u = typeof d;
      if (u === "object") {
        if (typeof d.next == "function")
          return d;
        if (typeof d.then == "function")
          return a(d);
      }
      return u === "function" ? r(d) ? d() : i(d) : a(o.resolve(d));
    }, s = function(d, o, u) {
      this.target = d, this.type = o, this.data = u;
    }, c = function(d, o, u) {
      if (n.call(this), typeof o != "number" || Math.floor(o) !== o || o < 1)
        throw new Error("Invalid concurrency");
      this._concurrency = o, this._options = u || {}, this._options.promise = this._options.promise || Promise, this._iterator = l(d, this._options.promise), this._done = !1, this._size = 0, this._promise = null, this._callbacks = null;
    };
    return c.prototype = new n(), c.prototype.constructor = c, c.prototype.concurrency = function(d) {
      return typeof d < "u" && (this._concurrency = d, this.active() && this._proceed()), this._concurrency;
    }, c.prototype.size = function() {
      return this._size;
    }, c.prototype.active = function() {
      return !!this._promise;
    }, c.prototype.promise = function() {
      return this._promise;
    }, c.prototype.start = function() {
      var d = this, o = this._options.promise;
      return this._promise = new o(function(u, h) {
        d._callbacks = {
          reject: h,
          resolve: u
        }, d._proceed();
      }), this._promise;
    }, c.prototype._fireEvent = function(d, o) {
      this.dispatchEvent(new s(this, d, o));
    }, c.prototype._settle = function(d) {
      d ? this._callbacks.reject(d) : this._callbacks.resolve(), this._promise = null, this._callbacks = null;
    }, c.prototype._onPooledPromiseFulfilled = function(d, o) {
      this._size--, this.active() && (this._fireEvent("fulfilled", {
        promise: d,
        result: o
      }), this._proceed());
    }, c.prototype._onPooledPromiseRejected = function(d, o) {
      this._size--, this.active() && (this._fireEvent("rejected", {
        promise: d,
        error: o
      }), this._settle(o || new Error("Unknown error")));
    }, c.prototype._trackPromise = function(d) {
      var o = this;
      d.then(function(u) {
        o._onPooledPromiseFulfilled(d, u);
      }, function(u) {
        o._onPooledPromiseRejected(d, u);
      }).catch(function(u) {
        o._settle(new Error("Promise processing failed: " + u));
      });
    }, c.prototype._proceed = function() {
      if (!this._done) {
        for (var d = { done: !1 }; this._size < this._concurrency && !(d = this._iterator.next()).done; )
          this._size++, this._trackPromise(d.value);
        this._done = d === null || !!d.done;
      }
      this._done && this._size === 0 && this._settle();
    }, c.PromisePoolEvent = s, c.PromisePool = c, c;
  });
})(lI);
var kj = lI.exports;
const Cj = /* @__PURE__ */ ad(kj);
function V4(e, t, n) {
  if (e && e.length) {
    const [r, i] = t, a = Math.PI / 180 * n, l = Math.cos(a), s = Math.sin(a);
    for (const c of e) {
      const [d, o] = c;
      c[0] = (d - r) * l - (o - i) * s + r, c[1] = (d - r) * s + (o - i) * l + i;
    }
  }
}
function Mj(e, t, n) {
  const r = [];
  e.forEach((i) => r.push(...i)), V4(r, t, n);
}
function Tj(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}
function Ij(e, t, n, r = 1) {
  const i = n, a = Math.max(t, 0.1), l = e[0] && e[0][0] && typeof e[0][0] == "number" ? [e] : e, s = [0, 0];
  if (i)
    for (const d of l)
      V4(d, s, i);
  const c = Aj(l, a, r);
  if (i) {
    for (const d of l)
      V4(d, s, -i);
    Mj(c, s, -i);
  }
  return c;
}
function Aj(e, t, n) {
  const r = [];
  for (const d of e) {
    const o = [...d];
    Tj(o[0], o[o.length - 1]) || o.push([o[0][0], o[0][1]]), o.length > 2 && r.push(o);
  }
  const i = [];
  t = Math.max(t, 0.1);
  const a = [];
  for (const d of r)
    for (let o = 0; o < d.length - 1; o++) {
      const u = d[o], h = d[o + 1];
      if (u[1] !== h[1]) {
        const f = Math.min(u[1], h[1]);
        a.push({
          ymin: f,
          ymax: Math.max(u[1], h[1]),
          x: f === u[1] ? u[0] : h[0],
          islope: (h[0] - u[0]) / (h[1] - u[1])
        });
      }
    }
  if (a.sort((d, o) => d.ymin < o.ymin ? -1 : d.ymin > o.ymin ? 1 : d.x < o.x ? -1 : d.x > o.x ? 1 : d.ymax === o.ymax ? 0 : (d.ymax - o.ymax) / Math.abs(d.ymax - o.ymax)), !a.length)
    return i;
  let l = [], s = a[0].ymin, c = 0;
  for (; l.length || a.length; ) {
    if (a.length) {
      let d = -1;
      for (let u = 0; u < a.length && !(a[u].ymin > s); u++)
        d = u;
      a.splice(0, d + 1).forEach((u) => {
        l.push({ s, edge: u });
      });
    }
    if (l = l.filter((d) => !(d.edge.ymax <= s)), l.sort((d, o) => d.edge.x === o.edge.x ? 0 : (d.edge.x - o.edge.x) / Math.abs(d.edge.x - o.edge.x)), (n !== 1 || c % t === 0) && l.length > 1)
      for (let d = 0; d < l.length; d = d + 2) {
        const o = d + 1;
        if (o >= l.length)
          break;
        const u = l[d].edge, h = l[o].edge;
        i.push([
          [Math.round(u.x), s],
          [Math.round(h.x), s]
        ]);
      }
    s += n, l.forEach((d) => {
      d.edge.x = d.edge.x + n * d.edge.islope;
    }), c++;
  }
  return i;
}
function $f(e, t) {
  var n;
  const r = t.hachureAngle + 90;
  let i = t.hachureGap;
  i < 0 && (i = t.strokeWidth * 4), i = Math.max(i, 0.1);
  let a = 1;
  return t.roughness >= 1 && (((n = t.randomizer) === null || n === void 0 ? void 0 : n.next()) || Math.random()) > 0.7 && (a = i), Ij(e, i, r, a || 1);
}
class s8 {
  constructor(t) {
    this.helper = t;
  }
  fillPolygons(t, n) {
    return this._fillPolygons(t, n);
  }
  _fillPolygons(t, n) {
    const r = $f(t, n);
    return { type: "fillSketch", ops: this.renderLines(r, n) };
  }
  renderLines(t, n) {
    const r = [];
    for (const i of t)
      r.push(...this.helper.doubleLineOps(i[0][0], i[0][1], i[1][0], i[1][1], n));
    return r;
  }
}
function Kg(e) {
  const t = e[0], n = e[1];
  return Math.sqrt(Math.pow(t[0] - n[0], 2) + Math.pow(t[1] - n[1], 2));
}
class Nj extends s8 {
  fillPolygons(t, n) {
    let r = n.hachureGap;
    r < 0 && (r = n.strokeWidth * 4), r = Math.max(r, 0.1);
    const i = Object.assign({}, n, { hachureGap: r }), a = $f(t, i), l = Math.PI / 180 * n.hachureAngle, s = [], c = r * 0.5 * Math.cos(l), d = r * 0.5 * Math.sin(l);
    for (const [u, h] of a)
      Kg([u, h]) && s.push([
        [u[0] - c, u[1] + d],
        [...h]
      ], [
        [u[0] + c, u[1] - d],
        [...h]
      ]);
    return { type: "fillSketch", ops: this.renderLines(s, n) };
  }
}
class Dj extends s8 {
  fillPolygons(t, n) {
    const r = this._fillPolygons(t, n), i = Object.assign({}, n, { hachureAngle: n.hachureAngle + 90 }), a = this._fillPolygons(t, i);
    return r.ops = r.ops.concat(a.ops), r;
  }
}
class Lj {
  constructor(t) {
    this.helper = t;
  }
  fillPolygons(t, n) {
    n = Object.assign({}, n, { hachureAngle: 0 });
    const r = $f(t, n);
    return this.dotsOnLines(r, n);
  }
  dotsOnLines(t, n) {
    const r = [];
    let i = n.hachureGap;
    i < 0 && (i = n.strokeWidth * 4), i = Math.max(i, 0.1);
    let a = n.fillWeight;
    a < 0 && (a = n.strokeWidth / 2);
    const l = i / 4;
    for (const s of t) {
      const c = Kg(s), d = c / i, o = Math.ceil(d) - 1, u = c - o * i, h = (s[0][0] + s[1][0]) / 2 - i / 4, f = Math.min(s[0][1], s[1][1]);
      for (let p = 0; p < o; p++) {
        const g = f + u + p * i, b = h - l + Math.random() * 2 * l, v = g - l + Math.random() * 2 * l, U = this.helper.ellipse(b, v, a, a, n);
        r.push(...U.ops);
      }
    }
    return { type: "fillSketch", ops: r };
  }
}
class Rj {
  constructor(t) {
    this.helper = t;
  }
  fillPolygons(t, n) {
    const r = $f(t, n);
    return { type: "fillSketch", ops: this.dashedLine(r, n) };
  }
  dashedLine(t, n) {
    const r = n.dashOffset < 0 ? n.hachureGap < 0 ? n.strokeWidth * 4 : n.hachureGap : n.dashOffset, i = n.dashGap < 0 ? n.hachureGap < 0 ? n.strokeWidth * 4 : n.hachureGap : n.dashGap, a = [];
    return t.forEach((l) => {
      const s = Kg(l), c = Math.floor(s / (r + i)), d = (s + i - c * (r + i)) / 2;
      let o = l[0], u = l[1];
      o[0] > u[0] && (o = l[1], u = l[0]);
      const h = Math.atan((u[1] - o[1]) / (u[0] - o[0]));
      for (let f = 0; f < c; f++) {
        const p = f * (r + i), g = p + r, b = [o[0] + p * Math.cos(h) + d * Math.cos(h), o[1] + p * Math.sin(h) + d * Math.sin(h)], v = [o[0] + g * Math.cos(h) + d * Math.cos(h), o[1] + g * Math.sin(h) + d * Math.sin(h)];
        a.push(...this.helper.doubleLineOps(b[0], b[1], v[0], v[1], n));
      }
    }), a;
  }
}
class Pj {
  constructor(t) {
    this.helper = t;
  }
  fillPolygons(t, n) {
    const r = n.hachureGap < 0 ? n.strokeWidth * 4 : n.hachureGap, i = n.zigzagOffset < 0 ? r : n.zigzagOffset;
    n = Object.assign({}, n, { hachureGap: r + i });
    const a = $f(t, n);
    return { type: "fillSketch", ops: this.zigzagLines(a, i, n) };
  }
  zigzagLines(t, n, r) {
    const i = [];
    return t.forEach((a) => {
      const l = Kg(a), s = Math.round(l / (2 * n));
      let c = a[0], d = a[1];
      c[0] > d[0] && (c = a[1], d = a[0]);
      const o = Math.atan((d[1] - c[1]) / (d[0] - c[0]));
      for (let u = 0; u < s; u++) {
        const h = u * 2 * n, f = (u + 1) * 2 * n, p = Math.sqrt(2 * Math.pow(n, 2)), g = [c[0] + h * Math.cos(o), c[1] + h * Math.sin(o)], b = [c[0] + f * Math.cos(o), c[1] + f * Math.sin(o)], v = [g[0] + p * Math.cos(o + Math.PI / 4), g[1] + p * Math.sin(o + Math.PI / 4)];
        i.push(...this.helper.doubleLineOps(g[0], g[1], v[0], v[1], r), ...this.helper.doubleLineOps(v[0], v[1], b[0], b[1], r));
      }
    }), i;
  }
}
const Jr = {};
function Oj(e, t) {
  let n = e.fillStyle || "hachure";
  if (!Jr[n])
    switch (n) {
      case "zigzag":
        Jr[n] || (Jr[n] = new Nj(t));
        break;
      case "cross-hatch":
        Jr[n] || (Jr[n] = new Dj(t));
        break;
      case "dots":
        Jr[n] || (Jr[n] = new Lj(t));
        break;
      case "dashed":
        Jr[n] || (Jr[n] = new Rj(t));
        break;
      case "zigzag-line":
        Jr[n] || (Jr[n] = new Pj(t));
        break;
      case "hachure":
      default:
        n = "hachure", Jr[n] || (Jr[n] = new s8(t));
        break;
    }
  return Jr[n];
}
function $j() {
  return Math.floor(Math.random() * 2 ** 31);
}
class sI {
  constructor(t) {
    this.seed = t;
  }
  next() {
    return this.seed ? (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31 : Math.random();
  }
}
const Fj = 0, G4 = 1, oI = 2, C1 = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };
function zj(e) {
  const t = new Array();
  for (; e !== ""; )
    if (e.match(/^([ \t\r\n,]+)/))
      e = e.substr(RegExp.$1.length);
    else if (e.match(/^([aAcChHlLmMqQsStTvVzZ])/))
      t[t.length] = { type: Fj, text: RegExp.$1 }, e = e.substr(RegExp.$1.length);
    else if (e.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))
      t[t.length] = { type: G4, text: `${parseFloat(RegExp.$1)}` }, e = e.substr(RegExp.$1.length);
    else
      return [];
  return t[t.length] = { type: oI, text: "" }, t;
}
function P6(e, t) {
  return e.type === t;
}
function o8(e) {
  const t = [], n = zj(e);
  let r = "BOD", i = 0, a = n[i];
  for (; !P6(a, oI); ) {
    let l = 0;
    const s = [];
    if (r === "BOD")
      if (a.text === "M" || a.text === "m")
        i++, l = C1[a.text], r = a.text;
      else
        return o8("M0,0" + e);
    else P6(a, G4) ? l = C1[r] : (i++, l = C1[a.text], r = a.text);
    if (i + l < n.length) {
      for (let c = i; c < i + l; c++) {
        const d = n[c];
        if (P6(d, G4))
          s[s.length] = +d.text;
        else
          throw new Error("Param not a number: " + r + "," + d.text);
      }
      if (typeof C1[r] == "number") {
        const c = { key: r, data: s };
        t.push(c), i += l, a = n[i], r === "M" && (r = "L"), r === "m" && (r = "l");
      } else
        throw new Error("Bad segment: " + r);
    } else
      throw new Error("Path data ended short");
  }
  return t;
}
function cI(e) {
  let t = 0, n = 0, r = 0, i = 0;
  const a = [];
  for (const { key: l, data: s } of e)
    switch (l) {
      case "M":
        a.push({ key: "M", data: [...s] }), [t, n] = s, [r, i] = s;
        break;
      case "m":
        t += s[0], n += s[1], a.push({ key: "M", data: [t, n] }), r = t, i = n;
        break;
      case "L":
        a.push({ key: "L", data: [...s] }), [t, n] = s;
        break;
      case "l":
        t += s[0], n += s[1], a.push({ key: "L", data: [t, n] });
        break;
      case "C":
        a.push({ key: "C", data: [...s] }), t = s[4], n = s[5];
        break;
      case "c": {
        const c = s.map((d, o) => o % 2 ? d + n : d + t);
        a.push({ key: "C", data: c }), t = c[4], n = c[5];
        break;
      }
      case "Q":
        a.push({ key: "Q", data: [...s] }), t = s[2], n = s[3];
        break;
      case "q": {
        const c = s.map((d, o) => o % 2 ? d + n : d + t);
        a.push({ key: "Q", data: c }), t = c[2], n = c[3];
        break;
      }
      case "A":
        a.push({ key: "A", data: [...s] }), t = s[5], n = s[6];
        break;
      case "a":
        t += s[5], n += s[6], a.push({ key: "A", data: [s[0], s[1], s[2], s[3], s[4], t, n] });
        break;
      case "H":
        a.push({ key: "H", data: [...s] }), t = s[0];
        break;
      case "h":
        t += s[0], a.push({ key: "H", data: [t] });
        break;
      case "V":
        a.push({ key: "V", data: [...s] }), n = s[0];
        break;
      case "v":
        n += s[0], a.push({ key: "V", data: [n] });
        break;
      case "S":
        a.push({ key: "S", data: [...s] }), t = s[2], n = s[3];
        break;
      case "s": {
        const c = s.map((d, o) => o % 2 ? d + n : d + t);
        a.push({ key: "S", data: c }), t = c[2], n = c[3];
        break;
      }
      case "T":
        a.push({ key: "T", data: [...s] }), t = s[0], n = s[1];
        break;
      case "t":
        t += s[0], n += s[1], a.push({ key: "T", data: [t, n] });
        break;
      case "Z":
      case "z":
        a.push({ key: "Z", data: [] }), t = r, n = i;
        break;
    }
  return a;
}
function dI(e) {
  const t = [];
  let n = "", r = 0, i = 0, a = 0, l = 0, s = 0, c = 0;
  for (const { key: d, data: o } of e) {
    switch (d) {
      case "M":
        t.push({ key: "M", data: [...o] }), [r, i] = o, [a, l] = o;
        break;
      case "C":
        t.push({ key: "C", data: [...o] }), r = o[4], i = o[5], s = o[2], c = o[3];
        break;
      case "L":
        t.push({ key: "L", data: [...o] }), [r, i] = o;
        break;
      case "H":
        r = o[0], t.push({ key: "L", data: [r, i] });
        break;
      case "V":
        i = o[0], t.push({ key: "L", data: [r, i] });
        break;
      case "S": {
        let u = 0, h = 0;
        n === "C" || n === "S" ? (u = r + (r - s), h = i + (i - c)) : (u = r, h = i), t.push({ key: "C", data: [u, h, ...o] }), s = o[0], c = o[1], r = o[2], i = o[3];
        break;
      }
      case "T": {
        const [u, h] = o;
        let f = 0, p = 0;
        n === "Q" || n === "T" ? (f = r + (r - s), p = i + (i - c)) : (f = r, p = i);
        const g = r + 2 * (f - r) / 3, b = i + 2 * (p - i) / 3, v = u + 2 * (f - u) / 3, U = h + 2 * (p - h) / 3;
        t.push({ key: "C", data: [g, b, v, U, u, h] }), s = f, c = p, r = u, i = h;
        break;
      }
      case "Q": {
        const [u, h, f, p] = o, g = r + 2 * (u - r) / 3, b = i + 2 * (h - i) / 3, v = f + 2 * (u - f) / 3, U = p + 2 * (h - p) / 3;
        t.push({ key: "C", data: [g, b, v, U, f, p] }), s = u, c = h, r = f, i = p;
        break;
      }
      case "A": {
        const u = Math.abs(o[0]), h = Math.abs(o[1]), f = o[2], p = o[3], g = o[4], b = o[5], v = o[6];
        u === 0 || h === 0 ? (t.push({ key: "C", data: [r, i, b, v, b, v] }), r = b, i = v) : (r !== b || i !== v) && (uI(r, i, b, v, u, h, f, p, g).forEach(function(y) {
          t.push({ key: "C", data: y });
        }), r = b, i = v);
        break;
      }
      case "Z":
        t.push({ key: "Z", data: [] }), r = a, i = l;
        break;
    }
    n = d;
  }
  return t;
}
function Bj(e) {
  return Math.PI * e / 180;
}
function gu(e, t, n) {
  const r = e * Math.cos(n) - t * Math.sin(n), i = e * Math.sin(n) + t * Math.cos(n);
  return [r, i];
}
function uI(e, t, n, r, i, a, l, s, c, d) {
  const o = Bj(l);
  let u = [], h = 0, f = 0, p = 0, g = 0;
  if (d)
    [h, f, p, g] = d;
  else {
    [e, t] = gu(e, t, -o), [n, r] = gu(n, r, -o);
    const L = (e - n) / 2, R = (t - r) / 2;
    let z = L * L / (i * i) + R * R / (a * a);
    z > 1 && (z = Math.sqrt(z), i = z * i, a = z * a);
    const F = s === c ? -1 : 1, W = i * i, B = a * a, j = W * B - W * R * R - B * L * L, V = W * R * R + B * L * L, q = F * Math.sqrt(Math.abs(j / V));
    p = q * i * R / a + (e + n) / 2, g = q * -a * L / i + (t + r) / 2, h = Math.asin(parseFloat(((t - g) / a).toFixed(9))), f = Math.asin(parseFloat(((r - g) / a).toFixed(9))), e < p && (h = Math.PI - h), n < p && (f = Math.PI - f), h < 0 && (h = Math.PI * 2 + h), f < 0 && (f = Math.PI * 2 + f), c && h > f && (h = h - Math.PI * 2), !c && f > h && (f = f - Math.PI * 2);
  }
  let b = f - h;
  if (Math.abs(b) > Math.PI * 120 / 180) {
    const L = f, R = n, z = r;
    c && f > h ? f = h + Math.PI * 120 / 180 * 1 : f = h + Math.PI * 120 / 180 * -1, n = p + i * Math.cos(f), r = g + a * Math.sin(f), u = uI(n, r, R, z, i, a, l, 0, c, [f, L, p, g]);
  }
  b = f - h;
  const v = Math.cos(h), U = Math.sin(h), y = Math.cos(f), w = Math.sin(f), x = Math.tan(b / 4), E = 4 / 3 * i * x, S = 4 / 3 * a * x, _ = [e, t], k = [e + E * U, t - S * v], M = [n + E * w, r - S * y], A = [n, r];
  if (k[0] = 2 * _[0] - k[0], k[1] = 2 * _[1] - k[1], d)
    return [k, M, A].concat(u);
  {
    u = [k, M, A].concat(u);
    const L = [];
    for (let R = 0; R < u.length; R += 3) {
      const z = gu(u[R][0], u[R][1], o), F = gu(u[R + 1][0], u[R + 1][1], o), W = gu(u[R + 2][0], u[R + 2][1], o);
      L.push([z[0], z[1], F[0], F[1], W[0], W[1]]);
    }
    return L;
  }
}
const Hj = {
  randOffset: jj,
  randOffsetWithRange: Kj,
  ellipse: Vj,
  doubleLineOps: Yj
};
function hI(e, t, n, r, i) {
  return { type: "path", ops: gs(e, t, n, r, i) };
}
function sp(e, t, n) {
  const r = (e || []).length;
  if (r > 2) {
    const i = [];
    for (let a = 0; a < r - 1; a++)
      i.push(...gs(e[a][0], e[a][1], e[a + 1][0], e[a + 1][1], n));
    return t && i.push(...gs(e[r - 1][0], e[r - 1][1], e[0][0], e[0][1], n)), { type: "path", ops: i };
  } else if (r === 2)
    return hI(e[0][0], e[0][1], e[1][0], e[1][1], n);
  return { type: "path", ops: [] };
}
function Wj(e, t) {
  return sp(e, !0, t);
}
function Xj(e, t, n, r, i) {
  const a = [
    [e, t],
    [e + n, t],
    [e + n, t + r],
    [e, t + r]
  ];
  return Wj(a, i);
}
function kw(e, t) {
  let n = Iw(e, 1 * (1 + t.roughness * 0.2), t);
  if (!t.disableMultiStroke) {
    const r = Iw(e, 1.5 * (1 + t.roughness * 0.22), qj(t));
    n = n.concat(r);
  }
  return { type: "path", ops: n };
}
function Vj(e, t, n, r, i) {
  const a = fI(n, r, i);
  return j4(e, t, i, a).opset;
}
function fI(e, t, n) {
  const r = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(e / 2, 2) + Math.pow(t / 2, 2)) / 2)), i = Math.ceil(Math.max(n.curveStepCount, n.curveStepCount / Math.sqrt(200) * r)), a = Math.PI * 2 / i;
  let l = Math.abs(e / 2), s = Math.abs(t / 2);
  const c = 1 - n.curveFitting;
  return l += Ze(l * c, n), s += Ze(s * c, n), { increment: a, rx: l, ry: s };
}
function j4(e, t, n, r) {
  const [i, a] = Aw(r.increment, e, t, r.rx, r.ry, 1, r.increment * hm(0.1, hm(0.4, 1, n), n), n);
  let l = fm(i, null, n);
  if (!n.disableMultiStroke && n.roughness !== 0) {
    const [s] = Aw(r.increment, e, t, r.rx, r.ry, 1.5, 0, n), c = fm(s, null, n);
    l = l.concat(c);
  }
  return {
    estimatedPoints: a,
    opset: { type: "path", ops: l }
  };
}
function Cw(e, t, n, r, i, a, l, s, c) {
  const d = e, o = t;
  let u = Math.abs(n / 2), h = Math.abs(r / 2);
  u += Ze(u * 0.01, c), h += Ze(h * 0.01, c);
  let f = i, p = a;
  for (; f < 0; )
    f += Math.PI * 2, p += Math.PI * 2;
  p - f > Math.PI * 2 && (f = 0, p = Math.PI * 2);
  const g = Math.PI * 2 / c.curveStepCount, b = Math.min(g / 2, (p - f) / 2), v = Nw(b, d, o, u, h, f, p, 1, c);
  if (!c.disableMultiStroke) {
    const U = Nw(b, d, o, u, h, f, p, 1.5, c);
    v.push(...U);
  }
  return l && (s ? v.push(...gs(d, o, d + u * Math.cos(f), o + h * Math.sin(f), c), ...gs(d, o, d + u * Math.cos(p), o + h * Math.sin(p), c)) : v.push({ op: "lineTo", data: [d, o] }, { op: "lineTo", data: [d + u * Math.cos(f), o + h * Math.sin(f)] })), { type: "path", ops: v };
}
function Mw(e, t) {
  const n = dI(cI(o8(e))), r = [];
  let i = [0, 0], a = [0, 0];
  for (const { key: l, data: s } of n)
    switch (l) {
      case "M": {
        a = [s[0], s[1]], i = [s[0], s[1]];
        break;
      }
      case "L":
        r.push(...gs(a[0], a[1], s[0], s[1], t)), a = [s[0], s[1]];
        break;
      case "C": {
        const [c, d, o, u, h, f] = s;
        r.push(...Zj(c, d, o, u, h, f, a, t)), a = [h, f];
        break;
      }
      case "Z":
        r.push(...gs(a[0], a[1], i[0], i[1], t)), a = [i[0], i[1]];
        break;
    }
  return { type: "path", ops: r };
}
function O6(e, t) {
  const n = [];
  for (const r of e)
    if (r.length) {
      const i = t.maxRandomnessOffset || 0, a = r.length;
      if (a > 2) {
        n.push({ op: "move", data: [r[0][0] + Ze(i, t), r[0][1] + Ze(i, t)] });
        for (let l = 1; l < a; l++)
          n.push({ op: "lineTo", data: [r[l][0] + Ze(i, t), r[l][1] + Ze(i, t)] });
      }
    }
  return { type: "fillPath", ops: n };
}
function Id(e, t) {
  return Oj(t, Hj).fillPolygons(e, t);
}
function Gj(e, t, n, r, i, a, l) {
  const s = e, c = t;
  let d = Math.abs(n / 2), o = Math.abs(r / 2);
  d += Ze(d * 0.01, l), o += Ze(o * 0.01, l);
  let u = i, h = a;
  for (; u < 0; )
    u += Math.PI * 2, h += Math.PI * 2;
  h - u > Math.PI * 2 && (u = 0, h = Math.PI * 2);
  const f = (h - u) / l.curveStepCount, p = [];
  for (let g = u; g <= h; g = g + f)
    p.push([s + d * Math.cos(g), c + o * Math.sin(g)]);
  return p.push([s + d * Math.cos(h), c + o * Math.sin(h)]), p.push([s, c]), Id([p], l);
}
function jj(e, t) {
  return Ze(e, t);
}
function Kj(e, t, n) {
  return hm(e, t, n);
}
function Yj(e, t, n, r, i) {
  return gs(e, t, n, r, i, !0);
}
function qj(e) {
  const t = Object.assign({}, e);
  return t.randomizer = void 0, e.seed && (t.seed = e.seed + 1), t;
}
function pI(e) {
  return e.randomizer || (e.randomizer = new sI(e.seed || 0)), e.randomizer.next();
}
function hm(e, t, n, r = 1) {
  return n.roughness * r * (pI(n) * (t - e) + e);
}
function Ze(e, t, n = 1) {
  return hm(-e, e, t, n);
}
function gs(e, t, n, r, i, a = !1) {
  const l = a ? i.disableMultiStrokeFill : i.disableMultiStroke, s = Tw(e, t, n, r, i, !0, !1);
  if (l)
    return s;
  const c = Tw(e, t, n, r, i, !0, !0);
  return s.concat(c);
}
function Tw(e, t, n, r, i, a, l) {
  const s = Math.pow(e - n, 2) + Math.pow(t - r, 2), c = Math.sqrt(s);
  let d = 1;
  c < 200 ? d = 1 : c > 500 ? d = 0.4 : d = -16668e-7 * c + 1.233334;
  let o = i.maxRandomnessOffset || 0;
  o * o * 100 > s && (o = c / 10);
  const u = o / 2, h = 0.2 + pI(i) * 0.2;
  let f = i.bowing * i.maxRandomnessOffset * (r - t) / 200, p = i.bowing * i.maxRandomnessOffset * (e - n) / 200;
  f = Ze(f, i, d), p = Ze(p, i, d);
  const g = [], b = () => Ze(u, i, d), v = () => Ze(o, i, d), U = i.preserveVertices;
  return l ? g.push({
    op: "move",
    data: [
      e + (U ? 0 : b()),
      t + (U ? 0 : b())
    ]
  }) : g.push({
    op: "move",
    data: [
      e + (U ? 0 : Ze(o, i, d)),
      t + (U ? 0 : Ze(o, i, d))
    ]
  }), l ? g.push({
    op: "bcurveTo",
    data: [
      f + e + (n - e) * h + b(),
      p + t + (r - t) * h + b(),
      f + e + 2 * (n - e) * h + b(),
      p + t + 2 * (r - t) * h + b(),
      n + (U ? 0 : b()),
      r + (U ? 0 : b())
    ]
  }) : g.push({
    op: "bcurveTo",
    data: [
      f + e + (n - e) * h + v(),
      p + t + (r - t) * h + v(),
      f + e + 2 * (n - e) * h + v(),
      p + t + 2 * (r - t) * h + v(),
      n + (U ? 0 : v()),
      r + (U ? 0 : v())
    ]
  }), g;
}
function Iw(e, t, n) {
  const r = [];
  r.push([
    e[0][0] + Ze(t, n),
    e[0][1] + Ze(t, n)
  ]), r.push([
    e[0][0] + Ze(t, n),
    e[0][1] + Ze(t, n)
  ]);
  for (let i = 1; i < e.length; i++)
    r.push([
      e[i][0] + Ze(t, n),
      e[i][1] + Ze(t, n)
    ]), i === e.length - 1 && r.push([
      e[i][0] + Ze(t, n),
      e[i][1] + Ze(t, n)
    ]);
  return fm(r, null, n);
}
function fm(e, t, n) {
  const r = e.length, i = [];
  if (r > 3) {
    const a = [], l = 1 - n.curveTightness;
    i.push({ op: "move", data: [e[1][0], e[1][1]] });
    for (let s = 1; s + 2 < r; s++) {
      const c = e[s];
      a[0] = [c[0], c[1]], a[1] = [c[0] + (l * e[s + 1][0] - l * e[s - 1][0]) / 6, c[1] + (l * e[s + 1][1] - l * e[s - 1][1]) / 6], a[2] = [e[s + 1][0] + (l * e[s][0] - l * e[s + 2][0]) / 6, e[s + 1][1] + (l * e[s][1] - l * e[s + 2][1]) / 6], a[3] = [e[s + 1][0], e[s + 1][1]], i.push({ op: "bcurveTo", data: [a[1][0], a[1][1], a[2][0], a[2][1], a[3][0], a[3][1]] });
    }
  } else r === 3 ? (i.push({ op: "move", data: [e[1][0], e[1][1]] }), i.push({
    op: "bcurveTo",
    data: [
      e[1][0],
      e[1][1],
      e[2][0],
      e[2][1],
      e[2][0],
      e[2][1]
    ]
  })) : r === 2 && i.push(...gs(e[0][0], e[0][1], e[1][0], e[1][1], n));
  return i;
}
function Aw(e, t, n, r, i, a, l, s) {
  const c = s.roughness === 0, d = [], o = [];
  if (c) {
    e = e / 4, o.push([
      t + r * Math.cos(-e),
      n + i * Math.sin(-e)
    ]);
    for (let u = 0; u <= Math.PI * 2; u = u + e) {
      const h = [
        t + r * Math.cos(u),
        n + i * Math.sin(u)
      ];
      d.push(h), o.push(h);
    }
    o.push([
      t + r * Math.cos(0),
      n + i * Math.sin(0)
    ]), o.push([
      t + r * Math.cos(e),
      n + i * Math.sin(e)
    ]);
  } else {
    const u = Ze(0.5, s) - Math.PI / 2;
    o.push([
      Ze(a, s) + t + 0.9 * r * Math.cos(u - e),
      Ze(a, s) + n + 0.9 * i * Math.sin(u - e)
    ]);
    const h = Math.PI * 2 + u - 0.01;
    for (let f = u; f < h; f = f + e) {
      const p = [
        Ze(a, s) + t + r * Math.cos(f),
        Ze(a, s) + n + i * Math.sin(f)
      ];
      d.push(p), o.push(p);
    }
    o.push([
      Ze(a, s) + t + r * Math.cos(u + Math.PI * 2 + l * 0.5),
      Ze(a, s) + n + i * Math.sin(u + Math.PI * 2 + l * 0.5)
    ]), o.push([
      Ze(a, s) + t + 0.98 * r * Math.cos(u + l),
      Ze(a, s) + n + 0.98 * i * Math.sin(u + l)
    ]), o.push([
      Ze(a, s) + t + 0.9 * r * Math.cos(u + l * 0.5),
      Ze(a, s) + n + 0.9 * i * Math.sin(u + l * 0.5)
    ]);
  }
  return [o, d];
}
function Nw(e, t, n, r, i, a, l, s, c) {
  const d = a + Ze(0.1, c), o = [];
  o.push([
    Ze(s, c) + t + 0.9 * r * Math.cos(d - e),
    Ze(s, c) + n + 0.9 * i * Math.sin(d - e)
  ]);
  for (let u = d; u <= l; u = u + e)
    o.push([
      Ze(s, c) + t + r * Math.cos(u),
      Ze(s, c) + n + i * Math.sin(u)
    ]);
  return o.push([
    t + r * Math.cos(l),
    n + i * Math.sin(l)
  ]), o.push([
    t + r * Math.cos(l),
    n + i * Math.sin(l)
  ]), fm(o, null, c);
}
function Zj(e, t, n, r, i, a, l, s) {
  const c = [], d = [s.maxRandomnessOffset || 1, (s.maxRandomnessOffset || 1) + 0.3];
  let o = [0, 0];
  const u = s.disableMultiStroke ? 1 : 2, h = s.preserveVertices;
  for (let f = 0; f < u; f++)
    f === 0 ? c.push({ op: "move", data: [l[0], l[1]] }) : c.push({ op: "move", data: [l[0] + (h ? 0 : Ze(d[0], s)), l[1] + (h ? 0 : Ze(d[0], s))] }), o = h ? [i, a] : [i + Ze(d[f], s), a + Ze(d[f], s)], c.push({
      op: "bcurveTo",
      data: [
        e + Ze(d[f], s),
        t + Ze(d[f], s),
        n + Ze(d[f], s),
        r + Ze(d[f], s),
        o[0],
        o[1]
      ]
    });
  return c;
}
function bu(e) {
  return [...e];
}
function Jj(e, t = 0) {
  const n = e.length;
  if (n < 3)
    throw new Error("A curve must have at least three points.");
  const r = [];
  if (n === 3)
    r.push(bu(e[0]), bu(e[1]), bu(e[2]), bu(e[2]));
  else {
    const i = [];
    i.push(e[0], e[0]);
    for (let s = 1; s < e.length; s++)
      i.push(e[s]), s === e.length - 1 && i.push(e[s]);
    const a = [], l = 1 - t;
    r.push(bu(i[0]));
    for (let s = 1; s + 2 < i.length; s++) {
      const c = i[s];
      a[0] = [c[0], c[1]], a[1] = [c[0] + (l * i[s + 1][0] - l * i[s - 1][0]) / 6, c[1] + (l * i[s + 1][1] - l * i[s - 1][1]) / 6], a[2] = [i[s + 1][0] + (l * i[s][0] - l * i[s + 2][0]) / 6, i[s + 1][1] + (l * i[s][1] - l * i[s + 2][1]) / 6], a[3] = [i[s + 1][0], i[s + 1][1]], r.push(a[1], a[2], a[3]);
    }
  }
  return r;
}
function Qj(e, t) {
  return Math.sqrt(op(e, t));
}
function op(e, t) {
  return Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2);
}
function eK(e, t, n) {
  const r = op(t, n);
  if (r === 0)
    return op(e, t);
  let i = ((e[0] - t[0]) * (n[0] - t[0]) + (e[1] - t[1]) * (n[1] - t[1])) / r;
  return i = Math.max(0, Math.min(1, i)), op(e, Zo(t, n, i));
}
function Zo(e, t, n) {
  return [
    e[0] + (t[0] - e[0]) * n,
    e[1] + (t[1] - e[1]) * n
  ];
}
function tK(e, t) {
  const n = e[t + 0], r = e[t + 1], i = e[t + 2], a = e[t + 3];
  let l = 3 * r[0] - 2 * n[0] - a[0];
  l *= l;
  let s = 3 * r[1] - 2 * n[1] - a[1];
  s *= s;
  let c = 3 * i[0] - 2 * a[0] - n[0];
  c *= c;
  let d = 3 * i[1] - 2 * a[1] - n[1];
  return d *= d, l < c && (l = c), s < d && (s = d), l + s;
}
function K4(e, t, n, r) {
  const i = r || [];
  if (tK(e, t) < n) {
    const a = e[t + 0];
    i.length ? Qj(i[i.length - 1], a) > 1 && i.push(a) : i.push(a), i.push(e[t + 3]);
  } else {
    const l = e[t + 0], s = e[t + 1], c = e[t + 2], d = e[t + 3], o = Zo(l, s, 0.5), u = Zo(s, c, 0.5), h = Zo(c, d, 0.5), f = Zo(o, u, 0.5), p = Zo(u, h, 0.5), g = Zo(f, p, 0.5);
    K4([l, o, f, g], 0, n, i), K4([g, p, h, d], 0, n, i);
  }
  return i;
}
function Y4(e, t, n, r, i) {
  const a = i || [], l = e[t], s = e[n - 1];
  let c = 0, d = 1;
  for (let o = t + 1; o < n - 1; ++o) {
    const u = eK(e[o], l, s);
    u > c && (c = u, d = o);
  }
  return Math.sqrt(c) > r ? (Y4(e, t, d + 1, r, a), Y4(e, d, n, r, a)) : (a.length || a.push(l), a.push(s)), a;
}
function nK(e, t = 0.15, n) {
  const r = [], i = (e.length - 1) / 3;
  for (let a = 0; a < i; a++) {
    const l = a * 3;
    K4(e, l, t, r);
  }
  return n && n > 0 ? Y4(r, 0, r.length, n) : r;
}
function rK(e, t) {
  return Math.sqrt(cp(e, t));
}
function cp(e, t) {
  return Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2);
}
function iK(e, t, n) {
  const r = cp(t, n);
  if (r === 0)
    return cp(e, t);
  let i = ((e[0] - t[0]) * (n[0] - t[0]) + (e[1] - t[1]) * (n[1] - t[1])) / r;
  return i = Math.max(0, Math.min(1, i)), cp(e, Jo(t, n, i));
}
function Jo(e, t, n) {
  return [
    e[0] + (t[0] - e[0]) * n,
    e[1] + (t[1] - e[1]) * n
  ];
}
function aK(e, t) {
  const n = e[t + 0], r = e[t + 1], i = e[t + 2], a = e[t + 3];
  let l = 3 * r[0] - 2 * n[0] - a[0];
  l *= l;
  let s = 3 * r[1] - 2 * n[1] - a[1];
  s *= s;
  let c = 3 * i[0] - 2 * a[0] - n[0];
  c *= c;
  let d = 3 * i[1] - 2 * a[1] - n[1];
  return d *= d, l < c && (l = c), s < d && (s = d), l + s;
}
function q4(e, t, n, r) {
  const i = r || [];
  if (aK(e, t) < n) {
    const a = e[t + 0];
    i.length ? rK(i[i.length - 1], a) > 1 && i.push(a) : i.push(a), i.push(e[t + 3]);
  } else {
    const l = e[t + 0], s = e[t + 1], c = e[t + 2], d = e[t + 3], o = Jo(l, s, 0.5), u = Jo(s, c, 0.5), h = Jo(c, d, 0.5), f = Jo(o, u, 0.5), p = Jo(u, h, 0.5), g = Jo(f, p, 0.5);
    q4([l, o, f, g], 0, n, i), q4([g, p, h, d], 0, n, i);
  }
  return i;
}
function lK(e, t) {
  return Z4(e, 0, e.length, t);
}
function Z4(e, t, n, r, i) {
  const a = i || [], l = e[t], s = e[n - 1];
  let c = 0, d = 1;
  for (let o = t + 1; o < n - 1; ++o) {
    const u = iK(e[o], l, s);
    u > c && (c = u, d = o);
  }
  return Math.sqrt(c) > r ? (Z4(e, t, d + 1, r, a), Z4(e, d, n, r, a)) : (a.length || a.push(l), a.push(s)), a;
}
function sK(e, t = 0.15, n) {
  const r = [], i = (e.length - 1) / 3;
  for (let a = 0; a < i; a++) {
    const l = a * 3;
    q4(e, l, t, r);
  }
  return r;
}
function oK(e, t, n) {
  const r = o8(e), i = dI(cI(r)), a = [];
  let l = [], s = [0, 0], c = [];
  const d = () => {
    c.length >= 4 && l.push(...sK(c, t)), c = [];
  }, o = () => {
    d(), l.length && (a.push(l), l = []);
  };
  for (const { key: h, data: f } of i)
    switch (h) {
      case "M":
        o(), s = [f[0], f[1]], l.push(s);
        break;
      case "L":
        d(), l.push([f[0], f[1]]);
        break;
      case "C":
        if (!c.length) {
          const p = l.length ? l[l.length - 1] : s;
          c.push([p[0], p[1]]);
        }
        c.push([f[0], f[1]]), c.push([f[2], f[3]]), c.push([f[4], f[5]]);
        break;
      case "Z":
        d(), l.push([s[0], s[1]]);
        break;
    }
  if (o(), !n)
    return a;
  const u = [];
  for (const h of a) {
    const f = lK(h, n);
    f.length && u.push(f);
  }
  return u;
}
const gi = "none";
class Xh {
  constructor(t) {
    this.defaultOptions = {
      maxRandomnessOffset: 2,
      roughness: 1,
      bowing: 1,
      stroke: "#000",
      strokeWidth: 1,
      curveTightness: 0,
      curveFitting: 0.95,
      curveStepCount: 9,
      fillStyle: "hachure",
      fillWeight: -1,
      hachureAngle: -41,
      hachureGap: -1,
      dashOffset: -1,
      dashGap: -1,
      zigzagOffset: -1,
      seed: 0,
      disableMultiStroke: !1,
      disableMultiStrokeFill: !1,
      preserveVertices: !1,
      fillShapeRoughnessGain: 0.8
    }, this.config = t || {}, this.config.options && (this.defaultOptions = this._o(this.config.options));
  }
  static newSeed() {
    return $j();
  }
  _o(t) {
    return t ? Object.assign({}, this.defaultOptions, t) : this.defaultOptions;
  }
  _d(t, n, r) {
    return { shape: t, sets: n || [], options: r || this.defaultOptions };
  }
  line(t, n, r, i, a) {
    const l = this._o(a);
    return this._d("line", [hI(t, n, r, i, l)], l);
  }
  rectangle(t, n, r, i, a) {
    const l = this._o(a), s = [], c = Xj(t, n, r, i, l);
    if (l.fill) {
      const d = [[t, n], [t + r, n], [t + r, n + i], [t, n + i]];
      l.fillStyle === "solid" ? s.push(O6([d], l)) : s.push(Id([d], l));
    }
    return l.stroke !== gi && s.push(c), this._d("rectangle", s, l);
  }
  ellipse(t, n, r, i, a) {
    const l = this._o(a), s = [], c = fI(r, i, l), d = j4(t, n, l, c);
    if (l.fill)
      if (l.fillStyle === "solid") {
        const o = j4(t, n, l, c).opset;
        o.type = "fillPath", s.push(o);
      } else
        s.push(Id([d.estimatedPoints], l));
    return l.stroke !== gi && s.push(d.opset), this._d("ellipse", s, l);
  }
  circle(t, n, r, i) {
    const a = this.ellipse(t, n, r, r, i);
    return a.shape = "circle", a;
  }
  linearPath(t, n) {
    const r = this._o(n);
    return this._d("linearPath", [sp(t, !1, r)], r);
  }
  arc(t, n, r, i, a, l, s = !1, c) {
    const d = this._o(c), o = [], u = Cw(t, n, r, i, a, l, s, !0, d);
    if (s && d.fill)
      if (d.fillStyle === "solid") {
        const h = Object.assign({}, d);
        h.disableMultiStroke = !0;
        const f = Cw(t, n, r, i, a, l, !0, !1, h);
        f.type = "fillPath", o.push(f);
      } else
        o.push(Gj(t, n, r, i, a, l, d));
    return d.stroke !== gi && o.push(u), this._d("arc", o, d);
  }
  curve(t, n) {
    const r = this._o(n), i = [], a = kw(t, r);
    if (r.fill && r.fill !== gi && t.length >= 3)
      if (r.fillStyle === "solid") {
        const l = kw(t, Object.assign(Object.assign({}, r), { disableMultiStroke: !0, roughness: r.roughness ? r.roughness + r.fillShapeRoughnessGain : 0 }));
        i.push({
          type: "fillPath",
          ops: this._mergedShape(l.ops)
        });
      } else {
        const l = Jj(t), s = nK(l, 10, (1 + r.roughness) / 2);
        i.push(Id([s], r));
      }
    return r.stroke !== gi && i.push(a), this._d("curve", i, r);
  }
  polygon(t, n) {
    const r = this._o(n), i = [], a = sp(t, !0, r);
    return r.fill && (r.fillStyle === "solid" ? i.push(O6([t], r)) : i.push(Id([t], r))), r.stroke !== gi && i.push(a), this._d("polygon", i, r);
  }
  path(t, n) {
    const r = this._o(n), i = [];
    if (!t)
      return this._d("path", i, r);
    t = (t || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
    const a = r.fill && r.fill !== "transparent" && r.fill !== gi, l = r.stroke !== gi, s = !!(r.simplification && r.simplification < 1), c = s ? 4 - 4 * (r.simplification || 1) : (1 + r.roughness) / 2, d = oK(t, 1, c), o = Mw(t, r);
    if (a)
      if (r.fillStyle === "solid")
        if (d.length === 1) {
          const u = Mw(t, Object.assign(Object.assign({}, r), { disableMultiStroke: !0, roughness: r.roughness ? r.roughness + r.fillShapeRoughnessGain : 0 }));
          i.push({
            type: "fillPath",
            ops: this._mergedShape(u.ops)
          });
        } else
          i.push(O6(d, r));
      else
        i.push(Id(d, r));
    return l && (s ? d.forEach((u) => {
      i.push(sp(u, !1, r));
    }) : i.push(o)), this._d("path", i, r);
  }
  opsToPath(t, n) {
    let r = "";
    for (const i of t.ops) {
      const a = typeof n == "number" && n >= 0 ? i.data.map((l) => +l.toFixed(n)) : i.data;
      switch (i.op) {
        case "move":
          r += `M${a[0]} ${a[1]} `;
          break;
        case "bcurveTo":
          r += `C${a[0]} ${a[1]}, ${a[2]} ${a[3]}, ${a[4]} ${a[5]} `;
          break;
        case "lineTo":
          r += `L${a[0]} ${a[1]} `;
          break;
      }
    }
    return r.trim();
  }
  toPaths(t) {
    const n = t.sets || [], r = t.options || this.defaultOptions, i = [];
    for (const a of n) {
      let l = null;
      switch (a.type) {
        case "path":
          l = {
            d: this.opsToPath(a),
            stroke: r.stroke,
            strokeWidth: r.strokeWidth,
            fill: gi
          };
          break;
        case "fillPath":
          l = {
            d: this.opsToPath(a),
            stroke: gi,
            strokeWidth: 0,
            fill: r.fill || gi
          };
          break;
        case "fillSketch":
          l = this.fillSketch(a, r);
          break;
      }
      l && i.push(l);
    }
    return i;
  }
  fillSketch(t, n) {
    let r = n.fillWeight;
    return r < 0 && (r = n.strokeWidth / 2), {
      d: this.opsToPath(t),
      stroke: n.fill || gi,
      strokeWidth: r,
      fill: gi
    };
  }
  _mergedShape(t) {
    return t.filter((n, r) => r === 0 ? !0 : n.op !== "move");
  }
}
class cK {
  constructor(t, n) {
    this.canvas = t, this.ctx = this.canvas.getContext("2d"), this.gen = new Xh(n);
  }
  draw(t) {
    const n = t.sets || [], r = t.options || this.getDefaultOptions(), i = this.ctx, a = t.options.fixedDecimalPlaceDigits;
    for (const l of n)
      switch (l.type) {
        case "path":
          i.save(), i.strokeStyle = r.stroke === "none" ? "transparent" : r.stroke, i.lineWidth = r.strokeWidth, r.strokeLineDash && i.setLineDash(r.strokeLineDash), r.strokeLineDashOffset && (i.lineDashOffset = r.strokeLineDashOffset), this._drawToContext(i, l, a), i.restore();
          break;
        case "fillPath": {
          i.save(), i.fillStyle = r.fill || "";
          const s = t.shape === "curve" || t.shape === "polygon" || t.shape === "path" ? "evenodd" : "nonzero";
          this._drawToContext(i, l, a, s), i.restore();
          break;
        }
        case "fillSketch":
          this.fillSketch(i, l, r);
          break;
      }
  }
  fillSketch(t, n, r) {
    let i = r.fillWeight;
    i < 0 && (i = r.strokeWidth / 2), t.save(), r.fillLineDash && t.setLineDash(r.fillLineDash), r.fillLineDashOffset && (t.lineDashOffset = r.fillLineDashOffset), t.strokeStyle = r.fill || "", t.lineWidth = i, this._drawToContext(t, n, r.fixedDecimalPlaceDigits), t.restore();
  }
  _drawToContext(t, n, r, i = "nonzero") {
    t.beginPath();
    for (const a of n.ops) {
      const l = typeof r == "number" && r >= 0 ? a.data.map((s) => +s.toFixed(r)) : a.data;
      switch (a.op) {
        case "move":
          t.moveTo(l[0], l[1]);
          break;
        case "bcurveTo":
          t.bezierCurveTo(l[0], l[1], l[2], l[3], l[4], l[5]);
          break;
        case "lineTo":
          t.lineTo(l[0], l[1]);
          break;
      }
    }
    n.type === "fillPath" ? t.fill(i) : t.stroke();
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  line(t, n, r, i, a) {
    const l = this.gen.line(t, n, r, i, a);
    return this.draw(l), l;
  }
  rectangle(t, n, r, i, a) {
    const l = this.gen.rectangle(t, n, r, i, a);
    return this.draw(l), l;
  }
  ellipse(t, n, r, i, a) {
    const l = this.gen.ellipse(t, n, r, i, a);
    return this.draw(l), l;
  }
  circle(t, n, r, i) {
    const a = this.gen.circle(t, n, r, i);
    return this.draw(a), a;
  }
  linearPath(t, n) {
    const r = this.gen.linearPath(t, n);
    return this.draw(r), r;
  }
  polygon(t, n) {
    const r = this.gen.polygon(t, n);
    return this.draw(r), r;
  }
  arc(t, n, r, i, a, l, s = !1, c) {
    const d = this.gen.arc(t, n, r, i, a, l, s, c);
    return this.draw(d), d;
  }
  curve(t, n) {
    const r = this.gen.curve(t, n);
    return this.draw(r), r;
  }
  path(t, n) {
    const r = this.gen.path(t, n);
    return this.draw(r), r;
  }
}
const M1 = "http://www.w3.org/2000/svg";
class dK {
  constructor(t, n) {
    this.svg = t, this.gen = new Xh(n);
  }
  draw(t) {
    const n = t.sets || [], r = t.options || this.getDefaultOptions(), i = this.svg.ownerDocument || window.document, a = i.createElementNS(M1, "g"), l = t.options.fixedDecimalPlaceDigits;
    for (const s of n) {
      let c = null;
      switch (s.type) {
        case "path": {
          c = i.createElementNS(M1, "path"), c.setAttribute("d", this.opsToPath(s, l)), c.setAttribute("stroke", r.stroke), c.setAttribute("stroke-width", r.strokeWidth + ""), c.setAttribute("fill", "none"), r.strokeLineDash && c.setAttribute("stroke-dasharray", r.strokeLineDash.join(" ").trim()), r.strokeLineDashOffset && c.setAttribute("stroke-dashoffset", `${r.strokeLineDashOffset}`);
          break;
        }
        case "fillPath": {
          c = i.createElementNS(M1, "path"), c.setAttribute("d", this.opsToPath(s, l)), c.setAttribute("stroke", "none"), c.setAttribute("stroke-width", "0"), c.setAttribute("fill", r.fill || ""), (t.shape === "curve" || t.shape === "polygon") && c.setAttribute("fill-rule", "evenodd");
          break;
        }
        case "fillSketch": {
          c = this.fillSketch(i, s, r);
          break;
        }
      }
      c && a.appendChild(c);
    }
    return a;
  }
  fillSketch(t, n, r) {
    let i = r.fillWeight;
    i < 0 && (i = r.strokeWidth / 2);
    const a = t.createElementNS(M1, "path");
    return a.setAttribute("d", this.opsToPath(n, r.fixedDecimalPlaceDigits)), a.setAttribute("stroke", r.fill || ""), a.setAttribute("stroke-width", i + ""), a.setAttribute("fill", "none"), r.fillLineDash && a.setAttribute("stroke-dasharray", r.fillLineDash.join(" ").trim()), r.fillLineDashOffset && a.setAttribute("stroke-dashoffset", `${r.fillLineDashOffset}`), a;
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  opsToPath(t, n) {
    return this.gen.opsToPath(t, n);
  }
  line(t, n, r, i, a) {
    const l = this.gen.line(t, n, r, i, a);
    return this.draw(l);
  }
  rectangle(t, n, r, i, a) {
    const l = this.gen.rectangle(t, n, r, i, a);
    return this.draw(l);
  }
  ellipse(t, n, r, i, a) {
    const l = this.gen.ellipse(t, n, r, i, a);
    return this.draw(l);
  }
  circle(t, n, r, i) {
    const a = this.gen.circle(t, n, r, i);
    return this.draw(a);
  }
  linearPath(t, n) {
    const r = this.gen.linearPath(t, n);
    return this.draw(r);
  }
  polygon(t, n) {
    const r = this.gen.polygon(t, n);
    return this.draw(r);
  }
  arc(t, n, r, i, a, l, s = !1, c) {
    const d = this.gen.arc(t, n, r, i, a, l, s, c);
    return this.draw(d);
  }
  curve(t, n) {
    const r = this.gen.curve(t, n);
    return this.draw(r);
  }
  path(t, n) {
    const r = this.gen.path(t, n);
    return this.draw(r);
  }
}
const Po = {
  canvas(e, t) {
    return new cK(e, t);
  },
  svg(e, t) {
    return new dK(e, t);
  },
  generator(e) {
    return new Xh(e);
  },
  newSeed() {
    return Xh.newSeed();
  }
};
function Dw(e, t, n, r = (i) => i) {
  return e * r(0.5 - t * (0.5 - n));
}
function uK(e) {
  return [-e[0], -e[1]];
}
function ma(e, t) {
  return [e[0] + t[0], e[1] + t[1]];
}
function Oi(e, t) {
  return [e[0] - t[0], e[1] - t[1]];
}
function ha(e, t) {
  return [e[0] * t, e[1] * t];
}
function hK(e, t) {
  return [e[0] / t, e[1] / t];
}
function Uu(e) {
  return [e[1], -e[0]];
}
function Lw(e, t) {
  return e[0] * t[0] + e[1] * t[1];
}
function fK(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}
function pK(e) {
  return Math.hypot(e[0], e[1]);
}
function mK(e) {
  return e[0] * e[0] + e[1] * e[1];
}
function Rw(e, t) {
  return mK(Oi(e, t));
}
function mI(e) {
  return hK(e, pK(e));
}
function gK(e, t) {
  return Math.hypot(e[1] - t[1], e[0] - t[0]);
}
function vu(e, t, n) {
  let r = Math.sin(n), i = Math.cos(n), a = e[0] - t[0], l = e[1] - t[1], s = a * i - l * r, c = a * r + l * i;
  return [s + t[0], c + t[1]];
}
function J4(e, t, n) {
  return ma(e, ha(Oi(t, e), n));
}
function Pw(e, t, n) {
  return ma(e, ha(t, n));
}
var { min: Ud, PI: bK } = Math, Ow = 0.275, yu = bK + 1e-4;
function UK(e, t = {}) {
  let { size: n = 16, smoothing: r = 0.5, thinning: i = 0.5, simulatePressure: a = !0, easing: l = (B) => B, start: s = {}, end: c = {}, last: d = !1 } = t, { cap: o = !0, easing: u = (B) => B * (2 - B) } = s, { cap: h = !0, easing: f = (B) => --B * B * B + 1 } = c;
  if (e.length === 0 || n <= 0) return [];
  let p = e[e.length - 1].runningLength, g = s.taper === !1 ? 0 : s.taper === !0 ? Math.max(n, p) : s.taper, b = c.taper === !1 ? 0 : c.taper === !0 ? Math.max(n, p) : c.taper, v = Math.pow(n * r, 2), U = [], y = [], w = e.slice(0, 10).reduce((B, j) => {
    let V = j.pressure;
    if (a) {
      let q = Ud(1, j.distance / n), oe = Ud(1, 1 - q);
      V = Ud(1, B + (oe - B) * (q * Ow));
    }
    return (B + V) / 2;
  }, e[0].pressure), x = Dw(n, i, e[e.length - 1].pressure, l), E, S = e[0].vector, _ = e[0].point, k = _, M = _, A = k, L = !1;
  for (let B = 0; B < e.length; B++) {
    let { pressure: j } = e[B], { point: V, vector: q, distance: oe, runningLength: Ue } = e[B];
    if (B < e.length - 1 && p - Ue < 3) continue;
    if (i) {
      if (a) {
        let Je = Ud(1, oe / n), mt = Ud(1, 1 - Je);
        j = Ud(1, w + (mt - w) * (Je * Ow));
      }
      x = Dw(n, i, j, l);
    } else x = n / 2;
    E === void 0 && (E = x);
    let fe = Ue < g ? u(Ue / g) : 1, Pe = p - Ue < b ? f((p - Ue) / b) : 1;
    x = Math.max(0.01, x * Math.min(fe, Pe));
    let ze = (B < e.length - 1 ? e[B + 1] : e[B]).vector, Oe = B < e.length - 1 ? Lw(q, ze) : 1, Be = Lw(q, S) < 0 && !L, qe = Oe !== null && Oe < 0;
    if (Be || qe) {
      let Je = ha(Uu(S), x);
      for (let mt = 1 / 13, jt = 0; jt <= 1; jt += mt) M = vu(Oi(V, Je), V, yu * jt), U.push(M), A = vu(ma(V, Je), V, yu * -jt), y.push(A);
      _ = M, k = A, qe && (L = !0);
      continue;
    }
    if (L = !1, B === e.length - 1) {
      let Je = ha(Uu(q), x);
      U.push(Oi(V, Je)), y.push(ma(V, Je));
      continue;
    }
    let At = ha(Uu(J4(ze, q, Oe)), x);
    M = Oi(V, At), (B <= 1 || Rw(_, M) > v) && (U.push(M), _ = M), A = ma(V, At), (B <= 1 || Rw(k, A) > v) && (y.push(A), k = A), w = j, S = q;
  }
  let R = e[0].point.slice(0, 2), z = e.length > 1 ? e[e.length - 1].point.slice(0, 2) : ma(e[0].point, [1, 1]), F = [], W = [];
  if (e.length === 1) {
    if (!(g || b) || d) {
      let B = Pw(R, mI(Uu(Oi(R, z))), -(E || x)), j = [];
      for (let V = 1 / 13, q = V; q <= 1; q += V) j.push(vu(B, R, yu * 2 * q));
      return j;
    }
  } else {
    if (!(g || b && e.length === 1)) if (o) for (let j = 1 / 13, V = j; V <= 1; V += j) {
      let q = vu(y[0], R, yu * V);
      F.push(q);
    }
    else {
      let j = Oi(U[0], y[0]), V = ha(j, 0.5), q = ha(j, 0.51);
      F.push(Oi(R, V), Oi(R, q), ma(R, q), ma(R, V));
    }
    let B = Uu(uK(e[e.length - 1].vector));
    if (b || g && e.length === 1) W.push(z);
    else if (h) {
      let j = Pw(z, B, x);
      for (let V = 1 / 29, q = V; q < 1; q += V) W.push(vu(j, z, yu * 3 * q));
    } else W.push(ma(z, ha(B, x)), ma(z, ha(B, x * 0.99)), Oi(z, ha(B, x * 0.99)), Oi(z, ha(B, x)));
  }
  return U.concat(W, y.reverse(), F);
}
function vK(e, t = {}) {
  var n;
  let { streamline: r = 0.5, size: i = 16, last: a = !1 } = t;
  if (e.length === 0) return [];
  let l = 0.15 + (1 - r) * 0.85, s = Array.isArray(e[0]) ? e : e.map(({ x: f, y: p, pressure: g = 0.5 }) => [f, p, g]);
  if (s.length === 2) {
    let f = s[1];
    s = s.slice(0, -1);
    for (let p = 1; p < 5; p++) s.push(J4(s[0], f, p / 4));
  }
  s.length === 1 && (s = [...s, [...ma(s[0], [1, 1]), ...s[0].slice(2)]]);
  let c = [{ point: [s[0][0], s[0][1]], pressure: s[0][2] >= 0 ? s[0][2] : 0.25, vector: [1, 1], distance: 0, runningLength: 0 }], d = !1, o = 0, u = c[0], h = s.length - 1;
  for (let f = 1; f < s.length; f++) {
    let p = a && f === h ? s[f].slice(0, 2) : J4(u.point, s[f], l);
    if (fK(u.point, p)) continue;
    let g = gK(p, u.point);
    if (o += g, f < h && !d) {
      if (o < i) continue;
      d = !0;
    }
    u = { point: p, pressure: s[f][2] >= 0 ? s[f][2] : 0.5, vector: mI(Oi(u.point, p)), distance: g, runningLength: o }, c.push(u);
  }
  return c[0].vector = ((n = c[1]) == null ? void 0 : n.vector) || [0, 0], c;
}
function yK(e, t = {}) {
  return UK(vK(e, t), t);
}
function gI(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number")
    r += e;
  else if (typeof e == "object")
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (n = gI(e[t])) && (r && (r += " "), r += n);
    else
      for (t in e)
        e[t] && (r && (r += " "), r += t);
  return r;
}
function Me() {
  for (var e = 0, t, n, r = ""; e < arguments.length; )
    (t = arguments[e++]) && (n = gI(t)) && (r && (r += " "), r += n);
  return r;
}
function wK(e, t) {
  return Math.sqrt(dp(e, t));
}
function dp(e, t) {
  return Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2);
}
function xK(e, t, n) {
  const r = dp(t, n);
  if (r === 0)
    return dp(e, t);
  let i = ((e[0] - t[0]) * (n[0] - t[0]) + (e[1] - t[1]) * (n[1] - t[1])) / r;
  return i = Math.max(0, Math.min(1, i)), dp(e, Qo(t, n, i));
}
function Qo(e, t, n) {
  return [
    e[0] + (t[0] - e[0]) * n,
    e[1] + (t[1] - e[1]) * n
  ];
}
function EK(e, t) {
  const n = e[t + 0], r = e[t + 1], i = e[t + 2], a = e[t + 3];
  let l = 3 * r[0] - 2 * n[0] - a[0];
  l *= l;
  let s = 3 * r[1] - 2 * n[1] - a[1];
  s *= s;
  let c = 3 * i[0] - 2 * a[0] - n[0];
  c *= c;
  let d = 3 * i[1] - 2 * a[1] - n[1];
  return d *= d, l < c && (l = c), s < d && (s = d), l + s;
}
function Q4(e, t, n, r) {
  const i = r || [];
  if (EK(e, t) < n) {
    const a = e[t + 0];
    i.length ? wK(i[i.length - 1], a) > 1 && i.push(a) : i.push(a), i.push(e[t + 3]);
  } else {
    const l = e[t + 0], s = e[t + 1], c = e[t + 2], d = e[t + 3], o = Qo(l, s, 0.5), u = Qo(s, c, 0.5), h = Qo(c, d, 0.5), f = Qo(o, u, 0.5), p = Qo(u, h, 0.5), g = Qo(f, p, 0.5);
    Q4([l, o, f, g], 0, n, i), Q4([g, p, h, d], 0, n, i);
  }
  return i;
}
function SK(e, t) {
  return pm(e, 0, e.length, t);
}
function pm(e, t, n, r, i) {
  const a = i || [], l = e[t], s = e[n - 1];
  let c = 0, d = 1;
  for (let o = t + 1; o < n - 1; ++o) {
    const u = xK(e[o], l, s);
    u > c && (c = u, d = o);
  }
  return Math.sqrt(c) > r ? (pm(e, t, d + 1, r, a), pm(e, d, n, r, a)) : (a.length || a.push(l), a.push(s)), a;
}
function _K(e, t = 0.15, n) {
  const r = [], i = (e.length - 1) / 3;
  for (let a = 0; a < i; a++) {
    const l = a * 3;
    Q4(e, l, t, r);
  }
  return pm(r, 0, r.length, n);
}
var c8 = {};
Object.defineProperty(c8, "__esModule", { value: !0 });
var bI = c8.sanitizeUrl = void 0, kK = /^([^\w]*)(javascript|data|vbscript)/im, CK = /&#(\w+)(^\w|;)?/g, MK = /&(newline|tab);/gi, TK = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim, IK = /^.+(:|&colon;)/gim, AK = [".", "/"];
function NK(e) {
  return AK.indexOf(e[0]) > -1;
}
function DK(e) {
  return e.replace(CK, function(t, n) {
    return String.fromCharCode(n);
  });
}
function LK(e) {
  var t = DK(e || "").replace(MK, "").replace(TK, "").trim();
  if (!t)
    return "about:blank";
  if (NK(t))
    return t;
  var n = t.match(IK);
  if (!n)
    return t;
  var r = n[0];
  return kK.test(r) ? "about:blank" : t;
}
bI = c8.sanitizeUrl = LK;
const UI = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
function Pd(e, t, n) {
  const r = n[0];
  if (t != null && e >= t)
    throw new Error(e + " >= " + t);
  if (e.slice(-1) === r || t && t.slice(-1) === r)
    throw new Error("trailing zero");
  if (t) {
    let l = 0;
    for (; (e[l] || r) === t[l]; )
      l++;
    if (l > 0)
      return t.slice(0, l) + Pd(e.slice(l), t.slice(l), n);
  }
  const i = e ? n.indexOf(e[0]) : 0, a = t != null ? n.indexOf(t[0]) : n.length;
  if (a - i > 1) {
    const l = Math.round(0.5 * (i + a));
    return n[l];
  } else
    return t && t.length > 1 ? t.slice(0, 1) : n[i] + Pd(e.slice(1), null, n);
}
function vI(e) {
  if (e.length !== yI(e[0]))
    throw new Error("invalid integer part of order key: " + e);
}
function yI(e) {
  if (e >= "a" && e <= "z")
    return e.charCodeAt(0) - 97 + 2;
  if (e >= "A" && e <= "Z")
    return 90 - e.charCodeAt(0) + 2;
  throw new Error("invalid order key head: " + e);
}
function Xu(e) {
  const t = yI(e[0]);
  if (t > e.length)
    throw new Error("invalid order key: " + e);
  return e.slice(0, t);
}
function $w(e, t) {
  if (e === "A" + t[0].repeat(26))
    throw new Error("invalid order key: " + e);
  const n = Xu(e);
  if (e.slice(n.length).slice(-1) === t[0])
    throw new Error("invalid order key: " + e);
}
function Fw(e, t) {
  vI(e);
  const [n, ...r] = e.split("");
  let i = !0;
  for (let a = r.length - 1; i && a >= 0; a--) {
    const l = t.indexOf(r[a]) + 1;
    l === t.length ? r[a] = t[0] : (r[a] = t[l], i = !1);
  }
  if (i) {
    if (n === "Z")
      return "a" + t[0];
    if (n === "z")
      return null;
    const a = String.fromCharCode(n.charCodeAt(0) + 1);
    return a > "a" ? r.push(t[0]) : r.pop(), a + r.join("");
  } else
    return n + r.join("");
}
function RK(e, t) {
  vI(e);
  const [n, ...r] = e.split("");
  let i = !0;
  for (let a = r.length - 1; i && a >= 0; a--) {
    const l = t.indexOf(r[a]) - 1;
    l === -1 ? r[a] = t.slice(-1) : (r[a] = t[l], i = !1);
  }
  if (i) {
    if (n === "a")
      return "Z" + t.slice(-1);
    if (n === "A")
      return null;
    const a = String.fromCharCode(n.charCodeAt(0) - 1);
    return a < "Z" ? r.push(t.slice(-1)) : r.pop(), a + r.join("");
  } else
    return n + r.join("");
}
function vd(e, t, n = UI) {
  if (e != null && $w(e, n), t != null && $w(t, n), e != null && t != null && e >= t)
    throw new Error(e + " >= " + t);
  if (e == null) {
    if (t == null)
      return "a" + n[0];
    const c = Xu(t), d = t.slice(c.length);
    if (c === "A" + n[0].repeat(26))
      return c + Pd("", d, n);
    if (c < t)
      return c;
    const o = RK(c, n);
    if (o == null)
      throw new Error("cannot decrement any more");
    return o;
  }
  if (t == null) {
    const c = Xu(e), d = e.slice(c.length), o = Fw(c, n);
    return o ?? c + Pd(d, null, n);
  }
  const r = Xu(e), i = e.slice(r.length), a = Xu(t), l = t.slice(a.length);
  if (r === a)
    return r + Pd(i, l, n);
  const s = Fw(r, n);
  if (s == null)
    throw new Error("cannot increment any more");
  return s < t ? s : r + Pd(i, null, n);
}
function e7(e, t, n, r = UI) {
  if (n === 0)
    return [];
  if (n === 1)
    return [vd(e, t, r)];
  if (t == null) {
    let l = vd(e, t, r);
    const s = [l];
    for (let c = 0; c < n - 1; c++)
      l = vd(l, t, r), s.push(l);
    return s;
  }
  if (e == null) {
    let l = vd(e, t, r);
    const s = [l];
    for (let c = 0; c < n - 1; c++)
      l = vd(e, l, r), s.push(l);
    return s.reverse(), s;
  }
  const i = Math.floor(n / 2), a = vd(e, t, r);
  return [
    ...e7(e, a, i, r),
    a,
    ...e7(a, t, n - i - 1, r)
  ];
}
const od = (() => {
  if (typeof self > "u") return !1;
  if ("top" in self && self !== top) try {
  } catch {
    return !1;
  }
  else if ("showOpenFilePicker" in self) return "showOpenFilePicker";
  return !1;
})(), PK = od ? import("./file-open-002ab408-DN9HoVxI.js") : import("./file-open-7c801643-7JqFgE4-.js");
async function OK(...e) {
  return (await PK).default(...e);
}
od ? import("./directory-open-4ed118d0-O_QfH9Tw.js") : import("./directory-open-01563666-Dy1naDTQ.js");
const $K = od ? import("./file-save-745eba88-lCpg7dOn.js") : import("./file-save-3189631c-CPqqkX8Z.js");
async function FK(...e) {
  return (await $K).default(...e);
}
var zK = (e, t) => t.reduce((n, r) => (r in e && (n[r] = e[r]), n), {}), BK = 5, Ad = 5, HK = 4, Vu = 4, Gu = 1, sa = [0, 2, 4, 6, 8], oa = (e, t) => t.map((n) => wr[e][n]), ht = { transparent: "transparent", black: "#1e1e1e", white: "#ffffff", gray: oa("gray", sa), red: oa("red", sa), pink: oa("pink", sa), grape: oa("grape", sa), violet: oa("violet", sa), blue: oa("blue", sa), cyan: oa("cyan", sa), teal: oa("teal", sa), green: oa("green", sa), yellow: oa("yellow", sa), orange: oa("orange", sa), bronze: ["#f8f1ee", "#eaddd7", "#d2bab0", "#a18072", "#846358"] }, wI = zK(ht, ["cyan", "blue", "violet", "grape", "pink", "green", "teal", "yellow", "orange", "red"]), xI = [ht.black, ht.red[Vu], ht.green[Vu], ht.blue[Vu], ht.yellow[Vu]], EI = [ht.transparent, ht.red[Gu], ht.green[Gu], ht.blue[Gu], ht.yellow[Gu]], SI = [ht.white, "#f8f9fa", "#f5faff", "#fffce8", "#fdf8f6"], WK = { transparent: ht.transparent, white: ht.white, gray: ht.gray, black: ht.black, bronze: ht.bronze, ...wI }, XK = { transparent: ht.transparent, white: ht.white, gray: ht.gray, black: ht.black, bronze: ht.bronze, ...wI }, VK = (e) => [ht.cyan[e], ht.blue[e], ht.violet[e], ht.grape[e], ht.pink[e], ht.green[e], ht.teal[e], ht.yellow[e], ht.orange[e], ht.red[e]], GK = (e, t, n) => `#${((1 << 24) + (e << 16) + (t << 8) + n).toString(16).slice(1)}`, xl = /Mac|iPod|iPhone|iPad/.test(navigator.platform), _I = /^Win/.test(navigator.platform), jK = /\b(android)\b/i.test(navigator.userAgent), Vh = "netscape" in window && navigator.userAgent.indexOf("rv:") > 1 && navigator.userAgent.indexOf("Gecko") > 1, KK = navigator.userAgent.indexOf("Chrome") !== -1, YK = !KK && navigator.userAgent.indexOf("Safari") !== -1, kI = /iPad|iPhone/.test(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document, qK = () => {
  var e, t;
  return ((t = (e = navigator.brave) == null ? void 0 : e.isBrave) == null ? void 0 : t.name) === "isBrave";
}, t7 = typeof window < "u" && "ResizeObserver" in window, ZK = "Excalidraw", JK = 36, ec = 10, up = 8, QK = 5, zw = 1, eY = 30, Eo = Math.PI / 12, tY = "red", Ot = { TEXT: "text", CROSSHAIR: "crosshair", GRABBING: "grabbing", GRAB: "grab", POINTER: "pointer", MOVE: "move", AUTO: "" }, Vs = { MAIN: 0, WHEEL: 1, SECONDARY: 2, TOUCH: -1, ERASER: 5 }, yd = { enabled: "all", disabled: "none" }, T1 = { UNSTARTED: -1, ENDED: 0, PLAYING: 1, PAUSED: 2, BUFFERING: 3, CUED: 5 }, oi = { TEST: "test" }, f0 = { SHAPE_ACTIONS_MENU: "App-menu__left", ZOOM_ACTIONS: "zoom-actions", SEARCH_MENU_INPUT_WRAPPER: "layer-ui__search-inputWrapper" }, Od = "Xiaolai", Gh = "Segoe UI Emoji", Un = { Virgil: 1, Helvetica: 2, Cascadia: 3, Excalifont: 5, Nunito: 6, "Lilita One": 7, "Comic Shanns": 8, "Liberation Sans": 9 }, $d = { [Od]: 100, [Gh]: 1e3 }, CI = (e) => {
  switch (e) {
    case Un.Excalifont:
      return [Od, Gh];
    default:
      return [Gh];
  }
}, gt = { LIGHT: "light", DARK: "dark" }, vn = { strokeColor: "#bbb", strokeWidth: 2, strokeStyle: "solid", fillStyle: "solid", roughness: 0, roundness: null, backgroundColor: "transparent", radius: 8, nameOffsetY: 3, nameColorLightTheme: "#999999", nameColorDarkTheme: "#7a7a7a", nameFontSize: 14, nameLineHeight: 1.25 }, d8 = 1, Is = 20, Oo = Un.Excalifont, Ff = "left", mm = "top", Wc = 2, gm = 2 * Wc, nY = 1e-5, rY = 2 * gm - nY, I1 = "#ffffff", iY = "#1e1e1e", aY = "#a2f1a6", bm = 20, MI = 5, p0 = { svg: "image/svg+xml", png: "image/png", jpg: "image/jpeg", gif: "image/gif", webp: "image/webp", bmp: "image/bmp", ico: "image/x-icon", avif: "image/avif", jfif: "image/jfif" }, $e = { text: "text/plain", html: "text/html", json: "application/json", excalidraw: "application/vnd.excalidraw+json", excalidrawlib: "application/vnd.excalidrawlib+json", "excalidraw.svg": "image/svg+xml", "excalidraw.png": "image/png", binary: "application/octet-stream", ...p0 }, lY = [$e.text, $e.html, ...Object.values(p0)], $6 = { png: "png", svg: "svg", clipboard: "clipboard" }, ji = { excalidraw: "excalidraw", excalidrawClipboard: "excalidraw/clipboard", excalidrawLibrary: "excalidrawlib", excalidrawClipboardWithAPI: "excalidraw-api/clipboard" }, u8 = window.EXCALIDRAW_EXPORT_SOURCE || window.location.origin, sY = 500, oY = 300, cY = 500, dY = 100, Yg = 0.1, h8 = 0.1, f8 = 30, uY = 300, p8 = "invert(93%) hue-rotate(180deg)", Bw = { canvasActions: { changeViewBackgroundColor: !0, clearCanvas: !0, export: { saveFileToDisk: !0 }, loadScene: !0, saveToActiveFile: !0, toggleTheme: null, saveAsImage: !0 } }, hY = 730, fY = 1e3, pY = 500, mY = 1229, wu = 2, m8 = [1, 2, 3], tu = 10, gY = 1440, Hw = 4 * 1024 * 1024, Et = "http://www.w3.org/2000/svg", qg = { excalidraw: 2, excalidrawLibrary: 2 }, Zn = 5, bY = 0.7, UY = 11, Si = { TOP: "top", MIDDLE: "middle", BOTTOM: "bottom" }, jh = { LEFT: "left", CENTER: "center", RIGHT: "right" }, vY = 20, F6 = 0.25, yY = 32, Jn = { LEGACY: 1, PROPORTIONAL_RADIUS: 2, ADAPTIVE_RADIUS: 3 }, TI = { artist: 1, cartoonist: 2 }, z6 = { thin: 1, bold: 2, extraBold: 4 }, Cn = { strokeColor: ht.black, backgroundColor: ht.transparent, fillStyle: "solid", strokeWidth: 2, strokeStyle: "solid", roughness: TI.artist, opacity: 100, locked: !1 }, Um = "library", Zd = "search", Ia = { name: "default", defaultTab: Um }, II = /* @__PURE__ */ new Set(["iframe", "embeddable", "image"]), lr = { selection: "selection", rectangle: "rectangle", diamond: "diamond", ellipse: "ellipse", text: "text", image: "image", eraser: "eraser", frame: "frame", magicframe: "magicframe", laser: "laser" }, fh = { MERMAID_TO_EXCALIDRAW: "mermaid-to-excalidraw", PUBLISH_LIBRARY: "publish-library-data" }, AI = "Untitled", Fd = { generalStats: 1, elementProperties: 2 }, $i = 1, br = { sharp: "sharp", round: "round", elbow: "elbow" }, NI = 0.3, vm = "element", wY = Symbol.for("__test__originalId__"), xY = ((e) => (e.ACTIVE = "active", e.AWAY = "away", e.IDLE = "idle", e))(xY || {}), EY = m8.includes(devicePixelRatio) ? devicePixelRatio : 1, El = () => ({ showWelcomeScreen: !1, theme: gt.LIGHT, collaborators: /* @__PURE__ */ new Map(), currentChartType: "bar", currentItemBackgroundColor: Cn.backgroundColor, currentItemEndArrowhead: "arrow", currentItemFillStyle: Cn.fillStyle, currentItemFontFamily: Oo, currentItemFontSize: Is, currentItemOpacity: Cn.opacity, currentItemRoughness: Cn.roughness, currentItemStartArrowhead: null, currentItemStrokeColor: Cn.strokeColor, currentItemRoundness: "round", currentItemArrowType: br.round, currentItemStrokeStyle: Cn.strokeStyle, currentItemStrokeWidth: Cn.strokeWidth, currentItemTextAlign: Ff, currentHoveredFontFamily: null, cursorButton: "up", activeEmbeddable: null, newElement: null, editingTextElement: null, editingGroupId: null, editingLinearElement: null, activeTool: { type: "selection", customType: null, locked: Cn.locked, lastActiveTool: null }, penMode: !1, penDetected: !1, errorMessage: null, exportBackground: !0, exportScale: EY, exportEmbedScene: !1, exportWithDarkMode: !1, fileHandle: null, gridSize: bm, gridStep: MI, gridModeEnabled: !1, isBindingEnabled: !0, defaultSidebarDockedPreference: !1, isLoading: !1, isResizing: !1, isRotating: !1, lastPointerDownWith: "mouse", multiElement: null, name: null, contextMenu: null, openMenu: null, openPopup: null, openSidebar: null, openDialog: null, pasteDialog: { shown: !1, data: null }, previousSelectedElementIds: {}, resizingElement: null, scrolledOutside: !1, scrollX: 0, scrollY: 0, selectedElementIds: {}, hoveredElementIds: {}, selectedGroupIds: {}, selectedElementsAreBeingDragged: !1, selectionElement: null, shouldCacheIgnoreZoom: !1, stats: { open: !1, panels: Fd.generalStats | Fd.elementProperties }, startBoundElement: null, suggestedBindings: [], frameRendering: { enabled: !0, clip: !0, name: !0, outline: !0 }, frameToHighlight: null, editingFrame: null, elementsToHighlight: null, toast: null, viewBackgroundColor: ht.white, zenModeEnabled: !1, zoom: { value: 1 }, viewModeEnabled: !1, pendingImageElementId: null, showHyperlinkPopup: !1, selectedLinearElement: null, snapLines: [], originSnapOffset: { x: 0, y: 0 }, objectsSnapModeEnabled: !1, userToFollow: null, followedBy: /* @__PURE__ */ new Set(), isCropping: !1, croppingElementId: null, searchMatches: [] }), SY = /* @__PURE__ */ ((e) => e)({ showWelcomeScreen: { browser: !0, export: !1, server: !1 }, theme: { browser: !0, export: !1, server: !1 }, collaborators: { browser: !1, export: !1, server: !1 }, currentChartType: { browser: !0, export: !1, server: !1 }, currentItemBackgroundColor: { browser: !0, export: !1, server: !1 }, currentItemEndArrowhead: { browser: !0, export: !1, server: !1 }, currentItemFillStyle: { browser: !0, export: !1, server: !1 }, currentItemFontFamily: { browser: !0, export: !1, server: !1 }, currentItemFontSize: { browser: !0, export: !1, server: !1 }, currentItemRoundness: { browser: !0, export: !1, server: !1 }, currentItemArrowType: { browser: !0, export: !1, server: !1 }, currentItemOpacity: { browser: !0, export: !1, server: !1 }, currentItemRoughness: { browser: !0, export: !1, server: !1 }, currentItemStartArrowhead: { browser: !0, export: !1, server: !1 }, currentItemStrokeColor: { browser: !0, export: !1, server: !1 }, currentItemStrokeStyle: { browser: !0, export: !1, server: !1 }, currentItemStrokeWidth: { browser: !0, export: !1, server: !1 }, currentItemTextAlign: { browser: !0, export: !1, server: !1 }, currentHoveredFontFamily: { browser: !1, export: !1, server: !1 }, cursorButton: { browser: !0, export: !1, server: !1 }, activeEmbeddable: { browser: !1, export: !1, server: !1 }, newElement: { browser: !1, export: !1, server: !1 }, editingTextElement: { browser: !1, export: !1, server: !1 }, editingGroupId: { browser: !0, export: !1, server: !1 }, editingLinearElement: { browser: !1, export: !1, server: !1 }, activeTool: { browser: !0, export: !1, server: !1 }, penMode: { browser: !0, export: !1, server: !1 }, penDetected: { browser: !0, export: !1, server: !1 }, errorMessage: { browser: !1, export: !1, server: !1 }, exportBackground: { browser: !0, export: !1, server: !1 }, exportEmbedScene: { browser: !0, export: !1, server: !1 }, exportScale: { browser: !0, export: !1, server: !1 }, exportWithDarkMode: { browser: !0, export: !1, server: !1 }, fileHandle: { browser: !1, export: !1, server: !1 }, gridSize: { browser: !0, export: !0, server: !0 }, gridStep: { browser: !0, export: !0, server: !0 }, gridModeEnabled: { browser: !0, export: !0, server: !0 }, height: { browser: !1, export: !1, server: !1 }, isBindingEnabled: { browser: !1, export: !1, server: !1 }, defaultSidebarDockedPreference: { browser: !0, export: !1, server: !1 }, isLoading: { browser: !1, export: !1, server: !1 }, isResizing: { browser: !1, export: !1, server: !1 }, isRotating: { browser: !1, export: !1, server: !1 }, lastPointerDownWith: { browser: !0, export: !1, server: !1 }, multiElement: { browser: !1, export: !1, server: !1 }, name: { browser: !0, export: !1, server: !1 }, offsetLeft: { browser: !1, export: !1, server: !1 }, offsetTop: { browser: !1, export: !1, server: !1 }, contextMenu: { browser: !1, export: !1, server: !1 }, openMenu: { browser: !0, export: !1, server: !1 }, openPopup: { browser: !1, export: !1, server: !1 }, openSidebar: { browser: !0, export: !1, server: !1 }, openDialog: { browser: !1, export: !1, server: !1 }, pasteDialog: { browser: !1, export: !1, server: !1 }, previousSelectedElementIds: { browser: !0, export: !1, server: !1 }, resizingElement: { browser: !1, export: !1, server: !1 }, scrolledOutside: { browser: !0, export: !1, server: !1 }, scrollX: { browser: !0, export: !1, server: !1 }, scrollY: { browser: !0, export: !1, server: !1 }, selectedElementIds: { browser: !0, export: !1, server: !1 }, hoveredElementIds: { browser: !1, export: !1, server: !1 }, selectedGroupIds: { browser: !0, export: !1, server: !1 }, selectedElementsAreBeingDragged: { browser: !1, export: !1, server: !1 }, selectionElement: { browser: !1, export: !1, server: !1 }, shouldCacheIgnoreZoom: { browser: !0, export: !1, server: !1 }, stats: { browser: !0, export: !1, server: !1 }, startBoundElement: { browser: !1, export: !1, server: !1 }, suggestedBindings: { browser: !1, export: !1, server: !1 }, frameRendering: { browser: !1, export: !1, server: !1 }, frameToHighlight: { browser: !1, export: !1, server: !1 }, editingFrame: { browser: !1, export: !1, server: !1 }, elementsToHighlight: { browser: !1, export: !1, server: !1 }, toast: { browser: !1, export: !1, server: !1 }, viewBackgroundColor: { browser: !0, export: !0, server: !0 }, width: { browser: !1, export: !1, server: !1 }, zenModeEnabled: { browser: !0, export: !1, server: !1 }, zoom: { browser: !0, export: !1, server: !1 }, viewModeEnabled: { browser: !1, export: !1, server: !1 }, pendingImageElementId: { browser: !1, export: !1, server: !1 }, showHyperlinkPopup: { browser: !1, export: !1, server: !1 }, selectedLinearElement: { browser: !0, export: !1, server: !1 }, snapLines: { browser: !1, export: !1, server: !1 }, originSnapOffset: { browser: !1, export: !1, server: !1 }, objectsSnapModeEnabled: { browser: !0, export: !1, server: !1 }, userToFollow: { browser: !1, export: !1, server: !1 }, followedBy: { browser: !1, export: !1, server: !1 }, isCropping: { browser: !1, export: !1, server: !1 }, croppingElementId: { browser: !1, export: !1, server: !1 }, searchMatches: { browser: !1, export: !1, server: !1 } }), _Y = (e, t) => {
  var r;
  let n = {};
  for (let i of Object.keys(e)) if ((r = SY[i]) != null && r[t]) {
    let a = e[i];
    n[i] = a;
  }
  return n;
}, DI = (e) => _Y(e, "export"), tl = ({ activeTool: e }) => e.type === "eraser", m0 = ({ activeTool: e }) => e.type === "hand", ft = (e, t, n) => Math.min(Math.max(e, t), n), vl = (e, t, n = "round") => {
  let r = Math.pow(10, t);
  return Math[n]((e + Number.EPSILON) * r) / r;
}, kY = (e, t, n = "round") => {
  let r = 1 / t;
  return Math[n](e * r) / r;
}, A1 = (e, t) => (e + t) / 2, ph = (e) => typeof e == "number" && Number.isFinite(e), Ww = (e, t, n = 1e-4) => Math.abs(e - t) < n, ym = (e) => e < 0 ? e + 2 * Math.PI : e >= 2 * Math.PI ? e - 2 * Math.PI : e;
function Uc(e) {
  return e * Math.PI / 180;
}
function zf(e) {
  return e * 180 / Math.PI;
}
function CY(e) {
  return Math.abs(Math.sin(2 * e)) < 1e-4;
}
function _r(e, t, n = 0, r = 0) {
  return [e - n, t - r];
}
function Le(e, t = [0, 0]) {
  return _r(e[0] - t[0], e[1] - t[1]);
}
function ar(e, t) {
  return e[0] * t[1] - t[0] * e[1];
}
function Xw(e, t) {
  return e[0] * t[0] + e[1] * t[1];
}
function io(e, t) {
  return [e[0] + t[0], e[1] + t[1]];
}
function wm(e, t) {
  return [e[0] - t[0], e[1] - t[1]];
}
function An(e, t) {
  return _r(e[0] * t, e[1] * t);
}
function MY(e) {
  return e[0] * e[0] + e[1] * e[1];
}
function TY(e) {
  return Math.sqrt(MY(e));
}
var Rr = (e) => {
  let t = TY(e);
  return t === 0 ? _r(0, 0) : _r(e[0] / t, e[1] / t);
};
function T(e, t) {
  return [e, t];
}
function g8(e) {
  return e.length === 2 ? T(e[0], e[1]) : void 0;
}
function pt(e, t = T(0, 0)) {
  return T(t[0] + e[0], t[1] + e[1]);
}
function IY(e) {
  return Array.isArray(e) && e.length === 2 && typeof e[0] == "number" && !isNaN(e[0]) && typeof e[1] == "number" && !isNaN(e[1]);
}
function Ra(e, t) {
  let n = Math.abs;
  return n(e[0] - t[0]) < 1e-4 && n(e[1] - t[1]) < 1e-4;
}
function te([e, t], [n, r], i) {
  return T((e - n) * Math.cos(i) - (t - r) * Math.sin(i) + n, (e - n) * Math.sin(i) + (t - r) * Math.cos(i) + r);
}
function xm(e, t = [0, 0]) {
  return T(e[0] + t[0], e[1] + t[1]);
}
function Bf(e, t) {
  return T((e[0] + t[0]) / 2, (e[1] + t[1]) / 2);
}
function Tt(e, t) {
  return Math.hypot(t[0] - e[0], t[1] - e[1]);
}
function Kh(e, t) {
  let n = t[0] - e[0], r = t[1] - e[1];
  return n * n + r * r;
}
var Xl = (e, t, n) => xm(t, An(Le(e, t), n)), LI = (e, t, n) => t[0] <= Math.max(e[0], n[0]) && t[0] >= Math.min(e[0], n[0]) && t[1] <= Math.max(e[1], n[1]) && t[1] >= Math.min(e[1], n[1]);
function n7(e, t) {
  return [e, t];
}
function AY(e, t) {
  let n = e[1][1] - e[0][1], r = e[0][0] - e[1][0], i = t[1][1] - t[0][1], a = t[0][0] - t[1][0], l = n * a - i * r;
  if (l !== 0) {
    let s = n * e[0][0] + r * e[0][1], c = i * t[0][0] + a * t[0][1];
    return T((s * a - c * r) / l, (n * c - i * s) / l);
  }
  return null;
}
function Re(e, t) {
  return [e, t];
}
var Xc = (e, t, n = 1e-4) => {
  let r = b8(e, t);
  return r === 0 ? !0 : r < n;
}, b8 = (e, t) => {
  let [n, r] = e, [[i, a], [l, s]] = t, c = n - i, d = r - a, o = l - i, u = s - a, h = c * o + d * u, f = o * o + u * u, p = -1;
  f !== 0 && (p = h / f);
  let g, b;
  p < 0 ? (g = i, b = a) : p > 1 ? (g = l, b = s) : (g = i + p * o, b = a + p * u);
  let v = n - g, U = r - b;
  return Math.sqrt(v * v + U * U);
};
function Yh(e, t) {
  let n = AY(n7(e[0], e[1]), n7(t[0], t[1]));
  return !n || !Xc(n, t) || !Xc(n, e) ? null : n;
}
function r7(e, t) {
  return [e, t];
}
function NY(e, t) {
  return [Re(e[0], T(e[1][0], e[0][1])), Re(T(e[1][0], e[0][1]), e[1]), Re(e[1], T(e[0][0], e[1][1])), Re(T(e[0][0], e[1][1]), e[0])].map((n) => Yh(t, n)).filter((n) => !!n);
}
function rs(e, t, n, r) {
  return [e, t, n, r];
}
function Vw(e, t, n, r = 1e-6) {
  return [(e(t + r, n) - e(t - r, n)) / (2 * r), (e(t, n + r) - e(t, n - r)) / (2 * r)];
}
function DY(e, t, n, r = 1e-3, i = 10) {
  let a = 1 / 0, l = 0;
  for (; a >= r; ) {
    if (l >= i) return null;
    let s = e(t, n), c = [Vw((g, b) => e(g, b)[0], t, n), Vw((g, b) => e(g, b)[1], t, n)], d = [[-s[0]], [-s[1]]], o = c[0][0] * c[1][1] - c[0][1] * c[1][0];
    if (o === 0) return null;
    let u = [[c[1][1] / o, -c[0][1] / o], [-c[1][0] / o, c[0][0] / o]], h = [[u[0][0] * d[0][0] + u[0][1] * d[1][0]], [u[1][0] * d[0][0] + u[1][1] * d[1][0]]];
    t = t + h[0][0], n = n + h[1][0];
    let [f, p] = e(t, n);
    a = Math.max(Math.abs(f), Math.abs(p)), l += 1;
  }
  return [t, n];
}
var mh = (e, t) => T((1 - t) ** 3 * e[0][0] + 3 * (1 - t) ** 2 * t * e[1][0] + 3 * (1 - t) * t ** 2 * e[2][0] + t ** 3 * e[3][0], (1 - t) ** 3 * e[0][1] + 3 * (1 - t) ** 2 * t * e[1][1] + 3 * (1 - t) * t ** 2 * e[2][1] + t ** 3 * e[3][1]);
function RI(e, t) {
  let n = RY(e);
  if (NY(r7(T(n[0], n[1]), T(n[2], n[3])), t).length === 0) return [];
  let r = (s) => T(t[0][0] + s * (t[1][0] - t[0][0]), t[0][1] + s * (t[1][1] - t[0][1])), i = [[0.5, 0], [0.2, 0], [0.8, 0]], a = ([s, c]) => {
    let d = DY((h, f) => {
      let p = mh(e, h), g = r(f);
      return [p[0] - g[0], p[1] - g[1]];
    }, s, c);
    if (!d) return null;
    let [o, u] = d;
    return o < 0 || o > 1 || u < 0 || u > 1 ? null : mh(e, o);
  }, l = a(i[0]);
  return l ? [l] : (l = a(i[1]), l ? [l] : (l = a(i[2]), l ? [l] : []));
}
function LY(e, t, n = 1e-3) {
  let r = (c, d, o, u = n) => {
    let h = c, f = d, p;
    for (; f - h > u; ) p = (f + h) / 2, o(p - u) < o(p + u) ? f = p : h = p;
    return p;
  }, i = 0;
  for (let c = 1 / 0, d = 0; d < 30; d++) {
    let o = Tt(t, mh(e, d / 30));
    o < c && (c = o, i = d);
  }
  let a = Math.max((i - 1) / 30, 0), l = Math.min((i + 1) / 30, 1), s = r(a, l, (c) => Tt(t, mh(e, c)));
  return s ? mh(e, s) : null;
}
function PI(e, t) {
  let n = LY(e, t);
  return n ? Tt(t, n) : 0;
}
function RY(e) {
  let [t, n, r, i] = e, a = [t[0], n[0], r[0], i[0]], l = [t[1], n[1], r[1], i[1]];
  return [Math.min(...a), Math.min(...l), Math.max(...a), Math.max(...l)];
}
function Gw(...e) {
  return OI(e);
}
function Em(e) {
  return OI(e);
}
var jw = (e, t) => {
  let n = e[0], r = e[1], i = !1;
  for (let a = 0, l = t.length - 1; a < t.length; l = a++) {
    let s = t[a][0], c = t[a][1], d = t[l][0], o = t[l][1];
    (c > r && o <= r || c <= r && o > r) && n < (d - s) * (r - c) / (o - c) + s && (i = !i);
  }
  return i;
}, PY = (e, t, n = 1e-4) => {
  let r = !1;
  for (let i = 0, a = t.length - 1; i < a; i++) if (Xc(e, Re(t[i], t[i + 1]), n)) {
    r = !0;
    break;
  }
  return r;
};
function OI(e) {
  return OY(e) ? e : [...e, e[0]];
}
function OY(e) {
  return Ra(e[0], e[e.length - 1]);
}
function Nr(e, t) {
  return ta([e, t]);
}
var Sm = ([e, t], [n, r]) => e <= n ? t >= n : e >= n ? r >= e : !1, _m = ([e, t], [n, r]) => {
  let i = Math.max(e, n), a = Math.min(t, r);
  return i <= a ? ta([i, a]) : null;
}, N1 = (e, [t, n]) => e >= t && e <= n;
function wd([e, t, n], r) {
  let i = (o, u, h) => (o[0] - h[0]) * (u[1] - h[1]) - (u[0] - h[0]) * (o[1] - h[1]), a = i(r, e, t), l = i(r, t, n), s = i(r, n, e), c = a < 0 || l < 0 || s < 0, d = a > 0 || l > 0 || s > 0;
  return !(c && d);
}
var Kw = () => {
  let e = /* @__PURE__ */ new Date(), t = e.getFullYear(), n = `${e.getMonth() + 1}`.padStart(2, "0"), r = `${e.getDate()}`.padStart(2, "0"), i = `${e.getHours()}`.padStart(2, "0"), a = `${e.getMinutes()}`.padStart(2, "0");
  return `${t}-${n}-${r}-${i}${a}`;
}, gh = (e) => e.charAt(0).toUpperCase() + e.slice(1), $Y = (e) => e instanceof HTMLElement && e.className.includes("ToolIcon"), i7 = (e) => e instanceof HTMLElement && e.dataset.type === "wysiwyg" || e instanceof HTMLBRElement || e instanceof HTMLInputElement || e instanceof HTMLTextAreaElement || e instanceof HTMLSelectElement, FY = (e) => i7(e) || e instanceof Element && !!e.closest("label, button"), rc = (e) => e instanceof HTMLElement && e.dataset.type === "wysiwyg" || e instanceof HTMLBRElement || e instanceof HTMLTextAreaElement || e instanceof HTMLInputElement && (e.type === "text" || e.type === "number" || e.type === "password"), g0 = ({ fontFamily: e }) => {
  for (let [t, n] of Object.entries(Un)) if (n === e) return `${t}${CI(n).map((r) => `, ${r}`).join("")}`;
  return Gh;
}, Wt = ({ fontSize: e, fontFamily: t }) => `${e}px ${g0({ fontFamily: t })}`, b0 = (e, t) => {
  let n = 0, r = null, i = (...a) => {
    r = a, clearTimeout(n), n = window.setTimeout(() => {
      r = null, e(...a);
    }, t);
  };
  return i.flush = () => {
    if (clearTimeout(n), r) {
      let a = r;
      r = null, e(...a);
    }
  }, i.cancel = () => {
    r = null, clearTimeout(n);
  }, i;
}, Zg = (e, t) => {
  let n = null, r = null, i = null, a = (s) => {
    n = window.requestAnimationFrame(() => {
      n = null, e(...s), r = null, i && (r = i, i = null, a(r));
    });
  }, l = (...s) => {
    if (st.MODE === "test") {
      e(...s);
      return;
    }
    r = s, n === null ? a(r) : t != null && t.trailing && (i = s);
  };
  return l.flush = () => {
    n !== null && (cancelAnimationFrame(n), n = null), r && (e(...i || r), r = i = null);
  }, l.cancel = () => {
    r = i = null, n !== null && (cancelAnimationFrame(n), n = null);
  }, l;
}, vc = (e) => 1 - Math.pow(1 - e, 4), Yw = (e, t, n) => (t - e) * vc(n) + e, zY = ({ fromValues: e, toValues: t, onStep: n, duration: r = 250, interpolateValue: i, onStart: a, onEnd: l, onCancel: s }) => {
  let c = !1, d = 0, o;
  function u(h) {
    if (c) return;
    o === void 0 && (o = h, a == null || a());
    let f = Math.min(h - o, r), p = vc(f / r), g = {};
    if (Object.keys(e).forEach((b) => {
      let v = b, U = (t[v] - e[v]) * p + e[v];
      g[v] = U;
    }), n(g), f < r) {
      let b = f / r, v = {};
      Object.keys(e).forEach((U) => {
        let y = U, w = e[y], x = t[y], E;
        E = i ? i(w, x, b, y) : Yw(w, x, b), E == null && (E = Yw(w, x, b)), v[y] = E;
      }), n(v), d = window.requestAnimationFrame(u);
    } else n(t), l == null || l();
  }
  return d = window.requestAnimationFrame(u), () => {
    s == null || s(), c = !0, window.cancelAnimationFrame(d);
  };
}, BY = (e, t) => {
  if (!e.length || t < 1) return [];
  let n = 0, r = 0, i = Array(Math.ceil(e.length / t));
  for (; n < e.length; ) i[r++] = e.slice(n, n += t);
  return i;
}, Dr = (e, t) => Math.abs(e - t), Wn = (e, t) => t.type === "custom" ? { ...e.activeTool, type: "custom", customType: t.customType, locked: t.locked ?? e.activeTool.locked } : { ...e.activeTool, lastActiveTool: t.lastActiveToolBeforeEraser === void 0 ? e.activeTool.lastActiveTool : t.lastActiveToolBeforeEraser, type: t.type, customType: null, locked: t.locked ?? e.activeTool.locked }, ae = (e) => (e = e.replace(/\bAlt\b/i, "Alt").replace(/\bShift\b/i, "Shift").replace(/\b(Enter|Return)\b/i, "Enter"), xl ? e.replace(/\bCtrlOrCmd\b/gi, "Cmd").replace(/\bAlt\b/i, "Option") : e.replace(/\bCtrlOrCmd\b/gi, "Ctrl")), en = ({ clientX: e, clientY: t }, { zoom: n, offsetLeft: r, offsetTop: i, scrollX: a, scrollY: l }) => {
  let s = (e - r) / n.value - a, c = (t - i) / n.value - l;
  return { x: s, y: c };
}, wa = ({ sceneX: e, sceneY: t }, { zoom: n, offsetLeft: r, offsetTop: i, scrollX: a, scrollY: l }) => {
  let s = (e + a) * n.value + r, c = (t + l) * n.value + i;
  return { x: s, y: c };
}, D1 = (e) => getComputedStyle(document.documentElement).getPropertyValue(`--${e}`), HY = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿Ⰰ-﬜﷾-﹯﻽-￿", WY = "֑-߿יִ-﷽ﹰ-ﻼ", XY = new RegExp(`^[^${HY}]*[${WY}]`), $I = (e) => XY.test(e), xa = (e) => {
  let [t, n] = e;
  return { x: t, y: n };
}, FI = (e) => {
  if ((e == null ? void 0 : e.name) === "AbortError") {
    console.warn(e);
    return;
  }
  throw e;
}, zI = (e, t, n = 0) => {
  n < 0 && (n = e.length + n), n = Math.min(e.length, Math.max(n, 0));
  let r = n - 1;
  for (; ++r < e.length; ) if (t(e[r], r, e)) return r;
  return -1;
}, ic = (e, t, n = e.length - 1) => {
  n < 0 && (n = e.length + n), n = Math.min(e.length - 1, Math.max(n, 0));
  let r = n + 1;
  for (; --r > -1; ) if (t(e[r], r, e)) return r;
  return -1;
}, Ea = (e) => {
  let t = e.length === 5 && e.substr(4, 1) === "0", n = e.length === 9 && e.substr(7, 2) === "00";
  return t || n || e === ht.transparent;
}, B6 = (e) => e.fillStyle !== "solid" || Ea(e.backgroundColor), VY = () => {
  let e, t, n = new Promise((r, i) => {
    e = r, t = i;
  });
  return n.resolve = e, n.reject = t, n;
}, GY = (e) => {
  let t = e.parentElement;
  for (; t; ) {
    if (t === document.body) return document;
    let { overflowY: n } = window.getComputedStyle(t);
    if (t.scrollHeight > t.clientHeight && (n === "auto" || n === "scroll" || n === "overlay")) return t;
    t = t.parentElement;
  }
  return document;
}, jY = (e) => {
  let t = e.parentElement;
  for (; t; ) {
    if (t.tabIndex > -1) {
      t.focus();
      return;
    }
    t = t.parentElement;
  }
}, KY = (e) => Array.from(e).map((t) => `0${t.toString(16)}`.slice(-2)).join(""), nu = () => bs() ? 1 : Date.now(), Ge = (e) => e instanceof Map ? e : e.reduce((t, n) => (t.set(typeof n == "string" ? n : n.id, n), t), /* @__PURE__ */ new Map()), YY = (e) => e.reduce((t, n, r) => (t.set(n.id, [n, r]), t), /* @__PURE__ */ new Map()), Bl = (e, t) => e.reduce((n, r) => (n[t ? t(r) : String(r)] = r, n), {}), qY = (e) => e.reduce((t, n, r) => {
  let i = { ...n, prev: null, next: null };
  if (r !== 0) {
    let a = t[r - 1];
    if (i.prev = a, a.next = i, r === e.length - 1) {
      let l = t[0];
      i.next = l, l.prev = i;
    }
  }
  return t.push(i), t;
}, []), bs = () => st.MODE === "test", BI = () => st.MODE === "development", ZY = () => typeof process < "u" && !0, HI = (e, t) => new CustomEvent(e, { detail: { nativeEvent: t }, cancelable: !0 }), hp = (e, t) => {
  let n = !1;
  for (let r in t) {
    let i = t[r];
    if (typeof i < "u") {
      if (e[r] === i && (typeof i != "object" || i === null)) continue;
      n = !0;
    }
  }
  return n ? { ...e, ...t } : e;
}, JY = () => {
  try {
    return window.self === window.top ? "top" : "iframe";
  } catch {
    return "iframe";
  }
}, Hf = (e) => !!e && typeof e == "object" && "then" in e && "catch" in e && "finally" in e, a7 = (e) => {
  let t = e == null ? void 0 : e.querySelectorAll("button, a, input, select, textarea, div[tabindex], label[tabindex]");
  return t ? Array.from(t).filter((n) => n.tabIndex > -1 && !n.disabled) : [];
}, qw = (e, t) => Array.isArray(e) && Array.isArray(t) && e.length === 0 && t.length === 0 ? !0 : e === t, Tr = (e, t, n, r = !1) => {
  let i = Object.keys(e), a = Object.keys(t);
  if (i.length !== a.length) return r && console.warn("%cisShallowEqual: objects don't have same properties ->", "color: #8B4000", e, t), !1;
  if (n && Array.isArray(n)) {
    for (let l of n) if (!(e[l] === t[l] || qw(e[l], t[l]))) return r && console.warn(`%cisShallowEqual: ${l} not equal ->`, "color: #8B4000", e[l], t[l]), !1;
    return !0;
  }
  return i.every((l) => {
    let s = n == null ? void 0 : n[l], c = s ? s(e[l], t[l]) : e[l] === t[l] || qw(e[l], t[l]);
    return !c && r && console.warn(`%cisShallowEqual: ${l} not equal ->`, "color: #8B4000", e[l], t[l]), c;
  });
}, Jg = (e, t, { checkForDefaultPrevented: n = !0 } = {}) => function(r) {
  if (e == null || e(r), !n || !(r != null && r.defaultPrevented)) return t == null ? void 0 : t(r);
}, Vc = (e, t, n) => {
  if (!t) return e;
  if (n) return console.error(t), e;
  throw new Error(t);
};
function Or(e, t) {
  if (!e) throw new Error(t);
}
var QY = (e) => {
  let t, n, r = function(i) {
    let a = Object.entries(i);
    if (t) {
      let s = !0;
      for (let [c, d] of a) if (t.get(c) !== d) {
        s = !1;
        break;
      }
      if (s) return n;
    }
    let l = e(i);
    return t = new Map(a), n = l, l;
  };
  return r.clear = () => {
    t = void 0, n = void 0;
  }, r;
}, WI = (e, t) => e instanceof Set || e instanceof Map ? e.has(t) : "includes" in e ? e.includes(t) : e.hasOwnProperty(t), cs = (e) => JSON.parse(JSON.stringify(e)), xu = (e, t) => Tr(e, t) ? e : t;
function gn(e, t, n, r) {
  var i;
  return e ? ((i = e == null ? void 0 : e.addEventListener) == null || i.call(e, t, n, r), () => {
    var a;
    (a = e == null ? void 0 : e.removeEventListener) == null || a.call(e, t, n, r);
  }) : () => {
  };
}
function eq(e, t = !0) {
  let n = e.length;
  if (n < 4) return "";
  let r = e[0], i = e[1], a = e[2], l = `M${r[0].toFixed(2)},${r[1].toFixed(2)} Q${i[0].toFixed(2)},${i[1].toFixed(2)} ${A1(i[0], a[0]).toFixed(2)},${A1(i[1], a[1]).toFixed(2)} T`;
  for (let s = 2, c = n - 1; s < c; s++) r = e[s], i = e[s + 1], l += `${A1(r[0], i[0]).toFixed(2)},${A1(r[1], i[1]).toFixed(2)} `;
  return t && (l += "Z"), l;
}
var XI = (e) => e.replace(/\r?\n|\r/g, `
`), ta = (e) => e, U0 = async (e, ...t) => new Promise((n) => {
  n(e(...t));
}), tq = (...e) => Math.max(...e.map((t) => t ? 1 : 0)) > 0, Zw = class {
  constructor(e, t) {
    $(this, "pool"), $(this, "entries", {}), this.pool = new Cj(e, t);
  }
  all() {
    let e = (t) => {
      if (t.data.result) {
        let [n, r] = t.data.result;
        this.entries[n] = r;
      }
    };
    return this.pool.addEventListener("fulfilled", e), this.pool.start().then(() => (setTimeout(() => {
      this.pool.removeEventListener("fulfilled", e);
    }), Object.values(this.entries)));
  }
}, fp = (e) => e.replace(/"/g, "&quot;"), Jw = (e) => Array.isArray(e) ? e : [e], zi = (e) => !!e && e.type === "image" && !!e.fileId, Mt = (e) => !!e && e.type === "image", ri = (e) => !!e && e.type === "embeddable", qs = (e) => !!e && e.type === "iframe", Bi = (e) => !!e && (e.type === "iframe" || e.type === "embeddable"), we = (e) => e != null && e.type === "text", VI = (e) => e != null && e.type === "frame", pp = (e) => e != null && e.type === "magicframe", Ve = (e) => e != null && (e.type === "frame" || e.type === "magicframe"), na = (e) => e != null && nq(e.type), nq = (e) => e === "freedraw", et = (e) => e != null && U8(e.type), dt = (e) => e != null && e.type === "arrow", Se = (e) => dt(e) && e.elbowed, U8 = (e) => e === "arrow" || e === "line", hl = (e, t = !0) => e != null && (!e.locked || t === !0) && GI(e.type), GI = (e) => e === "arrow", Pa = (e, t = !0) => e != null && (!e.locked || t === !0) && (e.type === "rectangle" || e.type === "diamond" || e.type === "ellipse" || e.type === "image" || e.type === "iframe" || e.type === "embeddable" || e.type === "frame" || e.type === "magicframe" || e.type === "text" && !e.containerId), rq = (e) => e != null && (e.type === "rectangle" || e.type === "diamond" || e.type === "image" || e.type === "iframe" || e.type === "embeddable" || e.type === "frame" || e.type === "magicframe" || e.type === "text" && !e.containerId), yc = (e, t = !0) => e != null && (!e.locked || t === !0) && (e.type === "rectangle" || e.type === "diamond" || e.type === "ellipse" || dt(e)), jI = (e) => {
  let t = e == null ? void 0 : e.type;
  if (!t) return !1;
  switch (t) {
    case "text":
    case "diamond":
    case "rectangle":
    case "iframe":
    case "embeddable":
    case "ellipse":
    case "arrow":
    case "freedraw":
    case "line":
    case "frame":
    case "magicframe":
    case "image":
    case "selection":
      return !0;
    default:
      return Vc(t, null), !1;
  }
}, Qg = (e) => e.type === "rectangle" || e.type === "ellipse" || e.type === "diamond", ra = (e) => {
  var t;
  return yc(e) && !!((t = e.boundElements) != null && t.some(({ type: n }) => n === "text"));
}, sn = (e) => e !== null && "containerId" in e && e.containerId !== null && we(e), ru = (e) => e === "rectangle" || e === "embeddable" || e === "iframe" || e === "image", KI = (e) => e === "line" || e === "arrow" || e === "diamond", iq = (e, t) => !!((e === Jn.ADAPTIVE_RADIUS || e === Jn.LEGACY) && ru(t.type) || e === Jn.PROPORTIONAL_RADIUS && KI(t.type)), aq = (e) => KI(e.type) ? { type: Jn.PROPORTIONAL_RADIUS } : ru(e.type) ? { type: Jn.ADAPTIVE_RADIUS } : null, km = (e) => Object.hasOwn(e, "fixedPoint") && e.fixedPoint != null, $r = (e, t, n) => {
  let r = e.split(`
`).map((l) => l || " ").join(`
`), i = parseFloat(t), a = cq(r, i, n);
  return { width: w8(r, t), height: a };
}, YI = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".toLocaleUpperCase(), qI = (e, t) => {
  let n = dq(e);
  return n === 0 ? $r(YI.split("").join(`
`), e, t).width + Zn * 2 : n + Zn * 2;
}, v8 = (e, t) => $r("", e, t).width + Zn * 2, lq = () => w8(YI, Wt({ fontSize: Is, fontFamily: Oo })) > 0, v0 = (e) => XI(e).replace(/\t/g, "        "), y8 = (e) => v0(e).split(`
`), sq = (e) => {
  let t = y8(e.text).length;
  return e.height / t / e.fontSize;
}, Wf = (e, t) => e * t, ZI = (e, t) => Wf(e, t) + Zn * 2, H6, oq = class {
  constructor() {
    $(this, "canvas"), this.canvas = document.createElement("canvas");
  }
  getLineWidth(e, t) {
    let n = this.canvas.getContext("2d");
    n.font = t;
    let r = n.measureText(e).width;
    return bs() ? r * 10 : r;
  }
}, Gc = (e, t) => (H6 || (H6 = new oq()), H6.getLineWidth(e, t)), w8 = (e, t) => {
  let n = y8(e), r = 0;
  return n.forEach((i) => {
    r = Math.max(r, Gc(i, t));
  }), r;
}, cq = (e, t, n) => {
  let r = y8(e).length;
  return Wf(t, n) * r;
}, Xf = /* @__PURE__ */ (() => {
  let e = {};
  return { calculate: (t, n) => {
    let r = t.charCodeAt(0);
    if (e[n] || (e[n] = []), !e[n][r]) {
      let i = Gc(t, n);
      e[n][r] = i;
    }
    return e[n][r];
  }, getCache: (t) => e[t], clearCache: (t) => {
    e[t] = [];
  } };
})(), dq = (e) => {
  let t = Xf.getCache(e);
  if (!t) return 0;
  let n = t.filter((r) => r !== void 0);
  return Math.max(...n);
}, W6, L1, X6, uq = (e) => (W6 || (W6 = Dt.class(...Object.values(Vl))), W6.test(e)), hq = () => {
  if (!L1) try {
    L1 = pq();
  } catch {
    L1 = fq();
  }
  return L1;
}, x8 = () => (X6 || (X6 = mq()), X6), Ri = { WHITESPACE: /\s/u, HYPHEN: /-/u, OPENING: /<\(\[\{/u, CLOSING: />\)\]\}.,:;!\?…\//u }, Vl = { CHAR: new RegExp("\\p{Script=Han}\\p{Script=Hiragana}\\p{Script=Katakana}\\p{Script=Hangul}｀＇＾〃〰〆＃＆＊＋－ー／＼＝｜￤〒￢￣", "u"), OPENING: /（［｛〈《｟｢「『【〖〔〘〚＜〝/u, CLOSING: /）］｝〉》｠｣」』】〗〕〙〛＞。．，、〟‥？！：；・〜〞/u, CURRENCY: /￥￦￡￠＄/u }, Go = { FLAG: new RegExp("\\p{RI}\\p{RI}", "u"), JOINER: new RegExp("(?:\\p{Emoji_Modifier}|\\uFE0F\\u20E3?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?", "u"), ZWJ: /\u200D/u, ANY: /[\p{Emoji}]/u, MOST: /[\p{Extended_Pictographic}\p{Emoji_Presentation}]/u }, fq = () => Dt.or(x8(), $n.On(Ri.HYPHEN, Ri.WHITESPACE, Vl.CHAR)), pq = () => Dt.or(x8(), $n.Before(Ri.WHITESPACE).Build(), $n.After(Ri.WHITESPACE, Ri.HYPHEN).Build(), $n.Before(Vl.CHAR, Vl.CURRENCY).NotPrecededBy(Ri.OPENING, Vl.OPENING).Build(), $n.After(Vl.CHAR).NotFollowedBy(Ri.HYPHEN, Ri.CLOSING, Vl.CLOSING).Build(), $n.BeforeMany(Vl.OPENING).NotPrecededBy(Ri.OPENING).Build(), $n.AfterMany(Vl.CLOSING).NotFollowedBy(Ri.CLOSING).Build(), $n.AfterMany(Ri.CLOSING).FollowedBy(Ri.OPENING).Build()), mq = () => Dt.group(Dt.or(Go.FLAG, Dt.and(Go.MOST, Go.JOINER, Dt.build(`(?:${Go.ZWJ.source}(?:${Go.FLAG.source}|${Go.ANY.source}${Go.JOINER.source}))*`)))), Dt = { build: (e) => new RegExp(e, "u"), join: (...e) => e.map((t) => t.source).join(""), and: (...e) => Dt.build(Dt.join(...e)), or: (...e) => Dt.build(e.map((t) => t.source).join("|")), group: (...e) => Dt.build(`(${Dt.join(...e)})`), class: (...e) => Dt.build(`[${Dt.join(...e)}]`) }, $n = { On: (...e) => {
  let t = Dt.join(...e);
  return Dt.build(`([${t}])`);
}, Before: (...e) => {
  let t = Dt.join(...e), n = () => Dt.build(`(?=[${t}])`);
  return $n.Chain(n);
}, After: (...e) => {
  let t = Dt.join(...e), n = () => Dt.build(`(?<=[${t}])`);
  return $n.Chain(n);
}, BeforeMany: (...e) => {
  let t = Dt.join(...e), n = () => Dt.build(`(?<![${t}])(?=[${t}])`);
  return $n.Chain(n);
}, AfterMany: (...e) => {
  let t = Dt.join(...e), n = () => Dt.build(`(?<=[${t}])(?![${t}])`);
  return $n.Chain(n);
}, NotBefore: (...e) => {
  let t = Dt.join(...e), n = () => Dt.build(`(?![${t}])`);
  return $n.Chain(n);
}, NotAfter: (...e) => {
  let t = Dt.join(...e), n = () => Dt.build(`(?<![${t}])`);
  return $n.Chain(n);
}, Chain: (e) => ({ Build: e, PreceededBy: (...t) => {
  let n = e(), r = $n.After(...t).Build(), i = () => Dt.and(r, n);
  return $n.Chain(i);
}, FollowedBy: (...t) => {
  let n = e(), r = $n.Before(...t).Build(), i = () => Dt.and(n, r);
  return $n.Chain(i);
}, NotPrecededBy: (...t) => {
  let n = e(), r = $n.NotAfter(...t).Build(), i = () => Dt.and(r, n);
  return $n.Chain(i);
}, NotFollowedBy: (...t) => {
  let n = e(), r = $n.NotBefore(...t).Build(), i = () => Dt.and(n, r);
  return $n.Chain(i);
} }) }, gq = (e) => {
  let t = hq();
  return e.normalize("NFC").split(t).filter(Boolean);
}, cd = (e, t, n) => {
  if (!Number.isFinite(n) || n < 0) return e;
  let r = [], i = e.split(`
`);
  for (let a of i) {
    if (Gc(a, t) <= n) {
      r.push(a);
      continue;
    }
    let l = bq(a, t, n);
    r.push(...l);
  }
  return r.join(`
`);
}, bq = (e, t, n) => {
  let r = [], i = gq(e)[Symbol.iterator](), a = "", l = 0, s = i.next();
  for (; !s.done; ) {
    let c = s.value, d = a + c, o = yq(c) ? l + Xf.calculate(c, t) : Gc(d, t);
    if (/\s/.test(c) || o <= n) {
      a = d, l = o, s = i.next();
      continue;
    }
    if (a) r.push(a.trimEnd()), a = "", l = 0;
    else {
      let u = Uq(c, t, n), h = u[u.length - 1] ?? "", f = u.slice(0, -1);
      r.push(...f), a = h, l = Gc(h, t), s = i.next();
    }
  }
  if (a) {
    let c = vq(a, t, n);
    r.push(c);
  }
  return r;
}, Uq = (e, t, n) => {
  if (x8().test(e)) return [e];
  wq(e);
  let r = [], i = Array.from(e), a = "", l = 0;
  for (let s of i) {
    let c = Xf.calculate(s, t), d = l + c;
    if (d <= n) {
      a = a + s, l = d;
      continue;
    }
    a && r.push(a), a = s, l = c;
  }
  return a && r.push(a), r;
}, vq = (e, t, n) => {
  if (!(Gc(e, t) > n)) return e;
  let [, r, i] = e.match(/^(.+?)(\s+)$/) ?? [e, e.trimEnd(), ""], a = Gc(r, t);
  for (let l of Array.from(i)) {
    let s = Xf.calculate(l, t), c = a + s;
    if (c > n) break;
    r = r + l, a = c;
  }
  return r;
}, yq = (e) => e.codePointAt(0) !== void 0 && e.codePointAt(1) === void 0, wq = (e) => {
  if ((st.MODE === oi.TEST || st.DEV) && /\s/.test(e)) throw new Error("Word should not contain any whitespaces!");
}, Br = class {
};
$(Br, "rg", new Xh()), $(Br, "cache", /* @__PURE__ */ new WeakMap()), $(Br, "get", (e) => Br.cache.get(e)), $(Br, "set", (e, t) => Br.cache.set(e, t)), $(Br, "delete", (e) => Br.cache.delete(e)), $(Br, "destroy", () => {
  Br.cache = /* @__PURE__ */ new WeakMap();
}), $(Br, "generateElementShape", (e, t) => {
  let n = t != null && t.isExporting ? void 0 : Br.get(e);
  if (n !== void 0) return n;
  p7.delete(e);
  let r = Mre(e, Br.rg, t || { isExporting: !1, canvasBackgroundColor: ht.white, embedsValidationStatus: null });
  return Br.cache.set(e, r), r;
});
var wn = Br, va = (e) => "var(--icon-fill-color)", JI = (e) => e === gt.LIGHT ? wr.white : "#1e1e1e", Z = (e, t = 512) => {
  let { width: n = 512, height: r = n, mirror: i, style: a, ...l } = typeof t == "number" ? { width: t } : t;
  return m("svg", { "aria-hidden": "true", focusable: "false", role: "img", viewBox: `0 0 ${n} ${r}`, className: Me({ "rtl-mirror": i }), style: a, ...l, children: typeof e == "string" ? m("path", { fill: "currentColor", d: e }) : e });
}, ye = { width: 24, height: 24, fill: "none", strokeWidth: 2, stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" }, nt = { width: 20, height: 20, fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" };
Z(D("g", { strokeWidth: "1.5", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("rect", { x: 3, y: 8, width: 18, height: 4, rx: 1 }), m("line", { x1: 12, y1: 8, x2: 12, y2: 21 }), m("path", { d: "M19 12v7a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-7" }), m("path", { d: "M7.5 8a2.5 2.5 0 0 1 0 -5a4.8 8 0 0 1 4.5 5a4.8 8 0 0 1 4.5 -5a2.5 2.5 0 0 1 0 5" })] }), ye);
var E8 = Z(D("g", { strokeWidth: "1.25", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M3 19a9 9 0 0 1 9 0a9 9 0 0 1 9 0" }), m("path", { d: "M3 6a9 9 0 0 1 9 0a9 9 0 0 1 9 0" }), m("line", { x1: "3", y1: "6", x2: "3", y2: "19" }), m("line", { x1: "12", y1: "6", x2: "12", y2: "19" }), m("line", { x1: "21", y1: "6", x2: "21", y2: "19" })] }), ye), xq = Z(D("svg", { strokeWidth: "1.5", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("line", { x1: "12", y1: "5", x2: "12", y2: "19" }), m("line", { x1: "5", y1: "12", x2: "19", y2: "12" })] }), ye), Eq = Z(D("g", { strokeWidth: "1.5", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("circle", { cx: "12", cy: "12", r: "1" }), m("circle", { cx: "12", cy: "19", r: "1" }), m("circle", { cx: "12", cy: "5", r: "1" })] }), ye), Sq = Z(D("svg", { strokeWidth: "1.5", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M9 4v6l-2 4v2h10v-2l-2 -4v-6" }), m("line", { x1: "12", y1: "16", x2: "12", y2: "21" }), m("line", { x1: "8", y1: "4", x2: "16", y2: "4" })] }), ye), e2 = Z(D("g", { children: [m("path", { d: "M13.542 8.542H6.458a2.5 2.5 0 0 0-2.5 2.5v3.75a2.5 2.5 0 0 0 2.5 2.5h7.084a2.5 2.5 0 0 0 2.5-2.5v-3.75a2.5 2.5 0 0 0-2.5-2.5Z", stroke: "currentColor", strokeWidth: "1.25" }), m("path", { d: "M10 13.958a1.042 1.042 0 1 0 0-2.083 1.042 1.042 0 0 0 0 2.083Z", stroke: "currentColor", strokeWidth: "1.25" }), m("mask", { id: "UnlockedIcon", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: 6, y: 1, width: 9, height: 9, children: m("path", { stroke: "none", d: "M6.399 9.561V5.175c0-.93.401-1.823 1.116-2.48a3.981 3.981 0 0 1 2.693-1.028c1.01 0 1.98.37 2.694 1.027.715.658 1.116 1.55 1.116 2.481", fill: "#fff" }) }), m("g", { mask: "url(#UnlockedIcon)", children: m("path", { stroke: "none", d: "M5.149 9.561v1.25h2.5v-1.25h-2.5Zm5.06-7.894V.417v1.25Zm2.559 3.508v1.25h2.5v-1.25h-2.5ZM7.648 8.51V5.175h-2.5V8.51h2.5Zm0-3.334c0-.564.243-1.128.713-1.561L6.668 1.775c-.959.883-1.52 2.104-1.52 3.4h2.5Zm.713-1.561a2.732 2.732 0 0 1 1.847-.697v-2.5c-1.31 0-2.585.478-3.54 1.358L8.36 3.614Zm1.847-.697c.71 0 1.374.26 1.847.697l1.694-1.839a5.231 5.231 0 0 0-3.54-1.358v2.5Zm1.847.697c.47.433.713.997.713 1.561h2.5c0-1.296-.56-2.517-1.52-3.4l-1.693 1.839Z", fill: "currentColor" }) })] }), nt), S8 = Z(D("g", { strokeWidth: "1.25", children: [m("path", { d: "M13.542 8.542H6.458a2.5 2.5 0 0 0-2.5 2.5v3.75a2.5 2.5 0 0 0 2.5 2.5h7.084a2.5 2.5 0 0 0 2.5-2.5v-3.75a2.5 2.5 0 0 0-2.5-2.5Z" }), m("path", { d: "M10 13.958a1.042 1.042 0 1 0 0-2.083 1.042 1.042 0 0 0 0 2.083Z" }), m("path", { d: "M6.667 8.333V5.417C6.667 3.806 8.159 2.5 10 2.5c1.841 0 3.333 1.306 3.333 2.917v2.916" })] }), nt), _q = Z(D(ge, { children: [m("path", { d: "M38.5 83.5c-14-2-17.833-10.473-21-22.5C14.333 48.984 12 22 12 12.5", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round" }), m("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m12.005 10.478 7.905 14.423L6 25.75l6.005-15.273Z", fill: "currentColor" }), m("path", { d: "M12.005 10.478c1.92 3.495 3.838 7 7.905 14.423m-7.905-14.423c3.11 5.683 6.23 11.368 7.905 14.423m0 0c-3.68.226-7.35.455-13.91.85m13.91-.85c-5.279.33-10.566.647-13.91.85m0 0c1.936-4.931 3.882-9.86 6.005-15.273M6 25.75c2.069-5.257 4.135-10.505 6.005-15.272", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round" })] }), { width: 41, height: 94, fill: "none" }), kq = Z(D(ge, { children: [m("path", { d: "M18.026 1.232c-5.268 13.125-5.548 33.555 3.285 42.311 8.823 8.75 33.31 12.304 42.422 13.523", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round" }), m("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m72.181 59.247-13.058-10-2.948 13.62 16.006-3.62Z", fill: "currentColor" }), m("path", { d: "M72.181 59.247c-3.163-2.429-6.337-4.856-13.058-10m13.058 10c-5.145-3.936-10.292-7.882-13.058-10m0 0c-.78 3.603-1.563 7.196-2.948 13.62m2.948-13.62c-1.126 5.168-2.24 10.346-2.948 13.62m0 0c5.168-1.166 10.334-2.343 16.006-3.62m-16.006 3.62c5.51-1.248 11.01-2.495 16.006-3.62", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round" })] }), { width: 85, height: 71, fill: "none" }), Cq = Z(D(ge, { children: [m("path", { d: "M1 77c14-2 31.833-11.973 35-24 3.167-12.016-6-35-9.5-43.5", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round" }), m("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m24.165 1.093-2.132 16.309 13.27-4.258-11.138-12.05Z", fill: "currentColor" }), m("path", { d: "M24.165 1.093c-.522 3.953-1.037 7.916-2.132 16.309m2.131-16.309c-.835 6.424-1.68 12.854-2.13 16.308m0 0c3.51-1.125 7.013-2.243 13.27-4.257m-13.27 4.257c5.038-1.608 10.08-3.232 13.27-4.257m0 0c-3.595-3.892-7.197-7.777-11.14-12.05m11.14 12.05c-3.837-4.148-7.667-8.287-11.14-12.05", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round" })] }), { width: 38, height: 78, fill: "none" });
Z(m("g", { fill: "currentColor", children: m("path", { d: "M39.9 32.889a.326.326 0 0 0-.279-.056c-2.094-3.083-4.774-6-7.343-8.833l-.419-.472a.212.212 0 0 0-.056-.139.586.586 0 0 0-.167-.111l-.084-.083-.056-.056c-.084-.167-.28-.278-.475-.167-.782.39-1.507.973-2.206 1.528-.92.722-1.842 1.445-2.708 2.25a8.405 8.405 0 0 0-.977 1.028c-.14.194-.028.361.14.444-.615.611-1.23 1.223-1.843 1.861a.315.315 0 0 0-.084.223c0 .083.056.166.111.194l1.09.833v.028c1.535 1.528 4.244 3.611 7.12 5.861.418.334.865.667 1.284 1 .195.223.39.473.558.695.084.11.28.139.391.055.056.056.14.111.196.167a.398.398 0 0 0 .167.056.255.255 0 0 0 .224-.111.394.394 0 0 0 .055-.167c.029 0 .028.028.056.028a.318.318 0 0 0 .224-.084l5.082-5.528a.309.309 0 0 0 0-.444Zm-14.63-1.917a.485.485 0 0 0 .111.14c.586.5 1.2 1 1.843 1.555l-2.569-1.945-.251-.166c-.056-.028-.112-.084-.168-.111l-.195-.167.056-.056.055-.055.112-.111c.866-.861 2.346-2.306 3.1-3.028-.81.805-2.43 3.167-2.095 3.944Zm8.767 6.89-2.122-1.612a44.713 44.713 0 0 0-2.625-2.5c1.145.861 2.122 1.611 2.262 1.75 1.117.972 1.06.806 1.815 1.445l.921.666a1.06 1.06 0 0 1-.251.25Zm.558.416-.056-.028c.084-.055.168-.111.252-.194l-.196.222ZM1.089 5.75c.055.361.14.722.195 1.056.335 1.833.67 3.5 1.284 4.75l.252.944c.084.361.223.806.363.917 1.424 1.25 3.602 3.11 5.947 4.889a.295.295 0 0 0 .363 0s0 .027.028.027a.254.254 0 0 0 .196.084.318.318 0 0 0 .223-.084c2.988-3.305 5.221-6.027 6.813-8.305.112-.111.14-.278.14-.417.111-.111.195-.25.307-.333.111-.111.111-.306 0-.39l-.028-.027c0-.055-.028-.139-.084-.167-.698-.666-1.2-1.138-1.731-1.638-.922-.862-1.871-1.75-3.881-3.75l-.028-.028c-.028-.028-.056-.056-.112-.056-.558-.194-1.703-.389-3.127-.639C6.087 2.223 3.21 1.723.614.944c0 0-.168 0-.196.028l-.083.084c-.028.027-.056.055-.224.11h.056-.056c.028.167.028.278.084.473 0 .055.112.5.112.555l.782 3.556Zm15.496 3.278-.335-.334c.084.112.196.195.335.334Zm-3.546 4.666-.056.056c0-.028.028-.056.056-.056Zm-2.038-10c.168.167.866.834 1.033.973-.726-.334-2.54-1.167-3.379-1.445.838.167 1.983.334 2.346.472ZM1.424 2.306c.419.722.754 3.222 1.089 5.666-.196-.778-.335-1.555-.503-2.278-.251-1.277-.503-2.416-.838-3.416.056 0 .14 0 .252.028Zm-.168-.584c-.112 0-.223-.028-.307-.028 0-.027 0-.055-.028-.055.14 0 .223.028.335.083Zm-1.089.222c0-.027 0-.027 0 0ZM39.453 1.333c.028-.11-.558-.61-.363-.639.42-.027.42-.666 0-.666-.558.028-1.144.166-1.675.25-.977.194-1.982.389-2.96.61-2.205.473-4.383.973-6.561 1.557-.67.194-1.424.333-2.066.666-.224.111-.196.333-.084.472-.056.028-.084.028-.14.056-.195.028-.363.056-.558.083-.168.028-.252.167-.224.334 0 .027.028.083.028.11-1.173 1.556-2.485 3.195-3.909 4.945-1.396 1.611-2.876 3.306-4.356 5.056-4.719 5.5-10.052 11.75-15.943 17.25a.268.268 0 0 0 0 .389c.028.027.056.055.084.055-.084.084-.168.14-.252.222-.056.056-.084.111-.084.167a.605.605 0 0 0-.111.139c-.112.111-.112.305.028.389.111.11.307.11.39-.028.029-.028.029-.056.056-.056a.44.44 0 0 1 .615 0c.335.362.67.723.977 1.028l-.698-.583c-.112-.111-.307-.083-.39.028-.113.11-.085.305.027.389l7.427 6.194c.056.056.112.056.196.056s.14-.028.195-.084l.168-.166c.028.027.083.027.111.027.084 0 .14-.027.196-.083 10.052-10.055 18.15-17.639 27.42-24.417.083-.055.111-.166.111-.25.112 0 .196-.083.251-.194 1.704-5.194 2.039-9.806 2.15-12.083v-.028c0-.028.028-.056.028-.083.028-.056.028-.084.028-.084a1.626 1.626 0 0 0-.111-1.028ZM21.472 9.5c.446-.5.893-1.028 1.34-1.5-2.876 3.778-7.65 9.583-14.408 16.5 4.607-5.083 9.242-10.333 13.068-15ZM5.193 35.778h.084-.084Zm3.462 3.194c-.027-.028-.027-.028 0-.028v.028Zm4.16-3.583c.224-.25.448-.472.699-.722 0 0 0 .027.028.027-.252.223-.475.445-.726.695Zm1.146-1.111c.14-.14.279-.334.446-.5l.028-.028c1.648-1.694 3.351-3.389 5.082-5.111l.028-.028c.419-.333.921-.694 1.368-1.028a379.003 379.003 0 0 0-6.952 6.695ZM24.794 6.472c-.921 1.195-1.954 2.778-2.82 4.028-2.736 3.944-11.532 13.583-11.727 13.75a1976.983 1976.983 0 0 1-8.042 7.639l-.167.167c-.14-.167-.14-.417.028-.556C14.49 19.861 22.03 10.167 25.074 5.917c-.084.194-.14.36-.28.555Zm4.83 5.695c-1.116-.64-1.646-1.64-1.34-2.611l.084-.334c.028-.083.084-.194.14-.277.307-.5.754-.917 1.257-1.167.027 0 .055 0 .083-.028-.028-.056-.028-.139-.028-.222.028-.167.14-.278.335-.278.335 0 1.369.306 1.76.639.111.083.223.194.335.305.14.167.363.445.474.667.056.028.112.306.196.445.056.222.111.472.084.694-.028.028 0 .194-.028.194a2.668 2.668 0 0 1-.363 1.028c-.028.028-.028.056-.056.084l-.028.027c-.14.223-.335.417-.53.556-.643.444-1.369.583-2.095.389 0 0-.195-.084-.28-.111Zm8.154-.834a39.098 39.098 0 0 1-.893 3.167c0 .028-.028.083 0 .111-.056 0-.084.028-.14.056-2.206 1.61-4.356 3.305-6.506 5.028 1.843-1.64 3.686-3.306 5.613-4.945.558-.5.949-1.139 1.06-1.861l.28-1.667v-.055c.14-.334.67-.195.586.166Z", fill: "currentColor" }) }), { width: 40, height: 40, fill: "none" });
var Mq = Z(D("g", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M6 6l4.153 11.793a0.365 .365 0 0 0 .331 .207a0.366 .366 0 0 0 .332 -.207l2.184 -4.793l4.787 -1.994a0.355 .355 0 0 0 .213 -.323a0.355 .355 0 0 0 -.213 -.323l-11.787 -4.36z" }), m("path", { d: "M13.5 13.5l4.5 4.5" })] }), { fill: "none", width: 22, height: 22, strokeWidth: 1.25 }), Tq = Z(D("g", { strokeWidth: "1.5", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("rect", { x: "4", y: "4", width: "16", height: "16", rx: "2" })] }), ye), Iq = Z(D("g", { strokeWidth: "1.5", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M10.5 20.4l-6.9 -6.9c-.781 -.781 -.781 -2.219 0 -3l6.9 -6.9c.781 -.781 2.219 -.781 3 0l6.9 6.9c.781 .781 .781 2.219 0 3l-6.9 6.9c-.781 .781 -2.219 .781 -3 0z" })] }), ye), Aq = Z(D("g", { strokeWidth: "1.5", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("circle", { cx: "12", cy: "12", r: "9" })] }), ye), Nq = Z(D("g", { strokeWidth: "1.5", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("line", { x1: "5", y1: "12", x2: "19", y2: "12" }), m("line", { x1: "15", y1: "16", x2: "19", y2: "12" }), m("line", { x1: "15", y1: "8", x2: "19", y2: "12" })] }), ye), Dq = Z(m("path", { d: "M4.167 10h11.666", strokeWidth: "1.5" }), nt), Lq = Z(D("g", { strokeWidth: "1.25", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M20 17v-12c0 -1.121 -.879 -2 -2 -2s-2 .879 -2 2v12l2 2l2 -2z" }), m("path", { d: "M16 7h4" }), m("path", { d: "M18 19h-13a2 2 0 1 1 0 -4h4a2 2 0 1 0 0 -4h-3" })] }), ye), qh = Z(D("g", { strokeWidth: "1.25", children: [m("path", { clipRule: "evenodd", d: "m7.643 15.69 7.774-7.773a2.357 2.357 0 1 0-3.334-3.334L4.31 12.357a3.333 3.333 0 0 0-.977 2.357v1.953h1.953c.884 0 1.732-.352 2.357-.977Z" }), m("path", { d: "m11.25 5.417 3.333 3.333" })] }), nt), QI = Z(D("g", { strokeWidth: "1.5", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("line", { x1: "4", y1: "20", x2: "7", y2: "20" }), m("line", { x1: "14", y1: "20", x2: "21", y2: "20" }), m("line", { x1: "6.9", y1: "15", x2: "13.8", y2: "15" }), m("line", { x1: "10.2", y1: "6.3", x2: "16", y2: "20" }), m("polyline", { points: "5 20 11 4 13 4 20 20" })] }), ye), Rq = Z(D("g", { strokeWidth: "1.25", children: [m("path", { d: "M12.5 6.667h.01" }), m("path", { d: "M4.91 2.625h10.18a2.284 2.284 0 0 1 2.285 2.284v10.182a2.284 2.284 0 0 1-2.284 2.284H4.909a2.284 2.284 0 0 1-2.284-2.284V4.909a2.284 2.284 0 0 1 2.284-2.284Z" }), m("path", { d: "m3.333 12.5 3.334-3.333c.773-.745 1.726-.745 2.5 0l4.166 4.166" }), m("path", { d: "m11.667 11.667.833-.834c.774-.744 1.726-.744 2.5 0l1.667 1.667" })] }), nt), Pq = Z(D("g", { strokeWidth: "1.5", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M19 20h-10.5l-4.21 -4.3a1 1 0 0 1 0 -1.41l10 -10a1 1 0 0 1 1.41 0l5 5a1 1 0 0 1 0 1.41l-9.2 9.3" }), m("path", { d: "M18 13.3l-6.3 -6.3" })] }), ye), Qw = Z(m("path", { strokeWidth: "1.25", d: "M10 4.167v11.666M4.167 10h11.666" }), nt), ex = Z(m("path", { d: "M5 10h10", strokeWidth: "1.25" }), nt), Oq = Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M21 21l-6 -6" }), m("path", { d: "M3.268 12.043a7.017 7.017 0 0 0 6.634 4.957a7.012 7.012 0 0 0 7.043 -6.131a7 7 0 0 0 -5.314 -7.672a7.021 7.021 0 0 0 -8.241 4.403" }), m("path", { d: "M3 4v4h4" })] }), ye), jc = Z(m("path", { strokeWidth: "1.25", d: "M3.333 5.833h13.334M8.333 9.167v5M11.667 9.167v5M4.167 5.833l.833 10c0 .92.746 1.667 1.667 1.667h6.666c.92 0 1.667-.746 1.667-1.667l.833-10M7.5 5.833v-2.5c0-.46.373-.833.833-.833h3.334c.46 0 .833.373.833.833v2.5" }), nt), $q = Z(D("g", { strokeWidth: "1.25", children: [m("polyline", { points: "12 16 18 10 12 4" }), m("polyline", { points: "8 4 2 10 8 16" })] }), nt), l7 = Z(D("g", { strokeWidth: "1.25", children: [m("path", { d: "M14.375 6.458H8.958a2.5 2.5 0 0 0-2.5 2.5v5.417a2.5 2.5 0 0 0 2.5 2.5h5.417a2.5 2.5 0 0 0 2.5-2.5V8.958a2.5 2.5 0 0 0-2.5-2.5Z" }), m("path", { clipRule: "evenodd", d: "M11.667 3.125c.517 0 .986.21 1.325.55.34.338.55.807.55 1.325v1.458H8.333c-.485 0-.927.185-1.26.487-.343.312-.57.75-.609 1.24l-.005 5.357H5a1.87 1.87 0 0 1-1.326-.55 1.87 1.87 0 0 1-.549-1.325V5c0-.518.21-.987.55-1.326.338-.34.807-.549 1.325-.549h6.667Z" })] }), nt), s7 = Z(m("path", { clipRule: "evenodd", d: "M10 2.5h.328a6.25 6.25 0 0 0 6.6 10.372A7.5 7.5 0 1 1 10 2.493V2.5Z", stroke: "currentColor" }), nt), o7 = Z(m("g", { stroke: "currentColor", strokeLinejoin: "round", children: m("path", { d: "M10 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM10 4.167V2.5M14.167 5.833l1.166-1.166M15.833 10H17.5M14.167 14.167l1.166 1.166M10 15.833V17.5M5.833 14.167l-1.166 1.166M5 10H3.333M5.833 5.833 4.667 4.667" }) }), { ...nt, strokeWidth: 1.5 }), eA = Z(D("g", { strokeWidth: "1.5", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("line", { x1: "4", y1: "6", x2: "20", y2: "6" }), m("line", { x1: "4", y1: "12", x2: "20", y2: "12" }), m("line", { x1: "4", y1: "18", x2: "20", y2: "18" })] }), ye), t2 = Z(m("path", { strokeWidth: "1.25", d: "M3.333 14.167v1.666c0 .92.747 1.667 1.667 1.667h10c.92 0 1.667-.746 1.667-1.667v-1.666M5.833 9.167 10 13.333l4.167-4.166M10 3.333v10" }), nt), _8 = Z(D("g", { strokeWidth: "1.5", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("circle", { cx: "12", cy: "12", r: "9" }), m("line", { x1: "12", y1: "17", x2: "12", y2: "17.01" }), m("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" })] }), ye), Fq = Z(D("g", { strokeWidth: "1.25", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("circle", { cx: "12", cy: "12", r: "9" }), m("line", { x1: "12", y1: "17", x2: "12", y2: "17.01" }), m("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" })] }), ye), tx = Z(m("path", { strokeWidth: "1.25", d: "M9.167 5.833H5.833c-1.254 0-2.5 1.282-2.5 2.5v5.834c0 1.283 1.252 2.5 2.5 2.5h5.834c1.251 0 2.5-1.25 2.5-2.5v-3.334M8.333 11.667l8.334-8.334M12.5 3.333h4.167V7.5" }), nt), tA = Z(m("path", { d: "M7.5 15.833c-3.583 1.167-3.583-2.083-5-2.5m10 4.167v-2.917c0-.833.083-1.166-.417-1.666 2.334-.25 4.584-1.167 4.584-5a3.833 3.833 0 0 0-1.084-2.667 3.5 3.5 0 0 0-.083-2.667s-.917-.25-2.917 1.084a10.25 10.25 0 0 0-5.166 0C5.417 2.333 4.5 2.583 4.5 2.583a3.5 3.5 0 0 0-.083 2.667 3.833 3.833 0 0 0-1.084 2.667c0 3.833 2.25 4.75 4.584 5-.5.5-.5 1-.417 1.666V17.5", strokeWidth: "1.25" }), nt), zq = Z(D("g", { strokeWidth: "1.25", children: [m("path", { d: "M7.5 10.833a.833.833 0 1 0 0-1.666.833.833 0 0 0 0 1.666ZM12.5 10.833a.833.833 0 1 0 0-1.666.833.833 0 0 0 0 1.666ZM6.25 6.25c2.917-.833 4.583-.833 7.5 0M5.833 13.75c2.917.833 5.417.833 8.334 0" }), m("path", { d: "M12.917 14.167c0 .833 1.25 2.5 1.666 2.5 1.25 0 2.361-1.39 2.917-2.5.556-1.39.417-4.861-1.25-9.584-1.214-.846-2.5-1.116-3.75-1.25l-.833 2.084M7.083 14.167c0 .833-1.13 2.5-1.526 2.5-1.191 0-2.249-1.39-2.778-2.5-.529-1.39-.397-4.861 1.19-9.584 1.157-.846 2.318-1.116 3.531-1.25l.833 2.084" })] }), nt), Bq = Z(D("g", { strokeWidth: "1.25", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M4 4l11.733 16h4.267l-11.733 -16z" }), m("path", { d: "M4 20l6.768 -6.768m2.46 -2.46l6.772 -6.772" })] }), ye), Hq = Z(m("polyline", { fill: "none", stroke: "currentColor", points: "20 6 9 17 4 12" }), { width: 24, height: 24 }), c7 = Z(D("g", { strokeWidth: "1.25", children: [m("path", { d: "M8.333 11.667a2.917 2.917 0 0 0 4.167 0l3.333-3.334a2.946 2.946 0 1 0-4.166-4.166l-.417.416" }), m("path", { d: "M11.667 8.333a2.917 2.917 0 0 0-4.167 0l-3.333 3.334a2.946 2.946 0 0 0 4.166 4.166l.417-.416" })] }), nt), Wq = Z("M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z", { width: 448, height: 512 }), Xq = Z("M252 54L203 8a28 27 0 00-20-8H28C12 0 0 12 0 27v195c0 15 12 26 28 26h204c15 0 28-11 28-26V73a28 27 0 00-8-19zM130 213c-21 0-37-16-37-36 0-19 16-35 37-35 20 0 37 16 37 35 0 20-17 36-37 36zm56-169v56c0 4-4 6-7 6H44c-4 0-7-2-7-6V42c0-4 3-7 7-7h133l4 2 3 2a7 7 0 012 5z M296 201l87 95-188 205-78 9c-10 1-19-8-18-20l9-84zm141-14l-41-44a31 31 0 00-46 0l-38 41 87 95 38-42c13-14 13-36 0-50z", { width: 448, height: 512 }), k8 = Z(m("path", { d: "m9.257 6.351.183.183H15.819c.34 0 .727.182 1.051.506.323.323.505.708.505 1.05v5.819c0 .316-.183.7-.52 1.035-.337.338-.723.522-1.037.522H4.182c-.352 0-.74-.181-1.058-.5-.318-.318-.499-.705-.499-1.057V5.182c0-.351.181-.736.5-1.054.32-.321.71-.503 1.057-.503H6.53l2.726 2.726Z", strokeWidth: "1.25" }), nt);
Z("M384 112v352c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h80c0-35.29 28.71-64 64-64s64 28.71 64 64h80c26.51 0 48 21.49 48 48zM192 40c-13.255 0-24 10.745-24 24s10.745 24 24 24 24-10.745 24-24-10.745-24-24-24m96 114v-20a6 6 0 0 0-6-6H102a6 6 0 0 0-6 6v20a6 6 0 0 0 6 6h180a6 6 0 0 0 6-6z", { width: 384, height: 512 });
var Vq = Z("M204.3 5C104.9 24.4 24.8 104.3 5.2 203.4c-37 187 131.7 326.4 258.8 306.7 41.2-6.4 61.4-54.6 42.5-91.7-23.1-45.4 9.9-98.4 60.9-98.4h79.7c35.8 0 64.8-29.6 64.9-65.3C511.5 97.1 368.1-26.9 204.3 5zM96 320c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm32-128c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128-64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128 64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z"), V6 = Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M5 16l1.465 1.638a2 2 0 1 1 -3.015 .099l1.55 -1.737z" }), m("path", { d: "M13.737 9.737c2.299 -2.3 3.23 -5.095 2.081 -6.245c-1.15 -1.15 -3.945 -.217 -6.244 2.082c-2.3 2.299 -3.231 5.095 -2.082 6.244c1.15 1.15 3.946 .218 6.245 -2.081z" }), m("path", { d: "M7.492 11.818c.362 .362 .768 .676 1.208 .934l6.895 4.047c1.078 .557 2.255 -.075 3.692 -1.512c1.437 -1.437 2.07 -2.614 1.512 -3.692c-.372 -.718 -1.72 -3.017 -4.047 -6.895a6.015 6.015 0 0 0 -.934 -1.208" })] }), ye), nA = Z(D("g", { strokeWidth: "1.25", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M15 8h.01" }), m("path", { d: "M12 20h-5a3 3 0 0 1 -3 -3v-10a3 3 0 0 1 3 -3h10a3 3 0 0 1 3 3v5" }), m("path", { d: "M4 15l4 -4c.928 -.893 2.072 -.893 3 0l4 4" }), m("path", { d: "M14 14l1 -1c.617 -.593 1.328 -.793 2.009 -.598" }), m("path", { d: "M19 16v6" }), m("path", { d: "M22 19l-3 3l-3 -3" })] }), ye), Gq = Z("M216 0h80c13.3 0 24 10.7 24 24v168h87.7c17.8 0 26.7 21.5 14.1 34.1L269.7 378.3c-7.5 7.5-19.8 7.5-27.3 0L90.1 226.1c-12.6-12.6-3.7-34.1 14.1-34.1H192V24c0-13.3 10.7-24 24-24zm296 376v112c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V376c0-13.3 10.7-24 24-24h146.7l49 49c20.1 20.1 52.5 20.1 72.6 0l49-49H488c13.3 0 24 10.7 24 24zm-124 88c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20zm64 0c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20z", { width: 512, height: 512 });
Z("M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z", { width: 448, height: 512 });
Z("M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z", { width: 448, height: 512 });
var jq = Z("M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z");
Z("M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z");
var nx = Z(m("path", { d: "M7.5 10.833 4.167 7.5 7.5 4.167M4.167 7.5h9.166a3.333 3.333 0 0 1 0 6.667H12.5", strokeWidth: "1.25" }), nt), rx = Z(m("path", { d: "M12.5 10.833 15.833 7.5 12.5 4.167M15.833 7.5H6.667a3.333 3.333 0 1 0 0 6.667H7.5", strokeWidth: "1.25" }), nt), Kq = Z("M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z", { mirror: !0 });
Z(m("path", { d: "M5 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM15 7.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM15 17.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM7.25 8.917l5.5-2.834M7.25 11.083l5.5 2.834", strokeWidth: "1.5" }), nt);
Z("M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480H40c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24V296c0 13.3 10.7 24 24 24s24-10.7 24-24V184c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z");
Z("M16 5l-1.42 1.42-1.59-1.59V16h-1.98V4.83L9.42 6.42 8 5l4-4 4 4zm4 5v11c0 1.1-.9 2-2 2H6c-1.11 0-2-.9-2-2V10c0-1.11.89-2 2-2h3v2H6v11h12V10h-3V8h3c1.1 0 2 .89 2 2z", { width: 24, height: 24 });
Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M8 9h-1a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-8a2 2 0 0 0 -2 -2h-1" }), m("path", { d: "M12 14v-11" }), m("path", { d: "M9 6l3 -3l3 3" })] }), ye);
Z(D(ge, { children: [m("path", { fill: "currentColor", d: "M40 5.6v6.1l-4.1.7c-8.9 1.4-16.5 6.9-20.6 15C13 32 10.9 43 12.4 43c.4 0 2.4-1.3 4.4-3 5-3.9 12.1-7 18.2-7.7l5-.6v12.8l11.2-11.3L62.5 22 51.2 10.8 40-.5v6.1zm10.2 22.6L44 34.5v-6.8l-6.9.6c-3.9.3-9.8 1.7-13.2 3.1-3.5 1.4-6.5 2.4-6.7 2.2-.9-1 3-7.5 6.4-10.8C28 18.6 34.4 16 40.1 16c3.7 0 3.9-.1 3.9-3.2V9.5l6.2 6.3 6.3 6.2-6.3 6.2z" }), m("path", { stroke: "currentColor", fill: "currentColor", d: "M0 36v20h48v-6.2c0-6 0-6.1-2-4.3-1.1 1-2 2.9-2 4.2V52H4V34c0-17.3-.1-18-2-18s-2 .7-2 20z" })] }), { width: 64, height: 64 });
Z(m("path", { stroke: "currentColor", strokeWidth: "40", fill: "currentColor", d: "M148 560a318 318 0 0 0 522 110 316 316 0 0 0 0-450 316 316 0 0 0-450 0c-11 11-21 22-30 34v4h47c25 0 46 21 46 46s-21 45-46 45H90c-13 0-25-6-33-14-9-9-14-20-14-33V156c0-25 20-45 45-45s45 20 45 45v32l1 1a401 401 0 0 1 623 509l212 212a42 42 0 0 1-59 59L698 757A401 401 0 0 1 65 570a42 42 0 0 1 83-10z" }), { width: 1024 });
var rA = D("g", { strokeWidth: 1.5, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M12 10l0 10" }), m("path", { d: "M12 10l4 4" }), m("path", { d: "M12 10l-4 4" }), m("path", { d: "M4 4l16 0" })] }), iA = D("g", { strokeWidth: 1.5, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M12 5l0 14" }), m("path", { d: "M16 9l-4 -4" }), m("path", { d: "M8 9l4 -4" })] }), ix = Z(iA, ye), ax = Z(iA, { ...ye, style: { transform: "rotate(180deg)" } }), lx = Z(rA, ye), sx = Z(rA, { ...ye, style: { transform: "rotate(180deg)" } }), ox = Z(D(ge, { children: [D("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [m("path", { d: "M3.333 3.333h13.334", strokeLinecap: "round", strokeLinejoin: "round" }), m("path", { d: "M13.542 6.458h-.417c-.92 0-1.667.747-1.667 1.667v7.083c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667V8.125c0-.92-.746-1.667-1.666-1.667ZM6.875 6.458h-.417c-.92 0-1.666.747-1.666 1.667v3.75c0 .92.746 1.667 1.666 1.667h.417c.92 0 1.667-.746 1.667-1.667v-3.75c0-.92-.747-1.667-1.667-1.667Z" })] }), m("defs", { children: m("clipPath", { id: "a", children: m("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), nt), cx = Z(D(ge, { children: [D("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [m("path", { d: "M3.333 16.667h13.334", strokeLinecap: "round", strokeLinejoin: "round" }), m("path", { d: "M6.875 3.125h-.417c-.92 0-1.666.746-1.666 1.667v7.083c0 .92.746 1.667 1.666 1.667h.417c.92 0 1.667-.746 1.667-1.667V4.792c0-.92-.747-1.667-1.667-1.667ZM13.542 5.817h-.417c-.92 0-1.667.747-1.667 1.667v4.391c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667V7.484c0-.92-.746-1.667-1.666-1.667Z" })] }), m("defs", { children: m("clipPath", { id: "a", children: m("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), nt), dx = Z(D(ge, { children: [D("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [m("path", { d: "M3.333 3.333v13.334", strokeLinecap: "round", strokeLinejoin: "round" }), m("path", { d: "M15.208 4.792H8.125c-.92 0-1.667.746-1.667 1.666v.417c0 .92.747 1.667 1.667 1.667h7.083c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666ZM12.516 11.458H8.125c-.92 0-1.667.746-1.667 1.667v.417c0 .92.747 1.666 1.667 1.666h4.391c.92 0 1.667-.746 1.667-1.666v-.417c0-.92-.746-1.667-1.667-1.667Z" })] }), m("defs", { children: m("clipPath", { id: "a", children: m("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), nt), ux = Z(D(ge, { children: [D("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [m("path", { d: "M16.667 3.333v13.334", strokeLinecap: "round", strokeLinejoin: "round" }), m("path", { d: "M11.875 4.792H4.792c-.92 0-1.667.746-1.667 1.666v.417c0 .92.746 1.667 1.667 1.667h7.083c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666ZM11.683 11.458H7.292c-.92 0-1.667.746-1.667 1.667v.417c0 .92.746 1.666 1.667 1.666h4.39c.921 0 1.667-.746 1.667-1.666v-.417c0-.92-.746-1.667-1.666-1.667Z" })] }), m("defs", { children: m("clipPath", { id: "a", children: m("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), nt), Yq = Z(D(ge, { children: [D("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [m("path", { d: "M16.667 3.333v13.334M3.333 3.333v13.334", strokeLinecap: "round", strokeLinejoin: "round" }), m("path", { d: "M14.375 10.208v-.416c0-.92-.746-1.667-1.667-1.667H7.292c-.92 0-1.667.746-1.667 1.667v.416c0 .92.746 1.667 1.667 1.667h5.416c.92 0 1.667-.746 1.667-1.667Z" })] }), m("defs", { children: m("clipPath", { id: "a", children: m("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), nt), qq = Z(D(ge, { children: [D("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [m("path", { d: "M3.333 3.333h13.334M3.333 16.667h13.334", strokeLinecap: "round", strokeLinejoin: "round" }), m("path", { d: "M10.208 5.625h-.416c-.92 0-1.667.746-1.667 1.667v5.416c0 .92.746 1.667 1.667 1.667h.416c.92 0 1.667-.746 1.667-1.667V7.292c0-.92-.746-1.667-1.667-1.667Z" })] }), m("defs", { children: m("clipPath", { id: "a", children: m("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), nt), hx = Z(D("g", { stroke: "currentColor", strokeWidth: "1.25", children: [m("path", { d: "M1.667 10h2.916", strokeLinecap: "round", strokeLinejoin: "round" }), m("path", { d: "M8.333 10h3.334", strokeLinejoin: "round" }), m("path", { d: "M15.417 10h2.916", strokeLinecap: "round", strokeLinejoin: "round" }), m("path", { d: "M6.875 4.792h-.417c-.92 0-1.666.746-1.666 1.666v7.084c0 .92.746 1.666 1.666 1.666h.417c.92 0 1.667-.746 1.667-1.666V6.458c0-.92-.747-1.666-1.667-1.666ZM13.542 6.458h-.417c-.92 0-1.667.747-1.667 1.667v3.75c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667v-3.75c0-.92-.746-1.667-1.666-1.667Z" })] }), nt), fx = Z(D("g", { stroke: "currentColor", strokeWidth: "1.25", children: [m("path", { d: "M10 18.333v-2.916", strokeLinecap: "round", strokeLinejoin: "round" }), m("path", { d: "M10 11.667V8.333", strokeLinejoin: "round" }), m("path", { d: "M10 4.583V1.667", strokeLinecap: "round", strokeLinejoin: "round" }), m("path", { d: "M4.792 13.125v.417c0 .92.746 1.666 1.666 1.666h7.084c.92 0 1.666-.746 1.666-1.666v-.417c0-.92-.746-1.667-1.666-1.667H6.458c-.92 0-1.666.746-1.666 1.667ZM6.458 6.458v.417c0 .92.747 1.667 1.667 1.667h3.75c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666h-3.75c-.92 0-1.667.746-1.667 1.666Z" })] }), nt), aA = Z(D("g", { strokeWidth: "1.5", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("circle", { cx: "9", cy: "7", r: "4" }), m("path", { d: "M3 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" }), m("path", { d: "M16 3.13a4 4 0 0 1 0 7.75" }), m("path", { d: "M21 21v-2a4 4 0 0 0 -3 -3.85" })] }), ye);
Z("M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm115.7 272l-176 101c-15.8 8.8-35.7-2.5-35.7-21V152c0-18.4 19.8-29.8 35.7-21l176 107c16.4 9.2 16.4 32.9 0 42z");
Z("M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm96 328c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V176c0-8.8 7.2-16 16-16h160c8.8 0 16 7.2 16 16v160z");
var iu = Z(D(ge, { children: [m("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round", children: m("path", { d: "M15 5 5 15M5 5l10 10" }) }), m("defs", { children: m("clipPath", { id: "a", children: m("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), nt);
Z("M464 0c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48H176c-26.51 0-48-21.49-48-48V48c0-26.51 21.49-48 48-48h288M176 416c-44.112 0-80-35.888-80-80V128H48c-26.51 0-48 21.49-48 48v288c0 26.51 21.49 48 48 48h288c26.51 0 48-21.49 48-48v-48H176z", { mirror: !0 });
Z("M11.553 22.894a.998.998 0 00.894 0s3.037-1.516 5.465-4.097C19.616 16.987 21 14.663 21 12V5a1 1 0 00-.649-.936l-8-3a.998.998 0 00-.702 0l-8 3A1 1 0 003 5v7c0 2.663 1.384 4.987 3.088 6.797 2.428 2.581 5.465 4.097 5.465 4.097zm-1.303-8.481l6.644-6.644a.856.856 0 111.212 1.212l-7.25 7.25a.856.856 0 01-1.212 0l-3.75-3.75a.856.856 0 111.212-1.212l3.144 3.144z", { width: 24 });
Z("M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm32-48h224V288l-23.5-23.5c-4.7-4.7-12.3-4.7-17 0L176 352l-39.5-39.5c-4.7-4.7-12.3-4.7-17 0L80 352v64zm48-240c-26.5 0-48 21.5-48 48s21.5 48 48 48 48-21.5 48-48-21.5-48-48-48z", { width: 384, height: 512 });
var px = pe.memo(({ theme: e }) => Z(D(ge, { children: [m("path", { d: "M25 26H111V111H25", fill: va() }), m("path", { d: "M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z", stroke: va(), strokeWidth: "2" }), m("path", { d: "M100 100H160V160H100", fill: va() }), m("path", { d: "M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z", stroke: va(), strokeWidth: "2" }), D("g", { fill: JI(e), stroke: va(), strokeWidth: "6", children: [m("rect", { x: "2.5", y: "2.5", width: "30", height: "30" }), m("rect", { x: "2.5", y: "149.5", width: "30", height: "30" }), m("rect", { x: "147.5", y: "149.5", width: "30", height: "30" }), m("rect", { x: "147.5", y: "2.5", width: "30", height: "30" })] })] }), { width: 182, height: 182, mirror: !0 })), mx = pe.memo(({ theme: e }) => Z(D(ge, { children: [m("path", { d: "M25 26H111V111H25", fill: va() }), m("path", { d: "M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z", stroke: va(), strokeWidth: "2" }), m("path", { d: "M100 100H160V160H100", fill: va() }), m("path", { d: "M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z", stroke: va(), strokeWidth: "2" }), D("g", { fill: JI(e), stroke: va(), strokeWidth: "6", children: [m("rect", { x: "2.5", y: "2.5", width: "30", height: "30" }), m("rect", { x: "78.5", y: "149.5", width: "30", height: "30" }), m("rect", { x: "147.5", y: "149.5", width: "30", height: "30" }), m("rect", { x: "147.5", y: "78.5", width: "30", height: "30" }), m("rect", { x: "105.5", y: "2.5", width: "30", height: "30" }), m("rect", { x: "2.5", y: "102.5", width: "30", height: "30" })] })] }), { width: 182, height: 182, mirror: !0 })), Zq = Z(m("g", { strokeWidth: 1.25, children: m("path", { d: "M5.879 2.625h8.242a3.27 3.27 0 0 1 3.254 3.254v8.242a3.27 3.27 0 0 1-3.254 3.254H5.88a3.27 3.27 0 0 1-3.254-3.254V5.88A3.27 3.27 0 0 1 5.88 2.626l-.001-.001ZM4.518 16.118l7.608-12.83m.198 13.934 5.051-9.897M2.778 9.675l9.348-6.387m-7.608 12.83 12.857-8.793" }) }), nt), Jq = Z(D(ge, { children: [m("path", { d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z", stroke: "currentColor", strokeWidth: "1.25" }), m("mask", { id: "FillHachureIcon", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: 2, y: 2, width: 16, height: 16, children: m("path", { d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z", fill: "currentColor", stroke: "currentColor", strokeWidth: "1.25" }) }), m("g", { mask: "url(#FillHachureIcon)", children: m("path", { d: "M2.258 15.156 15.156 2.258M7.324 20.222 20.222 7.325m-20.444 5.35L12.675-.222m-8.157 18.34L17.416 5.22", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round" }) })] }), nt), Qq = Z(D(ge, { children: [D("g", { clipPath: "url(#a)", children: [m("path", { d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z", stroke: "currentColor", strokeWidth: "1.25" }), m("mask", { id: "FillCrossHatchIcon", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: -1, y: -1, width: 22, height: 22, children: m("path", { d: "M2.426 15.044 15.044 2.426M7.383 20 20 7.383M0 12.617 12.617 0m-7.98 17.941L17.256 5.324m-2.211 12.25L2.426 4.956M20 12.617 7.383 0m5.234 20L0 7.383m17.941 7.98L5.324 2.745", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round" }) }), m("g", { mask: "url(#FillCrossHatchIcon)", children: m("path", { d: "M14.121 2H5.88A3.879 3.879 0 0 0 2 5.879v8.242A3.879 3.879 0 0 0 5.879 18h8.242A3.879 3.879 0 0 0 18 14.121V5.88A3.879 3.879 0 0 0 14.121 2Z", fill: "currentColor" }) })] }), m("defs", { children: m("clipPath", { id: "a", children: m("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), nt), eZ = Z(D(ge, { children: [m("g", { clipPath: "url(#a)", children: m("path", { d: "M4.91 2.625h10.18a2.284 2.284 0 0 1 2.285 2.284v10.182a2.284 2.284 0 0 1-2.284 2.284H4.909a2.284 2.284 0 0 1-2.284-2.284V4.909a2.284 2.284 0 0 1 2.284-2.284Z", stroke: "currentColor", strokeWidth: "1.25" }) }), m("defs", { children: m("clipPath", { id: "a", children: m("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), { ...nt, fill: "currentColor" }), lA = Z(m(ge, { children: m("path", { d: "M4.167 10h11.666", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round" }) }), nt), tZ = Z(m("path", { d: "M5 10h10", stroke: "currentColor", strokeWidth: "2.5", strokeLinecap: "round", strokeLinejoin: "round" }), nt), nZ = Z(m("path", { d: "M5 10h10", stroke: "currentColor", strokeWidth: "3.75", strokeLinecap: "round", strokeLinejoin: "round" }), nt);
pe.memo(({ theme: e }) => Z(m("path", { d: "M6 10H34", stroke: va(), strokeWidth: 2, fill: "none", strokeLinecap: "round" }), { width: 40, height: 20 }));
var rZ = Z(D("g", { strokeWidth: "2", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M5 12h2" }), m("path", { d: "M17 12h2" }), m("path", { d: "M11 12h2" })] }), ye), iZ = Z(D("g", { strokeWidth: "2", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M4 12v.01" }), m("path", { d: "M8 12v.01" }), m("path", { d: "M12 12v.01" }), m("path", { d: "M16 12v.01" }), m("path", { d: "M20 12v.01" })] }), ye), aZ = Z(m("path", { d: "M2.5 12.038c1.655-.885 5.9-3.292 8.568-4.354 2.668-1.063.101 2.821 1.32 3.104 1.218.283 5.112-1.814 5.112-1.814", strokeWidth: "1.25" }), nt), lZ = Z(m("path", { d: "M2.5 12.563c1.655-.886 5.9-3.293 8.568-4.355 2.668-1.062.101 2.822 1.32 3.105 1.218.283 5.112-1.814 5.112-1.814m-13.469 2.23c2.963-1.586 6.13-5.62 7.468-4.998 1.338.623-1.153 4.11-.132 5.595 1.02 1.487 6.133-1.43 6.133-1.43", strokeWidth: "1.25" }), nt), sZ = Z(m("path", { d: "M2.5 11.936c1.737-.879 8.627-5.346 10.42-5.268 1.795.078-.418 5.138.345 5.736.763.598 3.53-1.789 4.235-2.147M2.929 9.788c1.164-.519 5.47-3.28 6.987-3.114 1.519.165 1 3.827 2.121 4.109 1.122.281 3.839-2.016 4.606-2.42", strokeWidth: "1.25" }), nt), oZ = Z(D("svg", { strokeWidth: "1.5", children: [m("path", { d: "M3.33334 9.99998V6.66665C3.33334 6.04326 3.33403 4.9332 3.33539 3.33646C4.95233 3.33436 6.06276 3.33331 6.66668 3.33331H10" }), m("path", { d: "M13.3333 3.33331V3.34331" }), m("path", { d: "M16.6667 3.33331V3.34331" }), m("path", { d: "M16.6667 6.66669V6.67669" }), m("path", { d: "M16.6667 10V10.01" }), m("path", { d: "M3.33334 13.3333V13.3433" }), m("path", { d: "M16.6667 13.3333V13.3433" }), m("path", { d: "M3.33334 16.6667V16.6767" }), m("path", { d: "M6.66666 16.6667V16.6767" }), m("path", { d: "M10 16.6667V16.6767" }), m("path", { d: "M13.3333 16.6667V16.6767" }), m("path", { d: "M16.6667 16.6667V16.6767" })] }), nt), cZ = Z(D("g", { strokeWidth: "1.5", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M4 12v-4a4 4 0 0 1 4 -4h4" }), m("line", { x1: "16", y1: "4", x2: "16", y2: "4.01" }), m("line", { x1: "20", y1: "4", x2: "20", y2: "4.01" }), m("line", { x1: "20", y1: "8", x2: "20", y2: "8.01" }), m("line", { x1: "20", y1: "12", x2: "20", y2: "12.01" }), m("line", { x1: "4", y1: "16", x2: "4", y2: "16.01" }), m("line", { x1: "20", y1: "16", x2: "20", y2: "16.01" }), m("line", { x1: "4", y1: "20", x2: "4", y2: "20.01" }), m("line", { x1: "8", y1: "20", x2: "8", y2: "20.01" }), m("line", { x1: "12", y1: "20", x2: "12", y2: "20.01" }), m("line", { x1: "16", y1: "20", x2: "16", y2: "20.01" }), m("line", { x1: "20", y1: "20", x2: "20", y2: "20.01" })] }), ye), dZ = Z(D("g", { stroke: "currentColor", opacity: 0.3, strokeWidth: 2, children: [m("path", { d: "M12 12l9 0" }), m("path", { d: "M3 9l6 6" }), m("path", { d: "M3 15l6 -6" })] }), ye), uZ = pe.memo(({ flip: e = !1 }) => Z(D("g", { transform: e ? "translate(40, 0) scale(-1, 1)" : "", stroke: "currentColor", strokeWidth: 2, fill: "none", children: [m("path", { d: "M34 10H6M34 10L27 5M34 10L27 15" }), m("path", { d: "M27.5 5L34.5 10L27.5 15" })] }), { width: 40, height: 20 })), hZ = pe.memo(({ flip: e = !1 }) => Z(D("g", { stroke: "currentColor", fill: "currentColor", transform: e ? "translate(40, 0) scale(-1, 1)" : "", children: [m("path", { d: "M32 10L6 10", strokeWidth: 2 }), m("circle", { r: "4", transform: "matrix(-1 0 0 1 30 10)" })] }), { width: 40, height: 20 })), fZ = pe.memo(({ flip: e = !1 }) => Z(D("g", { stroke: "currentColor", fill: "none", transform: e ? "translate(40, 0) scale(-1, 1)" : "", strokeWidth: 2, children: [m("path", { d: "M26 10L6 10" }), m("circle", { r: "4", transform: "matrix(-1 0 0 1 30 10)" })] }), { width: 40, height: 20 })), pZ = pe.memo(({ flip: e = !1 }) => Z(m("g", { transform: e ? "translate(40, 0) scale(-1, 1)" : "", children: m("path", { d: "M34 10H5.99996M34 10L34 5M34 10L34 15", stroke: "currentColor", strokeWidth: 2, fill: "none" }) }), { width: 40, height: 20 })), mZ = pe.memo(({ flip: e = !1 }) => Z(D("g", { stroke: "currentColor", fill: "currentColor", transform: e ? "translate(40, 0) scale(-1, 1)" : "", children: [m("path", { d: "M32 10L6 10", strokeWidth: 2 }), m("path", { d: "M27.5 5.5L34.5 10L27.5 14.5L27.5 5.5" })] }), { width: 40, height: 20 })), gZ = pe.memo(({ flip: e = !1 }) => Z(D("g", { stroke: "currentColor", fill: "none", transform: e ? "translate(40, 0) scale(-1, 1)" : "", strokeWidth: 2, strokeLinejoin: "round", children: [m("path", { d: "M6,9.5H27" }), m("path", { d: "M27,5L34,10L27,14Z", fill: "none" })] }), { width: 40, height: 20 })), bZ = pe.memo(({ flip: e = !1 }) => Z(D("g", { stroke: "currentColor", fill: "currentColor", transform: e ? "translate(40, 0) scale(-1, 1)" : "", strokeLinejoin: "round", strokeWidth: 2, children: [m("path", { d: "M6,9.5H20" }), m("path", { d: "M27,5L34,10L27,14L20,9.5Z" })] }), { width: 40, height: 20 })), UZ = pe.memo(({ flip: e = !1 }) => Z(D("g", { stroke: "currentColor", fill: "none", transform: e ? "translate(40, 0) scale(-1, 1)" : "", strokeLinejoin: "round", strokeWidth: 2, children: [m("path", { d: "M6,9.5H20" }), m("path", { d: "M27,5L34,10L27,14L20,9.5Z" })] }), { width: 40, height: 20 })), vZ = pe.memo(({ flip: e = !1 }) => Z(m("g", { stroke: "currentColor", fill: "none", transform: e ? "" : "translate(40, 0) scale(-1, 1)", strokeLinejoin: "round", strokeWidth: 2, children: m("path", { d: "M34,10 H6 M15,10 L7,5 M15,10 L7,15" }) }), { width: 40, height: 20 })), yZ = pe.memo(({ flip: e = !1 }) => Z(m("g", { stroke: "currentColor", fill: "none", transform: e ? "" : "translate(40, 0) scale(-1, 1)", strokeLinejoin: "round", strokeWidth: 2, children: m("path", { d: "M34,10 H6 M15,10 L15,15 L15,5" }) }), { width: 40, height: 20 })), wZ = pe.memo(({ flip: e = !1 }) => Z(m("g", { stroke: "currentColor", fill: "none", transform: e ? "" : "translate(40, 0) scale(-1, 1)", strokeLinejoin: "round", strokeWidth: 2, children: m("path", { d: "M34,10 H6 M15,10 L15,16 L15,4 M15,10 L7,5 M15,10 L7,15" }) }), { width: 40, height: 20 })), xZ = Z(D(ge, { children: [m("g", { clipPath: "url(#a)", children: m("path", { d: "M14.167 6.667a3.333 3.333 0 0 0-3.334-3.334H9.167a3.333 3.333 0 0 0 0 6.667h1.666a3.333 3.333 0 0 1 0 6.667H9.167a3.333 3.333 0 0 1-3.334-3.334", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round" }) }), m("defs", { children: m("clipPath", { id: "a", children: m("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), nt), EZ = Z(D(ge, { children: [m("g", { clipPath: "url(#a)", children: m("path", { d: "M5 16.667V3.333L10 15l5-11.667v13.334", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round" }) }), m("defs", { children: m("clipPath", { id: "a", children: m("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), nt), SZ = Z(D(ge, { children: [m("g", { clipPath: "url(#a)", children: m("path", { d: "M5.833 3.333v13.334h8.334", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round" }) }), m("defs", { children: m("clipPath", { id: "a", children: m("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), nt), _Z = Z(m(ge, { children: m("path", { d: "m1.667 3.333 6.666 13.334M8.333 3.333 1.667 16.667M11.667 3.333v13.334h6.666", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round" }) }), nt), n2 = Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M3 7v-2h13v2" }), m("path", { d: "M10 5v14" }), m("path", { d: "M12 19h-4" }), m("path", { d: "M15 13v-1h6v1" }), m("path", { d: "M18 12v7" }), m("path", { d: "M17 19h2" })] }), ye), kZ = Z(m(ge, { children: D("g", { stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M7 12h10" }), m("path", { d: "M7 5v14" }), m("path", { d: "M17 5v14" }), m("path", { d: "M15 19h4" }), m("path", { d: "M15 5h4" }), m("path", { d: "M5 19h4" }), m("path", { d: "M5 5h4" })] }) }), ye), Cm = Z(m(ge, { children: m("g", { stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round", children: m("path", { d: "M5.833 16.667v-10a3.333 3.333 0 0 1 3.334-3.334h1.666a3.333 3.333 0 0 1 3.334 3.334v10M5.833 10.833h8.334" }) }) }), nt), d7 = Z(D(ge, { children: [m("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round", children: m("path", { d: "M5.833 6.667 2.5 10l3.333 3.333M14.167 6.667 17.5 10l-3.333 3.333M11.667 3.333 8.333 16.667" }) }), m("defs", { children: m("clipPath", { id: "a", children: m("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), nt), CZ = Z(D("g", { stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("line", { x1: "4", y1: "8", x2: "20", y2: "8" }), m("line", { x1: "4", y1: "12", x2: "12", y2: "12" }), m("line", { x1: "4", y1: "16", x2: "16", y2: "16" })] }), ye), MZ = Z(D("g", { stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("line", { x1: "4", y1: "8", x2: "20", y2: "8" }), m("line", { x1: "8", y1: "12", x2: "16", y2: "12" }), m("line", { x1: "6", y1: "16", x2: "18", y2: "16" })] }), ye), TZ = Z(D("g", { stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("line", { x1: "4", y1: "8", x2: "20", y2: "8" }), m("line", { x1: "10", y1: "12", x2: "20", y2: "12" }), m("line", { x1: "8", y1: "16", x2: "20", y2: "16" })] }), ye), IZ = pe.memo(({ theme: e }) => Z(D("g", { strokeWidth: "1.5", stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("line", { x1: "4", y1: "4", x2: "20", y2: "4" }), m("rect", { x: "9", y: "8", width: "6", height: "12", rx: "2" })] }), ye)), AZ = pe.memo(({ theme: e }) => Z(D("g", { strokeWidth: "2", stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("line", { x1: "4", y1: "20", x2: "20", y2: "20" }), m("rect", { x: "9", y: "4", width: "6", height: "12", rx: "2" })] }), ye)), NZ = pe.memo(({ theme: e }) => Z(D("g", { strokeWidth: "1.5", stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("line", { x1: "4", y1: "12", x2: "9", y2: "12" }), m("line", { x1: "15", y1: "12", x2: "20", y2: "12" }), m("rect", { x: "9", y: "6", width: "6", height: "12", rx: "2" })] }), ye)), sA = Z(D("g", { children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M21 19h-18l9 -15" }), m("path", { d: "M20.615 15.171h.015" }), m("path", { d: "M19.515 11.771h.015" }), m("path", { d: "M17.715 8.671h.015" }), m("path", { d: "M15.415 5.971h.015" })] }), ye), DZ = Z(m("path", { d: "M537.6 226.6c4.1-10.7 6.4-22.4 6.4-34.6 0-53-43-96-96-96-19.7 0-38.1 6-53.3 16.2C367 64.2 315.3 32 256 32c-88.4 0-160 71.6-160 160 0 2.7.1 5.4.2 8.1C40.2 219.8 0 273.2 0 336c0 79.5 64.5 144 144 144h368c70.7 0 128-57.3 128-128 0-61.9-44-113.6-102.4-125.4zM393.4 288H328v112c0 8.8-7.2 16-16 16h-48c-8.8 0-16-7.2-16-16V288h-65.4c-14.3 0-21.4-17.2-11.3-27.3l105.4-105.4c6.2-6.2 16.4-6.2 22.6 0l105.4 105.4c10.1 10.1 2.9 27.3-11.3 27.3z", fill: "currentColor" }), { width: 640, height: 512 });
Z(m("path", { d: "M480 416C497.7 416 512 430.3 512 448C512 465.7 497.7 480 480 480H150.6C133.7 480 117.4 473.3 105.4 461.3L25.37 381.3C.3786 356.3 .3786 315.7 25.37 290.7L258.7 57.37C283.7 32.38 324.3 32.38 349.3 57.37L486.6 194.7C511.6 219.7 511.6 260.3 486.6 285.3L355.9 416H480zM265.4 416L332.7 348.7L195.3 211.3L70.63 336L150.6 416L265.4 416z" }));
var oA = Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M8 13v-7.5a1.5 1.5 0 0 1 3 0v6.5" }), m("path", { d: "M11 5.5v-2a1.5 1.5 0 1 1 3 0v8.5" }), m("path", { d: "M14 5.5a1.5 1.5 0 0 1 3 0v6.5" }), m("path", { d: "M17 7.5a1.5 1.5 0 0 1 3 0v8.5a6 6 0 0 1 -6 6h-2h.208a6 6 0 0 1 -5.012 -2.7a69.74 69.74 0 0 1 -.196 -.3c-.312 -.479 -1.407 -2.388 -3.286 -5.728a1.5 1.5 0 0 1 .536 -2.022a1.867 1.867 0 0 1 2.28 .28l1.47 1.47" })] }), ye), gx = Z(D(ge, { children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2" }), m("path", { d: "M7 11l5 5l5 -5" }), m("path", { d: "M12 4l0 12" })] }), ye), C8 = Z(D(ge, { children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z" }), m("path", { d: "M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2" })] }), ye), LZ = Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M7 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" }), m("path", { d: "M17 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" }), m("path", { d: "M9.15 14.85l8.85 -10.85" }), m("path", { d: "M6 4l8.85 10.85" })] }), ye), RZ = Z(D(ge, { children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" }), m("path", { d: "M12 17l0 .01" }), m("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" })] }), ye);
Z(D(ge, { children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M7 4v16l13 -8z" })] }), ye);
Z(D(ge, { children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M17 4h-10a3 3 0 0 0 -3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3 -3v-10a3 3 0 0 0 -3 -3z", strokeWidth: "0", fill: "currentColor" })] }), ye);
var PZ = Z(D(ge, { children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M5 12l5 5l10 -10" })] }), ye), OZ = Z(D(ge, { children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M10.24 3.957l-8.422 14.06a1.989 1.989 0 0 0 1.7 2.983h16.845a1.989 1.989 0 0 0 1.7 -2.983l-8.423 -14.06a1.989 1.989 0 0 0 -3.4 0z" }), m("path", { d: "M12 9v4" }), m("path", { d: "M12 17h.01" })] }), ye), $Z = Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M11 7l6 6" }), m("path", { d: "M4 16l11.7 -11.7a1 1 0 0 1 1.4 0l2.6 2.6a1 1 0 0 1 0 1.4l-11.7 11.7h-4v-4z" })] }), ye), FZ = Z(D("g", { strokeWidth: 1.5, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M12 3l-4 7h8z" }), m("path", { d: "M17 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" }), m("path", { d: "M4 14m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z" })] }), ye), cA = Z(D("g", { strokeWidth: 1.5, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M4 7l16 0" }), m("path", { d: "M4 17l16 0" }), m("path", { d: "M7 4l0 16" }), m("path", { d: "M17 4l0 16" })] }), ye), dA = Z(m("path", { fill: "currentColor", d: "M407.48,111.18C335.587,108.103 269.573,152.338 245.08,220C220.587,152.338 154.573,108.103 82.68,111.18C80.285,168.229 107.577,222.632 154.74,254.82C178.908,271.419 193.35,298.951 193.27,328.27L193.27,379.13L296.9,379.13L296.9,328.27C296.816,298.953 311.255,271.42 335.42,254.82C382.596,222.644 409.892,168.233 407.48,111.18Z" })), mp = Z(D("g", { strokeWidth: "1.25", children: [m("path", { d: "M4.16602 10H15.8327" }), m("path", { d: "M12.5 13.3333L15.8333 10" }), m("path", { d: "M12.5 6.66666L15.8333 9.99999" })] }), nt), uA = Z(D("g", { fill: "none", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round", transform: "rotate(90 10 10)", children: [m("path", { clipRule: "evenodd", d: "m9.644 13.69 7.774-7.773a2.357 2.357 0 0 0-3.334-3.334l-7.773 7.774L8 12l1.643 1.69Z" }), m("path", { d: "m13.25 3.417 3.333 3.333M10 10l2-2M5 15l3-3M2.156 17.894l1-1M5.453 19.029l-.144-1.407M2.377 11.887l.866 1.118M8.354 17.273l-1.194-.758M.953 14.652l1.408.13" })] }), 20), hA = Z(D("g", { stroke: "currentColor", fill: "none", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z" }), m("path", { d: "M6 21l15 -15l-3 -3l-15 15l3 3" }), m("path", { d: "M15 6l3 3" }), m("path", { d: "M9 3a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" }), m("path", { d: "M19 13a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" })] }), ye);
Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z" }), m("path", { d: "M6 21l15 -15l-3 -3l-15 15l3 3" }), m("path", { d: "M15 6l3 3" }), m("path", { d: "M9 3a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" }), m("path", { d: "M19 13a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" })] }), ye);
Z(D("g", { stroke: "currentColor", fill: "none", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M11.217 19.384a3.501 3.501 0 0 0 6.783 -1.217v-5.167l-6 -3.35" }), m("path", { d: "M5.214 15.014a3.501 3.501 0 0 0 4.446 5.266l4.34 -2.534v-6.946" }), m("path", { d: "M6 7.63c-1.391 -.236 -2.787 .395 -3.534 1.689a3.474 3.474 0 0 0 1.271 4.745l4.263 2.514l6 -3.348" }), m("path", { d: "M12.783 4.616a3.501 3.501 0 0 0 -6.783 1.217v5.067l6 3.45" }), m("path", { d: "M18.786 8.986a3.501 3.501 0 0 0 -4.446 -5.266l-4.34 2.534v6.946" }), m("path", { d: "M18 16.302c1.391 .236 2.787 -.395 3.534 -1.689a3.474 3.474 0 0 0 -1.271 -4.745l-4.308 -2.514l-5.955 3.42" })] }), ye);
var zZ = Z(D("g", { stroke: "currentColor", fill: "none", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2" }), m("path", { d: "M4 16v2a2 2 0 0 0 2 2h2" }), m("path", { d: "M16 4h2a2 2 0 0 1 2 2v2" }), m("path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2" })] }), ye), M8 = Z(D("g", { stroke: "currentColor", fill: "none", strokeWidth: 1.5, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" }), m("path", { d: "M21 12c-2.4 4 -5.4 6 -9 6c-3.6 0 -6.6 -2 -9 -6c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6" })] }), ye), BZ = Z(D("g", { stroke: "currentColor", fill: "none", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M10.585 10.587a2 2 0 0 0 2.829 2.828" }), m("path", { d: "M16.681 16.673a8.717 8.717 0 0 1 -4.681 1.327c-3.6 0 -6.6 -2 -9 -6c1.272 -2.12 2.712 -3.678 4.32 -4.674m2.86 -1.146a9.055 9.055 0 0 1 1.82 -.18c3.6 0 6.6 2 9 6c-.666 1.11 -1.379 2.067 -2.138 2.87" }), m("path", { d: "M3 3l18 18" })] }), ye);
Z(D("g", { stroke: "currentColor", fill: "none", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M15.5 13a3.5 3.5 0 0 0 -3.5 3.5v1a3.5 3.5 0 0 0 7 0v-1.8" }), m("path", { d: "M8.5 13a3.5 3.5 0 0 1 3.5 3.5v1a3.5 3.5 0 0 1 -7 0v-1.8" }), m("path", { d: "M17.5 16a3.5 3.5 0 0 0 0 -7h-.5" }), m("path", { d: "M19 9.3v-2.8a3.5 3.5 0 0 0 -7 0" }), m("path", { d: "M6.5 16a3.5 3.5 0 0 1 0 -7h.5" }), m("path", { d: "M5 9.3v-2.8a3.5 3.5 0 0 1 7 0v10" })] }), ye);
var HZ = Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M15.5 13a3.5 3.5 0 0 0 -3.5 3.5v1a3.5 3.5 0 0 0 7 0v-1.8" }), m("path", { d: "M8.5 13a3.5 3.5 0 0 1 3.5 3.5v1a3.5 3.5 0 0 1 -7 0v-1.8" }), m("path", { d: "M17.5 16a3.5 3.5 0 0 0 0 -7h-.5" }), m("path", { d: "M19 9.3v-2.8a3.5 3.5 0 0 0 -7 0" }), m("path", { d: "M6.5 16a3.5 3.5 0 0 1 0 -7h.5" }), m("path", { d: "M5 9.3v-2.8a3.5 3.5 0 0 1 7 0v10" })] }), ye), Kc = Z(D("g", { strokeWidth: 1.5, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" }), m("path", { d: "M21 21l-6 -6" })] }), ye), WZ = Z(D("g", { strokeWidth: 1.5, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M20.984 12.53a9 9 0 1 0 -7.552 8.355" }), m("path", { d: "M12 7v5l3 3" }), m("path", { d: "M19 16l-2 3h4l-2 3" })] }), ye), XZ = Z(D("g", { strokeWidth: 1.5, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M9 2m0 3a3 3 0 0 1 3 -3h0a3 3 0 0 1 3 3v5a3 3 0 0 1 -3 3h0a3 3 0 0 1 -3 -3z" }), m("path", { d: "M5 10a7 7 0 0 0 14 0" }), m("path", { d: "M8 21l8 0" }), m("path", { d: "M12 17l0 4" })] }), ye), VZ = Z(D("g", { strokeWidth: 1.5, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M3 3l18 18" }), m("path", { d: "M9 5a3 3 0 0 1 6 0v5a3 3 0 0 1 -.13 .874m-2 2a3 3 0 0 1 -3.87 -2.872v-1" }), m("path", { d: "M5 10a7 7 0 0 0 10.846 5.85m2 -2a6.967 6.967 0 0 0 1.152 -3.85" }), m("path", { d: "M8 21l8 0" }), m("path", { d: "M12 17l0 4" })] }), ye), fA = Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M13 3l0 7l6 0l-8 11l0 -7l-6 0l8 -11" })] }), ye), GZ = Z(D("g", { children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M8 8m0 1a1 1 0 0 1 1 -1h6a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-6a1 1 0 0 1 -1 -1z" }), m("path", { d: "M12 20v.01" }), m("path", { d: "M16 20v.01" }), m("path", { d: "M8 20v.01" }), m("path", { d: "M4 20v.01" }), m("path", { d: "M4 16v.01" }), m("path", { d: "M4 12v.01" }), m("path", { d: "M4 8v.01" }), m("path", { d: "M4 4v.01" }), m("path", { d: "M8 4v.01" }), m("path", { d: "M12 4v.01" }), m("path", { d: "M16 4v.01" }), m("path", { d: "M20 4v.01" }), m("path", { d: "M20 8v.01" }), m("path", { d: "M20 12v.01" }), m("path", { d: "M20 16v.01" }), m("path", { d: "M20 20v.01" })] }), ye), jZ = Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M5 3v18" }), m("path", { d: "M19 21v-18" }), m("path", { d: "M5 7h14" }), m("path", { d: "M5 15h14" }), m("path", { d: "M8 13v4" }), m("path", { d: "M11 13v4" }), m("path", { d: "M16 13v4" }), m("path", { d: "M14 5v4" }), m("path", { d: "M11 5v4" }), m("path", { d: "M8 5v4" }), m("path", { d: "M3 21h18" })] }), ye), KZ = Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M3 12l18 0" }), m("path", { d: "M7 16l10 0l-10 5l0 -5" }), m("path", { d: "M7 8l10 0l-10 -5l0 5" })] }), ye), YZ = Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M12 3l0 18" }), m("path", { d: "M16 7l0 10l5 0l-5 -10" }), m("path", { d: "M8 7l0 10l-5 0l5 -10" })] }), ye), pA = Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M5 3m0 2a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2z" }), m("path", { d: "M19 6h1a2 2 0 0 1 2 2a5 5 0 0 1 -5 5l-5 0v2" }), m("path", { d: "M10 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z" })] }), ye), T8 = Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M15 15m-5 0a5 5 0 1 0 10 0a5 5 0 1 0 -10 0" }), m("path", { d: "M22 22l-3 -3" }), m("path", { d: "M6 18h-1a2 2 0 0 1 -2 -2v-1" }), m("path", { d: "M3 11v-1" }), m("path", { d: "M3 6v-1a2 2 0 0 1 2 -2h1" }), m("path", { d: "M10 3h1" }), m("path", { d: "M15 3h1a2 2 0 0 1 2 2v1" })] }), ye), qZ = Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }), m("path", { d: "M5 12v-7a2 2 0 0 1 2 -2h7l5 5v4" }), m("path", { d: "M4 20.25c0 .414 .336 .75 .75 .75h1.25a1 1 0 0 0 1 -1v-1a1 1 0 0 0 -1 -1h-1a1 1 0 0 1 -1 -1v-1a1 1 0 0 1 1 -1h1.25a.75 .75 0 0 1 .75 .75" }), m("path", { d: "M10 15l2 6l2 -6" }), m("path", { d: "M20 15h-1a2 2 0 0 0 -2 2v2a2 2 0 0 0 2 2h1v-3" })] }), ye), ZZ = Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }), m("path", { d: "M5 12v-7a2 2 0 0 1 2 -2h7l5 5v4" }), m("path", { d: "M20 15h-1a2 2 0 0 0 -2 2v2a2 2 0 0 0 2 2h1v-3" }), m("path", { d: "M5 18h1.5a1.5 1.5 0 0 0 0 -3h-1.5v6" }), m("path", { d: "M11 21v-6l3 6v-6" })] }), ye), JZ = Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M4 13v-8a2 2 0 0 1 2 -2h1a2 2 0 0 1 2 2v8a2 2 0 0 0 6 0v-8a2 2 0 0 1 2 -2h1a2 2 0 0 1 2 2v8a8 8 0 0 1 -16 0" }), m("path", { d: "M4 8l5 0" }), m("path", { d: "M15 8l4 0" })] }), ye), QZ = Z(D("g", { strokeWidth: 1.25, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M3 14c.83 .642 2.077 1.017 3.5 1c1.423 .017 2.67 -.358 3.5 -1c.83 -.642 2.077 -1.017 3.5 -1c1.423 -.017 2.67 .358 3.5 1" }), m("path", { d: "M8 3a2.4 2.4 0 0 0 -1 2a2.4 2.4 0 0 0 1 2" }), m("path", { d: "M12 3a2.4 2.4 0 0 0 -1 2a2.4 2.4 0 0 0 1 2" }), m("path", { d: "M3 10h14v5a6 6 0 0 1 -6 6h-2a6 6 0 0 1 -6 -6v-5z" }), m("path", { d: "M16.746 16.726a3 3 0 1 0 .252 -5.555" })] }), ye), eJ = Z(D("g", { stroke: "currentColor", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M3 5a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1h-16a1 1 0 0 1-1-1v-10zM7 20h10M9 16v4M15 16v4" })] }), { ...ye, strokeWidth: 1.5 });
Z(D("g", { strokeWidth: 1.5, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M15 8v-2a2 2 0 0 0 -2 -2h-7a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h7a2 2 0 0 0 2 -2v-2" }), m("path", { d: "M21 12h-13l3 -3" }), m("path", { d: "M11 15l-3 -3" })] }), ye);
var tJ = Z(D("g", { children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M2 8a4 4 0 0 1 4 -4h12a4 4 0 0 1 4 4v8a4 4 0 0 1 -4 4h-12a4 4 0 0 1 -4 -4v-8z" }), m("path", { d: "M10 9l5 3l-5 3z" })] }), ye), nJ = Z(D("g", { strokeWidth: 1.5, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M3 6h18" }), m("path", { d: "M3 12h18" }), m("path", { d: "M3 18h18" }), m("path", { d: "M6 3v18" }), m("path", { d: "M12 3v18" }), m("path", { d: "M18 3v18" })] }), ye), rJ = Z(D("g", { strokeWidth: 1.5, children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M17 3m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z" }), m("path", { d: "M3 17m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z" }), m("path", { d: "M17 5c-6.627 0 -12 5.373 -12 12" })] }), ye), iJ = Z(D("g", { children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M6 18l12 -12" }), m("path", { d: "M18 10v-4h-4" })] }), ye), aJ = Z(D("g", { children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M4,19L10,19C11.097,19 12,18.097 12,17L12,9C12,7.903 12.903,7 14,7L21,7" }), m("path", { d: "M18 4l3 3l-3 3" })] }), ye), lJ = Z(D("g", { children: [m("path", { d: "M16,12L20,9L16,6" }), m("path", { d: "M6 20c0 -6.075 4.925 -11 11 -11h3" })] }), ye), mA = Z(D("g", { children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M6 9l6 6l6 -6" })] }), ye), sJ = Z(D("g", { children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M6 15l6 -6l6 6" })] }), ye), oJ = Z(D("g", { children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M6 15l6 -6l6 6" })] }), ye), bx = Z(D("g", { strokeWidth: "1.25", children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M8 5v10a1 1 0 0 0 1 1h10" }), m("path", { d: "M5 8h10a1 1 0 0 1 1 1v10" })] }), ye), gA = Z(D("g", { children: [m("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), m("path", { d: "M5 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }), m("path", { d: "M19 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }), m("path", { d: "M5 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }), m("path", { d: "M19 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }), m("path", { d: "M5 7l0 10" }), m("path", { d: "M7 5l10 0" }), m("path", { d: "M7 19l10 0" }), m("path", { d: "M19 7l0 10" })] }), ye), Mm = { [Un.Excalifont]: { metrics: { unitsPerEm: 1e3, ascender: 886, descender: -374, lineHeight: 1.25 }, icon: qh }, [Un.Nunito]: { metrics: { unitsPerEm: 1e3, ascender: 1011, descender: -353, lineHeight: 1.35 }, icon: Cm }, [Un["Lilita One"]]: { metrics: { unitsPerEm: 1e3, ascender: 923, descender: -220, lineHeight: 1.15 }, icon: kZ }, [Un["Comic Shanns"]]: { metrics: { unitsPerEm: 1e3, ascender: 750, descender: -250, lineHeight: 1.25 }, icon: d7 }, [Un.Virgil]: { metrics: { unitsPerEm: 1e3, ascender: 886, descender: -374, lineHeight: 1.25 }, icon: qh, deprecated: !0 }, [Un.Helvetica]: { metrics: { unitsPerEm: 2048, ascender: 1577, descender: -471, lineHeight: 1.15 }, icon: Cm, deprecated: !0, local: !0 }, [Un.Cascadia]: { metrics: { unitsPerEm: 2048, ascender: 1900, descender: -480, lineHeight: 1.2 }, icon: d7, deprecated: !0 }, [Un["Liberation Sans"]]: { metrics: { unitsPerEm: 2048, ascender: 1854, descender: -434, lineHeight: 1.15 }, serverSide: !0 }, [$d.Xiaolai]: { metrics: { unitsPerEm: 1e3, ascender: 880, descender: -144, lineHeight: 1.15 }, fallback: !0 }, [$d["Segoe UI Emoji"]]: { metrics: { unitsPerEm: 1e3, ascender: 886, descender: -374, lineHeight: 1.25 }, local: !0, fallback: !0 } }, ac = { LATIN: "U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD", LATIN_EXT: "U+0100-02AF, U+0304, U+0308, U+0329, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF", CYRILIC_EXT: "U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F", CYRILIC: "U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116", VIETNAMESE: "U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+0300-0301, U+0303-0304, U+0308-0309, U+0323, U+0329, U+1EA0-1EF9, U+20AB" }, I8 = "local:", cJ = class extends Error {
  constructor(e = "Couldn't export canvas.", t = "CANVAS_ERROR") {
    super(), this.name = t, this.message = e;
  }
}, r2 = class extends DOMException {
  constructor(e = "Request Aborted") {
    super(e, "AbortError");
  }
}, hc = class extends Error {
  constructor(e = "Image Scene Data Error", t = "IMAGE_SCENE_DATA_ERROR") {
    super(e), $(this, "code"), this.name = "EncodingError", this.code = t;
  }
}, dJ = class extends Error {
  constructor() {
    super(...arguments), $(this, "code", "ELEMENT_HAS_INVALID_INDEX");
  }
}, bA = class extends Error {
  constructor(e = "Worker URL is not defined!", t = "WORKER_URL_NOT_DEFINED") {
    super(e), $(this, "code"), this.name = "WorkerUrlNotDefinedError", this.code = t;
  }
}, UA = class extends Error {
  constructor(e = "Worker has to be in a separate chunk!", t = "WORKER_IN_THE_MAIN_CHUNK") {
    super(e), $(this, "code"), this.name = "WorkerInTheMainChunkError", this.code = t;
  }
}, Ux = class extends Error {
  constructor(e) {
    super(e), this.name = "ExcalidrawError";
  }
}, uJ = class {
  constructor(e) {
    $(this, "instance"), $(this, "debounceTerminate"), this.instance = new Worker(e, { type: "module" });
  }
}, hJ = class vA {
  constructor(t, n) {
    $(this, "idleWorkers", /* @__PURE__ */ new Set()), $(this, "workerUrl"), $(this, "workerTTL"), this.workerUrl = t, this.workerTTL = n.ttl || 1e3;
  }
  static create(t, n = {}) {
    if (!t) throw new bA();
    if (!import.meta.url || t.toString() === import.meta.url) throw new UA();
    return new vA(t, n);
  }
  async postMessage(t, n) {
    let r, i = Array.from(this.idleWorkers).shift();
    return i ? (this.idleWorkers.delete(i), r = i) : r = await this.createWorker(), new Promise((a, l) => {
      r.instance.onmessage = this.onMessageHandler(r, a), r.instance.onerror = this.onErrorHandler(r, l), r.instance.postMessage(t, n), r.debounceTerminate(() => l(new Error(`Active worker did not respond for ${this.workerTTL}ms!`)));
    });
  }
  async clear() {
    for (let t of this.idleWorkers) t.debounceTerminate.cancel(), t.instance.terminate();
    this.idleWorkers.clear();
  }
  async createWorker() {
    let t = new uJ(this.workerUrl);
    return t.debounceTerminate = b0((n) => {
      t.instance.terminate(), this.idleWorkers.has(t) ? (this.idleWorkers.delete(t), console.debug("Job finished! Idle worker has been released from the pool.")) : n ? n() : console.error("Worker has been terminated!");
    }, this.workerTTL), t;
  }
  onMessageHandler(t, n) {
    return (r) => {
      t.debounceTerminate(), this.idleWorkers.add(t), n(r.data);
    };
  }
  onErrorHandler(t, n) {
    return (r) => {
      t.debounceTerminate(() => n(r)), t.debounceTerminate.flush(), this.clear();
    };
  }
}, vx = typeof Worker < "u", fJ = async (e, t) => {
  let { Commands: n, subsetToBase64: r, toBase64: i } = await mJ();
  return vx ? U0(async () => {
    try {
      let a = await gJ(), l = e.slice(0), s = await a.postMessage({ command: n.Subset, arrayBuffer: l, codePoints: t }, { transfer: [l] });
      return i(s);
    } catch (a) {
      return vx = !1, ZY() && (a instanceof bA || a instanceof UA) || console.error("Failed to use workers for subsetting, falling back to the main thread.", a), r(e, t);
    }
  }) : r(e, t);
}, G6 = null, j6 = null, pJ = async () => (G6 || (G6 = import("./subset-worker.chunk-Dl1o7vwa.js")), G6), mJ = async () => (j6 || (j6 = import("./subset-shared.chunk-CcXgJhXT.js")), j6), K6 = null, gJ = () => (K6 || (K6 = U0(async () => {
  let { WorkerUrl: e } = await pJ();
  return hJ.create(e);
})), K6), yA = class gp {
  constructor(t, n, r) {
    $(this, "urls"), $(this, "fontFace"), this.urls = gp.createUrls(n);
    let i = this.urls.map((a) => `url(${a}) ${gp.getFormat(a)}`).join(", ");
    this.fontFace = new FontFace(t, i, { display: "swap", style: "normal", weight: "400", ...r });
  }
  toCSS(t) {
    if (!this.getUnicodeRangeRegex().test(t)) return;
    let n = Array.from(t).map((r) => r.codePointAt(0));
    return this.getContent(n).then((r) => `@font-face { font-family: ${this.fontFace.family}; src: url(${r}); }`);
  }
  async getContent(t) {
    let n = 0, r = [];
    for (; n < this.urls.length; ) {
      let i = this.urls[n];
      try {
        let a = await this.fetchFont(i);
        return await fJ(a, t);
      } catch (a) {
        r.push(`"${i.toString()}" returned error "${a}"`);
      }
      n++;
    }
    return console.error(`Failed to fetch font family "${this.fontFace.family}"`, JSON.stringify(r, void 0, 2)), this.urls.length ? this.urls[this.urls.length - 1].toString() : "";
  }
  fetchFont(t) {
    return U0(async () => {
      let n = await fetch(t, { cache: "force-cache", headers: { Accept: "font/woff2" } });
      if (!n.ok) {
        let r = t instanceof URL ? t.toString() : "dataurl";
        throw new Error(`Failed to fetch "${r}": ${n.statusText}`);
      }
      return await n.arrayBuffer();
    });
  }
  getUnicodeRangeRegex() {
    let t = this.fontFace.unicodeRange.split(/,\s*/).map((n) => {
      let [r, i] = n.replace("U+", "").split("-");
      return i ? `\\u{${r}}-\\u{${i}}` : `\\u{${r}}`;
    }).join("");
    return new RegExp(`[${t}]`, "u");
  }
  static createUrls(t) {
    if (t.startsWith("data")) return [t];
    if (t.startsWith(I8)) return [];
    if (t.startsWith("http")) return [new URL(t)];
    let n = t.replace(/^\/+/, ""), r = [];
    if (typeof window.EXCALIDRAW_ASSET_PATH == "string") {
      let i = this.normalizeBaseUrl(window.EXCALIDRAW_ASSET_PATH);
      r.push(new URL(n, i));
    } else Array.isArray(window.EXCALIDRAW_ASSET_PATH) && window.EXCALIDRAW_ASSET_PATH.forEach((i) => {
      let a = this.normalizeBaseUrl(i);
      r.push(new URL(n, a));
    });
    return r.push(new URL(n, gp.ASSETS_FALLBACK_URL)), r;
  }
  static getFormat(t) {
    if (!(t instanceof URL)) return "";
    try {
      let n = new URL(t).pathname.split(".");
      return n.length === 1 ? "" : `format('${n.pop()}')`;
    } catch {
      return "";
    }
  }
  static normalizeBaseUrl(t) {
    var r;
    let n = t;
    return /^\.?\//.test(n) && (n = new URL(n.replace(/^\.?\/+/, ""), (r = window == null ? void 0 : window.location) == null ? void 0 : r.origin).toString()), n = `${n.replace(/\/+$/, "")}/`, n;
  }
};
$(yA, "ASSETS_FALLBACK_URL", `https://esm.sh/${`${st.PKG_NAME}@${st.PKG_VERSION}`}/dist/prod/`);
var bJ = yA, UJ = "./fonts/Cascadia/CascadiaCode-Regular.woff2", vJ = [{ uri: UJ }], yJ = "./fonts/ComicShanns/ComicShanns-Regular-279a7b317d12eb88de06167bd672b4b4.woff2", wJ = "./fonts/ComicShanns/ComicShanns-Regular-fcb0fc02dcbee4c9846b3e2508668039.woff2", xJ = "./fonts/ComicShanns/ComicShanns-Regular-dc6a8806fa96795d7b3be5026f989a17.woff2", EJ = "./fonts/ComicShanns/ComicShanns-Regular-6e066e8de2ac57ea9283adb9c24d7f0c.woff2", SJ = [{ uri: yJ, descriptors: { unicodeRange: "U+20-7e,U+a1-a6,U+a8,U+ab-ac,U+af-b1,U+b4,U+b8,U+bb-bc,U+bf-cf,U+d1-d7,U+d9-de,U+e0-ef,U+f1-f7,U+f9-ff,U+131,U+152-153,U+2c6,U+2da,U+2dc,U+2013-2014,U+2018-201a,U+201c-201d,U+2020-2022,U+2026,U+2039-203a,U+2044,U+20ac,U+2191,U+2193,U+2212" } }, { uri: wJ, descriptors: { unicodeRange: "U+100-10f,U+112-125,U+128-130,U+134-137,U+139-13c,U+141-148,U+14c-151,U+154-161,U+164-165,U+168-17f,U+1bf,U+1f7,U+218-21b,U+237,U+1e80-1e85,U+1ef2-1ef3,U+a75b" } }, { uri: xJ, descriptors: { unicodeRange: "U+2c7,U+2d8-2d9,U+2db,U+2dd,U+315,U+2190,U+2192,U+2200,U+2203-2204,U+2264-2265,U+f6c3" } }, { uri: EJ, descriptors: { unicodeRange: "U+3bb" } }], _J = [{ uri: I8 }], kJ = "./fonts/Excalifont/Excalifont-Regular-a88b72a24fb54c9f94e3b5fdaa7481c9.woff2", CJ = "./fonts/Excalifont/Excalifont-Regular-be310b9bcd4f1a43f571c46df7809174.woff2", MJ = "./fonts/Excalifont/Excalifont-Regular-b9dcf9d2e50a1eaf42fc664b50a3fd0d.woff2", TJ = "./fonts/Excalifont/Excalifont-Regular-41b173a47b57366892116a575a43e2b6.woff2", IJ = "./fonts/Excalifont/Excalifont-Regular-3f2c5db56cc93c5a6873b1361d730c16.woff2", AJ = "./fonts/Excalifont/Excalifont-Regular-349fac6ca4700ffec595a7150a0d1e1d.woff2", NJ = "./fonts/Excalifont/Excalifont-Regular-623ccf21b21ef6b3a0d87738f77eb071.woff2", DJ = [{ uri: kJ, descriptors: { unicodeRange: "U+20-7e,U+a0-a3,U+a5-a6,U+a8-ab,U+ad-b1,U+b4,U+b6-b8,U+ba-ff,U+131,U+152-153,U+2bc,U+2c6,U+2da,U+2dc,U+304,U+308,U+2013-2014,U+2018-201a,U+201c-201e,U+2020,U+2022,U+2024-2026,U+2030,U+2039-203a,U+20ac,U+2122,U+2212" } }, { uri: CJ, descriptors: { unicodeRange: "U+100-130,U+132-137,U+139-149,U+14c-151,U+154-17e,U+192,U+1fc-1ff,U+218-21b,U+237,U+1e80-1e85,U+1ef2-1ef3,U+2113" } }, { uri: MJ, descriptors: { unicodeRange: "U+400-45f,U+490-491,U+2116" } }, { uri: TJ, descriptors: { unicodeRange: "U+37e,U+384-38a,U+38c,U+38e-393,U+395-3a1,U+3a3-3a8,U+3aa-3cf,U+3d7" } }, { uri: IJ, descriptors: { unicodeRange: "U+2c7,U+2d8-2d9,U+2db,U+2dd,U+302,U+306-307,U+30a-30c,U+326-328,U+212e,U+2211,U+fb01-fb02" } }, { uri: AJ, descriptors: { unicodeRange: "U+462-463,U+472-475,U+4d8-4d9,U+4e2-4e3,U+4e6-4e9,U+4ee-4ef" } }, { uri: NJ, descriptors: { unicodeRange: "U+300-301,U+303" } }], LJ = [{ uri: I8 }], RJ = "./fonts/Liberation/LiberationSans-Regular.woff2", PJ = [{ uri: RJ }], OJ = "./fonts/Lilita/Lilita-Regular-i7dPIFZ9Zz-WBtRtedDbYEF8RXi4EwQ.woff2", $J = "./fonts/Lilita/Lilita-Regular-i7dPIFZ9Zz-WBtRtedDbYE98RXi4EwSsbg.woff2", FJ = [{ uri: $J, descriptors: { unicodeRange: ac.LATIN_EXT } }, { uri: OJ, descriptors: { unicodeRange: ac.LATIN } }], zJ = "./fonts/Nunito/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTQ3j6zbXWjgeg.woff2", BJ = "./fonts/Nunito/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTo3j6zbXWjgevT5.woff2", HJ = "./fonts/Nunito/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTA3j6zbXWjgevT5.woff2", WJ = "./fonts/Nunito/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTk3j6zbXWjgevT5.woff2", XJ = "./fonts/Nunito/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTs3j6zbXWjgevT5.woff2", VJ = [{ uri: WJ, descriptors: { unicodeRange: ac.CYRILIC_EXT, weight: "500" } }, { uri: HJ, descriptors: { unicodeRange: ac.CYRILIC, weight: "500" } }, { uri: XJ, descriptors: { unicodeRange: ac.VIETNAMESE, weight: "500" } }, { uri: BJ, descriptors: { unicodeRange: ac.LATIN_EXT, weight: "500" } }, { uri: zJ, descriptors: { unicodeRange: ac.LATIN, weight: "500" } }], GJ = "./fonts/Virgil/Virgil-Regular.woff2", jJ = [{ uri: GJ }], KJ = "./fonts/Xiaolai/Xiaolai-Regular-09850c4077f3fffe707905872e0e2460.woff2", YJ = "./fonts/Xiaolai/Xiaolai-Regular-7eb9fffd1aa890d07d0f88cc82e6cfe4.woff2", qJ = "./fonts/Xiaolai/Xiaolai-Regular-60a3089806700d379f11827ee9843b6b.woff2", ZJ = "./fonts/Xiaolai/Xiaolai-Regular-6fe5c5973cc06f74b2387a631ea36b88.woff2", JJ = "./fonts/Xiaolai/Xiaolai-Regular-b96d9226ce77ec94ceca043d712182e6.woff2", QJ = "./fonts/Xiaolai/Xiaolai-Regular-6ae5b42180ad70b971c91e7eefb8eba2.woff2", eQ = "./fonts/Xiaolai/Xiaolai-Regular-a4c34be6d42152e64b0df90bc4607f64.woff2", tQ = "./fonts/Xiaolai/Xiaolai-Regular-c69f61a4ab18d0488c8d1fc12e7028e8.woff2", nQ = "./fonts/Xiaolai/Xiaolai-Regular-e3fcf5180fd466c8915c4e8069491054.woff2", rQ = "./fonts/Xiaolai/Xiaolai-Regular-c1f94158256bb1f3bf665b053d895af9.woff2", iQ = "./fonts/Xiaolai/Xiaolai-Regular-544fc28abe2c5c30e62383fd4dac255f.woff2", aQ = "./fonts/Xiaolai/Xiaolai-Regular-7197d6fda6cba7c3874c53d6381ca239.woff2", lQ = "./fonts/Xiaolai/Xiaolai-Regular-70c2eb8d64e71a42a834eb857ea9df51.woff2", sQ = "./fonts/Xiaolai/Xiaolai-Regular-069e77aac84590e2e991d0a0176d34f2.woff2", oQ = "./fonts/Xiaolai/Xiaolai-Regular-41521fade99856108931b4768b1b2648.woff2", cQ = "./fonts/Xiaolai/Xiaolai-Regular-a004ddfcb26e67bd6e678c8ed19e25ce.woff2", dQ = "./fonts/Xiaolai/Xiaolai-Regular-04b718e5623574919c8b0dea5f301444.woff2", uQ = "./fonts/Xiaolai/Xiaolai-Regular-7e4bde7e9c7f84cd34d8a845e384c746.woff2", hQ = "./fonts/Xiaolai/Xiaolai-Regular-23686f7f29da6e8008c36dd3a80c83d6.woff2", fQ = "./fonts/Xiaolai/Xiaolai-Regular-69c09cc5fa3e55c74fc4821f76909cc3.woff2", pQ = "./fonts/Xiaolai/Xiaolai-Regular-25b7f38e18f035f96cb5e547bd2bd08c.woff2", mQ = "./fonts/Xiaolai/Xiaolai-Regular-ba3de316d63c7e339987b16f41a0b879.woff2", gQ = "./fonts/Xiaolai/Xiaolai-Regular-12b52b58eb3df36804b9a654ec9ee194.woff2", bQ = "./fonts/Xiaolai/Xiaolai-Regular-b1220a3c61f85cc0408deedb4c5f57a2.woff2", UQ = "./fonts/Xiaolai/Xiaolai-Regular-4535823663ad81405188a528d8f2b1a2.woff2", vQ = "./fonts/Xiaolai/Xiaolai-Regular-3eaa538115d76932653c21d8dc28f207.woff2", yQ = "./fonts/Xiaolai/Xiaolai-Regular-7e929f262f30c8ee78bf398150b1a7cd.woff2", wQ = "./fonts/Xiaolai/Xiaolai-Regular-73e309718fd16cea44b4d54a33581811.woff2", xQ = "./fonts/Xiaolai/Xiaolai-Regular-9eb5a99df4e76ac3363453ac9ca288b1.woff2", EQ = "./fonts/Xiaolai/Xiaolai-Regular-3e63ed8162808a9e425ed80a8bc79114.woff2", SQ = "./fonts/Xiaolai/Xiaolai-Regular-cb17fc3db95f6d139afc9d31a8e93293.woff2", _Q = "./fonts/Xiaolai/Xiaolai-Regular-c8b71798409ccc126ee264a00aadcf21.woff2", kQ = "./fonts/Xiaolai/Xiaolai-Regular-11c345711937f0ba4b8f7b6b919c8440.woff2", CQ = "./fonts/Xiaolai/Xiaolai-Regular-e480d9c614742d05f0e78f274f1e69e6.woff2", MQ = "./fonts/Xiaolai/Xiaolai-Regular-95429962233afd82db1c27df1500a28c.woff2", TQ = "./fonts/Xiaolai/Xiaolai-Regular-2cf96d082d35ea3d8106851223ad0d16.woff2", IQ = "./fonts/Xiaolai/Xiaolai-Regular-2d43040e86ff03ba677f6f9c04cd0805.woff2", AQ = "./fonts/Xiaolai/Xiaolai-Regular-2a26d20a23b00898ce82f09d2ee47c3f.woff2", NQ = "./fonts/Xiaolai/Xiaolai-Regular-a365e82ed54697a52f27adcea1315fe8.woff2", DQ = "./fonts/Xiaolai/Xiaolai-Regular-f5d079153c99a25b9be5b8583c4cc8a7.woff2", LQ = "./fonts/Xiaolai/Xiaolai-Regular-10a7ae9a371830a80c3d844acf1c02d7.woff2", RQ = "./fonts/Xiaolai/Xiaolai-Regular-e4bca6cfa53e499cae0a6be4894a90e9.woff2", PQ = "./fonts/Xiaolai/Xiaolai-Regular-60a41c7e1c68f22424e6d22df544bc82.woff2", OQ = "./fonts/Xiaolai/Xiaolai-Regular-7ab2bed91166a9dca83a5ebfbe2a7f38.woff2", $Q = "./fonts/Xiaolai/Xiaolai-Regular-670ba603758d94268e8606f240a42e12.woff2", FQ = "./fonts/Xiaolai/Xiaolai-Regular-e656f091b9dc4709722c9f4b84d3c797.woff2", zQ = "./fonts/Xiaolai/Xiaolai-Regular-15dc6d811c9cd078f9086a740d5a1038.woff2", BQ = "./fonts/Xiaolai/Xiaolai-Regular-f0f13b5c60e0af5553bd359f5513be1b.woff2", HQ = "./fonts/Xiaolai/Xiaolai-Regular-8c2f33cee3993174f7e87c28e4bf42ee.woff2", WQ = "./fonts/Xiaolai/Xiaolai-Regular-761d05e3cd968cf574166867998ef06a.woff2", XQ = "./fonts/Xiaolai/Xiaolai-Regular-642b26e2e5f5fb780b51b593dbc8c851.woff2", VQ = "./fonts/Xiaolai/Xiaolai-Regular-5572b3513ba8df57a3d5d7303ee6b11b.woff2", GQ = "./fonts/Xiaolai/Xiaolai-Regular-3c9de2ae0ea4bc91a510942dfa4be8d2.woff2", jQ = "./fonts/Xiaolai/Xiaolai-Regular-671a2c20b1eb9e4ef8a192833940e319.woff2", KQ = "./fonts/Xiaolai/Xiaolai-Regular-4dc6d5f188d5c96d44815cd1e81aa885.woff2", YQ = "./fonts/Xiaolai/Xiaolai-Regular-ce4884f96f11589608b76b726a755803.woff2", qQ = "./fonts/Xiaolai/Xiaolai-Regular-8f476c4c99813d57cbe6eca4727388ad.woff2", ZQ = "./fonts/Xiaolai/Xiaolai-Regular-5935a5775af3d5c6307ac667bd9ae74e.woff2", JQ = "./fonts/Xiaolai/Xiaolai-Regular-79f007c1c6d07557120982951ea67998.woff2", QQ = "./fonts/Xiaolai/Xiaolai-Regular-bafff7a14c27403dcc6cf1432e8ea836.woff2", eee = "./fonts/Xiaolai/Xiaolai-Regular-543fa46ace099a7099dad69123399400.woff2", tee = "./fonts/Xiaolai/Xiaolai-Regular-4ddc14ed3eb0c3e46364317dfc0144a3.woff2", nee = "./fonts/Xiaolai/Xiaolai-Regular-0fa55a080fcd0f9dc2e0b0058b793df8.woff2", ree = "./fonts/Xiaolai/Xiaolai-Regular-66493ba5a8367f2928812f446f47b56a.woff2", iee = "./fonts/Xiaolai/Xiaolai-Regular-57862b464a55b18c7bf234ce22907d73.woff2", aee = "./fonts/Xiaolai/Xiaolai-Regular-8d3bcabb847b56243b16afe62adaaf21.woff2", lee = "./fonts/Xiaolai/Xiaolai-Regular-2b77e8ebfb2367ab2662396a60e7d320.woff2", see = "./fonts/Xiaolai/Xiaolai-Regular-0b5d723fdc4e249c140f0909e87d03b4.woff2", oee = "./fonts/Xiaolai/Xiaolai-Regular-cdbce89e82cc1ab53a2decbf5819278f.woff2", cee = "./fonts/Xiaolai/Xiaolai-Regular-739bc1a567439c7cffcd1614644593d2.woff2", dee = "./fonts/Xiaolai/Xiaolai-Regular-72252d73220fa3cd856677888cee1635.woff2", uee = "./fonts/Xiaolai/Xiaolai-Regular-08e0dc436ad0ad61ba5558db0674d762.woff2", hee = "./fonts/Xiaolai/Xiaolai-Regular-cf6ff4e0f491ca0cf3038187a997b9b4.woff2", fee = "./fonts/Xiaolai/Xiaolai-Regular-9cfb2a77a4e45025105ad29a1748b90d.woff2", pee = "./fonts/Xiaolai/Xiaolai-Regular-450da755d5bcb70906e1295e559b9602.woff2", mee = "./fonts/Xiaolai/Xiaolai-Regular-0986d134c05864f5025962eef9f994a0.woff2", gee = "./fonts/Xiaolai/Xiaolai-Regular-1ee544f0f1dac422545c505baa788992.woff2", bee = "./fonts/Xiaolai/Xiaolai-Regular-4806e761d750087c2d734fc64596eaff.woff2", Uee = "./fonts/Xiaolai/Xiaolai-Regular-33432927cd87d40cfe393c7482bf221f.woff2", vee = "./fonts/Xiaolai/Xiaolai-Regular-be549ab72f0719d606a5c01e2c0219b6.woff2", yee = "./fonts/Xiaolai/Xiaolai-Regular-019d66dcad46dc156b162d267f981c20.woff2", wee = "./fonts/Xiaolai/Xiaolai-Regular-b5c1596551c256e0e9cf02028595b092.woff2", xee = "./fonts/Xiaolai/Xiaolai-Regular-e5f453bb04da18eed01675eeebd88bf8.woff2", Eee = "./fonts/Xiaolai/Xiaolai-Regular-cf2cc71752631e579e35b0e423bf2638.woff2", See = "./fonts/Xiaolai/Xiaolai-Regular-6f3256af8454371776bc46670d33cc65.woff2", _ee = "./fonts/Xiaolai/Xiaolai-Regular-23f228f3999c01983860012330e4be08.woff2", kee = "./fonts/Xiaolai/Xiaolai-Regular-21430ee05a1248901da8d0de08744d47.woff2", Cee = "./fonts/Xiaolai/Xiaolai-Regular-5330a2119a716e4e7224ed108b085dac.woff2", Mee = "./fonts/Xiaolai/Xiaolai-Regular-cd145ce4a0ea18469358df53c207bc1b.woff2", Tee = "./fonts/Xiaolai/Xiaolai-Regular-36925dfe329a45086cbb7fc5c20d45ac.woff2", Iee = "./fonts/Xiaolai/Xiaolai-Regular-4bfaa8ffa64c5ee560aa2daba7c9cbd3.woff2", Aee = "./fonts/Xiaolai/Xiaolai-Regular-112c051027b2d766c19a519f6ee1f4f7.woff2", Nee = "./fonts/Xiaolai/Xiaolai-Regular-5b0ed6971aaab9c8ad563230bd5471a7.woff2", Dee = "./fonts/Xiaolai/Xiaolai-Regular-98f2ad84457de7f3740d9920b8fa8667.woff2", Lee = "./fonts/Xiaolai/Xiaolai-Regular-733171b4ffcd17ea1fe1c0ba627173bf.woff2", Ree = "./fonts/Xiaolai/Xiaolai-Regular-684d65f1793cac449dde5d59cb3c47fb.woff2", Pee = "./fonts/Xiaolai/Xiaolai-Regular-cbaaefaaf326668277aa24dfa93c4d28.woff2", Oee = "./fonts/Xiaolai/Xiaolai-Regular-58fd02350d0bc52cf1ca3bb32ce9766e.woff2", $ee = "./fonts/Xiaolai/Xiaolai-Regular-7ccce86603f80a099ddb0cb21d4ae3e3.woff2", Fee = "./fonts/Xiaolai/Xiaolai-Regular-3717077e38f98d89eae729b6c14e56dc.woff2", zee = "./fonts/Xiaolai/Xiaolai-Regular-dbea1af6dcd9860be40c3d18254338f5.woff2", Bee = "./fonts/Xiaolai/Xiaolai-Regular-4a0fdb40036e87b40aa08dd30584cb85.woff2", Hee = "./fonts/Xiaolai/Xiaolai-Regular-0f626226ba1272e832aea87bafd9720e.woff2", Wee = "./fonts/Xiaolai/Xiaolai-Regular-938d90c10ff8c20386af7f242c05d6b0.woff2", Xee = "./fonts/Xiaolai/Xiaolai-Regular-b6d128682ee29e471486354d486a1b90.woff2", Vee = "./fonts/Xiaolai/Xiaolai-Regular-e51ef413167c6e14e0c0fdcc585f2fc9.woff2", Gee = "./fonts/Xiaolai/Xiaolai-Regular-9d81066dd2b337c938df6e90380a00dc.woff2", jee = "./fonts/Xiaolai/Xiaolai-Regular-20e7bf72fa05de9adf7dbcc7bf51dde6.woff2", Kee = "./fonts/Xiaolai/Xiaolai-Regular-4095eb84ef3874e2600247bee0b04026.woff2", Yee = "./fonts/Xiaolai/Xiaolai-Regular-4ee10ae43505e2e0bc62656ced49c0fa.woff2", qee = "./fonts/Xiaolai/Xiaolai-Regular-7494dc504ae00ee9cd0505f990f88c5d.woff2", Zee = "./fonts/Xiaolai/Xiaolai-Regular-8de5b863cb50dfefdd07cb11c774d579.woff2", Jee = "./fonts/Xiaolai/Xiaolai-Regular-3e1f8f654357353bf0e04ba5c34b5f7f.woff2", Qee = "./fonts/Xiaolai/Xiaolai-Regular-2e33e8dc771ef5e1d9127d60a6b73679.woff2", ete = "./fonts/Xiaolai/Xiaolai-Regular-173945821411c09f70c95f98d590e697.woff2", tte = "./fonts/Xiaolai/Xiaolai-Regular-b358f7a51ece39a3247942b1feabdb29.woff2", nte = "./fonts/Xiaolai/Xiaolai-Regular-23ad2d71b280f00b1363b95b7bea94eb.woff2", rte = "./fonts/Xiaolai/Xiaolai-Regular-5882ffa04f32584d26109137e2da4352.woff2", ite = "./fonts/Xiaolai/Xiaolai-Regular-a203b91dad570bf05a58c3c3ddb529bf.woff2", ate = "./fonts/Xiaolai/Xiaolai-Regular-bd77e3c7f9e0b072d96af37f73d1aa32.woff2", lte = "./fonts/Xiaolai/Xiaolai-Regular-5a45d991244d4c7140217e1e5f5ca4f4.woff2", ste = "./fonts/Xiaolai/Xiaolai-Regular-f56414bf9bced67990def8660e306759.woff2", ote = "./fonts/Xiaolai/Xiaolai-Regular-583d166e56ba0de4b77eabb47ef67839.woff2", cte = "./fonts/Xiaolai/Xiaolai-Regular-7f855356ab893b0d2b9c1c83b8116f0e.woff2", dte = "./fonts/Xiaolai/Xiaolai-Regular-b57aaedfd8ebdf3931f25119dc6a5eb2.woff2", ute = "./fonts/Xiaolai/Xiaolai-Regular-b6fd38ca30869792244804b04bc058da.woff2", hte = "./fonts/Xiaolai/Xiaolai-Regular-452225341522a7942f0f6aab1a5c91a3.woff2", fte = "./fonts/Xiaolai/Xiaolai-Regular-866fa7613df6b3fd272bcfd4530c0bb9.woff2", pte = "./fonts/Xiaolai/Xiaolai-Regular-52a84a22fd1369bffeaf21da2d6158dc.woff2", mte = "./fonts/Xiaolai/Xiaolai-Regular-829615148e6357d826b9242eb7fbbd1e.woff2", gte = "./fonts/Xiaolai/Xiaolai-Regular-c99eda15fc26a2941579560f76c3a5cf.woff2", bte = "./fonts/Xiaolai/Xiaolai-Regular-395c35dd584b56b0789f58a0559beaf1.woff2", Ute = "./fonts/Xiaolai/Xiaolai-Regular-203b0e569e3b14aac86a003dc3fa523e.woff2", vte = "./fonts/Xiaolai/Xiaolai-Regular-51a0e808bbc8361236ac521a119758a3.woff2", yte = "./fonts/Xiaolai/Xiaolai-Regular-6e092f71c1e634059ada0e52abadce67.woff2", wte = "./fonts/Xiaolai/Xiaolai-Regular-0f7fb1e0d5015bb1371343153ecf7ce3.woff2", xte = "./fonts/Xiaolai/Xiaolai-Regular-d0cf73942fea1c74edbdf0b3011f4656.woff2", Ete = "./fonts/Xiaolai/Xiaolai-Regular-968cffdc8ee679da094e77ebf50f58ef.woff2", Ste = "./fonts/Xiaolai/Xiaolai-Regular-7a07ddc0f0c0f5f4a9bad6ee3dda66b5.woff2", _te = "./fonts/Xiaolai/Xiaolai-Regular-ec181b795ac1fb5a50d700b6e996d745.woff2", kte = "./fonts/Xiaolai/Xiaolai-Regular-cfb211578629b7e8153b37240de6a9d5.woff2", Cte = "./fonts/Xiaolai/Xiaolai-Regular-59e9ff77b0efaf684bc09274fb6908c9.woff2", Mte = "./fonts/Xiaolai/Xiaolai-Regular-2adbc89c11e65905393d3dfc468b9d5b.woff2", Tte = "./fonts/Xiaolai/Xiaolai-Regular-70e811fd7994e61f408c923de6ddd078.woff2", Ite = "./fonts/Xiaolai/Xiaolai-Regular-c4a687ac4f0c2766eefc9f77ed99cddf.woff2", Ate = "./fonts/Xiaolai/Xiaolai-Regular-51502f1206be09c565f1547c406e9558.woff2", Nte = "./fonts/Xiaolai/Xiaolai-Regular-1fdc0c67ed57263a80fd108c1f6ccf24.woff2", Dte = "./fonts/Xiaolai/Xiaolai-Regular-e11567fd2accf9957cd0d3c2be937d87.woff2", Lte = "./fonts/Xiaolai/Xiaolai-Regular-20cc1bbf50e7efb442756cb605672c1f.woff2", Rte = "./fonts/Xiaolai/Xiaolai-Regular-5d2898fbc097a7e24c6f38d80587621e.woff2", Pte = "./fonts/Xiaolai/Xiaolai-Regular-ac9ceb44437becc3e9c4dbfebab7fc2d.woff2", Ote = "./fonts/Xiaolai/Xiaolai-Regular-c16ed9740b85badf16e86ea782a3062f.woff2", $te = "./fonts/Xiaolai/Xiaolai-Regular-aa0d470430e6391eca720c7cfa44446f.woff2", Fte = "./fonts/Xiaolai/Xiaolai-Regular-f2b54d4e7be0eaefe1c2c56836fa5368.woff2", zte = "./fonts/Xiaolai/Xiaolai-Regular-99a16ef6a64934d5781933dbd9c46b2e.woff2", Bte = "./fonts/Xiaolai/Xiaolai-Regular-c40533fdf4cc57177b12803598af7e59.woff2", Hte = "./fonts/Xiaolai/Xiaolai-Regular-91ddb2969bf2d31ba02ad82998d1314c.woff2", Wte = "./fonts/Xiaolai/Xiaolai-Regular-774d4f764a1299da5d28ec2f2ffe0d69.woff2", Xte = "./fonts/Xiaolai/Xiaolai-Regular-7718fe60986d8b42b1be9c5ace5ccf25.woff2", Vte = "./fonts/Xiaolai/Xiaolai-Regular-aa5c9ca6cf4fba00433b7aa3fa10671a.woff2", Gte = "./fonts/Xiaolai/Xiaolai-Regular-4f50e5136e136527280bc902c5817561.woff2", jte = "./fonts/Xiaolai/Xiaolai-Regular-093b9ef39a46ceae95a1df18a0a3a326.woff2", Kte = "./fonts/Xiaolai/Xiaolai-Regular-a0ca5df4258213d7fc9fce80f65ce760.woff2", Yte = "./fonts/Xiaolai/Xiaolai-Regular-d2666cbed13462c5dc36fa2f15c202ca.woff2", qte = "./fonts/Xiaolai/Xiaolai-Regular-1e6fd68f1f3902ce48ce8c69df385622.woff2", Zte = "./fonts/Xiaolai/Xiaolai-Regular-87599f94b6cc129d505b375798d0d751.woff2", Jte = "./fonts/Xiaolai/Xiaolai-Regular-06c77b8c66e51ed6c63ccb502dd8b8af.woff2", Qte = "./fonts/Xiaolai/Xiaolai-Regular-13ae07ed2e272d26d59bc0691cd7117a.woff2", ene = "./fonts/Xiaolai/Xiaolai-Regular-353f33792a8f60dc69323ddf635a269e.woff2", tne = "./fonts/Xiaolai/Xiaolai-Regular-0facdf1ea213ba40261022f5d5ed4493.woff2", nne = "./fonts/Xiaolai/Xiaolai-Regular-f8ee5d36068a42b51d0e4a1116cfcec1.woff2", rne = "./fonts/Xiaolai/Xiaolai-Regular-79d494361ae093b69e74ee9dbe65bfd4.woff2", ine = "./fonts/Xiaolai/Xiaolai-Regular-74e2263a91439c25b91d5132ce9f4d62.woff2", ane = "./fonts/Xiaolai/Xiaolai-Regular-ee8bae97908d5147b423f77ad0d3c1bb.woff2", lne = "./fonts/Xiaolai/Xiaolai-Regular-56467a5c8840c4d23a60b2f935114848.woff2", sne = "./fonts/Xiaolai/Xiaolai-Regular-145aa02cdd91946e67dc934e1acffe75.woff2", one = "./fonts/Xiaolai/Xiaolai-Regular-54acdfc2166ad7fcbd074f75fd4a56ba.woff2", cne = "./fonts/Xiaolai/Xiaolai-Regular-29cec36cd205b211da97acabaa62f055.woff2", dne = "./fonts/Xiaolai/Xiaolai-Regular-3756e81d3e149cf6099163ee79944fec.woff2", une = "./fonts/Xiaolai/Xiaolai-Regular-8e9f97f01034820170065b2921b4fb5e.woff2", hne = "./fonts/Xiaolai/Xiaolai-Regular-13d2887ec8ee73c43acdabc52a05af7b.woff2", fne = "./fonts/Xiaolai/Xiaolai-Regular-72536a3d71b694a0d53dd90ddceae41e.woff2", pne = "./fonts/Xiaolai/Xiaolai-Regular-603aefd23e350ba7eb124273e3c9bcf1.woff2", mne = "./fonts/Xiaolai/Xiaolai-Regular-095c169f3314805276f603a362766abd.woff2", gne = "./fonts/Xiaolai/Xiaolai-Regular-9544732d2e62d1a429674f8ee41b5d3a.woff2", bne = "./fonts/Xiaolai/Xiaolai-Regular-d3716376641d615e2995605b29bca7b6.woff2", Une = "./fonts/Xiaolai/Xiaolai-Regular-5a1ce3117cfe90c48e8fb4a9a00f694d.woff2", vne = "./fonts/Xiaolai/Xiaolai-Regular-b7d203b051eff504ff59ddca7576b6a9.woff2", yne = "./fonts/Xiaolai/Xiaolai-Regular-4a38cc3e9cf104e69ba246d37f8cf135.woff2", wne = "./fonts/Xiaolai/Xiaolai-Regular-982b630266d87db93d2539affb1275c6.woff2", xne = "./fonts/Xiaolai/Xiaolai-Regular-9592bfc861f07bcb8d75c196b370e548.woff2", Ene = "./fonts/Xiaolai/Xiaolai-Regular-a7accba310e821da5505f71c03b76bdb.woff2", Sne = "./fonts/Xiaolai/Xiaolai-Regular-dac48066b5883d8b4551fc584f0c2a3e.woff2", _ne = "./fonts/Xiaolai/Xiaolai-Regular-a1f916d6039285c4ffb900cd654e418f.woff2", kne = "./fonts/Xiaolai/Xiaolai-Regular-95bfd249da4902577b4b7d76ebdd0b44.woff2", Cne = "./fonts/Xiaolai/Xiaolai-Regular-93fc8f28a33234bcadf1527cafabd502.woff2", Mne = "./fonts/Xiaolai/Xiaolai-Regular-903bb6865f3452e2fda42e3a25547bc5.woff2", Tne = "./fonts/Xiaolai/Xiaolai-Regular-4aca6a43e59aceee2166b0c7e4e85ef1.woff2", Ine = "./fonts/Xiaolai/Xiaolai-Regular-24476a126f129212beb33f66853ea151.woff2", Ane = "./fonts/Xiaolai/Xiaolai-Regular-1b611157cd46bb184d4fa4dae2d6a2b8.woff2", Nne = "./fonts/Xiaolai/Xiaolai-Regular-56a32a7689abd0326e57c10c6c069bb4.woff2", Dne = "./fonts/Xiaolai/Xiaolai-Regular-3cc70dbb64df5b21f1326cc24dee2195.woff2", Lne = "./fonts/Xiaolai/Xiaolai-Regular-f6032fc06eb20480f096199713f70885.woff2", Rne = "./fonts/Xiaolai/Xiaolai-Regular-e2ead7ea7da0437f085f42ffc05f8d13.woff2", Pne = "./fonts/Xiaolai/Xiaolai-Regular-97f7f48ce90c9429bf32ae51469db74d.woff2", One = "./fonts/Xiaolai/Xiaolai-Regular-24a21c1e4449222e8d1898d69ff3a404.woff2", $ne = "./fonts/Xiaolai/Xiaolai-Regular-726303e0774b4e678bff8c2deb6ca603.woff2", Fne = "./fonts/Xiaolai/Xiaolai-Regular-5a7fac4b8b23a6e4e5ba0c9bf1756c91.woff2", zne = "./fonts/Xiaolai/Xiaolai-Regular-2b7441d46298788ac94e610ffcc709b6.woff2", Bne = [{ uri: KJ, descriptors: { unicodeRange: "U+f9b8-fa6d,U+fe32,U+fe45-fe4f,U+ff02-ff0b,U+ff0d-ff1e,U+ff20-ff2a" } }, { uri: YJ, descriptors: { unicodeRange: "U+20dd-20de,U+25ef,U+ff2b-ffbe,U+ffc2-ffc7,U+ffca-ffcf,U+ffd2-ffd7,U+ffda-ffdc,U+ffe0-ffe6,U+ffe8-ffee" } }, { uri: qJ, descriptors: { unicodeRange: "U+d7eb-d7fb,U+f900-f9b7" } }, { uri: ZJ, descriptors: { unicodeRange: "U+d6f2-d7a3,U+d7b0-d7c6,U+d7cb-d7ea" } }, { uri: JJ, descriptors: { unicodeRange: "U+d609-d6f1" } }, { uri: QJ, descriptors: { unicodeRange: "U+d520-d608" } }, { uri: eQ, descriptors: { unicodeRange: "U+d437-d51f" } }, { uri: tQ, descriptors: { unicodeRange: "U+d34e-d436" } }, { uri: nQ, descriptors: { unicodeRange: "U+d265-d34d" } }, { uri: rQ, descriptors: { unicodeRange: "U+d17c-d264" } }, { uri: iQ, descriptors: { unicodeRange: "U+d093-d17b" } }, { uri: aQ, descriptors: { unicodeRange: "U+cfaa-d092" } }, { uri: lQ, descriptors: { unicodeRange: "U+cec1-cfa9" } }, { uri: sQ, descriptors: { unicodeRange: "U+cdd8-cec0" } }, { uri: oQ, descriptors: { unicodeRange: "U+ccf1-cdd7" } }, { uri: cQ, descriptors: { unicodeRange: "U+cc08-ccf0" } }, { uri: dQ, descriptors: { unicodeRange: "U+cb43-cc07" } }, { uri: uQ, descriptors: { unicodeRange: "U+ca83-cb42" } }, { uri: hQ, descriptors: { unicodeRange: "U+c9a1-ca82" } }, { uri: fQ, descriptors: { unicodeRange: "U+c8b8-c9a0" } }, { uri: pQ, descriptors: { unicodeRange: "U+c7cf-c8b7" } }, { uri: mQ, descriptors: { unicodeRange: "U+c6e6-c7ce" } }, { uri: gQ, descriptors: { unicodeRange: "U+c5fd-c6e5" } }, { uri: bQ, descriptors: { unicodeRange: "U+c514-c5fc" } }, { uri: UQ, descriptors: { unicodeRange: "U+c42b-c513" } }, { uri: vQ, descriptors: { unicodeRange: "U+c341-c34e,U+c350-c42a" } }, { uri: yQ, descriptors: { unicodeRange: "U+c258-c340" } }, { uri: wQ, descriptors: { unicodeRange: "U+c16f-c257" } }, { uri: xQ, descriptors: { unicodeRange: "U+c086-c16e" } }, { uri: EQ, descriptors: { unicodeRange: "U+bf9d-c085" } }, { uri: SQ, descriptors: { unicodeRange: "U+beb4-bf9c" } }, { uri: _Q, descriptors: { unicodeRange: "U+bdcb-beb3" } }, { uri: kQ, descriptors: { unicodeRange: "U+bce2-bdca" } }, { uri: CQ, descriptors: { unicodeRange: "U+bbf9-bce1" } }, { uri: MQ, descriptors: { unicodeRange: "U+bb10-bbf8" } }, { uri: TQ, descriptors: { unicodeRange: "U+ba27-bb0f" } }, { uri: IQ, descriptors: { unicodeRange: "U+b93e-ba26" } }, { uri: AQ, descriptors: { unicodeRange: "U+b855-b93d" } }, { uri: NQ, descriptors: { unicodeRange: "U+b76c-b854" } }, { uri: DQ, descriptors: { unicodeRange: "U+b683-b76b" } }, { uri: LQ, descriptors: { unicodeRange: "U+b59a-b682" } }, { uri: RQ, descriptors: { unicodeRange: "U+b4b1-b599" } }, { uri: PQ, descriptors: { unicodeRange: "U+11fb-11ff,U+b3cd-b4b0" } }, { uri: OQ, descriptors: { unicodeRange: "U+11e6-11fa,U+b2f9-b3cc" } }, { uri: $Q, descriptors: { unicodeRange: "U+11d1-11e5,U+b225-b2f8" } }, { uri: FQ, descriptors: { unicodeRange: "U+11bc-11d0,U+b151-b224" } }, { uri: zQ, descriptors: { unicodeRange: "U+11a7-11bb,U+b07d-b150" } }, { uri: BQ, descriptors: { unicodeRange: "U+1191-11a6,U+afaa-b07c" } }, { uri: HQ, descriptors: { unicodeRange: "U+117c-1190,U+aed6-afa9" } }, { uri: WQ, descriptors: { unicodeRange: "U+1167-117b,U+ae02-aed5" } }, { uri: XQ, descriptors: { unicodeRange: "U+1152-115e,U+1160-1166,U+ad2d-ae01" } }, { uri: VQ, descriptors: { unicodeRange: "U+113d-1151,U+ac59-ad2c" } }, { uri: GQ, descriptors: { unicodeRange: "U+1100-113c,U+9f95-9f98,U+9f9c-9f9e,U+9fa1-9fce,U+9fd0,U+a960-a97c,U+ac00-ac58" } }, { uri: jQ, descriptors: { unicodeRange: "U+9771-9772,U+9775,U+9777-977b,U+977d-9784,U+9786-978a,U+978c,U+978e-9790,U+9793,U+9795-9797,U+9799-979f,U+97a1-97a2,U+97a4-97aa,U+97ac,U+97ae,U+97b0-97b1,U+97b3,U+97b5-97e5,U+97e8,U+97ee-97f2,U+97f4,U+97f7-982d" } }, { uri: KQ, descriptors: { unicodeRange: "U+9491,U+9496,U+9498,U+94c7,U+94cf,U+94d3-94d4,U+94da,U+94e6,U+94fb,U+951c,U+9520,U+9527,U+9533,U+953d,U+9543,U+9548,U+954b,U+9555,U+955a,U+9560,U+956e,U+9574-9575,U+9577-957e,U+9580-95e7,U+95ec,U+95ff,U+9607,U+9613,U+9618,U+961b,U+961e,U+9620,U+9623-9629,U+962b-962d,U+962f-9630,U+9637-963a,U+963e,U+9641,U+9643,U+964a,U+964e-964f,U+9651-9653,U+9656-965a,U+965c-965e,U+9660,U+9663,U+9665-9666,U+966b,U+966d-9671,U+9673,U+9678-9684,U+9687,U+9689-968a,U+968c,U+968e,U+9691-9693" } }, { uri: YQ, descriptors: { unicodeRange: "U+923c-9273,U+9275-928d,U+928f-92ad,U+92af-92c7,U+92c9-92ee" } }, { uri: qQ, descriptors: { unicodeRange: "U+9159,U+915b-915c,U+915f-9160,U+9166-9168,U+916b,U+916d,U+9173,U+917a-917c,U+9180-9184,U+9186,U+9188,U+918a,U+918e-918f,U+9193-9199,U+919c-91a1,U+91a4-91a9,U+91ab-91ac,U+91b0-91b3,U+91b6-91b9,U+91bb-91c6,U+91c8,U+91cb,U+91d0,U+91d2-91db,U+91dd-923b" } }, { uri: ZQ, descriptors: { unicodeRange: "U+902b-902c,U+9030-9034,U+9037,U+9039-903a,U+903d,U+903f-9040,U+9043,U+9045-9046,U+9048-904c,U+904e,U+9054-9056,U+9059-905a,U+905c-9061,U+9064,U+9066-9067,U+9069-906c,U+906f-9073,U+9076-907c,U+907e,U+9081,U+9084-9087,U+9089-908a,U+908c-9090,U+9092,U+9094,U+9096,U+9098,U+909a,U+909c,U+909e-90a0,U+90a4-90a5,U+90a7-90a9,U+90ab,U+90ad,U+90b2,U+90b7,U+90bc-90bd,U+90bf-90c0,U+90c2-90c3,U+90c6,U+90c8-90c9,U+90cb-90cd,U+90d2,U+90d4-90d6,U+90d8-90da,U+90de-90e0,U+90e3-90e5,U+90e9-90ea,U+90ec,U+90ee,U+90f0-90f3,U+90f5-90f7,U+90f9-90fc,U+90ff-9101,U+9103,U+9105-9118,U+911a-911d,U+911f-9121,U+9124-912e,U+9130,U+9132-9138,U+913a-9142,U+9144-9145,U+9147-9148,U+9151,U+9153-9156,U+9158" } }, { uri: JQ, descriptors: { unicodeRange: "U+8f03-8f65,U+8f6a,U+8f80,U+8f8c,U+8f92,U+8f9d,U+8fa0-8fa2,U+8fa4-8fa7,U+8faa,U+8fac-8faf,U+8fb2-8fb5,U+8fb7-8fb8,U+8fba-8fbc,U+8fbf-8fc0,U+8fc3,U+8fc6,U+8fc9-8fcd,U+8fcf,U+8fd2,U+8fd6-8fd7,U+8fda,U+8fe0-8fe1,U+8fe3,U+8fe7,U+8fec,U+8fef,U+8ff1-8ff2,U+8ff4-8ff6,U+8ffa-8ffc,U+8ffe-8fff,U+9007-9008,U+900c,U+900e,U+9013,U+9015,U+9018-9019,U+901c,U+9023-9025,U+9027-902a" } }, { uri: QQ, descriptors: { unicodeRange: "U+8d03-8d1c,U+8d20,U+8d51-8d52,U+8d57,U+8d5f,U+8d65,U+8d68-8d6a,U+8d6c,U+8d6e-8d6f,U+8d71-8d72,U+8d78-8d80,U+8d82-8d83,U+8d86-8d89,U+8d8c-8d90,U+8d92-8d93,U+8d95-8d9e,U+8da0-8da2,U+8da4-8db0,U+8db2,U+8db6-8db7,U+8db9,U+8dbb,U+8dbd,U+8dc0-8dc2,U+8dc5,U+8dc7-8dca,U+8dcd,U+8dd0,U+8dd2-8dd5,U+8dd8-8dd9,U+8ddc,U+8de0-8de2,U+8de5-8de7,U+8de9,U+8ded-8dee,U+8df0-8df2,U+8df4,U+8df6,U+8dfc,U+8dfe-8e04,U+8e06-8e08,U+8e0b,U+8e0d-8e0e,U+8e10-8e13,U+8e15-8e1c,U+8e20-8e21,U+8e24-8e28,U+8e2b,U+8e2d,U+8e30,U+8e32-8e34,U+8e36-8e38,U+8e3b-8e3c,U+8e3e-8e3f,U+8e43,U+8e45-8e46" } }, { uri: eee, descriptors: { unicodeRange: "U+8bea,U+8c09,U+8c1e,U+8c38-8c40,U+8c42-8c45,U+8c48,U+8c4a-8c4b,U+8c4d-8c54,U+8c56-8c59,U+8c5b-8c60,U+8c63-8c69,U+8c6c-8c72,U+8c74-8c77,U+8c7b-8c81,U+8c83-8c84,U+8c86-8c88,U+8c8b,U+8c8d-8c93,U+8c95-8c97,U+8c99-8d02" } }, { uri: tee, descriptors: { unicodeRange: "U+8a64-8a78,U+8a7a-8a88,U+8a8b-8a92,U+8a94-8b06,U+8b08-8b1b" } }, { uri: nee, descriptors: { unicodeRange: "U+8987-89c0,U+89c3,U+89cd,U+89d3-89d5,U+89d7-89d9,U+89db,U+89dd,U+89df-89e2,U+89e4,U+89e7-89ea,U+89ec-89ee,U+89f0-89f2,U+89f4-89ff,U+8a01-8a06,U+8a08-8a3d,U+8a3f-8a47,U+8a49-8a63" } }, { uri: ree, descriptors: { unicodeRange: "U+87e3-87e4,U+87e6-87e9,U+87eb-87ed,U+87ef-87f8,U+87fa-87fd,U+87ff-8802,U+8804-8809,U+880b-8812,U+8814,U+8817-881a,U+881c-8820,U+8823-8831,U+8833-8838,U+883a-883b,U+883d-883f,U+8841-8843,U+8846-884b,U+884e-8853,U+8855-8856,U+8858,U+885a-8860,U+8866-8867,U+886a,U+886d,U+886f,U+8871,U+8873-8876,U+8878-887c,U+8880,U+8883,U+8886-8887,U+8889-888a,U+888c,U+888e-8891,U+8893-8895,U+8897-889b,U+889d-88a1,U+88a3,U+88a5-88aa,U+88ac,U+88ae-88b0,U+88b2-88b6,U+88b8-88bb" } }, { uri: iee, descriptors: { unicodeRange: "U+86e7-86e8,U+86ea-86ec,U+86ef,U+86f5-86f7,U+86fa-86fd,U+86ff,U+8701,U+8704-8706,U+870b-870c,U+870e-8711,U+8714,U+8716,U+8719,U+871b,U+871d,U+871f-8720,U+8724,U+8726-8728,U+872a-872d,U+872f-8730,U+8732-8733,U+8735-8736,U+8738-873a,U+873c-873d,U+8740-8746,U+874a-874b,U+874d,U+874f-8752,U+8754-8756,U+8758,U+875a-875f,U+8761-8762,U+8766-876d,U+876f,U+8771-8773,U+8775,U+8777-877a,U+877f-8781,U+8784,U+8786-8787,U+8789-878a,U+878c,U+878e-8792,U+8794-8796,U+8798-879e,U+87a0-87a7,U+87a9-87aa,U+87ae,U+87b0-87b2,U+87b4,U+87b6-87b9,U+87bb-87bc,U+87be-87bf,U+87c1-87c5,U+87c7-87c9,U+87cc-87d0,U+87d4-87da,U+87dc-87df,U+87e1-87e2" } }, { uri: aee, descriptors: { unicodeRange: "U+8604,U+8606-8610,U+8612-8615,U+8617-8626,U+8628,U+862a-8637,U+8639-863b,U+863d-864c,U+8652-8653,U+8655-8659,U+865b-865d,U+865f-8661,U+8663-866a,U+866d,U+866f-8670,U+8672-8678,U+8683-8689,U+868e-8692,U+8694,U+8696-869b,U+869e-86a2,U+86a5-86a6,U+86ab,U+86ad-86ae,U+86b2-86b3,U+86b7-86b9,U+86bb-86bf,U+86c1-86c3,U+86c5,U+86c8,U+86cc-86cd,U+86d2-86d3,U+86d5-86d7,U+86da,U+86dc-86dd,U+86e0-86e3,U+86e5-86e6" } }, { uri: lee, descriptors: { unicodeRange: "U+8456,U+8458,U+845d-8460,U+8462,U+8464-8468,U+846a,U+846e-8470,U+8472,U+8474,U+8477,U+8479,U+847b-8481,U+8483-8486,U+848a,U+848d,U+848f-8496,U+8498,U+849a-849b,U+849d-84a0,U+84a2-84ae,U+84b0-84b1,U+84b3,U+84b5-84b7,U+84bb-84bc,U+84be,U+84c0,U+84c2-84c3,U+84c5-84c8,U+84cb-84cc,U+84ce-84cf,U+84d2,U+84d4-84d5,U+84d7-84dc,U+84de,U+84e1-84e2,U+84e4,U+84e7-84eb,U+84ed-84ef,U+84f1-84fb,U+84fd-84fe,U+8500-850b,U+850d-8510,U+8512,U+8514-8516,U+8518-8519,U+851b-851e,U+8520,U+8522-852a,U+852d-8536,U+853e-8542,U+8544-8547,U+854b-854f" } }, { uri: see, descriptors: { unicodeRange: "U+82c2-82c3,U+82c5-82c6,U+82c9,U+82d0,U+82d6,U+82d9-82da,U+82dd,U+82e2,U+82e7-82ea,U+82ec-82ee,U+82f0,U+82f2-82f3,U+82f5-82f6,U+82f8,U+82fa,U+82fc-8300,U+830a-830b,U+830d,U+8310,U+8312-8313,U+8316,U+8318-8319,U+831d-8326,U+8329-832a,U+832e,U+8330,U+8332,U+8337,U+833b,U+833d-833f,U+8341-8342,U+8344-8345,U+8348,U+834a-834e,U+8353,U+8355-8359,U+835d,U+8362,U+8370-8376,U+8379-837a,U+837e-8384,U+8387-8388,U+838a-838d,U+838f-8391,U+8394-8397,U+8399-839a,U+839d,U+839f,U+83a1-83a7,U+83ac-83af,U+83b5,U+83bb,U+83be-83bf,U+83c2-83c4,U+83c6,U+83c8-83c9,U+83cb,U+83cd-83ce,U+83d0-83d3,U+83d5,U+83d7,U+83d9-83db,U+83de,U+83e2-83e4,U+83e6-83e8,U+83eb-83ef,U+83f3-83f7,U+83fa-83fc,U+83fe-8400,U+8402,U+8405,U+8407-840a,U+8410,U+8412-8417,U+8419-841b,U+841e-8423,U+8429-8430,U+8432-8437,U+8439-843b,U+843e-8445,U+8447-8450,U+8452-8455" } }, { uri: oee, descriptors: { unicodeRange: "U+81a4-81a5,U+81a7,U+81a9,U+81ab-81b2,U+81b4-81b9,U+81bc-81bf,U+81c4-81c5,U+81c7-81c9,U+81cb,U+81cd-81e2,U+81e4-81e6,U+81e8-81e9,U+81eb,U+81ee-81f2,U+81f5-81fa,U+81fd,U+81ff,U+8203,U+8207-820b,U+820e-820f,U+8211,U+8213,U+8215-821a,U+821d,U+8220,U+8224-8227,U+8229,U+822e,U+8232,U+823a,U+823c-823d,U+823f-8243,U+8245-8246,U+8248,U+824a,U+824c-824e,U+8250-8257,U+8259,U+825b-825e,U+8260-8267,U+8269-826d,U+8271,U+8275-8278,U+827b-827c,U+8280-8281,U+8283,U+8285-8287,U+8289,U+828c,U+8290,U+8293-8296,U+829a-829b,U+829e,U+82a0,U+82a2-82a3,U+82a7,U+82b2,U+82b5-82b6,U+82ba-82bc,U+82bf-82c0" } }, { uri: cee, descriptors: { unicodeRange: "U+8059,U+805b-8068,U+806b-8070,U+8072-807e,U+8081-8082,U+8085,U+8088,U+808a,U+808d-8092,U+8094-8095,U+8097,U+8099,U+809e,U+80a3,U+80a6-80a8,U+80ac,U+80b0,U+80b3,U+80b5-80b6,U+80b8-80b9,U+80bb,U+80c5,U+80c7-80cb,U+80cf-80d5,U+80d8,U+80df-80e0,U+80e2-80e3,U+80e6,U+80ee,U+80f5,U+80f7,U+80f9,U+80fb,U+80fe-8101,U+8103-8105,U+8107-8108,U+810b-810c,U+8115,U+8117,U+8119,U+811b-811d,U+811f-812b,U+812d-812e,U+8130,U+8133-8135,U+8137,U+8139-813d,U+813f-8145,U+8147,U+8149,U+814d-814f,U+8152,U+8156-8158,U+815b-815f,U+8161-8164,U+8166,U+8168,U+816a-816c,U+816f,U+8172-8173,U+8175-8178,U+8181,U+8183-8187,U+8189,U+818b-818e,U+8190,U+8192-8197,U+8199-819a,U+819e-81a2" } }, { uri: dee, descriptors: { unicodeRange: "U+7f3c-7f41,U+7f43,U+7f46-7f4f,U+7f52-7f53,U+7f56,U+7f59,U+7f5b-7f5e,U+7f60,U+7f63-7f67,U+7f6b-7f6d,U+7f6f-7f70,U+7f73,U+7f75-7f78,U+7f7a-7f7d,U+7f7f-7f80,U+7f82-7f89,U+7f8b,U+7f8d,U+7f8f-7f93,U+7f95-7f99,U+7f9b-7f9c,U+7fa0,U+7fa2-7fa3,U+7fa5-7fa6,U+7fa8-7fae,U+7fb1,U+7fb3-7fb7,U+7fba-7fbb,U+7fbe,U+7fc0,U+7fc2-7fc4,U+7fc6-7fc9,U+7fcb,U+7fcd,U+7fcf-7fd3,U+7fd6-7fd7,U+7fd9-7fde,U+7fe2-7fe4,U+7fe7-7fe8,U+7fea-7fed,U+7fef,U+7ff2,U+7ff4-7ffa,U+7ffd-7fff,U+8002,U+8007-800a,U+800e-800f,U+8011,U+8013,U+801a-801b,U+801d-801f,U+8021,U+8023-8024,U+802b-8030,U+8032,U+8034,U+8039-803a,U+803c,U+803e,U+8040-8041,U+8044-8045,U+8047-8049,U+804e-8051,U+8053,U+8055-8057" } }, { uri: uee, descriptors: { unicodeRange: "U+7cd8,U+7cda-7cdb,U+7cdd-7cde,U+7ce1-7ce7,U+7ce9-7cee,U+7cf0-7cf7,U+7cf9-7cfa,U+7cfc-7d09,U+7d0b-7d1f,U+7d21,U+7d23-7d26,U+7d28-7d2a,U+7d2c-7d2e,U+7d30-7d6d,U+7d6f-7d76,U+7d78-7d94" } }, { uri: hee, descriptors: { unicodeRange: "U+7afe,U+7b00-7b02,U+7b05,U+7b07,U+7b09,U+7b0c-7b0e,U+7b10,U+7b12-7b13,U+7b16-7b18,U+7b1a,U+7b1c-7b1d,U+7b1f,U+7b21-7b23,U+7b27,U+7b29,U+7b2d,U+7b2f-7b30,U+7b32,U+7b34-7b37,U+7b39,U+7b3b,U+7b3d,U+7b3f-7b44,U+7b46,U+7b48,U+7b4a,U+7b4d-7b4e,U+7b53,U+7b55,U+7b57,U+7b59,U+7b5c,U+7b5e-7b5f,U+7b61,U+7b63-7b6d,U+7b6f-7b70,U+7b73-7b74,U+7b76,U+7b78,U+7b7a,U+7b7c-7b7d,U+7b7f,U+7b81-7b84,U+7b86-7b8c,U+7b8e-7b8f,U+7b91-7b93,U+7b96,U+7b98-7b9b,U+7b9e-7ba0,U+7ba3-7ba5,U+7bae-7bb0,U+7bb2-7bb3,U+7bb5-7bb7,U+7bb9-7bc0,U+7bc2-7bc5,U+7bc8-7bcb,U+7bcd-7bd0,U+7bd2,U+7bd4-7bd8,U+7bdb-7bdc,U+7bde-7be0,U+7be2-7be4,U+7be7-7be9,U+7beb-7bed,U+7bef-7bf0,U+7bf2-7bf6,U+7bf8-7bfb,U+7bfd,U+7bff-7c06,U+7c08-7c0a,U+7c0d-7c0e,U+7c10-7c13" } }, { uri: fee, descriptors: { unicodeRange: "U+7a10-7a13,U+7a15-7a16,U+7a18-7a19,U+7a1b-7a1d,U+7a1f,U+7a21-7a22,U+7a24-7a32,U+7a34-7a36,U+7a38,U+7a3a,U+7a3e,U+7a40-7a45,U+7a47-7a50,U+7a52-7a56,U+7a58-7a6f,U+7a71-7a73,U+7a75,U+7a7b-7a7e,U+7a82,U+7a85,U+7a87,U+7a89-7a8c,U+7a8e-7a90,U+7a93-7a94,U+7a99-7a9b,U+7a9e,U+7aa1-7aa4,U+7aa7,U+7aa9-7aab,U+7aae-7ab2,U+7ab4-7abe,U+7ac0-7aca,U+7acc-7ad5,U+7ad7-7ad8,U+7ada-7add,U+7ae1-7ae2,U+7ae4,U+7ae7-7aec,U+7aee,U+7af0-7af8,U+7afb-7afc" } }, { uri: pee, descriptors: { unicodeRange: "U+790d-7912,U+7914-791d,U+791f-7923,U+7925-7933,U+7935-7939,U+793d,U+793f,U+7942-7945,U+7947,U+794a-7952,U+7954-7955,U+7958-7959,U+7961,U+7963-7964,U+7966,U+7969-796c,U+796e,U+7970-7976,U+7979,U+797b-797f,U+7982-7983,U+7986-7989,U+798b-798e,U+7990-7999,U+799b-79a6,U+79a8-79b2,U+79b4-79b8,U+79bc,U+79bf,U+79c2,U+79c4-79c5,U+79c7-79c8,U+79ca,U+79cc,U+79ce-79d0,U+79d3-79d4,U+79d6-79d7,U+79d9-79de,U+79e0-79e2,U+79e5,U+79e8,U+79ea,U+79ec,U+79ee,U+79f1-79f7,U+79f9-79fa,U+79fc,U+79fe-79ff,U+7a01,U+7a04-7a05,U+7a07-7a0a,U+7a0c,U+7a0f" } }, { uri: mee, descriptors: { unicodeRange: "U+77d8-77da,U+77dd-77e1,U+77e4,U+77e6,U+77e8,U+77ea,U+77ef-77f2,U+77f4-77f5,U+77f7,U+77f9-77fc,U+7803-7808,U+780a-780b,U+780e-7810,U+7813,U+7815,U+7819,U+781b,U+781e,U+7820-7822,U+7824,U+7828,U+782a-782b,U+782e-782f,U+7831-7833,U+7835-7836,U+783d,U+783f,U+7841-7844,U+7846,U+7848-784b,U+784d,U+784f,U+7851,U+7853-7854,U+7858-785c,U+785e-7869,U+786f-7876,U+7878-787b,U+787d-7886,U+7888,U+788a-788b,U+788f-7890,U+7892,U+7894-7896,U+7899,U+789d-789e,U+78a0,U+78a2,U+78a4,U+78a6,U+78a8-78af,U+78b5-78b8,U+78ba-78bd,U+78bf-78c0,U+78c2-78c4,U+78c6-78c8,U+78cc-78cf,U+78d1-78d3,U+78d6-78d8,U+78da-78e7,U+78e9-78eb,U+78ed-78f1,U+78f3,U+78f5-78f6,U+78f8-78f9,U+78fb-7900,U+7902-7904,U+7906-790c" } }, { uri: gee, descriptors: { unicodeRange: "U+76af-76b0,U+76b3,U+76b5-76be,U+76c0-76c1,U+76c3-76c4,U+76c7,U+76c9,U+76cb-76cc,U+76d3,U+76d5,U+76d9-76da,U+76dc-76de,U+76e0-76e4,U+76e6-76ed,U+76f0,U+76f3,U+76f5-76f7,U+76fa-76fb,U+76fd,U+76ff-7703,U+7705-7706,U+770a,U+770c,U+770e-7718,U+771b-771e,U+7721,U+7723-7725,U+7727,U+772a-772c,U+772e,U+7730-7734,U+7739,U+773b,U+773d-773f,U+7742,U+7744-7746,U+7748-774f,U+7752-7759,U+775c-7760,U+7764,U+7767,U+7769-776a,U+776d-7778,U+777a-777c,U+7781-7783,U+7786-778b,U+778f-7790,U+7793-779e,U+77a1,U+77a3-77a4,U+77a6,U+77a8,U+77ab,U+77ad-77af,U+77b1-77b2,U+77b4,U+77b6-77ba,U+77bc,U+77be,U+77c0-77cc,U+77ce-77d6" } }, { uri: bee, descriptors: { unicodeRange: "U+7589-758a,U+758c-758e,U+7590,U+7593,U+7595,U+7598,U+759b-759c,U+759e,U+75a2,U+75a6-75aa,U+75ad,U+75b6-75b7,U+75ba-75bb,U+75bf-75c1,U+75c6,U+75cb-75cc,U+75ce-75d1,U+75d3,U+75d7,U+75d9-75da,U+75dc-75dd,U+75df-75e1,U+75e5,U+75e9,U+75ec-75ef,U+75f2-75f3,U+75f5-75f8,U+75fa-75fb,U+75fd-75fe,U+7602,U+7604,U+7606-7609,U+760b,U+760d-760f,U+7611-7614,U+7616,U+761a,U+761c-761e,U+7621,U+7623,U+7627-7628,U+762c,U+762e-762f,U+7631-7632,U+7636-7637,U+7639-763b,U+763d,U+7641-7642,U+7644-764b,U+764e-7653,U+7655,U+7657-765b,U+765d,U+765f-7662,U+7664-766a,U+766c-766e,U+7670-7677,U+7679-767a,U+767c,U+767f-7681,U+7683,U+7685,U+7689-768a,U+768c-768d,U+768f-7690,U+7692,U+7694-7695,U+7697-7698,U+769a-76a3,U+76a5-76ad" } }, { uri: Uee, descriptors: { unicodeRange: "U+7492-749b,U+749d,U+749f-74a6,U+74aa-74b9,U+74bb-74d1,U+74d3-74db,U+74dd,U+74df,U+74e1,U+74e5,U+74e7-74ed,U+74f0-74f3,U+74f5,U+74f8-74fe,U+7500-7503,U+7505-750c,U+750e,U+7510,U+7512,U+7514-7517,U+751b,U+751d-751e,U+7520-7524,U+7526-7527,U+752a,U+752e,U+7534,U+7536,U+7539,U+753c-753d,U+753f,U+7541-7544,U+7546-7547,U+7549-754a,U+754d,U+7550-7553,U+7555-7558,U+755d-7564,U+7567-7569,U+756b-7571,U+7573,U+7575-7577,U+757a-757e,U+7580-7582,U+7584-7585,U+7587-7588" } }, { uri: vee, descriptors: { unicodeRange: "U+7372-737d,U+737f-7383,U+7385-7386,U+7388,U+738a,U+738c-738d,U+738f-7390,U+7392-7395,U+7397-739a,U+739c-739e,U+73a0-73a1,U+73a3-73a8,U+73aa,U+73ac-73ad,U+73b1,U+73b4-73b6,U+73b8-73b9,U+73bc-73bf,U+73c1,U+73c3-73c7,U+73cb-73cc,U+73ce,U+73d2-73d8,U+73da-73dd,U+73df,U+73e1-73e4,U+73e6,U+73e8,U+73ea-73ec,U+73ee-73f1,U+73f3-7402,U+7404,U+7407-7408,U+740b-740e,U+7411-7419,U+741c-7421,U+7423-7424,U+7427,U+7429,U+742b,U+742d,U+742f,U+7431-7432,U+7437-743b,U+743d-7440,U+7442-7454,U+7456,U+7458,U+745d,U+7460-746c,U+746e-746f,U+7471-7475,U+7478-747d,U+747f,U+7482,U+7484-7486,U+7488-748a,U+748c-748d,U+748f,U+7491" } }, { uri: yee, descriptors: { unicodeRange: "U+7054-705d,U+705f-706a,U+706e,U+7071-7074,U+7077,U+7079-707b,U+707d,U+7081-7084,U+7086-7088,U+708b-708d,U+708f-7091,U+7093,U+7097-7098,U+709a-709b,U+709e-70aa,U+70b0,U+70b2,U+70b4-70b6,U+70ba,U+70be-70bf,U+70c4-70c7,U+70c9,U+70cb-70d7,U+70da,U+70dc-70de,U+70e0-70e3,U+70e5,U+70ea,U+70ee,U+70f0-70f6,U+70f8,U+70fa-70fc,U+70fe-7108,U+710b-710f,U+7111-7112,U+7114,U+7117,U+711b-7125,U+7127-712e,U+7132-7135,U+7137-7144,U+7146-7149,U+714b,U+714d,U+714f-715b,U+715d,U+715f-7163,U+7165,U+7169-716d,U+716f-7171,U+7174-7177" } }, { uri: wee, descriptors: { unicodeRange: "U+722e-722f,U+7232-7234,U+723a,U+723c,U+723e,U+7240-7246,U+7249-724b,U+724e-7251,U+7253-7255,U+7257-7258,U+725a,U+725c,U+725e,U+7260,U+7263-7265,U+7268,U+726a-726d,U+7270-7271,U+7273-7274,U+7276-7278,U+727b-727d,U+7282-7283,U+7285-7289,U+728c,U+728e,U+7290-7291,U+7293-729e,U+72a0-72ab,U+72ae,U+72b1-72b3,U+72b5,U+72ba-72c0,U+72c5-72c7,U+72c9-72cc,U+72cf,U+72d1,U+72d3-72d6,U+72d8,U+72da-72dd,U+72df,U+72e2-72e7,U+72ea-72eb,U+72f5-72f6,U+72f9,U+72fd-7300,U+7302,U+7304-7309,U+730b-730d,U+730f-7312,U+7314,U+7318-731a,U+731f-7320,U+7323-7324,U+7326-7328,U+732d,U+732f-7330,U+7332-7333,U+7335-7336,U+733a-733d,U+7340-734c,U+734e-734f,U+7351,U+7353-7356,U+7358-735f,U+7361-736b,U+736e,U+7370-7371" } }, { uri: xee, descriptors: { unicodeRange: "U+6ec5-6ec6,U+6ec8-6eca,U+6ecc-6ece,U+6ed0,U+6ed2,U+6ed6,U+6ed8-6ed9,U+6edb-6edd,U+6ee3,U+6ee7,U+6eea-6ef3,U+6ef5-6ef8,U+6efa-6f01,U+6f03-6f05,U+6f07-6f08,U+6f0a-6f0e,U+6f10-6f12,U+6f16-6f1f,U+6f21-6f23,U+6f25-6f28,U+6f2c,U+6f2e,U+6f30,U+6f32,U+6f34-6f35,U+6f37-6f3d,U+6f3f-6f45,U+6f48-6f4a,U+6f4c,U+6f4e-6f57,U+6f59-6f5b,U+6f5d,U+6f5f-6f61,U+6f63-6f65,U+6f67-6f6c,U+6f6f-6f71,U+6f73,U+6f75-6f77,U+6f79,U+6f7b,U+6f7d-6f83,U+6f85-6f87,U+6f8a-6f8b,U+6f8f-6f9b,U+6f9d-6fa0,U+6fa2-6fa6,U+6fa8-6fb1" } }, { uri: Eee, descriptors: { unicodeRange: "U+6d73,U+6d75-6d76,U+6d79-6d7b,U+6d7d-6d81,U+6d83-6d84,U+6d86-6d87,U+6d8a-6d8b,U+6d8d,U+6d8f-6d90,U+6d92,U+6d96-6d9a,U+6d9c,U+6da2,U+6da5,U+6dac-6dad,U+6db0-6db1,U+6db3-6db4,U+6db6-6db7,U+6db9-6dbe,U+6dc1-6dc3,U+6dc8-6dca,U+6dcd-6dd0,U+6dd2-6dd5,U+6dd7,U+6dda-6ddc,U+6ddf,U+6de2-6de3,U+6de5,U+6de7-6dea,U+6ded,U+6def-6df0,U+6df2,U+6df4-6df6,U+6df8,U+6dfa,U+6dfd-6e04,U+6e06-6e09,U+6e0b,U+6e0f,U+6e12-6e13,U+6e15,U+6e18-6e19,U+6e1b-6e1c,U+6e1e-6e1f,U+6e22,U+6e26-6e28,U+6e2a,U+6e2c,U+6e2e,U+6e30-6e31,U+6e33,U+6e35-6e37,U+6e39,U+6e3b-6e42,U+6e45-6e4c,U+6e4f-6e52,U+6e55,U+6e57,U+6e59-6e5a,U+6e5c-6e5e,U+6e60-6e6a,U+6e6c-6e6d,U+6e6f-6e7d,U+6e80-6e82,U+6e84,U+6e87-6e88,U+6e8a-6e8e,U+6e91-6e97,U+6e99-6e9b,U+6e9d-6e9e,U+6ea0-6ea1,U+6ea3-6ea4,U+6ea6,U+6ea8-6ea9,U+6eab-6eae,U+6eb0,U+6eb3,U+6eb5,U+6eb8-6eb9,U+6ebc,U+6ebe-6ec0,U+6ec3-6ec4" } }, { uri: See, descriptors: { unicodeRange: "U+6bbb-6bbe,U+6bc0,U+6bc3-6bc4,U+6bc6-6bca,U+6bcc,U+6bce,U+6bd0-6bd1,U+6bd8,U+6bda,U+6bdc-6be0,U+6be2-6be9,U+6bec-6bee,U+6bf0-6bf2,U+6bf4,U+6bf6-6bf8,U+6bfa-6bfc,U+6bfe-6c04,U+6c08-6c0c,U+6c0e,U+6c12,U+6c17,U+6c1c-6c1e,U+6c20,U+6c23,U+6c25,U+6c2b-6c2d,U+6c31,U+6c33,U+6c36-6c37,U+6c39-6c3c,U+6c3e-6c3f,U+6c43-6c45,U+6c48,U+6c4b-6c4f,U+6c51-6c53,U+6c56,U+6c58-6c5a,U+6c62-6c63,U+6c65-6c67,U+6c6b-6c6f,U+6c71,U+6c73,U+6c75,U+6c77-6c78,U+6c7a-6c7c,U+6c7f-6c80,U+6c84,U+6c87,U+6c8a-6c8b,U+6c8d-6c8e,U+6c91-6c92,U+6c95-6c98,U+6c9a,U+6c9c-6c9e,U+6ca0,U+6ca2,U+6ca8,U+6cac,U+6caf-6cb0,U+6cb4-6cb7,U+6cba,U+6cc0-6cc3,U+6cc6-6cc8,U+6ccb,U+6ccd-6ccf,U+6cd1-6cd2,U+6cd8-6cda,U+6cdc-6cdd,U+6cdf,U+6ce4,U+6ce6-6ce7,U+6ce9,U+6cec-6ced,U+6cf2,U+6cf4,U+6cf9,U+6cff-6d00,U+6d02-6d03,U+6d05-6d06,U+6d08-6d0a,U+6d0d,U+6d0f-6d11,U+6d13-6d16,U+6d18,U+6d1c-6d1d,U+6d1f-6d24,U+6d26,U+6d28-6d29,U+6d2c-6d2d,U+6d2f-6d30,U+6d34,U+6d36-6d38,U+6d3a,U+6d3f-6d40,U+6d42,U+6d44,U+6d49,U+6d4c,U+6d50,U+6d55-6d58,U+6d5b,U+6d5d,U+6d5f,U+6d61-6d62,U+6d64-6d65,U+6d67-6d68,U+6d6b-6d6d,U+6d70-6d72" } }, { uri: _ee, descriptors: { unicodeRange: "U+6967-696a,U+696c-696d,U+696f-6970,U+6972-6976,U+697a-697b,U+697d-697f,U+6981,U+6983,U+6985,U+698a-698c,U+698e-6993,U+6996-6997,U+6999-699a,U+699d-69a6,U+69a9-69aa,U+69ac,U+69ae-69b0,U+69b2-69b3,U+69b5-69b6,U+69b8-69ba,U+69bc-69c0,U+69c2-69c9,U+69cb,U+69cd,U+69cf,U+69d1-69d3,U+69d5-69da,U+69dc-69de,U+69e1-69ec,U+69ee-69f1,U+69f3-69fc,U+69fe,U+6a00-6a09,U+6a0b-6a16,U+6a19-6a1e,U+6a20,U+6a22-6a27,U+6a29,U+6a2b-6a2e,U+6a30,U+6a32-6a34,U+6a36-6a3c,U+6a3f-6a43,U+6a45-6a46,U+6a48-6a4a" } }, { uri: kee, descriptors: { unicodeRange: "U+6830-6831,U+6834-6836,U+683a-683b,U+683f,U+6847,U+684b,U+684d,U+684f,U+6852,U+6856-685f,U+686a,U+686c-6873,U+6875,U+6878-6880,U+6882,U+6884,U+6887-688e,U+6890-6892,U+6894-6896,U+6898-68a1,U+68a3-68a5,U+68a9-68ac,U+68ae,U+68b1-68b2,U+68b4,U+68b6-68bf,U+68c1,U+68c3-68c8,U+68ca,U+68cc,U+68ce-68d1,U+68d3-68d4,U+68d6-68d7,U+68d9,U+68db-68df,U+68e1-68e2,U+68e4-68ed,U+68ef,U+68f2-68f4,U+68f6-68f8,U+68fb,U+68fd-6900,U+6902-6904,U+6906-690a,U+690c,U+690f,U+6911,U+6913-691e,U+6921-6923,U+6925-692c,U+692e-692f,U+6931-6933,U+6935-6938,U+693a-693c,U+693e,U+6940-6941,U+6943-6953,U+6955-6956,U+6958-6959,U+695b-695c,U+695f,U+6961-6962,U+6964-6965" } }, { uri: Cee, descriptors: { unicodeRange: "U+66b8,U+66ba-66bd,U+66bf-66d8,U+66da,U+66de-66e5,U+66e7-66e8,U+66ea-66ef,U+66f1,U+66f5-66f6,U+66f8,U+66fa-66fb,U+66fd,U+6701-6707,U+670c,U+670e-670f,U+6711-6713,U+6716,U+6718-671a,U+671c,U+671e,U+6720-6725,U+6727,U+6729,U+672e,U+6730,U+6732-6733,U+6736-6739,U+673b-673c,U+673e-673f,U+6741,U+6744-6745,U+6747,U+674a-674b,U+674d,U+6752,U+6754-6755,U+6757-675b,U+675d,U+6762-6764,U+6766-6767,U+676b-676c,U+676e,U+6771,U+6774,U+6776,U+6778-677b,U+677d,U+6780,U+6782-6783,U+6785-6786,U+6788,U+678a,U+678c-678f,U+6791-6794,U+6796,U+6799,U+679b,U+679f-67a1,U+67a4,U+67a6,U+67a9,U+67ac,U+67ae,U+67b1-67b2,U+67b4,U+67b9-67c0,U+67c2,U+67c5-67ce,U+67d5-67d7,U+67db,U+67df,U+67e1,U+67e3-67e4,U+67e6-67e8,U+67ea-67eb,U+67ed-67ee,U+67f2,U+67f5-67fc,U+67fe,U+6801-6804,U+6806,U+680d,U+6810,U+6812,U+6814-6815,U+6818-681c,U+681e-6820,U+6822-6828,U+682b-682f" } }, { uri: Mee, descriptors: { unicodeRange: "U+6569-656a,U+656d-656f,U+6571,U+6573,U+6575-6576,U+6578-6586,U+6588-658a,U+658d-658f,U+6592,U+6594-6596,U+6598,U+659a,U+659d-659e,U+65a0,U+65a2-65a3,U+65a6,U+65a8,U+65aa,U+65ac,U+65ae,U+65b1-65b8,U+65ba-65bb,U+65be-65c0,U+65c2,U+65c7-65ca,U+65cd,U+65d0-65d1,U+65d3-65d5,U+65d8-65df,U+65e1,U+65e3-65e4,U+65ea-65eb,U+65f2-65f5,U+65f8-65f9,U+65fb-65ff,U+6601,U+6604-6605,U+6607-6609,U+660b,U+660d,U+6610-6612,U+6616-6618,U+661a-661c,U+661e,U+6621-6624,U+6626,U+6629-662c,U+662e,U+6630,U+6632-6633,U+6637-663b,U+663d,U+663f-6640,U+6642,U+6644-664a,U+664d-664e,U+6650-6651,U+6658-6659,U+665b-665e,U+6660,U+6662-6663,U+6665,U+6667,U+6669-666d,U+6671-6673,U+6675,U+6678-6679,U+667b-667d,U+667f-6681,U+6683,U+6685-6686,U+6688-668b,U+668d-6690,U+6692-6695,U+6698-669c,U+669e-66a6,U+66a9-66ad,U+66af-66b3,U+66b5-66b7" } }, { uri: Tee, descriptors: { unicodeRange: "U+5f30,U+5f32-5f38,U+5f3b,U+5f3d-5f3f,U+5f41-5f4f,U+5f51,U+5f54,U+5f59-5f5c,U+5f5e-5f60,U+5f63,U+5f65,U+5f67-5f68,U+5f6b,U+5f6e-5f6f,U+5f72,U+5f74-5f76,U+5f78,U+5f7a,U+5f7d-5f7f,U+5f83,U+5f86,U+5f8d-5f8f,U+5f91,U+5f93-5f94,U+5f96,U+5f9a-5f9b,U+5f9d-5fa0,U+5fa2-5fa7,U+5fa9,U+5fab-5fac,U+5faf-5fb4,U+5fb6,U+5fb8-5fbb,U+5fbe-5fc2,U+5fc7-5fc8,U+5fca-5fcb,U+5fce,U+5fd3-5fd5,U+5fda-5fdc,U+5fde-5fdf,U+5fe2-5fe3,U+5fe5-5fe6,U+5fe8-5fe9,U+5fec,U+5fef-5ff0,U+5ff2-5ff4,U+5ff6-5ff7,U+5ff9-5ffa,U+5ffc,U+6007-6009,U+600b-600c,U+6010-6011,U+6013,U+6017-6018,U+601a,U+601e-601f,U+6022-6024,U+602c-602e,U+6030-6034,U+6036-603a,U+603d-603e,U+6040,U+6044-604a,U+604c,U+604e-604f,U+6051,U+6053-6054,U+6056-6058,U+605b-605c,U+605e-6061,U+6065-6066,U+606e,U+6071-6072,U+6074-6075,U+6077,U+607e,U+6080-6082,U+6085-6088,U+608a-608b,U+608e-6091,U+6093,U+6095,U+6097-6099,U+609c,U+609e,U+60a1-60a2,U+60a4-60a5,U+60a7,U+60a9-60aa,U+60ae,U+60b0,U+60b3,U+60b5-60b7,U+60b9-60ba,U+60bd-60c4,U+60c7-60c9,U+60cc" } }, { uri: Iee, descriptors: { unicodeRange: "U+635a-635d,U+6360,U+6364-6366,U+6368,U+636a-636c,U+636f-6370,U+6372-6375,U+6378-6379,U+637c-637f,U+6381,U+6383-6386,U+638b,U+638d,U+6391,U+6393-6395,U+6397,U+6399-639f,U+63a1,U+63a4,U+63a6,U+63ab,U+63af,U+63b1-63b2,U+63b5-63b6,U+63b9,U+63bb,U+63bd,U+63bf-63c3,U+63c5,U+63c7-63c8,U+63ca-63cc,U+63d1,U+63d3-63d5,U+63d7-63dd,U+63df,U+63e2,U+63e4-63e8,U+63eb-63ec,U+63ee-63f1,U+63f3,U+63f5,U+63f7,U+63f9-63fc,U+63fe,U+6403-6404,U+6406-640a,U+640d-640e,U+6411-6412,U+6415-641a,U+641d,U+641f,U+6422-6425,U+6427-6429,U+642b,U+642e-6433,U+6435-6439,U+643b-643c,U+643e,U+6440,U+6442-6443,U+6449,U+644b-6451,U+6453,U+6455-6457,U+6459-645d,U+645f-6466,U+6468,U+646a-646c,U+646e-6477,U+647b-6481,U+6483,U+6486,U+6488-648f" } }, { uri: Aee, descriptors: { unicodeRange: "U+61c5-61c7,U+61c9,U+61cc-61d0,U+61d3,U+61d5-61e5,U+61e7-61f4,U+61f6-61fe,U+6200-6205,U+6207,U+6209,U+6213-6214,U+6219,U+621c-621e,U+6220,U+6223,U+6226-6229,U+622b,U+622d,U+622f-6232,U+6235-6236,U+6238-623c,U+6242,U+6244-6246,U+624a,U+624f-6250,U+6255-6257,U+6259-625a,U+625c-6262,U+6264-6265,U+6268,U+6271-6272,U+6274-6275,U+6277-6278,U+627a-627b,U+627d,U+6281-6283,U+6285-6288,U+628b-6290,U+6294,U+6299,U+629c-629e,U+62a3,U+62a6-62a7,U+62a9-62aa,U+62ad-62b0,U+62b2-62b4,U+62b6-62b8,U+62ba,U+62be,U+62c0-62c1,U+62c3,U+62cb,U+62cf,U+62d1,U+62d5,U+62dd-62de,U+62e0-62e1,U+62e4,U+62ea-62eb,U+62f0,U+62f2,U+62f5,U+62f8-62fb,U+6300,U+6303-6306,U+630a-630d,U+630f-6310,U+6312-6315,U+6317-6319,U+631c,U+6326-6327,U+6329,U+632c-632e,U+6330-6331,U+6333-6338,U+633b-633c,U+633e-6341,U+6344,U+6347-6348,U+634a,U+6351-6354,U+6356-6359" } }, { uri: Nee, descriptors: { unicodeRange: "U+5dd0-5dda,U+5ddc,U+5ddf-5de0,U+5de3-5de4,U+5dea,U+5dec-5ded,U+5df0,U+5df5-5df6,U+5df8-5dfc,U+5dff-5e00,U+5e04,U+5e07,U+5e09-5e0b,U+5e0d-5e0e,U+5e12-5e13,U+5e17,U+5e1e-5e25,U+5e28-5e2c,U+5e2f-5e30,U+5e32-5e36,U+5e39-5e3a,U+5e3e-5e41,U+5e43,U+5e46-5e4b,U+5e4d-5e53,U+5e56-5e5a,U+5e5c-5e5d,U+5e5f-5e60,U+5e63-5e71,U+5e75,U+5e77,U+5e79,U+5e7e,U+5e81-5e83,U+5e85,U+5e88-5e89,U+5e8c-5e8e,U+5e92,U+5e98,U+5e9b,U+5e9d,U+5ea1-5ea4,U+5ea8-5eac,U+5eae-5eb2,U+5eb4,U+5eba-5ebd,U+5ebf-5ec8,U+5ecb-5ed0,U+5ed4-5ed5,U+5ed7-5eda,U+5edc-5ee7,U+5ee9,U+5eeb-5ef3,U+5ef5,U+5ef8-5ef9,U+5efb-5efd,U+5f05-5f07,U+5f09,U+5f0c-5f0e,U+5f10,U+5f12,U+5f14,U+5f16,U+5f19-5f1a,U+5f1c-5f1e,U+5f21-5f24,U+5f28,U+5f2b-5f2c,U+5f2e" } }, { uri: Dee, descriptors: { unicodeRange: "U+60cd-60d0,U+60d2-60d4,U+60d6-60d7,U+60d9,U+60db,U+60de,U+60e1-60e5,U+60ea,U+60f1-60f2,U+60f5,U+60f7-60f8,U+60fb-60ff,U+6102-6105,U+6107,U+610a-610c,U+6110-6114,U+6116-6119,U+611b-611e,U+6121-6122,U+6125,U+6128-612a,U+612c-613e,U+6140-6147,U+6149,U+614b,U+614d,U+614f-6150,U+6152-6154,U+6156-615c,U+615e-6161,U+6163-6166,U+6169-616f,U+6171-6174,U+6176,U+6178-618a,U+618c-618d,U+618f-6193,U+6195-619c,U+619e-61a6,U+61aa-61ab,U+61ad-61b6,U+61b8-61bd,U+61bf-61c1,U+61c3-61c4" } }, { uri: Lee, descriptors: { unicodeRange: "U+5cf4-5cfa,U+5cfc-5d01,U+5d04-5d05,U+5d08-5d0d,U+5d0f-5d13,U+5d15,U+5d17-5d1a,U+5d1c-5d1d,U+5d1f-5d23,U+5d25,U+5d28,U+5d2a-5d2c,U+5d2f-5d33,U+5d35-5d3c,U+5d3f-5d46,U+5d48-5d49,U+5d4d-5d57,U+5d59-5d5a,U+5d5c,U+5d5e-5d68,U+5d6a,U+5d6d-5d6e,U+5d70-5d73,U+5d75-5d81,U+5d83-5d98,U+5d9a-5d9c,U+5d9e-5db6,U+5db8-5dc4,U+5dc6-5dcc,U+5dce-5dcf" } }, { uri: Ree, descriptors: { unicodeRange: "U+5b52,U+5b56,U+5b5e,U+5b60-5b61,U+5b67-5b68,U+5b6b,U+5b6d-5b6f,U+5b72,U+5b74,U+5b76-5b79,U+5b7b-5b7c,U+5b7e-5b7f,U+5b82,U+5b86,U+5b8a,U+5b8d-5b8e,U+5b90-5b92,U+5b94,U+5b96,U+5b9f,U+5ba7-5ba9,U+5bac-5baf,U+5bb1-5bb2,U+5bb7,U+5bba-5bbc,U+5bc0-5bc1,U+5bc3,U+5bc8-5bcb,U+5bcd-5bcf,U+5bd1,U+5bd4-5bdc,U+5be0,U+5be2-5be3,U+5be6-5be7,U+5be9-5bed,U+5bef,U+5bf1-5bf7,U+5bfd-5bfe,U+5c00,U+5c02-5c03,U+5c05,U+5c07-5c08,U+5c0b-5c0e,U+5c10,U+5c12-5c13,U+5c17,U+5c19,U+5c1b,U+5c1e-5c21,U+5c23,U+5c26,U+5c28-5c2b,U+5c2d-5c30,U+5c32-5c33,U+5c35-5c37,U+5c43-5c44,U+5c46-5c47,U+5c4c-5c4d,U+5c52-5c54,U+5c56-5c58,U+5c5a-5c5d,U+5c5f,U+5c62,U+5c64,U+5c67-5c6d,U+5c70,U+5c72-5c78,U+5c7b-5c7e,U+5c80,U+5c83-5c87,U+5c89-5c8b,U+5c8e-5c8f,U+5c92-5c93,U+5c95,U+5c9d-5ca1,U+5ca4-5ca8,U+5caa,U+5cae-5cb0,U+5cb2,U+5cb4,U+5cb6,U+5cb9-5cbc,U+5cbe,U+5cc0,U+5cc2-5cc3,U+5cc5-5cca,U+5ccc-5cd1,U+5cd3-5cd8,U+5cda-5ce0,U+5ce2-5ce3,U+5ce7,U+5ce9,U+5ceb-5cec,U+5cee-5cef,U+5cf1-5cf3" } }, { uri: Pee, descriptors: { unicodeRange: "U+593b,U+593d-5940,U+5943,U+5945-5946,U+594a,U+594c-594d,U+5950,U+5952-5953,U+5959,U+595b-595f,U+5961,U+5963-5964,U+5966-5972,U+5975,U+5977,U+597a-597c,U+597e-5980,U+5985,U+5989,U+598b-598c,U+598e-5991,U+5994-5995,U+5998,U+599a-599d,U+599f-59a2,U+59a6-59a7,U+59ac-59ad,U+59b0-59b1,U+59b3-59b8,U+59ba,U+59bc-59bd,U+59bf-59c5,U+59c7-59c9,U+59cc-59cf,U+59d5-59d6,U+59d9,U+59db,U+59de-59e2,U+59e4,U+59e6-59e7,U+59e9-59eb,U+59ed-59f8,U+59fa,U+59fc-59fe,U+5a00,U+5a02,U+5a0a-5a0b,U+5a0d-5a10,U+5a12,U+5a14-5a17,U+5a19-5a1b,U+5a1d-5a1e,U+5a21-5a22,U+5a24,U+5a26-5a28,U+5a2a-5a30,U+5a33,U+5a35,U+5a37-5a3b,U+5a3d-5a3f,U+5a41-5a45,U+5a47-5a48,U+5a4b-5a54,U+5a56-5a59,U+5a5b-5a61,U+5a63-5a66,U+5a68-5a69,U+5a6b-5a73,U+5a78-5a79,U+5a7b-5a7e,U+5a80-5a90" } }, { uri: Oee, descriptors: { unicodeRange: "U+5a91,U+5a93-5a99,U+5a9c-5aa9,U+5aab-5ab1,U+5ab4,U+5ab6-5ab7,U+5ab9-5abd,U+5abf-5ac0,U+5ac3-5ac8,U+5aca-5acb,U+5acd-5ad1,U+5ad3,U+5ad5,U+5ad7,U+5ad9-5adb,U+5add-5adf,U+5ae2,U+5ae4-5ae5,U+5ae7-5ae8,U+5aea,U+5aec-5af0,U+5af2-5b08,U+5b0a-5b15,U+5b18-5b31,U+5b33,U+5b35-5b36,U+5b38-5b3f,U+5b41-5b4f" } }, { uri: $ee, descriptors: { unicodeRange: "U+5843,U+5845-584b,U+584e-5850,U+5852-5853,U+5855-5857,U+5859-585d,U+585f-5864,U+5866-586a,U+586d-587d,U+587f,U+5882,U+5884,U+5886-5888,U+588a-5891,U+5894-5898,U+589b-589d,U+58a0-58a7,U+58aa-58bb,U+58bd-58c0,U+58c2-58c4,U+58c6-58d0,U+58d2-58d4,U+58d6-58e3,U+58e5-58ea,U+58ed,U+58ef,U+58f1-58f2,U+58f4-58f5,U+58f7-58f8,U+58fa-5901,U+5903,U+5905-5906,U+5908-590c,U+590e,U+5910-5913,U+5917-5918,U+591b,U+591d-591e,U+5920-5923,U+5926,U+5928,U+592c,U+5930,U+5932-5933,U+5935-5936" } }, { uri: Fee, descriptors: { unicodeRange: "U+56d0-56d3,U+56d5-56d6,U+56d8-56d9,U+56dc,U+56e3,U+56e5-56ea,U+56ec,U+56ee-56ef,U+56f2-56f3,U+56f6-56f8,U+56fb-56fc,U+5700-5702,U+5705,U+5707,U+570b-571b,U+571d-571e,U+5720-5722,U+5724-5727,U+572b,U+5731-5732,U+5734-5738,U+573c-573d,U+573f,U+5741,U+5743-5746,U+5748-5749,U+574b,U+5752-5756,U+5758-5759,U+5762-5763,U+5765,U+5767,U+576c,U+576e,U+5770-5772,U+5774-5775,U+5778-577a,U+577d-5781,U+5787-578a,U+578d-5791,U+5794-579a,U+579c-579f,U+57a5,U+57a8,U+57aa,U+57ac,U+57af-57b1,U+57b3,U+57b5-57b7,U+57b9-57c1,U+57c4-57ca,U+57cc-57cd,U+57d0-57d1,U+57d3,U+57d6-57d7,U+57db-57dc,U+57de,U+57e1-57e3,U+57e5-57ec,U+57ee,U+57f0-57f3,U+57f5-57f7,U+57fb-57fc,U+57fe-57ff,U+5801,U+5803-5805,U+5808-580a,U+580c,U+580e-5810,U+5812-5814,U+5816-5818,U+581a-581d,U+581f,U+5822-5823,U+5825-5829,U+582b-582f,U+5831-5834,U+5836-5842" } }, { uri: zee, descriptors: { unicodeRange: "U+55f9-55fc,U+55ff,U+5602-5607,U+560a-560b,U+560d,U+5610-5617,U+5619-561a,U+561c-561d,U+5620-5622,U+5625-5626,U+5628-562b,U+562e-5630,U+5633,U+5635,U+5637-5638,U+563a,U+563c-563e,U+5640-564b,U+564f-5653,U+5655-5656,U+565a-565b,U+565d-5661,U+5663,U+5665-5667,U+566d-5670,U+5672-5675,U+5677-567a,U+567d-5684,U+5687-568d,U+5690-5692,U+5694-56a2,U+56a4-56ae,U+56b0-56b6,U+56b8-56bb,U+56bd-56c9,U+56cb-56cf" } }, { uri: Bee, descriptors: { unicodeRange: "U+5286-5287,U+5289-528f,U+5291-5292,U+5294-529a,U+529c,U+52a4-52a7,U+52ae-52b0,U+52b4-52bd,U+52c0-52c2,U+52c4-52c6,U+52c8,U+52ca,U+52cc-52cf,U+52d1,U+52d3-52d5,U+52d7,U+52d9-52de,U+52e0-52e3,U+52e5-52ef,U+52f1-52f8,U+52fb-52fd,U+5301-5304,U+5307,U+5309-530c,U+530e,U+5311-5314,U+5318,U+531b-531c,U+531e-531f,U+5322,U+5324-5325,U+5327-5329,U+532b-532d,U+532f-5338,U+533c-533d,U+5340,U+5342,U+5344,U+5346,U+534b-534d,U+5350,U+5354,U+5358-5359,U+535b,U+535d,U+5365,U+5368,U+536a,U+536c-536d,U+5372,U+5376,U+5379,U+537b-537e,U+5380-5381,U+5383,U+5387-5388,U+538a,U+538e-5394,U+5396-5397,U+5399,U+539b-539c,U+539e,U+53a0-53a1,U+53a4,U+53a7,U+53aa-53ad,U+53af-53b5,U+53b7-53ba,U+53bc-53be,U+53c0,U+53c3-53c7,U+53ce-53d0,U+53d2-53d3,U+53d5,U+53da,U+53dc-53de,U+53e1-53e2,U+53e7,U+53f4,U+53fa,U+53fe-5400,U+5402,U+5405,U+5407,U+540b,U+5414,U+5418-541a,U+541c,U+5422,U+5424-5425,U+542a,U+5430,U+5433,U+5436-5437,U+543a" } }, { uri: Hee, descriptors: { unicodeRange: "U+5101-5105,U+5108-510a,U+510c-5111,U+5113-5120,U+5122-513e,U+5142,U+5147,U+514a,U+514c,U+514e-5150,U+5152-5153,U+5157-5159,U+515b,U+515d-5161,U+5163-5164,U+5166-5167,U+5169-516a,U+516f,U+5172,U+517a,U+517e-517f,U+5183-5184,U+5186-5187,U+518a-518b,U+518e-5191,U+5193-5194,U+5198,U+519a,U+519d-519f,U+51a1,U+51a3,U+51a6-51aa,U+51ad-51ae,U+51b4,U+51b8-51ba,U+51be-51bf,U+51c1-51c3,U+51c5,U+51c8,U+51ca,U+51cd-51ce,U+51d0,U+51d2-51da,U+51dc,U+51de-51df,U+51e2-51e3,U+51e5-51ea,U+51ec,U+51ee,U+51f1-51f2,U+51f4,U+51f7,U+51fe,U+5204-5205,U+5209,U+520b-520c,U+520f-5210,U+5213-5215,U+521c,U+521e-521f,U+5221-5223,U+5225-5227,U+522a,U+522c,U+522f,U+5231-5232,U+5234-5235,U+523c,U+523e,U+5244-5249,U+524b,U+524e-524f,U+5252-5253,U+5255,U+5257-525b,U+525d,U+525f-5260,U+5262-5264,U+5266,U+5268,U+526b-526e,U+5270-5271,U+5273-527c,U+527e,U+5280,U+5283-5285" } }, { uri: Wee, descriptors: { unicodeRange: "U+543d,U+543f,U+5441-5442,U+5444-5445,U+5447,U+5449,U+544c-544f,U+5451,U+545a,U+545d-5461,U+5463,U+5465,U+5467,U+5469-5470,U+5474,U+5479-547a,U+547e-547f,U+5481,U+5483,U+5485,U+5487-548a,U+548d,U+5491,U+5493,U+5497-5498,U+549c,U+549e-54a2,U+54a5,U+54ae,U+54b0,U+54b2,U+54b5-54b7,U+54b9-54ba,U+54bc,U+54be,U+54c3,U+54c5,U+54ca-54cb,U+54d6,U+54d8,U+54db,U+54e0-54e4,U+54eb-54ec,U+54ef-54f1,U+54f4-54f9,U+54fb,U+54fe,U+5500,U+5502-5505,U+5508,U+550a-550e,U+5512-5513,U+5515-551a,U+551c-551f,U+5521,U+5525-5526,U+5528-5529,U+552b,U+552d,U+5532,U+5534-5536,U+5538-553b,U+553d,U+5540,U+5542,U+5545,U+5547-5548,U+554b-554f,U+5551-5554,U+5557-555b,U+555d-5560,U+5562-5563,U+5568-5569,U+556b,U+556f-5574,U+5579-557a,U+557d,U+557f,U+5585-5586,U+558c-558e,U+5590,U+5592-5593,U+5595-5597,U+559a-559b,U+559e,U+55a0-55a6,U+55a8-55b0,U+55b2,U+55b4,U+55b6,U+55b8,U+55ba,U+55bc,U+55bf-55c3,U+55c6-55c8,U+55ca-55cb,U+55ce-55d0,U+55d5,U+55d7-55db,U+55de,U+55e0,U+55e2,U+55e7,U+55e9,U+55ed-55ee,U+55f0-55f1,U+55f4,U+55f6,U+55f8" } }, { uri: Xee, descriptors: { unicodeRange: "U+4fe0,U+4fe2,U+4fe4-4fe5,U+4fe7,U+4feb-4fec,U+4ff0,U+4ff2,U+4ff4-4ff7,U+4ff9,U+4ffb-4ffd,U+4fff-500b,U+500e,U+5010-5011,U+5013,U+5015-5017,U+501b,U+501d-501e,U+5020,U+5022-5024,U+5027,U+502b,U+502f-5039,U+503b,U+503d,U+503f-5042,U+5044-5046,U+5049-504b,U+504d,U+5050-5054,U+5056-5059,U+505b,U+505d-5064,U+5066-506b,U+506d-5075,U+5078-507a,U+507c-507d,U+5081-5084,U+5086-5087,U+5089-508c,U+508e-50a2,U+50a4,U+50a6,U+50aa-50ab,U+50ad-50b1,U+50b3-50b9,U+50bc-50ce,U+50d0-50d5,U+50d7-50d9,U+50db-50e5,U+50e8-50eb,U+50ef-50f2,U+50f4,U+50f6-50fa,U+50fc-5100" } }, { uri: Vee, descriptors: { unicodeRange: "U+49d5-4a77" } }, { uri: Gee, descriptors: { unicodeRange: "U+4dac-4dad,U+4daf-4db5,U+4e02,U+4e04-4e06,U+4e0f,U+4e12,U+4e17,U+4e1f-4e21,U+4e23,U+4e26,U+4e29,U+4e2e-4e2f,U+4e31,U+4e33,U+4e35,U+4e37,U+4e3c,U+4e40-4e42,U+4e44,U+4e46,U+4e4a,U+4e51,U+4e55,U+4e57,U+4e5a-4e5b,U+4e62-4e65,U+4e67-4e68,U+4e6a-4e6f,U+4e72,U+4e74-4e7d,U+4e7f-4e85,U+4e87,U+4e8a,U+4e90,U+4e96-4e97,U+4e99,U+4e9c-4e9e,U+4ea3,U+4eaa,U+4eaf-4eb1,U+4eb4,U+4eb6-4eb9,U+4ebc-4ebe,U+4ec8,U+4ecc,U+4ecf-4ed0,U+4ed2,U+4eda-4edc,U+4ee0,U+4ee2,U+4ee6-4ee7,U+4ee9,U+4eed-4eef,U+4ef1,U+4ef4,U+4ef8-4efa,U+4efc,U+4efe,U+4f00,U+4f02-4f08,U+4f0b-4f0c,U+4f12-4f16,U+4f1c-4f1d,U+4f21,U+4f23,U+4f28-4f29,U+4f2c-4f2e,U+4f31,U+4f33,U+4f35,U+4f37,U+4f39,U+4f3b,U+4f3e-4f42,U+4f44-4f45,U+4f47-4f4c,U+4f52,U+4f54,U+4f56,U+4f61-4f62,U+4f66,U+4f68,U+4f6a-4f6b,U+4f6d-4f6e,U+4f71-4f72,U+4f75,U+4f77-4f7a,U+4f7d,U+4f80-4f82,U+4f85-4f87,U+4f8a,U+4f8c,U+4f8e,U+4f90,U+4f92-4f93,U+4f95-4f96,U+4f98-4f9a,U+4f9c,U+4f9e-4f9f,U+4fa1-4fa2,U+4fa4,U+4fab,U+4fad,U+4fb0-4fb4,U+4fb6-4fbe,U+4fc0-4fc2,U+4fc6-4fc9,U+4fcb-4fcd,U+4fd2-4fd6,U+4fd9,U+4fdb" } }, { uri: jee, descriptors: { unicodeRange: "U+4933-49d4" } }, { uri: Kee, descriptors: { unicodeRange: "U+487a-4932" } }, { uri: Yee, descriptors: { unicodeRange: "U+47d2-4879,U+2ce7c,U+2ce88,U+2ce93" } }, { uri: qee, descriptors: { unicodeRange: "U+4756-47d1,U+2ca02,U+2ca0e,U+2ca7d,U+2caa9,U+2cb29,U+2cb2e,U+2cb31,U+2cb38-2cb39,U+2cb3f,U+2cb41,U+2cb4e,U+2cb5a,U+2cb64,U+2cb69,U+2cb6c,U+2cb6f,U+2cb76,U+2cb78,U+2cb7c,U+2cbb1,U+2cbbf-2cbc0,U+2cbce,U+2cc5f,U+2ccf5-2ccf6,U+2ccfd,U+2ccff,U+2cd02-2cd03,U+2cd0a,U+2cd8b,U+2cd8d,U+2cd8f-2cd90,U+2cd9f-2cda0,U+2cda8,U+2cdad-2cdae,U+2cdd5,U+2ce18,U+2ce1a,U+2ce23,U+2ce26,U+2ce2a" } }, { uri: Zee, descriptors: { unicodeRange: "U+46c3-4755,U+2c488,U+2c494,U+2c497,U+2c542,U+2c613,U+2c618,U+2c621,U+2c629,U+2c62b-2c62d,U+2c62f,U+2c642,U+2c64a-2c64b,U+2c72c,U+2c72f,U+2c79f,U+2c7c1,U+2c7fd,U+2c8d9,U+2c8de,U+2c8e1,U+2c8f3,U+2c907,U+2c90a,U+2c91d" } }, { uri: Jee, descriptors: { unicodeRange: "U+4629-46c2,U+2bdf7,U+2be29,U+2c029-2c02a,U+2c0a9,U+2c0ca,U+2c1d5,U+2c1d9,U+2c1f9,U+2c27c,U+2c288,U+2c2a4,U+2c317,U+2c35b,U+2c361,U+2c364" } }, { uri: Qee, descriptors: { unicodeRange: "U+458e-4628,U+2b7a9,U+2b7c5,U+2b7e6,U+2b7f9,U+2b806,U+2b80a,U+2b81c,U+2b8b8,U+2bac7,U+2bb5f,U+2bb62,U+2bb7c,U+2bb83,U+2bc1b,U+2bd77,U+2bd87" } }, { uri: ete, descriptors: { unicodeRange: "U+4449-4511,U+2afa2,U+2b127-2b128,U+2b137-2b138,U+2b1ed" } }, { uri: tte, descriptors: { unicodeRange: "U+439b-4448,U+2a437,U+2a5f1,U+2a602,U+2a61a,U+2a6b2,U+2a7dd,U+2a8fb,U+2a917,U+2aa30,U+2aa36,U+2aa58" } }, { uri: nte, descriptors: { unicodeRange: "U+4275-430d,U+298c6,U+29a72,U+29d98,U+29ddb,U+29e15,U+29e3d,U+29e49" } }, { uri: rte, descriptors: { unicodeRange: "U+4132-41de,U+28bef,U+28c47,U+28c4f,U+28c51,U+28c54,U+28d10,U+28d71,U+28dfb,U+28e1f,U+28e36,U+28e89,U+28e99,U+28eeb,U+28f32,U+28ff8,U+292a0" } }, { uri: ite, descriptors: { unicodeRange: "U+41df-4274,U+292b1,U+29490,U+295cf,U+2967f,U+296f0,U+29719,U+29750" } }, { uri: ate, descriptors: { unicodeRange: "U+408e-4131,U+285c8-285c9,U+28678,U+28695,U+286d7,U+286fa,U+287e0,U+28946,U+28949,U+2896b,U+28987-28988,U+289ba-289bb,U+28a1e,U+28a29,U+28a43,U+28a71,U+28a99,U+28acd,U+28add,U+28ae4,U+28b49,U+28bc1" } }, { uri: lte, descriptors: { unicodeRange: "U+3e83-3f2f,U+27139,U+273da-273db,U+273fe,U+27410,U+27449,U+27614-27615,U+27631,U+27684,U+27693,U+2770e,U+27723,U+27752" } }, { uri: ste, descriptors: { unicodeRange: "U+3f30-3fdb,U+27985,U+27a84,U+27bb3,U+27bbe,U+27bc7,U+27cb8,U+27da0,U+27e10" } }, { uri: ote, descriptors: { unicodeRange: "U+3fdc-408d,U+27fb7,U+27ff9,U+2808a,U+280bb,U+2815d,U+28277,U+28282,U+282e2,U+282f3,U+283cd,U+28408,U+2840c,U+28455,U+28468,U+2856b" } }, { uri: cte, descriptors: { unicodeRange: "U+3dd2-3e82,U+26a58,U+26a8c,U+26ab7,U+26aff,U+26b5c,U+26c21,U+26c29,U+26c73,U+26cdd,U+26e40,U+26e65,U+26f94,U+26ff6-26ff8,U+270f4,U+2710d" } }, { uri: dte, descriptors: { unicodeRange: "U+3d34-3dd1,U+2648d,U+26676,U+2667e,U+266b0,U+2671d,U+2677c,U+267cc,U+268dd,U+268ea,U+26951,U+2696f,U+269dd,U+269fa,U+26a1e" } }, { uri: ute, descriptors: { unicodeRange: "U+3c76-3d33,U+25d0a,U+25da1,U+25e2e,U+25e56,U+25e62,U+25e65,U+25ec2,U+25ed7-25ed8,U+25ee8,U+25f23,U+25f5c,U+25fd4,U+25fe0,U+25ffb,U+2600c,U+26017,U+26060,U+260ed,U+26221,U+26270,U+26286,U+2634c,U+26402" } }, { uri: hte, descriptors: { unicodeRange: "U+3bda-3c75,U+25771,U+257a9,U+257b4,U+259c4,U+259d4,U+25ae3-25ae4,U+25af1,U+25bb2,U+25c14,U+25c4b,U+25c64" } }, { uri: fte, descriptors: { unicodeRange: "U+3b25-3bd9,U+2504a,U+25055,U+25122,U+2512b,U+251a9,U+251cd,U+251e5,U+2521e,U+2524c,U+2542e,U+2548e,U+254d9,U+2550e,U+25532,U+25562,U+255a7-255a8" } }, { uri: pte, descriptors: { unicodeRange: "U+3a6b-3b24,U+24896,U+249db,U+24a4d,U+24a7d,U+24ac9,U+24b56,U+24b6f,U+24c16,U+24d14,U+24dea,U+24e0e,U+24e37,U+24e6a,U+24e8b,U+24eaa" } }, { uri: mte, descriptors: { unicodeRange: "U+39a9-3a6a,U+24096,U+24103,U+241ac,U+241c6,U+241fe,U+243bc,U+243f8,U+244d3,U+24629,U+246a5,U+247f1" } }, { uri: gte, descriptors: { unicodeRange: "U+38e3-39a8,U+23a98,U+23c7f,U+23c97-23c98,U+23cfe,U+23d00,U+23d0e,U+23d40,U+23dd3,U+23df9-23dfa,U+23e23,U+23f7e" } }, { uri: bte, descriptors: { unicodeRange: "U+3760-382a,U+22ab8,U+22b43,U+22b46,U+22b4f-22b50,U+22ba6,U+22bca,U+22c1d,U+22c24,U+22c55,U+22d4c,U+22de1" } }, { uri: Ute, descriptors: { unicodeRange: "U+382b-38e2,U+231b6,U+231c3-231c4,U+231f5,U+23350,U+23372,U+233d0,U+233d2-233d3,U+233d5,U+233da,U+233df,U+233e4,U+2344a-2344b,U+23451,U+23465,U+234e4,U+2355a,U+23594,U+235c4,U+235cb,U+23638-2363a,U+23647,U+2370c,U+2371c,U+2373f,U+23763-23764,U+237e7,U+237ff,U+23824,U+2383d" } }, { uri: vte, descriptors: { unicodeRange: "U+3698-375f,U+22218,U+2231e,U+223ad,U+224dc,U+226f3,U+2285b,U+228ab,U+2298f" } }, { uri: yte, descriptors: { unicodeRange: "U+35e6-3697,U+21c56,U+21cde,U+21d2d,U+21d45,U+21d62,U+21d78,U+21d92,U+21d9c,U+21da1,U+21db7,U+21de0,U+21e33-21e34,U+21f1e,U+21f76,U+21ffa,U+2217b" } }, { uri: wte, descriptors: { unicodeRange: "U+3444-350e,U+20ad3,U+20b1d,U+20b9f,U+20c41,U+20cbf,U+20cd0,U+20d45,U+20de1,U+20e64,U+20e6d,U+20e95,U+20e9d,U+20ea2,U+20f5f,U+210c1,U+21201,U+2123d,U+21255,U+21274,U+2127b" } }, { uri: xte, descriptors: { unicodeRange: "U+350f-35e5,U+212d7,U+212e4,U+212fd,U+2131b,U+21336,U+21344,U+2139a,U+213c4,U+21413,U+2146d-2146e,U+215d7,U+21647,U+216b4,U+21706,U+21742,U+218bd,U+219c3" } }, { uri: Ete, descriptors: { unicodeRange: "U+336d-3443,U+2032b,U+20371,U+20381,U+203f9,U+2044a,U+20509,U+20547,U+205d6,U+20628,U+20676,U+2074f,U+20779,U+20807,U+2083a,U+20895,U+208b9,U+2097c,U+2099d" } }, { uri: Ste, descriptors: { unicodeRange: "U+328b-336c,U+2000b,U+20089,U+200a2,U+200a4,U+20164,U+201a2,U+20213" } }, { uri: _te, descriptors: { unicodeRange: "U+3192-31ba,U+31c0-31e3,U+31f0-321e,U+3220-328a,U+1f250-1f251" } }, { uri: kte, descriptors: { unicodeRange: "U+2f74-2fd5,U+3000,U+3003-3007,U+3012-3013,U+3018-301c,U+3020-3029,U+302f-303f,U+3041-3096,U+3099-30a1" } }, { uri: Cte, descriptors: { unicodeRange: "U+30a2-30ff,U+3105-312f,U+3131-318e,U+3190-3191" } }, { uri: Mte, descriptors: { unicodeRange: "U+4e36,U+4ea0,U+4f74,U+4f91,U+4f94,U+4fc5,U+507e,U+50ed,U+5182,U+51f5,U+525e,U+5282,U+52f9,U+5326,U+537a,U+53a3,U+5423,U+5459,U+54b4,U+54d9,U+55c9,U+57f4,U+580b,U+5902,U+5925,U+5a08,U+5ab5,U+5b84,U+5be4,U+5c22,U+5cb5,U+5cbd,U+5d3e,U+5e31,U+5e5e,U+5e80,U+5ee8,U+5f82,U+5fc9,U+5fed,U+600a,U+605d,U+609b,U+609d,U+60dd,U+6243,U+6322,U+63ce,U+640c,U+643f,U+6445,U+64d7,U+6534,U+6549,U+656b,U+6603,U+674c,U+680a,U+6864,U+69d4,U+6a65,U+6c2a,U+6c46,U+6c5c,U+6d0e,U+6d48,U+6e2b,U+6eb2,U+6eb7,U+6f89,U+706c,U+70b1,U+7113,U+71d4,U+727f,U+72f3,U+7303,U+7321,U+736c,U+736f,U+74a9,U+74de,U+750d,U+7513,U+7592,U+75c4,U+7605,U+760a,U+761b,U+7625,U+762d,U+7643,U+7707,U+7747,U+77b5,U+7839,U+784e,U+78a5,U+7924,U+793b,U+798a,U+7a03,U+7a06,U+7a78,U+7a80,U+7aad,U+7ba8,U+7be5,U+7cc8,U+7ec1,U+7f0b,U+7f0f,U+7f12,U+7f68,U+7f9d,U+8025,U+809c,U+80ad,U+80b7,U+80e8,U+811e,U+8204,U+8223,U+822d,U+823b,U+824b,U+825a,U+827d,U+827f,U+828f,U+82c8,U+8307,U+831b,U+8347,U+837d,U+839b,U+83a9,U+83f9,U+84b9,U+8579,U+864d,U+867f,U+86b0,U+86d1,U+86d8,U+86f2,U+8764,U+8770,U+8788,U+8797,U+87ac-87ad,U+87b5,U+881b,U+8844,U+88bc,U+88fc,U+8930,U+89cf,U+89d6,U+8ba0,U+8bd4,U+8c02,U+8c2b,U+8c85,U+8e23,U+8f81-8f82,U+8fd5,U+90b6,U+90db,U+914e,U+9164,U+91ad,U+943e,U+94b7-94b8,U+94eb,U+950d,U+9514,U+9516,U+9518,U+9529,U+9538,U+953f,U+954e,U+955f,U+95fc,U+9667,U+96b3,U+9792,U+97b2,U+98a1,U+9969,U+9987,U+9998,U+9a80,U+9a92,U+9a96,U+9adf,U+9cb4,U+9cbd,U+9cd0,U+9cd4,U+9e31,U+9e3a,U+9e71,U+9ee5,U+9eea,U+9ef9,U+9fa0" } }, { uri: Tte, descriptors: { unicodeRange: "U+4e0c,U+4e28,U+4e3f,U+4ec2,U+502e,U+50ba,U+5155,U+5181,U+522d,U+5281,U+5290,U+5369,U+53b6,U+54d5,U+54dc,U+54ff,U+552a,U+553c,U+5588,U+55b5,U+5686,U+570a,U+5776,U+5786,U+57a4,U+5820,U+5865,U+58bc,U+5b32,U+5b65,U+5c1c,U+5c66,U+5c6e,U+5c8d,U+5ddb,U+5f2a,U+5f50,U+5f61,U+6067,U+614a,U+615d,U+619d,U+61d4,U+620b,U+6224-6225,U+6343,U+63ad,U+63f2,U+640b,U+6420,U+6434,U+6496,U+64d0,U+6509,U+652e,U+67a8,U+6833,U+6844,U+684a,U+6920,U+6957,U+6971,U+6a8e,U+6a91,U+6aa0,U+6b43,U+6bea,U+6bf5,U+6c15,U+6cd0,U+6ee0,U+6f24,U+6f2d,U+70c0,U+721d,U+728b,U+72c3,U+72e8,U+730a,U+7338-7339,U+734d,U+746d,U+752f,U+754e,U+770d,U+7735,U+778d,U+77a2,U+77e7,U+7857,U+786d,U+78c9,U+78f2,U+791e,U+7953,U+7b58,U+7b9d,U+7bda,U+7cd7,U+7f32-7f33,U+8022,U+8028-8029,U+8035,U+804d,U+8080,U+80c2,U+80e9,U+80ec,U+80f2,U+810e,U+8221,U+8274,U+82b0,U+82e0,U+83b0,U+8487-8488,U+848e,U+84cd,U+84d0,U+8539,U+857a,U+85a8,U+85b7,U+867c,U+871e,U+8723,U+877e,U+878b,U+8793,U+8803,U+88d2,U+8966,U+89cc,U+89eb,U+8b26,U+8c8a,U+8c98,U+8d33,U+8d47,U+8d55,U+8dbc,U+8e40,U+8e94,U+8f77,U+8f79,U+9058,U+91a2,U+91b5,U+928e,U+9494,U+94b6,U+94de,U+94f4,U+94f9,U+950a,U+950e,U+951e,U+952b,U+953c,U+953e,U+9544,U+9561,U+9564,U+9569,U+95f6,U+9603,U+960d,U+963d,U+9674,U+9794,U+97ab,U+98a5,U+9a9f,U+9ab1,U+9ad1,U+9b0f,U+9b2f,U+9c92,U+9c95,U+9cba,U+9cbc,U+9cc6,U+9ccb,U+9cd8,U+9e32,U+9e38,U+9e5b,U+9e7e,U+9eb4,U+9efb-9efc,U+9f3d" } }, { uri: Ite, descriptors: { unicodeRange: "U+2e3b,U+2e80-2e99,U+2e9b-2ef3,U+2f00-2f73,U+ffffd" } }, { uri: Ate, descriptors: { unicodeRange: "U+4e69,U+4f1b,U+4f67,U+4f7e,U+4fdc,U+50e6,U+5196,U+5202,U+5233,U+523f,U+52a2,U+536e,U+5476,U+54ad,U+54cf,U+5537,U+561e,U+56dd,U+56df,U+5709,U+572c,U+57cf,U+57f8,U+580d,U+5881,U+589a,U+5941,U+59b2,U+5c25,U+5d24,U+5d74,U+5e42,U+5e8b,U+5eb3,U+5ed2,U+5fad,U+6003,U+603c,U+6083,U+6100,U+6126,U+6206,U+62ca,U+638e,U+63b4,U+6426,U+646d,U+6535,U+65c4,U+66db,U+6715,U+6769,U+6798,U+67c3,U+6861,U+698d,U+69ca,U+69ed,U+69f2,U+69ff,U+6a18,U+6b39,U+6bb3,U+6c0d,U+6cb2,U+6cd6,U+6cf7,U+6cfa,U+6d33,U+6e16,U+6e53-6e54,U+6ebb,U+6fb6,U+709d,U+72ad,U+72f7,U+72fb,U+7313,U+739f,U+74ba,U+754b,U+755b,U+758b,U+75ac,U+75d6,U+7617,U+7635,U+7640,U+76a4,U+76b2,U+775a,U+77bd,U+781f,U+79b3,U+7b2b,U+7b31,U+7b3e,U+7b6e,U+7b9c,U+7c0b,U+7c9e,U+7cc1,U+7ce8,U+7ea5,U+7f21,U+7f27,U+7f74,U+7fb0,U+8031,U+8071,U+80ea,U+8114,U+8160,U+81a6,U+81c1,U+829f,U+82a4,U+82fb,U+831a,U+8333,U+836c,U+83b6,U+83f8,U+8411,U+841c,U+8489,U+848c,U+85a4,U+8627,U+8629,U+866e,U+86b5,U+872e,U+8731,U+877b,U+877d,U+87ea,U+8813,U+8816,U+8864,U+88ce,U+88e5,U+897b,U+89cb,U+89f3,U+8bfc,U+8c35,U+8d46,U+8d4d,U+8dba,U+8e3a,U+8f75,U+8f7e,U+8fd3,U+9161,U+9179,U+917e,U+91a3,U+94ac,U+94d7,U+94e5,U+952a,U+952c,U+9545,U+9565,U+9568,U+956a,U+961d,U+96e0,U+972a,U+9730,U+989f,U+98e7,U+990d,U+9967,U+9993,U+9aa3,U+9ac0,U+9ae1,U+9aeb,U+9af9,U+9c86,U+9c8b,U+9ca0-9ca1,U+9ca3,U+9ce2,U+9e48,U+9e6a,U+9e87,U+9ee2,U+9ee9,U+9f17,U+9f19,U+9f2c,U+9f80" } }, { uri: Nte, descriptors: { unicodeRange: "U+4ef3,U+50d6,U+50ec,U+51ab,U+51b1,U+52d6,U+54a9,U+54da,U+55be,U+55cd,U+564d,U+572f,U+574c,U+576b,U+57d8,U+57fd,U+5844,U+59d2,U+5ae0,U+5b16,U+5b37,U+5b5b,U+5b80,U+5d1e,U+5d6b,U+5efe,U+5f11,U+5f56,U+5f58,U+5f73,U+5f8c,U+5fc4,U+5fe4,U+602b,U+6106,U+610d,U+63de,U+63f8,U+641b,U+64e4,U+6634,U+676a,U+67b5,U+681d,U+6883,U+69b1,U+69e0,U+6b37,U+6b9b,U+6d7c,U+6ed7,U+6f36,U+6f72,U+6f8c,U+7035,U+7039,U+7173,U+7178,U+7228,U+728f,U+72b4,U+72ef,U+72f4,U+7331,U+7481,U+74e0,U+7540,U+75c3,U+75e6,U+763c,U+764d,U+76cd,U+7704,U+7743,U+7780,U+7847,U+786a,U+78b9,U+7962,U+7a02,U+7aac,U+7ab3,U+7b0a,U+7b4c,U+7b7b,U+7bfc,U+7c0f,U+7c16,U+7c40,U+7ca2,U+7cc7,U+7cf8,U+7d77,U+7e3b,U+7ea1,U+7ea9,U+7ef2,U+7f02,U+7f07,U+7f0c,U+7f23,U+7f2f,U+7fbc,U+8016,U+8020,U+812c,U+8136,U+8182,U+822f,U+8233,U+825f,U+8268,U+8284,U+8288,U+8291,U+8308,U+8311,U+835b,U+836d,U+83dd,U+8406,U+840f,U+845c,U+84b4,U+84e3,U+850c,U+855e,U+863c,U+86ba,U+86c4,U+86de,U+86f1,U+873e,U+87bd,U+87db,U+880a,U+883c,U+887f,U+88f0,U+890a,U+892b,U+895e,U+89ef,U+8a48,U+8bdc,U+8c18,U+8c33,U+8c94,U+8db1,U+8dcf,U+8dd6,U+8de3,U+8e6f,U+8e90,U+8f7a,U+8fb6,U+902d,U+90be,U+91af,U+936a,U+948b,U+94d8,U+9513,U+953a,U+956c,U+963c,U+9654,U+966c,U+9688,U+97b4,U+996b,U+9a75,U+9a7a,U+9aba,U+9aed,U+9b08,U+9b43,U+9c8e,U+9c94,U+9c9a,U+9e2b,U+9e36,U+9e4b,U+9e4e,U+9e55,U+9e63,U+9e68-9e69,U+9ebd,U+9ec9,U+9f0d,U+9f37,U+9f51" } }, { uri: Dte, descriptors: { unicodeRange: "U+50a7,U+5240,U+5261,U+52ac,U+531a,U+5363,U+5432,U+5452,U+5456,U+5472,U+5478,U+553f,U+5575,U+5581,U+55cc,U+55fe,U+5601,U+572e,U+57d2,U+57ef,U+581e,U+5924,U+5981,U+5997,U+59a3,U+5aaa,U+5ab8,U+5b34,U+5d5d,U+5def,U+5e11,U+5e91,U+5ed1,U+5ef4,U+5f40,U+600d,U+6019,U+601b,U+605a,U+6092,U+60ab,U+6217,U+623d,U+6369,U+65d2,U+6661,U+670a,U+6753,U+67a7,U+6855,U+68f9,U+6939,U+696e,U+6980,U+6a7c,U+6aab,U+6b82,U+6bf3,U+6bf9,U+6c05,U+6c19-6c1a,U+6ca9,U+6cf6,U+6d1a,U+6dab,U+6f74,U+7085,U+7198,U+71b5,U+7256,U+725d,U+727e,U+72fa,U+7322,U+738e,U+73e5,U+750f,U+755a,U+7594,U+75b3,U+760c,U+7615,U+7630,U+763f,U+77ec,U+7817,U+78a1,U+78d9,U+7905,U+7b2a,U+7b2e,U+7b62,U+7b85,U+7bcc,U+7bea,U+7c26,U+7c74,U+7c9c-7c9d,U+7e47,U+7e9b,U+7e9f,U+7ee0,U+7ee8,U+7ef1,U+7f01,U+7f11,U+7f17,U+7f36,U+7f7e,U+7fee,U+802a,U+80cd,U+8112,U+8169,U+8234,U+8279,U+8298,U+82ca,U+82d8,U+82e1,U+83c0,U+83d4,U+83df,U+8401,U+8451,U+845a,U+8476,U+8478,U+84ba,U+84bd,U+84e0,U+851f,U+8548,U+8556,U+8585,U+868d,U+86e9,U+86f4,U+86f8,U+8765,U+8785,U+87ab,U+87ee,U+8832,U+8872,U+88b7,U+88e2-88e3,U+89da,U+8bce,U+8bd3,U+8bd6,U+8bf9,U+8c16,U+8c73,U+8d5c,U+8dde,U+8f6d,U+8f94,U+8fe8,U+9011,U+915e,U+9185,U+918c,U+94ab,U+94d1,U+94f3,U+9515,U+951d,U+9558,U+9567,U+96ce,U+96e9,U+9785,U+9878,U+987c,U+9883,U+98d1,U+9954,U+9963,U+9a93,U+9ac1,U+9acc,U+9b1f,U+9b49,U+9b4d,U+9b51,U+9ca7,U+9cae,U+9cce,U+9cd3,U+9e37,U+9e39,U+9e41,U+9e46,U+9f22,U+9f2f,U+9f39,U+9f85" } }, { uri: Lte, descriptors: { unicodeRange: "U+4e5c,U+4edf,U+4f25,U+4f32,U+4f5e,U+4f76,U+4faa,U+4fe6,U+5028,U+5048,U+5250,U+535f,U+538d,U+53c1,U+5412,U+5443,U+54d4,U+54dd,U+5541,U+5550,U+5577,U+55dd,U+55f3,U+560f,U+562c,U+5657-5658,U+5664,U+56af,U+575c,U+577c,U+57b2,U+57da,U+5800,U+5a62,U+5aeb,U+5c3b,U+5ca3,U+5d26,U+5d9d,U+5f01,U+5fb5,U+5fdd,U+5ff8,U+6029,U+6041,U+6079,U+60b1,U+6222,U+629f,U+6332,U+63bc,U+63e0,U+6485,U+65ab,U+65c3,U+65c6,U+668c,U+669d,U+66be,U+67fd,U+6800,U+68fc,U+690b,U+6924,U+6978,U+69a7,U+6a3e,U+6a50,U+6a5b,U+6a97,U+6b24,U+6b8d,U+6baa,U+6c10,U+6c54,U+6ceb,U+6d04,U+6d4d,U+6eb1,U+6ebd,U+7110,U+71b3,U+71f9,U+7230,U+728d,U+7292,U+72b8,U+72d2,U+7360,U+73a2,U+7511,U+75a0,U+75c8,U+779f,U+7826,U+7877,U+7a39,U+7aa8,U+7ae6,U+7b04,U+7b0f,U+7baa,U+7bac,U+7c1f,U+7ccd,U+7ecb,U+7ed4,U+7ed7,U+7efb,U+7f0d,U+7f5f,U+7faf,U+7fd5,U+7fe5,U+8027,U+80bc,U+80dd,U+80fc,U+8132,U+815a,U+8167,U+816d,U+81ca,U+8228,U+82a1,U+82a9,U+82ab,U+82cc,U+8351,U+8368,U+83b8,U+83d8,U+83ea,U+83f0,U+8497,U+84c1,U+858f,U+85ff,U+867b,U+86a8-86a9,U+870a,U+8722,U+876e,U+877c,U+87e5,U+8888,U+88df,U+8919,U+8bcc,U+8bdf,U+8be8,U+8bee,U+8c20,U+8c2f,U+8d36,U+8df8,U+8e05,U+8e2f,U+8f9a,U+9021,U+908b,U+90b4,U+90ba,U+90d0,U+90eb,U+90fe,U+91aa,U+933e,U+9486-9487,U+948d,U+9490,U+94ad,U+94bd,U+94d6,U+94d9,U+9507,U+9546,U+955e,U+956b,U+95e9,U+9604,U+960b,U+9612,U+9615,U+9617,U+96b9,U+989a-989b,U+989e,U+9a78,U+9a7d,U+9aa0,U+9aa2,U+9ac2,U+9b23,U+9b3b,U+9c82,U+9cca,U+9cd9,U+9e28,U+9e5a,U+9e5e,U+9e6c,U+9efe,U+9f0b" } }, { uri: Rte, descriptors: { unicodeRange: "U+4e47,U+4e8d,U+4f65,U+4f89,U+50ee,U+520e,U+5416,U+5454,U+54bb,U+54c2,U+54d3,U+54de,U+5591,U+55e5,U+560c,U+566b,U+5769,U+578c,U+5793,U+57e4,U+5889,U+593c,U+59ab,U+5ad4,U+5ad8,U+5af1,U+5b53,U+5ba5,U+5c59,U+5c63,U+5d5b,U+5e0f,U+5e14,U+5edb,U+5fbc,U+6004,U+60ad,U+610e,U+61b7,U+624c,U+634c,U+647a,U+64ba,U+65f0,U+6600,U+66f7,U+67e2,U+67f0,U+680c,U+686b,U+6874,U+691f,U+6989,U+6a17,U+6b81,U+6b84,U+6c06-6c07,U+6c3d,U+6d07,U+6d27,U+6d2b,U+6d91,U+6e6b,U+6e8f,U+6fde,U+70bb,U+723b,U+726e,U+72b0,U+72ce,U+72f2,U+7301,U+731e,U+737e,U+7477,U+748e,U+74ff,U+7633,U+7654,U+771a,U+7726,U+7765,U+7768,U+781c,U+7829,U+78d4,U+7913,U+7957,U+79d5,U+79eb,U+7a70,U+7a86,U+7b25,U+7b38,U+7b47,U+7b72,U+7ba6-7ba7,U+7dae,U+7ee1,U+7efe,U+7f26,U+7f31,U+7f35,U+801c,U+8043,U+809f,U+80ab,U+80d7,U+8118,U+8188,U+81cc,U+823e,U+8244,U+824f,U+82b4,U+82c1,U+82e4,U+82f4,U+8306,U+833a,U+835c,U+839c,U+83b3,U+83bc,U+846d,U+867a,U+868b,U+8734,U+87ca,U+886e,U+887e,U+88a2,U+88c9,U+8921,U+8bb5,U+8bf3,U+8c04,U+8c17,U+8c1d,U+8c25,U+8c36,U+8c55,U+8c78,U+8d3d,U+8d40,U+8d59,U+8d67,U+8d91,U+8dbf,U+8deb-8dec,U+8dfd,U+8e14,U+8e41,U+8f8e,U+900b,U+9044,U+9062,U+90cf,U+9123,U+9146,U+9162,U+9172,U+918d,U+9190,U+92c8,U+93ca,U+948c,U+94aa,U+94b2,U+94c8,U+94ca,U+94d5,U+94df,U+94e9-94ea,U+94f7,U+94fc-94fd,U+951b,U+954f,U+9554,U+9559,U+9566,U+9571-9572,U+95f1,U+9608,U+960f,U+97af,U+988f,U+98d5,U+992e,U+9955,U+9ab0,U+9b32,U+9c90,U+9c9e,U+9ca5,U+9ca9,U+9cad,U+9cb1,U+9cc3,U+9e47,U+9ee7,U+9f87" } }, { uri: Pte, descriptors: { unicodeRange: "U+4e93,U+4ec4,U+4ef5,U+4f27,U+4f7b,U+4fe3,U+5080,U+5121,U+51eb,U+5208,U+52f0,U+53f5,U+5453,U+5466,U+54a6,U+54bf,U+54d0,U+5533,U+5549,U+5556,U+556d,U+558f,U+55f2,U+55f5,U+5627,U+567b,U+56d4,U+571c,U+5739,U+57b4,U+5807,U+58c5,U+59a4,U+59af,U+59d8,U+5a09,U+5a0c,U+5a4a,U+5ad2,U+5b6c,U+5ca2,U+5cac,U+5d03,U+5d6c,U+5db7,U+5ebe,U+5f2d,U+5fea,U+6042,U+6120,U+6175,U+6221,U+623e,U+6339,U+638a,U+643d,U+64b8,U+64e2,U+66e9,U+67b3,U+67c1,U+67d2,U+6832,U+6877,U+68f0,U+6934,U+6966,U+6987,U+6998,U+69c1,U+69ce,U+6a3d,U+6a84,U+6aa9,U+6b87,U+6bd6,U+6c16,U+6c18,U+6cd4,U+6cee,U+6de0,U+6e0c,U+6ecf,U+6f4b,U+70b7,U+7168,U+72d9,U+7352,U+73b3,U+73d0,U+7441,U+74d2,U+75a5,U+75e7-75e8,U+7610,U+7619,U+765e,U+772d,U+7812,U+782c,U+784c,U+7850,U+7856,U+789b,U+78f4,U+7a51,U+7b15,U+7b1e,U+7b24,U+7b5a,U+7bb8,U+7bc1,U+7bd9,U+7ed0,U+7ee6,U+7efa,U+7f1b,U+7f1f,U+7f22,U+7f45,U+7f71,U+7fa7,U+7fbf,U+7ff3,U+8052,U+80b1,U+80db,U+80f4,U+81bb,U+81ec,U+8202,U+8210,U+8249,U+828a,U+828e,U+82e3,U+8315,U+8369,U+8378,U+83a8,U+83aa,U+83b4,U+83e1,U+84fc,U+8538,U+853b,U+859c,U+85ae,U+86b4,U+86c9,U+86cf,U+8725,U+879f,U+87b3,U+887d,U+88fe,U+8a8a,U+8ba7,U+8c07,U+8c14,U+8c30,U+8c47,U+8db5,U+8dd7,U+8e1f,U+8e69,U+8e70,U+8e85,U+8f78,U+8f87,U+8f8b,U+8f8f,U+90c4,U+9143,U+917d,U+948f,U+94cd,U+94d2,U+94ef,U+954a,U+9609-960a,U+96d2,U+9708,U+9765,U+97ea,U+9880,U+98a7,U+996c,U+9980,U+9991,U+9a88,U+9ab6,U+9afb,U+9b47,U+9c87,U+9c9b,U+9cb5,U+9cc7,U+9e2c,U+9e42,U+9e58,U+9ecd,U+9ecf,U+9f8a,U+9f8c" } }, { uri: Ote, descriptors: { unicodeRange: "U+4ebb,U+4edd,U+4fa9,U+502c,U+50a5,U+51c7,U+51fc,U+523d,U+5241,U+530f,U+5464,U+549d,U+54a3,U+5514,U+5527,U+555c,U+556e,U+5576,U+55b1,U+55b9,U+55eb,U+5624,U+564c,U+5671,U+5685,U+568f,U+56d7,U+56e1,U+57a1,U+57d9,U+5942,U+5a67,U+5c50,U+5c7a,U+5c98,U+5d06,U+5d27,U+5d6f,U+5df3,U+5dfd,U+5e19,U+5ea0,U+5eb9,U+5eea,U+5ffe,U+600f,U+606b,U+6215,U+622c,U+6266,U+62bb,U+62bf,U+6308,U+6387,U+63b8,U+63c4,U+63c6,U+63f6,U+6441,U+6555,U+659b,U+6677,U+66a7,U+6775,U+678b,U+679e,U+6840,U+6849,U+6860,U+68c2,U+6910,U+6a28,U+6a2f,U+6a79,U+6b92-6b93,U+6bc2,U+6bfd,U+6c29,U+6c32,U+6c86,U+6cc5,U+6d0c,U+6d60,U+6da0,U+6ddd,U+6e86,U+6ed3,U+6edf,U+6fb9,U+6fd1,U+6fef,U+7023,U+7080,U+70ca,U+712f,U+7145,U+7284,U+732c,U+73c8,U+73d9,U+740a,U+7457,U+7596,U+759d,U+75a3,U+75d8,U+75e3-75e4,U+75ff,U+7622,U+7688,U+76b4,U+76e5,U+7818,U+7887,U+789a,U+78b2,U+7b08,U+7b33,U+7c2a,U+7ccc,U+7ea8,U+7ec0,U+7fe6,U+8012,U+8084,U+8093,U+80e4,U+80ef,U+8297,U+82a8,U+82be,U+8331,U+8366,U+83c5,U+83fd,U+8473,U+84a1,U+84ca,U+84d1,U+857b,U+85c1,U+85d3,U+8605,U+8662,U+86aa,U+86b1,U+86d4,U+86ed,U+86f3,U+8709,U+8748,U+874c,U+8763,U+89c7,U+89de,U+89e5,U+8a3e,U+8ba6,U+8c00,U+8c21,U+8c49,U+8c7a,U+8d30,U+8df9,U+8e51,U+8e59,U+8f6b,U+8f73,U+8ff3,U+9016,U+9026,U+902f,U+9099,U+909b,U+90c7,U+914a,U+91ae,U+91ba,U+9495,U+94a3,U+94af,U+94ba,U+94bf,U+94cc,U+94e1,U+94f0,U+9531,U+955d,U+95f3,U+9697,U+96bc,U+975b,U+977c,U+98a2,U+998a,U+9994-9995,U+9a9b,U+9ab7,U+9ac5,U+9c91,U+9ccf,U+9cd5,U+9e29,U+9edc,U+9edf,U+9f83,U+9f88-9f89" } }, { uri: $te, descriptors: { unicodeRange: "U+4ee8,U+4f22,U+4f43,U+4f57,U+4f5d,U+4f6f,U+4ff8,U+502d,U+507b,U+5345,U+53df,U+53fb,U+544b,U+5482,U+54a7,U+54cc,U+550f,U+5544,U+5555,U+5594,U+55e8,U+55ec,U+55ef,U+564e,U+56f9,U+5704,U+576d,U+5785,U+57ad,U+5914,U+5958,U+599e,U+59aa,U+59be,U+5a06,U+5abe,U+5ae1,U+5b40,U+5bee,U+5cbf,U+5cc4,U+5ccb,U+5d47,U+603f,U+6078,U+607d,U+607f,U+608c,U+609a,U+60fa,U+61ff,U+621b,U+622e,U+626a,U+6371,U+63ae,U+63cd,U+63d6,U+6410,U+6414,U+6421,U+6448,U+64d8,U+6710,U+6748,U+6772,U+680e,U+6954,U+69ab,U+6c68,U+6c8f,U+6ca4,U+6d2e,U+6e4e,U+6e98,U+6fe0,U+7094,U+70e9,U+7116,U+7119,U+723f,U+73c9,U+74e4,U+753e,U+7548,U+75bd,U+75cd,U+7618,U+7634,U+76c5,U+76f1,U+7708,U+7719,U+777e,U+7791,U+77b3,U+7823,U+7827,U+7830,U+7889,U+7893,U+7949,U+795c,U+79e3,U+7a14,U+7a88,U+7a95,U+7aa0,U+7afd,U+7b90,U+7bd1,U+7bfe,U+7da6,U+7ec2,U+7eef,U+7f03-7f04,U+7f08,U+7f58,U+7f61,U+7f9f,U+8174,U+8200,U+828d,U+82c4,U+82d5,U+82dc,U+82f7,U+832d,U+835a,U+840b,U+8438,U+852b,U+869d,U+86ac,U+86d0,U+86f0,U+8782,U+87a8,U+87d1-87d2,U+87e0,U+8839,U+8913,U+891b,U+8934,U+8941,U+89ca,U+89ce,U+8a07,U+8ba3,U+8bc5,U+8bcb,U+8bdb,U+8c11,U+8c15,U+8c29,U+8c32,U+8dc4,U+8dce,U+8ddb,U+8dfa,U+8e09,U+8e1d,U+8e39,U+8e42,U+8e49,U+8e4b,U+8e8f,U+8f71-8f72,U+9004,U+9036,U+9097,U+90dc,U+90e2,U+90e6,U+90ef,U+9104,U+919a,U+91b4,U+938f,U+9497,U+950f,U+9557,U+9562-9563,U+9573,U+9606,U+9649,U+972d,U+973e,U+97a3,U+97eb,U+988c,U+9894,U+98a6,U+9974,U+9977,U+997d,U+9a90,U+9a9d,U+9aef,U+9ca2,U+9ccd,U+9cdf,U+9e20,U+9e4c,U+9e6b,U+9f3e" } }, { uri: Fte, descriptors: { unicodeRange: "U+4ede,U+4ee1,U+4eeb,U+4fda,U+4ffe,U+5025,U+506c,U+50f3,U+5106,U+520d,U+525c,U+52ad,U+530d,U+5310,U+539d,U+53a9,U+53fc,U+5421,U+5477,U+54e7,U+551b,U+5530,U+557e,U+5599,U+55c4,U+55d1,U+55d4,U+55df,U+55e4,U+55ea,U+5623,U+562d,U+5654,U+56eb,U+56f5,U+57a7,U+57d5,U+57dd,U+584d,U+5880,U+58ec,U+59dd,U+5a32,U+5a55,U+5a75,U+5b51,U+5b71,U+5b73,U+5cd2,U+5ce4,U+5e5b,U+5e96,U+5fd2,U+607b,U+61d1,U+634b,U+636d,U+63b3,U+63ff,U+64c0,U+661d,U+6657,U+66dc,U+67a5,U+6841,U+6867,U+6901,U+699b,U+6a47,U+6b46,U+6c21,U+6c24,U+6c35,U+6c4a,U+6c94,U+6ca3,U+6d39,U+6d63,U+6d6f,U+6d94,U+705e,U+71e7,U+726f,U+72cd,U+72de,U+72f0,U+7325,U+7350,U+7391,U+741a,U+757f,U+7583,U+75b1,U+75b4,U+75b8,U+75c2,U+75f1,U+766f,U+7699,U+7751,U+789c,U+7a17,U+7be6,U+7cb2,U+7ea3,U+7eb0,U+7ebe,U+7eeb,U+7f25,U+7f2c,U+7fb8,U+8026,U+8037,U+8153,U+8171,U+8191,U+8214,U+821b,U+8222,U+826e,U+82eb,U+830c,U+8314,U+8334,U+83d6,U+8418,U+843c,U+84ff,U+8564,U+8572,U+8616,U+866c,U+8693,U+86a3,U+86a7,U+86af,U+86b6,U+86c6,U+86ca,U+8708,U+870d,U+8759,U+8760,U+87af,U+87c6,U+8869,U+88c6,U+89d0,U+8b07,U+8baa-8bab,U+8bc2,U+8be4,U+8bf0,U+8c2a,U+8c62,U+8c89,U+8d49,U+8d6d,U+8d84,U+8d94,U+8db8,U+8dc6,U+8e2e,U+8e3d,U+8e47,U+8e7f,U+9005,U+9051,U+907d,U+9082,U+9088,U+90b0,U+90d3,U+9150,U+949c,U+94a4,U+94b9,U+94cb,U+94e0,U+9509,U+9512,U+951f,U+9534,U+9552-9553,U+965f,U+96b0,U+9791,U+9889,U+9990,U+9a9c,U+9aa7,U+9c88,U+9cb2-9cb3,U+9cb6-9cb7,U+9cc5,U+9cdc,U+9e22,U+9e2a,U+9e57,U+9e67,U+9e73,U+9e82,U+9eb8,U+9ee0,U+9f9b" } }, { uri: zte, descriptors: { unicodeRange: "U+4eb5,U+4f09,U+4f5a,U+4f8f,U+4fce,U+4fdf,U+4fea,U+4ff3,U+500c,U+500f,U+504e,U+5088,U+52be,U+5420,U+5457,U+5499,U+549b,U+54c6,U+54d2,U+558b,U+559f,U+55bd,U+55d6,U+565c,U+567c,U+568e,U+5768,U+577b,U+57a9,U+57ed,U+59f9,U+5a11,U+5a40,U+5ae6,U+5b6a,U+5b93,U+5bb8,U+5c15,U+5c99,U+5c9c,U+5cc1,U+5d2e,U+5d4b,U+5d99,U+5e54,U+5e61,U+5fcf-5fd1,U+6002,U+6006,U+6014,U+60af,U+60c6,U+60da,U+60f4,U+621f,U+62c8,U+631b,U+631e,U+63e9,U+64b5,U+655d,U+6619,U+6635,U+6641,U+67ad,U+67b0,U+67b7,U+67e9,U+684e,U+688f,U+695d,U+696b,U+69b7,U+6a58,U+6c26,U+6d35,U+6d43,U+6d9e,U+6dd9,U+6dec,U+6e11,U+6e6e,U+6e9f,U+6ec2,U+6ee2,U+6ef9,U+6f09,U+6f66,U+6f8d,U+6fc2,U+6fc9,U+729f,U+72c8,U+73de,U+7430,U+7566,U+7579,U+75c9,U+75e2,U+75fc,U+762a,U+7638,U+7678,U+76c2,U+76f9,U+778c,U+77cd,U+77dc,U+7800,U+781d,U+782d,U+783b-783c,U+78a3,U+78ec,U+7980,U+7a23,U+7b95,U+7bdd,U+7c0c,U+7c41,U+7c91,U+7cb3,U+7cc5,U+7ecc,U+7f19,U+7fca,U+8006,U+8069,U+807f,U+80bd,U+80ed,U+814b,U+8198,U+82cb,U+82d2,U+834f,U+8360,U+847a,U+84d6,U+84e5,U+8537,U+85d0,U+8671,U+86a4,U+86ce,U+86f9,U+8703,U+8707,U+8737,U+873b,U+8815,U+8936,U+8bc3,U+8bcf,U+8bd2,U+8bd8,U+8be9,U+8c0c,U+8c0f,U+8c4c,U+8d45,U+8d5d,U+8d73,U+8e31,U+8e6d,U+8e76,U+8fe4,U+9041,U+90d7,U+9169,U+92ae,U+94a1,U+94c4,U+94c9,U+94db,U+94e7,U+9503,U+9506,U+9517,U+9528,U+9537,U+9542,U+9549,U+95fe,U+9616,U+961a,U+96c9,U+96f3,U+9701,U+970e,U+9739,U+9753,U+9798,U+98d2-98d3,U+98d9-98da,U+9968,U+996f,U+9984,U+9997,U+9acb,U+9b03,U+9c85,U+9ca8,U+9cab,U+9e49,U+9e51,U+9e66,U+9f10" } }, { uri: Bte, descriptors: { unicodeRange: "U+4e15,U+4e1e,U+4e2b,U+4eb3,U+4ec9,U+4f0e,U+4f64,U+501c,U+50a9,U+510b,U+51a2,U+51bc,U+527d,U+52d0,U+53fd,U+5429,U+542e,U+5486,U+54af,U+5506,U+5511,U+5522,U+552c,U+556c,U+55b3,U+55d2,U+55e6,U+55fd,U+561f,U+5639,U+5659,U+5662,U+5693,U+572a,U+5892,U+598a,U+5992,U+59a9,U+5a20,U+5ae3,U+5b17,U+5b7d,U+5d34,U+5d3d,U+5d4a,U+5d82,U+5e1a-5e1b,U+5ea5,U+5f0b,U+5f77,U+5fd6,U+5fff,U+6026,U+6035,U+6063,U+60b4,U+60bb,U+60ee,U+612b,U+6194,U+61ca,U+61e6,U+61f5,U+620a,U+6248,U+62a1,U+62d7,U+6376,U+637b,U+652b,U+65bc,U+65cc,U+65ce,U+65d6,U+664c,U+665f,U+6666,U+6684,U+66b9,U+6773,U+6777,U+6787,U+67de,U+6845,U+693d,U+6994,U+6a35,U+6d54,U+6d5c,U+6d8e,U+6dd6,U+6eb4,U+6f2a,U+6f78,U+704f,U+70ec,U+7118,U+714a,U+7172,U+71b9,U+724d,U+728a,U+7337,U+733e,U+7396,U+73b7,U+73cf,U+7428,U+742c,U+742e,U+74ee,U+74f4,U+7525,U+753a,U+7572,U+75d4,U+765c,U+768e,U+7762,U+777d,U+77fd,U+7825,U+7837,U+78b4,U+795f,U+79ed,U+7a1e,U+7b06,U+7b20,U+7ba9,U+7bab,U+7c7c,U+7cbd,U+7cdc,U+7ec9,U+7ef6,U+7f30,U+7f42,U+7f44,U+7f54,U+7f94,U+8004,U+800b,U+8019,U+809b,U+80ae,U+80c4,U+80f1,U+8146,U+816e,U+817c,U+81c0,U+81fc,U+81fe,U+822b,U+830f,U+832f,U+8340,U+8365,U+8385,U+8392,U+83a0,U+8424,U+84af,U+869c,U+8713,U+8717-8718,U+87c0,U+87cb,U+87fe,U+8821,U+8902,U+89d1,U+8bb9,U+8c12,U+8d32,U+8d53,U+8df7,U+8e7c,U+8f7c,U+8f95,U+8fab,U+9052,U+905b,U+9095,U+909d,U+90c5,U+911e,U+9122,U+916a,U+919b,U+948e,U+9492,U+949a,U+94b5,U+94bc,U+94c6,U+94f1,U+9502,U+9511,U+9536,U+956f-9570,U+9602,U+9621,U+9631,U+998b,U+99a5,U+9a81,U+9a9e,U+9ebe,U+9f8b" } }, { uri: Hte, descriptors: { unicodeRange: "U+4f2b,U+4f3d,U+4fac,U+5043,U+5055,U+5140,U+5156,U+51cb,U+5243,U+531d,U+536f,U+53a5,U+53ae,U+53f1,U+541d,U+5431,U+547b,U+5492,U+5494,U+54a4,U+54aa,U+54ce,U+54fd,U+5509,U+5520,U+553e,U+557b,U+55c5,U+55e1,U+55f7,U+5608,U+5636,U+563b,U+5773,U+57a0,U+5811,U+587e,U+58d5,U+59e3,U+5a29,U+5a6a,U+5a76,U+5a7a,U+5ac9,U+5b62,U+5b95,U+5c49,U+5c8c,U+5cab,U+5cb7,U+5d02,U+5d58,U+5e44,U+5e7a,U+5eff,U+5f29,U+5f89,U+5f9c,U+5fa8,U+6005,U+6043,U+60b8,U+60d8,U+60ec,U+60f0,U+6115,U+618e,U+630e,U+637a,U+6390,U+63ac,U+63b0,U+64de,U+6525,U+6538,U+65ee-65ef,U+6631,U+6636,U+6654,U+677c,U+67b8,U+67d8,U+683e,U+6886,U+68b5,U+692d,U+6963,U+6979,U+6988,U+6b59,U+6b9a,U+6c69,U+6c74,U+6cae,U+6ce0,U+6cef,U+6d95,U+6dc5,U+6dde,U+6de6,U+6dfc,U+6ea7,U+6f15,U+6f29,U+7096,U+70c3,U+7131,U+715c,U+7166,U+7266,U+7317,U+731d,U+7329,U+73e9,U+7425,U+7455,U+7490,U+74ef,U+7519,U+75b5,U+75b9,U+75de,U+7656,U+7663,U+7691,U+7729,U+77fe,U+783e,U+787c,U+795a,U+7a79,U+7abf,U+7b3a,U+7b4f,U+7b60,U+7b75,U+7b8d,U+7bb4,U+7bd3,U+7be1,U+7cbc,U+7edb,U+7f1c,U+7f8c,U+7fb2,U+7fb9,U+7fce,U+7ff1,U+810d,U+81c6,U+82a5,U+82aa,U+82de,U+8317,U+8343,U+835e,U+8364,U+836a,U+853a,U+8543,U+854a,U+8559,U+8568,U+85b0,U+85b9,U+864f,U+86e4,U+8715,U+8845,U+8884,U+88e8,U+88f1,U+8983,U+8be1,U+8c1f,U+8c27,U+8c5a,U+8c82,U+8d58,U+8dbe,U+8f98,U+9035,U+9074,U+90a1,U+9149,U+9157,U+93d6,U+949d,U+94c2,U+94e3-94e4,U+95eb,U+95f0,U+9611,U+9619,U+9642,U+968d,U+9706,U+970f,U+97ed,U+988a,U+9893,U+98e8,U+9a77,U+9a87,U+9aa1,U+9abc,U+9cdd,U+9e2f,U+9e33,U+9e44,U+9e5c,U+9e9d,U+9edd" } }, { uri: Wte, descriptors: { unicodeRange: "U+4f58,U+4f6c,U+4f70,U+4fd0,U+5014,U+51bd,U+524c,U+5315,U+5323,U+535e,U+540f,U+542d,U+545b,U+548e,U+549a,U+54ab,U+54fc,U+5567,U+556a,U+5600,U+5618,U+563f,U+5669,U+56f1,U+56ff,U+573b,U+574d,U+579b,U+57b8,U+57c2,U+586c,U+58f9,U+595a,U+598d,U+5993,U+5996,U+59d7,U+5b7a,U+5ba6,U+5c4e,U+5c96,U+5ce5,U+5eb6,U+5f08,U+5f99,U+602f,U+6059,U+606c,U+607a,U+60ed,U+61a9,U+620c,U+6249,U+62a8,U+62c4,U+62ed,U+62fd,U+6342,U+6345,U+6396,U+63a3,U+6402,U+6413,U+642a,U+6487,U+64a9,U+64ac,U+64ae,U+64b7,U+659f,U+65a1,U+667e,U+66f3,U+67e0,U+69db,U+69df,U+6aac,U+6b86,U+6c50,U+6c5e,U+6c76,U+6c85,U+6c8c,U+6cde,U+6d19,U+6d52,U+6da7,U+6db8,U+6e1a,U+6e25,U+6e4d,U+6e5f,U+6ec1,U+6f31,U+6f7a,U+6fa7,U+6fe1,U+701b,U+70ab,U+70f7,U+717d,U+71a8,U+7252,U+72c4,U+72e1,U+7315,U+736d,U+73ae,U+73c0,U+73c2,U+740f,U+75a4,U+7600-7601,U+768b,U+76bf,U+76d4,U+7728,U+772f,U+776c,U+77a0,U+77b0,U+77f8,U+783a,U+78d0,U+78fa,U+7977,U+7a37,U+7a92,U+7afa,U+7b71,U+7b94,U+7cef,U+7f28,U+7fe1,U+808b,U+80e5,U+80eb,U+8110,U+8113,U+812f,U+814c,U+81c3,U+8235,U+82d4,U+8309,U+83c1,U+8431,U+8469,U+84bf,U+84d3,U+84df,U+84e6,U+8511,U+8638,U+86c0,U+86db,U+86fe,U+8757,U+8822,U+8882,U+8885,U+8892,U+88f3,U+892a,U+8ba5,U+8bd9,U+8be0,U+8be7,U+8bfd,U+8c1a,U+8d4a,U+8d4e,U+8d66,U+8dda,U+8e0c,U+8e52,U+8e74,U+8e87,U+8f76,U+8fc2,U+8fe6,U+900d,U+9068,U+90ac,U+90b3,U+90b8,U+90e7,U+9119,U+9131,U+915a,U+916e,U+94b4,U+94d0,U+94e2,U+94ec,U+94ff,U+9522,U+9535,U+9556,U+965b,U+96f9,U+9774,U+9981,U+998d,U+998f,U+9a6e,U+9a7f,U+9a8a,U+9b13,U+9c9f,U+9e3e,U+9e43,U+9e6d,U+9e8b,U+9e92,U+9edb,U+9eef" } }, { uri: Xte, descriptors: { unicodeRange: "U+4e10,U+4e56,U+4e98,U+4ec3,U+4f3a,U+4f5f,U+4f88,U+4f97,U+4fa5,U+4fe8,U+504c,U+5197,U+52fa,U+5364,U+53e8,U+5406,U+543c,U+545c,U+5471,U+5480,U+5495,U+54b3,U+54df,U+54e6,U+54ee,U+557c,U+5583,U+55dc,U+55e3,U+566c,U+592f,U+5944,U+5983,U+59ca,U+59e5,U+5a13,U+5a7f,U+5b09,U+5bd0,U+5e4c,U+5eb5,U+5f1b,U+5f3c,U+608d,U+60cb,U+61a7,U+61ac,U+61cb,U+6233,U+62a0,U+62e7,U+62ee,U+62f4,U+62f7,U+634e,U+6382,U+63c9,U+63ea,U+6400,U+645e,U+6482,U+6556,U+6593,U+6615,U+664f,U+66e6,U+672d,U+675e,U+67da,U+6805,U+6808,U+6868,U+68a2,U+695e,U+69ad,U+6a80,U+6a90,U+6b83,U+6be1,U+6c30,U+6cad,U+6cb1,U+6cf1,U+6d31,U+6d93,U+6dae,U+6dbf,U+6dc6-6dc7,U+6e0d,U+6e32,U+6e3a,U+6e85,U+6eba,U+6f3e,U+6f5e,U+6f7c,U+6fee,U+71ee,U+722a,U+72b7,U+72e9,U+73ba,U+73d1,U+7409,U+7435-7436,U+7459-745a,U+747e,U+7487,U+74e2,U+7504,U+752c-752d,U+7599,U+759f,U+75a1,U+75ca,U+75f0,U+761f,U+7629,U+777f,U+7785,U+77a5,U+77bf,U+78d5,U+7934,U+7940,U+79a7,U+7b19,U+7c38,U+7c95,U+7cb1,U+7ce0,U+7eca,U+7ef7,U+7f2b,U+7f81,U+7fcc,U+8046,U+8148,U+8165,U+819b,U+81ba,U+828b,U+82ae,U+82b7,U+82d3,U+8301,U+830e,U+831c,U+8338,U+837c,U+8393,U+8398,U+83ba,U+83e0,U+83e9,U+853c,U+8654,U+86df,U+8712,U+873f,U+874e,U+8783,U+8859,U+88a4,U+8925,U+8bb7,U+8bff,U+8c19,U+8c1b,U+8c24,U+8c2c,U+8d61,U+8db4,U+8e6c,U+8f8a,U+8fe5,U+8ff8,U+901e,U+90f4,U+912f,U+9163,U+9170,U+91dc,U+949b,U+94a8,U+94b3,U+94c0,U+94e8,U+9525,U+9530,U+9539,U+954c-954d,U+9550,U+955b,U+962a,U+9685,U+96cc,U+9776,U+988d,U+9975,U+9985,U+9a6f,U+9aa5,U+9ab8,U+9c7f,U+9ca4,U+9cb8,U+9e25,U+9e35,U+9e4a" } }, { uri: Vte, descriptors: { unicodeRange: "U+4ea2,U+4ea5,U+4f36,U+4f84,U+4f8d,U+501a,U+5029,U+516e,U+51a5,U+51c4,U+51f8,U+5201,U+527f,U+5321,U+5352,U+5366,U+53e9,U+54c7,U+5632,U+5676,U+56b7,U+56bc,U+56da,U+56e4,U+5703,U+5729,U+5742,U+57a2-57a3,U+5815,U+58d1,U+5919,U+592d,U+5955,U+5a05,U+5a25,U+5a34,U+5b70,U+5b75,U+5bdd,U+5bf0,U+5c41,U+5c79,U+5c91,U+5c94,U+5ce6,U+5ced,U+5d69,U+5dc5,U+5e16,U+5e27,U+5f27,U+5f95,U+5ffb,U+6020,U+604d,U+6055,U+60e6,U+60eb,U+6123,U+618b,U+61a8,U+620d,U+62c7,U+62ce,U+62d9,U+631f,U+634d,U+6452,U+6479,U+64ce,U+64d2,U+655b,U+660a,U+6726,U+67c4,U+6809,U+6853,U+68e3,U+68f1,U+68fa,U+693f,U+6942,U+6995,U+69a8,U+69b4,U+6a71,U+6b89,U+6bcb,U+6bd3,U+6bd9,U+6c40,U+6cf8,U+6cfe,U+6d85,U+6da3,U+6daa,U+6e0e,U+6e43-6e44,U+6f88,U+7078,U+7099,U+70bd,U+70d9,U+70fd,U+7109,U+7184,U+7239,U+733f,U+73f2,U+748b,U+749c,U+749e,U+759a,U+75d2,U+75eb,U+7620,U+766b,U+7693,U+76cf,U+7738,U+773a,U+776b,U+778e,U+77aa,U+7852,U+78be,U+7948,U+795b,U+7960,U+796f,U+79ba,U+7a20,U+7a96,U+7aa5,U+7b03,U+7b28,U+7b50,U+7b77,U+7bc6,U+7bf1,U+7c27,U+7d0a,U+7ead,U+7ec5,U+7ee2,U+7ef0,U+7efd,U+7f0e,U+7f2e,U+7f79,U+7f9a,U+8098,U+80da,U+80e7,U+80f0,U+80f3,U+80fa,U+818a,U+81e7,U+8237-8238,U+8299,U+82b8,U+82ce,U+837b,U+83bd,U+83cf,U+8426,U+8475,U+85c9,U+85d5,U+85dc,U+85e9,U+871a,U+8747,U+8749,U+888d,U+8910,U+891a,U+8bb4,U+8be3,U+8bec,U+8bf2,U+8c06,U+8c0d,U+8d31,U+8d48,U+8de4,U+8e1e,U+8e4a,U+8e66,U+8f84,U+8f97,U+9083,U+90e1,U+9165,U+91c9,U+94b0,U+94f5,U+9504,U+9532,U+956d,U+95f5,U+95fa,U+9668,U+9698,U+96bd,U+9704,U+9773,U+9890,U+996a,U+997a,U+9a74,U+9a8b,U+9cc4,U+9ccc" } }, { uri: Gte, descriptors: { unicodeRange: "U+4ea8,U+4f1e,U+4f51,U+4f63,U+4f7c,U+4f83,U+4fa0,U+4fd1,U+4ffa,U+5018,U+5026,U+508d,U+50bb,U+50f5,U+50fb,U+5162,U+5319,U+5320,U+538c,U+5413,U+541f,U+5475,U+54bd,U+54d1,U+5589,U+5598,U+575f,U+57ae,U+57e0,U+5937,U+5974,U+5978,U+59ae,U+5a1f,U+5a49,U+5ab3,U+5b99,U+5b9b,U+5ba0,U+5be1,U+5be5,U+5c09,U+5c27,U+5de2,U+5e9a,U+5f26,U+5f8a,U+5f98,U+6021,U+606d,U+60bc,U+60d5,U+60e7,U+611a,U+614c,U+6254,U+626f,U+6292,U+6296,U+62b9,U+62e2,U+631a,U+631d,U+6320,U+6346,U+63ba,U+6467,U+64bc,U+658b,U+663c,U+6643,U+6652,U+6656,U+6687,U+66d9,U+66dd,U+66f0,U+673d,U+67ab,U+6816-6817,U+68a7,U+68ad,U+68cd,U+68e0,U+6986,U+69fd,U+6b47,U+6bd7,U+6c1f,U+6c2e-6c2f,U+6cbe,U+6de4,U+6e1d,U+6e83,U+6e9c,U+6ed4-6ed5,U+6f4d,U+70f9,U+7130,U+716e,U+718f,U+71ac,U+71e5,U+72fc,U+731c,U+7334,U+73ca,U+7422,U+7426,U+745f,U+7470,U+75af,U+75f4,U+762b,U+763e,U+7696,U+7737,U+7741,U+77a7,U+77bb,U+77ee,U+785d,U+788c,U+78ca,U+7901,U+796d,U+7985,U+79fd,U+7a3c,U+7a57,U+7a74,U+7b5b,U+7caa,U+7cb9,U+7cd5,U+7eac,U+7eb6,U+7ed1,U+7ee5,U+7f20,U+7f2a,U+7f38,U+7f69,U+7fa1,U+8018,U+8038,U+803f,U+804b,U+80a2,U+80be,U+80d6,U+817a,U+81fb,U+820c,U+82ad,U+82af,U+82bd,U+8327,U+8354,U+835f,U+8367,U+836b,U+840c,U+841d,U+8471,U+849c,U+84b2,U+84c9,U+8517,U+851a,U+8549,U+8681,U+8721,U+8776,U+88d9,U+88f9,U+89c5,U+8c1c,U+8c34,U+8d81,U+8d9f,U+8e0a,U+8e72,U+8eb2,U+8fed,U+901b,U+902e,U+906e,U+9091,U+90aa,U+90af,U+915d,U+9171,U+946b,U+9489,U+9499,U+94a5,U+9508,U+9524,U+952d,U+9551,U+9576,U+95f7,U+9600,U+96b6,U+96c0,U+9756,U+97f6,U+98a0,U+98a4,U+997f,U+9a73,U+9a86,U+9ad3,U+9e3d,U+9ed4" } }, { uri: jte, descriptors: { unicodeRange: "U+4e4d,U+4e5e,U+4ec7,U+4ed5,U+50da,U+50e7,U+515c,U+51a4,U+51ff,U+5203,U+5254,U+5300,U+533e,U+5375,U+53ee,U+5435,U+543b,U+5455,U+548b,U+548f,U+54d7,U+54fa,U+5578,U+5587,U+55a7,U+560e,U+5760,U+576f,U+5777,U+5830,U+58a9,U+5962,U+59e8,U+5a07,U+5a23,U+5a3c,U+5b5a,U+5bb5,U+5bc5,U+5bde,U+5c7f,U+5cb1,U+5ce8,U+5cea,U+5d29,U+5d4c,U+5e18,U+5f57,U+5f5d,U+5f87,U+5ff1,U+6016,U+601c,U+6064,U+6177,U+61d2,U+625b,U+62e3,U+62f1,U+634f,U+63a0,U+6401,U+6405,U+6495,U+64c2,U+6512,U+6577,U+6590,U+65a7,U+65a9,U+65f7,U+6627,U+6655,U+6714,U+6795,U+67d1,U+67ff,U+68b3,U+68d5,U+68d8,U+6930,U+6960,U+6977,U+69bb,U+69d0,U+6a31,U+6b7c,U+6bb4,U+6c22,U+6c72,U+6c79,U+6c7e,U+6c81,U+6c93,U+6ca5,U+6cbc,U+6ce3,U+6cfb,U+6d3c,U+6da9,U+6df3,U+6e2d,U+6eaf,U+6ec7,U+6f13,U+6f33,U+6f62,U+6fa1,U+7011,U+707c,U+708a,U+70c1,U+70d8,U+70eb,U+711a,U+7194,U+7281,U+7316,U+7357,U+7384,U+7405,U+742a,U+745b,U+7574,U+7578,U+75ea,U+7682,U+7792,U+77d7,U+77e9,U+77eb,U+77f6,U+780c,U+78c5,U+7941,U+79e4,U+7a1a,U+7a9c,U+7ad6,U+7b5d,U+7bf7,U+7c07,U+7c3f,U+7c9f,U+7ca5,U+7cdf,U+7e82,U+7eab,U+7ece,U+7eda,U+7f09,U+7f15,U+7f9e,U+7fdf,U+7fe9,U+803b,U+803d,U+80aa,U+80b4,U+813e,U+8155,U+817b,U+819d,U+821c,U+82b9,U+82df,U+82ef,U+8304,U+83b9,U+8446,U+853d,U+85af,U+85fb,U+8650,U+865e,U+86d9,U+86ee,U+8700,U+8862,U+889c,U+88d4,U+88f8,U+895f,U+8a79,U+8bb3,U+8bb6,U+8bc0,U+8beb,U+8bf5,U+8c23,U+8c79,U+8d1e,U+8dcb,U+8e29,U+8e44,U+8e81,U+8eac,U+8eaf,U+8f8d,U+9050,U+90f8,U+914b,U+948a,U+94be,U+94ee,U+950c,U+9540,U+962e,U+9647,U+9661,U+9699,U+96cf,U+9716,U+9761,U+97a0,U+97e7,U+9a7c,U+9a8f,U+9ae6,U+9cd6,U+9e26" } }, { uri: Kte, descriptors: { unicodeRange: "U+4fa3,U+4fae,U+4fd8,U+4fef,U+50a3,U+5189,U+5195,U+51db,U+51f3,U+51f9,U+5220,U+5228,U+5288,U+52ff,U+532e,U+533f,U+5351,U+53db,U+53ed,U+5450,U+5484,U+5490,U+54c9,U+54e9,U+5501,U+5507,U+5543,U+55d3,U+56a3,U+575e,U+589f,U+5984,U+59ec,U+5a04,U+5a36,U+5a77,U+5a9a-5a9b,U+5ab2,U+5ac2,U+5ad6,U+5bc7,U+5c2c,U+5c34,U+5c51,U+5cd9,U+5d0e,U+5deb,U+5e3c,U+5e87,U+5ed3,U+5f13,U+5f64,U+5fe1,U+606a,U+6096,U+60df,U+60f6,U+60f9,U+6151,U+620e,U+6241,U+6252,U+6273,U+627c,U+6289,U+62c2,U+62cc,U+62ef,U+6361,U+6363,U+63b7,U+63e3,U+6518,U+66ae,U+6756,U+6789,U+6813,U+6829,U+6862,U+6866,U+6893,U+6897,U+690e,U+6984,U+69cc,U+6a1f,U+6a44,U+6a59,U+6ba1,U+6c13,U+6c90,U+6ca6,U+6cbd,U+6ccc,U+6cd3,U+6cd7,U+6d4a,U+6d4f,U+6d5a,U+6d9f,U+6da1,U+6dcc,U+6ea5,U+6ee4,U+6ee6,U+6f2f,U+6f8e,U+701a,U+7095,U+709c,U+70af,U+70db,U+70e8,U+714e,U+715e,U+71a0,U+71ce,U+7235,U+7280,U+72d0,U+72f8,U+73ab,U+7410,U+745c,U+7480,U+74a7-74a8,U+74e3,U+75ae,U+75f9,U+76b1,U+76ce,U+7736,U+77e2-77e3,U+781a,U+789f,U+797a,U+79be,U+79c3,U+79c6,U+79f8,U+7a8d,U+7a98,U+7aa6,U+7aff,U+7b1b,U+7cd9,U+7d6e,U+7ede,U+7eee,U+7f00,U+7f24,U+7f2d,U+7fd8,U+800d,U+8116,U+8151,U+81b3,U+8205,U+82c7,U+82db,U+832c,U+8335,U+8339,U+8386,U+846b,U+8587,U+8611,U+8682,U+868a,U+868c,U+8774,U+88d8,U+88f4,U+8912,U+8b6c,U+8bbd,U+8c0e,U+8c41,U+8d26,U+8d3b-8d3c,U+8d50,U+8dea,U+8e35,U+8f99,U+8fe2,U+8fe9,U+9017,U+914c,U+916f,U+9175-9176,U+918b,U+94a0,U+94ae,U+94ce,U+94f2,U+951a,U+952f,U+9541,U+9640,U+9672,U+968b,U+96cd,U+96ef,U+9713,U+97ec,U+9885,U+9992,U+9a6d,U+9a79,U+9a85,U+9cbb,U+9cd7,U+9cde,U+9e93,U+9f9f" } }, { uri: Yte, descriptors: { unicodeRange: "U+4e11,U+4ed7,U+4fcf,U+4fe9,U+4fed,U+50ac,U+50b2,U+5112,U+5180,U+5188,U+51f6,U+522e,U+5265,U+52cb,U+52df,U+5349,U+5367,U+5378,U+537f,U+5395,U+5398,U+53d4,U+543e,U+5440,U+5446,U+54b8,U+5565-5566,U+5580,U+55bb,U+56ca,U+572d,U+573e,U+574e,U+5782-5784,U+58f3,U+5938-5939,U+5948,U+594e,U+5a1c,U+5a74,U+5ae9,U+5b55,U+5b5c,U+5bb0,U+5bd3,U+5bf8,U+5c3f,U+5d14,U+5d2d,U+5df7,U+5dfe,U+5e05-5e06,U+5e1c,U+5e62,U+5e7b,U+5e7d,U+5ed6,U+5f2f,U+5f66,U+5f6c,U+5fa1,U+604b,U+609f,U+60a6,U+60e8,U+6101,U+6124,U+6127,U+6148,U+61be,U+6247,U+62d8,U+62da,U+633d,U+635e,U+6367,U+6380,U+638f,U+63a9,U+63fd,U+641c,U+64e6,U+655e,U+6572,U+6591,U+65a5,U+6691,U+6735,U+67a2-67a3,U+67ef,U+680b,U+6876,U+6905,U+6a0a,U+6a61,U+6b79,U+6bb7,U+6bbf,U+6c41,U+6c55,U+6c83,U+6c9b,U+6ca7,U+6cfc,U+6d46,U+6d51,U+6d74,U+6d9d,U+6daf,U+6dc0,U+6deb,U+6e17,U+6e24,U+6e89,U+6ea2,U+6ef4,U+6f6d,U+707f,U+70b3,U+70e4,U+70ef,U+710a,U+722c,U+725f,U+7261,U+72ee,U+72f1,U+730e,U+732b,U+7433,U+7538,U+75bc,U+7624,U+7709,U+7750,U+7779,U+7802,U+7898,U+78a7,U+78b1,U+78cb,U+78f7,U+7984,U+7a83,U+7aed,U+7b3c,U+7b4b,U+7c92,U+7c98,U+7ca4,U+7eb9,U+7ee3,U+7ef3,U+7ef5,U+7f05,U+7f55,U+7f62,U+7fc1,U+7fd4,U+7fe0,U+8042,U+806a,U+80a0,U+80a4,U+80c3,U+8102,U+8106,U+814a,U+8154,U+8247,U+8258,U+82cd,U+8328,U+832b,U+8389,U+83ca,U+845b,U+846c,U+84b8,U+8574,U+859b,U+8680,U+8695,U+86c7,U+8702,U+886c,U+8896,U+88b1,U+88e4,U+8bc8,U+8c10,U+8c26,U+8c28,U+8c2d,U+8d4c,U+8d63,U+8f67,U+8f74,U+8fc4,U+9006,U+9063,U+90a2,U+90b1,U+90c1,U+9177,U+9189,U+9493,U+949e,U+94fe,U+9610,U+961c,U+96a7,U+96fe,U+978d,U+97f5,U+9888,U+997c,U+9a84,U+9b3c,U+9b44-9b45,U+9b54,U+9e64,U+9f0e,U+9f9a" } }, { uri: qte, descriptors: { unicodeRange: "U+4e19,U+4e38,U+4e53,U+4e7e,U+4e9f,U+4ec6,U+4f50,U+4fde,U+502a,U+5154,U+517d,U+51d1,U+51f0,U+5239,U+5256,U+52c9,U+52fe,U+5308,U+532a,U+535c,U+5384,U+53a2,U+53a8,U+53c9,U+53e0,U+5496,U+54ac,U+54c0,U+54c4,U+54e8,U+5561,U+5582,U+561b,U+5631,U+566a,U+5764,U+576a,U+5792,U+57ab,U+584c,U+5885,U+58f6,U+59a8,U+5acc,U+5bc2,U+5c38-5c39,U+5c60,U+5c6f,U+5c82,U+5c90,U+5d16,U+5dcd,U+5e37,U+5e90,U+5eb8,U+5f6a,U+5fcc,U+6012,U+6068,U+6073,U+607c,U+6094,U+6109,U+621a,U+626e,U+6284,U+62d0,U+62e6,U+62fe,U+6321,U+6328,U+632b,U+6349,U+6454,U+65ed,U+660f,U+6674,U+66a8,U+6749,U+674f,U+6760,U+67af,U+6850,U+6854,U+6869,U+68a8,U+68d2,U+68f5,U+6912,U+6b49,U+6b6a,U+6bef,U+6c28,U+6c5d,U+6c82,U+6cab,U+6cb8,U+6cc4,U+6cf5,U+6d47,U+6d78,U+6da4,U+6dc4,U+6dcb,U+6df9,U+6e0a,U+6e23,U+6e5b,U+6eb6,U+6f06,U+6f47,U+6f84,U+6f9c,U+6fd2,U+7076,U+70ac,U+7199,U+723d,U+72ac,U+72ed,U+7476,U+7529,U+752b,U+754f,U+7554,U+75d5,U+7626,U+76ef,U+7720,U+7766,U+7784,U+77ac,U+780d,U+7838,U+7845,U+786b,U+78b3,U+7978,U+79b9,U+79c9,U+79e7,U+7a3d,U+7a84,U+7a9f,U+7b0b,U+7b52,U+7c7d,U+7f1a,U+7fc5,U+7ff0,U+804a,U+8086-8087,U+808c,U+809a,U+80ba,U+810a,U+8180,U+818f,U+81c2,U+81ed,U+8231,U+8292,U+829c,U+82a6,U+82d1,U+8346,U+838e,U+839e,U+83c7,U+83f1,U+8403,U+840e,U+8513,U+857e,U+85e4,U+867e,U+871c,U+87ba,U+87f9,U+884d,U+8944,U+8a93,U+8c05,U+8d2c,U+8d2e,U+8d42-8d43,U+8dfb,U+8e22,U+8eba,U+8f69,U+8f9c,U+8fa3,U+8fa8,U+8fb1,U+900a,U+9038,U+903b,U+9042,U+904f,U+90b5,U+90dd,U+9102,U+9187,U+94a7,U+94c5,U+9523,U+95f8,U+95fd,U+960e,U+964b-964c,U+96c1,U+9709,U+971c,U+97ad,U+9882,U+9965,U+9976,U+9988,U+99a8,U+9a82,U+9a9a,U+9b41,U+9c8d,U+9e45,U+9e70,U+9e9f,U+9f3b,U+9f7f" } }, { uri: Zte, descriptors: { unicodeRange: "U+4e08,U+4e18,U+4e1b,U+4e22,U+4e27,U+4e32,U+4e52,U+4e73,U+4ead,U+4ed4,U+4ed9,U+4ef0,U+4fa6,U+5076,U+5179,U+51bb,U+51c9,U+51ef,U+51fd,U+524a,U+526a,U+529d,U+52ab,U+5306,U+5339,U+53d9,U+540a,U+5410,U+541e,U+5439,U+54b1,U+54ed,U+5564,U+558a,U+55b7,U+5634,U+574a,U+5751,U+57a6,U+57cb,U+57d4,U+5824,U+582a,U+5835,U+5858,U+5893,U+58e4,U+5951,U+5986,U+59da,U+59fb,U+59ff,U+5a03,U+5a46,U+5ac1,U+5b5d,U+5bfa,U+5c18,U+5c3a,U+5c48,U+5c4f,U+5c61,U+5cb3,U+5d1b,U+5e15,U+5e3d,U+5e99,U+5e9e,U+5eca,U+5f0a,U+5f17-5f18,U+5f25,U+5f7c,U+5fcd,U+6028,U+60a0,U+60ac,U+60d1,U+614e,U+6155,U+6168,U+61c8,U+6208,U+6212,U+6251,U+629a-629b,U+62ab-62ac,U+62fc,U+6323,U+632a,U+63d2,U+643a,U+6491-6492,U+649e,U+64b0,U+64c5,U+659c,U+6614,U+662d,U+6664,U+6670,U+6676,U+6746,U+67cf,U+67d4,U+682a,U+6843,U+6846,U+68da,U+6b3a,U+6b67,U+6c27,U+6c5b,U+6c64,U+6c70,U+6caa,U+6cca,U+6ce1,U+6d12,U+6d45,U+6dd1,U+6dd8,U+6e34,U+6e7f,U+6ee5,U+6f02,U+7092,U+70c2,U+70e6,U+7115,U+7237,U+7272,U+727a,U+72c2,U+739b,U+73b2,U+743c,U+751c,U+758f,U+75b2,U+7686,U+76c6,U+76d2,U+76fc,U+775b,U+77a9,U+7816,U+788e,U+7897,U+78b0,U+79bd,U+7a0d,U+7a91,U+7a9d,U+7ae3,U+7bad,U+7cca,U+7d2b,U+7eb1,U+7f06,U+7f14,U+7f1d,U+7f50,U+7ffc,U+8036,U+80bf,U+80c1,U+80ce,U+80f8,U+8109,U+810f,U+8170,U+8179,U+819c,U+821f,U+8230,U+8236,U+8273,U+829d,U+82f9,U+8305,U+8350,U+83b2,U+83cc,U+8404,U+840d,U+8427,U+8482,U+8679,U+8854,U+886b,U+8bbc,U+8be6,U+8c31,U+8c6b,U+8d4b,U+8dcc,U+8e2a,U+8e48,U+8f90,U+8fb0,U+9022,U+903c,U+903e,U+9065,U+916c,U+917f,U+94a9,U+94c3,U+94dd,U+94ed,U+9510,U+953b,U+96c7,U+970d,U+9738,U+9877,U+987d,U+989c,U+98d8,U+9a70,U+9a91,U+9aa4,U+9b42,U+9b4f,U+9e2d,U+9e3f,U+9e7f,U+9f20" } }, { uri: Jte, descriptors: { unicodeRange: "U+4e59,U+4ed3,U+4f0f,U+4f38,U+4f69,U+4fa7,U+4faf,U+4ff1,U+5077,U+5085,U+5144,U+5151,U+51af,U+51b6,U+51cc,U+523a,U+5251,U+5269,U+5272,U+52d8,U+5353,U+5389,U+53f9,U+5401,U+5415,U+541b,U+54f2,U+5524,U+554a,U+559d,U+5609,U+5740,U+575d,U+5806,U+5821,U+586b,U+5915,U+594f,U+5960,U+5999,U+59a5,U+59b9,U+59c6,U+59d1,U+59dc,U+5b5f,U+5b64,U+5b87,U+5bb4,U+5bbf,U+5c16,U+5c1d,U+5c3e,U+5c9a,U+5ca9,U+5cad,U+5cfb,U+5de1,U+5de7,U+5de9,U+5ef7,U+5f04,U+5f70,U+5f79,U+5fc6,U+602a,U+6050,U+6052,U+6070,U+6084,U+60b2,U+60dc,U+60e9,U+6167,U+6170,U+61c2,U+6270,U+6291,U+62b1,U+62bc,U+62dc,U+62df,U+62f3,U+6324,U+633a,U+6377,U+6398,U+63cf,U+640f,U+642c-642d,U+6458,U+6478,U+6500,U+654c,U+6566,U+658c,U+65c1,U+65cb,U+65e8,U+65ec,U+6696-6697,U+6734,U+679a,U+679d,U+67dc,U+67f3-67f4,U+680f,U+683d,U+684c,U+68af,U+699c,U+6bc1,U+6c0f,U+6c1b,U+6c57,U+6c6a,U+6d3d,U+6d6e,U+6d82,U+6db5,U+6dee,U+6e58,U+6eaa,U+6ecb,U+6ede,U+6ee9,U+6f0f,U+6f20,U+6f58,U+704c,U+7070,U+70b8,U+718a,U+7238,U+7262,U+7275,U+72b9,U+72d7,U+72e0,U+741b,U+7434,U+7483,U+74f6-74f7,U+75ab,U+764c,U+7761,U+7855,U+7891,U+78c1,U+79d2,U+7a00,U+7a3b,U+7c97,U+7ea4,U+7eb2,U+7ed2,U+7eea,U+7ef8,U+7f18,U+7fbd,U+8000,U+8010,U+8096,U+809d,U+80a9,U+817f,U+81e3,U+8206,U+8212,U+82ac,U+8302,U+8361,U+8377,U+83f2,U+8461,U+848b,U+84ec,U+8521,U+85aa,U+8870,U+8877,U+8881,U+888b,U+88ad,U+88c2,U+8986,U+8bd1,U+8bf1,U+8d24,U+8d2a,U+8d3e-8d3f,U+8d41,U+8d56,U+8d64,U+8d6b,U+8e0f,U+8f70,U+8f85,U+8f88,U+8fa9,U+9003,U+901d,U+90b9,U+90ce,U+94a6,U+94f8,U+9505,U+95ea,U+95ef,U+95f2,U+95f9,U+9601,U+9605,U+9634,U+966a,U+9677,U+9690,U+9694,U+96d5,U+971e,U+9896-9897,U+9972,U+9a71,U+9a76,U+9a7e,U+9e1f,U+9e23" } }, { uri: Qte, descriptors: { unicodeRange: "U+4e01,U+4e43,U+4ea6,U+4ef2,U+4eff,U+4f26,U+4f2a,U+4f2f,U+4f5b,U+4fa8,U+4fca,U+4fd7,U+5021,U+504f,U+5141,U+51c0,U+51dd,U+51e4,U+51ed,U+5200,U+5237,U+5427,U+5448,U+54a8,U+5706,U+5708,U+5723,U+575b,U+57c3,U+5899,U+58a8,U+58c1,U+5976,U+5988,U+59bb,U+59d0,U+59d3,U+5a18,U+5a31,U+5a92,U+5b54,U+5b85,U+5baa-5bab,U+5bc4,U+5bd2,U+5be8,U+5bff,U+5c65,U+5d07,U+5e1d,U+5e78,U+5e7c,U+5f03,U+5f1f,U+5f39,U+5f6d,U+5f92,U+5faa,U+5fbd,U+5fe7,U+5ffd,U+60a8,U+60ef,U+6108,U+6162,U+622a,U+6234,U+626b,U+626d,U+62c6,U+62d2,U+62d4,U+62d6,U+62e8,U+6316,U+6355,U+63ed,U+6447,U+64a4,U+65f1,U+6606,U+6628,U+664b,U+6668,U+6682,U+66f9,U+66fc,U+66ff,U+6717,U+6740,U+676d,U+67aa,U+67ec,U+67f1,U+6842,U+6851,U+695a,U+6982,U+6a2a,U+6b20,U+6b23,U+6b32,U+6b96,U+6bc5,U+6beb,U+6c60,U+6c9f,U+6cea,U+6cf3,U+6d1e,U+6d53,U+6d66,U+6d69,U+6d8c,U+6d9b,U+6db2,U+6de1,U+6dfb,U+6e14,U+6ed1,U+6eda,U+6ee8,U+6f2b,U+706d,U+7089,U+708e,U+70ad-70ae,U+70e7,U+7126,U+714c,U+71c3,U+71d5,U+7206,U+7259,U+731b,U+73a9,U+73bb,U+74dc,U+7532,U+7545,U+755c,U+75c7,U+7687,U+76d7,U+76f2,U+788d,U+78e8,U+79e6,U+79e9,U+7a3f,U+7a46,U+7a97,U+7af9,U+7bee,U+7c4d,U+7c89,U+7cd6,U+7eb5,U+7ebd,U+7ed8,U+8017,U+8033,U+80c0,U+80de,U+80f6,U+8138,U+817e,U+81a8,U+820d,U+827e,U+82b3,U+82d7,U+83b1,U+84c4,U+84dd,U+8584,U+864e,U+865a,U+866b,U+86cb,U+88d5,U+89e6,U+8bca,U+8bde,U+8bfa,U+8c0a,U+8c37,U+8c46,U+8c6a,U+8c8c,U+8d1d,U+8d29,U+8d4f,U+8d54,U+8d5a,U+8d60,U+8d62,U+8f7f,U+8f96,U+8f9e-8f9f,U+8fc1,U+8fdf,U+8fea,U+8ff7,U+9012,U+906d,U+9075,U+90a6,U+90bb,U+90ca,U+9178,U+9192,U+91ca,U+94bb,U+94dc,U+94fa,U+9501,U+950b,U+9521,U+955c,U+963b,U+9655,U+9675-9676,U+9887,U+9891,U+9971,U+9a97,U+9ece,U+9ed8" } }, { uri: ene, descriptors: { unicodeRange: "U+4e1d,U+4e39,U+4e4c,U+4e4f,U+4e54,U+4e58,U+4e95,U+4ea1,U+4eab,U+4eae,U+4ec1,U+4f10,U+4f19,U+4f30,U+4f34,U+4fb5,U+503e,U+518c,U+5192,U+51a0,U+51ac,U+51b0,U+51e1,U+5211,U+5242,U+52a3,U+52b2,U+52c3,U+52c7,U+52d2,U+52e4,U+5377,U+539a,U+53a6,U+53e5,U+5417,U+5510,U+552f,U+5531,U+574f-5750,U+5761,U+5851,U+5854,U+58ee,U+593a,U+5949,U+5954,U+5a5a,U+5b8b,U+5bbd,U+5c04,U+5c0a,U+5c4b,U+5ce1,U+5cf0,U+5e10,U+5e8a,U+5e9f,U+5ec9,U+5f31,U+5f84,U+5fd8-5fd9,U+5fe0,U+6015,U+6062,U+6069,U+6076,U+6089,U+60a3,U+60ca,U+620f,U+624e,U+6263,U+6298,U+62a2,U+62bd,U+6311,U+6350,U+6389,U+638c,U+63f4,U+6446,U+644a,U+6469,U+64cd,U+654f,U+6562,U+656c,U+65d7,U+65e6,U+65fa,U+660c,U+6653,U+66b4,U+670b,U+672b,U+676f-6770,U+6881,U+6885,U+68a6,U+68cb,U+68ee,U+6b8a,U+6c88-6c89,U+6cc9,U+6ce5,U+6d01,U+6d17,U+6d1b,U+6d59,U+6d6a,U+6da8,U+6df7,U+6e10,U+6e20-6e21,U+6f5c,U+706f,U+70bc,U+719f,U+7267,U+732a,U+73cd,U+7518,U+756a,U+7586,U+7591,U+75db,U+76c8,U+76d0,U+76d6,U+76d8,U+76df,U+76fe,U+77db,U+7801,U+786c,U+795d,U+7965,U+79cb,U+7a77,U+7a7f,U+7aef,U+7b11,U+7bb1,U+7bc7,U+7ea0,U+7eaf,U+7ed5,U+7edc,U+7f13,U+7f29,U+7f34,U+7f8a,U+7ffb,U+8015,U+8058,U+805a,U+8083,U+80af,U+80c6,U+80cc,U+811a,U+8150,U+82e5,U+8336,U+8352,U+83ab,U+8428,U+8463,U+852c,U+8861,U+89c8,U+8bcd,U+8bd7,U+8bda,U+8be2,U+8bef,U+8bf8,U+8c0b,U+8c13,U+8d34,U+8d3a,U+8d74,U+8d76,U+8da3,U+8dd1,U+8ddd,U+8ddf,U+8df3,U+8f68,U+8f6f,U+8f7d,U+8f91,U+8f9b,U+8fbd,U+8fc8,U+8fd4,U+8feb,U+8ff9,U+900f,U+9057,U+907f-9080,U+90d1,U+90ed,U+91ce,U+9519,U+9526,U+95ed,U+9614,U+9635,U+9644,U+9686,U+96c5,U+96ea,U+9707,U+9732,U+9759,U+978b,U+9876,U+9881,U+9910,U+996e,U+9970,U+9c81,U+9e21,U+9ebb,U+9f84" } }, { uri: tne, descriptors: { unicodeRange: "U+4e3d,U+4e4e,U+4e71,U+4e8f,U+4ed8,U+4eea,U+4f0a,U+4f0d,U+4f11,U+4f1f,U+4f24,U+4f3c,U+4f73,U+4fc4,U+500d,U+5012,U+501f,U+503a,U+505c,U+507f,U+50a8,U+514d,U+5178,U+517c,U+51b2,U+51b7,U+520a,U+5238,U+523b,U+52b1,U+535a,U+5371,U+5385,U+53eb-53ec,U+53f3,U+53f6,U+5409,U+542b,U+542f,U+5434,U+5462,U+5473,U+547c,U+54c8,U+54ea,U+56fa,U+5733,U+5757,U+5766,U+5802,U+585e,U+590f,U+591c,U+591f,U+5947,U+594b,U+5987,U+5a01,U+5b59,U+5b63,U+5b88,U+5b97,U+5b9c,U+5bbe,U+5bfb,U+5c01,U+5c1a,U+5c24,U+5c3c,U+5c97,U+5c9b,U+5cb8,U+5de6,U+5e01,U+5e2e,U+5e45,U+5e55,U+5e84,U+5ef6,U+5f02,U+5f52,U+5f69,U+5f7b,U+5f90,U+5fae,U+6000,U+600e,U+6025,U+60e0,U+6276,U+6297,U+62b5,U+62cd,U+62d3,U+62e5,U+62e9,U+62ff,U+6302,U+632f,U+63e1,U+6444,U+64ad,U+653b,U+6551,U+6563,U+65a4,U+65e7,U+6620,U+667a,U+66f2,U+671d,U+6731,U+6742,U+675f,U+6768,U+677e-677f,U+6790,U+67b6,U+67d3,U+6863,U+68b0,U+68c9,U+690d,U+6b8b,U+6bcd,U+6bd2,U+6bd5,U+6c38,U+6c61,U+6cbf,U+6cdb,U+6cf0,U+6d2a,U+6d89,U+6da6,U+6f6e,U+6fb3,U+7075,U+707e,U+70df,U+7164,U+7236,U+725b,U+7389,U+73e0,U+745e,U+74e6,U+751a,U+7537,U+75be,U+76ae,U+76db,U+793c,U+7956,U+7981,U+79d8,U+79df,U+79fb,U+7adf,U+7ae5,U+7b14,U+7b26,U+7b54,U+7b79,U+7d2f,U+7eb8,U+7eba,U+7ec6,U+7ee9,U+7eff,U+7f5a,U+7f6a,U+7f72,U+8089,U+80a5,U+80e1,U+8111,U+8131,U+821e,U+822c,U+8270,U+8499,U+8651,U+867d,U+8840,U+8857,U+8863,U+88c1,U+89c9,U+89d2,U+8a89,U+8bed,U+8bfe,U+8c01,U+8c22,U+8d21,U+8d25,U+8d2f,U+8d5e,U+8d75,U+8d8b,U+8dc3,U+8de8,U+8df5,U+8f6e,U+8f86,U+8f89,U+8fc5,U+8ff0,U+8ffd,U+9014,U+904d,U+90ae,U+9274,U+949f,U+952e,U+969c,U+96c4,U+96e8,U+96f6-96f7,U+97e9,U+987f,U+996d,U+9a7b,U+9aa8,U+9c7c,U+9c9c,U+9e4f,U+9f13,U+9f50" } }, { uri: nne, descriptors: { unicodeRange: "U+4e13,U+4e16,U+4e1c,U+4e24,U+4e3e,U+4e49,U+4e61,U+4e66,U+4e89,U+4e8c,U+4e94,U+4e9b,U+4ea4,U+4eac,U+4ebf,U+4eca,U+4ef6-4ef7,U+4efb,U+4f18,U+4f20,U+4f46,U+4f7f,U+4fe1,U+503c,U+505a,U+5146,U+5148,U+515a,U+5171,U+5177,U+519b,U+51b3,U+51c6,U+51e0,U+5212,U+521b,U+522b,U+529e,U+52bf,U+534e-534f,U+5355,U+5357,U+5382,U+539f,U+53bb,U+53bf,U+53c2,U+53c8,U+53ca,U+53d6-53d8,U+53e3,U+53ea,U+53f0,U+540d,U+5411,U+56db,U+56de,U+56e0,U+56e2,U+578b,U+57ce,U+57fa,U+589e,U+5904,U+5934,U+5982,U+5b89,U+5b8c,U+5bfc,U+5c06,U+5c11,U+5c40,U+5c71,U+5e38,U+5e72,U+5e76,U+5e7f,U+5e94,U+5e9c,U+5f0f,U+5f15,U+5f20,U+5f3a,U+5f62,U+5f88,U+5fc5,U+5fd7,U+5feb,U+601d,U+6027,U+60c5,U+60f3,U+610f,U+6216,U+6218,U+624b,U+624d,U+6279,U+628a,U+6295,U+6301,U+6307,U+636e,U+63a5,U+63a8,U+652f,U+6536,U+653e,U+6548,U+6559,U+6570,U+65bd,U+65e0,U+6602,U+660e,U+6613,U+66f4,U+6700,U+670d,U+671f,U+672f,U+6743,U+674e,U+6751,U+6761,U+6784,U+6797,U+679c,U+67e5,U+6807,U+6837,U+683c,U+6b21,U+6b63-6b65,U+6bcf,U+6bd4,U+6c42,U+6c5f,U+6ca1,U+6cbb,U+6d3b,U+6d41,U+6d88,U+6df1,U+70b9,U+7136,U+7269,U+7279,U+7531,U+754c,U+767e,U+76ca,U+76f8,U+770b,U+7740,U+7814,U+79ef,U+7a0b,U+7a0e,U+7a76,U+7b80,U+7cbe,U+7cfb,U+7e41,U+7ea7,U+7ec4,U+7ec7,U+7ed3,U+7ed9,U+7edf,U+7f8e,U+8001,U+804c,U+8054,U+80b2,U+81f3,U+8425,U+8868,U+88ab,U+897f,U+89c1-89c2,U+89c4,U+89c6,U+89e3,U+8ba1,U+8ba4,U+8bae,U+8bb0,U+8bba,U+8bc1,U+8c03,U+8d28,U+8d39,U+8def,U+8f66,U+8f6c,U+8fd0-8fd1,U+9020,U+9053,U+90a3,U+90fd,U+91cc,U+9500,U+9547,U+95e8,U+95f4,U+961f,U+9645,U+9662,U+96be,U+96c6,U+9700,U+9769,U+97e6,U+9875,U+9879,U+9886,U+9898,U+98ce,U+9996,U+2b5af,U+2cc56,U+2e9f5,U+30edd-30ede" } }, { uri: rne, descriptors: { unicodeRange: "U+4e03,U+4e30,U+4e34,U+4e45,U+4e60,U+4e70,U+4e88,U+4e91-4e92,U+4ea9,U+4eb2,U+4ec0,U+4ecb,U+4ecd,U+4ee4,U+4fee,U+5019,U+5047,U+50cf,U+5145,U+516d,U+5170,U+5175,U+5199,U+51cf,U+51fb,U+521a,U+5224,U+5267,U+52aa,U+5347-5348,U+534a,U+5356,U+5361,U+536b,U+5370,U+538b,U+53e4,U+53e6,U+5403,U+5426,U+5428,U+542c,U+5438,U+5668,U+56ed,U+56f4,U+56fe,U+57df,U+592a,U+5957,U+5b69,U+5b81,U+5b8f,U+5b98,U+5b9d,U+5ba1,U+5ba4,U+5bb3,U+5bc6,U+5bdf,U+5c3d,U+5c5e,U+5c81,U+5ddd,U+5de8,U+5dee,U+5e0c,U+5e86,U+5e8f,U+5e93,U+5e95,U+5e97,U+5ea7,U+5ead,U+5eb7,U+5f55,U+5f81,U+5f85,U+5ff5,U+6001,U+613f,U+6258,U+6267,U+6269,U+626c,U+627e,U+62db,U+62ec,U+6325,U+635f,U+6362,U+6388,U+6392,U+63a2,U+63a7,U+63aa,U+641e,U+6545,U+6597,U+65e2,U+65e9,U+661f,U+665a,U+666e-666f,U+66fe,U+6728,U+67d0,U+6811,U+6838,U+6865,U+697c,U+6b22,U+6b27,U+6b4c,U+6b62,U+6b66,U+6b7b,U+6bdb,U+6c47,U+6c49,U+6c7d,U+6c99,U+6cfd,U+6d0b,U+6d25,U+6d32,U+6d3e,U+6d4b,U+6e29,U+6e56,U+6e7e,U+6f14,U+6fc0,U+706b,U+70c8,U+7247,U+72af,U+72b6,U+72ec,U+732e,U+73ed,U+7403,U+7533,U+753b,U+7559,U+7565,U+7597,U+767b,U+773c,U+7763,U+77ed,U+77ff,U+7968,U+798f,U+79bb,U+79c0-79c1,U+7ad9,U+7ae0,U+7b51,U+7b7e,U+7cae,U+7d22,U+7ea2,U+7eb3,U+7eb7,U+7ec3,U+7ec8,U+7ecd,U+7edd,U+7efc,U+7f16,U+7f3a,U+7f51,U+7f57,U+7f6e,U+80dc,U+822a,U+8239,U+826f,U+82cf,U+82e6,U+8349,U+8363,U+83dc,U+8457,U+85cf,U+878d,U+8865,U+8a00,U+8b66,U+8ba2,U+8ba8,U+8bad,U+8bb2,U+8bc9,U+8bd5,U+8bfb,U+8d2b,U+8d35,U+8d37,U+8f7b,U+8f93,U+8fce,U+8fdd,U+9000-9002,U+9010,U+9047,U+9093,U+9152,U+9488,U+94a2,U+9633,U+9636,U+963f,U+9646,U+9648,U+964d,U+9664,U+9669,U+9760,U+97f3,U+987a,U+987e,U+9884,U+98de,U+9986,U+9ed1" } }, { uri: ine, descriptors: { unicodeRange: "U+4e14,U+4e25,U+4e48,U+4e50,U+4e5d,U+4e9a,U+4ec5,U+4efd,U+4f17,U+4f4e-4f4f,U+4f55,U+4f59,U+4f60,U+4f8b,U+4f9b,U+4f9d,U+4fbf,U+4fc3,U+5065,U+513f,U+5149,U+514b,U+516b,U+5174,U+517b,U+518d,U+51b5,U+5207,U+5217-5219,U+521d,U+526f,U+529f,U+52a9,U+52b3,U+5305,U+533b,U+5343,U+5360,U+5373-5374,U+5386,U+53cb-53cd,U+53f2,U+53f7,U+544a,U+5468,U+547d,U+54cd,U+552e,U+5584,U+56f0,U+571f,U+5747,U+575a,U+57f9,U+5883,U+58eb,U+58f0,U+5907,U+590d,U+592e,U+5931,U+5956,U+5965,U+5973,U+5979,U+59cb,U+5b57-5b58,U+5b83,U+5ba2-5ba3,U+5bb9,U+5bcc,U+5c42,U+5c45,U+5c4a,U+5dde,U+5df1,U+5df4,U+5e03,U+5e08,U+5e26,U+5e2d,U+5f71,U+5f80,U+5f8b,U+5fb7,U+606f,U+611f,U+6237,U+623f,U+6253,U+627f,U+6293,U+62a4,U+62c5,U+62c9,U+6309,U+6574,U+6599,U+65ad,U+65af,U+65c5,U+65cf,U+6625,U+663e,U+671b,U+672a,U+6750,U+6781,U+6821,U+6839,U+6848,U+68c0,U+6a21,U+6b3e,U+6bb5,U+6c14,U+6cb3,U+6cb9,U+6ce8,U+6e05,U+6e2f,U+6e38,U+6e90,U+6ee1,U+70ed,U+7167,U+7231,U+7248,U+724c,U+7387,U+738b,U+73af,U+7530,U+75c5,U+767d,U+76d1,U+76f4,U+771f,U+77e5,U+77f3,U+7834,U+7840,U+786e,U+793a,U+795e,U+79f0,U+7a33,U+7a7a,U+7a81,U+7ade,U+7b56,U+7b97,U+7c73,U+7c7b,U+7d20,U+7d27,U+7ea6,U+7eaa,U+7ebf,U+7ee7,U+7eed,U+7ef4,U+7fa4,U+8003,U+80a1,U+81f4,U+8272,U+827a,U+8282,U+82b1,U+82f1,U+8303,U+836f,U+83b7,U+843d,U+88c5,U+8ba9,U+8baf,U+8bb8,U+8bbf,U+8bc4,U+8bc6,U+8bdd,U+8be5,U+8bf7,U+8c08,U+8c61,U+8d1f,U+8d22-8d23,U+8d27,U+8d2d,U+8d38,U+8d5b,U+8d70,U+8d85,U+8d8a,U+8db3,U+8eab,U+8f83,U+8fb9,U+8fdc,U+8fde,U+9009,U+901f,U+914d,U+91c7,U+94b1,U+94c1,U+94f6,U+95fb,U+9632,U+9650,U+968f,U+9752,U+975e,U+987b,U+989d,U+98df,U+9999,U+9a6c,U+9a8c,U+9ec4,U+9feb-9fec" } }, { uri: ane, descriptors: { unicodeRange: "U+98fb-990c,U+990e-990f,U+9911-992d,U+992f-9953,U+9956-9962,U+9964,U+9966,U+9973,U+9978-9979,U+997b,U+997e,U+9982-9983,U+9989,U+998c,U+998e,U+999a-99a4,U+99a6-99a7,U+99a9-99c8" } }, { uri: lne, descriptors: { unicodeRange: "U+8e4c-8e50,U+8e53-8e58,U+8e5a-8e65,U+8e67-8e68,U+8e6a-8e6b,U+8e6e,U+8e71,U+8e73,U+8e75,U+8e77-8e7b,U+8e7d-8e7e,U+8e80,U+8e82-8e84,U+8e86,U+8e88-8e8e,U+8e91-8e93,U+8e95-8e9b,U+8e9d,U+8e9f-8eaa,U+8ead-8eae,U+8eb0-8eb1,U+8eb3-8eb9,U+8ebb-8ecd,U+8ecf-8f02" } }, { uri: sne, descriptors: { unicodeRange: "U+2e3a,U+3001-3002,U+3008-3011,U+3014-3017,U+301d-301f,U+4dae,U+4e00,U+4e07,U+4e09-4e0b,U+4e0d-4e0e,U+4e1a,U+4e2a,U+4e2d,U+4e3a-4e3b,U+4e4b,U+4e5f,U+4e86,U+4e8b,U+4e8e,U+4ea7,U+4eba,U+4ece,U+4ed1,U+4ed6,U+4ee3,U+4ee5,U+4eec,U+4f01,U+4f1a,U+4f4d,U+4f53,U+4f5c,U+4fdd,U+5143,U+5165,U+5168,U+516c,U+5173,U+5176,U+5185,U+519c,U+51fa,U+5206,U+5229,U+5230,U+5236,U+524d,U+529b,U+52a0-52a1,U+52a8,U+5316-5317,U+533a,U+5341,U+5362,U+53d1,U+53ef,U+53f8,U+5404,U+5408,U+540c,U+540e,U+5458,U+548c,U+54c1,U+54e5,U+5546,U+559c,U+56fd,U+5728,U+5730,U+573a,U+5916,U+591a,U+5927,U+5929,U+592b,U+597d,U+59d4,U+5b50,U+5b66,U+5b9a,U+5b9e,U+5bb6,U+5bf9,U+5c0f,U+5c14,U+5c31,U+5c55,U+5de5,U+5df2,U+5e02,U+5e73-5e74,U+5ea6,U+5efa,U+5f00,U+5f53,U+5f97,U+5fc3,U+603b,U+6210-6211,U+6240,U+6280,U+62a5,U+63d0,U+6539,U+653f,U+6587,U+65b0,U+65b9,U+65e5,U+65f6,U+662f,U+6708-6709,U+672c,U+673a,U+675c,U+6765,U+6c11,U+6c34,U+6cd5,U+6ce2,U+6d4e,U+6d77,U+73b0,U+7406,U+751f,U+7528,U+7535,U+7684,U+76ee,U+793e,U+79cd,U+79d1,U+7acb,U+7b2c,U+7b49,U+7ba1,U+7ecf,U+8005,U+800c,U+80fd,U+81ea,U+884c,U+8981,U+8bbe,U+8bf4,U+8d44,U+8d77,U+8fbe,U+8fc7,U+8fd8-8fd9,U+8fdb,U+901a,U+90e8,U+91cd,U+91cf,U+91d1,U+9485,U+957f,U+95ee,U+9762,U+9ad8,U+9ea6,U+9f99,U+9fcf,U+9fd4,U+9fed,U+fe10-fe19,U+fe30-fe31,U+fe33-fe44,U+ff01,U+ff0c,U+ff1f,U+2b4e7,U+2b7f7,U+2b7fc,U+2cb2d,U+2cb3b,U+2cb4a,U+2cb5b,U+2cb73" } }, { uri: one, descriptors: { unicodeRange: "U+6490,U+6493-6494,U+6497-6498,U+649a-649d,U+649f-64a3,U+64a5-64a8,U+64aa-64ab,U+64af,U+64b1-64b4,U+64b6,U+64b9,U+64bb,U+64bd-64bf,U+64c1,U+64c3-64c4,U+64c6-64cc,U+64cf,U+64d1,U+64d3-64d6,U+64d9-64dd,U+64df-64e1,U+64e3,U+64e5,U+64e7-64ff,U+6501-6508,U+650a-6511,U+6513-6517,U+6519-6524,U+6526-652a,U+652c-652d,U+6530-6533,U+6537,U+653a,U+653c-653d,U+6540-6544,U+6546-6547,U+654a-654b,U+654d-654e,U+6550,U+6552-6554,U+6557-6558,U+655a,U+655c,U+655f-6561,U+6564-6565,U+6567-6568" } }, { uri: cne, descriptors: { unicodeRange: "U+9695-9696,U+969a-969b,U+969d-96a6,U+96a8-96af,U+96b1-96b2,U+96b4-96b5,U+96b7-96b8,U+96ba-96bb,U+96bf,U+96c2-96c3,U+96c8,U+96ca-96cb,U+96d0-96d1,U+96d3-96d4,U+96d6-96df,U+96e1-96e7,U+96eb-96ee,U+96f0-96f2,U+96f4-96f5,U+96f8,U+96fa-96fd,U+96ff,U+9702-9703,U+9705,U+970a-970c,U+9710-9712,U+9714-9715,U+9717-971b,U+971d,U+971f-9729,U+972b-972c,U+972e-972f,U+9731,U+9733-9737,U+973a-973d,U+973f-9751,U+9754-9755,U+9757-9758,U+975a,U+975c-975d,U+975f,U+9763-9764,U+9766-9768,U+976a-9770" } }, { uri: dne, descriptors: { unicodeRange: "U+6af0-6b1f,U+6b25-6b26,U+6b28-6b31,U+6b33-6b36,U+6b38,U+6b3b-6b3d,U+6b3f-6b42,U+6b44-6b45,U+6b48,U+6b4a-6b4b,U+6b4d-6b58,U+6b5a-6b61,U+6b68-6b69,U+6b6b-6b78,U+6b7a,U+6b7d-6b80,U+6b85,U+6b88,U+6b8c,U+6b8e-6b91,U+6b94-6b95,U+6b97-6b99,U+6b9c-6ba0,U+6ba2-6ba9,U+6bab-6bb2,U+6bb6,U+6bb8-6bba" } }, { uri: une, descriptors: { unicodeRange: "U+430e-439a,U+29e8a,U+29ec4,U+29edb,U+29ee9,U+29f7e,U+29f83,U+29f8c,U+29fce,U+2a01a,U+2a02f,U+2a082,U+2a0f9,U+2a190,U+2a38c" } }, { uri: hne, descriptors: { unicodeRange: "U+92ef-933d,U+933f-9369,U+936b-9388" } }, { uri: fne, descriptors: { unicodeRange: "U+4512-458d,U+2b300,U+2b363,U+2b36f,U+2b372,U+2b37d,U+2b404,U+2b410,U+2b413,U+2b461,U+2b4ef,U+2b4f6,U+2b4f9,U+2b50d-2b50e,U+2b536,U+2b5ae,U+2b5b3,U+2b5e7,U+2b5f4,U+2b61c-2b61d,U+2b626-2b628,U+2b62a,U+2b62c,U+2b695-2b696,U+2b6ad,U+2b6ed" } }, { uri: pne, descriptors: { unicodeRange: "U+88bd-88c0,U+88c3-88c4,U+88c7-88c8,U+88ca-88cd,U+88cf-88d1,U+88d3,U+88d6-88d7,U+88da-88de,U+88e0-88e1,U+88e6-88e7,U+88e9-88ef,U+88f2,U+88f5-88f7,U+88fa-88fb,U+88fd,U+88ff-8901,U+8903-8909,U+890b-890f,U+8911,U+8914-8918,U+891c-8920,U+8922-8924,U+8926-8929,U+892c-892f,U+8931-8933,U+8935,U+8937-8940,U+8942-8943,U+8945-895d,U+8960-8965,U+8967-897a,U+897c-897e,U+8980,U+8982,U+8984-8985" } }, { uri: mne, descriptors: { unicodeRange: "U+4b0b-4ba0" } }, { uri: gne, descriptors: { unicodeRange: "U+7179,U+717b-717c,U+717e-7183,U+7185-7189,U+718b-718e,U+7190-7193,U+7195-7197,U+719a-719e,U+71a1-71a7,U+71a9-71ab,U+71ad-71b2,U+71b4,U+71b6-71b8,U+71ba-71c2,U+71c4-71cd,U+71cf-71d3,U+71d6-71df,U+71e1-71e4,U+71e6,U+71e8-71ed,U+71ef-71f8,U+71fa-7205,U+7207-721c,U+721e-7227,U+7229,U+722b,U+722d" } }, { uri: bne, descriptors: { unicodeRange: "U+982e-9874,U+988b,U+988e,U+9892,U+9895,U+9899,U+98a3,U+98a8-98cd,U+98cf-98d0,U+98d4,U+98d6-98d7,U+98db-98dd,U+98e0-98e6,U+98e9-98fa" } }, { uri: Une, descriptors: { unicodeRange: "U+7c14-7c15,U+7c17-7c1e,U+7c20-7c25,U+7c28-7c29,U+7c2b-7c37,U+7c39-7c3e,U+7c42-7c4c,U+7c4e-7c72,U+7c75-7c7a,U+7c7e-7c88,U+7c8a-7c90,U+7c93-7c94,U+7c96,U+7c99-7c9b,U+7ca0-7ca1,U+7ca3,U+7ca6-7ca9,U+7cab-7cad,U+7caf-7cb0,U+7cb4-7cb8,U+7cba-7cbb,U+7cbf-7cc0,U+7cc2-7cc4,U+7cc6,U+7cc9,U+7ccb,U+7cce-7cd4" } }, { uri: vne, descriptors: { unicodeRange: "U+7d95-7da5,U+7da7-7dad,U+7daf-7e2a" } }, { uri: yne, descriptors: { unicodeRange: "U+4a78-4b0a" } }, { uri: wne, descriptors: { unicodeRange: "U+9b30-9b31,U+9b33-9b3a,U+9b3d-9b40,U+9b46,U+9b4a-9b4c,U+9b4e,U+9b50,U+9b52-9b53,U+9b55-9bcf" } }, { uri: xne, descriptors: { unicodeRange: "U+6a4b-6a4f,U+6a51-6a57,U+6a5a,U+6a5c-6a60,U+6a62-6a64,U+6a66-6a70,U+6a72-6a78,U+6a7a-6a7b,U+6a7d-6a7f,U+6a81-6a83,U+6a85-6a8d,U+6a8f,U+6a92-6a96,U+6a98-6a9f,U+6aa1-6aa8,U+6aaa,U+6aad-6aef" } }, { uri: Ene, descriptors: { unicodeRange: "U+99c9-9a53" } }, { uri: Sne, descriptors: { unicodeRange: "U+8550-8555,U+8557-8558,U+855a-855d,U+855f-8563,U+8565-8567,U+8569-8571,U+8573,U+8575-8578,U+857c-857d,U+857f-8583,U+8586,U+8588-858e,U+8590-859a,U+859d-85a3,U+85a5-85a7,U+85a9,U+85ab-85ad,U+85b1-85b6,U+85b8,U+85ba-85c0,U+85c2-85c8,U+85ca-85ce,U+85d1-85d2,U+85d4,U+85d6-85db,U+85dd-85e3,U+85e5-85e8,U+85ea-85fa,U+85fc-85fe,U+8600-8603" } }, { uri: _ne, descriptors: { unicodeRange: "U+6fb2,U+6fb4-6fb5,U+6fb7-6fb8,U+6fba-6fbf,U+6fc1,U+6fc3-6fc8,U+6fca-6fd0,U+6fd3-6fdd,U+6fdf,U+6fe2-6fed,U+6ff0-7010,U+7012-7019,U+701c-7022,U+7024-7034,U+7036-7038,U+703a-704b,U+704d-704e,U+7050-7053" } }, { uri: kne, descriptors: { unicodeRange: "U+4ba1-4c2c" } }, { uri: Cne, descriptors: { unicodeRange: "U+9a54-9a6b,U+9a72,U+9a83,U+9a89,U+9a8d-9a8e,U+9a94-9a95,U+9a99,U+9aa6,U+9aa9-9aaf,U+9ab2-9ab5,U+9ab9,U+9abb,U+9abd-9abf,U+9ac3-9ac4,U+9ac6-9aca,U+9acd-9ad0,U+9ad2,U+9ad4-9ad7,U+9ad9-9ade,U+9ae0,U+9ae2-9ae5,U+9ae7-9aea,U+9aec,U+9aee,U+9af0-9af8,U+9afa,U+9afc-9b02,U+9b04-9b07,U+9b09-9b0e,U+9b10-9b12,U+9b14-9b1e,U+9b20-9b22,U+9b24-9b2e" } }, { uri: Mne, descriptors: { unicodeRange: "U+9d1a-9da1" } }, { uri: Tne, descriptors: { unicodeRange: "U+9e13-9e1e,U+9e24,U+9e27,U+9e2e,U+9e30,U+9e34,U+9e3b-9e3c,U+9e40,U+9e4d,U+9e50,U+9e52-9e54,U+9e56,U+9e59,U+9e5d,U+9e5f-9e62,U+9e65,U+9e6e-9e6f,U+9e72,U+9e74-9e7d,U+9e80-9e81,U+9e83-9e86,U+9e89-9e8a,U+9e8c-9e91,U+9e94-9e9c,U+9e9e,U+9ea0-9ea5,U+9ea7-9eb3,U+9eb5-9eb7,U+9eb9-9eba,U+9ebc,U+9ebf-9ec3,U+9ec5-9ec8,U+9eca-9ecc,U+9ed0,U+9ed2-9ed3,U+9ed5-9ed7,U+9ed9-9eda,U+9ede,U+9ee1,U+9ee3-9ee4,U+9ee6,U+9ee8,U+9eeb-9eee,U+9ef0-9ef8" } }, { uri: Ine, descriptors: { unicodeRange: "U+8b1c-8b25,U+8b27-8b65,U+8b67-8b6b,U+8b6d-8b9f,U+8bac,U+8bb1,U+8bbb,U+8bc7,U+8bd0" } }, { uri: Ane, descriptors: { unicodeRange: "U+4cad-4d2f" } }, { uri: Nne, descriptors: { unicodeRange: "U+9c4b-9c7b,U+9c7d-9c7e,U+9c80,U+9c83-9c84,U+9c89-9c8a,U+9c8c,U+9c8f,U+9c93,U+9c96-9c99,U+9c9d,U+9caa,U+9cac,U+9caf,U+9cb9,U+9cbe-9cc2,U+9cc8-9cc9,U+9cd1-9cd2,U+9cda-9cdb,U+9ce0-9ce1,U+9ce3-9d19" } }, { uri: Dne, descriptors: { unicodeRange: "U+9389-938e,U+9390-93c9,U+93cb-93d5,U+93d7-9410" } }, { uri: Lne, descriptors: { unicodeRange: "U+20a0-20b5,U+20b9-20ba,U+20bc-20bd,U+4e2c,U+5107,U+5216,U+5293,U+54f3,U+5523,U+5819,U+5adc,U+5c88,U+5e3b,U+5fee,U+62f6,U+63be,U+6484,U+6499,U+67d9,U+67dd,U+6d5e,U+6f46,U+717a,U+71e0,U+72c1,U+73e7,U+75b0,U+7603,U+7722,U+7809,U+7811,U+7946,U+7967,U+799a,U+7b45,U+7ba2,U+8014,U+80d9,U+8159,U+817d,U+81a3,U+81aa,U+8201,U+833c,U+836e,U+83e5,U+8459,U+84f0,U+8729,U+8753,U+87d3,U+89dc,U+8bf6,U+8c2e,U+8e2c,U+8e9c,U+8e9e,U+8ece,U+8fee,U+9139,U+914f,U+9174,U+9191,U+960c,U+9622,U+9a98,U+9b48,U+9ca6,U+9cb0,U+9da2-9e12,U+9e88,U+9f44,U+9f86" } }, { uri: Rne, descriptors: { unicodeRange: "U+9bd0-9c4a" } }, { uri: Pne, descriptors: { unicodeRange: "U+4c2d-4cac" } }, { uri: One, descriptors: { unicodeRange: "U+4d30-4dab" } }, { uri: $ne, descriptors: { unicodeRange: "U+9411-943d,U+943f-946a,U+946c-9484" } }, { uri: Fne, descriptors: { unicodeRange: "U+9efa,U+9efd,U+9eff-9f0a,U+9f0c,U+9f0f,U+9f11-9f12,U+9f14-9f16,U+9f18,U+9f1a-9f1f,U+9f21,U+9f23-9f2b,U+9f2d-9f2e,U+9f30-9f36,U+9f38,U+9f3a,U+9f3c,U+9f3f-9f43,U+9f45-9f4f,U+9f52-9f7e,U+9f81-9f82,U+9f8d-9f94" } }, { uri: zne, descriptors: { unicodeRange: "U+7e2b-7e3a,U+7e3c-7e40,U+7e42-7e46,U+7e48-7e81,U+7e83-7e9a,U+7e9c-7e9e,U+7eae,U+7eb4,U+7ebb-7ebc,U+7ed6,U+7ee4,U+7eec,U+7ef9,U+7f0a,U+7f10,U+7f1e,U+7f37,U+7f39,U+7f3b" } }], Gs = class Vt {
  constructor(t) {
    $(this, "scene"), $(this, "getSceneFamilies", () => Vt.getUniqueFamilies(this.scene.getNonDeletedElements())), $(this, "onLoaded", (n) => {
      let r = !0;
      for (let l of n) {
        let s = `${l.family}-${l.style}-${l.weight}-${l.unicodeRange}`;
        Vt.loadedFontsCache.has(s) || (Vt.loadedFontsCache.add(s), r = !1);
      }
      if (r) return;
      let i = !1, a = this.scene.getNonDeletedElementsMap();
      for (let l of this.scene.getNonDeletedElements()) if (we(l)) {
        i = !0, wn.delete(l), Xf.clearCache(Wt(l));
        let s = xr(l, a);
        s && wn.delete(s);
      }
      i && this.scene.triggerUpdate();
    }), $(this, "loadSceneFonts", async () => {
      let n = this.getSceneFamilies(), r = Vt.getCharsPerFamily(this.scene.getNonDeletedElements());
      return Vt.loadFontFaces(n, r);
    }), this.scene = t;
  }
  static get registered() {
    return Vt._registered ? Vt._initialized || (Vt._registered = new Map([...Vt.init().entries(), ...Vt._registered.entries()])) : Vt._registered = Vt.init(), Vt._registered;
  }
  get registered() {
    return Vt.registered;
  }
  static async generateFontFaceDeclarations(t) {
    let n = Vt.getUniqueFamilies(t), r = Vt.getCharsPerFamily(t), i = n.find((c) => CI(c).includes(Od));
    if (i) {
      let c = Vt.getCharacters(r, i);
      if (uq(c)) {
        let d = $d[Od];
        r[d] = new Set(c), n.unshift($d[Od]);
      }
    }
    let a = Vt.fontFacesStylesGenerator(n, r), l = 3, s = await new Zw(a, l).all();
    return Array.from(new Set(s));
  }
  static async loadFontFaces(t, n) {
    for (let { fontFaces: a, metadata: l } of Vt.registered.values()) if (!l.local) for (let { fontFace: s } of a) window.document.fonts.has(s) || window.document.fonts.add(s);
    let r = Vt.fontFacesLoader(t, n), i = 10;
    return (await new Zw(r, i).all()).flat().filter(Boolean);
  }
  static *fontFacesLoader(t, n) {
    for (let [r, i] of t.entries()) {
      let a = Wt({ fontFamily: i, fontSize: 16 }), l = Vt.getCharacters(n, i);
      window.document.fonts.check(a, l) || (yield U0(async () => {
        var s;
        try {
          let c = await window.document.fonts.load(a, l);
          return [r, c];
        } catch (c) {
          console.error(`Failed to load font "${a}" from urls "${(s = Vt.registered.get(i)) == null ? void 0 : s.fontFaces.map((d) => d.urls)}"`, c);
        }
      }));
    }
  }
  static *fontFacesStylesGenerator(t, n) {
    for (let [r, i] of t.entries()) {
      let { fontFaces: a, metadata: l } = Vt.registered.get(i) ?? {};
      if (!Array.isArray(a)) {
        console.error(`Couldn't find registered fonts for font-family "${i}"`, Vt.registered);
        continue;
      }
      if (!(l != null && l.local)) for (let [s, c] of a.entries()) yield U0(async () => {
        try {
          let d = Vt.getCharacters(n, i), o = await c.toCSS(d);
          return o ? [r * 1e4 + s, o] : void 0;
        } catch (d) {
          console.error(`Couldn't transform font-face to css for family "${c.fontFace.family}"`, d);
        }
      });
    }
  }
  static register(t, n, ...r) {
    let i = Un[t] ?? $d[t];
    return this.registered.get(i) || this.registered.set(i, { metadata: n, fontFaces: r.map(({ uri: a, descriptors: l }) => new bJ(t, a, l)) }), this.registered;
  }
  static init() {
    let t = { registered: /* @__PURE__ */ new Map() }, n = (r, ...i) => {
      let a = Un[r] ?? $d[r], l = Mm[a] ?? Mm[Un.Excalifont];
      Vt.register.call(t, r, l, ...i);
    };
    return n("Cascadia", ...vJ), n("Comic Shanns", ...SJ), n("Excalifont", ...DJ), n("Helvetica", ...LJ), n("Liberation Sans", ...PJ), n("Lilita One", ...FJ), n("Nunito", ...VJ), n("Virgil", ...jJ), n(Od, ...Bne), n(Gh, ..._J), Vt._initialized = !0, t.registered;
  }
  static getUniqueFamilies(t) {
    return Array.from(t.reduce((n, r) => (we(r) && n.add(r.fontFamily), n), /* @__PURE__ */ new Set()));
  }
  static getCharsPerFamily(t) {
    let n = {};
    for (let r of t) if (we(r)) for (let i of r.originalText) n[r.fontFamily] || (n[r.fontFamily] = /* @__PURE__ */ new Set()), n[r.fontFamily].add(i);
    return n;
  }
  static getCharacters(t, n) {
    return t[n] ? Array.from(t[n]).join("") : "";
  }
  static getAllFamilies() {
    return Array.from(Vt.registered.keys());
  }
};
$(Gs, "loadedFontsCache", /* @__PURE__ */ new Set()), $(Gs, "_registered"), $(Gs, "_initialized", !1), $(Gs, "loadElementsFonts", async (e) => {
  let t = Gs.getUniqueFamilies(e), n = Gs.getCharsPerFamily(e);
  return Gs.loadFontFaces(t, n);
});
var ds = Gs, wA = (e, t, n) => {
  var c;
  let { unitsPerEm: r, ascender: i, descender: a } = ((c = ds.registered.get(e)) == null ? void 0 : c.metadata.metrics) || Mm[Un.Virgil].metrics, l = t / r, s = (n - l * i + l * a) / 2;
  return l * i + s;
}, Yc = (e) => {
  var n;
  let { lineHeight: t } = ((n = ds.registered.get(e)) == null ? void 0 : n.metadata.metrics) || Mm[Un.Excalifont].metrics;
  return t;
}, xA = (e) => {
  let { angle: t, width: n, height: r, x: i, y: a } = e, l = i + n / 2, s = a + r / 2, c = T(l, s), d;
  return e.type === "diamond" ? d = Gw(te(T(l, a), c, t), te(T(i + n, s), c, t), te(T(l, a + r), c, t), te(T(i, s), c, t)) : d = Gw(te(T(i, a), c, t), te(T(i + n, a), c, t), te(T(i + n, a + r), c, t), te(T(i, a + r), c, t)), { type: "polygon", data: d };
}, Hne = (e, t, n = 10) => {
  let [r, i, a, l, s, c] = tt(e, t, !0);
  r -= n, a += n, i -= n, l += n;
  let d = T(s, c), o = te(T(r, i), d, e.angle), u = te(T(a, i), d, e.angle), h = te(T(r, l), d, e.angle), f = te(T(a, l), d, e.angle);
  return { type: "polygon", data: [o, u, f, h] };
}, Wne = (e) => {
  let { width: t, height: n, angle: r, x: i, y: a } = e;
  return { type: "ellipse", data: { center: T(i + t / 2, a + n / 2), angle: r, halfWidth: t / 2, halfHeight: n / 2 } };
}, $o = (e) => {
  if (!e) return [];
  for (let t of e.sets) if (t.type === "path") return t.ops;
  return e.sets[0].ops;
}, Xne = (e, t = T(0, 0), n, r) => {
  let i = (c) => te(T(c[0] + t[0], c[1] + t[1]), r, n), a = $o(e), l = [], s = T(0, 0);
  for (let c of a) {
    if (c.op === "move") {
      let d = g8(c.data);
      Or(d != null, "Ops data is not a point"), s = i(d);
    }
    if (c.op === "bcurveTo") {
      let d = i(T(c.data[0], c.data[1])), o = i(T(c.data[2], c.data[3])), u = i(T(c.data[4], c.data[5]));
      l.push(rs(s, d, o, u)), s = u;
    }
  }
  return { type: "polycurve", data: l };
}, Vne = (e) => {
  let t = e[0], n = [];
  for (let r = 1; r < e.length; r++) {
    let i = e[r];
    n.push(Re(t, i)), t = i;
  }
  return n;
}, Gne = (e, t, n = !1) => {
  let r = (a) => te(pt(io(Le(a), _r(e.x, e.y))), t, e.angle), i = Vne(e.points.map((a) => r(a)));
  return n ? { type: "polygon", data: Em(i.flat()) } : { type: "polyline", data: i };
}, jne = (e, t, n = T(0, 0), r, i) => {
  let a = (o) => te(T(o[0] + n[0], o[1] + n[1]), i, r);
  if (e.roundness === null) return { type: "polygon", data: Em(e.points.map((o) => a(o))) };
  let l = $o(t), s = [], c = !1;
  for (let o of l) o.op === "move" ? (c = !c, c && s.push(T(o.data[0], o.data[1]))) : o.op === "bcurveTo" ? c && (s.push(T(o.data[0], o.data[1])), s.push(T(o.data[2], o.data[3])), s.push(T(o.data[4], o.data[5]))) : o.op === "lineTo" && c && s.push(T(o.data[0], o.data[1]));
  let d = _K(s, 10, 5).map((o) => a(o));
  return { type: "polygon", data: Em(d) };
}, Kne = (e, t) => {
  let { angle: n, halfWidth: r, halfHeight: i, center: a } = t, l = r, s = i, c = io(Le(e), An(Le(a), -1)), [d, o] = te(pt(c), T(0, 0), -n), u = Math.abs(d), h = Math.abs(o), f = 0.707, p = 0.707;
  for (let v = 0; v < 3; v++) {
    let U = l * f, y = s * p, w = (l * l - s * s) * f ** 3 / l, x = (s * s - l * l) * p ** 3 / s, E = U - w, S = y - x, _ = u - w, k = h - x, M = Math.hypot(S, E), A = Math.hypot(k, _);
    f = Math.min(1, Math.max(0, (_ * M / A + w) / l)), p = Math.min(1, Math.max(0, (k * M / A + x) / s));
    let L = Math.hypot(p, f);
    f /= L, p /= L;
  }
  let [g, b] = [l * f * Math.sign(d), s * p * Math.sign(o)];
  return Tt(T(d, o), T(g, b));
}, Yne = (e, t, n = 1e-4) => Kne(e, t) <= n, qne = (e, t) => {
  let { center: n, angle: r, halfWidth: i, halfHeight: a } = t, l = io(Le(e), An(Le(n), -1)), [s, c] = te(pt(l), T(0, 0), -r);
  return s / i * (s / i) + c / a * (c / a) <= 1;
}, u7 = (e, t, n = 0) => {
  switch (t.type) {
    case "polygon":
      return PY(e, t.data, n);
    case "ellipse":
      return Yne(e, t.data, n);
    case "line":
      return Xc(e, t.data, n);
    case "polyline":
      return SA(e, t.data, n);
    case "curve":
      return EA(e, t.data, n);
    case "polycurve":
      return Zne(e, t.data, n);
    default:
      throw Error(`shape ${t} is not implemented`);
  }
}, Tm = (e, t) => {
  switch (t.type) {
    case "polygon":
      return jw(e, t.data);
    case "line":
      return !1;
    case "curve":
      return !1;
    case "ellipse":
      return qne(e, t.data);
    case "polyline": {
      let n = Em(t.data.flat());
      return jw(e, n);
    }
    case "polycurve":
      return !1;
    default:
      throw Error(`shape ${t} is not implemented`);
  }
}, Zne = (e, t, n) => t.some((r) => EA(e, r, n)), Jne = (e) => {
  let [t, n, r, i] = e;
  return (a, l) => Math.pow(1 - a, 3) * i[l] + 3 * a * Math.pow(1 - a, 2) * r[l] + 3 * Math.pow(a, 2) * (1 - a) * n[l] + t[l] * Math.pow(a, 3);
}, Qne = (e, t = 10) => {
  let n = Jne(e), r = [n(0, 0), n(0, 1)], i = [], a = 0, l = 1 / t;
  for (let s = 0; s < t; s++) if (a += l, a <= 1) {
    let c = T(n(a, 0), n(a, 1));
    i.push(Re(r, c)), r = c;
  }
  return i;
}, EA = (e, t, n) => SA(e, Qne(t), n), SA = (e, t, n = 1e-4) => t.some((r) => Xc(e, r, n));
function _A(e, t, n) {
  return { center: e, halfWidth: t, halfHeight: n };
}
var ere = (e, t) => {
  let { halfWidth: n, halfHeight: r, center: i } = t, a = n, l = r, s = io(Le(e), An(Le(i), -1)), c = Math.abs(s[0]), d = Math.abs(s[1]), o = 0.707, u = 0.707;
  for (let p = 0; p < 3; p++) {
    let g = a * o, b = l * u, v = (a * a - l * l) * o ** 3 / a, U = (l * l - a * a) * u ** 3 / l, y = g - v, w = b - U, x = c - v, E = d - U, S = Math.hypot(w, y), _ = Math.hypot(E, x);
    o = Math.min(1, Math.max(0, (x * S / _ + v) / a)), u = Math.min(1, Math.max(0, (E * S / _ + U) / l));
    let k = Math.hypot(u, o);
    o /= k, u /= k;
  }
  let [h, f] = [a * o * Math.sign(s[0]), l * u * Math.sign(s[1])];
  return Tt(pt(s), T(h, f));
};
function tre({ center: e, halfWidth: t, halfHeight: n }, [r, i]) {
  let [a, l] = e, s = r[0] - a, c = r[1] - l, d = i[0] - a, o = i[1] - l, u = Math.pow(d - s, 2) / Math.pow(t, 2) + Math.pow(o - c, 2) / Math.pow(n, 2), h = 2 * (s * (d - s) / Math.pow(t, 2) + c * (o - c) / Math.pow(n, 2)), f = Math.pow(s, 2) / Math.pow(t, 2) + Math.pow(c, 2) / Math.pow(n, 2) - 1, p = (-h + Math.sqrt(Math.pow(h, 2) - 4 * u * f)) / (2 * u), g = (-h - Math.sqrt(Math.pow(h, 2) - 4 * u * f)) / (2 * u), b = [T(s + p * (d - s) + a, c + p * (o - c) + l), T(s + g * (d - s) + a, c + g * (o - c) + l)].filter((v) => !isNaN(v[0]) && !isNaN(v[1]));
  return b.length === 2 && Ra(b[0], b[1]) ? [b[0]] : b;
}
function kA(e, t = 0) {
  let n = Aa(Math.min(e.width, e.height), e);
  if (n <= 0) {
    let u = r7(T(e.x - t, e.y - t), T(e.x + e.width + t, e.y + e.height + t)), h = Re(T(u[0][0] + n, u[0][1]), T(u[1][0] - n, u[0][1])), f = Re(T(u[1][0], u[0][1] + n), T(u[1][0], u[1][1] - n)), p = Re(T(u[0][0] + n, u[1][1]), T(u[1][0] - n, u[1][1])), g = Re(T(u[0][0], u[1][1] - n), T(u[0][0], u[0][1] + n));
    return [[h, f, p, g], []];
  }
  let r = T(e.x + e.width / 2, e.y + e.height / 2), i = r7(T(e.x, e.y), T(e.x + e.width, e.y + e.height)), a = Re(T(i[0][0] + n, i[0][1]), T(i[1][0] - n, i[0][1])), l = Re(T(i[1][0], i[0][1] + n), T(i[1][0], i[1][1] - n)), s = Re(T(i[0][0] + n, i[1][1]), T(i[1][0] - n, i[1][1])), c = Re(T(i[0][0], i[1][1] - n), T(i[0][0], i[0][1] + n)), d = [An(Rr(Le(T(i[0][0] - t, i[0][1] - t), r)), t), An(Rr(Le(T(i[1][0] + t, i[0][1] - t), r)), t), An(Rr(Le(T(i[1][0] + t, i[1][1] + t), r)), t), An(Rr(Le(T(i[0][0] - t, i[1][1] + t), r)), t)], o = [rs(pt(d[0], c[1]), pt(d[0], T(c[1][0] + 2 / 3 * (i[0][0] - c[1][0]), c[1][1] + 2 / 3 * (i[0][1] - c[1][1]))), pt(d[0], T(a[0][0] + 2 / 3 * (i[0][0] - a[0][0]), a[0][1] + 2 / 3 * (i[0][1] - a[0][1]))), pt(d[0], a[0])), rs(pt(d[1], a[1]), pt(d[1], T(a[1][0] + 2 / 3 * (i[1][0] - a[1][0]), a[1][1] + 2 / 3 * (i[0][1] - a[1][1]))), pt(d[1], T(l[0][0] + 2 / 3 * (i[1][0] - l[0][0]), l[0][1] + 2 / 3 * (i[0][1] - l[0][1]))), pt(d[1], l[0])), rs(pt(d[2], l[1]), pt(d[2], T(l[1][0] + 2 / 3 * (i[1][0] - l[1][0]), l[1][1] + 2 / 3 * (i[1][1] - l[1][1]))), pt(d[2], T(s[1][0] + 2 / 3 * (i[1][0] - s[1][0]), s[1][1] + 2 / 3 * (i[1][1] - s[1][1]))), pt(d[2], s[1])), rs(pt(d[3], s[0]), pt(d[3], T(s[0][0] + 2 / 3 * (i[0][0] - s[0][0]), s[0][1] + 2 / 3 * (i[1][1] - s[0][1]))), pt(d[3], T(c[0][0] + 2 / 3 * (i[0][0] - c[0][0]), c[0][1] + 2 / 3 * (i[1][1] - c[0][1]))), pt(d[3], c[0]))];
  return [[Re(o[0][3], o[1][0]), Re(o[1][3], o[2][0]), Re(o[2][3], o[3][0]), Re(o[3][3], o[0][0])], o];
}
function CA(e, t = 0) {
  var y;
  let [n, r, i, a, l, s, c, d] = jA(e), o = Aa(Math.abs(n - c), e), u = Aa(Math.abs(a - r), e);
  if (((y = e.roundness) == null ? void 0 : y.type) == null) {
    let [w, x, E, S] = [T(e.x + n, e.y + r - t), T(e.x + i + t, e.y + a), T(e.x + l, e.y + s + t), T(e.x + c - t, e.y + d)], _ = Re(T(w[0] + o, w[1] + u), T(x[0] - o, x[1] - u)), k = Re(T(x[0] - o, x[1] + u), T(E[0] + o, E[1] - u)), M = Re(T(E[0] - o, E[1] - u), T(S[0] + o, S[1] + u)), A = Re(T(S[0] + o, S[1] - u), T(w[0] - o, w[1] + u));
    return [[_, k, M, A], []];
  }
  let h = T(e.x + e.width / 2, e.y + e.height / 2), [f, p, g, b] = [T(e.x + n, e.y + r), T(e.x + i, e.y + a), T(e.x + l, e.y + s), T(e.x + c, e.y + d)], v = [An(Rr(Le(p, h)), t), An(Rr(Le(g, h)), t), An(Rr(Le(b, h)), t), An(Rr(Le(f, h)), t)], U = [rs(pt(v[0], T(p[0] - o, p[1] - u)), pt(v[0], p), pt(v[0], p), pt(v[0], T(p[0] - o, p[1] + u))), rs(pt(v[1], T(g[0] + o, g[1] - u)), pt(v[1], g), pt(v[1], g), pt(v[1], T(g[0] - o, g[1] - u))), rs(pt(v[2], T(b[0] + o, b[1] + u)), pt(v[2], b), pt(v[2], b), pt(v[2], T(b[0] + o, b[1] - u))), rs(pt(v[3], T(f[0] - o, f[1] + u)), pt(v[3], f), pt(v[3], f), pt(v[3], T(f[0] + o, f[1] + u)))];
  return [[Re(U[0][3], U[1][0]), Re(U[1][3], U[2][0]), Re(U[2][3], U[3][0]), Re(U[3][3], U[0][0])], U];
}
var h7 = (e) => {
  if (e.type === "arrow") return !1;
  let t = !Ea(e.backgroundColor) || ra(e) || Bi(e) || we(e);
  return e.type === "line" || e.type === "freedraw" ? t && Us(e.points) : t || Mt(e);
}, Nd = ({ x: e, y: t, element: n, shape: r, threshold: i = 10, frameNameBound: a = null }) => {
  let l = h7(n) && Tm(T(e, t), r) || u7(T(e, t), r, i);
  return !l && a && (l = Tm(T(e, t), { type: "polygon", data: xA(a).data })), l;
}, A8 = (e, t, n, r, i = 0) => {
  let [a, l, s, c] = Oa(n, r);
  return a -= i, l -= i, s += i, c += i, LI(T(a, l), T(e, t), T(s, c));
}, nre = (e, t) => !Nd(e) && !MA(e.x, e.y, IA(e.element, t)) && A8(e.x, e.y, e.element, t), MA = (e, t, n) => !!n && Tm(T(e, t), n), TA = (e, t, n = 0) => {
  switch (e.type) {
    case "rectangle":
    case "image":
    case "text":
    case "iframe":
    case "embeddable":
    case "frame":
    case "magicframe":
      return rre(e, t, n);
    case "diamond":
      return ire(e, t, n);
    case "ellipse":
      return are(e, t, n);
    default:
      throw new Error(`Unimplemented element type '${e.type}'`);
  }
}, rre = (e, t, n = 0) => {
  let r = T(e.x + e.width / 2, e.y + e.height / 2), i = te(t[0], r, -e.angle), a = te(t[1], r, -e.angle), [l, s] = kA(e, n);
  return [...l.map((c) => Yh(Re(i, a), c)).filter((c) => c != null).map((c) => te(c, r, e.angle)), ...s.flatMap((c) => RI(c, Re(i, a))).filter((c) => c != null).map((c) => te(c, r, e.angle))].filter((c, d, o) => o.findIndex((u) => Ra(c, u)) === d);
}, ire = (e, t, n = 0) => {
  let r = T(e.x + e.width / 2, e.y + e.height / 2), i = te(t[0], r, -e.angle), a = te(t[1], r, -e.angle), [l, s] = CA(e, n);
  return [...l.map((c) => Yh(Re(i, a), c)).filter((c) => c != null).map((c) => te(c, r, e.angle)), ...s.flatMap((c) => RI(c, Re(i, a))).filter((c) => c != null).map((c) => te(c, r, e.angle))].filter((c, d, o) => o.findIndex((u) => Ra(c, u)) === d);
}, are = (e, t, n = 0) => {
  let r = T(e.x + e.width / 2, e.y + e.height / 2), i = te(t[0], r, -e.angle), a = te(t[1], r, -e.angle);
  return tre(_A(r, e.width / 2 + n, e.height / 2 + n), n7(i, a)).map((l) => te(l, r, e.angle));
}, xt = { EQUAL: "Equal", MINUS: "Minus", NUM_ADD: "NumpadAdd", NUM_SUBTRACT: "NumpadSubtract", NUM_ZERO: "Numpad0", BRACKET_RIGHT: "BracketRight", BRACKET_LEFT: "BracketLeft", ONE: "Digit1", TWO: "Digit2", THREE: "Digit3", QUOTE: "Quote", ZERO: "Digit0", SLASH: "Slash", C: "KeyC", D: "KeyD", H: "KeyH", V: "KeyV", Z: "KeyZ", Y: "KeyY", R: "KeyR", S: "KeyS" }, H = { ARROW_DOWN: "ArrowDown", ARROW_LEFT: "ArrowLeft", ARROW_RIGHT: "ArrowRight", ARROW_UP: "ArrowUp", PAGE_UP: "PageUp", PAGE_DOWN: "PageDown", BACKSPACE: "Backspace", ALT: "Alt", CTRL_OR_CMD: xl ? "metaKey" : "ctrlKey", DELETE: "Delete", ENTER: "Enter", ESCAPE: "Escape", QUESTION_MARK: "?", SPACE: " ", TAB: "Tab", CHEVRON_LEFT: "<", CHEVRON_RIGHT: ">", PERIOD: ".", COMMA: ",", SLASH: "/", A: "a", D: "d", E: "e", F: "f", G: "g", H: "h", I: "i", L: "l", O: "o", P: "p", Q: "q", R: "r", S: "s", T: "t", V: "v", X: "x", Y: "y", Z: "z", K: "k", 0: "0", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9" }, lre = /* @__PURE__ */ new Map([[H.Z, xt.Z], [H.Y, xt.Y]]), sre = (e) => /^[a-z]$/.test(e.toLowerCase()), f7 = (e, t) => {
  if (t === e.key.toLowerCase()) return !0;
  let n = lre.get(t);
  return !!(n && !sre(e.key) && e.code === n);
}, ju = (e) => e === H.ARROW_LEFT || e === H.ARROW_RIGHT || e === H.ARROW_DOWN || e === H.ARROW_UP, Y6 = (e) => e.altKey, Eu = (e) => e.shiftKey, bh = (e) => e.shiftKey, N8 = [{ icon: Mq, value: "selection", key: H.V, numericKey: H[1], fillable: !0 }, { icon: Tq, value: "rectangle", key: H.R, numericKey: H[2], fillable: !0 }, { icon: Iq, value: "diamond", key: H.D, numericKey: H[3], fillable: !0 }, { icon: Aq, value: "ellipse", key: H.O, numericKey: H[4], fillable: !0 }, { icon: Nq, value: "arrow", key: H.A, numericKey: H[5], fillable: !0 }, { icon: Dq, value: "line", key: H.L, numericKey: H[6], fillable: !0 }, { icon: qh, value: "freedraw", key: [H.P, H.X], numericKey: H[7], fillable: !1 }, { icon: QI, value: "text", key: H.T, numericKey: H[8], fillable: !1 }, { icon: Rq, value: "image", key: null, numericKey: H[9], fillable: !1 }, { icon: Pq, value: "eraser", key: H.E, numericKey: H[0], fillable: !1 }], ore = (e) => {
  var t;
  return ((t = N8.find((n, r) => n.numericKey != null && e === n.numericKey.toString() || n.key && (typeof n.key == "string" ? n.key === e : n.key.includes(e)))) == null ? void 0 : t.value) || null;
}, Jl = (e, t) => {
  var n;
  switch (e.type) {
    case "rectangle":
    case "diamond":
    case "frame":
    case "magicframe":
    case "embeddable":
    case "image":
    case "iframe":
    case "text":
    case "selection":
      return xA(e);
    case "arrow":
    case "line": {
      let r = ((n = wn.get(e)) == null ? void 0 : n[0]) ?? wn.generateElementShape(e, null)[0], [, , , , i, a] = tt(e, t);
      return h7(e) ? jne(e, r, T(e.x, e.y), e.angle, T(i, a)) : Xne(r, T(e.x, e.y), e.angle, T(i, a));
    }
    case "ellipse":
      return Wne(e);
    case "freedraw": {
      let [, , , , r, i] = tt(e, t);
      return Gne(e, T(r, i), h7(e));
    }
  }
}, IA = (e, t) => {
  let n = lt(e, t);
  return n ? e.type === "arrow" ? Jl({ ...n, ...Ee.getBoundTextElementPosition(e, n, t) }, t) : Jl(n, t) : null;
}, AA = (e, t) => {
  let n = wn.generateElementShape(e, null);
  if (!n) return null;
  let r = $o(n[0]), i = T(0, 0), a = 0, l = 1 / 0, s = null;
  for (; a < r.length; ) {
    let { op: c, data: d } = r[a];
    if (c === "move" && (Or(IY(d), "The returned ops is not compatible with a point"), i = d), c === "bcurveTo") {
      let o = i, u = T(d[0], d[1]), h = T(d[2], d[3]), f = T(d[4], d[5]), p = Tt(f, t);
      p < l && (l = p, s = [o, u, h, f]), i = f;
    }
    a++;
  }
  return s;
}, NA = (e, t, n, r, i) => {
  let a = (c, d) => Math.pow(1 - c, 3) * r[d] + 3 * c * Math.pow(1 - c, 2) * n[d] + 3 * Math.pow(c, 2) * (1 - c) * t[d] + e[d] * Math.pow(c, 3), l = a(i, 0), s = a(i, 1);
  return T(l, s);
}, cre = (e, t) => {
  let n = AA(e, t);
  if (!n) return [];
  let r = [], i = 1;
  for (; i > 0; ) {
    let a = NA(n[0], n[1], n[2], n[3], i);
    r.push(T(a[0], a[1])), i -= 0.05;
  }
  return r.length && Ra(r.at(-1), t) && r.push(T(t[0], t[1])), r;
}, DA = (e, t) => {
  let n = [];
  n[0] = 0;
  let r = cre(e, t), i = 0, a = 0;
  for (; i < r.length - 1; ) {
    let l = Tt(r[i], r[i + 1]);
    a += l, n.push(a), i++;
  }
  return n;
}, dre = (e, t) => DA(e, t).at(-1), ure = (e, t, n) => {
  let r = DA(e, t), i = r.length - 1, a = r.at(-1), l = n * a, s = 0, c = i, d = 0;
  for (; s < c; ) d = Math.floor(s + (c - s) / 2), r[d] < l ? s = d + 1 : c = d;
  return r[d] > l && d--, r[d] === l ? d / i : 1 - (d + (l - r[d]) / (r[d + 1] - r[d])) / i;
}, sl = (e, t) => {
  let n = { minX: e.x, minY: e.y, maxX: e.x + e.width, maxY: e.y + e.height, midX: e.x + e.width / 2, midY: e.y + e.height / 2 }, r = T(n.midX, n.midY), [i, a] = te(T(n.minX, n.minY), r, e.angle), [l, s] = te(T(n.maxX, n.minY), r, e.angle), [c, d] = te(T(n.maxX, n.maxY), r, e.angle), [o, u] = te(T(n.minX, n.maxY), r, e.angle), h = [Math.min(i, l, c, o), Math.min(a, s, d, u), Math.max(i, l, c, o), Math.max(a, s, d, u)];
  if (t) {
    let [f, p, g, b] = t;
    return [h[0] - b, h[1] - f, h[2] + p, h[3] + g];
  }
  return h;
}, y0 = (e, t) => e[0] > t[0] && e[0] < t[2] && e[1] > t[1] && e[1] < t[3], Aa = (e, t) => {
  var n, r, i, a;
  if (((n = t.roundness) == null ? void 0 : n.type) === Jn.PROPORTIONAL_RADIUS || ((r = t.roundness) == null ? void 0 : r.type) === Jn.LEGACY) return e * F6;
  if (((i = t.roundness) == null ? void 0 : i.type) === Jn.ADAPTIVE_RADIUS) {
    let l = ((a = t.roundness) == null ? void 0 : a.value) ?? yY, s = l / F6;
    return e <= s ? e * F6 : l;
  }
  return 0;
}, Us = (e, t = 1) => {
  if (e.length >= 3) {
    let [n, r] = [e[0], e[e.length - 1]];
    return Tt(n, r) <= up / t;
  }
  return !1;
}, pr = 10, hre = (e, t, n, r, i, a, l) => {
  var M, A;
  let { width: s, height: c } = vs(e), d = n / s, o = r / c, u = (((M = e.crop) == null ? void 0 : M.x) ?? 0) / d, h = (((A = e.crop) == null ? void 0 : A.y) ?? 0) / o, f = te(T(i, a), T(e.x + e.width / 2, e.y + e.height / 2), -e.angle);
  i = f[0], a = f[1];
  let p = e.width, g = e.height, b = e.crop ?? { x: 0, y: 0, width: n, height: r, naturalWidth: n, naturalHeight: r }, v = b.height, U = b.width, y = e.scale[0] === -1, w = e.scale[1] === -1, x = a - e.y, E = i - e.x;
  t.includes("n") && (g = ft(e.height - x, pr, w ? c - h : e.height + h)), t.includes("s") && (x = a - e.y - e.height, g = ft(e.height + x, pr, w ? e.height + h : c - h)), t.includes("e") && (E = i - e.x - e.width, p = ft(e.width + E, pr, y ? e.width + u : s - u)), t.includes("w") && (p = ft(e.width - E, pr, y ? s - u : e.width + u));
  let S = (L) => {
    L.height = g * o, L.width = p * d;
  };
  S(b);
  let _ = (L, R) => {
    S(R), L.includes("n") && (w || (R.y += v - R.height)), L.includes("s") && w && (R.y += v - R.height), L.includes("e") && y && (R.x += U - R.width), L.includes("w") && (y || (R.x += U - R.width));
  };
  switch (t) {
    case "n": {
      if (l) {
        let L = u + e.width / 2, R = s - u - e.width / 2, z = Math.min(L, R) * 2;
        p = ft(g * l, pr, z), g = p / l;
      }
      _(t, b), l && (b.x += (U - b.width) / 2);
      break;
    }
    case "s": {
      if (l) {
        let L = u + e.width / 2, R = s - u - e.width / 2, z = Math.min(L, R) * 2;
        p = ft(g * l, pr, z), g = p / l;
      }
      _(t, b), l && (b.x += (U - b.width) / 2);
      break;
    }
    case "w": {
      if (l) {
        let L = h + e.height / 2, R = c - h - e.height / 2, z = Math.min(L, R) * 2;
        g = ft(p / l, pr, z), p = g * l;
      }
      _(t, b), l && (b.y += (v - b.height) / 2);
      break;
    }
    case "e": {
      if (l) {
        let L = h + e.height / 2, R = c - h - e.height / 2, z = Math.min(L, R) * 2;
        g = ft(p / l, pr, z), p = g * l;
      }
      _(t, b), l && (b.y += (v - b.height) / 2);
      break;
    }
    case "ne": {
      if (l) if (E > -x) {
        let L = w ? c - h : h + e.height;
        g = ft(p / l, pr, L), p = g * l;
      } else {
        let L = y ? u + e.width : s - u;
        p = ft(g * l, pr, L), g = p / l;
      }
      _(t, b);
      break;
    }
    case "nw": {
      if (l) if (E < x) {
        let L = w ? c - h : h + e.height;
        g = ft(p / l, pr, L), p = g * l;
      } else {
        let L = y ? s - u : u + e.width;
        p = ft(g * l, pr, L), g = p / l;
      }
      _(t, b);
      break;
    }
    case "se": {
      if (l) if (E > x) {
        let L = w ? h + e.height : c - h;
        g = ft(p / l, pr, L), p = g * l;
      } else {
        let L = y ? u + e.width : s - u;
        p = ft(g * l, pr, L), g = p / l;
      }
      _(t, b);
      break;
    }
    case "sw": {
      if (l) if (-E > x) {
        let L = w ? h + e.height : c - h;
        g = ft(p / l, pr, L), p = g * l;
      } else {
        let L = y ? s - u : u + e.width;
        p = ft(g * l, pr, L), g = p / l;
      }
      _(t, b);
      break;
    }
  }
  let k = fre(e, t, p, g, !!l);
  return Ww(b.width, b.naturalWidth) && Ww(b.height, b.naturalHeight) && (b = null), { x: k[0], y: k[1], width: p, height: g, crop: b };
}, fre = (e, t, n, r, i) => {
  let [a, l, s, c] = po(e, e.width, e.height, !0), d = T(a, l), o = T(s, c), u = Bf(d, o), [h, f, p, g] = po(e, n, r, !0), b = p - h, v = g - f, U = [...d];
  if (["n", "w", "nw"].includes(t) && (U = [o[0] - Math.abs(b), o[1] - Math.abs(v)]), t === "ne") {
    let _ = [d[0], o[1]];
    U = [_[0], _[1] - Math.abs(v)];
  }
  if (t === "sw") {
    let _ = [o[0], d[1]];
    U = [_[0] - Math.abs(b), _[1]];
  }
  i && (["s", "n"].includes(t) && (U[0] = u[0] - b / 2), ["e", "w"].includes(t) && (U[1] = u[1] - v / 2));
  let y = e.angle, w = te(U, u, y), x = [U[0] + Math.abs(b) / 2, U[1] + Math.abs(v) / 2], E = te(x, u, y);
  U = te(w, E, -y);
  let S = [...U];
  return S[0] += e.x - h, S[1] += e.y - f, S;
}, pre = (e, t) => {
  if (e.crop) {
    let { width: n, height: r } = vs(e), [i, a, l, s, c, d] = tt(e, t), o = Le(te(T(i, a), T(c, d), e.angle)), u = Le(te(T(l, a), T(c, d), e.angle)), h = Rr(wm(u, o)), f = Le(te(T(i, s), T(c, d), e.angle)), p = wm(f, o), g = Rr(p), { cropX: b, cropY: v } = mre(e.crop, e.scale), U = io(io(o, An(h, -b * n / e.crop.naturalWidth)), An(g, -v * r / e.crop.naturalHeight)), y = pt(io(io(U, An(h, n / 2)), An(g, r / 2))), w = te(pt(U), y, -e.angle);
    return { ...e, x: w[0], y: w[1], width: n, height: r, crop: null };
  }
  return e;
}, vs = (e) => {
  if (e.crop) {
    let t = e.width / (e.crop.width / e.crop.naturalWidth), n = e.height / (e.crop.height / e.crop.naturalHeight);
    return { width: t, height: n };
  }
  return { width: e.width, height: e.height };
}, mre = (e, t) => {
  let n = e.x, r = e.y, i = t[0] === -1, a = t[1] === -1;
  return i && (n = e.naturalWidth - Math.abs(n) - e.width), a && (r = e.naturalHeight - Math.abs(r) - e.height), { cropX: n, cropY: r };
}, gre = (e, t = !1) => {
  let n = e.crop;
  if (!n) return null;
  let r = e.scale[0] === -1, i = e.scale[1] === -1, a = n.x, l = n.y;
  if (r && (a = n.naturalWidth - n.width - n.x), i && (l = n.naturalHeight - n.height - n.y), t) return { x: a, y: l };
  let { width: s, height: c } = vs(e);
  return { x: a / (n.naturalWidth / s), y: l / (n.naturalHeight / c) };
}, LA = "invert(100%) hue-rotate(180deg) saturate(1.25)", bre = El(), RA = (e, t) => zi(e) && !t.imageCache.has(e.fileId), PA = (e, t, n) => {
  var r;
  return n.theme === gt.DARK && zi(e) && !RA(e, t) && ((r = t.imageCache.get(e.fileId)) == null ? void 0 : r.mimeType) !== $e.svg;
}, i2 = (e) => {
  switch (e.type) {
    case "freedraw":
      return e.strokeWidth * 12;
    case "text":
      return e.fontSize / 2;
    default:
      return 20;
  }
}, OA = (e, t, n, r, i = 1) => {
  let a = ((t == null ? void 0 : t.opacity) ?? 100) * e.opacity / 1e4 * i;
  return (n.has(e.id) || r && r.some((l) => l.id === e.id) || t && n.has(t.id)) && (a *= vY / 100), a;
}, Ure = (e, t, n) => {
  let r = i2(e), [i, a, l, s] = tt(e, t), c = et(e) || na(e) ? Dr(i, l) : e.width, d = et(e) || na(e) ? Dr(a, s) : e.height, o = c * window.devicePixelRatio + r * 2, u = d * window.devicePixelRatio + r * 2, h = n.value;
  return (o * h > 32767 || u * h > 32767) && (h = Math.min(32767 / o, 32767 / u)), o * u * h * h > 16777216 && (h = Math.sqrt(16777216 / (o * u))), o = Math.floor(o * h), u = Math.floor(u * h), { width: o, height: u, scale: h };
}, $A = (e, t, n, r, i) => {
  var v, U;
  let a = document.createElement("canvas"), l = a.getContext("2d"), s = i2(e), { width: c, height: d, scale: o } = Ure(e, t, n);
  if (!c || !d) return null;
  a.width = c, a.height = d;
  let u = -100, h = 0;
  if (et(e) || na(e)) {
    let [y, w] = tt(e, t);
    u = e.x > y ? Dr(e.x, y) * window.devicePixelRatio * o : 0, h = e.y > w ? Dr(e.y, w) * window.devicePixelRatio * o : 0, l.translate(u, h);
  }
  l.save(), l.translate(s * o, s * o), l.scale(window.devicePixelRatio * o, window.devicePixelRatio * o);
  let f = Po.canvas(a);
  PA(e, r, i) && (l.filter = LA), bp(e, f, l, r), l.restore();
  let p = lt(e, t), g = document.createElement("canvas"), b = g.getContext("2d");
  if (dt(e) && p) {
    let [y, w, x, E] = tt(e, t), S = Math.max(Dr(y, x), Dr(w, E));
    g.width = S * window.devicePixelRatio * o + s * o * 10, g.height = S * window.devicePixelRatio * o + s * o * 10, b.translate(g.width / 2, g.height / 2), b.rotate(e.angle), b.drawImage(a, -a.width / 2, -a.height / 2, a.width, a.height);
    let [, , , , _, k] = tt(p, t);
    b.rotate(-e.angle);
    let M = (g.width - a.width) / 2, A = (g.height - a.height) / 2, L = g.width / 2 - (_ - y) * window.devicePixelRatio * o - M - s * o, R = g.height / 2 - (k - w) * window.devicePixelRatio * o - A - s * o;
    b.translate(-L, -R), b.clearRect(-(p.width / 2 + Zn) * window.devicePixelRatio * o, -(p.height / 2 + Zn) * window.devicePixelRatio * o, (p.width + Zn * 2) * window.devicePixelRatio * o, (p.height + Zn * 2) * window.devicePixelRatio * o);
  }
  return { element: e, canvas: a, theme: i.theme, scale: o, zoomValue: n.value, canvasOffsetX: u, canvasOffsetY: h, boundTextElementVersion: ((v = lt(e, t)) == null ? void 0 : v.version) || null, containingFrameOpacity: ((U = hi(e, t)) == null ? void 0 : U.opacity) || 100, boundTextCanvas: g, angle: e.angle, imageCrop: Mt(e) ? e.crop : null };
}, vre = 14, FA = document.createElement("img");
FA.src = `data:${$e.svg},${encodeURIComponent('<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="image" class="svg-inline--fa fa-image fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="#888" d="M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z"></path></svg>')}`;
var zA = document.createElement("img");
zA.src = `data:${$e.svg},${encodeURIComponent('<svg viewBox="0 0 668 668" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2"><path d="M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48ZM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56ZM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48Z" style="fill:#888;fill-rule:nonzero" transform="matrix(.81709 0 0 .81709 124.825 145.825)"/><path d="M256 8C119.034 8 8 119.033 8 256c0 136.967 111.034 248 248 248s248-111.034 248-248S392.967 8 256 8Zm130.108 117.892c65.448 65.448 70 165.481 20.677 235.637L150.47 105.216c70.204-49.356 170.226-44.735 235.638 20.676ZM125.892 386.108c-65.448-65.448-70-165.481-20.677-235.637L361.53 406.784c-70.203 49.356-170.226 44.736-235.638-20.676Z" style="fill:#888;fill-rule:nonzero" transform="matrix(.30366 0 0 .30366 506.822 60.065)"/></svg>')}`;
var yre = (e, t) => {
  t.fillStyle = "#E7E7E7", t.fillRect(0, 0, e.width, e.height);
  let n = Math.min(e.width, e.height), r = Math.min(n, Math.min(n * 0.4, 100));
  t.drawImage(e.status === "error" ? zA : FA, e.width / 2 - r / 2, e.height / 2 - r / 2, r, r);
}, bp = (e, t, n, r, i) => {
  var a;
  switch (e.type) {
    case "rectangle":
    case "iframe":
    case "embeddable":
    case "diamond":
    case "ellipse": {
      n.lineJoin = "round", n.lineCap = "round", t.draw(wn.get(e));
      break;
    }
    case "arrow":
    case "line": {
      n.lineJoin = "round", n.lineCap = "round", wn.get(e).forEach((l) => {
        t.draw(l);
      });
      break;
    }
    case "freedraw": {
      n.save(), n.fillStyle = e.strokeColor;
      let l = Ere(e), s = wn.get(e);
      s && t.draw(s), n.fillStyle = e.strokeColor, n.fill(l), n.restore();
      break;
    }
    case "image": {
      let l = zi(e) ? (a = r.imageCache.get(e.fileId)) == null ? void 0 : a.image : void 0;
      if (l != null && !(l instanceof Promise)) {
        e.roundness && n.roundRect && (n.beginPath(), n.roundRect(0, 0, e.width, e.height, Aa(Math.min(e.width, e.height), e)), n.clip());
        let { x: s, y: c, width: d, height: o } = e.crop ? e.crop : { x: 0, y: 0, width: l.naturalWidth, height: l.naturalHeight };
        n.drawImage(l, s, c, d, o, 0, 0, e.width, e.height);
      } else yre(e, n);
      break;
    }
    default:
      if (we(e)) {
        let l = $I(e.text), s = l && !n.canvas.isConnected;
        s && document.body.appendChild(n.canvas), n.canvas.setAttribute("dir", l ? "rtl" : "ltr"), n.save(), n.font = Wt(e), n.fillStyle = e.strokeColor, n.textAlign = e.textAlign;
        let c = e.text.replace(/\r\n?/g, `
`).split(`
`), d = e.textAlign === "center" ? e.width / 2 : e.textAlign === "right" ? e.width : 0, o = Wf(e.fontSize, e.lineHeight), u = wA(e.fontFamily, e.fontSize, o);
        for (let h = 0; h < c.length; h++) n.fillText(c[h], d, h * o + u);
        n.restore(), s && n.canvas.remove();
      } else throw new Error(`Unimplemented type ${e.type}`);
  }
}, p7 = /* @__PURE__ */ new WeakMap(), yx = (e, t, n, r) => {
  var u;
  let i = n ? r.zoom : bre.zoom, a = p7.get(e), l = a && a.zoomValue !== i.value && !(r != null && r.shouldCacheIgnoreZoom), s = lt(e, t), c = (s == null ? void 0 : s.version) || null, d = Mt(e) ? e.crop : null, o = ((u = hi(e, t)) == null ? void 0 : u.opacity) || 100;
  if (!a || l || a.theme !== r.theme || a.boundTextElementVersion !== c || a.imageCrop !== d || a.containingFrameOpacity !== o || dt(e) && s && e.angle !== a.angle) {
    let h = $A(e, t, i, n, r);
    return h ? (p7.set(e, h), h) : null;
  }
  return a;
}, q6 = (e, t, n, r, i) => {
  let a = e.element, l = i2(a), s = e.scale, [c, d, o, u] = tt(a, i), h = ((c + o) / 2 + r.scrollX) * window.devicePixelRatio, f = ((d + u) / 2 + r.scrollY) * window.devicePixelRatio;
  t.save(), t.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);
  let p = lt(a, i);
  if (dt(a) && p) {
    let g = (e.boundTextCanvas.width - e.canvas.width) / 2, b = (e.boundTextCanvas.height - e.canvas.height) / 2;
    t.translate(h, f), t.drawImage(e.boundTextCanvas, -(o - c) / 2 * window.devicePixelRatio - g / s - l, -(u - d) / 2 * window.devicePixelRatio - b / s - l, e.boundTextCanvas.width / s, e.boundTextCanvas.height / s);
  } else t.translate(h, f), t.rotate(a.angle), "scale" in e.element && !RA(a, n) && t.scale(e.element.scale[0], e.element.scale[1]), t.translate(-h, -f), t.drawImage(e.canvas, (c + r.scrollX) * window.devicePixelRatio - l * e.scale / e.scale, (d + r.scrollY) * window.devicePixelRatio - l * e.scale / e.scale, e.canvas.width / e.scale, e.canvas.height / e.scale), st.VITE_APP_DEBUG_ENABLE_TEXT_CONTAINER_BOUNDING_BOX;
  t.restore();
}, wre = (e, t, n, r) => {
  t.save(), t.translate(e.x + n.scrollX, e.y + n.scrollY), t.fillStyle = "rgba(0, 0, 200, 0.04)";
  let i = 0.5 / n.zoom.value;
  t.fillRect(i, i, e.width, e.height), t.lineWidth = 1 / n.zoom.value, t.strokeStyle = r, t.strokeRect(i, i, e.width, e.height), t.restore();
}, tc = (e, t, n, r, i, a, l) => {
  var c;
  let s = ((c = l.openDialog) == null ? void 0 : c.name) === "elementLinkSelector" && !l.selectedElementIds[e.id] && !l.hoveredElementIds[e.id];
  switch (i.globalAlpha = OA(e, hi(e, t), a.elementsPendingErasure, a.pendingFlowchartNodes, s ? NI : 1), e.type) {
    case "magicframe":
    case "frame": {
      l.frameRendering.enabled && l.frameRendering.outline && (i.save(), i.translate(e.x + l.scrollX, e.y + l.scrollY), i.fillStyle = "rgba(0, 0, 200, 0.04)", i.lineWidth = vn.strokeWidth / l.zoom.value, i.strokeStyle = vn.strokeColor, pp(e) && (i.strokeStyle = l.theme === gt.LIGHT ? "#7affd7" : "#1d8264"), i.roundRect ? (i.beginPath(), i.roundRect(0, 0, e.width, e.height, vn.radius / l.zoom.value), i.stroke(), i.closePath()) : i.strokeRect(0, 0, e.width, e.height), i.restore());
      break;
    }
    case "freedraw": {
      if (wn.generateElementShape(e, null), a.isExporting) {
        let [d, o, u, h] = tt(e, t), f = (d + u) / 2 + l.scrollX, p = (o + h) / 2 + l.scrollY, g = (u - d) / 2 - (e.x - d), b = (h - o) / 2 - (e.y - o);
        i.save(), i.translate(f, p), i.rotate(e.angle), i.translate(-g, -b), bp(e, r, i, a), i.restore();
      } else {
        let d = yx(e, n, a, l);
        if (!d) return;
        q6(d, i, a, l, n);
      }
      break;
    }
    case "rectangle":
    case "diamond":
    case "ellipse":
    case "line":
    case "arrow":
    case "image":
    case "text":
    case "iframe":
    case "embeddable": {
      if (wn.generateElementShape(e, a), a.isExporting) {
        let [d, o, u, h] = tt(e, t), f = (d + u) / 2 + l.scrollX, p = (o + h) / 2 + l.scrollY, g = (u - d) / 2 - (e.x - d), b = (h - o) / 2 - (e.y - o);
        if (we(e)) {
          let U = xr(e, t);
          if (dt(U)) {
            let y = Ee.getBoundTextElementPosition(U, e, t);
            g = (u - d) / 2 - (y.x - d), b = (h - o) / 2 - (y.y - o);
          }
        }
        i.save(), i.translate(f, p), PA(e, a, l) && (i.filter = "none");
        let v = lt(e, t);
        if (dt(e) && v) {
          let U = document.createElement("canvas"), y = U.getContext("2d"), w = Math.max(Dr(d, u), Dr(o, h)), x = i2(e);
          U.width = w * l.exportScale + x * 10 * l.exportScale, U.height = w * l.exportScale + x * 10 * l.exportScale, y.translate(U.width / 2, U.height / 2), y.scale(l.exportScale, l.exportScale), g = e.width / 2 - (e.x - d), b = e.height / 2 - (e.y - o), y.rotate(e.angle);
          let E = Po.canvas(U);
          y.translate(-g, -b), bp(e, E, y, a), y.translate(g, b), y.rotate(-e.angle);
          let [, , , , S, _] = tt(v, t), k = (d + u) / 2 - S, M = (o + h) / 2 - _;
          y.translate(-k, -M), y.clearRect(-v.width / 2, -v.height / 2, v.width, v.height), i.scale(1 / l.exportScale, 1 / l.exportScale), i.drawImage(U, -U.width / 2, -U.height / 2, U.width, U.height);
        } else i.rotate(e.angle), e.type === "image" && i.scale(e.scale[0], e.scale[1]), i.translate(-g, -b), bp(e, r, i, a);
        i.restore();
      } else {
        let d = yx(e, n, a, l);
        if (!d) return;
        let o = i.imageSmoothingEnabled;
        if (!(l != null && l.shouldCacheIgnoreZoom) && (!e.angle || CY(e.angle)) && (i.imageSmoothingEnabled = !1), e.id === l.croppingElementId && Mt(d.element) && d.element.crop !== null) {
          i.save(), i.globalAlpha = 0.1;
          let u = $A(pre(d.element, t), n, l.zoom, a, l);
          u && q6(u, i, a, l, n), i.restore();
        }
        q6(d, i, a, l, n), i.imageSmoothingEnabled = o;
      }
      break;
    }
    default:
      throw new Error(`Unimplemented type ${e.type}`);
  }
  i.globalAlpha = 1;
}, BA = /* @__PURE__ */ new WeakMap([]);
function xre(e) {
  let t = HA(e), n = new Path2D(t);
  return BA.set(e, n), n;
}
function Ere(e) {
  return BA.get(e);
}
function HA(e) {
  let t = e.simulatePressure ? e.points : e.points.length ? e.points.map(([r, i], a) => [r, i, e.pressures[a]]) : [[0, 0, 0.5]], n = { simulatePressure: e.simulatePressure, size: e.strokeWidth * 4.25, thinning: 0.6, smoothing: 0.5, streamline: 0.5, easing: (r) => Math.sin(r * Math.PI / 2), last: !!e.lastCommittedPoint };
  return _re(yK(t, n));
}
function wx(e, t) {
  return [(e[0] + t[0]) / 2, (e[1] + t[1]) / 2];
}
var Sre = /(\s?[A-Z]?,?-?[0-9]*\.[0-9]{0,2})(([0-9]|e|-)*)/g;
function _re(e) {
  if (!e.length) return "";
  let t = e.length - 1;
  return e.reduce((n, r, i, a) => (i === t ? n.push(r, wx(r, a[0]), "L", a[0], "Z") : n.push(r, wx(r, a[i + 1])), n), ["M", e[0], "Q"]).join(" ").replace(Sre, "$1");
}
var w0 = (e) => e === "rectangle" || e === "iframe" || e === "embeddable" || e === "ellipse" || e === "diamond" || e === "line" || e === "freedraw", m7 = (e) => e !== "image" && e !== "frame" && e !== "magicframe", xx = (e) => e === "rectangle" || e === "iframe" || e === "embeddable" || e === "ellipse" || e === "diamond" || e === "freedraw" || e === "arrow" || e === "line", Ex = (e) => e === "rectangle" || e === "iframe" || e === "embeddable" || e === "ellipse" || e === "diamond" || e === "arrow" || e === "line", g7 = (e) => e === "rectangle" || e === "iframe" || e === "embeddable" || e === "line" || e === "diamond" || e === "image", Sx = (e) => e === "arrow", Im = (e) => e === "arrow", In = [1, 0], yr = [0, 1], ai = [-1, 0], li = [0, -1], R1 = (e, t) => {
  let n = zf(Math.atan2(t[1] - e[1], t[0] - e[0]));
  return n >= 315 || n < 45 ? li : n >= 45 && n < 135 ? In : n >= 135 && n < 225 ? yr : ai;
}, qc = (e) => {
  let [t, n] = e, r = Math.abs(t), i = Math.abs(n);
  return t > i ? In : t <= -i ? ai : n > r ? yr : li;
}, Zh = (e, t) => qc(Le(e, t)), ts = (e, t) => is(Zh(e, t)), Nn = (e, t) => e[0] === t[0] && e[1] === t[1], is = (e) => Nn(e, In) || Nn(e, ai), WA = (e, t, n) => {
  let r = R8(t);
  if (e.type === "diamond") {
    if (n[0] < e.x) return ai;
    if (n[1] < e.y) return li;
    if (n[0] > e.x + e.width) return In;
    if (n[1] > e.y + e.height) return yr;
    let c = te(Xl(T(e.x + e.width / 2, e.y), r, 2), r, e.angle), d = te(Xl(T(e.x + e.width, e.y + e.height / 2), r, 2), r, e.angle), o = te(Xl(T(e.x + e.width / 2, e.y + e.height), r, 2), r, e.angle), u = te(Xl(T(e.x, e.y + e.height / 2), r, 2), r, e.angle);
    return wd([c, d, r], n) ? R1(c, d) : wd([d, o, r], n) ? R1(d, o) : wd([o, u, r], n) ? R1(o, u) : R1(u, c);
  }
  let i = Xl(T(t[0], t[1]), r, 2), a = Xl(T(t[2], t[1]), r, 2), l = Xl(T(t[0], t[3]), r, 2), s = Xl(T(t[2], t[3]), r, 2);
  return wd([i, a, r], n) ? li : wd([a, s, r], n) ? In : wd([s, l, r], n) ? yr : ai;
}, XA = (e) => [e[0] === 0 ? 0 : e[0] > 0 ? -1 : 1, e[1] === 0 ? 0 : e[1] > 0 ? -1 : 1], kre = (e) => [8, 8 + e], VA = (e) => [1.5, 6 + e];
function Cre(e) {
  let t = e.roughness, n = Math.max(e.width, e.height), r = Math.min(e.width, e.height);
  return r >= 20 && n >= 50 || r >= 15 && e.roundness && g7(e.type) || et(e) && n >= 50 ? t : Math.min(t / (n < 10 ? 3 : 2), 2.5);
}
var bi = (e, t = !1) => {
  let n = { seed: e.seed, strokeLineDash: e.strokeStyle === "dashed" ? kre(e.strokeWidth) : e.strokeStyle === "dotted" ? VA(e.strokeWidth) : void 0, disableMultiStroke: e.strokeStyle !== "solid", strokeWidth: e.strokeStyle !== "solid" ? e.strokeWidth + 0.5 : e.strokeWidth, fillWeight: e.strokeWidth / 2, hachureGap: e.strokeWidth * 4, roughness: Cre(e), stroke: e.strokeColor, preserveVertices: t || e.roughness < TI.cartoonist };
  switch (e.type) {
    case "rectangle":
    case "iframe":
    case "embeddable":
    case "diamond":
    case "ellipse":
      return n.fillStyle = e.fillStyle, n.fill = Ea(e.backgroundColor) ? void 0 : e.backgroundColor, e.type === "ellipse" && (n.curveFitting = 1), n;
    case "line":
    case "freedraw":
      return Us(e.points) && (n.fillStyle = e.fillStyle, n.fill = e.backgroundColor === "transparent" ? void 0 : e.backgroundColor), n;
    case "arrow":
      return n;
    default:
      throw new Error(`Unimplemented type ${e.type}`);
  }
}, _x = (e, t, n) => Bi(e) && (t || ri(e) && (n == null ? void 0 : n.get(e.id)) !== !0) && Ea(e.backgroundColor) && Ea(e.strokeColor) ? { ...e, roughness: 0, backgroundColor: "#d3d3d3", fillStyle: "solid" } : qs(e) ? { ...e, strokeColor: Ea(e.strokeColor) ? "#000000" : e.strokeColor, backgroundColor: Ea(e.backgroundColor) ? "#f4f4f6" : e.backgroundColor } : e, kx = (e, t, n, r, i, a, l) => {
  let s = Ix(e, t, n, r);
  if (s === null) return [];
  let c = (d, o) => {
    if (d === null) return [];
    let [, , u, h, f, p] = d;
    return [i.line(u, h, f, p, o)];
  };
  switch (r) {
    case "dot":
    case "circle":
    case "circle_outline": {
      let [d, o, u] = s;
      return delete a.strokeLineDash, [i.circle(d, o, u, { ...a, fill: r === "circle_outline" ? l : e.strokeColor, fillStyle: "solid", stroke: e.strokeColor, roughness: Math.min(0.5, a.roughness || 0) })];
    }
    case "triangle":
    case "triangle_outline": {
      let [d, o, u, h, f, p] = s;
      return delete a.strokeLineDash, [i.polygon([[d, o], [u, h], [f, p], [d, o]], { ...a, fill: r === "triangle_outline" ? l : e.strokeColor, fillStyle: "solid", roughness: Math.min(1, a.roughness || 0) })];
    }
    case "diamond":
    case "diamond_outline": {
      let [d, o, u, h, f, p, g, b] = s;
      return delete a.strokeLineDash, [i.polygon([[d, o], [u, h], [f, p], [g, b], [d, o]], { ...a, fill: r === "diamond_outline" ? l : e.strokeColor, fillStyle: "solid", roughness: Math.min(1, a.roughness || 0) })];
    }
    case "crowfoot_one":
      return c(s, a);
    case "bar":
    case "arrow":
    case "crowfoot_many":
    case "crowfoot_one_or_many":
    default: {
      let [d, o, u, h, f, p] = s;
      if (e.strokeStyle === "dotted") {
        let g = VA(e.strokeWidth - 1);
        a.strokeLineDash = [g[0], g[1] - 1];
      } else delete a.strokeLineDash;
      return a.roughness = Math.min(1, a.roughness || 0), [i.line(u, h, d, o, a), i.line(f, p, d, o, a), ...r === "crowfoot_one_or_many" ? c(Ix(e, t, n, "crowfoot_one"), a) : []];
    }
  }
}, Mre = (e, t, { isExporting: n, canvasBackgroundColor: r, embedsValidationStatus: i }) => {
  switch (e.type) {
    case "rectangle":
    case "iframe":
    case "embeddable": {
      let a;
      if (e.roundness) {
        let l = e.width, s = e.height, c = Aa(Math.min(l, s), e);
        a = t.path(`M ${c} 0 L ${l - c} 0 Q ${l} 0, ${l} ${c} L ${l} ${s - c} Q ${l} ${s}, ${l - c} ${s} L ${c} ${s} Q 0 ${s}, 0 ${s - c} L 0 ${c} Q 0 0, ${c} 0`, bi(_x(e, n, i), !0));
      } else a = t.rectangle(0, 0, e.width, e.height, bi(_x(e, n, i), !1));
      return a;
    }
    case "diamond": {
      let a, [l, s, c, d, o, u, h, f] = jA(e);
      if (e.roundness) {
        let p = Aa(Math.abs(l - h), e), g = Aa(Math.abs(d - s), e);
        a = t.path(`M ${l + p} ${s + g} L ${c - p} ${d - g}
            C ${c} ${d}, ${c} ${d}, ${c - p} ${d + g}
            L ${o + p} ${u - g}
            C ${o} ${u}, ${o} ${u}, ${o - p} ${u - g}
            L ${h + p} ${f + g}
            C ${h} ${f}, ${h} ${f}, ${h + p} ${f - g}
            L ${l - p} ${s + g}
            C ${l} ${s}, ${l} ${s}, ${l + p} ${s + g}`, bi(e, !0));
      } else a = t.polygon([[l, s], [c, d], [o, u], [h, f]], bi(e));
      return a;
    }
    case "ellipse":
      return t.ellipse(e.width / 2, e.height / 2, e.width, e.height, bi(e));
    case "line":
    case "arrow": {
      let a, l = bi(e), s = e.points.length ? e.points : [T(0, 0)];
      if (Se(e) ? s.every((c) => Math.abs(c[0]) <= 1e6 && Math.abs(c[1]) <= 1e6) ? a = [t.path(Tre(s, 16), bi(e, !0))] : (console.error("Elbow arrow with extreme point positions detected. Arrow not rendered.", e.id, JSON.stringify(s)), a = []) : e.roundness ? a = [t.curve(s, l)] : l.fill ? a = [t.polygon(s, l)] : a = [t.linearPath(s, l)], e.type === "arrow") {
        let { startArrowhead: c = null, endArrowhead: d = "arrow" } = e;
        if (c !== null) {
          let o = kx(e, a, "start", c, t, l, r);
          a.push(...o);
        }
        if (d !== null) {
          let o = kx(e, a, "end", d, t, l, r);
          a.push(...o);
        }
      }
      return a;
    }
    case "freedraw": {
      let a;
      if (xre(e), Us(e.points)) {
        let l = SK(e.points, 0.75);
        a = t.curve(l, { ...bi(e), stroke: "none" });
      } else a = null;
      return a;
    }
    case "frame":
    case "magicframe":
    case "text":
    case "image":
      return null;
    default:
      return Vc(e, `generateElementShape(): Unimplemented type ${e == null ? void 0 : e.type}`), null;
  }
}, Tre = (e, t) => {
  let n = [];
  for (let i = 1; i < e.length - 1; i += 1) {
    let a = e[i - 1], l = e[i + 1], s = e[i], c = ts(s, a), d = ts(l, s), o = Math.min(t, Tt(e[i], l) / 2, Tt(e[i], a) / 2);
    c ? a[0] < s[0] ? n.push([e[i][0] - o, e[i][1]]) : n.push([e[i][0] + o, e[i][1]]) : a[1] < s[1] ? n.push([e[i][0], e[i][1] - o]) : n.push([e[i][0], e[i][1] + o]), n.push(e[i]), d ? l[0] < s[0] ? n.push([e[i][0] - o, e[i][1]]) : n.push([e[i][0] + o, e[i][1]]) : l[1] < s[1] ? n.push([e[i][0], e[i][1] - o]) : n.push([e[i][0], e[i][1] + o]);
  }
  let r = [`M ${e[0][0]} ${e[0][1]}`];
  for (let i = 0; i < n.length; i += 3) r.push(`L ${n[i][0]} ${n[i][1]}`), r.push(`Q ${n[i + 1][0]} ${n[i + 1][1]}, ${n[i + 2][0]} ${n[i + 2][1]}`);
  return r.push(`L ${e[e.length - 1][0]} ${e[e.length - 1][1]}`), r.join(" ");
}, x0 = (e) => {
  let t = e.map((r) => r[0]), n = e.map((r) => r[1]);
  return { width: Math.max(...t) - Math.min(...t), height: Math.max(...n) - Math.min(...n) };
}, Am = (e, t, n, r) => {
  let i = n.map((h) => h[e]), a = Math.max(...i), l = Math.min(...i), s = a - l, c = s === 0 ? 1 : t / s, d = 1 / 0, o = n.map((h) => {
    let f = h[e] * c, p = [...h];
    return p[e] = f, f < d && (d = f), p;
  });
  if (!r || o.length === 2) return o;
  let u = l - d;
  return o.map((h) => h.map((f, p) => p === e ? f + u : f));
}, GA = class Up {
  static getBounds(t, n) {
    let r = Up.boundsCache.get(t);
    if (r != null && r.version && r.version === t.version && !sn(t)) return r.bounds;
    let i = Up.calculateBounds(t, n);
    return Up.boundsCache.set(t, { version: t.version, bounds: i }), i;
  }
  static calculateBounds(t, n) {
    let r, [i, a, l, s, c, d] = tt(t, n);
    if (na(t)) {
      let [o, u, h, f] = D8(t.points.map(([p, g]) => te(T(p, g), T(c - t.x, d - t.y), t.angle)));
      return [o + t.x, u + t.y, h + t.x, f + t.y];
    } else if (et(t)) r = Pre(t, c, d, n);
    else if (t.type === "diamond") {
      let [o, u] = te(T(c, a), T(c, d), t.angle), [h, f] = te(T(c, s), T(c, d), t.angle), [p, g] = te(T(i, d), T(c, d), t.angle), [b, v] = te(T(l, d), T(c, d), t.angle), U = Math.min(o, h, p, b), y = Math.min(u, f, g, v), w = Math.max(o, h, p, b), x = Math.max(u, f, g, v);
      r = [U, y, w, x];
    } else if (t.type === "ellipse") {
      let o = (l - i) / 2, u = (s - a) / 2, h = Math.cos(t.angle), f = Math.sin(t.angle), p = Math.hypot(o * h, u * f), g = Math.hypot(u * h, o * f);
      r = [c - p, d - g, c + p, d + g];
    } else {
      let [o, u] = te(T(i, a), T(c, d), t.angle), [h, f] = te(T(i, s), T(c, d), t.angle), [p, g] = te(T(l, s), T(c, d), t.angle), [b, v] = te(T(l, a), T(c, d), t.angle), U = Math.min(o, h, p, b), y = Math.min(u, f, g, v), w = Math.max(o, h, p, b), x = Math.max(u, f, g, v);
      r = [U, y, w, x];
    }
    return r;
  }
};
$(GA, "boundsCache", /* @__PURE__ */ new WeakMap());
var Ire = GA, tt = (e, t, n = !1) => {
  if (na(e)) return Nre(e);
  if (et(e)) return Ee.getElementAbsoluteCoords(e, t, n);
  if (we(e)) {
    let r = t ? xr(e, t) : null;
    if (dt(r)) {
      let { x: i, y: a } = Ee.getBoundTextElementPosition(r, e, t);
      return [i, a, i + e.width, a + e.height, i + e.width / 2, a + e.height / 2];
    }
  }
  return [e.x, e.y, e.x + e.width, e.y + e.height, e.x + e.width / 2, e.y + e.height / 2];
}, Cx = (e, t) => {
  let [n, r, i, a, l, s] = tt(e, t), c = T(l, s);
  if (et(e) || na(e)) {
    let v = [], U = 0;
    for (; U < e.points.length - 1; ) v.push(Re(te(T(e.points[U][0] + e.x, e.points[U][1] + e.y), c, e.angle), te(T(e.points[U + 1][0] + e.x, e.points[U + 1][1] + e.y), c, e.angle))), U++;
    return v;
  }
  let [d, o, u, h, f, p, g, b] = [[n, r], [i, r], [n, a], [i, a], [l, r], [l, a], [n, s], [i, s]].map((v) => te(v, c, e.angle));
  return e.type === "diamond" ? [Re(f, g), Re(f, b), Re(p, g), Re(p, b)] : e.type === "ellipse" ? [Re(f, g), Re(f, b), Re(p, g), Re(p, b), Re(f, g), Re(f, b), Re(p, g), Re(p, b)] : [Re(d, o), Re(u, h), Re(d, u), Re(o, h), Re(d, b), Re(u, b), Re(o, g), Re(h, g)];
}, jA = (e) => {
  let t = Math.floor(e.width / 2) + 1, n = 0, r = e.width, i = Math.floor(e.height / 2) + 1, a = t, l = e.height;
  return [t, n, r, i, a, l, 0, i];
}, Mx = (e, t, n, r, i) => {
  let a = 1 - e;
  return Math.pow(a, 3) * t + 3 * Math.pow(a, 2) * e * n + 3 * a * Math.pow(e, 2) * r + Math.pow(e, 3) * i;
}, Tx = (e, t, n, r) => {
  let i = t - e, a = n - t, l = r - n, s = 3 * i - 6 * a + 3 * l, c = 6 * a - 6 * i, d = 3 * i, o = c * c - 4 * s * d;
  if (!(o >= 0)) return !1;
  let u = null, h = null, f = 1 / 0, p = 1 / 0;
  return s === 0 ? f = p = -d / c : (f = (-c + Math.sqrt(o)) / (2 * s), p = (-c - Math.sqrt(o)) / (2 * s)), f >= 0 && f <= 1 && (u = Mx(f, e, t, n, r)), p >= 0 && p <= 1 && (h = Mx(p, e, t, n, r)), [u, h];
}, Are = (e, t, n, r) => {
  let i = Tx(e[0], t[0], n[0], r[0]), a = Tx(e[1], t[1], n[1], r[1]), l = Math.min(e[0], r[0]), s = Math.max(e[0], r[0]);
  if (i) {
    let o = i.filter((u) => u !== null);
    l = Math.min(l, ...o), s = Math.max(s, ...o);
  }
  let c = Math.min(e[1], r[1]), d = Math.max(e[1], r[1]);
  if (a) {
    let o = a.filter((u) => u !== null);
    c = Math.min(c, ...o), d = Math.max(d, ...o);
  }
  return [l, c, s, d];
}, a2 = (e, t) => {
  let n = T(0, 0), { minX: r, minY: i, maxX: a, maxY: l } = e.reduce((s, { op: c, data: d }) => {
    if (c === "move") {
      let o = g8(d);
      Or(o != null, "Op data is not a point"), n = o;
    } else if (c === "bcurveTo") {
      let o = T(d[0], d[1]), u = T(d[2], d[3]), h = T(d[4], d[5]), f = t ? t(o) : o, p = t ? t(u) : u, g = t ? t(h) : h, b = t ? t(n) : n;
      n = h;
      let [v, U, y, w] = Are(b, f, p, g);
      s.minX = Math.min(s.minX, v), s.minY = Math.min(s.minY, U), s.maxX = Math.max(s.maxX, y), s.maxY = Math.max(s.maxY, w);
    }
    return s;
  }, { minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 });
  return [r, i, a, l];
}, D8 = (e) => {
  let t = 1 / 0, n = 1 / 0, r = -1 / 0, i = -1 / 0;
  for (let [a, l] of e) t = Math.min(t, a), n = Math.min(n, l), r = Math.max(r, a), i = Math.max(i, l);
  return [t, n, r, i];
}, Nre = (e) => {
  let [t, n, r, i] = D8(e.points), a = t + e.x, l = n + e.y, s = r + e.x, c = i + e.y;
  return [a, l, s, c, (a + s) / 2, (l + c) / 2];
}, Dre = (e) => {
  switch (e) {
    case "arrow":
      return 25;
    case "diamond":
    case "diamond_outline":
      return 12;
    case "crowfoot_many":
    case "crowfoot_one":
    case "crowfoot_one_or_many":
      return 20;
    default:
      return 15;
  }
}, Lre = (e) => {
  switch (e) {
    case "bar":
      return 90;
    case "arrow":
      return 20;
    default:
      return 25;
  }
}, Ix = (e, t, n, r) => {
  if (t.length < 1) return null;
  let i = $o(t[0]);
  if (i.length < 1) return null;
  let a = n === "start" ? 1 : i.length - 1, l = i[a].data;
  Or(l.length === 6, "Op data length is not 6");
  let s = T(l[4], l[5]), c = T(l[2], l[3]), d = T(l[0], l[1]), o = i[a - 1], u = T(0, 0);
  if (o.op === "move") {
    let z = g8(o.data);
    Or(z != null, "Op data is not a point"), u = z;
  } else o.op === "bcurveTo" && (u = T(o.data[4], o.data[5]));
  let h = (z, F) => Math.pow(1 - z, 3) * s[F] + 3 * z * Math.pow(1 - z, 2) * c[F] + 3 * Math.pow(z, 2) * (1 - z) * d[F] + u[F] * Math.pow(z, 3), [f, p] = n === "start" ? u : s, [g, b] = [h(0.3, 0), h(0.3, 1)], v = Math.hypot(f - g, p - b), U = (f - g) / v, y = (p - b) / v, w = Dre(r), x = 0;
  {
    let [z, F] = n === "end" ? e.points[e.points.length - 1] : e.points[0], [W, B] = e.points.length > 1 ? n === "end" ? e.points[e.points.length - 2] : e.points[1] : [0, 0];
    x = Math.hypot(z - W, F - B);
  }
  let E = Math.min(w, x * (r === "diamond" || r === "diamond_outline" ? 0.25 : 0.5)), S = f - U * E, _ = p - y * E;
  if (r === "dot" || r === "circle" || r === "circle_outline") {
    let z = Math.hypot(_ - p, S - f) + e.strokeWidth - 2;
    return [f, p, z];
  }
  let k = Lre(r);
  if (r === "crowfoot_many" || r === "crowfoot_one_or_many") {
    let [z, F] = te(T(f, p), T(S, _), Uc(-k)), [W, B] = te(T(f, p), T(S, _), Uc(k));
    return [S, _, z, F, W, B];
  }
  let [M, A] = te(T(S, _), T(f, p), -k * Math.PI / 180), [L, R] = te(T(S, _), T(f, p), Uc(k));
  if (r === "diamond" || r === "diamond_outline") {
    let z, F;
    if (n === "start") {
      let [W, B] = e.points.length > 1 ? e.points[1] : [0, 0];
      [z, F] = te(T(f + E * 2, p), T(f, p), Math.atan2(B - p, W - f));
    } else {
      let [W, B] = e.points.length > 1 ? e.points[e.points.length - 2] : [0, 0];
      [z, F] = te(T(f - E * 2, p), T(f, p), Math.atan2(p - B, f - W));
    }
    return [f, p, M, A, z, F, L, R];
  }
  return [f, p, M, A, L, R];
}, Rre = (e) => {
  let t = Po.generator(), n = bi(e), r = e.roundness ? "curve" : n.fill ? "polygon" : "linearPath";
  return t[r](e.points, n);
}, Pre = (e, t, n, r) => {
  var d;
  let i = lt(e, r);
  if (e.points.length < 2) {
    let [o, u] = e.points[0], [h, f] = te(T(e.x + o, e.y + u), T(t, n), e.angle), p = [h, f, h, f];
    if (i) {
      let g = Ee.getMinMaxXYWithBoundText(e, r, [h, f, h, f], i);
      p = [g[0], g[1], g[2], g[3]];
    }
    return p;
  }
  let a = ((d = wn.get(e)) == null ? void 0 : d[0]) ?? Rre(e), l = $o(a), s = a2(l, ([o, u]) => te(T(e.x + o, e.y + u), T(t, n), e.angle)), c = [s[0], s[1], s[2], s[3]];
  if (i) {
    let o = Ee.getMinMaxXYWithBoundText(e, r, c, i);
    c = [o[0], o[1], o[2], o[3]];
  }
  return c;
}, Oa = (e, t) => Ire.getBounds(e, t), Lt = (e, t) => {
  if (!e.length) return [0, 0, 0, 0];
  let n = 1 / 0, r = -1 / 0, i = 1 / 0, a = -1 / 0, l = t || Ge(e);
  return e.forEach((s) => {
    let [c, d, o, u] = Oa(s, l);
    n = Math.min(n, c), i = Math.min(i, d), r = Math.max(r, o), a = Math.max(a, u);
  }), [n, i, r, a];
}, L8 = (e, t) => {
  let [n, r, i, a] = Lt(e);
  return [n + t.x, r + t.y, i + t.x, a + t.y];
}, po = (e, t, n, r) => {
  if (!(et(e) || na(e))) return [e.x, e.y, e.x + t, e.y + n];
  let i = Am(0, t, Am(1, n, e.points, r), r), a;
  if (na(e)) a = D8(i);
  else {
    let o = Po.generator(), u = e.roundness ? o.curve(i, bi(e)) : o.linearPath(i, bi(e)), h = $o(u);
    a = a2(h);
  }
  let [l, s, c, d] = a;
  return [l + e.x, s + e.y, c + e.x, d + e.y];
}, Ax = (e, t) => {
  let n = Po.generator(), r = e.roundness == null ? n.linearPath(t, bi(e)) : n.curve(t, bi(e)), i = $o(r), [a, l, s, c] = a2(i);
  return [a + e.x, l + e.y, s + e.x, c + e.y];
}, Ore = (e, t) => {
  if (!e.length) return [0, 0, 0, 0];
  let n = 1 / 0, r = e[0], i = Ge(e);
  return e.forEach((a) => {
    let [l, s, c, d] = Oa(a, i), o = Tt(T((l + c) / 2, (s + d) / 2), T(t.x, t.y));
    o < n && (n = o, r = a);
  }), Oa(r, i);
}, Na = (e) => {
  let [t, n, r, i] = Lt(e);
  return { minX: t, minY: n, maxX: r, maxY: i, width: r - t, height: i - n, midX: (t + r) / 2, midY: (n + i) / 2 };
}, $re = ({ scrollX: e, scrollY: t, width: n, height: r, zoom: i }) => [-e, -t, -e + n / i.value, -t + r / i.value], R8 = (e) => T(e[0] + (e[2] - e[0]) / 2, e[1] + (e[3] - e[1]) / 2), Fre = (e, t) => {
  if (e == null || t == null) return !1;
  let [n, r, i, a] = e, [l, s, c, d] = t;
  return n < c && i > l && r < d && a > s;
}, l2 = (e, t) => {
  switch (e.type) {
    case "rectangle":
    case "image":
    case "text":
    case "iframe":
    case "embeddable":
    case "frame":
    case "magicframe":
      return zre(e, t);
    case "diamond":
      return Bre(e, t);
    case "ellipse":
      return Hre(e, t);
  }
}, zre = (e, t) => {
  let n = T(e.x + e.width / 2, e.y + e.height / 2), r = te(t, n, -e.angle), [i, a] = kA(e);
  return Math.min(...i.map((l) => b8(r, l)), ...a.map((l) => PI(l, r)).filter((l) => l !== null));
}, Bre = (e, t) => {
  let n = T(e.x + e.width / 2, e.y + e.height / 2), r = te(t, n, -e.angle), [i, a] = CA(e);
  return Math.min(...i.map((l) => b8(r, l)), ...a.map((l) => PI(l, r)).filter((l) => l !== null));
}, Hre = (e, t) => {
  let n = T(e.x + e.width / 2, e.y + e.height / 2);
  return ere(te(t, n, -e.angle), _A(n, e.width / 2, e.height / 2));
}, Wre = (e) => !e[H.CTRL_OR_CMD], fc = (e) => e.isBindingEnabled, Zt = 5, P8 = 10, O8 = 4, Xre = (e, t) => {
  let n = [];
  return t.forEach((r) => {
    let i = e.getNonDeletedElement(r);
    i != null && n.push(i);
  }), n;
}, s2 = (e, t, n, r, i) => {
  let a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  Nx(e, t, n, "start", a, l, r), Nx(e, n, t, "end", a, l, r);
  let s = Array.from(l).filter((c) => !a.has(c));
  Xre(i, s).forEach((c) => {
    var d;
    le(c, { boundElements: (d = c.boundElements) == null ? void 0 : d.filter((o) => o.type !== "arrow" || o.id !== e.id) });
  });
}, Nx = (e, t, n, r, i, a, l) => {
  if (t !== "keep") {
    if (t === null) {
      let s = Yre(e, r);
      s != null && a.add(s);
      return;
    }
    ZA(e) ? (n == null || (n === "keep" ? !YA(e, t, r) : r === "start" || n.id !== t.id)) && (Sl(e, t, r, l), i.add(t.id)) : (Sl(e, t, r, l), i.add(t.id));
  }
}, Vre = (e, t, n, r) => {
  var l, s;
  let i = JA(e, t, n), a = t === "start" ? (l = e.startBinding) == null ? void 0 : l.elementId : (s = e.endBinding) == null ? void 0 : s.elementId;
  if (a) {
    let c = n.get(a);
    if (Pa(c) && vp(c, i, n, r)) return c;
  }
  return null;
}, KA = (e, t, n) => ["start", "end"].map((r) => Vre(e, r, t, n)), Gre = (e, t, n, r, i, a) => {
  let l = e.points.length - 1, s = n.findIndex((u) => u === 0) > -1, c = n.findIndex((u) => u === l) > -1, d = s ? t ? zd(e, "start", r, i, a) : null : Se(e) ? "keep" : zd(e, "start", r, i, a), o = c ? t ? zd(e, "end", r, i, a) : null : Se(e) ? "keep" : zd(e, "end", r, i, a);
  return [d, o];
}, jre = (e, t, n, r, i) => {
  if (Se(e)) return ["keep", "keep"];
  let [a, l] = KA(e, t, i), s = a && r ? zd(e, "start", t, n, i) : null, c = l && r ? zd(e, "end", t, n, i) : null;
  return [s, c];
}, Nm = (e, t, n, r, i, a, l) => {
  e.forEach((s) => {
    let [c, d] = a != null && a.length ? Gre(s, i, a ?? [], t, n, l) : jre(s, t, n, i, l);
    s2(s, c, d, t, r);
  });
}, Z6 = (e, t, n) => e.length > 50 ? [] : e.filter(et).flatMap((r) => KA(r, t, n)).filter((r) => r !== null).filter((r) => e.filter((i) => i.id === (r == null ? void 0 : r.id)).length === 0), b7 = (e, t, n, r, i) => {
  t.startBoundElement != null && Sl(e, t.startBoundElement, "start", r);
  let a = Sa(n, i, r, t.zoom, Se(e), Se(e));
  a !== null && (YA(e, a, "end") || Sl(e, a, "end", r));
}, Kre = (e, t) => {
  let n = e.gap, r = Vf(t, t.width, t.height);
  return n > r && (n = P8 + O8), { ...e, gap: n };
}, Sl = (e, t, n, r) => {
  if (!dt(e)) return;
  let i = { elementId: t.id, ...Se(e) ? { ...Dm(e, t, n), focus: 0, gap: 0 } : { ...Kre(Jre(e, t, n, r), t) } };
  le(e, { [n === "start" ? "startBinding" : "endBinding"]: i }), Ge(t.boundElements || []).has(e.id) || le(t, { boundElements: (t.boundElements || []).concat({ id: e.id, type: "arrow" }) });
}, YA = (e, t, n) => {
  let r = e[n === "start" ? "endBinding" : "startBinding"];
  return qA(e, r == null ? void 0 : r.elementId, t);
}, qA = (e, t, n) => t === n.id && ZA(e), ZA = (e) => e.points.length < 3, Yre = (e, t) => {
  let n = t === "start" ? "startBinding" : "endBinding", r = e[n];
  return r == null ? null : (le(e, { [n]: null }), r.elementId);
}, Sa = (e, t, n, r, i, a) => {
  if (a) {
    let l = !1, s = Zre(t, (d) => Pa(d, !1) && vp(d, e, n, r, (i || !B6(d)) && !Ve(d))).filter((d) => l ? !1 : (B6(d) || (l = !0), !0));
    if (!s || s.length === 0) return null;
    if (s.length === 1) return s[0];
    let c = s.filter((d) => vp(d, e, n, r, !1));
    return c.length === 1 ? c[0] : s.sort((d, o) => o.width ** 2 + o.height ** 2 - (d.width ** 2 + d.height ** 2)).pop();
  }
  return qre(t, (l) => Pa(l, !1) && vp(l, e, n, r, (i || !B6(l)) && !Ve(l)));
}, qre = (e, t) => {
  let n = null;
  for (let r = e.length - 1; r >= 0; --r) {
    let i = e[r];
    if (!i.isDeleted && t(i)) {
      n = i;
      break;
    }
  }
  return n;
}, Zre = (e, t) => {
  let n = [];
  for (let r = e.length - 1; r >= 0; --r) {
    let i = e[r];
    i.isDeleted || t(i) && n.push(i);
  }
  return n;
}, Jre = (e, t, n, r) => {
  let i = n === "start" ? -1 : 1, a = i === -1 ? 0 : e.points.length - 1, l = a - i, s = Ee.getPointAtIndexGlobalCoordinates(e, a, r), c = Ee.getPointAtIndexGlobalCoordinates(e, l, r);
  return { focus: sie(t, c, s), gap: Math.max(1, l2(t, s)) };
}, ui = (e, t, n) => {
  let { newSize: r, simultaneouslyUpdated: i } = n ?? {}, a = eie(i);
  Pa(e) && o2(t, e, (l) => {
    var p, g;
    if (!et(l) || l.isDeleted || !Qre(l, e)) return;
    let s = l.startBinding ? t.get(l.startBinding.elementId) : null, c = l.endBinding ? t.get(l.endBinding.elementId) : null, d = null, o = null;
    s && c && (d = Oa(s, t), o = Oa(c, t));
    let u = { startBinding: Dx(e, l.startBinding, r), endBinding: Dx(e, l.endBinding, r) };
    if (a.has(l.id)) {
      le(l, u, !0);
      return;
    }
    let h = c2(t, l, (b, v) => {
      var U, y;
      if (b && Pa(b) && (v === "startBinding" || v === "endBinding") && (e.id === ((U = l[v]) == null ? void 0 : U.elementId) || e.id === ((y = l[v === "startBinding" ? "endBinding" : "startBinding"]) == null ? void 0 : y.elementId) && !Fre(d, o))) {
        let w = lie(l, v, u[v], b, t);
        if (w) return { index: v === "startBinding" ? 0 : l.points.length - 1, point: w };
      }
      return null;
    }).filter((b) => b !== null);
    Ee.movePoints(l, h, { ...e.id === ((p = l.startBinding) == null ? void 0 : p.elementId) ? { startBinding: u.startBinding } : {}, ...e.id === ((g = l.endBinding) == null ? void 0 : g.elementId) ? { endBinding: u.endBinding } : {} });
    let f = lt(l, t);
    f && !f.isDeleted && Gf(l, t, !1);
  });
}, Qre = (e, t) => {
  var n, r;
  return ((n = e.startBinding) == null ? void 0 : n.elementId) === t.id || ((r = e.endBinding) == null ? void 0 : r.elementId) === t.id;
}, eie = (e) => new Set((e || []).map((t) => t.id)), tie = (e, t, n, r, i, a, l) => {
  let s = qc(Le(t, e));
  return !n || !r ? s : nie(a, n, i, l) ? WA(n, r, e) : qc(Le(e, T(n.x + n.width / 2, n.y + n.height / 2)));
}, nie = (e, t, n, r) => {
  let i = l2(t, e), a = Vf(t, t.width, t.height, r);
  return i > a ? null : i;
}, Jh = (e, t, n) => {
  let r = t && sl(t), i = e.points[n === "start" ? 0 : e.points.length - 1], a = T(e.x + i[0], e.y + i[1]), l = rq(t) ? iie(t, a) : a;
  if (t && r) {
    let s = R8(r), c = TA(t, Re(s, pt(An(Rr(Le(l, s)), Math.max(t.width, t.height)), s)))[0], d = Tt(l, s), o = Math.max(Tt(c ?? l, s), 1e-4), u = vl(d / o, 6);
    switch (!0) {
      case u > 0.9:
        return d - o > Zt || Kh(l, c) < 1e-4 ? l : pt(An(Rr(Le(l, c ?? s)), u > 1 ? Zt : -Zt), c ?? s);
      default:
        return rie(l, t, r);
    }
  }
  return l;
}, rie = (e, t, n) => {
  let r = R8(n), i = qc(Le(e, r));
  switch (!0) {
    case Nn(i, li):
      return te(T((n[0] + n[2]) / 2 + 0.1, n[1]), r, t.angle);
    case Nn(i, In):
      return te(T(n[2], (n[1] + n[3]) / 2 + 0.1), r, t.angle);
    case Nn(i, yr):
      return te(T((n[0] + n[2]) / 2 - 0.1, n[3]), r, t.angle);
    default:
      return te(T(n[0], (n[1] + n[3]) / 2 - 0.1), r, t.angle);
  }
}, iie = (e, t) => {
  let n = T(e.x + e.width / 2, e.y + e.height / 2), r = te(t, n, -e.angle);
  return r[0] < e.x && r[1] < e.y ? r[1] - e.y > -Zt ? te(T(e.x - Zt, e.y), n, e.angle) : te(T(e.x, e.y - Zt), n, e.angle) : r[0] < e.x && r[1] > e.y + e.height ? r[0] - e.x > -Zt ? te(T(e.x, e.y + e.height + Zt), n, e.angle) : te(T(e.x - Zt, e.y + e.height), n, e.angle) : r[0] > e.x + e.width && r[1] > e.y + e.height ? r[0] - e.x < e.width + Zt ? te(T(e.x + e.width, e.y + e.height + Zt), n, e.angle) : te(T(e.x + e.width + Zt, e.y + e.height), n, e.angle) : r[0] > e.x + e.width && r[1] < e.y ? r[0] - e.x < e.width + Zt ? te(T(e.x + e.width, e.y - Zt), n, e.angle) : te(T(e.x + e.width + Zt, e.y), n, e.angle) : t;
}, aie = (e, t, n = 0.05) => {
  let { x: r, y: i, width: a, height: l, angle: s } = e, c = T(r + a / 2 - 0.1, i + l / 2 - 0.1), d = te(t, c, -s), o = ft(n * l, 5, 80), u = ft(n * a, 5, 80);
  return d[0] <= r + a / 2 && d[1] > c[1] - o && d[1] < c[1] + o ? te(T(r - Zt, c[1]), c, s) : d[1] <= i + l / 2 && d[0] > c[0] - u && d[0] < c[0] + u ? te(T(c[0], i - Zt), c, s) : d[0] >= r + a / 2 && d[1] > c[1] - o && d[1] < c[1] + o ? te(T(r + a + Zt, c[1]), c, s) : d[1] >= i + l / 2 && d[0] > c[0] - u && d[0] < c[0] + u ? te(T(c[0], i + l + Zt), c, s) : t;
}, lie = (e, t, n, r, i) => {
  if (n == null || n.elementId !== r.id && e.points.length > 2) return null;
  let a = t === "startBinding" ? -1 : 1, l = a === -1 ? 0 : e.points.length - 1;
  if (Se(e) && km(n)) {
    let u = d2(n.fixedPoint) ?? Dm(e, r, t === "startBinding" ? "start" : "end").fixedPoint, h = T(r.x + r.width / 2, r.y + r.height / 2), f = T(r.x + u[0] * r.width, r.y + u[1] * r.height), p = te(f, h, r.angle);
    return Ee.pointFromAbsoluteCoords(e, p, i);
  }
  let s = l - a, c = Ee.getPointAtIndexGlobalCoordinates(e, s, i), d = oie(r, n.focus, c), o;
  if (n.gap === 0) o = d;
  else {
    let u = Ee.getPointAtIndexGlobalCoordinates(e, l, i), h = T(r.x + r.width / 2, r.y + r.height / 2), f = Tt(c, u) + Tt(c, h) + Math.max(r.width, r.height) * 2, p = TA(r, Re(c, pt(An(Rr(Le(d, c)), f), c)), n.gap).sort((g, b) => Kh(g, c) - Kh(b, c));
    p.length > 1 ? o = p[0] : p.length === 1 ? o = d : o = u;
  }
  return Ee.pointFromAbsoluteCoords(e, o, i);
}, Dm = (e, t, n, r) => {
  let i = [t.x, t.y, t.x + t.width, t.y + t.height], a = Jh(e, t, n), l = T(i[0] + (i[2] - i[0]) / 2, i[1] + (i[3] - i[1]) / 2), s = te(a, l, -t.angle);
  return { fixedPoint: d2([(s[0] - t.x) / t.width, (s[1] - t.y) / t.height]) };
}, Dx = (e, t, n) => {
  if (t == null || n == null) return t;
  let { width: r, height: i } = n, { width: a, height: l } = e, s = Math.max(1, Math.min(Vf(e, r, i), t.gap * (r < i ? r / a : i / l)));
  return { ...t, gap: s };
}, zd = (e, t, n, r, i) => Sa(JA(e, t, n), r, n, i, Se(e), Se(e)), JA = (e, t, n) => {
  let r = t === "start" ? 0 : -1;
  return xa(Ee.getPointAtIndexGlobalCoordinates(e, r, n));
}, QA = (e, t, n, r) => {
  let i = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set(), l = r === "duplicatesServeAsOld", s = new Map([...n].map(([c, d]) => [d, c]));
  t.forEach((c) => {
    let { boundElements: d } = c;
    if (d != null && d.length > 0 && (d.forEach((o) => {
      l && !n.has(o.id) && i.add(o.id);
    }), a.add(n.get(c.id))), hl(c)) {
      if (c.startBinding != null) {
        let { elementId: o } = c.startBinding;
        l && !n.has(o) && a.add(o);
      }
      if (c.endBinding != null) {
        let { elementId: o } = c.endBinding;
        l && !n.has(o) && a.add(o);
      }
      (c.startBinding != null || c.endBinding != null) && i.add(n.get(c.id));
    }
  }), e.filter(({ id: c }) => i.has(c)).forEach((c) => {
    let { startBinding: d, endBinding: o } = c;
    le(c, { startBinding: Lx(d, n), endBinding: Lx(o, n) });
  }), e.filter(({ id: c }) => a.has(c)).forEach((c) => {
    var u;
    let d = s.get(c.id), o = (u = e.find(({ id: h }) => h === d)) == null ? void 0 : u.boundElements;
    o && o.length > 0 && le(c, { boundElements: o.map((h) => n.has(h.id) ? { id: n.get(h.id), type: h.type } : h) });
  });
}, Lx = (e, t) => e == null ? null : { ...e, elementId: t.get(e.elementId) ?? e.elementId }, eN = (e, t) => {
  let n = Ge(e);
  for (let r of t) Bd.unbindAffected(n, r, le), Hd.unbindAffected(n, r, le);
}, Qh = (e, t, n = []) => {
  if (!e) return null;
  let r = e.filter((i) => !t.has(i.id));
  return r.push(...n.map((i) => ({ id: i.id, type: i.type }))), r;
}, vp = (e, { x: t, y: n }, r, i, a) => {
  let l = Vf(e, e.width, e.height, i), s = Jl(e, r);
  return u7(T(t, n), s, l) || a === !0 && y0(T(t, n), sl(e));
}, Vf = (e, t, n, r) => {
  let i = r != null && r.value && r.value < 1 ? r.value : 1, a = (e.type === "diamond" ? 1 / Math.sqrt(2) : 1) * Math.min(t, n);
  return Math.max(16, Math.min(0.25 * a, 32), P8 / i + O8);
}, sie = (e, t, n) => {
  let r = T(e.x + e.width / 2, e.y + e.height / 2);
  if (Ra(t, n)) return 0;
  let i = te(t, r, -e.angle), a = te(n, r, -e.angle), l = Math.sign(ar(Le(a, t), Le(a, r))) * -1, s = Re(a, pt(An(Rr(Le(a, i)), Math.max(e.width * 2, e.height * 2)), a)), c = e.type === "diamond" ? [Re(T(e.x + e.width / 2, e.y), T(e.x + e.width / 2, e.y + e.height)), Re(T(e.x, e.y + e.height / 2), T(e.x + e.width, e.y + e.height / 2))] : [Re(T(e.x, e.y), T(e.x + e.width, e.y + e.height)), Re(T(e.x + e.width, e.y), T(e.x, e.y + e.height))], d = e.type === "diamond" ? [Re(T(e.x + e.width / 2, e.y - e.height), T(e.x + e.width / 2, e.y + e.height * 2)), Re(T(e.x - e.width, e.y + e.height / 2), T(e.x + e.width * 2, e.y + e.height / 2))] : [Re(T(e.x - e.width, e.y - e.height), T(e.x + e.width * 2, e.y + e.height * 2)), Re(T(e.x + e.width * 2, e.y - e.height), T(e.x - e.width, e.y + e.height * 2))];
  return [Yh(s, d[0]), Yh(s, d[1])].filter((o) => o !== null).sort((o, u) => Kh(o, n) - Kh(u, n)).map((o, u) => l * Tt(r, o) / (e.type === "diamond" ? Tt(c[u][0], c[u][1]) / 2 : Math.sqrt(e.width ** 2 + e.height ** 2) / 2)).sort((o, u) => Math.abs(o) - Math.abs(u))[0] ?? 0;
}, oie = (e, t, n) => {
  let r = T(e.x + e.width / 2, e.y + e.height / 2);
  if (t === 0) return r;
  let i = (e.type === "diamond" ? [T(e.x, e.y + e.height / 2), T(e.x + e.width / 2, e.y), T(e.x + e.width, e.y + e.height / 2), T(e.x + e.width / 2, e.y + e.height)] : [T(e.x, e.y), T(e.x + e.width, e.y), T(e.x + e.width, e.y + e.height), T(e.x, e.y + e.height)]).map((l) => pt(An(Le(l, r), Math.abs(t)), r)).map((l) => te(l, r, e.angle)), a = [ar(Le(n, i[0]), Le(i[1], i[0])) > 0 && (t > 0 ? ar(Le(n, i[1]), Le(i[2], i[1])) < 0 : ar(Le(n, i[3]), Le(i[0], i[3])) < 0), ar(Le(n, i[1]), Le(i[2], i[1])) > 0 && (t > 0 ? ar(Le(n, i[2]), Le(i[3], i[2])) < 0 : ar(Le(n, i[0]), Le(i[1], i[0])) < 0), ar(Le(n, i[2]), Le(i[3], i[2])) > 0 && (t > 0 ? ar(Le(n, i[3]), Le(i[0], i[3])) < 0 : ar(Le(n, i[1]), Le(i[2], i[1])) < 0), ar(Le(n, i[3]), Le(i[0], i[3])) > 0 && (t > 0 ? ar(Le(n, i[0]), Le(i[1], i[0])) < 0 : ar(Le(n, i[2]), Le(i[3], i[2])) < 0)];
  return a[0] ? t > 0 ? i[1] : i[0] : a[1] ? t > 0 ? i[2] : i[1] : a[2] ? t > 0 ? i[3] : i[2] : t > 0 ? i[0] : i[3];
}, cie = /* @__PURE__ */ new Set(["boundElements", "frameId", "containerId", "startBinding", "endBinding"]), o2 = (e, t, n) => {
  var r;
  Pa(t) && (((r = t.boundElements) == null ? void 0 : r.slice()) ?? []).forEach(({ id: i }) => {
    n(e.get(i), "boundElements", i);
  });
}, c2 = (e, t, n) => {
  let r = [];
  if (t.frameId) {
    let i = t.frameId;
    r.push(n(e.get(i), "frameId", i));
  }
  if (sn(t)) {
    let i = t.containerId;
    r.push(n(e.get(i), "containerId", i));
  }
  if (dt(t)) {
    if (t.startBinding) {
      let i = t.startBinding.elementId;
      r.push(n(e.get(i), "startBinding", i));
    }
    if (t.endBinding) {
      let i = t.endBinding.elementId;
      r.push(n(e.get(i), "endBinding", i));
    }
  }
  return r;
}, Bd = class {
  static unbindAffected(e, t, n) {
    t && c2(e, t, (r) => {
      !r || r.isDeleted || o2(e, r, (i, a, l) => {
        l === t.id && n(r, { boundElements: Qh(r.boundElements, /* @__PURE__ */ new Set([l])) });
      });
    });
  }
};
$(Bd, "rebindAffected", (e, t, n) => {
  !t || t.isDeleted || c2(e, t, (r, i) => {
    var a, l;
    if (!r || r.isDeleted) {
      n(t, { [i]: null });
      return;
    }
    i !== "frameId" && ((a = r.boundElements) != null && a.find((s) => s.id === t.id) || (dt(t) && n(r, { boundElements: Qh(r.boundElements, /* @__PURE__ */ new Set(), new Array(t)) }), we(t) && ((l = r.boundElements) != null && l.find((s) => s.type === "text") ? n(t, { [i]: null }) : n(r, { boundElements: Qh(r.boundElements, /* @__PURE__ */ new Set(), new Array(t)) }))));
  });
});
var Hd = class {
  static unbindAffected(e, t, n) {
    t && o2(e, t, (r) => {
      !r || r.isDeleted || c2(e, r, (i, a, l) => {
        l === t.id && n(r, { [a]: null });
      });
    });
  }
};
$(Hd, "rebindAffected", (e, t, n) => {
  !t || t.isDeleted || o2(e, t, (r, i, a) => {
    var l, s;
    if (!r || r.isDeleted) {
      n(t, { boundElements: Qh(t.boundElements, /* @__PURE__ */ new Set([a])) });
      return;
    }
    we(r) && (((s = (((l = t.boundElements) == null ? void 0 : l.slice()) ?? []).reverse().find((c) => c.type === "text")) == null ? void 0 : s.id) === r.id ? r.containerId !== t.id && n(r, { containerId: t.id }) : (r.containerId !== null && n(r, { containerId: null }), n(t, { boundElements: Qh(t.boundElements, /* @__PURE__ */ new Set([r.id])) })));
  });
});
var U7 = (e, t) => {
  let [n, r] = d2(e);
  return te(T(t.x + t.width * n, t.y + t.height * r), T(t.x + t.width / 2, t.y + t.height / 2), t.angle);
}, die = (e, t) => {
  let n = e.startBinding && t.get(e.startBinding.elementId), r = e.endBinding && t.get(e.endBinding.elementId), i = n && e.startBinding ? U7(e.startBinding.fixedPoint, n) : T(e.x + e.points[0][0], e.y + e.points[0][1]), a = r && e.endBinding ? U7(e.endBinding.fixedPoint, r) : T(e.x + e.points[e.points.length - 1][0], e.y + e.points[e.points.length - 1][1]);
  return [i, a];
}, uie = (e, t) => {
  let [n, r] = die(e, t);
  return [Ee.pointFromAbsoluteCoords(e, n, t), Ee.pointFromAbsoluteCoords(e, r, t)];
}, d2 = (e) => e && (Math.abs(e[0] - 0.5) < 1e-4 || Math.abs(e[1] - 0.5) < 1e-4) ? e.map((t) => Math.abs(t - 0.5) < 1e-4 ? 0.5001 : t) : e, hie = (e, t) => {
  let [n, r, i, a] = t, { x: l, y: s } = wa({ sceneX: n, sceneY: r }, e), { x: c, y: d } = wa({ sceneX: i, sceneY: a }, e);
  return c - l > e.width || d - s > e.height;
}, tN = ({ scenePoint: e, viewportDimensions: t, zoom: n, offsets: r }) => {
  let i = (t.width - ((r == null ? void 0 : r.right) ?? 0)) / 2 / n.value - e.x;
  i += ((r == null ? void 0 : r.left) ?? 0) / 2 / n.value;
  let a = (t.height - ((r == null ? void 0 : r.bottom) ?? 0)) / 2 / n.value - e.y;
  return a += ((r == null ? void 0 : r.top) ?? 0) / 2 / n.value, { scrollX: i, scrollY: a };
}, ef = (e, t) => {
  if (e = Fle(e), !e.length) return { scrollX: 0, scrollY: 0 };
  let [n, r, i, a] = Lt(e);
  hie(t, [n, r, i, a]) && ([n, r, i, a] = Ore(e, en({ clientX: t.scrollX, clientY: t.scrollY }, t)));
  let l = (n + i) / 2, s = (r + a) / 2;
  return tN({ scenePoint: { x: l, y: s }, viewportDimensions: { width: t.width, height: t.height }, zoom: t.zoom });
}, as = (e) => ft(vl(e, 6), h8, f8), fie = (e) => ft(Math.round(e), 1, 100), nN = (e) => ft(Math.round(e), 1, 100), rN = (e, t, n) => {
  let r = n.reduce((i, a) => (a.groupIds.includes(e) && (i[a.id] = !0), i), {});
  return Object.keys(r).length < 2 ? t.selectedGroupIds[e] || t.editingGroupId === e ? { selectedElementIds: t.selectedElementIds, selectedGroupIds: { ...t.selectedGroupIds, [e]: !1 }, editingGroupId: null } : t : { editingGroupId: t.editingGroupId, selectedGroupIds: { ...t.selectedGroupIds, [e]: !0 }, selectedElementIds: { ...t.selectedElementIds, ...r } };
}, Hr = function() {
  let e = null, t = null, n = null, r = (a, l, s, c) => {
    if (n !== void 0 && l === t && a === e && s.editingGroupId === (n == null ? void 0 : n.editingGroupId)) return n;
    let d = {};
    for (let h of a) {
      let f = h.groupIds;
      if (s.editingGroupId) {
        let p = f.indexOf(s.editingGroupId);
        p > -1 && (f = f.slice(0, p));
      }
      if (f.length > 0) {
        let p = f[f.length - 1];
        d[p] = !0;
      }
    }
    let o = {}, u = l.reduce((h, f) => {
      if (f.isDeleted) return h;
      let p = f.groupIds.find((g) => d[g]);
      return p && (h[f.id] = !0, Array.isArray(o[p]) ? o[p].push(f.id) : o[p] = [f.id]), h;
    }, {});
    for (let h of Object.keys(o)) o[h].length < 2 && d[h] && (d[h] = !1);
    return t = l, e = a, n = { editingGroupId: s.editingGroupId, selectedGroupIds: d, selectedElementIds: kt({ ...s.selectedElementIds, ...u }, c) }, n;
  }, i = (a, l, s, c) => {
    let d = c ? c.scene.getSelectedElements({ selectedElementIds: a.selectedElementIds, elements: l }) : ct(l, a);
    return d.length ? r(d, l, a, s) : { selectedGroupIds: {}, editingGroupId: null, selectedElementIds: kt(a.selectedElementIds, s) };
  };
  return i.clearCache = () => {
    t = null, e = null, n = null;
  }, i;
}(), iN = (e, t) => aN(e, t) != null, aN = (e, t) => t.groupIds.filter((n) => n !== e.editingGroupId).find((n) => e.selectedGroupIds[n]), wc = (e) => Object.entries(e.selectedGroupIds).filter(([t, n]) => n).map(([t, n]) => t), lN = (e, t) => {
  let n = { ...t, selectedGroupIds: {} };
  for (let r of e) {
    let i = r.groupIds;
    if (t.editingGroupId) {
      let a = i.indexOf(t.editingGroupId);
      a > -1 && (i = i.slice(0, a));
    }
    if (i.length > 0) {
      let a = i[i.length - 1];
      n = { ...n, ...rN(a, n, e) };
    }
  }
  return n.selectedGroupIds;
}, pie = (e, t) => ({ ...e, editingGroupId: t.groupIds.length ? t.groupIds[0] : null, selectedGroupIds: {}, selectedElementIds: { [t.id]: !0 } }), tf = (e, t) => e.groupIds.includes(t), ln = (e, t) => {
  let n = [];
  for (let r of e.values()) tf(r, t) && n.push(r);
  return n;
}, mie = (e, t) => e.groupIds.find((n) => t[n]), gie = (e, t, n) => {
  let r = [...e], i = t ? e.indexOf(t) : -1, a = i > -1 ? i : e.length;
  for (let l = 0; l < a; l++) r[l] = n(r[l]);
  return r;
}, bie = (e, t, n) => {
  let r = [...e], i = n ? r.indexOf(n) : -1, a = i > -1 ? i : r.length;
  return r.splice(a, 0, t), r;
}, Uie = (e, t) => e.filter((n) => !t[n]), u2 = (e, t) => {
  let n = /* @__PURE__ */ new Map();
  return e.forEach((r) => {
    let i = r.groupIds.length === 0 ? r.id : r.groupIds[r.groupIds.length - 1], a = n.get(i) || [], l = lt(r, t);
    l && a.push(l), n.set(i, [...a, r]);
  }), Array.from(n.values());
}, vie = (e) => {
  let t = /* @__PURE__ */ new Set();
  for (let [, n] of e) if (!n.isDeleted) for (let r of n.groupIds ?? []) t.add(r);
  return t;
}, sN = (e) => {
  let t = e.flatMap((i) => i.groupIds), n = /* @__PURE__ */ new Map(), r = 0;
  for (let i of t) n.set(i, (n.get(i) ?? 0) + 1), n.get(i) > r && (r = n.get(i));
  return r === e.length;
}, E0 = (e) => e.groupIds.length > 0, yie = 8, Rx = 99999, h2 = (e) => yie / e, ei = class {
};
$(ei, "referenceSnapPoints", null), $(ei, "visibleGaps", null), $(ei, "setReferenceSnapPoints", (e) => {
  ei.referenceSnapPoints = e;
}), $(ei, "getReferenceSnapPoints", () => ei.referenceSnapPoints), $(ei, "setVisibleGaps", (e) => {
  ei.visibleGaps = e;
}), $(ei, "getVisibleGaps", () => ei.visibleGaps), $(ei, "destroy", () => {
  ei.referenceSnapPoints = null, ei.visibleGaps = null;
});
var Gl = ei, nf = (e) => e.props.gridModeEnabled ?? e.state.gridModeEnabled, So = ({ event: e, app: t, selectedElements: n }) => e ? t.state.objectsSnapModeEnabled && !e[H.CTRL_OR_CMD] || !t.state.objectsSnapModeEnabled && e[H.CTRL_OR_CMD] && !nf(t) : n.length === 1 && n[0].type === "arrow" ? !1 : t.state.objectsSnapModeEnabled, wie = (e, t, n = 0.01) => Math.abs(e - t) <= n, rf = (e, t, { omitCenter: n, boundingBoxCorners: r, dragOffset: i } = { omitCenter: !1, boundingBoxCorners: !1 }) => {
  let a = [];
  if (e.length === 1) {
    let l = e[0], [s, c, d, o, u, h] = tt(l, t);
    i && (s += i.x, d += i.x, u += i.x, c += i.y, o += i.y, h += i.y);
    let f = (d - s) / 2, p = (o - c) / 2;
    if ((l.type === "diamond" || l.type === "ellipse") && !r) {
      let g = te(T(s, c + p), T(u, h), l.angle), b = te(T(s + f, c), T(u, h), l.angle), v = te(T(d, c + p), T(u, h), l.angle), U = te(T(s + f, o), T(u, h), l.angle), y = T(u, h);
      a = n ? [g, b, v, U] : [g, b, v, U, y];
    } else {
      let g = te(T(s, c), T(u, h), l.angle), b = te(T(d, c), T(u, h), l.angle), v = te(T(s, o), T(u, h), l.angle), U = te(T(d, o), T(u, h), l.angle), y = T(u, h);
      a = n ? [g, b, v, U] : [g, b, v, U, y];
    }
  } else if (e.length > 1) {
    let [l, s, c, d] = L8(e, i ?? { x: 0, y: 0 }), o = c - l, u = d - s, h = T(l, s), f = T(c, s), p = T(l, d), g = T(c, d), b = T(l + o / 2, s + u / 2);
    a = n ? [h, f, p, g] : [h, f, p, g, b];
  }
  return a.map((l) => T(yn(l[0]), yn(l[1])));
}, oN = (e, t, n, r) => {
  let i = t.filter((a) => Ve(a)).map((a) => a.id);
  return tD(e, t, n, r).filter((a) => !(a.frameId && i.includes(a.frameId)));
}, xie = (e, t, n, r) => {
  let i = oN(e, t, n, r), a = u2(i, r).filter((u) => !(u.length === 1 && sn(u[0]))).map((u) => Lt(u).map((h) => yn(h))), l = a.sort((u, h) => u[0] - h[0]), s = [], c = 0;
  e: for (let u = 0; u < l.length; u++) {
    let h = l[u];
    for (let f = u + 1; f < l.length; f++) {
      if (++c > Rx) break e;
      let p = l[f], [, g, b, v] = h, [U, y, , w] = p;
      b < U && Sm(Nr(g, v), Nr(y, w)) && s.push({ startBounds: h, endBounds: p, startSide: [T(b, g), T(b, v)], endSide: [T(U, y), T(U, w)], length: U - b, overlap: _m(Nr(g, v), Nr(y, w)) });
    }
  }
  let d = a.sort((u, h) => u[1] - h[1]), o = [];
  c = 0;
  e: for (let u = 0; u < d.length; u++) {
    let h = d[u];
    for (let f = u + 1; f < d.length; f++) {
      if (++c > Rx) break e;
      let p = d[f], [g, , b, v] = h, [U, y, w] = p;
      v < y && Sm(Nr(g, b), Nr(U, w)) && o.push({ startBounds: h, endBounds: p, startSide: [T(g, v), T(b, v)], endSide: [T(U, y), T(w, y)], length: y - v, overlap: _m(Nr(g, b), Nr(U, w)) });
    }
  }
  return { horizontalGaps: s, verticalGaps: o };
}, Px = (e, t, n, r, i, a, l) => {
  if (!So({ app: n, event: r, selectedElements: e })) return [];
  if (e.length === 0) return [];
  let s = Gl.getVisibleGaps();
  if (s) {
    let { horizontalGaps: c, verticalGaps: d } = s, [o, u, h, f] = L8(e, t).map((b) => yn(b)), p = (o + h) / 2, g = (u + f) / 2;
    for (let b of c) {
      if (!Sm(Nr(u, f), b.overlap)) continue;
      let v = b.startSide[0][0] + b.length / 2, U = yn(v - p);
      if (b.length > h - o && Math.abs(U) <= l.x) {
        Math.abs(U) < l.x && (i.length = 0), l.x = Math.abs(U);
        let k = { type: "gap", direction: "center_horizontal", gap: b, offset: U };
        i.push(k);
        continue;
      }
      let [, , y] = b.endBounds, w = o - y, x = yn(b.length - w);
      if (Math.abs(x) <= l.x) {
        Math.abs(x) < l.x && (i.length = 0), l.x = Math.abs(x);
        let k = { type: "gap", direction: "side_right", gap: b, offset: x };
        i.push(k);
        continue;
      }
      let [E, , ,] = b.startBounds, S = E - h, _ = yn(S - b.length);
      if (Math.abs(_) <= l.x) {
        Math.abs(_) < l.x && (i.length = 0), l.x = Math.abs(_);
        let k = { type: "gap", direction: "side_left", gap: b, offset: _ };
        i.push(k);
        continue;
      }
    }
    for (let b of d) {
      if (!Sm(Nr(o, h), b.overlap)) continue;
      let v = b.startSide[0][1] + b.length / 2, U = yn(v - g);
      if (b.length > f - u && Math.abs(U) <= l.y) {
        Math.abs(U) < l.y && (a.length = 0), l.y = Math.abs(U);
        let k = { type: "gap", direction: "center_vertical", gap: b, offset: U };
        a.push(k);
        continue;
      }
      let [, y, ,] = b.startBounds, w = y - f, x = yn(w - b.length);
      if (Math.abs(x) <= l.y) {
        Math.abs(x) < l.y && (a.length = 0), l.y = Math.abs(x);
        let k = { type: "gap", direction: "side_top", gap: b, offset: x };
        a.push(k);
        continue;
      }
      let [, , , E] = b.endBounds, S = yn(u - E), _ = b.length - S;
      if (Math.abs(_) <= l.y) {
        Math.abs(_) < l.y && (a.length = 0), l.y = Math.abs(_);
        let k = { type: "gap", direction: "side_bottom", gap: b, offset: _ };
        a.push(k);
        continue;
      }
    }
  }
}, Eie = (e, t, n, r) => {
  let i = oN(e, t, n, r);
  return u2(i, r).filter((a) => !(a.length === 1 && sn(a[0]))).flatMap((a) => rf(a, r));
}, S0 = (e, t, n, r, i, a, l) => {
  if (!So({ app: n, event: r, selectedElements: e }) || e.length === 0 && t.length === 0) return [];
  let s = Gl.getReferenceSnapPoints();
  if (s) for (let c of t) for (let d of s) {
    let o = d[0] - c[0], u = d[1] - c[1];
    Math.abs(o) <= l.x && (Math.abs(o) < l.x && (i.length = 0), i.push({ type: "point", points: [c, d], offset: o }), l.x = Math.abs(o)), Math.abs(u) <= l.y && (Math.abs(u) < l.y && (a.length = 0), a.push({ type: "point", points: [c, d], offset: u }), l.y = Math.abs(u));
  }
}, Sie = (e, t, n, r, i) => {
  var b, v;
  let a = n.state, l = ct(e, a);
  if (!So({ app: n, event: r, selectedElements: l }) || l.length === 0) return { snapOffset: { x: 0, y: 0 }, snapLines: [] };
  t.x = yn(t.x), t.y = yn(t.y);
  let s = [], c = [], d = h2(a.zoom.value), o = { x: d, y: d }, u = rf(l, i, { dragOffset: t });
  S0(l, u, n, r, s, c, o), Px(l, t, n, r, s, c, o);
  let h = { x: ((b = s[0]) == null ? void 0 : b.offset) ?? 0, y: ((v = c[0]) == null ? void 0 : v.offset) ?? 0 };
  o.x = 0, o.y = 0, s.length = 0, c.length = 0;
  let f = { x: yn(t.x + h.x), y: yn(t.y + h.y) };
  S0(l, rf(l, i, { dragOffset: f }), n, r, s, c, o), Px(l, f, n, r, s, c, o);
  let p = $8(s, c), g = kie(l, f, [...s, ...c].filter((U) => U.type === "gap"));
  return { snapOffset: h, snapLines: [...p, ...g] };
}, yn = (e) => Math.round(e * 10 ** 6) / 10 ** 6, Ox = (e) => {
  let t = /* @__PURE__ */ new Map();
  for (let n of e) {
    let r = n.join(",");
    t.has(r) || t.set(r, n);
  }
  return Array.from(t.values());
}, $8 = (e, t) => {
  let n = {}, r = {};
  if (e.length > 0) {
    for (let i of e) if (i.type === "point") {
      let a = yn(i.points[0][0]);
      n[a] || (n[a] = []), n[a].push(...i.points.map((l) => T(yn(l[0]), yn(l[1]))));
    }
  }
  if (t.length > 0) {
    for (let i of t) if (i.type === "point") {
      let a = yn(i.points[0][1]);
      r[a] || (r[a] = []), r[a].push(...i.points.map((l) => T(yn(l[0]), yn(l[1]))));
    }
  }
  return Object.entries(n).map(([i, a]) => ({ type: "points", points: Ox(a.map((l) => T(Number(i), l[1])).sort((l, s) => l[1] - s[1])) })).concat(Object.entries(r).map(([i, a]) => ({ type: "points", points: Ox(a.map((l) => T(l[0], Number(i))).sort((l, s) => l[0] - s[0])) })));
}, _ie = (e) => {
  let t = /* @__PURE__ */ new Map();
  for (let n of e) {
    let r = n.points.flat().map((i) => [yn(i)]).join(",");
    t.has(r) || t.set(r, n);
  }
  return Array.from(t.values());
}, kie = (e, t, n) => {
  let [r, i, a, l] = L8(e, t), s = [];
  for (let c of n) {
    let [d, o, u, h] = c.gap.startBounds, [f, p, g, b] = c.gap.endBounds, v = _m(Nr(i, l), c.gap.overlap), U = _m(Nr(r, a), c.gap.overlap);
    switch (c.direction) {
      case "center_horizontal": {
        if (v) {
          let y = (v[0] + v[1]) / 2;
          s.push({ type: "gap", direction: "horizontal", points: [T(c.gap.startSide[0][0], y), T(r, y)] }, { type: "gap", direction: "horizontal", points: [T(a, y), T(c.gap.endSide[0][0], y)] });
        }
        break;
      }
      case "center_vertical": {
        if (U) {
          let y = (U[0] + U[1]) / 2;
          s.push({ type: "gap", direction: "vertical", points: [T(y, c.gap.startSide[0][1]), T(y, i)] }, { type: "gap", direction: "vertical", points: [T(y, l), T(y, c.gap.endSide[0][1])] });
        }
        break;
      }
      case "side_right": {
        if (v) {
          let y = (v[0] + v[1]) / 2;
          s.push({ type: "gap", direction: "horizontal", points: [T(u, y), T(f, y)] }, { type: "gap", direction: "horizontal", points: [T(g, y), T(r, y)] });
        }
        break;
      }
      case "side_left": {
        if (v) {
          let y = (v[0] + v[1]) / 2;
          s.push({ type: "gap", direction: "horizontal", points: [T(a, y), T(d, y)] }, { type: "gap", direction: "horizontal", points: [T(u, y), T(f, y)] });
        }
        break;
      }
      case "side_top": {
        if (U) {
          let y = (U[0] + U[1]) / 2;
          s.push({ type: "gap", direction: "vertical", points: [T(y, l), T(y, o)] }, { type: "gap", direction: "vertical", points: [T(y, h), T(y, p)] });
        }
        break;
      }
      case "side_bottom": {
        if (U) {
          let y = (U[0] + U[1]) / 2;
          s.push({ type: "gap", direction: "vertical", points: [T(y, h), T(y, p)] }, { type: "gap", direction: "vertical", points: [T(y, b), T(y, i)] });
        }
        break;
      }
    }
  }
  return _ie(s.map((c) => ({ ...c, points: c.points.map((d) => T(yn(d[0]), yn(d[1]))) })));
}, $x = (e, t, n, r, i, a) => {
  var E, S;
  if (!So({ event: r, selectedElements: e, app: n }) || e.length === 0 || e.length === 1 && !wie(e[0].angle, 0)) return { snapOffset: { x: 0, y: 0 }, snapLines: [] };
  let [l, s, c, d] = Lt(t);
  a && (a.includes("e") ? c += i.x : a.includes("w") && (l += i.x), a.includes("n") ? s += i.y : a.includes("s") && (d += i.y));
  let o = [];
  if (a) switch (a) {
    case "e": {
      o.push(T(c, s), T(c, d));
      break;
    }
    case "w": {
      o.push(T(l, s), T(l, d));
      break;
    }
    case "n": {
      o.push(T(l, s), T(c, s));
      break;
    }
    case "s": {
      o.push(T(l, d), T(c, d));
      break;
    }
    case "ne": {
      o.push(T(c, s));
      break;
    }
    case "nw": {
      o.push(T(l, s));
      break;
    }
    case "se": {
      o.push(T(c, d));
      break;
    }
    case "sw": {
      o.push(T(l, d));
      break;
    }
  }
  let u = h2(n.state.zoom.value), h = { x: u, y: u }, f = [], p = [];
  S0(t, o, n, r, f, p, h);
  let g = { x: ((E = f[0]) == null ? void 0 : E.offset) ?? 0, y: ((S = p[0]) == null ? void 0 : S.offset) ?? 0 };
  h.x = 0, h.y = 0, f.length = 0, p.length = 0;
  let [b, v, U, y] = Lt(e).map((_) => yn(_)), w = [T(b, v), T(b, y), T(U, v), T(U, y)];
  S0(e, w, n, r, f, p, h);
  let x = $8(f, p);
  return { snapOffset: g, snapLines: x };
}, Cie = (e, t, n, r, i, a) => {
  var p, g;
  if (!So({ event: n, selectedElements: [e], app: t })) return { snapOffset: { x: 0, y: 0 }, snapLines: [] };
  let l = [T(r.x + i.x, r.y + i.y)], s = h2(t.state.zoom.value), c = { x: s, y: s }, d = [], o = [];
  S0([e], l, t, n, d, o, c);
  let u = { x: ((p = d[0]) == null ? void 0 : p.offset) ?? 0, y: ((g = o[0]) == null ? void 0 : g.offset) ?? 0 };
  c.x = 0, c.y = 0, d.length = 0, o.length = 0;
  let h = rf([e], a, { boundingBoxCorners: !0, omitCenter: !0 });
  S0([e], h, t, n, d, o, c);
  let f = $8(d, o);
  return { snapOffset: u, snapLines: f };
}, Mie = (e, t, n, r, i) => {
  if (!So({ event: r, selectedElements: [], app: t })) return { originOffset: { x: 0, y: 0 }, snapLines: [] };
  let a = tD(e, [], t.state, i), l = h2(t.state.zoom.value), s = { x: l, y: l }, c = [], d = [];
  for (let o of a) {
    let u = rf([o], i);
    for (let h of u) {
      let f = h[0] - n.x;
      Math.abs(f) <= Math.abs(s.x) && (Math.abs(f) < Math.abs(s.x) && (d.length = 0), d.push({ type: "pointer", points: [h, T(h[0], n.y)], direction: "vertical" }), s.x = f);
      let p = h[1] - n.y;
      Math.abs(p) <= Math.abs(s.y) && (Math.abs(p) < Math.abs(s.y) && (c.length = 0), c.push({ type: "pointer", points: [h, T(n.x, h[1])], direction: "horizontal" }), s.y = p);
    }
  }
  return { originOffset: { x: d.length > 0 ? d[0].points[0][0] - n.x : 0, y: c.length > 0 ? c[0].points[0][1] - n.y : 0 }, snapLines: [...d, ...c] };
}, Tie = (e) => e === lr.rectangle || e === lr.ellipse || e === lr.diamond || e === lr.frame || e === lr.magicframe || e === lr.image || e === lr.text, Yn = (e, t, n) => n ? [Math.round(e / n) * n, Math.round(t / n) * n] : [e, t], Fs = { version: null, points: [], zoom: null }, Rn = class ut {
  constructor(t) {
    $(this, "elementId"), $(this, "selectedPointsIndices"), $(this, "pointerDownState"), $(this, "isDragging"), $(this, "lastUncommittedPoint"), $(this, "pointerOffset"), $(this, "startBindingElement"), $(this, "endBindingElement"), $(this, "hoverPointIndex"), $(this, "segmentMidPointHoveredCoords"), $(this, "elbowed"), this.elementId = t.id, Ra(t.points[0], T(0, 0)) || console.error("Linear element is not normalized", Error().stack), this.selectedPointsIndices = null, this.lastUncommittedPoint = null, this.isDragging = !1, this.pointerOffset = { x: 0, y: 0 }, this.startBindingElement = "keep", this.endBindingElement = "keep", this.pointerDownState = { prevSelectedPointsIndices: null, lastClickedPoint: -1, lastClickedIsEndPoint: !1, origin: null, segmentMidpoint: { value: null, index: null, added: !1 } }, this.hoverPointIndex = -1, this.segmentMidPointHoveredCoords = null, this.elbowed = Se(t) && t.elbowed;
  }
  static getElement(t, n) {
    return n.get(t) || null;
  }
  static handleBoxSelection(t, n, r, i) {
    if (!n.editingLinearElement || !n.selectionElement) return !1;
    let { editingLinearElement: a } = n, { selectedPointsIndices: l, elementId: s } = a, c = ut.getElement(s, i);
    if (!c) return !1;
    let [d, o, u, h] = tt(n.selectionElement, i), f = ut.getPointsGlobalCoordinates(c, i).reduce((p, g, b) => ((g[0] >= d && g[0] <= u && g[1] >= o && g[1] <= h || t.shiftKey && (l != null && l.includes(b))) && p.push(b), p), []).filter((p) => !(Se(c) && p !== 0 && p !== c.points.length - 1));
    r({ editingLinearElement: { ...a, selectedPointsIndices: f.length ? f : null } });
  }
  static handlePointDragging(t, n, r, i, a, l, s) {
    var p;
    if (!l) return !1;
    let { elementId: c } = l, d = s.getNonDeletedElementsMap(), o = ut.getElement(c, d);
    if (!o || Se(o) && !l.pointerDownState.lastClickedIsEndPoint && l.pointerDownState.lastClickedPoint !== 0) return !1;
    let u = Se(o) ? (p = l.selectedPointsIndices) == null ? void 0 : p.reduce((g, b) => b === 0 ? [0, g[1]] : [g[0], o.points.length - 1], [!1, !1]).filter((g) => typeof g == "number") : l.selectedPointsIndices, h = Se(o) ? l.pointerDownState.lastClickedPoint > 0 ? o.points.length - 1 : 0 : l.pointerDownState.lastClickedPoint, f = o.points[h];
    if (u && f) {
      if (bh(t) && u.length === 1 && o.points.length > 1) {
        let g = u[0], b = o.points[g === 0 ? 1 : g - 1], [v, U] = ut._getShiftLockedDelta(o, d, b, T(r, i), t[H.CTRL_OR_CMD] ? null : n.getEffectiveGridSize());
        ut.movePoints(o, [{ index: g, point: T(v + b[0], U + b[1]), isDragging: g === h }]);
      } else {
        let g = ut.createPointAt(o, d, r - l.pointerOffset.x, i - l.pointerOffset.y, t[H.CTRL_OR_CMD] ? null : n.getEffectiveGridSize()), b = g[0] - f[0], v = g[1] - f[1];
        ut.movePoints(o, u.map((U) => {
          let y = U === h ? ut.createPointAt(o, d, r - l.pointerOffset.x, i - l.pointerOffset.y, t[H.CTRL_OR_CMD] ? null : n.getEffectiveGridSize()) : T(o.points[U][0] + b, o.points[U][1] + v);
          return { index: U, point: y, isDragging: U === h };
        }));
      }
      if (lt(o, d) && Gf(o, d, !1), hl(o, !1)) {
        let g = [];
        u[0] === 0 && g.push(xa(ut.getPointGlobalCoordinates(o, o.points[0], d)));
        let b = u[u.length - 1];
        b === o.points.length - 1 && g.push(xa(ut.getPointGlobalCoordinates(o, o.points[b], d))), g.length && a(o, g);
      }
      return !0;
    }
    return !1;
  }
  static handlePointerUp(t, n, r, i) {
    var f;
    let a = i.getNonDeletedElementsMap(), l = i.getNonDeletedElements(), { elementId: s, selectedPointsIndices: c, isDragging: d, pointerDownState: o } = n, u = ut.getElement(s, a);
    if (!u) return n;
    let h = {};
    if (d && c) {
      for (let p of c) if (p === 0 || p === u.points.length - 1) {
        Us(u.points, r.zoom.value) && ut.movePoints(u, [{ index: p, point: p === 0 ? u.points[u.points.length - 1] : u.points[0] }]);
        let g = fc(r) ? Sa(xa(ut.getPointAtIndexGlobalCoordinates(u, p, a)), l, a, r.zoom, Se(u), Se(u)) : null;
        h[p === 0 ? "startBindingElement" : "endBindingElement"] = g;
      }
    }
    return { ...n, ...h, selectedPointsIndices: d || t.shiftKey ? !d && t.shiftKey && ((f = o.prevSelectedPointsIndices) != null && f.includes(o.lastClickedPoint)) ? c && c.filter((p) => p !== o.lastClickedPoint) : c : c != null && c.includes(o.lastClickedPoint) ? [o.lastClickedPoint] : c, isDragging: !1, pointerOffset: { x: 0, y: 0 } };
  }
  static isSegmentTooShort(t, n, r, i, a) {
    if (Se(t)) return i >= 0 && i < t.points.length ? Tt(n, r) * a.value < ut.POINT_HANDLE_SIZE / 2 : !1;
    let l = Tt(n, r);
    return t.points.length > 2 && t.roundness && (l = dre(t, r)), l * a.value < ut.POINT_HANDLE_SIZE * 4;
  }
  static getSegmentMidPoint(t, n, r, i, a) {
    let l = Bf(n, r);
    if (t.points.length > 2 && t.roundness) {
      let s = AA(t, t.points[i]);
      if (s) {
        let c = ure(t, t.points[i], 0.5);
        l = ut.getPointGlobalCoordinates(t, NA(s[0], s[1], s[2], s[3], c), a);
      }
    }
    return l;
  }
  static getSegmentMidPointIndex(t, n, r, i) {
    let a = ut.getElement(t.elementId, i);
    if (!a) return -1;
    let l = ut.getEditorMidPoints(a, i, n), s = 0;
    for (; s < l.length; ) {
      if (ut.arePointsEqual(r, l[s])) return s + 1;
      s++;
    }
    return -1;
  }
  static handlePointerDown(t, n, r, i, a, l) {
    var _;
    let s = n.state, c = l.getNonDeletedElementsMap(), d = l.getNonDeletedElements(), o = { didAddPoint: !1, hitElement: null, linearElementEditor: null };
    if (!a) return o;
    let { elementId: u } = a, h = ut.getElement(u, c);
    if (!h) return o;
    let f = ut.getSegmentMidpointHitCoords(a, i, s, c), p = null;
    if (f) p = ut.getSegmentMidPointIndex(a, s, f, c);
    else if (t.altKey && s.editingLinearElement) return a.lastUncommittedPoint == null && (le(h, { points: [...h.points, ut.createPointAt(h, c, i.x, i.y, t[H.CTRL_OR_CMD] ? null : n.getEffectiveGridSize())] }), o.didAddPoint = !0), r.shouldCaptureIncrement(), o.linearElementEditor = { ...a, pointerDownState: { prevSelectedPointsIndices: a.selectedPointsIndices, lastClickedPoint: -1, lastClickedIsEndPoint: !1, origin: { x: i.x, y: i.y }, segmentMidpoint: { value: f, index: p, added: !1 } }, selectedPointsIndices: [h.points.length - 1], lastUncommittedPoint: null, endBindingElement: Sa(i, d, c, n.state.zoom, a.elbowed) }, o.didAddPoint = !0, o;
    let g = ut.getPointIndexUnderCursor(h, c, s.zoom, i.x, i.y);
    if (g >= 0 || f) o.hitElement = h;
    else {
      let { startBindingElement: k, endBindingElement: M } = a;
      fc(s) && hl(h) && s2(h, k, M, c, l);
    }
    let [b, v, U, y] = tt(h, c), w = (b + U) / 2, x = (v + y) / 2, E = g > -1 && te(T(h.x + h.points[g][0], h.y + h.points[g][1]), T(w, x), h.angle), S = g > -1 || t.shiftKey ? t.shiftKey || (_ = a.selectedPointsIndices) != null && _.includes(g) ? Iie([...a.selectedPointsIndices || [], g]) : [g] : null;
    return o.linearElementEditor = { ...a, pointerDownState: { prevSelectedPointsIndices: a.selectedPointsIndices, lastClickedPoint: g, lastClickedIsEndPoint: g === h.points.length - 1, origin: { x: i.x, y: i.y }, segmentMidpoint: { value: f, index: p, added: !1 } }, selectedPointsIndices: S, pointerOffset: E ? { x: i.x - E[0], y: i.y - E[1] } : { x: 0, y: 0 } }, o;
  }
  static arePointsEqual(t, n) {
    return !t && !n ? !0 : !t || !n ? !1 : Ra(t, n);
  }
  static handlePointerMove(t, n, r, i, a) {
    let l = i.state;
    if (!l.editingLinearElement) return null;
    let { elementId: s, lastUncommittedPoint: c } = l.editingLinearElement, d = ut.getElement(s, a);
    if (!d) return l.editingLinearElement;
    let { points: o } = d, u = o[o.length - 1];
    if (!t.altKey) return u === c && ut.deletePoints(d, [o.length - 1]), { ...l.editingLinearElement, lastUncommittedPoint: null };
    let h;
    if (bh(t) && o.length >= 2) {
      let f = o[o.length - 2], [p, g] = ut._getShiftLockedDelta(d, a, f, T(n, r), t[H.CTRL_OR_CMD] ? null : i.getEffectiveGridSize());
      h = T(p + f[0], g + f[1]);
    } else h = ut.createPointAt(d, a, n - l.editingLinearElement.pointerOffset.x, r - l.editingLinearElement.pointerOffset.y, t[H.CTRL_OR_CMD] || Se(d) ? null : i.getEffectiveGridSize());
    return u === c ? ut.movePoints(d, [{ index: d.points.length - 1, point: h }]) : ut.addPoints(d, [{ point: h }]), { ...l.editingLinearElement, lastUncommittedPoint: d.points[d.points.length - 1] };
  }
  static getPointGlobalCoordinates(t, n, r) {
    let [i, a, l, s] = tt(t, r), c = (i + l) / 2, d = (a + s) / 2, { x: o, y: u } = t;
    return te(T(o + n[0], u + n[1]), T(c, d), t.angle);
  }
  static getPointsGlobalCoordinates(t, n) {
    let [r, i, a, l] = tt(t, n), s = (r + a) / 2, c = (i + l) / 2;
    return t.points.map((d) => {
      let { x: o, y: u } = t;
      return te(T(o + d[0], u + d[1]), T(s, c), t.angle);
    });
  }
  static getPointAtIndexGlobalCoordinates(t, n, r) {
    let i = n < 0 ? t.points.length + n : n, [a, l, s, c] = tt(t, r), d = (a + s) / 2, o = (l + c) / 2, u = t.points[i], { x: h, y: f } = t;
    return te(u ? T(h + u[0], f + u[1]) : T(h, f), T(d, o), t.angle);
  }
  static pointFromAbsoluteCoords(t, n, r) {
    if (Se(t)) return T(n[0] - t.x, n[1] - t.y);
    let [i, a, l, s] = tt(t, r), c = (i + l) / 2, d = (a + s) / 2, [o, u] = te(T(n[0], n[1]), T(c, d), -t.angle);
    return T(o - t.x, u - t.y);
  }
  static getPointIndexUnderCursor(t, n, r, i, a) {
    let l = ut.getPointsGlobalCoordinates(t, n), s = l.length;
    for (; --s > -1; ) {
      let c = l[s];
      if (Tt(T(i, a), T(c[0], c[1])) * r.value < ut.POINT_HANDLE_SIZE + 1) return s;
    }
    return -1;
  }
  static createPointAt(t, n, r, i, a) {
    let l = Yn(r, i, a), [s, c, d, o] = tt(t, n), u = (s + d) / 2, h = (c + o) / 2, [f, p] = te(T(l[0], l[1]), T(u, h), -t.angle);
    return T(f - t.x, p - t.y);
  }
  static getNormalizedPoints(t) {
    let { points: n } = t, r = n[0][0], i = n[0][1];
    return { points: n.map((a) => T(a[0] - r, a[1] - i)), x: t.x + r, y: t.y + i };
  }
  static normalizePoints(t) {
    le(t, ut.getNormalizedPoints(t));
  }
  static duplicateSelectedPoints(t, n) {
    Or(t.editingLinearElement, "Not currently editing a linear element");
    let { selectedPointsIndices: r, elementId: i } = t.editingLinearElement, a = ut.getElement(i, n);
    Or(a, "The linear element does not exist in the provided Scene"), Or(r != null, "There are no selected points to duplicate");
    let { points: l } = a, s = [], c = !1, d = -1, o = l.reduce((u, h, f) => {
      if (++d, u.push(h), r.includes(f)) {
        let p = l[f + 1];
        p || (c = !0), u.push(p ? T((h[0] + p[0]) / 2, (h[1] + p[1]) / 2) : T(h[0], h[1])), s.push(d + 1), ++d;
      }
      return u;
    }, []);
    if (le(a, { points: o }), c) {
      let u = a.points[a.points.length - 1];
      ut.movePoints(a, [{ index: a.points.length - 1, point: T(u[0] + 30, u[1] + 30) }]);
    }
    return { ...t, editingLinearElement: { ...t.editingLinearElement, selectedPointsIndices: s } };
  }
  static deletePoints(t, n) {
    let r = 0, i = 0;
    if (n.includes(0)) {
      let l = t.points.find((s, c) => !n.includes(c));
      l && (r = l[0], i = l[1]);
    }
    let a = t.points.reduce((l, s, c) => (n.includes(c) || l.push(l.length ? T(s[0] - r, s[1] - i) : T(0, 0)), l), []);
    ut._updatePoints(t, a, r, i);
  }
  static addPoints(t, n) {
    let r = [...t.points, ...n.map((i) => i.point)];
    ut._updatePoints(t, r, 0, 0);
  }
  static movePoints(t, n, r) {
    var o, u, h;
    let { points: i } = t, [a, l] = ((o = n.find(({ index: f }) => f === 0)) == null ? void 0 : o.point) ?? T(0, 0), [s, c] = T(a - i[0][0], l - i[0][1]), d = Se(t) ? [((u = n.find((f) => f.index === 0)) == null ? void 0 : u.point) ?? i[0], ((h = n.find((f) => f.index === i.length - 1)) == null ? void 0 : h.point) ?? i[i.length - 1]] : i.map((f, p) => {
      var b;
      let g = ((b = n.find((v) => v.index === p)) == null ? void 0 : b.point) ?? f;
      return T(g[0] - s, g[1] - c);
    });
    ut._updatePoints(t, d, s, c, r, { isDragging: n.reduce((f, p) => f || p.isDragging === !0, !1) });
  }
  static shouldAddMidpoint(t, n, r, i) {
    let a = ut.getElement(t.elementId, i);
    if (a && Se(a) || !a) return !1;
    let { segmentMidpoint: l } = t.pointerDownState;
    if (l.added || l.value === null || l.index === null || t.pointerDownState.origin === null) return !1;
    let s = t.pointerDownState.origin, c = Tt(T(s.x, s.y), T(n.x, n.y));
    return !(!r.editingLinearElement && c < ec / r.zoom.value);
  }
  static addMidpoint(t, n, r, i, a) {
    let l = ut.getElement(t.elementId, a);
    if (!l) return;
    let { segmentMidpoint: s } = t.pointerDownState, c = { pointerDownState: t.pointerDownState, selectedPointsIndices: t.selectedPointsIndices }, d = ut.createPointAt(l, a, n.x, n.y, i && !Se(l) ? r.getEffectiveGridSize() : null), o = [...l.points.slice(0, s.index), d, ...l.points.slice(s.index)];
    return le(l, { points: o }), c.pointerDownState = { ...t.pointerDownState, segmentMidpoint: { ...t.pointerDownState.segmentMidpoint, added: !0 }, lastClickedPoint: s.index }, c.selectedPointsIndices = [s.index], c;
  }
  static _updatePoints(t, n, r, i, a, l) {
    if (Se(t)) {
      let s = {};
      (a == null ? void 0 : a.startBinding) !== void 0 && (s.startBinding = a.startBinding !== null && km(a.startBinding) ? a.startBinding : null), (a == null ? void 0 : a.endBinding) !== void 0 && (s.endBinding = a.endBinding !== null && km(a.endBinding) ? a.endBinding : null), s.points = Array.from(n), le(t, s, !0, { isDragging: l == null ? void 0 : l.isDragging });
    } else {
      let s = Ax(t, n), c = Ax(t, t.points), d = (s[0] + s[2]) / 2, o = (s[1] + s[3]) / 2, u = (c[0] + c[2]) / 2, h = (c[1] + c[3]) / 2, f = u - d, p = h - o, g = te(T(r, i), T(f, p), t.angle);
      le(t, { ...a, points: n, x: t.x + g[0], y: t.y + g[1] });
    }
  }
  static _getShiftLockedDelta(t, n, r, i, a) {
    let l = ut.getPointGlobalCoordinates(t, r, n);
    if (Se(t)) return [i[0] - l[0], i[1] - l[1]];
    let [s, c] = Yn(i[0], i[1], a), { width: d, height: o } = C7(l[0], l[1], s, c);
    return te(T(d, o), T(0, 0), -t.angle);
  }
  static moveFixedSegment(t, n, r, i, a) {
    let l = ut.getElement(t.elementId, a);
    if (!l || !Se(l)) return t;
    if (n && n > 0 && n < l.points.length) {
      let s = is(qc(Le(l.points[n], l.points[n - 1]))), c = (l.fixedSegments ?? []).reduce((h, f) => (h[f.index] = f, h), {});
      c[n] = { index: n, start: T(s ? l.points[n - 1][0] : r - l.x, s ? i - l.y : l.points[n - 1][1]), end: T(s ? l.points[n][0] : r - l.x, s ? i - l.y : l.points[n][1]) };
      let d = Object.values(c).sort((h, f) => h.index - f.index), o = d.map((h) => h.index).reduce((h, f) => f < n ? h + 1 : h, 0);
      le(l, { fixedSegments: d });
      let u = T(l.x + (l.fixedSegments[o].start[0] + l.fixedSegments[o].end[0]) / 2, l.y + (l.fixedSegments[o].start[1] + l.fixedSegments[o].end[1]) / 2);
      return { ...t, segmentMidPointHoveredCoords: u, pointerDownState: { ...t.pointerDownState, segmentMidpoint: { added: !1, index: l.fixedSegments[o].index, value: u } } };
    }
    return t;
  }
  static deleteFixedSegment(t, n) {
    var r;
    le(t, { fixedSegments: (r = t.fixedSegments) == null ? void 0 : r.filter((i) => i.index !== n) }), le(t, {}, !0);
  }
};
$(Rn, "POINT_HANDLE_SIZE", 10), $(Rn, "getEditorMidPoints", (e, t, n) => {
  let r = lt(e, t);
  return !Se(e) && !n.editingLinearElement && e.points.length > 2 && !r ? [] : (Fs.version === e.version && Fs.zoom === n.zoom.value || Rn.updateEditorMidPointsCache(e, t, n), Fs.points);
}), $(Rn, "updateEditorMidPointsCache", (e, t, n) => {
  let r = Rn.getPointsGlobalCoordinates(e, t), i = 0, a = [];
  for (; i < r.length - 1; ) {
    if (Rn.isSegmentTooShort(e, e.points[i], e.points[i + 1], i, n.zoom)) {
      a.push(null), i++;
      continue;
    }
    let l = Rn.getSegmentMidPoint(e, r[i], r[i + 1], i + 1, t);
    a.push(l), i++;
  }
  Fs.points = a, Fs.version = e.version, Fs.zoom = n.zoom.value;
}), $(Rn, "getSegmentMidpointHitCoords", (e, t, n, r) => {
  let { elementId: i } = e, a = Rn.getElement(i, r);
  if (!a) return null;
  let l = Rn.getPointIndexUnderCursor(a, r, n.zoom, t.x, t.y);
  if (!Se(a) && l >= 0 || Rn.getPointsGlobalCoordinates(a, r).length >= 3 && !n.editingLinearElement && !Se(a)) return null;
  let s = (Rn.POINT_HANDLE_SIZE + 1) / n.zoom.value, c = e.segmentMidPointHoveredCoords;
  if (c && Tt(T(c[0], c[1]), T(t.x, t.y)) <= s) return c;
  let d = 0, o = Rn.getEditorMidPoints(a, r, n);
  for (; d < o.length; ) {
    if (o[d] !== null && Tt(o[d], T(t.x, t.y)) <= s) return o[d];
    d++;
  }
  return null;
}), $(Rn, "getBoundTextElementPosition", (e, t, n) => {
  let r = Rn.getPointsGlobalCoordinates(e, n);
  r.length < 2 && le(t, { isDeleted: !0 });
  let i = 0, a = 0;
  if (e.points.length % 2 === 1) {
    let l = Math.floor(e.points.length / 2), s = Rn.getPointGlobalCoordinates(e, e.points[l], n);
    i = s[0] - t.width / 2, a = s[1] - t.height / 2;
  } else {
    let l = e.points.length / 2 - 1, s = Fs.points[l];
    e.points.length === 2 && (s = Bf(r[0], r[1])), (!s || Fs.version !== e.version) && (s = Rn.getSegmentMidPoint(e, r[l], r[l + 1], l + 1, n)), i = s[0] - t.width / 2, a = s[1] - t.height / 2;
  }
  return { x: i, y: a };
}), $(Rn, "getMinMaxXYWithBoundText", (e, t, n, r) => {
  let [i, a, l, s] = n, c = (i + l) / 2, d = (a + s) / 2, { x: o, y: u } = Rn.getBoundTextElementPosition(e, r, t), h = o + r.width, f = u + r.height, p = T(c, d), g = te(T(i, a), p, e.angle), b = te(T(l, a), p, e.angle), v = te(T(o, u), p, -e.angle), U = te(T(h, u), p, -e.angle), y = te(T(o, f), p, -e.angle), w = te(T(h, f), p, -e.angle);
  return g[0] < b[0] && g[1] >= b[1] ? (i = Math.min(i, y[0]), l = Math.max(l, Math.max(U[0], w[0])), a = Math.min(a, v[1]), s = Math.max(s, w[1])) : g[0] >= b[0] && g[1] > b[1] ? (i = Math.min(i, w[0]), l = Math.max(l, Math.max(v[0], U[0])), a = Math.min(a, y[1]), s = Math.max(s, U[1])) : g[0] >= b[0] ? (i = Math.min(i, U[0]), l = Math.max(l, y[0]), a = Math.min(a, w[1]), s = Math.max(s, v[1])) : g[1] <= b[1] && (i = Math.min(i, Math.min(U[0], v[0])), l = Math.max(l, w[0]), a = Math.min(a, U[1]), s = Math.max(s, y[1])), [i, a, l, s, c, d];
}), $(Rn, "getElementAbsoluteCoords", (e, t, n = !1) => {
  let r, i, a, l, s;
  if (e.points.length < 2 || !wn.get(e)) {
    let { minX: u, minY: h, maxX: f, maxY: p } = e.points.reduce((g, [b, v]) => (g.minY = Math.min(g.minY, v), g.minX = Math.min(g.minX, b), g.maxX = Math.max(g.maxX, b), g.maxY = Math.max(g.maxY, v), g), { minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 });
    i = u + e.x, a = h + e.y, l = f + e.x, s = p + e.y;
  } else {
    let u = wn.generateElementShape(e, null), h = $o(u[0]), [f, p, g, b] = a2(h);
    i = f + e.x, a = p + e.y, l = g + e.x, s = b + e.y;
  }
  let c = (i + l) / 2, d = (a + s) / 2;
  if (r = [i, a, l, s, c, d], !n) return r;
  let o = lt(e, t);
  return o && (r = Rn.getMinMaxXYWithBoundText(e, t, [i, a, l, s], o)), r;
});
var Ee = Rn, Iie = (e) => {
  let t = [...new Set(e.filter((n) => n !== null && n !== -1))];
  return t = t.sort((n, r) => n - r), t.length ? t : null;
}, _0 = {}, Lm = (e, t) => {
  let n = _0[e] || (_0[e] = { height: t });
  return n.height = t, n;
}, cN = (e) => {
  _0[e] && delete _0[e];
}, Aie = (e) => {
  var t;
  return ((t = _0[e]) == null ? void 0 : t.height) ?? null;
}, jr = (e, t, n, r = !0) => {
  let i, a = { x: e.x, y: e.y, text: e.text, width: e.width, height: e.height, angle: (t == null ? void 0 : t.angle) ?? e.angle };
  a.text = e.text, (t || !e.autoResize) && (i = t ? ws(t, e) : e.width, a.text = cd(e.originalText, Wt(e), i));
  let l = $r(a.text, Wt(e), e.lineHeight);
  if (e.autoResize && (a.width = l.width), a.height = l.height, t) {
    let s = p2(t, e), c = ws(t, e);
    if (!dt(t) && l.height > s) {
      let h = Zc(l.height, t.type);
      le(t, { height: h }, r), Lm(t.id, h);
    }
    if (l.width > c) {
      let h = Zc(l.width, t.type);
      le(t, { width: h }, r);
    }
    let d = { ...e, ...a }, { x: o, y: u } = f2(t, d, n);
    a.x = o, a.y = u;
  }
  le(e, a, r);
}, dN = (e, t, n) => {
  let r = Ge(e);
  t.forEach((i) => {
    let a = n.get(i.id), l = ys(i);
    if (l) {
      let s = n.get(l);
      if (s) {
        let c = r.get(a);
        c && le(c, { boundElements: (i.boundElements || []).filter((o) => o.id !== s && o.id !== l).concat({ type: "text", id: s }) });
        let d = r.get(s);
        d && we(d) && le(d, { containerId: c ? a : null });
      }
    }
  });
}, Gf = (e, t, n, r = !1) => {
  if (!ys(e)) return;
  cN(e.id);
  let i = lt(e, t);
  if (i && i.text) {
    if (!e) return;
    let a = i.text, l = i.height, s = i.width, c = ws(e, i), d = p2(e, i), o = e.height;
    if (r || n !== "n" && n !== "s") {
      a && (a = cd(i.originalText, Wt(i), c));
      let u = $r(a, Wt(i), i.lineHeight);
      l = u.height, s = u.width;
    }
    if (l > d) {
      o = Zc(l, e.type);
      let u = o - e.height, h = !dt(e) && (n === "ne" || n === "nw" || n === "n") ? e.y - u : e.y;
      le(e, { height: o, y: h });
    }
    le(i, { text: a, width: s, height: l }), dt(e) || le(i, f2(e, i, t));
  }
}, f2 = (e, t, n) => {
  if (dt(e)) return Ee.getBoundTextElementPosition(e, t, n);
  let r = Nie(e), i = p2(e, t), a = ws(e, t), l, s;
  return t.verticalAlign === Si.TOP ? s = r.y : t.verticalAlign === Si.BOTTOM ? s = r.y + (i - t.height) : s = r.y + (i / 2 - t.height / 2), t.textAlign === jh.LEFT ? l = r.x : t.textAlign === jh.RIGHT ? l = r.x + (a - t.width) : l = r.x + (a / 2 - t.width / 2), { x: l, y: s };
}, ys = (e) => {
  var t, n, r;
  return ((t = e == null ? void 0 : e.boundElements) == null ? void 0 : t.length) && ((r = (n = e == null ? void 0 : e.boundElements) == null ? void 0 : n.find((i) => i.type === "text")) == null ? void 0 : r.id) || null;
}, lt = (e, t) => {
  if (!e) return null;
  let n = ys(e);
  return n && t.get(n) || null;
}, xr = (e, t) => e && e.containerId && t.get(e.containerId) || null, J6 = (e, t, n) => {
  if (!dt(e)) return { x: e.x + e.width / 2, y: e.y + e.height / 2 };
  let r = Ee.getPointsGlobalCoordinates(e, n);
  if (r.length % 2 === 1) {
    let l = Math.floor(e.points.length / 2), s = Ee.getPointGlobalCoordinates(e, e.points[l], n);
    return { x: s[0], y: s[1] };
  }
  let i = e.points.length / 2 - 1, a = Ee.getEditorMidPoints(e, n, t)[i];
  return a || (a = Ee.getSegmentMidPoint(e, r[i], r[i + 1], i + 1, n)), { x: a[0], y: a[1] };
}, Nie = (e) => {
  let t = Zn, n = Zn;
  return e.type === "ellipse" && (t += e.width / 2 * (1 - Math.sqrt(2) / 2), n += e.height / 2 * (1 - Math.sqrt(2) / 2)), e.type === "diamond" && (t += e.width / 4, n += e.height / 4), { x: e.x + t, y: e.y + n };
}, Die = (e, t) => !t || dt(t) ? e.angle : t.angle, Lie = (e, t) => e.some((n) => {
  if (sn(n)) {
    let r = xr(n, t);
    return !dt(r);
  }
  return !1;
}), Rie = (e, t) => e.some((n) => {
  if (sn(n)) {
    let r = xr(n, t);
    return !dt(r);
  }
  return we(n);
}), Pie = /* @__PURE__ */ new Set(["rectangle", "ellipse", "diamond", "arrow"]), Oie = (e) => Pie.has(e.type), Zc = (e, t) => {
  e = Math.ceil(e);
  let n = Zn * 2;
  return t === "ellipse" ? Math.round((e + n) / Math.sqrt(2) * 2) : t === "arrow" ? e + n * 8 : t === "diamond" ? 2 * (e + n) : e + n;
}, ws = (e, t) => {
  let { width: n } = e;
  if (dt(e)) {
    let r = ((t == null ? void 0 : t.fontSize) ?? Is) * UY;
    return Math.max(bY * n, r);
  }
  return e.type === "ellipse" ? Math.round(n / 2 * Math.sqrt(2)) - Zn * 2 : e.type === "diamond" ? Math.round(n / 2) - Zn * 2 : n - Zn * 2;
}, p2 = (e, t) => {
  let { height: n } = e;
  return dt(e) ? n - Zn * 8 * 2 <= 0 ? t.height : n : e.type === "ellipse" ? Math.round(n / 2 * Math.sqrt(2)) - Zn * 2 : e.type === "diamond" ? Math.round(n / 2) - Zn * 2 : n - Zn * 2;
}, $ie = (e, t = `

`) => e.reduce((n, r) => (we(r) && n.push(r.text), n), []).join(t), _i = (e) => (e = e.trim(), e && bI(fp(e))), uN = (e) => !!(e != null && e.includes(location.origin) || e != null && e.startsWith("/")), hN = (e) => {
  if (e = _i(e), e.startsWith("/")) return `${location.origin}${e}`;
  try {
    new URL(e);
  } catch {
    return "about:blank";
  }
  return e;
}, v7 = [], ve = (e) => (v7 = v7.concat(e), e), fN = '<svg viewBox="0 0 24 24" stroke-width="1" width="28" height="28" xmlns="http://www.w3.org/2000/svg">', Fie = '<path d="M6.164 11.755a5.314 5.314 0 0 1-4.932-5.298 5.314 5.314 0 0 1 5.311-5.311 5.314 5.314 0 0 1 5.307 5.113l8.773 8.773a3.322 3.322 0 0 1 0 4.696l-.895.895a3.322 3.322 0 0 1-4.696 0l-8.868-8.868Z" style="fill:#fff"/>', pN = '<path stroke="#1b1b1f" fill="#fff" d="m7.868 11.113 7.773 7.774a2.359 2.359 0 0 0 1.667.691 2.368 2.368 0 0 0 2.357-2.358c0-.625-.248-1.225-.69-1.667L11.201 7.78 9.558 9.469l-1.69 1.643v.001Zm10.273 3.606-3.333 3.333m-3.25-6.583 2 2m-7-7 3 3M3.664 3.625l1 1M2.529 6.922l1.407-.144m5.735-2.932-1.118.866M4.285 9.823l.758-1.194m1.863-6.207-.13 1.408"/>', zie = `data:${$e.svg},${encodeURIComponent(`${fN}${pN}</svg>`)}`, Bie = `data:${$e.svg},${encodeURIComponent(`${fN}${Fie}${pN}</svg>`)}`, fa = (e) => {
  e && (e.style.cursor = "");
}, Ht = (e, t) => {
  e && (e.style.cursor = t);
}, Ga, Fx, mN = (e, t) => {
  let n = () => {
    let r = t === gt.DARK;
    Ga = document.createElement("canvas"), Ga.theme = t, Ga.height = 20, Ga.width = 20;
    let i = Ga.getContext("2d");
    i.lineWidth = 1, i.beginPath(), i.arc(Ga.width / 2, Ga.height / 2, 5, 0, 2 * Math.PI), i.fillStyle = r ? wr.black : wr.white, i.fill(), i.strokeStyle = r ? wr.white : wr.black, i.stroke(), Fx = Ga.toDataURL($e.svg);
  };
  (!Ga || Ga.theme !== t) && n(), Ht(e, `url(${Fx}) ${20 / 2} ${20 / 2}, auto`);
}, Qa = (e, t) => {
  if (e) if (t.activeTool.type === "selection") fa(e);
  else if (m0(t)) e.style.cursor = Ot.GRAB;
  else if (tl(t)) mN(e, t.theme);
  else if (t.activeTool.type === "laser") {
    let n = t.theme === gt.LIGHT ? zie : Bie;
    e.style.cursor = `url(${n}), auto`;
  } else ["image", "custom"].includes(t.activeTool.type) ? t.activeTool.type !== "image" && (e.style.cursor = Ot.AUTO) : e.style.cursor = Ot.CROSSHAIR;
}, Hie = new sI(Date.now()), Wie = 0, _l = () => Math.floor(Hie.next() * 2 ** 31), ia = () => bs() ? `id${Wie++}` : l8(), $a = (e, { x: t, y: n, strokeColor: r = Cn.strokeColor, backgroundColor: i = Cn.backgroundColor, fillStyle: a = Cn.fillStyle, strokeWidth: l = Cn.strokeWidth, strokeStyle: s = Cn.strokeStyle, roughness: c = Cn.roughness, opacity: d = Cn.opacity, width: o = 0, height: u = 0, angle: h = 0, groupIds: f = [], frameId: p = null, index: g = null, roundness: b = null, boundElements: v = null, link: U = null, locked: y = Cn.locked, ...w }) => ((t < -1e6 || t > 1e6 || n < -1e6 || n > 1e6 || o < -1e6 || o > 1e6 || u < -1e6 || u > 1e6) && console.error("New element size or position is too large", { x: t, y: n, width: o, height: u, points: w.points }), { id: w.id || ia(), type: e, x: t, y: n, width: o, height: u, angle: h, strokeColor: r, backgroundColor: i, fillStyle: a, strokeWidth: l, strokeStyle: s, roughness: c, opacity: d, groupIds: f, frameId: p, index: g, roundness: b, seed: w.seed ?? _l(), version: w.version || 1, versionNonce: w.versionNonce ?? 0, isDeleted: !1, boundElements: v, updated: nu(), link: U, locked: y, customData: w.customData }), kl = (e) => $a(e.type, e), zx = (e) => $a("embeddable", e), Xie = (e) => ({ ...$a("iframe", e) }), F8 = (e) => at({ ...$a("frame", e), type: "frame", name: (e == null ? void 0 : e.name) || null }, {}), y7 = (e) => at({ ...$a("magicframe", e), type: "magicframe", name: (e == null ? void 0 : e.name) || null }, {}), gN = (e, t) => ({ x: e.textAlign === "center" ? t.width / 2 : e.textAlign === "right" ? t.width : 0, y: e.verticalAlign === "middle" ? t.height / 2 : 0 }), Ai = (e) => {
  let t = e.fontFamily || Oo, n = e.fontSize || Is, r = e.lineHeight || Yc(t), i = v0(e.text), a = $r(i, Wt({ fontFamily: t, fontSize: n }), r), l = e.textAlign || Ff, s = e.verticalAlign || mm, c = gN({ textAlign: l, verticalAlign: s }, a), d = { ...$a("text", e), text: i, fontSize: n, fontFamily: t, textAlign: l, verticalAlign: s, x: e.x - c.x, y: e.y - c.y, width: a.width, height: a.height, containerId: e.containerId || null, originalText: e.originalText ?? i, autoResize: e.autoResize ?? !0, lineHeight: r };
  return at(d, {});
}, Vie = (e, t, n) => {
  let { width: r, height: i } = $r(n, Wt(e), e.lineHeight);
  e.autoResize || (r = e.width);
  let { textAlign: a, verticalAlign: l } = e, s, c;
  if (a === "center" && l === Si.MIDDLE && !e.containerId && e.autoResize) {
    let d = $r(e.text, Wt(e), e.lineHeight), o = gN(e, { width: r - d.width, height: i - d.height });
    s = e.x - o.x, c = e.y - o.y;
  } else {
    let [d, o, u, h] = tt(e, t), [f, p, g, b] = po(e, r, i, !1), v = (d - f) / 2, U = (o - p) / 2, y = (u - g) / 2, w = (h - b) / 2;
    [s, c] = Gie({ s: !0, e: a === "center" || a === "left", w: a === "center" || a === "right" }, e.x, e.y, e.angle, v, U, y, w);
  }
  return { width: r, height: i, x: Number.isFinite(s) ? s : e.x, y: Number.isFinite(c) ? c : e.y };
}, Gie = (e, t, n, r, i, a, l, s) => {
  let c = Math.cos(r), d = Math.sin(r);
  return e.e && e.w ? t += i + l : e.e ? (t += i * (1 + c), n += i * d, t += l * (1 - c), n += l * -d) : e.w && (t += i * (1 - c), n += i * -d, t += l * (1 + c), n += l * d), e.n && e.s ? n += a + s : e.n ? (t += a * d, n += a * (1 - c), t += s * -d, n += s * (1 + c)) : (t += a * -d, n += a * (1 + c), t += s * d, n += s * (1 - c)), [t, n];
}, bN = (e, t, n, r = e.text) => {
  if (e.isDeleted) return;
  (t || !e.autoResize) && (r = cd(r, Wt(e), t ? ws(t, e) : e.width));
  let i = Vie(e, n, r);
  return { text: r, ...i };
}, jie = (e) => ({ ...$a(e.type, e), points: e.points || [], pressures: e.pressures || [], simulatePressure: e.simulatePressure, lastCommittedPoint: null }), xc = (e) => ({ ...$a(e.type, e), points: e.points || [], lastCommittedPoint: null, startBinding: null, endBinding: null, startArrowhead: null, endArrowhead: null }), z8 = (e) => e.elbowed ? { ...$a(e.type, e), points: e.points || [], lastCommittedPoint: null, startBinding: null, endBinding: null, startArrowhead: e.startArrowhead || null, endArrowhead: e.endArrowhead || null, elbowed: !0, fixedSegments: e.fixedSegments || [], startIsSpecial: !1, endIsSpecial: !1 } : { ...$a(e.type, e), points: e.points || [], lastCommittedPoint: null, startBinding: null, endBinding: null, startArrowhead: e.startArrowhead || null, endArrowhead: e.endArrowhead || null, elbowed: !1 }, UN = (e) => ({ ...$a("image", e), strokeColor: "transparent", status: e.status ?? "pending", fileId: e.fileId ?? null, scale: e.scale ?? [1, 1], crop: e.crop ?? null }), Rm = (e, t = 0) => {
  if (e == null || typeof e != "object") return e;
  let n = Object.prototype.toString.call(e);
  if (n === "[object Object]") {
    let r = typeof e.constructor == "function" ? Object.create(Object.getPrototypeOf(e)) : {};
    for (let i in e) if (e.hasOwnProperty(i)) {
      if (t === 0 && (i === "shape" || i === "canvas")) continue;
      r[i] = Rm(e[i], t + 1);
    }
    return r;
  }
  if (Array.isArray(e)) {
    let r = e.length, i = new Array(r);
    for (; r--; ) i[r] = Rm(e[r], t + 1);
    return i;
  }
  return st.DEV && n !== "[object Object]" && n !== "[object Array]" && n.startsWith("[object ") && console.warn(`_deepCloneElement: unexpected object type ${n}. This value will not be cloned!`), e;
}, dd = (e) => Rm(e), vN = (e, t) => {
  Object.defineProperty(e, wY, { value: t, writable: !1, enumerable: !1 });
}, Pm = () => ia(), yN = (e, t, n, r) => {
  let i = dd(n);
  return bs() && vN(i, n.id), i.id = Pm(), i.boundElements = null, i.updated = nu(), i.seed = _l(), i.groupIds = gie(i.groupIds, e, (a) => (t.has(a) || t.set(a, Pm()), t.get(a))), r && (i = Object.assign(i, r)), i;
}, wN = (e, t) => {
  let n = [], r = Ge(e), i = /* @__PURE__ */ new Map(), a = (s) => {
    if (i.has(s)) return i.get(s);
    if (r.has(s)) {
      let c = Pm();
      return i.set(s, c), c;
    }
    return null;
  }, l = /* @__PURE__ */ new Map();
  for (let s of e) {
    let c = Rm(s);
    if (c.id = a(s.id), bs() && vN(c, s.id), t != null && t.randomizeSeed && (c.seed = _l(), v2(c)), c.groupIds && (c.groupIds = c.groupIds.map((d) => (l.has(d) || l.set(d, Pm()), l.get(d)))), "containerId" in c && c.containerId) {
      let d = a(c.containerId);
      c.containerId = d;
    }
    if ("boundElements" in c && c.boundElements && (c.boundElements = c.boundElements.reduce((d, o) => {
      let u = a(o.id);
      return u && d.push({ ...o, id: u }), d;
    }, [])), "endBinding" in c && c.endBinding) {
      let d = a(c.endBinding.elementId);
      c.endBinding = d ? { ...c.endBinding, elementId: d } : null;
    }
    if ("startBinding" in c && c.startBinding) {
      let d = a(c.startBinding.elementId);
      c.startBinding = d ? { ...c.startBinding, elementId: d } : null;
    }
    c.frameId && (c.frameId = a(c.frameId)), n.push(c);
  }
  return n;
}, B8 = (e, { shouldThrow: t = !1, includeBoundTextValidation: n = !1, ignoreLogs: r, reconciliationContext: i }) => {
  let a = [], l = (c) => `${c == null ? void 0 : c.index}:${c == null ? void 0 : c.id}:${c == null ? void 0 : c.type}:${c == null ? void 0 : c.isDeleted}:${c == null ? void 0 : c.version}:${c == null ? void 0 : c.versionNonce}`, s = e.map((c) => c.index);
  for (let [c, d] of s.entries()) {
    let o = s[c - 1], u = s[c + 1];
    if (w7(d, o, u) || a.push(`Fractional indices invariant has been compromised: "${l(e[c - 1])}", "${l(e[c])}", "${l(e[c + 1])}"`), n && ra(e[c])) {
      let h = e[c], f = lt(h, Ge(e));
      f && f.index <= h.index && a.push(`Fractional indices invariant for bound elements has been compromised: "${l(f)}", "${l(h)}"`);
    }
  }
  if (a.length) {
    let c = new dJ(), d = [];
    if (i && (d.push("Additional reconciliation context:"), d.push(i.localElements.map((o) => l(o))), d.push(i.remoteElements.map((o) => l(o)))), r || console.error(a.join(`

`), c.stack, e.map((o) => l(o)), ...d), t) throw c;
  }
}, Kie = (e) => e.sort((t, n) => Bx(t) && Bx(n) ? t.index < n.index ? -1 : t.index > n.index ? 1 : t.id < n.id ? -1 : 1 : 1), Cl = (e, t) => {
  try {
    let n = Yie(e, t), r = xN(e, n), i = e.map((a) => r.has(a) ? { ...a, ...r.get(a) } : a);
    B8(i, { includeBoundTextValidation: !1, shouldThrow: !0, ignoreLogs: !0 });
    for (let [a, l] of r) le(a, l, !1);
  } catch {
    xs(e);
  }
  return e;
}, xs = (e) => {
  let t = qie(e), n = xN(e, t);
  for (let [r, i] of n) le(r, i, !1);
  return e;
}, Yie = (e, t) => {
  let n = [], r = 0;
  for (; r < e.length; ) if (t.has(e[r].id)) {
    let i = [r - 1, r];
    for (; ++r < e.length && t.has(e[r].id); ) i.push(r);
    i.push(r), n.push(i);
  } else r++;
  return n;
}, qie = (e) => {
  let t = [], n, r, i = -1, a = 0, l = (d) => {
    var h;
    let o = e[i] ? e[i].index : void 0, u = (h = e[d - 1]) == null ? void 0 : h.index;
    return !o && u || o && u && u > o ? [u, d - 1] : [o, i];
  }, s = (d) => {
    var h;
    let o = e[a] ? e[a].index : void 0;
    if (o && d < a) return [o, a];
    let u = a;
    for (; ++u < e.length; ) {
      let f = (h = e[u]) == null ? void 0 : h.index;
      if (!o && f || o && f && f > o) return [f, u];
    }
    return [void 0, u];
  }, c = 0;
  for (; c < e.length; ) {
    let d = e[c].index;
    if ([n, i] = l(c), [r, a] = s(c), w7(d, n, r)) c++;
    else {
      let o = [i, c];
      for (; ++c < e.length; ) {
        let u = e[c].index, [h, f] = l(c), [p, g] = s(c);
        if (w7(u, h, p)) break;
        [n, i] = [h, f], [r, a] = [p, g], o.push(c);
      }
      o.push(a), t.push(o);
    }
  }
  return t;
}, w7 = (e, t, n) => e ? t && n ? t < e && e < n : !t && n ? e < n : t && !n ? t < e : !!e : !1, xN = (e, t) => {
  var r, i;
  let n = /* @__PURE__ */ new Map();
  for (let a of t) {
    let l = a.shift(), s = a.pop(), c = e7((r = e[l]) == null ? void 0 : r.index, (i = e[s]) == null ? void 0 : i.index, a.length);
    for (let d = 0; d < a.length; d++) {
      let o = e[a[d]];
      n.set(o, { index: c[d] });
    }
  }
  return n;
}, Bx = (e) => !!e.index, Hn = class Ya {
  constructor(t, n) {
    this.deleted = t, this.inserted = n;
  }
  static create(t, n, r, i) {
    let a = r && i !== "inserted" ? r(t) : t, l = r && i !== "deleted" ? r(n) : n;
    return new Ya(a, l);
  }
  static calculate(t, n, r, i) {
    if (t === n) return Ya.empty();
    let a = {}, l = {};
    for (let d of this.distinctKeysIterator("full", t, n)) a[d] = t[d], l[d] = n[d];
    let [s, c] = i ? i(a, l) : [a, l];
    return Ya.create(s, c, r);
  }
  static empty() {
    return new Ya({}, {});
  }
  static isEmpty(t) {
    return !Object.keys(t.deleted).length && !Object.keys(t.inserted).length;
  }
  static mergeObjects(t, n, r) {
    let i = { ...t };
    for (let a of Object.keys(r)) delete i[a];
    return { ...i, ...n };
  }
  static mergeArrays(t, n, r, i) {
    return Object.values(Ya.mergeObjects(Bl(t ?? [], i), Bl(n ?? [], i), Bl(r ?? [], i)));
  }
  static diffObjects(t, n, r, i) {
    if (!(!t[r] && !n[r]) && (typeof t[r] == "object" || typeof n[r] == "object")) {
      let a = t[r] ?? {}, l = n[r] ?? {}, s = Ya.getLeftDifferences(a, l).reduce((d, o) => (d[o] = i(a[o]), d), {}), c = Ya.getRightDifferences(a, l).reduce((d, o) => (d[o] = i(l[o]), d), {});
      Object.keys(s).length || Object.keys(c).length ? (Reflect.set(t, r, s), Reflect.set(n, r, c)) : (Reflect.deleteProperty(t, r), Reflect.deleteProperty(n, r));
    }
  }
  static diffArrays(t, n, r, i) {
    if (!(!t[r] && !n[r]) && (Array.isArray(t[r]) || Array.isArray(n[r]))) {
      let a = Array.isArray(t[r]) ? t[r] : [], l = Array.isArray(n[r]) ? n[r] : [], s = Bl(Ya.getLeftDifferences(Bl(a, i), Bl(l, i))), c = Bl(Ya.getRightDifferences(Bl(a, i), Bl(l, i)));
      if (Object.keys(s).length || Object.keys(c).length) {
        let d = a.filter((u) => s[i ? i(u) : String(u)]), o = l.filter((u) => c[i ? i(u) : String(u)]);
        Reflect.set(t, r, d), Reflect.set(n, r, o);
      } else Reflect.deleteProperty(t, r), Reflect.deleteProperty(n, r);
    }
  }
  static isLeftDifferent(t, n, r = !1) {
    return !!this.distinctKeysIterator("left", t, n, r).next().value;
  }
  static isRightDifferent(t, n, r = !1) {
    return !!this.distinctKeysIterator("right", t, n, r).next().value;
  }
  static getLeftDifferences(t, n, r = !1) {
    return Array.from(this.distinctKeysIterator("left", t, n, r));
  }
  static getRightDifferences(t, n, r = !1) {
    return Array.from(this.distinctKeysIterator("right", t, n, r));
  }
  static *distinctKeysIterator(t, n, r, i = !1) {
    if (n === r) return;
    let a = [];
    t === "left" ? a = Object.keys(n) : t === "right" ? a = Object.keys(r) : t === "full" ? a = Array.from(/* @__PURE__ */ new Set([...Object.keys(n), ...Object.keys(r)])) : Vc(t, `Unknown distinctKeysIterator's join param "${t}"`, !0);
    for (let l of a) {
      let s = n[l], c = r[l];
      if (s !== c) {
        if (!i && typeof s == "object" && typeof c == "object" && s !== null && c !== null && Tr(s, c)) continue;
        yield l;
      }
    }
  }
}, Hx = class ti {
  constructor(t) {
    this.delta = t;
  }
  static calculate(t, n) {
    let r = Hn.calculate(t, n, void 0, ti.postProcess);
    return new ti(r);
  }
  static empty() {
    return new ti(Hn.create({}, {}));
  }
  inverse() {
    let t = Hn.create(this.delta.inserted, this.delta.deleted);
    return new ti(t);
  }
  applyTo(t, n) {
    try {
      let { selectedElementIds: r = {}, selectedGroupIds: i = {} } = this.delta.deleted, { selectedElementIds: a = {}, selectedGroupIds: l = {}, selectedLinearElementId: s, editingLinearElementId: c, ...d } = this.delta.inserted, o = Hn.mergeObjects(t.selectedElementIds, a, r), u = Hn.mergeObjects(t.selectedGroupIds, l, i), h = s && n.has(s) ? new Ee(n.get(s)) : null, f = c && n.has(c) ? new Ee(n.get(c)) : null, p = { ...t, ...d, selectedElementIds: o, selectedGroupIds: u, selectedLinearElement: typeof s < "u" ? h : t.selectedLinearElement, editingLinearElement: typeof c < "u" ? f : t.editingLinearElement }, g = this.filterInvisibleChanges(t, p, n);
      return [p, g];
    } catch (r) {
      if (console.error("Couldn't apply appstate change", r), st.DEV || st.MODE === oi.TEST) throw r;
      return [t, !1];
    }
  }
  isEmpty() {
    return Hn.isEmpty(this.delta);
  }
  static postProcess(t, n) {
    try {
      Hn.diffObjects(t, n, "selectedElementIds", (r) => !0), Hn.diffObjects(t, n, "selectedGroupIds", (r) => r ?? !1);
    } catch (r) {
      if (console.error("Couldn't postprocess appstate change deltas."), st.DEV || st.MODE === oi.TEST) throw r;
    } finally {
      return [t, n];
    }
  }
  filterInvisibleChanges(t, n, r) {
    let i = Om(t), a = Om(n), l = Hn.isRightDifferent(ti.stripElementsProps(i), ti.stripElementsProps(a)), s = Hn.isRightDifferent(ti.stripStandaloneProps(i), ti.stripStandaloneProps(a));
    if (!l && !s) return !1;
    let c = { value: l };
    if (s) {
      let d = Hn.getRightDifferences(ti.stripStandaloneProps(i), ti.stripStandaloneProps(a)), o = /* @__PURE__ */ new Set();
      (d.includes("editingGroupId") || d.includes("selectedGroupIds")) && (o = vie(r));
      for (let u of d) switch (u) {
        case "selectedElementIds":
          n[u] = ti.filterSelectedElements(n[u], r, c);
          break;
        case "selectedGroupIds":
          n[u] = ti.filterSelectedGroups(n[u], o, c);
          break;
        case "croppingElementId": {
          let g = n[u], b = g && r.get(g);
          b && !b.isDeleted ? c.value = !0 : n[u] = null;
          break;
        }
        case "editingGroupId":
          let h = n[u];
          h ? o.has(h) ? c.value = !0 : n[u] = null : c.value = !0;
          break;
        case "selectedLinearElementId":
        case "editingLinearElementId":
          let f = ti.convertToAppStateKey(u), p = n[f];
          if (!p) c.value = !0;
          else {
            let g = r.get(p.elementId);
            g && !g.isDeleted ? c.value = !0 : n[f] = null;
          }
          break;
        default:
          Vc(u, `Unknown ObservedElementsAppState's key "${u}"`, !0);
      }
    }
    return c.value;
  }
  static convertToAppStateKey(t) {
    switch (t) {
      case "selectedLinearElementId":
        return "selectedLinearElement";
      case "editingLinearElementId":
        return "editingLinearElement";
    }
  }
  static filterSelectedElements(t, n, r) {
    let i = Object.keys(t);
    if (!i.length) return r.value = !0, t;
    let a = { ...t };
    for (let l of i) {
      let s = n.get(l);
      s && !s.isDeleted ? r.value = !0 : delete a[l];
    }
    return a;
  }
  static filterSelectedGroups(t, n, r) {
    if (!Object.keys(t).length) return r.value = !0, t;
    let i = { ...t };
    for (let a of Object.keys(i)) n.has(a) ? r.value = !0 : delete i[a];
    return i;
  }
  static stripElementsProps(t) {
    let { editingGroupId: n, selectedGroupIds: r, selectedElementIds: i, editingLinearElementId: a, selectedLinearElementId: l, croppingElementId: s, ...c } = t;
    return c;
  }
  static stripStandaloneProps(t) {
    let { name: n, viewBackgroundColor: r, ...i } = t;
    return i;
  }
}, js = class bn {
  constructor(t, n, r) {
    this.added = t, this.removed = n, this.updated = r;
  }
  static create(t, n, r, i = { shouldRedistribute: !1 }) {
    let a;
    if (i.shouldRedistribute) {
      let l = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map(), d = [...t, ...n, ...r];
      for (let [o, u] of d) this.satisfiesAddition(u) ? l.set(o, u) : this.satisfiesRemoval(u) ? s.set(o, u) : c.set(o, u);
      a = new bn(l, s, c);
    } else a = new bn(t, n, r);
    return (st.DEV || st.MODE === oi.TEST) && (bn.validate(a, "added", this.satisfiesAddition), bn.validate(a, "removed", this.satisfiesRemoval), bn.validate(a, "updated", this.satisfiesUpdate)), a;
  }
  static validate(t, n, r) {
    for (let [i, a] of t[n].entries()) if (!r(a)) throw console.error(`Broken invariant for "${n}" delta, element "${i}", delta:`, a), new Error(`ElementsChange invariant broken for element "${i}".`);
  }
  static calculate(t, n) {
    if (t === n) return bn.empty();
    let r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
    for (let l of t.values()) if (!n.get(l.id)) {
      let s = { ...l, isDeleted: !1 }, c = { isDeleted: !0 }, d = Hn.create(s, c, bn.stripIrrelevantProps);
      i.set(l.id, d);
    }
    for (let l of n.values()) {
      let s = t.get(l.id);
      if (!s) {
        let c = { isDeleted: !0 }, d = { ...l, isDeleted: !1 }, o = Hn.create(c, d, bn.stripIrrelevantProps);
        r.set(l.id, o);
        continue;
      }
      if (s.versionNonce !== l.versionNonce) {
        let c = Hn.calculate(s, l, bn.stripIrrelevantProps, bn.postProcess);
        if (typeof s.isDeleted == "boolean" && typeof l.isDeleted == "boolean" && s.isDeleted !== l.isDeleted) {
          s.isDeleted && !l.isDeleted ? r.set(l.id, c) : i.set(l.id, c);
          continue;
        }
        Hn.isEmpty(c) || a.set(l.id, c);
      }
    }
    return bn.create(r, i, a);
  }
  static empty() {
    return bn.create(/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map());
  }
  inverse() {
    let t = (a) => {
      let l = /* @__PURE__ */ new Map();
      for (let [s, c] of a.entries()) l.set(s, Hn.create(c.inserted, c.deleted));
      return l;
    }, n = t(this.added), r = t(this.removed), i = t(this.updated);
    return bn.create(r, n, i);
  }
  isEmpty() {
    return this.added.size === 0 && this.removed.size === 0 && this.updated.size === 0;
  }
  applyLatestChanges(t) {
    let n = (s) => (c) => {
      let d = {};
      for (let o of Object.keys(c)) switch (o) {
        case "boundElements":
          d[o] = c[o];
          break;
        default:
          d[o] = s[o];
      }
      return d;
    }, r = (s) => {
      let c = /* @__PURE__ */ new Map();
      for (let [d, o] of s.entries()) {
        let u = t.get(d);
        if (u) {
          let h = Hn.create(o.deleted, o.inserted, n(u), "inserted");
          c.set(d, h);
        } else c.set(d, o);
      }
      return c;
    }, i = r(this.added), a = r(this.removed), l = r(this.updated);
    return bn.create(i, a, l, { shouldRedistribute: !0 });
  }
  applyTo(t, n) {
    let r = ta(new Map(t)), i, a = { containsVisibleDifference: !1, containsZindexDifference: !1 };
    try {
      let l = bn.createApplier(r, n, a), s = l(this.added), c = l(this.removed), d = l(this.updated), o = this.resolveConflicts(t, r);
      i = new Map([...s, ...c, ...d, ...o]);
    } catch (l) {
      if (console.error("Couldn't apply elements change", l), st.DEV || st.MODE === oi.TEST) throw l;
      return [t, !0];
    }
    try {
      bn.redrawTextBoundingBoxes(r, i), r = bn.reorderElements(r, i, a), bn.redrawBoundArrows(r, i);
    } catch (l) {
      if (console.error("Couldn't mutate elements after applying elements change", l), st.DEV || st.MODE === oi.TEST) throw l;
    } finally {
      return [r, a.containsVisibleDifference];
    }
  }
  static applyDelta(t, n, r = { containsVisibleDifference: !0, containsZindexDifference: !0 }) {
    var l, s;
    let { boundElements: i, ...a } = n.inserted;
    if ((l = n.deleted.boundElements) != null && l.length || (s = n.inserted.boundElements) != null && s.length) {
      let c = Hn.mergeArrays(t.boundElements, n.inserted.boundElements, n.deleted.boundElements, (d) => d.id);
      Object.assign(a, { boundElements: c });
    }
    if (Mt(t)) {
      let c = n;
      (c.deleted.crop || c.inserted.crop) && Object.assign(a, { crop: c.inserted.crop ?? null });
    }
    if (!r.containsVisibleDifference) {
      let { index: c, ...d } = a, o = bn.checkForVisibleDifference(t, d);
      r.containsVisibleDifference = o;
    }
    return r.containsZindexDifference || (r.containsZindexDifference = n.deleted.index !== n.inserted.index), at(t, a);
  }
  static checkForVisibleDifference(t, n) {
    return t.isDeleted && n.isDeleted !== !1 ? !1 : t.isDeleted && n.isDeleted === !1 || t.isDeleted === !1 && n.isDeleted ? !0 : Hn.isRightDifferent(t, n);
  }
  resolveConflicts(t, n) {
    let r = /* @__PURE__ */ new Map(), i = (d, o) => {
      let u = n.get(d.id);
      if (!u) return;
      let h;
      t.get(d.id) === u ? h = at(u, o) : h = le(u, o), r.set(h.id, h), n.set(h.id, h);
    };
    for (let [d] of this.removed) bn.unbindAffected(t, n, d, i);
    for (let [d] of this.added) bn.rebindAffected(t, n, d, i);
    for (let [d] of Array.from(this.updated).filter(([o, u]) => Object.keys({ ...u.deleted, ...u.inserted }).find((h) => cie.has(h)))) {
      let o = n.get(d);
      !o || o.isDeleted || bn.rebindAffected(t, n, d, i);
    }
    let a = new Map(Array.from(t).filter(([d]) => r.has(d))), { added: l, removed: s, updated: c } = bn.calculate(a, r);
    for (let [d, o] of l) this.added.set(d, o);
    for (let [d, o] of s) this.removed.set(d, o);
    for (let [d, o] of c) this.updated.set(d, o);
    return r;
  }
  static unbindAffected(t, n, r, i) {
    let a = () => t.get(r), l = () => n.get(r);
    Bd.unbindAffected(n, a(), i), Bd.unbindAffected(n, l(), i), Hd.unbindAffected(n, a(), i), Hd.unbindAffected(n, l(), i);
  }
  static rebindAffected(t, n, r, i) {
    let a = () => t.get(r), l = () => n.get(r);
    Bd.unbindAffected(n, a(), i), Bd.rebindAffected(n, l(), i), Hd.unbindAffected(n, a(), (s, c) => {
      we(s) && i(s, c);
    }), Hd.rebindAffected(n, l(), i);
  }
  static redrawTextBoundingBoxes(t, n) {
    let r = /* @__PURE__ */ new Map();
    for (let i of n.values()) {
      if (sn(i)) {
        let { containerId: a } = i, l = a ? t.get(a) : void 0;
        l && r.set(l.id, { container: l, boundText: i });
      }
      if (ra(i)) {
        let a = ys(i), l = a ? t.get(a) : void 0;
        l && r.set(i.id, { container: i, boundText: l });
      }
    }
    for (let { container: i, boundText: a } of r.values()) i.isDeleted || a.isDeleted || jr(a, i, t, !1);
  }
  static redrawBoundArrows(t, n) {
    for (let r of n.values()) !r.isDeleted && Pa(r) && ui(r, t, {});
  }
  static reorderElements(t, n, r) {
    if (!r.containsZindexDifference) return t;
    let i = Array.from(t.values()), a = Kie([...i]), l = Hn.getRightDifferences(i, a, !0).reduce((s, c) => {
      let d = i[Number(c)];
      return d && n.has(d.id) && s.set(d.id, d), s;
    }, /* @__PURE__ */ new Map());
    return !r.containsVisibleDifference && l.size && (r.containsVisibleDifference = !0), Ge(Cl(a, l));
  }
  static postProcess(t, n) {
    try {
      Hn.diffArrays(t, n, "boundElements", (r) => r.id);
    } catch (r) {
      if (console.error("Couldn't postprocess elements change deltas."), st.DEV || st.MODE === oi.TEST) throw r;
    } finally {
      return [t, n];
    }
  }
  static stripIrrelevantProps(t) {
    let { id: n, updated: r, version: i, versionNonce: a, seed: l, ...s } = t;
    return s;
  }
};
$(js, "satisfiesAddition", ({ deleted: e, inserted: t }) => e.isDeleted === !0 && !t.isDeleted), $(js, "satisfiesRemoval", ({ deleted: e, inserted: t }) => !e.isDeleted && t.isDeleted === !0), $(js, "satisfiesUpdate", ({ deleted: e, inserted: t }) => !!e.isDeleted == !!t.isDeleted), $(js, "createApplier", (e, t, n) => {
  let r = js.createGetter(e, t, n);
  return (i) => Array.from(i.entries()).reduce((a, [l, s]) => {
    let c = r(l, s.inserted);
    if (c) {
      let d = js.applyDelta(c, s, n);
      e.set(d.id, d), a.set(d.id, d);
    }
    return a;
  }, /* @__PURE__ */ new Map());
}), $(js, "createGetter", (e, t, n) => (r, i) => {
  let a = e.get(r);
  return a || (a = t.get(r), a && (n.containsZindexDifference = !0, (i.isDeleted === !1 || i.isDeleted !== !0 && a.isDeleted === !1) && (n.containsVisibleDifference = !0))), a;
});
var Wx = js, nl = class {
  constructor() {
    $(this, "subscribers", []);
  }
  on(...e) {
    let t = e.flat().filter((n) => typeof n == "function");
    return this.subscribers.push(...t), () => this.off(t);
  }
  once(...e) {
    let t = e.flat().filter((r) => typeof r == "function");
    t.push(() => n());
    let n = this.on(...t);
    return n;
  }
  off(...e) {
    let t = e.flat();
    this.subscribers = this.subscribers.filter((n) => !t.includes(n));
  }
  trigger(...e) {
    for (let t of this.subscribers) t(...e);
    return this;
  }
  clear() {
    this.subscribers = [];
  }
}, EN = "__observedAppState", Om = (e) => {
  var n, r;
  let t = { name: e.name, editingGroupId: e.editingGroupId, viewBackgroundColor: e.viewBackgroundColor, selectedElementIds: e.selectedElementIds, selectedGroupIds: e.selectedGroupIds, editingLinearElementId: ((n = e.editingLinearElement) == null ? void 0 : n.elementId) || null, selectedLinearElementId: ((r = e.selectedLinearElement) == null ? void 0 : r.elementId) || null, croppingElementId: e.croppingElementId };
  return Reflect.defineProperty(t, EN, { value: !0, enumerable: !1 }), t;
}, Zie = (e) => !!Reflect.get(e, EN), ne = { IMMEDIATELY: "IMMEDIATELY", NEVER: "NEVER", EVENTUALLY: "EVENTUALLY" }, Jie = class {
  constructor(e, t) {
    this.elementsChange = e, this.appStateChange = t;
  }
}, Qie = class {
  constructor() {
    $(this, "onStoreIncrementEmitter", new nl()), $(this, "scheduledActions", /* @__PURE__ */ new Set()), $(this, "_snapshot", Xx.empty()), $(this, "shouldCaptureIncrement", () => {
      this.scheduleAction(ne.IMMEDIATELY);
    }), $(this, "shouldUpdateSnapshot", () => {
      this.scheduleAction(ne.NEVER);
    }), $(this, "scheduleAction", (e) => {
      this.scheduledActions.add(e), this.satisfiesScheduledActionsInvariant();
    }), $(this, "commit", (e, t) => {
      try {
        this.scheduledActions.has(ne.IMMEDIATELY) ? this.captureIncrement(e, t) : this.scheduledActions.has(ne.NEVER) && this.updateSnapshot(e, t);
      } finally {
        this.satisfiesScheduledActionsInvariant(), this.scheduledActions = /* @__PURE__ */ new Set();
      }
    }), $(this, "captureIncrement", (e, t) => {
      let n = this.snapshot, r = this.snapshot.maybeClone(e, t);
      if (n !== r) {
        let i = r.meta.didElementsChange ? Wx.calculate(n.elements, r.elements) : Wx.empty(), a = r.meta.didAppStateChange ? Hx.calculate(n.appState, r.appState) : Hx.empty();
        (!i.isEmpty() || !a.isEmpty()) && this.onStoreIncrementEmitter.trigger(new Jie(i, a)), this.snapshot = r;
      }
    }), $(this, "updateSnapshot", (e, t) => {
      let n = this.snapshot.maybeClone(e, t);
      this.snapshot !== n && (this.snapshot = n);
    }), $(this, "filterUncomittedElements", (e, t) => {
      for (let [n, r] of e.entries()) {
        if (!t.get(n)) continue;
        let i = this.snapshot.elements.get(n);
        i ? i.version < r.version && t.set(n, i) : t.delete(n);
      }
      return t;
    }), $(this, "clear", () => {
      this.snapshot = Xx.empty(), this.scheduledActions = /* @__PURE__ */ new Set();
    }), $(this, "satisfiesScheduledActionsInvariant", () => {
      if (!(this.scheduledActions.size >= 0 && this.scheduledActions.size <= 3)) {
        let e = `There can be at most three store actions scheduled at the same time, but there are "${this.scheduledActions.size}".`;
        if (console.error(e, this.scheduledActions.values()), st.DEV || st.MODE === oi.TEST) throw new Error(e);
      }
    });
  }
  get snapshot() {
    return this._snapshot;
  }
  set snapshot(e) {
    this._snapshot = e;
  }
}, Xx = class x7 {
  constructor(t, n, r = { didElementsChange: !1, didAppStateChange: !1, isEmpty: !1 }) {
    this.elements = t, this.appState = n, this.meta = r;
  }
  static empty() {
    return new x7(/* @__PURE__ */ new Map(), Om(El()), { didElementsChange: !1, didAppStateChange: !1, isEmpty: !0 });
  }
  isEmpty() {
    return this.meta.isEmpty;
  }
  maybeClone(t, n) {
    let r = this.maybeCreateElementsSnapshot(t), i = this.maybeCreateAppStateSnapshot(n), a = !1, l = !1;
    return this.elements !== r && (a = !0), this.appState !== i && (l = !0), !a && !l ? this : new x7(r, i, { didElementsChange: a, didAppStateChange: l });
  }
  maybeCreateAppStateSnapshot(t) {
    if (!t) return this.appState;
    let n = Zie(t) ? t : Om(t);
    return this.detectChangedAppState(n) ? n : this.appState;
  }
  detectChangedAppState(t) {
    return !Tr(this.appState, t, { selectedElementIds: Tr, selectedGroupIds: Tr });
  }
  maybeCreateElementsSnapshot(t) {
    return t ? this.detectChangedElements(t) ? this.createElementsSnapshot(t) : this.elements : this.elements;
  }
  detectChangedElements(t) {
    if (this.elements === t) return !1;
    if (this.elements.size !== t.size) return !0;
    let n = Array.from(t.keys());
    for (let r = n.length - 1; r >= 0; r--) {
      let i = this.elements.get(n[r]), a = t.get(n[r]);
      if (!i || !a || i.id !== a.id || i.versionNonce !== a.versionNonce) return !0;
    }
    return !1;
  }
  createElementsSnapshot(t) {
    let n = /* @__PURE__ */ new Map();
    for (let [r, i] of this.elements.entries()) t.get(r) ? n.set(r, i) : n.set(r, at(i, { isDeleted: !0 }));
    for (let [r, i] of t.entries()) {
      let a = n.get(r);
      (!a || a && a.versionNonce !== i.versionNonce) && n.set(r, dd(i));
    }
    return n;
  }
}, ja = /* @__PURE__ */ new Map(), eae = /^(?:http(?:s)?:\/\/)?(?:www\.)?youtu(?:be\.com|\.be)\/(embed\/|watch\?v=|shorts\/|playlist\?list=|embed\/videoseries\?list=)?([a-zA-Z0-9_-]+)(?:\?t=|&t=|\?start=|&start=)?([a-zA-Z0-9_-]+)?[^\s]*$/, tae = /^(?:http(?:s)?:\/\/)?(?:(?:w){3}\.)?(?:player\.)?vimeo\.com\/(?:video\/)?([^?\s]+)(?:\?.*)?$/, nae = /^https:\/\/(?:www\.)?figma\.com/, Vx = /^https:\/\/gist\.github\.com\/([\w_-]+)\/([\w_-]+)/, rae = /^<script[\s\S]*?\ssrc=["'](https:\/\/gist\.github\.com\/.*?)\.js["']/i, Gx = /(?:https?:\/\/)?(?:(?:w){3}\.)?(?:twitter|x)\.com\/[^/]+\/status\/(\d+)/, iae = /^<blockquote[\s\S]*?\shref=["'](https?:\/\/(?:twitter|x)\.com\/[^"']*)/i, aae = /^https:\/\/(?:www\.)?val\.town\/(v|embed)\/[a-zA-Z_$][0-9a-zA-Z_$]+\.[a-zA-Z_$][0-9a-zA-Z_$]+/, lae = /^<(?:iframe|blockquote)[\s\S]*?\s(?:src|href)=["']([^"']*)["'][\s\S]*?>$/i, jx = /giphy.com\/(?:clips|embed|gifs)\/[a-zA-Z0-9]*?-?([a-zA-Z0-9]+)(?:[^a-zA-Z0-9]|$)/, Kx = /^(?:http(?:s)?:\/\/)?(?:www\.)?reddit\.com\/r\/([a-zA-Z0-9_]+)\/comments\/([a-zA-Z0-9_]+)\/([a-zA-Z0-9_]+)\/?(?:\?[^#\s]*)?(?:#[^\s]*)?$/, sae = /^<blockquote[\s\S]*?\shref=["'](https?:\/\/(?:www\.)?reddit\.com\/[^"']*)/i, E7 = /* @__PURE__ */ new Set(["youtube.com", "youtu.be", "vimeo.com", "player.vimeo.com", "figma.com", "link.excalidraw.com", "gist.github.com", "twitter.com", "x.com", "*.simplepdf.eu", "stackblitz.com", "val.town", "giphy.com", "reddit.com"]), Yx = /* @__PURE__ */ new Set(["youtube.com", "youtu.be", "vimeo.com", "player.vimeo.com", "figma.com", "twitter.com", "x.com", "*.simplepdf.eu", "stackblitz.com", "reddit.com"]), Uh = (e) => `<html><body>${e}</body></html>`, Wd = (e) => {
  if (!e) return null;
  if (ja.has(e)) return ja.get(e);
  let t = e, n = Yx.has(S7(e, Yx) || ""), r = "generic", i = { w: 560, h: 840 }, a = e.match(eae);
  if (a != null && a[2]) {
    let c = a[3] ? `&start=${a[3]}` : "", d = e.includes("shorts");
    switch (r = "video", a[1]) {
      case "embed/":
      case "watch?v=":
      case "shorts/":
        e = `https://www.youtube.com/embed/${a[2]}?enablejsapi=1${c}`;
        break;
      case "playlist?list=":
      case "embed/videoseries?list=":
        e = `https://www.youtube.com/embed/videoseries?list=${a[2]}&enablejsapi=1${c}`;
        break;
      default:
        e = `https://www.youtube.com/embed/${a[2]}?enablejsapi=1${c}`;
        break;
    }
    return i = d ? { w: 315, h: 560 } : { w: 560, h: 315 }, ja.set(t, { link: e, intrinsicSize: i, type: r, sandbox: { allowSameOrigin: n } }), { link: e, intrinsicSize: i, type: r, sandbox: { allowSameOrigin: n } };
  }
  let l = e.match(tae);
  if (l != null && l[1]) {
    let c = l == null ? void 0 : l[1], d = /^\d+$/.test(c) ? void 0 : new URIError("Invalid embed link format");
    return r = "video", e = `https://player.vimeo.com/video/${c}?api=1`, i = { w: 560, h: 315 }, ja.set(t, { link: e, intrinsicSize: i, type: r, sandbox: { allowSameOrigin: n } }), { link: e, intrinsicSize: i, type: r, error: d, sandbox: { allowSameOrigin: n } };
  }
  if (e.match(nae)) return r = "generic", e = `https://www.figma.com/embed?embed_host=share&url=${encodeURIComponent(e)}`, i = { w: 550, h: 550 }, ja.set(t, { link: e, intrinsicSize: i, type: r, sandbox: { allowSameOrigin: n } }), { link: e, intrinsicSize: i, type: r, sandbox: { allowSameOrigin: n } };
  let s = e.match(aae);
  if (s) return e = s[1] === "embed" ? s[0] : s[0].replace("/v", "/embed"), ja.set(t, { link: e, intrinsicSize: i, type: r, sandbox: { allowSameOrigin: n } }), { link: e, intrinsicSize: i, type: r, sandbox: { allowSameOrigin: n } };
  if (Gx.test(e)) {
    let c = e.match(Gx)[1], d = fp(`https://twitter.com/x/status/${c}`), o = { type: "document", srcdoc: (u) => Uh(`<blockquote class="twitter-tweet" data-dnt="true" data-theme="${u}"><a href="${d}"></a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"><\/script>`), intrinsicSize: { w: 480, h: 480 }, sandbox: { allowSameOrigin: n } };
    return ja.set(t, o), o;
  }
  if (Kx.test(e)) {
    let [, c, d, o] = e.match(Kx), u = fp(`https://reddit.com/r/${c}/comments/${d}/${o}`), h = { type: "document", srcdoc: (f) => Uh(`<blockquote class="reddit-embed-bq" data-embed-theme="${f}"><a href="${u}"></a><br></blockquote><script async="" src="https://embed.reddit.com/widgets.js" charset="UTF-8"><\/script>`), intrinsicSize: { w: 480, h: 480 }, sandbox: { allowSameOrigin: n } };
    return ja.set(t, h), h;
  }
  if (Vx.test(e)) {
    let [, c, d] = e.match(Vx), o = fp(`https://gist.github.com/${c}/${d}`), u = { type: "document", srcdoc: () => Uh(`
          <script src="${o}.js"><\/script>
          <style type="text/css">
            * { margin: 0px; }
            table, .gist { height: 100%; }
            .gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }
          </style>
        `), intrinsicSize: { w: 550, h: 720 }, sandbox: { allowSameOrigin: n } };
    return ja.set(e, u), u;
  }
  return ja.set(e, { link: e, intrinsicSize: i, type: r, sandbox: { allowSameOrigin: n } }), { link: e, intrinsicSize: i, type: r, sandbox: { allowSameOrigin: n } };
}, SN = (e) => {
  let t;
  qs(e) ? t = "IFrame element" : t = !e.link || (e == null ? void 0 : e.link) === "" ? "Empty Web-Embed" : e.link;
  let n = Math.max(Math.min(e.width / 2, e.width / t.length), e.width / 30), r = Un.Helvetica, i = Wt({ fontSize: n, fontFamily: r });
  return Ai({ x: e.x + e.width / 2, y: e.y + e.height / 2, strokeColor: e.strokeColor !== "transparent" ? e.strokeColor : "black", backgroundColor: "transparent", fontFamily: r, fontSize: n, text: cd(t, i, e.width - 20), textAlign: "center", verticalAlign: Si.MIDDLE, angle: e.angle ?? 0 });
};
ve({ name: "setEmbeddableAsActiveTool", trackEvent: { category: "toolbar" }, target: "Tool", label: "toolBar.embeddable", perform: (e, t, n, r) => {
  let i = Wn(t, { type: "embeddable" });
  return Qa(r.canvas, { ...t, activeTool: i }), { elements: e, appState: { ...t, activeTool: Wn(t, { type: "embeddable" }) }, captureUpdate: ne.EVENTUALLY };
} });
var S7 = (e, t) => {
  try {
    let { hostname: n } = new URL(e), r = n.replace(/^www\./, "");
    if (t instanceof Set) {
      if (E7.has(r)) return r;
      let a = r.replace(/^([^.]+)/, "*");
      return E7.has(a) ? a : null;
    }
    let i = t.replace(/^www\./, "");
    if (r === i) return i;
  } catch {
  }
  return null;
}, oae = (e) => {
  let t = e.match(iae);
  if (t && t.length === 2) return t[1];
  let n = e.match(sae);
  if (n && n.length === 2) return n[1];
  let r = e.match(rae);
  if (r && r.length === 2) return r[1];
  if (jx.test(e)) return `https://giphy.com/embed/${jx.exec(e)[1]}`;
  let i = e.match(lae);
  return i && i.length === 2 ? i[1] : e;
}, yp = (e, t) => {
  if (!e) return !1;
  if (t != null) if (typeof t == "function") {
    let n = t(e);
    if (typeof n == "boolean") return n;
  } else {
    if (typeof t == "boolean") return t;
    if (t instanceof RegExp) return t.test(e);
    if (Array.isArray(t)) {
      for (let n of t) if (n instanceof RegExp) {
        if (e.match(n)) return !0;
      } else if (S7(e, n)) return !0;
      return !1;
    }
  }
  return !!S7(e, E7);
}, Su = (e, t, n) => {
  let r = { sets: t.sets, shape: t.shape, options: { ...t.options, fixedDecimalPlaceDigits: n } };
  return e.draw(r);
}, _u = (e, t, n, r, i) => {
  if (!r.enabled || !r.clip) return null;
  let a = hi(e, i);
  if (a) {
    let l = t.ownerDocument.createElementNS(Et, "g");
    return l.setAttributeNS(Et, "clip-path", `url(#${a.id})`), n.forEach((s) => l.appendChild(s)), l;
  }
  return null;
}, wp = (e, t, n, r, i, a, l, s) => {
  var y;
  let c = { x: a, y: l }, [d, o, u, h] = tt(e, t), f = (u - d) / 2 - (e.x - d), p = (h - o) / 2 - (e.y - o);
  if (we(e)) {
    let w = xr(e, t);
    if (dt(w)) {
      let [x, E, S, _] = tt(w, t), k = Ee.getBoundTextElementPosition(w, e, t);
      f = (S - x) / 2 - (k.x - x), p = (_ - E) / 2 - (k.y - E), a = a + k.x - e.x, l = l + k.y - e.y;
    }
  }
  let g = 180 * e.angle / Math.PI, b = r;
  if (e.link) {
    let w = r.ownerDocument.createElementNS(Et, "a");
    w.setAttribute("href", _i(e.link)), b.appendChild(w), b = w;
  }
  let v = (w, x) => {
    bs() && w.setAttribute("data-id", x.id), b.appendChild(w);
  }, U = (((y = hi(e, t)) == null ? void 0 : y.opacity) ?? 100) * e.opacity / 1e4;
  switch (e.type) {
    case "selection":
      throw new Error("Selection rendering is not supported for SVG");
    case "rectangle":
    case "diamond":
    case "ellipse": {
      let w = wn.generateElementShape(e, null), x = Su(n, w, wu);
      U !== 1 && (x.setAttribute("stroke-opacity", `${U}`), x.setAttribute("fill-opacity", `${U}`)), x.setAttribute("stroke-linecap", "round"), x.setAttribute("transform", `translate(${a || 0} ${l || 0}) rotate(${g} ${f} ${p})`);
      let E = _u(e, b, [x], s.frameRendering, t);
      v(E || x, e);
      break;
    }
    case "iframe":
    case "embeddable": {
      let w = wn.generateElementShape(e, s), x = Su(n, w, wu), E = e.opacity / 100;
      E !== 1 && (x.setAttribute("stroke-opacity", `${E}`), x.setAttribute("fill-opacity", `${E}`)), x.setAttribute("stroke-linecap", "round"), x.setAttribute("transform", `translate(${a || 0} ${l || 0}) rotate(${g} ${f} ${p})`), v(x, e);
      let S = SN(e);
      wp(S, t, n, b, i, S.x + c.x - e.x, S.y + c.y - e.y, s);
      let _ = Su(n, w, wu);
      for (_.setAttribute("stroke-linecap", "round"), _.setAttribute("transform", `translate(${a || 0} ${l || 0}) rotate(${g} ${f} ${p})`); _.firstChild; ) _.removeChild(_.firstChild);
      let k = Aa(Math.min(e.width, e.height), e), M = Wd(hN(e.link || ""));
      if (s.renderEmbeddables === !1 || (M == null ? void 0 : M.type) === "document") {
        let A = r.ownerDocument.createElementNS(Et, "a");
        A.setAttribute("href", _i(e.link || "")), A.setAttribute("target", "_blank"), A.setAttribute("rel", "noopener noreferrer"), A.style.borderRadius = `${k}px`, _.appendChild(A);
      } else {
        let A = r.ownerDocument.createElementNS(Et, "foreignObject");
        A.style.width = `${e.width}px`, A.style.height = `${e.height}px`, A.style.border = "none";
        let L = A.ownerDocument.createElementNS(Et, "div");
        L.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), L.style.width = "100%", L.style.height = "100%";
        let R = L.ownerDocument.createElement("iframe");
        R.src = (M == null ? void 0 : M.link) ?? "", R.style.width = "100%", R.style.height = "100%", R.style.border = "none", R.style.borderRadius = `${k}px`, R.style.top = "0", R.style.left = "0", R.allowFullscreen = !0, L.appendChild(R), A.appendChild(L), _.appendChild(A);
      }
      v(_, e);
      break;
    }
    case "line":
    case "arrow": {
      let w = lt(e, t), x = r.ownerDocument.createElementNS(Et, "mask");
      if (w) {
        x.setAttribute("id", `mask-${e.id}`);
        let _ = r.ownerDocument.createElementNS(Et, "rect");
        a = a || 0, l = l || 0, _.setAttribute("x", "0"), _.setAttribute("y", "0"), _.setAttribute("fill", "#fff"), _.setAttribute("width", `${e.width + 100 + a}`), _.setAttribute("height", `${e.height + 100 + l}`), x.appendChild(_);
        let k = r.ownerDocument.createElementNS(Et, "rect"), M = Ee.getBoundTextElementPosition(e, w, t), A = a + M.x - e.x, L = l + M.y - e.y;
        k.setAttribute("x", A.toString()), k.setAttribute("y", L.toString()), k.setAttribute("fill", "#000"), k.setAttribute("width", `${w.width}`), k.setAttribute("height", `${w.height}`), k.setAttribute("opacity", "1"), x.appendChild(k);
      }
      let E = r.ownerDocument.createElementNS(Et, "g");
      w && E.setAttribute("mask", `url(#mask-${e.id})`), E.setAttribute("stroke-linecap", "round"), wn.generateElementShape(e, s).forEach((_) => {
        let k = Su(n, _, wu);
        U !== 1 && (k.setAttribute("stroke-opacity", `${U}`), k.setAttribute("fill-opacity", `${U}`)), k.setAttribute("transform", `translate(${a || 0} ${l || 0}) rotate(${g} ${f} ${p})`), e.type === "line" && Us(e.points) && e.backgroundColor !== "transparent" && k.setAttribute("fill-rule", "evenodd"), E.appendChild(k);
      });
      let S = _u(e, b, [E, x], s.frameRendering, t);
      S ? (v(S, e), b.appendChild(S)) : (v(E, e), b.append(x));
      break;
    }
    case "freedraw": {
      let w = wn.generateElementShape(e, s), x = w ? Su(n, w, wu) : r.ownerDocument.createElementNS(Et, "g");
      U !== 1 && (x.setAttribute("stroke-opacity", `${U}`), x.setAttribute("fill-opacity", `${U}`)), x.setAttribute("transform", `translate(${a || 0} ${l || 0}) rotate(${g} ${f} ${p})`), x.setAttribute("stroke", "none");
      let E = r.ownerDocument.createElementNS(Et, "path");
      E.setAttribute("fill", e.strokeColor), E.setAttribute("d", HA(e)), x.appendChild(E);
      let S = _u(e, b, [x], s.frameRendering, t);
      v(S || x, e);
      break;
    }
    case "image": {
      let w = Math.round(e.width), x = Math.round(e.height), E = zi(e) && i[e.fileId];
      if (E) {
        let { reuseImages: S = !0 } = s, _ = `image-${E.id}`, k = e.width, M = e.height;
        e.crop && ({ width: k, height: M } = vs(e), _ = `image-crop-${E.id}-${$le(`${k}x${M}`)}`), S || (_ = `image-${e.id}`);
        let A = r.querySelector(`#${_}`);
        if (!A) {
          A = r.ownerDocument.createElementNS(Et, "symbol"), A.id = _;
          let V = r.ownerDocument.createElementNS(Et, "image");
          V.setAttribute("href", E.dataURL), V.setAttribute("preserveAspectRatio", "none"), e.crop || !S ? (V.setAttribute("width", `${k}`), V.setAttribute("height", `${M}`)) : (V.setAttribute("width", "100%"), V.setAttribute("height", "100%")), A.appendChild(V), (b.querySelector("defs") || b).prepend(A);
        }
        let L = r.ownerDocument.createElementNS(Et, "use");
        L.setAttribute("href", `#${_}`), s.exportWithDarkMode && E.mimeType !== $e.svg && L.setAttribute("filter", LA);
        let R = 0, z = 0;
        if (e.crop) {
          let { width: V, height: q } = vs(e);
          R = e.crop.x / (e.crop.naturalWidth / V), z = e.crop.y / (e.crop.naturalHeight / q);
        }
        let F = f + R, W = p + z;
        L.setAttribute("width", `${w + R}`), L.setAttribute("height", `${x + z}`), L.setAttribute("opacity", `${U}`), (e.scale[0] !== 1 || e.scale[1] !== 1) && L.setAttribute("transform", `translate(${F} ${W}) scale(${e.scale[0]} ${e.scale[1]}) translate(${-F} ${-W})`);
        let B = r.ownerDocument.createElementNS(Et, "g");
        if (e.crop) {
          let V = r.ownerDocument.createElementNS(Et, "mask");
          V.setAttribute("id", `mask-image-crop-${e.id}`), V.setAttribute("fill", "#fff");
          let q = r.ownerDocument.createElementNS(Et, "rect");
          q.setAttribute("x", `${R}`), q.setAttribute("y", `${z}`), q.setAttribute("width", `${w}`), q.setAttribute("height", `${x}`), V.appendChild(q), b.appendChild(V), B.setAttribute("mask", `url(#${V.id})`);
        }
        if (B.appendChild(L), B.setAttribute("transform", `translate(${a - R} ${l - z}) rotate(${g} ${F} ${W})`), e.roundness) {
          let V = r.ownerDocument.createElementNS(Et, "clipPath");
          V.id = `image-clipPath-${e.id}`;
          let q = r.ownerDocument.createElementNS(Et, "rect"), oe = Aa(Math.min(e.width, e.height), e);
          q.setAttribute("width", `${e.width}`), q.setAttribute("height", `${e.height}`), q.setAttribute("rx", `${oe}`), q.setAttribute("ry", `${oe}`), V.appendChild(q), v(V, e), B.setAttributeNS(Et, "clip-path", `url(#${V.id})`);
        }
        let j = _u(e, b, [B], s.frameRendering, t);
        v(j || B, e);
      }
      break;
    }
    case "frame":
    case "magicframe": {
      if (s.frameRendering.enabled && s.frameRendering.outline) {
        let w = document.createElementNS(Et, "rect");
        w.setAttribute("transform", `translate(${a || 0} ${l || 0}) rotate(${g} ${f} ${p})`), w.setAttribute("width", `${e.width}px`), w.setAttribute("height", `${e.height}px`), w.setAttribute("rx", vn.radius.toString()), w.setAttribute("ry", vn.radius.toString()), w.setAttribute("fill", "none"), w.setAttribute("stroke", vn.strokeColor), w.setAttribute("stroke-width", vn.strokeWidth.toString()), v(w, e);
      }
      break;
    }
    default:
      if (we(e)) {
        let w = r.ownerDocument.createElementNS(Et, "g");
        U !== 1 && (w.setAttribute("stroke-opacity", `${U}`), w.setAttribute("fill-opacity", `${U}`)), w.setAttribute("transform", `translate(${a || 0} ${l || 0}) rotate(${g} ${f} ${p})`);
        let x = e.text.replace(/\r\n?/g, `
`).split(`
`), E = Wf(e.fontSize, e.lineHeight), S = e.textAlign === "center" ? e.width / 2 : e.textAlign === "right" ? e.width : 0, _ = wA(e.fontFamily, e.fontSize, E), k = $I(e.text) ? "rtl" : "ltr", M = e.textAlign === "center" ? "middle" : e.textAlign === "right" || k === "rtl" ? "end" : "start";
        for (let L = 0; L < x.length; L++) {
          let R = r.ownerDocument.createElementNS(Et, "text");
          R.textContent = x[L], R.setAttribute("x", `${S}`), R.setAttribute("y", `${L * E + _}`), R.setAttribute("font-family", g0(e)), R.setAttribute("font-size", `${e.fontSize}px`), R.setAttribute("fill", e.strokeColor), R.setAttribute("text-anchor", M), R.setAttribute("style", "white-space: pre;"), R.setAttribute("direction", k), R.setAttribute("dominant-baseline", "alphabetic"), w.appendChild(R);
        }
        let A = _u(e, b, [w], s.frameRendering, t);
        v(A || w, e);
      } else throw new Error(`Unimplemented type ${e.type}`);
  }
}, cae = (e, t, n, r, i, a) => {
  r && (e.filter((l) => !Bi(l)).forEach((l) => {
    if (!l.isDeleted) {
      if (we(l) && l.containerId && t.has(l.containerId)) return;
      try {
        wp(l, t, n, r, i, l.x + a.offsetX, l.y + a.offsetY, a);
        let s = lt(l, t);
        s && wp(s, t, n, r, i, s.x + a.offsetX, s.y + a.offsetY, a);
      } catch (s) {
        console.error(s);
      }
    }
  }), e.filter((l) => Bi(l)).forEach((l) => {
    if (!l.isDeleted) try {
      wp(l, t, n, r, i, l.x + a.offsetX, l.y + a.offsetY, a);
    } catch (s) {
      console.error(s);
    }
  }));
}, qx = 500, H8 = (e) => {
  var r, i;
  let t = (r = e.extensions) == null ? void 0 : r.reduce((a, l) => (a.push($e[l]), a), []), n = (i = e.extensions) == null ? void 0 : i.reduce((a, l) => l === "jpg" ? a.concat(".jpg", ".jpeg") : a.concat(`.${l}`), []);
  return OK({ description: e.description, extensions: n, mimeTypes: t, multiple: e.multiple ?? !1, legacySetup: (a, l, s) => {
    let c = b0(l, qx), d = () => {
      o(), document.addEventListener("keyup", c), document.addEventListener("pointerup", c), c();
    }, o = () => {
      var h;
      if ((h = s.files) != null && h.length) {
        let f = e.multiple ? [...s.files] : s.files[0];
        a(f);
      }
    };
    requestAnimationFrame(() => {
      window.addEventListener("focus", d);
    });
    let u = window.setInterval(() => {
      o();
    }, qx);
    return (h) => {
      clearInterval(u), c.cancel(), window.removeEventListener("focus", d), document.removeEventListener("keyup", c), document.removeEventListener("pointerup", c), h && (console.warn("Opening the file was canceled (legacy-fs)."), h(new r2()));
    };
  } });
}, $m = (e, t) => FK(e, { fileName: `${t.name}.${t.extension}`, description: t.description, extensions: [`.${t.extension}`], mimeTypes: t.mimeTypes }, t.fileHandle), dae = (e, t) => {
  let n = {};
  for (let r of e) !r.isDeleted && "fileId" in r && r.fileId && t[r.fileId] && (n[r.fileId] = t[r.fileId]);
  return n;
}, W8 = (e, t, n, r) => {
  let i = { type: ji.excalidraw, version: qg.excalidraw, source: u8, elements: cD(e), appState: DI(t), files: dae(e, n) };
  return JSON.stringify(i, null, 2);
}, _N = async (e, t, n, r = t.name || AI) => {
  let i = W8(e, t, n), a = new Blob([i], { type: $e.excalidraw });
  return { fileHandle: await $m(a, { name: r, extension: "excalidraw", description: "Excalidraw file", fileHandle: vU(t.fileHandle) ? null : t.fileHandle }) };
}, uae = async (e, t) => {
  let n = await H8({ description: "Excalidraw files" });
  return pD(await yU(n), e, t, n.handle);
}, hae = (e) => (e == null ? void 0 : e.type) === ji.excalidraw && (!e.elements || Array.isArray(e.elements) && (!e.appState || typeof e.appState == "object")), kN = (e) => typeof e == "object" && e && e.type === ji.excalidrawLibrary && (e.version === 1 || e.version === 2), CN = (e) => {
  let t = { type: ji.excalidrawLibrary, version: qg.excalidrawLibrary, source: u8, libraryItems: e };
  return JSON.stringify(t, null, 2);
}, fae = async (e) => {
  let t = CN(e);
  await $m(new Blob([t], { type: $e.excalidrawlib }), { name: "library", extension: "excalidrawlib", description: "Excalidraw library file" });
}, MN = (e) => new Promise((t, n) => {
  let r = new Image();
  r.onload = () => {
    t(r);
  }, r.onerror = (i) => {
    n(i);
  }, r.src = e;
}), TN = async ({ fileIds: e, files: t, imageCache: n }) => {
  let r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  return await Promise.all(e.reduce((a, l) => {
    let s = t[l];
    return s && !r.has(l) ? (r.set(l, !0), a.concat((async () => {
      try {
        if (s.mimeType === $e.binary) throw new Error("Only images can be added to ImageCache");
        let c = MN(s.dataURL), d = { image: c, mimeType: s.mimeType };
        n.set(l, d);
        let o = await c;
        n.set(l, { ...d, image: o });
      } catch {
        i.set(l, !0);
      }
    })())) : a;
  }, [])), { imageCache: n, updatedFiles: r, erroredFiles: i };
}, IN = (e) => e.filter((t) => zi(t)), pae = (e) => (e == null ? void 0 : e.nodeName.toLowerCase()) === "svg", Zx = (e) => {
  let t = new DOMParser().parseFromString(e, $e.svg), n = t.querySelector("svg");
  if (t.querySelector("parsererror") || !pae(n)) throw new Error("Invalid SVG");
  {
    n.hasAttribute("xmlns") || n.setAttribute("xmlns", Et);
    let r = n.getAttribute("width"), i = n.getAttribute("height");
    (r != null && r.includes("%") || r === "auto") && (r = null), (i != null && i.includes("%") || i === "auto") && (i = null);
    let a = n.getAttribute("viewBox");
    if (!r || !i) {
      if (r = r || "50", i = i || "50", a) {
        let l = a.match(/\d+ +\d+ +(\d+(?:\.\d+)?) +(\d+(?:\.\d+)?)/);
        l && ([, r, i] = l);
      }
      n.setAttribute("width", r), n.setAttribute("height", i);
    }
    return a || n.setAttribute("viewBox", `0 0 ${r} ${i}`), n.outerHTML;
  }
}, AN = document.createElement("img");
AN.src = `data:${$e.svg}, ${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#1971c2" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>')}`;
var NN = document.createElement("img");
NN.src = `data:${$e.svg}, ${encodeURIComponent('<svg  xmlns="http://www.w3.org/2000/svg"  width="16"  height="16"  viewBox="0 0 24 24"  fill="none"  stroke="#1971c2"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-arrow-big-right-line"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 9v-3.586a1 1 0 0 1 1.707 -.707l6.586 6.586a1 1 0 0 1 0 1.414l-6.586 6.586a1 1 0 0 1 -1.707 -.707v-3.586h-6v-6h6z" /><path d="M3 9v6" /></svg>')}`;
var X8 = ([e, t, n, r], i, a) => {
  let l = vre, s = l / a.zoom.value, c = l / a.zoom.value, d = l / a.zoom.value, o = (e + n) / 2, u = (t + r) / 2, h = (l - 8) / (2 * a.zoom.value), f = 4 / a.zoom.value, p = n + f - h, g = t - f - d + h, [b, v] = te(T(p + s / 2, g + c / 2), T(o, u), i);
  return [b - s / 2, v - c / 2, s, c];
}, DN = (e, t, n, [r, i]) => {
  let a = 4 / n.zoom.value, [l, s, c, d] = tt(e, t), [o, u, h, f] = X8([l, s, c, d], e.angle, n);
  return r > o - a && r < o + a + h && i > u - a && i < u + f + a;
}, Q6 = (e, t, n, [r, i], a) => !e.link || n.selectedElementIds[e.id] ? !1 : !a && n.viewModeEnabled && A8(r, i, e, t) ? !0 : DN(e, t, n, T(r, i)), m2 = (e, t, n, r, i = !0) => {
  e.beginPath(), e.arc(t, n, r, 0, Math.PI * 2), e.fill(), i && e.stroke();
}, V8 = (e, t) => [e.width / t, e.height / t], G8 = ({ canvas: e, scale: t, normalizedWidth: n, normalizedHeight: r, theme: i, isExporting: a, viewBackgroundColor: l }) => {
  let s = e.getContext("2d");
  return s.setTransform(1, 0, 0, 1, 0, 0), s.scale(t, t), a && i === gt.DARK && (s.filter = p8), typeof l == "string" ? ((l === "transparent" || l.length === 5 || l.length === 9 || /(hsla|rgba)\(/.test(l)) && s.clearRect(0, 0, n, r), s.save(), s.fillStyle = l, s.fillRect(0, 0, n, r), s.restore()) : s.clearRect(0, 0, n, r), s;
}, LN = (e, t) => {
  let n = window.location.href;
  try {
    let r = new URL(n);
    return r.searchParams.set(vm, e), _i(r.toString());
  } catch (r) {
    console.error(r);
  }
  return _i(n);
}, RN = (e, t) => {
  if (e.length > 0 && Fm(e)) {
    if (e.length === 1) return { id: e[0].id, type: "element" };
    if (e.length > 1) {
      let n = Object.keys(t.selectedGroupIds)[0];
      return n ? { id: n, type: "group" } : { id: e[0].groupIds[0], type: "group" };
    }
  }
  return null;
}, Fm = (e) => !!(e.length === 1 || e.length > 1 && sN(e)), vh = (e) => {
  try {
    let t = new URL(e);
    return t.searchParams.has(vm) && t.host === window.location.host;
  } catch {
    return !1;
  }
}, mae = (e) => {
  try {
    let { searchParams: t } = new URL(e);
    if (t.has(vm)) return t.get(vm);
  } catch {
  }
  return null;
}, P1 = { Bold: "#dddddd", Regular: "#e5e5e5" }, gae = (e, t, n, r, i, a, l, s) => {
  let c = r % t - t, d = i % t - t, o = t * a.value, u = 1 / a.value;
  e.save(), a.value === 1 && e.translate(c % 1 ? 0 : 0.5, d % 1 ? 0 : 0.5);
  for (let h = c; h < c + l + t * 2; h += t) {
    let f = n > 1 && Math.round(h - r) % (n * t) === 0;
    if (!f && o < 10) continue;
    let p = Math.min(1 / a.value, f ? 4 : 1);
    e.lineWidth = p;
    let g = [p * 3, u + (p + u)];
    e.beginPath(), e.setLineDash(f ? [] : g), e.strokeStyle = f ? P1.Bold : P1.Regular, e.moveTo(h, d - t), e.lineTo(h, Math.ceil(d + s + t * 2)), e.stroke();
  }
  for (let h = d; h < d + s + t * 2; h += t) {
    let f = n > 1 && Math.round(h - i) % (n * t) === 0;
    if (!f && o < 10) continue;
    let p = Math.min(1 / a.value, f ? 4 : 1);
    e.lineWidth = p;
    let g = [p * 3, u + (p + u)];
    e.beginPath(), e.setLineDash(f ? [] : g), e.strokeStyle = f ? P1.Bold : P1.Regular, e.moveTo(c - t, h), e.lineTo(Math.ceil(c + l + t * 2), h), e.stroke();
  }
  e.restore();
}, Jx = (e, t, n, r) => {
  t.translate(e.x + r.scrollX, e.y + r.scrollY), t.beginPath(), t.roundRect ? t.roundRect(0, 0, e.width, e.height, vn.radius / r.zoom.value) : t.rect(0, 0, e.width, e.height), t.clip(), t.translate(-(e.x + r.scrollX), -(e.y + r.scrollY));
}, Qx = { regularLink: null, elementLink: null }, eE = (e, t, n, r) => {
  if (e.link && !n.selectedElementIds[e.id]) {
    let [i, a, l, s] = tt(e, r), [c, d, o, u] = X8([i, a, l, s], e.angle, n), h = c + o / 2, f = d + u / 2;
    t.save(), t.translate(n.scrollX + h, n.scrollY + f), t.rotate(e.angle);
    let p = vh(e.link) ? "elementLink" : "regularLink", g = Qx[p];
    if (!g || g.zoom !== n.zoom.value) {
      g = Object.assign(document.createElement("canvas"), { zoom: n.zoom.value }), g.width = o * window.devicePixelRatio * n.zoom.value, g.height = u * window.devicePixelRatio * n.zoom.value, Qx[p] = g;
      let b = g.getContext("2d");
      b.scale(window.devicePixelRatio * n.zoom.value, window.devicePixelRatio * n.zoom.value), b.fillStyle = "#fff", b.fillRect(0, 0, o, u), p === "elementLink" ? b.drawImage(NN, 0, 0, o, u) : b.drawImage(AN, 0, 0, o, u), b.restore();
    }
    t.drawImage(g, c - h, d - f, o, u), t.restore();
  }
}, PN = ({ canvas: e, rc: t, elementsMap: n, allElementsMap: r, visibleElements: i, scale: a, appState: l, renderConfig: s }) => {
  var g;
  if (e === null) return;
  let { renderGrid: c = !0, isExporting: d } = s, [o, u] = V8(e, a), h = G8({ canvas: e, scale: a, normalizedWidth: o, normalizedHeight: u, theme: l.theme, isExporting: d, viewBackgroundColor: l.viewBackgroundColor });
  h.scale(l.zoom.value, l.zoom.value), c && gae(h, l.gridSize, l.gridStep, l.scrollX, l.scrollY, l.zoom, o / l.zoom.value, u / l.zoom.value);
  let f = /* @__PURE__ */ new Set();
  i.forEach((b) => {
    b.groupIds.length > 0 && l.frameToHighlight && l.selectedElementIds[b.id] && (ko(b, l.frameToHighlight, n) || b.groupIds.find((v) => f.has(v))) && b.groupIds.forEach((v) => f.add(v));
  });
  let p = /* @__PURE__ */ new Map();
  i.filter((b) => !Bi(b)).forEach((b) => {
    var v;
    try {
      let U = b.frameId || ((v = l.frameToHighlight) == null ? void 0 : v.id);
      if (we(b) && b.containerId && n.has(b.containerId)) return;
      if (h.save(), U && l.frameRendering.enabled && l.frameRendering.clip) {
        let w = _7(b, n, l);
        w && pE(b, w, l, n, p) && Jx(w, h, s, l), tc(b, n, r, t, h, s, l);
      } else tc(b, n, r, t, h, s, l);
      let y = lt(b, n);
      y && tc(y, n, r, t, h, s, l), h.restore(), d || eE(b, h, l, n);
    } catch (U) {
      console.error(U, b.id, b.x, b.y, b.width, b.height);
    }
  }), i.filter((b) => Bi(b)).forEach((b) => {
    var v;
    try {
      let U = () => {
        if (tc(b, n, r, t, h, s, l), Bi(b) && (d || ri(b) && s.embedsValidationStatus.get(b.id) !== !0) && b.width && b.height) {
          let y = SN(b);
          tc(y, n, r, t, h, s, l);
        }
        d || eE(b, h, l, n);
      };
      if ((b.frameId || (v = l.frameToHighlight) != null && v.id) && l.frameRendering.enabled && l.frameRendering.clip) {
        h.save();
        let y = _7(b, n, l);
        y && pE(b, y, l, n, p) && Jx(y, h, s, l), U(), h.restore();
      } else U();
    } catch (U) {
      console.error(U);
    }
  }), (g = s.pendingFlowchartNodes) == null || g.forEach((b) => {
    try {
      tc(b, n, r, t, h, s, l);
    } catch (v) {
      console.error(v);
    }
  });
}, ON = Zg((e) => {
  PN(e);
}, { trailing: !0 }), $N = (e, t) => {
  if (t) {
    ON(e);
    return;
  }
  PN(e);
}, bae = (e, t) => {
  if (e.width <= t) return e;
  let n = document.createElement("canvas").getContext("2d");
  n.font = Wt({ fontFamily: e.fontFamily, fontSize: e.fontSize });
  let r = e.text;
  if (n.measureText(r).width > t) for (let i = r.length; i > 0; i--) {
    let a = `${r.slice(0, i)}...`;
    if (n.measureText(a).width <= t) {
      r = a;
      break;
    }
  }
  return at(e, { text: r, width: t });
}, Uae = (e, t) => {
  let n = [];
  for (let r of e) {
    if (Ve(r)) {
      let i = Ai({ x: r.x, y: r.y - vn.nameOffsetY, fontFamily: Un.Helvetica, fontSize: vn.nameFontSize, lineHeight: vn.nameLineHeight, strokeColor: t.exportWithDarkMode ? vn.nameColorDarkTheme : vn.nameColorLightTheme, text: QN(r) });
      i.y -= i.height, i = bae(i, r.width), n.push(i);
    }
    n.push(r);
  }
  return n;
}, FN = (e, t) => (t = t || El().frameRendering, { enabled: e ? !0 : t.enabled, outline: e ? !1 : t.outline, name: e ? !1 : t.name, clip: e ? !0 : t.clip }), zN = ({ elements: e, exportingFrame: t, frameRendering: n, exportWithDarkMode: r }) => {
  let i;
  return t ? i = uU(e, t) : n.enabled && n.name ? i = Uae(e, { exportWithDarkMode: r }) : i = e, i;
}, BN = async (e, t, n, { exportBackground: r, exportPadding: i = tu, viewBackgroundColor: a, exportingFrame: l }, s = (d, o) => {
  let u = document.createElement("canvas");
  return u.width = d * t.exportScale, u.height = o * t.exportScale, { canvas: u, scale: t.exportScale };
}, c = async () => {
  await ds.loadElementsFonts(e);
}) => {
  await c();
  let d = FN(l ?? null, t.frameRendering ?? null);
  l && (d.clip = !1);
  let o = zN({ elements: e, exportingFrame: l, exportWithDarkMode: t.exportWithDarkMode, frameRendering: d });
  l && (i = 0);
  let [u, h, f, p] = K8(l ? [l] : dU(o), i), { canvas: g, scale: b = 1 } = s(f, p), v = El(), { imageCache: U } = await TN({ imageCache: /* @__PURE__ */ new Map(), fileIds: IN(o).map((y) => y.fileId), files: n });
  return $N({ canvas: g, rc: Po.canvas(g), elementsMap: ta(Ge(o)), allElementsMap: ta(Ge(xs(e))), visibleElements: o, scale: b, appState: { ...t, frameRendering: d, viewBackgroundColor: r ? a : null, scrollX: -u + i, scrollY: -h + i, zoom: v.zoom, shouldCacheIgnoreZoom: !1, theme: t.exportWithDarkMode ? gt.DARK : gt.LIGHT }, renderConfig: { canvasBackgroundColor: a, imageCache: U, renderGrid: !1, isExporting: !0, embedsValidationStatus: /* @__PURE__ */ new Map(), elementsPendingErasure: /* @__PURE__ */ new Set(), pendingFlowchartNodes: null } }), g;
}, Ku = (e) => document.createComment(` ${e} `), j8 = async (e, t, n, r) => {
  let i = FN((r == null ? void 0 : r.exportingFrame) ?? null, t.frameRendering ?? null), { exportPadding: a = tu, exportWithDarkMode: l = !1, viewBackgroundColor: s, exportScale: c = 1, exportEmbedScene: d } = t, { exportingFrame: o = null } = r || {}, u = zN({ elements: e, exportingFrame: o, exportWithDarkMode: l, frameRendering: i });
  o && (a = 0);
  let [h, f, p, g] = K8(o ? [o] : dU(u), a), b = -h + a, v = -f + a, U = document.createElementNS(Et, "svg");
  U.setAttribute("version", "1.1"), U.setAttribute("xmlns", Et), U.setAttribute("viewBox", `0 0 ${p} ${g}`), U.setAttribute("width", `${p * c}`), U.setAttribute("height", `${g * c}`), l && U.setAttribute("filter", p8);
  let y = U.ownerDocument.createElementNS(Et, "defs"), w = U.ownerDocument.createElementNS(Et, "metadata");
  if (U.appendChild(Ku("svg-source:excalidraw")), U.appendChild(w), U.appendChild(y), d) try {
    vae({ metadataElement: w, payload: W8(e, t, n || {}, "local") });
  } catch (A) {
    console.error(A);
  }
  let x = cU(e);
  if (x.length) {
    let A = Ge(e);
    for (let L of x) {
      let R = U.ownerDocument.createElementNS(Et, "clipPath");
      R.setAttribute("id", L.id);
      let [z, F, W, B] = tt(L, A), j = (W - z) / 2 - (L.x - z), V = (B - F) / 2 - (L.y - F), q = U.ownerDocument.createElementNS(Et, "rect");
      q.setAttribute("transform", `translate(${L.x + b} ${L.y + v}) rotate(${L.angle} ${j} ${V})`), q.setAttribute("width", `${L.width}`), q.setAttribute("height", `${L.height}`), o || (q.setAttribute("rx", `${vn.radius}`), q.setAttribute("ry", `${vn.radius}`)), R.appendChild(q), y.appendChild(R);
    }
  }
  let E = r != null && r.skipInliningFonts ? [] : await ds.generateFontFaceDeclarations(e), S = `
      `, _ = U.ownerDocument.createElementNS(Et, "style");
  if (_.classList.add("style-fonts"), _.appendChild(document.createTextNode(`${S}${E.join(S)}`)), y.appendChild(_), t.exportBackground && s) {
    let A = U.ownerDocument.createElementNS(Et, "rect");
    A.setAttribute("x", "0"), A.setAttribute("y", "0"), A.setAttribute("width", `${p}`), A.setAttribute("height", `${g}`), A.setAttribute("fill", s), U.appendChild(A);
  }
  let k = Po.svg(U), M = (r == null ? void 0 : r.renderEmbeddables) ?? !1;
  return cae(u, ta(Ge(u)), k, U, n || {}, { offsetX: b, offsetY: v, isExporting: !0, exportWithDarkMode: l, renderEmbeddables: M, frameRendering: i, canvasBackgroundColor: s, embedsValidationStatus: M ? new Map(u.filter((A) => Ve(A)).map((A) => [A.id, !0])) : /* @__PURE__ */ new Map(), reuseImages: (r == null ? void 0 : r.reuseImages) ?? !0 }), U;
}, vae = ({ payload: e, metadataElement: t }) => {
  let n = UD(JSON.stringify(yD({ text: e })), !0);
  t.appendChild(Ku(`payload-type:${$e.excalidraw}`)), t.appendChild(Ku("payload-version:2")), t.appendChild(Ku("payload-start")), t.appendChild(document.createTextNode(n)), t.appendChild(Ku("payload-end"));
}, yae = ({ svg: e }) => {
  var t;
  if (e.includes(`payload-type:${$e.excalidraw}`)) {
    let n = e.match(/<!-- payload-start -->\s*(.+?)\s*<!-- payload-end -->/);
    if (!n) throw new Error("INVALID");
    let r = (((t = e.match(/<!-- payload-version:(\d+) -->/)) == null ? void 0 : t[1]) || "1") !== "1";
    try {
      let i = vD(n[1], r), a = JSON.parse(i);
      if (!("encoded" in a)) {
        if ("type" in a && a.type === ji.excalidraw) return i;
        throw new Error("FAILED");
      }
      return wD(a);
    } catch (i) {
      throw console.error(i), new Error("FAILED");
    }
  }
  throw new Error("INVALID");
}, K8 = (e, t) => {
  let [n, r, i, a] = Lt(e), l = Dr(n, i) + t * 2, s = Dr(r, a) + t * 2;
  return [n, r, l, s];
}, wae = (e, t, n) => {
  let [, , r, i] = K8(e, t).map((a) => Math.trunc(a * n));
  return [r, i];
}, xae = class {
  constructor(t) {
    this.scoreFunction = t, $(this, "content", []);
  }
  sinkDown(t) {
    let n = this.content[t];
    for (; t > 0; ) {
      let r = (t + 1 >> 1) - 1, i = this.content[r];
      if (this.scoreFunction(n) < this.scoreFunction(i)) this.content[r] = n, this.content[t] = i, t = r;
      else break;
    }
  }
  bubbleUp(t) {
    let n = this.content.length, r = this.content[t], i = this.scoreFunction(r);
    for (; ; ) {
      let a = t + 1 << 1, l = a - 1, s = null, c = 0;
      if (l < n) {
        let d = this.content[l];
        c = this.scoreFunction(d), c < i && (s = l);
      }
      if (a < n) {
        let d = this.content[a];
        this.scoreFunction(d) < (s === null ? i : c) && (s = a);
      }
      if (s !== null) this.content[t] = this.content[s], this.content[s] = r, t = s;
      else break;
    }
  }
  push(t) {
    this.content.push(t), this.sinkDown(this.content.length - 1);
  }
  pop() {
    if (this.content.length === 0) return null;
    let t = this.content[0], n = this.content.pop();
    return this.content.length > 0 && (this.content[0] = n, this.bubbleUp(0)), t;
  }
  remove(t) {
    if (this.content.length === 0) return;
    let n = this.content.indexOf(t), r = this.content.pop();
    n < this.content.length && (this.content[n] = r, this.scoreFunction(r) < this.scoreFunction(t) ? this.sinkDown(n) : this.bubbleUp(n));
  }
  size() {
    return this.content.length;
  }
  rescoreElement(t) {
    this.sinkDown(this.content.indexOf(t));
  }
}, Y8 = 1, $t = 40, Eae = (e, t) => {
  let n = e.fixedSegments ? e.fixedSegments.slice() : null;
  if (n) {
    let r = [];
    e.points.map((l) => T(e.x + l[0], e.y + l[1])).forEach((l, s, c) => {
      if (s < 2) return r.push(l);
      let d = Zh(l, c[s - 1]), o = Zh(c[s - 1], c[s - 2]);
      if (Nn(d, o)) {
        let u = (n == null ? void 0 : n.findIndex((f) => f.index === s - 1)) ?? -1, h = (n == null ? void 0 : n.findIndex((f) => f.index === s)) ?? -1;
        h !== -1 && (n[h].start = T(c[s - 2][0] - e.x, c[s - 2][1] - e.y)), u !== -1 && n.splice(u, 1), r.splice(-1, 1), n.forEach((f) => {
          f.index > s - 1 && (f.index -= 1);
        });
      }
      return r.push(l);
    });
    let i = [];
    r.forEach((l, s, c) => {
      if (s < 3) return i.push(l);
      if (Tt(c[s - 2], c[s - 1]) < Y8) {
        let d = (n == null ? void 0 : n.findIndex((h) => h.index === s - 2)) ?? -1, o = (n == null ? void 0 : n.findIndex((h) => h.index === s - 1)) ?? -1;
        o !== -1 && n.splice(o, 1), d !== -1 && n.splice(d, 1), i.splice(-2, 2), n.forEach((h) => {
          h.index > s - 2 && (h.index -= 2);
        });
        let u = ts(l, c[s - 1]);
        return i.push(T(u ? l[0] : c[s - 2][0], u ? c[s - 2][1] : l[1]));
      }
      i.push(l);
    });
    let a = n.filter((l) => l.index !== 1 && l.index !== i.length - 1);
    return a.length === 0 ? _o(Q8(eU(J8(e, Z8(e, t, i.map((l) => T(l[0] - e.x, l[1] - e.y)), e.startBinding && k0(e.startBinding.elementId, t), e.endBinding && k0(e.endBinding.elementId, t))) ?? [])), a, null, null) : (st.DEV && Or(tU(i), "Invalid elbow points with fixed segments"), _o(i, a, e.startIsSpecial, e.endIsSpecial));
  }
  return { x: e.x, y: e.y, points: e.points, fixedSegments: e.fixedSegments, startIsSpecial: e.startIsSpecial, endIsSpecial: e.endIsSpecial };
}, Sae = (e, t, n) => {
  var _, k;
  let r = t.map((M) => M.index), i = (((_ = e.fixedSegments) == null ? void 0 : _.map((M) => M.index)) ?? []).findIndex((M) => !r.includes(M));
  if (i === -1 || !((k = e.fixedSegments) != null && k[i])) return { points: e.points };
  let a = e.fixedSegments[i].index, l = e.fixedSegments[i - 1], s = e.fixedSegments[i + 1], c = e.x + (l ? l.end[0] : 0), d = e.y + (l ? l.end[1] : 0), o = l ? null : e.startBinding, u = s ? null : e.endBinding, { startHeading: h, endHeading: f, startGlobalPoint: p, endGlobalPoint: g, hoveredStartElement: b, hoveredEndElement: v, ...U } = Z8({ x: c, y: d, startBinding: o, endBinding: u, startArrowhead: null, endArrowhead: null, points: e.points }, n, [T(0, 0), T(e.x + ((s == null ? void 0 : s.start[0]) ?? e.points[e.points.length - 1][0]) - c, e.y + ((s == null ? void 0 : s.start[1]) ?? e.points[e.points.length - 1][1]) - d)], o && k0(o.elementId, n), u && k0(u.elementId, n), { isDragging: !1 }), { points: y } = _o(Q8(eU(J8(e, { startHeading: h, endHeading: f, startGlobalPoint: p, endGlobalPoint: g, hoveredEndElement: v, ...U }) ?? [])), t, null, null), w = [];
  if (l) for (let M = 0; M < l.index; M++) w.push(T(e.x + e.points[M][0], e.y + e.points[M][1]));
  if (y.forEach((M) => {
    w.push(T(e.x + (l ? l.end[0] : 0) + M[0], e.y + (l ? l.end[1] : 0) + M[1]));
  }), s) for (let M = s.index; M < e.points.length; M++) w.push(T(e.x + e.points[M][0], e.y + e.points[M][1]));
  let x = ((s == null ? void 0 : s.index) ?? e.points.length) - ((l == null ? void 0 : l.index) ?? 0) - 1, E = t.map((M) => M.index > a ? { ...M, index: M.index - x + (y.length - 1) } : M), S = w.flatMap((M, A) => {
    let L = w[A - 1], R = w[A + 1];
    if (L && R) {
      let z = Zh(M, L), F = Zh(R, M);
      if (Nn(z, F)) return E.forEach((W) => {
        W.index > A && (W.index -= 1);
      }), [];
      if (Nn(z, XA(F))) return E.forEach((W) => {
        W.index > A && (W.index += 1);
      }), [M, M];
    }
    return [M];
  });
  return _o(S, E, !1, !1);
}, _ae = (e, t, n, r, i, a) => {
  var x, E;
  let l = t.map((S, _) => e.fixedSegments == null || e.fixedSegments[_] === void 0 || e.fixedSegments[_].index !== S.index || (S.start[0] !== e.fixedSegments[_].start[0] && S.end[0] !== e.fixedSegments[_].end[0]) != (S.start[1] !== e.fixedSegments[_].start[1] && S.end[1] !== e.fixedSegments[_].end[1]) ? _ : null).filter((S) => S !== null).shift();
  if (l == null) return { points: e.points };
  let s = ((x = e.fixedSegments) == null ? void 0 : x.findIndex((S) => S.index === 1)) ?? -1, c = ((E = e.fixedSegments) == null ? void 0 : E.findIndex((S) => S.index === e.points.length - 1)) ?? -1, d = Tt(t[l].start, t[l].end), o = d < $t + 5;
  if (s === -1 && t[l].index === 1 && i) {
    let S = is(n), _ = (S ? Nn(n, In) : Nn(n, yr)) ? o ? d / 2 : $t : o ? -d / 2 : -$t;
    t[l].start = T(t[l].start[0] + (S ? _ : 0), t[l].start[1] + (S ? 0 : _));
  }
  if (c === -1 && t[l].index === e.points.length - 1 && a) {
    let S = is(r), _ = (S ? Nn(r, In) : Nn(r, yr)) ? o ? d / 2 : $t : o ? -d / 2 : -$t;
    t[l].end = T(t[l].end[0] + (S ? _ : 0), t[l].end[1] + (S ? 0 : _));
  }
  let u = t.map((S) => ({ ...S, start: T(e.x + S.start[0], e.y + S.start[1]), end: T(e.x + S.end[0], e.y + S.end[1]) })), h = e.points.map((S, _) => T(e.x + S[0], e.y + S[1])), f = u[l].index - 1, p = u[l].index, g = u[l].start, b = u[l].end, v = h[f - 1] && !Ra(h[f], h[f - 1]) ? ts(h[f - 1], h[f]) : void 0, U = h[p + 1] && !Ra(h[p], h[p + 1]) ? ts(h[p + 1], h[p]) : void 0;
  if (v !== void 0) {
    let S = v ? 1 : 0;
    h[f - 1][S] = g[S];
  }
  if (h[f] = g, h[p] = b, U !== void 0) {
    let S = U ? 1 : 0;
    h[p + 1][S] = b[S];
  }
  let y = u.findIndex((S) => S.index === f);
  if (y !== -1) {
    let S = ts(u[y].end, u[y].start) ? 1 : 0;
    u[y].start[S] = g[S], u[y].end = g;
  }
  let w = u.findIndex((S) => S.index === p + 1);
  if (w !== -1) {
    let S = ts(u[w].end, u[w].start) ? 1 : 0;
    u[w].end[S] = b[S], u[w].start = b;
  }
  if (s === -1 && f === 0) {
    let S = i ? is(n) : ts(h[1], h[0]);
    h.unshift(T(S ? g[0] : e.x + e.points[0][0], S ? e.y + e.points[0][1] : g[1])), i && h.unshift(T(e.x + e.points[0][0], e.y + e.points[0][1]));
    for (let _ of u) _.index += i ? 2 : 1;
  }
  if (c === -1 && p === e.points.length - 1) {
    let S = is(r);
    h.push(T(S ? b[0] : e.x + e.points[e.points.length - 1][0], S ? e.y + e.points[e.points.length - 1][1] : b[1])), a && h.push(T(e.x + e.points[e.points.length - 1][0], e.y + e.points[e.points.length - 1][1]));
  }
  return _o(h, u.map((S) => ({ ...S, start: T(S.start[0] - e.x, S.start[1] - e.y), end: T(S.end[0] - e.x, S.end[1] - e.y) })), !1, !1);
}, kae = (e, t, n, r, i, a, l, s, c) => {
  let d = e.startIsSpecial ?? null, o = e.endIsSpecial ?? null, u = t.map((b, v) => v === 0 || v === t.length - 1 ? T(e.x + b[0], e.y + b[1]) : T(e.x + e.points[v][0], e.y + e.points[v][1])), h = n.map((b) => ({ ...b, start: T(e.x + (b.start[0] - t[0][0]), e.y + (b.start[1] - t[0][1])), end: T(e.x + (b.end[0] - t[0][0]), e.y + (b.end[1] - t[0][1])) })), f = [], p = 2 + (d ? 1 : 0), g = 2 + (o ? 1 : 0);
  for (; f.length + p < u.length - g; ) f.push(u[f.length + p]);
  {
    let b = u[d ? 2 : 1], v = u[d ? 3 : 2], U = is(r), y = is(qc(Le(b, v)));
    if (s && U === y) {
      let w = U ? Nn(r, In) : Nn(r, yr);
      if (f.unshift(T(y ? a[0] + (w ? $t : -$t) : v[0], y ? v[1] : a[1] + (w ? $t : -$t))), f.unshift(T(U ? a[0] + (w ? $t : -$t) : a[0], U ? a[1] : a[1] + (w ? $t : -$t))), !d) {
        d = !0;
        for (let x of h) x.index > 1 && (x.index += 1);
      }
    } else if (f.unshift(T(y ? a[0] : b[0], y ? b[1] : a[1])), d) {
      d = !1;
      for (let w of h) w.index > 1 && (w.index -= 1);
    }
    f.unshift(a);
  }
  {
    let b = u[u.length - (o ? 3 : 2)], v = u[u.length - (o ? 4 : 3)], U = is(i), y = ts(v, b);
    if (c && U === y) {
      let w = U ? Nn(i, In) : Nn(i, yr);
      f.push(T(y ? l[0] + (w ? $t : -$t) : v[0], y ? v[1] : l[1] + (w ? $t : -$t))), f.push(T(U ? l[0] + (w ? $t : -$t) : l[0], U ? l[1] : l[1] + (w ? $t : -$t))), o || (o = !0);
    } else f.push(T(y ? l[0] : b[0], y ? b[1] : l[1])), o && (o = !1);
  }
  return f.push(l), _o(f, h.map(({ index: b }) => ({ index: b, start: f[b - 1], end: f[b] })).map((b) => ({ ...b, start: T(b.start[0] - a[0], b.start[1] - a[1]), end: T(b.end[0] - a[0], b.end[1] - a[1]) })), d, o);
}, Yt = 1e6, q8 = (e, t, n, r) => {
  var v, U, y, w, x, E, S, _, k, M, A, L, R, z, F, W, B, j, V, q, oe, Ue, fe, Pe, ze;
  if (e.points.length < 2) return { points: n.points ?? e.points };
  (e.x < -Yt || e.x > Yt || e.y < -Yt || e.y > Yt || e.x + (((y = (U = n == null ? void 0 : n.points) == null ? void 0 : U[((v = n == null ? void 0 : n.points) == null ? void 0 : v.length) - 1]) == null ? void 0 : y[0]) ?? 0) < -Yt || e.x + (((E = (x = n == null ? void 0 : n.points) == null ? void 0 : x[((w = n == null ? void 0 : n.points) == null ? void 0 : w.length) - 1]) == null ? void 0 : E[0]) ?? 0) > Yt || e.y + (((k = (_ = n == null ? void 0 : n.points) == null ? void 0 : _[((S = n == null ? void 0 : n.points) == null ? void 0 : S.length) - 1]) == null ? void 0 : k[1]) ?? 0) < -Yt || e.y + (((L = (A = n == null ? void 0 : n.points) == null ? void 0 : A[((M = n == null ? void 0 : n.points) == null ? void 0 : M.length) - 1]) == null ? void 0 : L[1]) ?? 0) > Yt || e.x + (((F = (z = e == null ? void 0 : e.points) == null ? void 0 : z[((R = e == null ? void 0 : e.points) == null ? void 0 : R.length) - 1]) == null ? void 0 : F[0]) ?? 0) < -Yt || e.x + (((j = (B = e == null ? void 0 : e.points) == null ? void 0 : B[((W = e == null ? void 0 : e.points) == null ? void 0 : W.length) - 1]) == null ? void 0 : j[0]) ?? 0) > Yt || e.y + (((oe = (q = e == null ? void 0 : e.points) == null ? void 0 : q[((V = e == null ? void 0 : e.points) == null ? void 0 : V.length) - 1]) == null ? void 0 : oe[1]) ?? 0) < -Yt || e.y + (((Pe = (fe = e == null ? void 0 : e.points) == null ? void 0 : fe[((Ue = e == null ? void 0 : e.points) == null ? void 0 : Ue.length) - 1]) == null ? void 0 : Pe[1]) ?? 0) > Yt) && console.error("Elbow arrow (or update) is outside reasonable bounds (> 1e6)", { arrow: e, updates: n }), e.x = ft(e.x, -Yt, Yt), e.y = ft(e.y, -Yt, Yt), n.points && (n.points = n.points.map(([Oe, Be]) => T(ft(Oe, -Yt, Yt), ft(Be, -Yt, Yt))));
  let i = n.points ? n.points && n.points.length === 2 ? e.points.map((Oe, Be) => Be === 0 ? n.points[0] : Be === e.points.length - 1 ? n.points[1] : Oe) : n.points.slice() : e.points.slice(), a = typeof n.startBinding < "u" ? n.startBinding : e.startBinding, l = typeof n.endBinding < "u" ? n.endBinding : e.endBinding, s = a && k0(a.elementId, t), c = l && k0(l.elementId, t);
  if (t.size === 0 && tU(i) || (s == null ? void 0 : s.id) !== (a == null ? void 0 : a.elementId) || (c == null ? void 0 : c.id) !== (l == null ? void 0 : l.elementId)) return _o(i.map((Oe) => T(e.x + Oe[0], e.y + Oe[1])), e.fixedSegments, e.startIsSpecial, e.endIsSpecial);
  let { startHeading: d, endHeading: o, startGlobalPoint: u, endGlobalPoint: h, hoveredStartElement: f, hoveredEndElement: p, ...g } = Z8({ x: e.x, y: e.y, startBinding: a, endBinding: l, startArrowhead: e.startArrowhead, endArrowhead: e.endArrowhead, points: e.points }, t, i, s, c, r), b = n.fixedSegments ?? e.fixedSegments ?? [];
  return !n.points && !n.fixedSegments && !n.startBinding && !n.endBinding ? Eae(e, t) : n.startBinding === e.startBinding && n.endBinding === e.endBinding && (n.points ?? []).every((Oe, Be) => Ra(Oe, e.points[Be] ?? T(1 / 0, 1 / 0))) ? {} : b.length === 0 ? _o(Q8(eU(J8(e, { startHeading: d, endHeading: o, startGlobalPoint: u, endGlobalPoint: h, hoveredEndElement: p, ...g }) ?? [])), b, null, null) : (((ze = e.fixedSegments) == null ? void 0 : ze.length) ?? 0) > b.length ? Sae(e, b, t) : n.points ? n.points && n.fixedSegments ? n : kae(e, i, b, d, o, u, h, f, p) : _ae(e, b, d, o, f, p);
}, Z8 = (e, t, n, r, i, a) => {
  var S, _;
  let l = xm(n[0], _r(e.x, e.y)), s = xm(n[n.length - 1], _r(e.x, e.y)), c = r, d = i;
  if (a != null && a.isDragging) {
    let k = Array.from(t.values());
    c = iE(l, t, k, a == null ? void 0 : a.zoom) || r, d = iE(s, t, k, a == null ? void 0 : a.zoom) || i;
  }
  let o = nE({ ...e, points: n }, "start", (S = e.startBinding) == null ? void 0 : S.fixedPoint, l, r, c, a == null ? void 0 : a.isDragging), u = nE({ ...e, points: n }, "end", (_ = e.endBinding) == null ? void 0 : _.fixedPoint, s, i, d, a == null ? void 0 : a.isDragging), h = rE(o, u, t, c, l), f = rE(u, o, t, d, s), p = [o[0] - 2, o[1] - 2, o[0] + 2, o[1] + 2], g = [u[0] - 2, u[1] - 2, u[0] + 2, u[1] + 2], b = c ? sl(c, zs(h, e.startArrowhead ? Zt * 6 : Zt * 2, 1)) : p, v = d ? sl(d, zs(f, e.endArrowhead ? Zt * 6 : Zt * 2, 1)) : g, U = y0(o, d ? sl(d, zs(f, $t, $t)) : g) || y0(u, c ? sl(c, zs(h, $t, $t)) : p), y = HN(U ? [p, g] : [b, v]), w = Tae(U ? p : b, U ? g : v, y, U ? zs(h, !c && !d ? 0 : $t, 0) : zs(h, !c && !d ? 0 : $t - (e.startArrowhead ? Zt * 6 : Zt * 2), $t), U ? zs(f, !c && !d ? 0 : $t, 0) : zs(f, !c && !d ? 0 : $t - (e.endArrowhead ? Zt * 6 : Zt * 2), $t), U, c && sl(c), d && sl(d)), x = tE(w[0], h, o), E = tE(w[1], f, u);
  return { dynamicAABBs: w, startDonglePosition: x, startGlobalPoint: o, startHeading: h, endDonglePosition: E, endGlobalPoint: u, endHeading: f, commonBounds: y, hoveredStartElement: c, hoveredEndElement: d, boundsOverlap: U, startElementBounds: b, endElementBounds: v };
}, J8 = (e, t) => {
  let { dynamicAABBs: n, startDonglePosition: r, startGlobalPoint: i, startHeading: a, endDonglePosition: l, endGlobalPoint: s, endHeading: c, commonBounds: d, hoveredEndElement: o } = t, u = Iae(n, r || i, a, l || s, c, d), h = r && O1(r, u), f = l && O1(l, u), p = O1(s, u);
  p && o && (p.closed = !0);
  let g = O1(i, u);
  g && e.startBinding && (g.closed = !0);
  let b = h && f && (y0(h.pos, n[1]) || y0(f.pos, n[0])), v = Cae(h || g, f || p, u, a || In, c || In, b ? [] : n);
  if (v) {
    let U = v.map((y) => [y.pos[0], y.pos[1]]);
    return h && U.unshift(i), f && U.push(s), U;
  }
  return null;
}, zs = (e, t, n) => {
  switch (e) {
    case li:
      return [t, n, n, n];
    case In:
      return [n, t, n, n];
    case yr:
      return [n, n, t, n];
  }
  return [n, n, n, t];
}, Cae = (e, t, n, r, i, a) => {
  let l = e5(e.pos, t.pos), s = new xae((c) => c.f);
  for (s.push(e); s.size() > 0; ) {
    let c = s.pop();
    if (!c || c.closed) continue;
    if (c === t) return Mae(e, c);
    c.closed = !0;
    let d = Nae(c.addr, n);
    for (let o = 0; o < 4; o++) {
      let u = d[o];
      if (!u || u.closed) continue;
      let h = Xl(u.pos, c.pos, 0.5);
      if (tq(...a.map((y) => y0(h, y)))) continue;
      let f = Dae(o), p = c.parent ? qc(Le(c.pos, c.parent.pos)) : r, g = XA(p);
      if (Nn(g, f) || aE(e.addr, u.addr) && Nn(f, r) || aE(t.addr, u.addr) && Nn(f, i)) continue;
      let b = p !== f, v = c.g + e5(u.pos, c.pos) + (b ? Math.pow(l, 3) : 0), U = u.visited;
      if (!U || v < u.g) {
        let y = Aae(u, t, f, i);
        u.visited = !0, u.parent = c, u.h = e5(t.pos, u.pos) + y * Math.pow(l, 2), u.g = v, u.f = u.g + u.h, U ? s.rescoreElement(u) : s.push(u);
      }
    }
  }
  return null;
}, Mae = (e, t) => {
  let n = t, r = [];
  for (; n.parent; ) r.unshift(n), n = n.parent;
  return r.unshift(e), r;
}, e5 = (e, t) => Math.abs(e[0] - t[0]) + Math.abs(e[1] - t[1]), Tae = (e, t, n, r, i, a, l, s) => {
  let c = l ?? e, d = s ?? t, [o, u, h, f] = r ?? [0, 0, 0, 0], [p, g, b, v] = i ?? [0, 0, 0, 0], U = [e[0] > t[2] ? e[1] > t[3] || e[3] < t[1] ? Math.min((c[0] + d[2]) / 2, e[0] - f) : (c[0] + d[2]) / 2 : e[0] > t[0] ? e[0] - f : n[0] - f, e[1] > t[3] ? e[0] > t[2] || e[2] < t[0] ? Math.min((c[1] + d[3]) / 2, e[1] - o) : (c[1] + d[3]) / 2 : e[1] > t[1] ? e[1] - o : n[1] - o, e[2] < t[0] ? e[1] > t[3] || e[3] < t[1] ? Math.max((c[2] + d[0]) / 2, e[2] + u) : (c[2] + d[0]) / 2 : e[2] < t[2] ? e[2] + u : n[2] + u, e[3] < t[1] ? e[0] > t[2] || e[2] < t[0] ? Math.max((c[3] + d[1]) / 2, e[3] + h) : (c[3] + d[1]) / 2 : e[3] < t[3] ? e[3] + h : n[3] + h], y = [t[0] > e[2] ? t[1] > e[3] || t[3] < e[1] ? Math.min((d[0] + c[2]) / 2, t[0] - v) : (d[0] + c[2]) / 2 : t[0] > e[0] ? t[0] - v : n[0] - v, t[1] > e[3] ? t[0] > e[2] || t[2] < e[0] ? Math.min((d[1] + c[3]) / 2, t[1] - p) : (d[1] + c[3]) / 2 : t[1] > e[1] ? t[1] - p : n[1] - p, t[2] < e[0] ? t[1] > e[3] || t[3] < e[1] ? Math.max((d[2] + c[0]) / 2, t[2] + g) : (d[2] + c[0]) / 2 : t[2] < e[2] ? t[2] + g : n[2] + g, t[3] < e[1] ? t[0] > e[2] || t[2] < e[0] ? Math.max((d[3] + c[1]) / 2, t[3] + b) : (d[3] + c[1]) / 2 : t[3] < e[3] ? t[3] + b : n[3] + b], w = HN([U, y]);
  if (!a && U[2] - U[0] + y[2] - y[0] > w[2] - w[0] + 1e-11 && U[3] - U[1] + y[3] - y[1] > w[3] - w[1] + 1e-11) {
    let [x, E] = [(y[0] + y[2]) / 2, (y[1] + y[3]) / 2];
    if (t[0] > e[2] && e[1] > t[3]) {
      let S = U[2] + (y[0] - U[2]) / 2, _ = y[3] + (U[1] - y[3]) / 2;
      return ar(_r(e[2] - x, e[1] - E), _r(e[0] - x, e[3] - E)) > 0 ? [[U[0], U[1], S, U[3]], [S, y[1], y[2], y[3]]] : [[U[0], _, U[2], U[3]], [y[0], y[1], y[2], _]];
    } else if (e[2] < t[0] && e[3] < t[1]) {
      let S = U[2] + (y[0] - U[2]) / 2, _ = U[3] + (y[1] - U[3]) / 2;
      return ar(_r(e[0] - x, e[1] - E), _r(e[2] - x, e[3] - E)) > 0 ? [[U[0], U[1], U[2], _], [y[0], _, y[2], y[3]]] : [[U[0], U[1], S, U[3]], [S, y[1], y[2], y[3]]];
    } else if (e[0] > t[2] && e[3] < t[1]) {
      let S = y[2] + (U[0] - y[2]) / 2, _ = U[3] + (y[1] - U[3]) / 2;
      return ar(_r(e[2] - x, e[1] - E), _r(e[0] - x, e[3] - E)) > 0 ? [[S, U[1], U[2], U[3]], [y[0], y[1], S, y[3]]] : [[U[0], U[1], U[2], _], [y[0], _, y[2], y[3]]];
    } else if (e[0] > t[2] && e[1] > t[3]) {
      let S = y[2] + (U[0] - y[2]) / 2, _ = y[3] + (U[1] - y[3]) / 2;
      return ar(_r(e[0] - x, e[1] - E), _r(e[2] - x, e[3] - E)) > 0 ? [[S, U[1], U[2], U[3]], [y[0], y[1], S, y[3]]] : [[U[0], _, U[2], U[3]], [y[0], y[1], y[2], _]];
    }
  }
  return [U, y];
}, Iae = (e, t, n, r, i, a) => {
  let l = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set();
  n === ai || n === In ? s.add(t[1]) : l.add(t[0]), i === ai || i === In ? s.add(r[1]) : l.add(r[0]), e.forEach((o) => {
    l.add(o[0]), l.add(o[2]), s.add(o[1]), s.add(o[3]);
  }), l.add(a[0]), l.add(a[2]), s.add(a[1]), s.add(a[3]);
  let c = Array.from(s).sort((o, u) => o - u), d = Array.from(l).sort((o, u) => o - u);
  return { row: c.length, col: d.length, data: c.flatMap((o, u) => d.map((h, f) => ({ f: 0, g: 0, h: 0, closed: !1, visited: !1, parent: null, addr: [f, u], pos: [h, o] }))) };
}, tE = (e, t, n) => {
  switch (t) {
    case li:
      return T(n[0], e[1]);
    case In:
      return T(e[2], n[1]);
    case yr:
      return T(n[0], e[3]);
  }
  return T(e[0], n[1]);
}, Aae = (e, t, n, r) => {
  if (r === In) switch (n) {
    case In:
      return e.pos[0] >= t.pos[0] ? 4 : e.pos[1] === t.pos[1] ? 0 : 2;
    case li:
      return e.pos[1] > t.pos[1] && e.pos[0] < t.pos[0] ? 1 : 3;
    case yr:
      return e.pos[1] < t.pos[1] && e.pos[0] < t.pos[0] ? 1 : 3;
    case ai:
      return e.pos[1] === t.pos[1] ? 4 : 2;
  }
  else if (r === ai) switch (n) {
    case In:
      return e.pos[1] === t.pos[1] ? 4 : 2;
    case li:
      return e.pos[1] > t.pos[1] && e.pos[0] > t.pos[0] ? 1 : 3;
    case yr:
      return e.pos[1] < t.pos[1] && e.pos[0] > t.pos[0] ? 1 : 3;
    case ai:
      return e.pos[0] <= t.pos[0] ? 4 : e.pos[1] === t.pos[1] ? 0 : 2;
  }
  else if (r === li) switch (n) {
    case In:
      return e.pos[1] > t.pos[1] && e.pos[0] < t.pos[0] ? 1 : 3;
    case li:
      return e.pos[1] >= t.pos[1] ? 4 : e.pos[0] === t.pos[0] ? 0 : 2;
    case yr:
      return e.pos[0] === t.pos[0] ? 4 : 2;
    case ai:
      return e.pos[1] > t.pos[1] && e.pos[0] > t.pos[0] ? 1 : 3;
  }
  else if (r === yr) switch (n) {
    case In:
      return e.pos[1] < t.pos[1] && e.pos[0] < t.pos[0] ? 1 : 3;
    case li:
      return e.pos[0] === t.pos[0] ? 4 : 2;
    case yr:
      return e.pos[1] <= t.pos[1] ? 4 : e.pos[0] === t.pos[0] ? 0 : 2;
    case ai:
      return e.pos[1] < t.pos[1] && e.pos[0] > t.pos[0] ? 1 : 3;
  }
  return 0;
}, Nae = ([e, t], n) => [Yu([e, t - 1], n), Yu([e + 1, t], n), Yu([e, t + 1], n), Yu([e - 1, t], n)], Yu = ([e, t], n) => e < 0 || e >= n.col || t < 0 || t >= n.row ? null : n.data[t * n.col + e] ?? null, O1 = (e, t) => {
  for (let n = 0; n < t.col; n++) for (let r = 0; r < t.row; r++) {
    let i = Yu([n, r], t);
    if (i && e[0] === i.pos[0] && e[1] === i.pos[1]) return i;
  }
  return null;
}, HN = (e) => [Math.min(...e.map((t) => t[0])), Math.min(...e.map((t) => t[1])), Math.max(...e.map((t) => t[2])), Math.max(...e.map((t) => t[3]))], k0 = (e, t) => {
  let n = t.get(e);
  return n && Pa(n) ? n : null;
}, _o = (e, t, n, r) => {
  let i = e[0][0], a = e[0][1], l = e.map((s) => xm(s, An(Le(e[0]), -1)));
  return (i < -Yt || i > Yt || a < -Yt || a > Yt || i + l[l.length - 1][0] < -Yt || a + l[l.length - 1][0] > Yt || i + l[l.length - 1][1] < -Yt || a + l[l.length - 1][1] > Yt) && console.error("Elbow arrow normalization is outside reasonable bounds (> 1e6)", { x: i, y: a, points: l, ...x0(l) }), l = l.map(([s, c]) => T(ft(s, -1e6, 1e6), ft(c, -1e6, 1e6))), { points: l, x: ft(i, -1e6, 1e6), y: ft(a, -1e6, 1e6), fixedSegments: ((t == null ? void 0 : t.length) ?? 0) > 0 ? t : null, ...x0(l), startIsSpecial: n, endIsSpecial: r };
}, Q8 = (e) => {
  if (e.length > 1) {
    let t = Math.abs(e[0][1] - e[1][1]) < Math.abs(e[0][0] - e[1][0]);
    return e.filter((n, r) => {
      if (r === 0 || r === e.length - 1) return !0;
      let i = e[r + 1], a = Math.abs(n[1] - i[1]) < Math.abs(n[0] - i[0]);
      return t === a ? (t = a, !1) : (t = a, !0);
    });
  }
  return e;
}, eU = (e) => e.length >= 4 ? e.filter((t, n) => {
  if (n === 0 || n === e.length - 1) return !0;
  let r = e[n - 1];
  return Tt(r, t) > Y8;
}) : e, Dae = (e) => {
  switch (e) {
    case 0:
      return li;
    case 1:
      return In;
    case 2:
      return yr;
  }
  return ai;
}, nE = (e, t, n, r, i, a, l) => {
  if (l) {
    if (a) {
      let s = Jh(e, a, t);
      return aie(a, s);
    }
    return r;
  }
  if (i) {
    let s = U7(n || [0, 0], i);
    return Math.abs(l2(i, s) - Zt) > 0.01 ? Jh(e, i, t) : s;
  }
  return r;
}, rE = (e, t, n, r, i) => tie(e, t, r, r && sl(r, Array(4).fill(l2(r, e))), n, i), iE = (e, t, n, r) => Sa(xa(e), n, t, r, !0, !0), aE = (e, t) => e[0] === t[0] && e[1] === t[1], tU = (e, t = Y8) => e.slice(1).map((n, r) => Math.abs(n[0] - e[r][0]) < t || Math.abs(n[1] - e[r][1]) < t).every(Boolean), Lae = { selection: !0, text: !0, rectangle: !0, diamond: !0, ellipse: !0, line: !0, image: !0, arrow: !0, freedraw: !0, eraser: !1, custom: !0, frame: !0, embeddable: !0, hand: !0, laser: !1, magicframe: !1 }, Rae = (e) => Object.keys(Un).includes(e) ? Un[e] : Oo, xd = (e, t) => {
  if (!t) return null;
  let n = t.focus || 0;
  return Se(e) ? km(t) ? { ...t, focus: n, fixedPoint: d2(t.fixedPoint ?? [0, 0]) } : null : { ...t, focus: n };
}, Bs = (e, t) => {
  let n = { type: t.type || e.type, version: e.version || 1, versionNonce: e.versionNonce ?? 0, index: e.index ?? null, isDeleted: e.isDeleted ?? !1, id: e.id || ia(), fillStyle: e.fillStyle || Cn.fillStyle, strokeWidth: e.strokeWidth || Cn.strokeWidth, strokeStyle: e.strokeStyle ?? Cn.strokeStyle, roughness: e.roughness ?? Cn.roughness, opacity: e.opacity == null ? Cn.opacity : e.opacity, angle: e.angle || 0, x: t.x ?? e.x ?? 0, y: t.y ?? e.y ?? 0, strokeColor: e.strokeColor || Cn.strokeColor, backgroundColor: e.backgroundColor || Cn.backgroundColor, width: e.width || 0, height: e.height || 0, seed: e.seed ?? 1, groupIds: e.groupIds ?? [], frameId: e.frameId ?? null, roundness: e.roundness ? e.roundness : e.strokeSharpness === "round" ? { type: ru(e.type) ? Jn.LEGACY : Jn.PROPORTIONAL_RADIUS } : null, boundElements: e.boundElementIds ? e.boundElementIds.map((r) => ({ type: "arrow", id: r })) : e.boundElements ?? [], updated: e.updated ?? nu(), link: e.link ? _i(e.link) : null, locked: e.locked ?? !1 };
  return ("customData" in e || "customData" in t) && (n.customData = "customData" in t ? t.customData : e.customData), { ...e, ...n, ...rD(n), ...t };
}, Pae = (e) => {
  switch (e = { ...e }, e.type) {
    case "text":
      delete e.rawText;
      let t = e.fontSize, n = e.fontFamily;
      if ("font" in e) {
        let [o, u] = e.font.split(" ");
        t = parseFloat(o), n = Rae(u);
      }
      let r = typeof e.text == "string" && e.text || "", i = e.lineHeight || (e.height ? sq(e) : Yc(e.fontFamily));
      return e = Bs(e, { fontSize: t, fontFamily: n, text: r, textAlign: e.textAlign || Ff, verticalAlign: e.verticalAlign || mm, containerId: e.containerId ?? null, originalText: e.originalText || r, autoResize: e.autoResize ?? !0, lineHeight: i }), !r && !e.isDeleted && (e = { ...e, originalText: r, isDeleted: !0 }, e = v2(e)), e;
    case "freedraw":
      return Bs(e, { points: e.points, lastCommittedPoint: null, simulatePressure: e.simulatePressure, pressures: e.pressures });
    case "image":
      return Bs(e, { status: e.status || "pending", fileId: e.fileId, scale: e.scale || [1, 1], crop: e.crop ?? null });
    case "line":
    case "draw":
      let { startArrowhead: a = null, endArrowhead: l = null } = e, s = e.x, c = e.y, d = !Array.isArray(e.points) || e.points.length < 2 ? [T(0, 0), T(e.width, e.height)] : e.points;
      return (d[0][0] !== 0 || d[0][1] !== 0) && ({ points: d, x: s, y: c } = Ee.getNormalizedPoints(e)), Bs(e, { type: e.type === "draw" ? "line" : e.type, startBinding: xd(e, e.startBinding), endBinding: xd(e, e.endBinding), lastCommittedPoint: null, startArrowhead: a, endArrowhead: l, points: d, x: s, y: c, ...x0(d) });
    case "arrow": {
      let { startArrowhead: o = null, endArrowhead: u = "arrow" } = e, h = e.x, f = e.y, p = !Array.isArray(e.points) || e.points.length < 2 ? [T(0, 0), T(e.width, e.height)] : e.points;
      (p[0][0] !== 0 || p[0][1] !== 0) && ({ points: p, x: h, y: f } = Ee.getNormalizedPoints(e));
      let g = { type: e.type, startBinding: xd(e, e.startBinding), endBinding: xd(e, e.endBinding), lastCommittedPoint: null, startArrowhead: o, endArrowhead: u, points: p, x: h, y: f, elbowed: e.elbowed, ...x0(p) };
      return Se(e) ? Bs(e, { ...g, elbowed: !0, startBinding: xd(e, e.startBinding), endBinding: xd(e, e.endBinding), fixedSegments: e.fixedSegments, startIsSpecial: e.startIsSpecial, endIsSpecial: e.endIsSpecial }) : Bs(e, g);
    }
    case "ellipse":
    case "rectangle":
    case "diamond":
    case "iframe":
    case "embeddable":
      return Bs(e, {});
    case "magicframe":
    case "frame":
      return Bs(e, { name: e.name ?? null });
  }
  return null;
}, Oae = (e, t) => {
  if (e.boundElements) {
    let n = e.boundElements.slice(), r = /* @__PURE__ */ new Set();
    e.boundElements = n.reduce((i, a) => {
      let l = t.get(a.id);
      if (l && !r.has(a.id)) {
        if (r.add(a.id), l.isDeleted) return i;
        i.push(a), we(l) && !l.containerId && (l.containerId = e.id);
      }
      return i;
    }, []);
  }
}, $ae = (e, t) => {
  let n = e.containerId ? t.get(e.containerId) : null;
  if (!n) {
    e.containerId = null;
    return;
  }
  if (!e.isDeleted && n.boundElements && !n.boundElements.find((r) => r.id === e.id)) {
    let r = (n.boundElements || (n.boundElements = [])).slice();
    r.push({ type: "text", id: e.id }), n.boundElements = r;
  }
}, Fae = (e, t) => {
  e.frameId && (t.get(e.frameId) || (e.frameId = null));
}, nU = (e, t, n) => {
  let r = /* @__PURE__ */ new Set(), i = t ? Ge(t) : null, a = xs((e || []).reduce((s, c) => {
    if (c.type !== "selection" && !M0(c)) {
      let d = Pae(c);
      if (d) {
        let o = i == null ? void 0 : i.get(c.id);
        o && o.version > d.version && (d = v2(d, o.version)), r.has(d.id) && (d = { ...d, id: ia() }), r.add(d.id), s.push(d);
      }
    }
    return s;
  }, []));
  if (!(n != null && n.repairBindings)) return a;
  let l = Ge(a);
  for (let s of a) s.frameId && Fae(s, l), we(s) && s.containerId ? $ae(s, l) : s.boundElements && Oae(s, l), n.refreshDimensions && we(s) && Object.assign(s, bN(s, xr(s, l), l)), et(s) && (s.startBinding && (!l.has(s.startBinding.elementId) || !dt(s)) && (s.startBinding = null), s.endBinding && (!l.has(s.endBinding.elementId) || !dt(s)) && (s.endBinding = null));
  return a.map((s) => {
    if (Se(s) && s.startBinding == null && s.endBinding == null && !tU(s.points)) return { ...s, ...q8(s, l, { points: [T(0, 0), s.points[s.points.length - 1]] }), index: s.index };
    if (Se(s) && s.startBinding && s.endBinding && s.startBinding.elementId === s.endBinding.elementId && s.points.length > 1 && s.points.some(([c, d]) => Math.abs(c) > 1e6 || Math.abs(d) > 1e6)) {
      console.error("Fixing self-bound elbow arrow", s.id);
      let c = l.get(s.startBinding.elementId);
      return c ? { ...s, x: c.x + c.width / 2, y: c.y - 5, width: c.width, height: c.height, points: [T(0, 0), T(0, -10), T(c.width / 2 + 5, -10), T(c.width / 2 + 5, c.height / 2 + 5)] } : (console.error("Bound element not found", s.startBinding.elementId), s);
    }
    return s;
  });
}, zae = (e, t, n) => {
  let r = t[e];
  return r !== void 0 ? r : n[e];
}, lE = { isSidebarDocked: (e, t) => ["defaultSidebarDockedPreference", e.isSidebarDocked ?? zae("defaultSidebarDockedPreference", e, t)] }, Bae = (e, t) => {
  var i;
  e = e || {};
  let n = El(), r = {};
  for (let a of Object.keys(lE)) if (a in e) {
    let [l, s] = lE[a](e, n);
    r[l] = s;
  }
  for (let [a, l] of Object.entries(n)) {
    let s = e[a], c = t ? t[a] : void 0;
    r[a] = s !== void 0 ? s : c !== void 0 ? c : l;
  }
  return { ...r, cursorButton: (t == null ? void 0 : t.cursorButton) || "up", penDetected: (t == null ? void 0 : t.penDetected) ?? (e.penMode ? e.penDetected ?? !1 : !1), activeTool: { ...Wn(n, r.activeTool.type && Lae[r.activeTool.type] ? r.activeTool : { type: "selection" }), lastActiveTool: null, locked: r.activeTool.locked ?? !1 }, zoom: { value: as(ph(e.zoom) ? e.zoom : ((i = e.zoom) == null ? void 0 : i.value) ?? n.zoom.value) }, openSidebar: typeof e.openSidebar == "string" ? { name: Ia.name } : r.openSidebar, gridSize: fie(ph(e.gridSize) ? e.gridSize : bm), gridStep: nN(ph(e.gridStep) ? e.gridStep : MI), editingFrame: null };
}, g2 = (e, t, n, r) => ({ elements: nU(e == null ? void 0 : e.elements, n, r), appState: Bae(e == null ? void 0 : e.appState, t || null), files: (e == null ? void 0 : e.files) || {} }), sE = (e) => {
  let t = nU(Jt(e.elements), null);
  return t.length ? { ...e, elements: t } : null;
}, rU = (e = [], t) => {
  let n = [];
  for (let r of e) if (Array.isArray(r)) {
    let i = sE({ status: t, elements: r, id: ia(), created: Date.now() });
    i && n.push(i);
  } else {
    let i = r, a = sE({ ...i, id: i.id || ia(), status: i.status || t, created: i.created || Date.now() });
    a && n.push(a);
  }
  return n;
}, Ua = 32, qt = 12, mo = 256, WN = 50, lc = "NOT_SPREADSHEET", af = "VALID_SPREADSHEET", qu = (e) => {
  let t = /^([-+]?)[$€£¥₩]?([-+]?)([\d.,]+)[%]?$/.exec(e);
  return t ? parseFloat(`${(t[1] || t[2]) + t[3]}`.replace(/,/g, "")) : null;
}, t5 = (e, t) => e.slice(1).every((n) => qu(n[t]) !== null), oE = (e) => {
  let t = e[0].length;
  if (t > 2) return { type: lc, reason: "More than 2 columns" };
  if (t === 1) {
    if (!t5(e, 0)) return { type: lc, reason: "Value is not numeric" };
    let c = qu(e[0][0]) === null, d = (c ? e.slice(1) : e).map((o) => qu(o[0]));
    return d.length < 2 ? { type: lc, reason: "Less than two rows" } : { type: af, spreadsheet: { title: c ? e[0][0] : null, labels: null, values: d } };
  }
  let n = t5(e, 0), r = t5(e, 1);
  if (!n && !r) return { type: lc, reason: "Value is not numeric" };
  let [i, a] = r ? [0, 1] : [1, 0], l = qu(e[0][a]) === null, s = l ? e.slice(1) : e;
  return s.length < 2 ? { type: lc, reason: "Less than 2 rows" } : { type: af, spreadsheet: { title: l ? e[0][a] : null, labels: s.map((c) => c[i]), values: s.map((c) => qu(c[a])) } };
}, Hae = (e) => {
  let t = [];
  for (let n = 0; n < e[0].length; n++) {
    let r = [];
    for (let i = 0; i < e.length; i++) r.push(e[i][n]);
    t.push(r);
  }
  return t;
}, Wae = (e) => {
  let t = e.trim().split(`
`).map((i) => i.trim().split("	"));
  if (t.length && t[0].length !== 2 && (t = e.trim().split(`
`).map((i) => i.trim().split(","))), t.length === 0) return { type: lc, reason: "No values" };
  let n = t[0].length;
  if (!t.every((i) => i.length === n)) return { type: lc, reason: "All rows don't have same number of columns" };
  let r = oE(t);
  if (r.type !== af) {
    let i = oE(Hae(t));
    if (i.type === af) return i;
  }
  return r;
}, zm = VK(HK), Ki = { fillStyle: "hachure", fontFamily: Oo, fontSize: Is, opacity: 100, roughness: 1, strokeColor: ht.black, roundness: null, strokeStyle: "solid", strokeWidth: 1, verticalAlign: Si.MIDDLE, locked: !1 }, XN = (e) => {
  let t = (Ua + qt) * e.values.length + qt, n = mo + qt * 2;
  return { chartWidth: t, chartHeight: n };
}, Xae = (e, t, n, r, i) => {
  var a;
  return ((a = e.labels) == null ? void 0 : a.map((l, s) => Ai({ groupIds: [r], backgroundColor: i, ...Ki, text: l.length > 8 ? `${l.slice(0, 5)}...` : l, x: t + s * (Ua + qt) + qt * 2, y: n + qt / 2, width: Ua, angle: 5.87, fontSize: 16, textAlign: "center", verticalAlign: "top" }))) || [];
}, Vae = (e, t, n, r, i) => {
  let a = Ai({ groupIds: [r], backgroundColor: i, ...Ki, x: t - qt, y: n - qt, text: "0", textAlign: "right" }), l = Ai({ groupIds: [r], backgroundColor: i, ...Ki, x: t - qt, y: n - mo - a.height / 2, text: Math.max(...e.values).toLocaleString(), textAlign: "right" });
  return [a, l];
}, Gae = (e, t, n, r, i) => {
  let { chartWidth: a, chartHeight: l } = XN(e), s = xc({ backgroundColor: i, groupIds: [r], ...Ki, type: "line", x: t, y: n, width: a, points: [T(0, 0), T(a, 0)] }), c = xc({ backgroundColor: i, groupIds: [r], ...Ki, type: "line", x: t, y: n, height: l, points: [T(0, 0), T(0, -l)] }), d = xc({ backgroundColor: i, groupIds: [r], ...Ki, type: "line", x: t, y: n - mo - qt, strokeStyle: "dotted", width: a, opacity: WN, points: [T(0, 0), T(a, 0)] });
  return [s, c, d];
}, VN = (e, t, n, r, i, a) => {
  let { chartWidth: l, chartHeight: s } = XN(e), c = e.title ? Ai({ backgroundColor: i, groupIds: [r], ...Ki, text: e.title, x: t + l / 2, y: n - mo - qt * 2 - Is, roundness: null, textAlign: "center" }) : null, d = a ? kl({ backgroundColor: i, groupIds: [r], ...Ki, type: "rectangle", x: t, y: n - s, width: l, height: s, strokeColor: ht.black, fillStyle: "solid", opacity: 6 }) : null;
  return [...d ? [d] : [], ...c ? [c] : [], ...Xae(e, t, n, r, i), ...Vae(e, t, n, r, i), ...Gae(e, t, n, r, i)];
}, jae = (e, t, n) => {
  let r = Math.max(...e.values), i = ia(), a = zm[Math.floor(Math.random() * zm.length)];
  return [...e.values.map((l, s) => {
    let c = l / r * mo;
    return kl({ backgroundColor: a, groupIds: [i], ...Ki, type: "rectangle", x: t + s * (Ua + qt) + qt, y: n - c - qt, width: Ua, height: c });
  }), ...VN(e, t, n, i, a, st.DEV)];
}, Kae = (e, t, n) => {
  let r = Math.max(...e.values), i = ia(), a = zm[Math.floor(Math.random() * zm.length)], l = 0, s = [];
  for (let g of e.values) {
    let b = l * (Ua + qt), v = -(g / r) * mo;
    s.push([b, v]), l++;
  }
  let c = Math.max(...s.map((g) => g[0])), d = Math.max(...s.map((g) => g[1])), o = Math.min(...s.map((g) => g[0])), u = Math.min(...s.map((g) => g[1])), h = xc({ backgroundColor: a, groupIds: [i], ...Ki, type: "line", x: t + qt + Ua / 2, y: n - qt, height: d - u, width: c - o, strokeWidth: 2, points: s }), f = e.values.map((g, b) => {
    let v = b * (Ua + qt) + qt / 2, U = -(g / r) * mo + qt / 2;
    return kl({ backgroundColor: a, groupIds: [i], ...Ki, fillStyle: "solid", strokeWidth: 2, type: "ellipse", x: t + v + Ua / 2, y: n + U - qt * 2, width: qt, height: qt });
  }), p = e.values.map((g, b) => {
    let v = b * (Ua + qt) + qt / 2, U = g / r * mo + qt / 2 + qt;
    return xc({ backgroundColor: a, groupIds: [i], ...Ki, type: "line", x: t + v + Ua / 2 + qt / 2, y: n - U, height: U, strokeStyle: "dotted", opacity: WN, points: [T(0, 0), T(0, U)] });
  });
  return [...VN(e, t, n, i, a, st.DEV), h, ...p, ...f];
}, Yae = (e, t, n, r) => e === "line" ? Kae(t, n, r) : jae(t, n, r), iU = "clipboard" in navigator && "writeText" in navigator.clipboard, aU = "clipboard" in navigator && "write" in navigator.clipboard && "ClipboardItem" in window && "toBlob" in HTMLCanvasElement.prototype, qae = (e) => !!([ji.excalidraw, ji.excalidrawClipboard, ji.excalidrawClipboardWithAPI].includes(e == null ? void 0 : e.type) && Array.isArray(e.elements)), Zae = ({ types: e, files: t }) => {
  var r, i, a, l;
  !e && !t && console.warn("createPasteEvent: no types or files provided");
  let n = new ClipboardEvent("paste", { clipboardData: new DataTransfer() });
  if (e) for (let [s, c] of Object.entries(e)) {
    if (typeof c != "string") {
      t = t || [], t.push(c);
      continue;
    }
    try {
      if ((r = n.clipboardData) == null || r.setData(s, c), ((i = n.clipboardData) == null ? void 0 : i.getData(s)) !== c) throw new Error(`Failed to set "${s}" as clipboardData item`);
    } catch (d) {
      throw new Error(d.message);
    }
  }
  if (t) {
    let s = -1;
    for (let c of t) {
      s++;
      try {
        if ((a = n.clipboardData) == null || a.items.add(c), ((l = n.clipboardData) == null ? void 0 : l.files[s]) !== c) throw new Error(`Failed to set file "${c.name}" as clipboardData item`);
      } catch (d) {
        throw new Error(d.message);
      }
    }
  }
  return n;
}, Jae = ({ elements: e, files: t }) => {
  let n = Ge(e), r = new Set(e.filter((s) => Ve(s))), i = !1, a = e.reduce((s, c) => (zi(c) && (i = !0, t && t[c.fileId] && (s[c.fileId] = t[c.fileId])), s), {});
  i && !t && console.warn("copyToClipboard: attempting to file element(s) without providing associated `files` object.");
  let l = { type: ji.excalidrawClipboard, elements: e.map((s) => {
    if (hi(s, n) && !r.has(hi(s, n))) {
      let c = dd(s);
      return le(c, { frameId: null }), c;
    }
    return s;
  }), files: t ? a : void 0 };
  return JSON.stringify(l);
}, Qae = async (e, t, n) => {
  await jf(Jae({ elements: e, files: t }), n);
}, ele = (e) => {
  let t = Wae(e);
  return t.type === af ? { spreadsheet: t.spreadsheet } : null;
};
function GN(e) {
  var n;
  let t = [];
  for (let r of e.childNodes) if (r.nodeType === 3) {
    let i = (n = r.textContent) == null ? void 0 : n.trim();
    i && t.push({ type: "text", value: i });
  } else if (r instanceof HTMLImageElement) {
    let i = r.getAttribute("src");
    i && i.startsWith("http") && t.push({ type: "imageUrl", value: i });
  } else t = t.concat(GN(r));
  return t;
}
var tle = (e) => {
  var n;
  let t = (n = e.clipboardData) == null ? void 0 : n.getData($e.html);
  if (!t) return null;
  try {
    let r = new DOMParser().parseFromString(t, $e.html), i = GN(r.body);
    if (i.length) return { type: "mixedContent", value: i };
  } catch (r) {
    console.error(`error in parseHTMLFromPaste: ${r.message}`);
  }
  return null;
}, nle = async () => {
  var n, r, i, a;
  let e = {}, t;
  try {
    t = await ((n = navigator.clipboard) == null ? void 0 : n.read());
  } catch (l) {
    try {
      if ((r = navigator.clipboard) != null && r.readText) {
        console.warn(`navigator.clipboard.readText() failed (${l.message}). Failling back to navigator.clipboard.read()`);
        let s = await ((i = navigator.clipboard) == null ? void 0 : i.readText());
        if (s) return { [$e.text]: s };
      }
    } catch (s) {
      if ((a = navigator.clipboard) != null && a.read) console.warn(`navigator.clipboard.readText() failed (${s.message}). Failling back to navigator.clipboard.read()`);
      else {
        if (s.name === "DataError") return console.warn(`navigator.clipboard.read() error, clipboard is probably empty: ${s.message}`), e;
        throw s;
      }
    }
    throw l;
  }
  for (let l of t) for (let s of l.types) if (WI(lY, s)) try {
    if (s === $e.text || s === $e.html) e[s] = await (await l.getType(s)).text();
    else if (hD(s)) {
      let c = await l.getType(s), d = Zu(c, s, void 0);
      e[s] = d;
    } else throw new Ux(`Unsupported clipboard type: ${s}`);
  } catch (c) {
    console.warn(c instanceof Ux ? c.message : `Cannot retrieve ${s} from clipboardItem: ${c.message}`);
  }
  return Object.keys(e).length === 0 && console.warn("No clipboard data found from clipboard.read()."), e;
}, rle = async (e, t = !1) => {
  var n, r;
  try {
    let i = !t && e && tle(e);
    return i ? i.value.every((a) => a.type === "text") ? { type: "text", value: ((n = e.clipboardData) == null ? void 0 : n.getData($e.text)) || i.value.map((a) => a.value).join(`
`).trim() } : i : { type: "text", value: (((r = e.clipboardData) == null ? void 0 : r.getData($e.text)) || "").trim() };
  } catch {
    return { type: "text", value: "" };
  }
}, jN = async (e, t = !1) => {
  let n = await rle(e, t);
  if (n.type === "mixedContent") return { mixedContent: n.value };
  try {
    let r = !t && ele(n.value);
    if (r) return r;
  } catch (r) {
    console.error(r);
  }
  try {
    let r = JSON.parse(n.value), i = r.type === ji.excalidrawClipboardWithAPI;
    if (qae(r)) return { elements: r.elements, files: r.files, text: t ? JSON.stringify(r.elements, null, 2) : void 0, programmaticAPI: i };
  } catch {
  }
  return { text: n.value };
}, ile = async (e) => {
  try {
    await navigator.clipboard.write([new window.ClipboardItem({ [$e.png]: e })]);
  } catch (t) {
    if (Hf(e)) await navigator.clipboard.write([new window.ClipboardItem({ [$e.png]: await e })]);
    else throw t;
  }
}, jf = async (e, t) => {
  var n, r;
  if (iU) try {
    await navigator.clipboard.writeText(e || "");
    return;
  } catch (i) {
    console.error(i);
  }
  try {
    if (t) {
      if ((n = t.clipboardData) == null || n.setData($e.text, e || ""), ((r = t.clipboardData) == null ? void 0 : r.getData($e.text)) !== e) throw new Error("Failed to setData on clipboardEvent");
      return;
    }
  } catch (i) {
    console.error(i);
  }
  if (!ale(e)) throw new Error("Error copying to clipboard.");
}, ale = (e) => {
  e || (e = " ");
  let t = document.documentElement.getAttribute("dir") === "rtl", n = document.createElement("textarea");
  n.style.border = "0", n.style.padding = "0", n.style.margin = "0", n.style.position = "absolute", n.style[t ? "right" : "left"] = "-9999px";
  let r = window.pageYOffset || document.documentElement.scrollTop;
  n.style.top = `${r}px`, n.style.fontSize = "12pt", n.setAttribute("readonly", ""), n.value = e, document.body.appendChild(n);
  let i = !1;
  try {
    n.select(), n.setSelectionRange(0, n.value.length), i = document.execCommand("copy");
  } catch (a) {
    console.error(a);
  }
  return n.remove(), i;
}, lU = ({ elements: e, appState: t, files: n, maxWidthOrHeight: r, getDimensions: i, exportPadding: a, exportingFrame: l }) => {
  let { elements: s, appState: c } = g2({ elements: e, appState: t }, null, null), { exportBackground: d, viewBackgroundColor: o } = c;
  return BN(s, { ...c, offsetTop: 0, offsetLeft: 0, width: 0, height: 0 }, n || {}, { exportBackground: d, exportPadding: a, viewBackgroundColor: o, exportingFrame: l }, (u, h) => {
    let f = document.createElement("canvas");
    if (r) {
      typeof i == "function" && console.warn("`getDimensions()` is ignored when `maxWidthOrHeight` is supplied.");
      let g = Math.max(u, h), b = r < g ? r / g : (t == null ? void 0 : t.exportScale) ?? 1;
      return f.width = u * b, f.height = h * b, { canvas: f, scale: b };
    }
    let p = (i == null ? void 0 : i(u, h)) || { width: u, height: h };
    return f.width = p.width, f.height = p.height, { canvas: f, scale: p.scale ?? 1 };
  });
}, KN = async ({ elements: e, appState: t = El(), files: n = {}, exportPadding: r, renderEmbeddables: i, exportingFrame: a, skipInliningFonts: l, reuseImages: s }) => {
  let { elements: c, appState: d } = g2({ elements: e, appState: t }, null, null), o = { ...d, exportPadding: r };
  return j8(c, o, n, { exportingFrame: a, renderEmbeddables: i, skipInliningFonts: l, reuseImages: s });
}, lle = (e) => e.type === "diamond" ? [T(e.width / 2, 0), T(e.width, e.height / 2), T(e.width / 2, e.height), T(0, e.height / 2)] : [T(0, 0), T(0 + e.width, 0), T(0 + e.width, e.height), T(0, e.height)], sle = (e) => et(e) || na(e) ? e.points : lle(e), cE = (e) => {
  let t = e.reduce((n, [r, i]) => (n.minY = Math.min(n.minY, i), n.minX = Math.min(n.minX, r), n.maxX = Math.max(n.maxX, r), n.maxY = Math.max(n.maxY, i), n), { minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0, cx: 0, cy: 0 });
  return t.cx = (t.maxX + t.minX) / 2, t.cy = (t.maxY + t.minY) / 2, t;
}, ole = (e) => {
  let t = sle(e), { cx: n, cy: r } = cE(t), i = T(n, r), a = t.map((o) => te(o, i, e.angle)), { minX: l, minY: s, maxX: c, maxY: d } = cE(a);
  return [l + e.x, s + e.y, c + e.x, d + e.y];
}, cle = (e, t) => {
  let n = ole(e);
  return (N1(n[0], Nr(t[0], t[2])) || N1(t[0], Nr(n[0], n[2]))) && (N1(n[1], Nr(t[1], t[3])) || N1(t[1], Nr(n[1], n[3])));
}, dle = ({ elements: e, bounds: t, type: n, errorMargin: r = 0 }) => {
  var l;
  jI(t) && (t = Oa(t, Ge(e)));
  let i = [t[0] - r, t[1] - r, t[2] + r, t[3] + r], a = /* @__PURE__ */ new Set();
  for (let s of e)
    if (!a.has(s.id) && cle(s, i)) {
      if (a.add(s.id), s.boundElements) for (let c of s.boundElements) a.add(c.id);
      we(s) && s.containerId && a.add(s.containerId), dt(s) && (s.startBinding && a.add(s.startBinding.elementId), s.endBinding && a.add((l = s.endBinding) == null ? void 0 : l.elementId));
    }
  return e.filter((s) => a.has(s.id));
};
function dE(e) {
  return [Math.min(e[0][0], e[1][0]), Math.min(e[0][1], e[1][1]), Math.max(e[0][0], e[1][0]), Math.max(e[0][1], e[1][1])];
}
function ule(e, t) {
  return e[0] <= t[2] && e[2] >= t[0] && e[1] <= t[3] && e[3] >= t[1];
}
var hle = 1e-6;
function uE(e, t) {
  let n = Le(e[1], e[0]), r = Le(t, e[0]), i = ar(n, r);
  return Math.abs(i) < hle;
}
function n5(e, t) {
  let n = Le(e[1], e[0]), r = Le(t, e[0]);
  return ar(n, r) < 0;
}
function hE(e, t) {
  return uE(e, t[0]) || uE(e, t[1]) || (n5(e, t[0]) ? !n5(e, t[1]) : n5(e, t[1]));
}
function fle(e, t) {
  return ule(dE(e), dE(t)) && hE(e, t) && hE(t, e);
}
var YN = (e, t, n) => {
  let r = Ge(e);
  for (let i of t) if (i.frameId) {
    let a = n.get(i.id), l = n.get(i.frameId);
    if (a) {
      let s = r.get(a);
      s && le(s, { frameId: l ?? i.frameId }, !1);
    }
  }
};
function sU(e, t, n) {
  let r = Cx(t, n), i = Cx(e, n);
  return r.some((a) => i.some((l) => fle(a, l)));
}
var qN = (e, t, n) => U2(fU(e, t, n, !1)).filter((r) => !Ve(r) && !r.frameId || r.frameId === t.id), oU = (e, t, n) => fU([t], e, n).some((r) => r.id === t.id), Kf = (e, t, n) => {
  let [r, i, a, l] = tt(t, n), [s, c, d, o] = Lt(e);
  return r <= s && i <= c && a >= d && l >= o;
}, ko = (e, t, n) => Kf([e], t, n) || sU(e, t, n) || oU(e, t, n), fE = (e, t, n) => {
  let [r, i, a, l] = tt(t, n);
  return LI(T(r, i), T(e.x, e.y), T(a, l));
}, ple = (e) => {
  let t = /* @__PURE__ */ new Map();
  for (let n of e) {
    let r = Ve(n) ? n.id : n.frameId;
    r && !t.has(r) && t.set(r, Ml(e, r));
  }
  return t;
}, Ml = (e, t) => {
  let n = [];
  for (let r of e.values()) r.frameId === t && n.push(r);
  return n;
}, cU = (e) => e.filter((t) => Ve(t)), dU = (e) => {
  let t = Ge(cU(e));
  return e.filter((n) => t.has(n.id) || !n.frameId || !t.has(n.frameId));
}, xp = (e, t, n, r) => {
  let i = Ml(e, t.id), a = new Set(i), l = /* @__PURE__ */ new Set([...qN(e, t, r), ...i.filter((h) => oU(h, t, r))]), s = i.filter((h) => !l.has(h)), c = new Set(Array.from(l).flatMap((h) => h.groupIds));
  for (let h of s) if (!sU(h, t, r)) h.groupIds.length === 0 && a.delete(h);
  else if (h.groupIds.length > 0) for (let f of h.groupIds) c.add(f);
  for (let h of s) if (h.groupIds.length > 0) {
    let f = !0;
    for (let p of h.groupIds) c.has(p) && (f = !1);
    f && a.delete(h);
  }
  let d = Array.from(l).filter((h) => h.groupIds.length === 0);
  for (let h of d) a.add(h);
  let o = Array.from(l).filter((h) => h.groupIds.length > 0), u = lN(o, n);
  for (let [h, f] of Object.entries(u)) if (f) {
    let p = ln(e, h);
    if (Kf(p, t, r)) for (let g of p) a.add(g);
  }
  return [...a].filter((h) => !(we(h) && h.containerId));
}, mle = (e, t, n) => gle(U2(e, qN(e, t, n)), t, n), gle = (e, t, n) => {
  let r = [], i = /* @__PURE__ */ new Map();
  for (let a of e) {
    let l = !1;
    if (a.groupIds.length > 0) {
      if (a.groupIds.some((s) => i.get(s))) l = !0;
      else {
        let s = new Set(a.groupIds.flatMap((c) => ln(n, c)));
        l = !Kf(Array.from(s), t, n);
      }
      a.groupIds.forEach((s) => {
        i.set(s, l);
      });
    }
    l || r.push(a);
  }
  return r;
}, hi = (e, t) => e.frameId && t.get(e.frameId) || null, ble = (e, t) => {
  let n = /* @__PURE__ */ new Set(), r = Ge(e);
  e = U2(e);
  for (let l of e) Ve(l) && l.id !== t.id && n.add(l.id);
  let i = /* @__PURE__ */ new Set(), a = [];
  for (let l of e) if (!(Ve(l) || l.frameId && n.has(l.frameId))) if (l.groupIds.length) {
    let s = l.groupIds.at(-1);
    if (!i.has(s)) {
      i.add(s);
      let c = ln(e, s);
      if (c.some((d) => ko(d, t, r))) for (let d of c) a.push(d);
    }
  } else ko(l, t, r) && a.push(l);
  return a;
}, yh = (e, t, n, r) => {
  let i = Ge(e), a = /* @__PURE__ */ new Map();
  for (let d of e.values()) d.frameId === n.id && a.set(d.id, !0);
  let l = new Set(t.map((d) => d.id)), s = [], c = /* @__PURE__ */ new Set();
  for (let d of t) Ve(d) && d.id !== n.id && c.add(d.id);
  for (let d of U2(e, t)) {
    if (Ve(d) || d.frameId && c.has(d.frameId) || d.frameId && r.selectedElementIds[d.id] && r.selectedElementIds[d.frameId]) continue;
    a.has(d.id) || s.push(d);
    let o = lt(d, i);
    o && !l.has(o.id) && !a.has(o.id) && s.push(o);
  }
  for (let d of s) le(d, { frameId: n.id }, !1);
  return e;
}, b2 = (e, t) => {
  let n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  for (let i of e) if (i.frameId) {
    n.set(i.id, i);
    let a = r.get(i.frameId) || [];
    a.push(i);
    let l = lt(i, t);
    l && (n.set(l.id, l), a.push(l)), r.set(i.frameId, a);
  }
  for (let [, i] of n) le(i, { frameId: null }, !1);
}, ZN = (e, t) => {
  let n = Ml(e, t.id);
  return b2(n, Ge(e)), e;
}, JN = (e, t, n, r) => yh(ZN(e, n), t, n, r.state).slice(), C0 = (e, t, n) => {
  let r = n.scene.getSelectedElements({ selectedElementIds: t.selectedElementIds, elements: e }), i = new Set(r);
  if (t.editingGroupId) for (let s of r) s.groupIds.length === 0 ? i.add(s) : s.groupIds.flatMap((c) => ln(e, c)).forEach((c) => i.add(c));
  let a = /* @__PURE__ */ new Set(), l = Ge(e);
  return i.forEach((s) => {
    s.frameId && !Ve(s) && !Bm(s, l, t) && a.add(s);
  }), a.size > 0 && b2(a, l), e;
}, U2 = (e, t) => {
  let n = /* @__PURE__ */ new Set(), r = t || e;
  for (let l of r.values()) {
    let s = l.groupIds[l.groupIds.length - 1];
    s && n.add(s);
  }
  let i = /* @__PURE__ */ new Set();
  for (let l of n) ln(e, l).some((s) => Ve(s)) && i.add(l);
  let a = [];
  for (let l of r.values()) i.has(l.groupIds[l.groupIds.length - 1]) || a.push(l);
  return a;
}, _7 = (e, t, n) => {
  let r = we(e) && xr(e, t) || e;
  return r.frameId && n.selectedElementIds[r.id] && n.selectedElementIds[r.frameId] ? hi(r, t) : n.selectedElementIds[r.id] && n.selectedElementsAreBeingDragged ? n.frameToHighlight : hi(r, t);
}, Bm = (e, t, n, r) => {
  var c;
  let i = (r == null ? void 0 : r.targetFrame) ?? _7(e, t, n);
  if (!i) return !1;
  let a = we(e) && xr(e, t) || e, l = (d) => {
    r != null && r.checkedGroups && a.groupIds.forEach((o) => {
      var u;
      (u = r.checkedGroups) == null || u.set(o, d);
    });
  };
  if (!n.selectedElementIds[a.id] || !n.selectedElementsAreBeingDragged || n.selectedElementIds[a.id] && n.selectedElementIds[i.id]) return !0;
  if (a.groupIds.length === 0) return ko(a, i, t);
  for (let d of a.groupIds) if ((c = r == null ? void 0 : r.checkedGroups) != null && c.has(d)) return r.checkedGroups.get(d);
  let s = new Set(a.groupIds.filter((d) => r != null && r.checkedGroups ? !r.checkedGroups.has(d) : !0).flatMap((d) => ln(t, d)));
  if (n.editingGroupId && n.selectedElementsAreBeingDragged) {
    let d = new Set(ct(t, n));
    if (n.frameToHighlight !== null) return !0;
    d.forEach((o) => {
      s.delete(o);
    });
  }
  for (let d of s) if (Ve(d)) return l(!1), !1;
  for (let d of s) if (ko(d, i, t)) return l(!0), !0;
  return !1;
}, pE = (e, t, n, r, i) => {
  if (!n.frameRendering || !n.frameRendering.clip) return !1;
  let a = sU(e, t, r) || oU(e, t, r);
  if (a) {
    for (let l of e.groupIds) i == null || i.set(l, !0);
    return !0;
  }
  if (!a && e.groupIds.length > 0 && !Kf([e], t, r)) {
    let l = !1;
    if (n.selectedElementsAreBeingDragged) l = Bm(e, r, n, { targetFrame: t, checkedGroups: i });
    else {
      l = e.frameId === t.id;
      for (let s of e.groupIds) i == null || i.set(s, l);
    }
    for (let s of e.groupIds) i == null || i.set(s, l);
    return l;
  }
  return !1;
}, QN = (e) => e.name === null ? VI(e) ? "Frame" : "AI Frame" : e.name, uU = (e, t) => dle({ elements: e, bounds: t, type: "overlap" }).filter((n) => !n.frameId || n.frameId === t.id), eD = (e) => {
  let t = Ge(e);
  return e.length > 1 && e.some((n) => n.frameId && t.has(n.frameId));
}, hU = (e) => {
  let t = /* @__PURE__ */ new Set();
  return e.forEach((n) => {
    Ve(n) && t.add(n.id);
  }), e.filter((n) => !(n.frameId && t.has(n.frameId)));
}, fU = (e, t, n, r = !0) => {
  let [i, a, l, s] = tt(t, n), c = e.filter((d) => {
    let [o, u, h, f] = Oa(d, n), p = hi(d, n);
    if (p) {
      let [g, b, v, U] = Oa(p, n);
      o = Math.max(g, o), u = Math.max(b, u), h = Math.min(v, h), f = Math.min(U, f);
    }
    return d.locked === !1 && d.type !== "selection" && !sn(d) && i <= o && a <= u && l >= h && s >= f;
  });
  return c = r ? hU(c) : c, c = c.filter((d) => {
    let o = hi(d, n);
    return o ? ko(d, o, n) : !0;
  }), c;
}, tD = (e, t, n, r) => {
  let i = new Set(t.map((a) => a.id));
  return e.filter((a) => {
    let l = Hm(a, n.width, n.height, n, r);
    return !i.has(a.id) && l;
  });
}, Qn = function() {
  let e = null, t = null, n = null, r = (i, a) => (n != null && i === e && a.selectedElementIds === t || (n = i.some((l) => a.selectedElementIds[l.id]), e = i, t = a.selectedElementIds), n);
  return r.clearCache = () => {
    e = null, t = null, n = null;
  }, r;
}(), Ule = (e, t, n) => {
  let r = Array.from(new Set(ct(e, t).map((i) => n(i))));
  return r.length === 1 ? r[0] : null;
}, ct = (e, t, n) => {
  let r = /* @__PURE__ */ new Set(), i = [];
  for (let a of e.values()) {
    if (t.selectedElementIds[a.id]) {
      i.push(a), r.add(a.id);
      continue;
    }
    if (n != null && n.includeBoundTextElement && sn(a) && t.selectedElementIds[a == null ? void 0 : a.containerId]) {
      i.push(a), r.add(a.id);
      continue;
    }
  }
  if (n != null && n.includeElementsInFrames) {
    let a = [];
    return i.forEach((l) => {
      Ve(l) && Ml(e, l.id).forEach((s) => !r.has(s.id) && a.push(s)), a.push(l);
    }), a;
  }
  return i;
}, nD = (e, t) => t.editingTextElement ? [t.editingTextElement] : t.newElement ? [t.newElement] : ct(e, t, { includeBoundTextElement: !0 }), kt = (e, t) => Tr(t.selectedElementIds, e) ? t.selectedElementIds : e, mE = (e) => {
  let t = /* @__PURE__ */ new Map(), n = [];
  for (let r of e) r.isDeleted || (n.push(r), t.set(r.id, r));
  return { elementsMap: t, elements: n };
}, vle = Of((e) => {
  (st.DEV || st.MODE === oi.TEST || window != null && window.DEBUG_FRACTIONAL_INDICES) && B8(e, { shouldThrow: st.DEV || st.MODE === oi.TEST, includeBoundTextValidation: !0 });
}, 1e3 * 60, { leading: !0, trailing: !1 }), yle = (e) => {
  let t = ["includeBoundTextElement", "includeElementsInFrames"], n = "";
  for (let r of t) n += `${r}:${e[r] ? "1" : "0"}`;
  return n;
}, gE = (e) => typeof e == "string", k7 = class Ep {
  constructor() {
    $(this, "callbacks", /* @__PURE__ */ new Set()), $(this, "nonDeletedElements", []), $(this, "nonDeletedElementsMap", ta(/* @__PURE__ */ new Map())), $(this, "elements", []), $(this, "nonDeletedFramesLikes", []), $(this, "frames", []), $(this, "elementsMap", ta(/* @__PURE__ */ new Map())), $(this, "selectedElementsCache", { selectedElementIds: null, elements: null, cache: /* @__PURE__ */ new Map() }), $(this, "sceneNonce"), $(this, "insertElement", (t) => {
      let n = t.frameId ? this.getElementIndex(t.frameId) : this.elements.length;
      this.insertElementAtIndex(t, n);
    }), $(this, "insertElements", (t) => {
      var r;
      if (!t.length) return;
      let n = (r = t[0]) != null && r.frameId ? this.getElementIndex(t[0].frameId) : this.elements.length;
      this.insertElementsAtIndex(t, n);
    }), $(this, "getContainerElement", (t) => t && t.containerId && this.getElement(t.containerId) || null), $(this, "getElementsFromId", (t) => {
      let n = this.getNonDeletedElementsMap(), r = n.get(t);
      return r ? [r] : ln(n, t);
    });
  }
  static mapElementToScene(t, n) {
    gE(t) ? this.sceneMapById.set(t, n) : (this.sceneMapByElement.set(t, n), this.sceneMapById.set(t.id, n));
  }
  static getScene(t) {
    return gE(t) ? this.sceneMapById.get(t) || null : this.sceneMapByElement.get(t) || null;
  }
  getSceneNonce() {
    return this.sceneNonce;
  }
  getNonDeletedElementsMap() {
    return this.nonDeletedElementsMap;
  }
  getElementsIncludingDeleted() {
    return this.elements;
  }
  getElementsMapIncludingDeleted() {
    return this.elementsMap;
  }
  getNonDeletedElements() {
    return this.nonDeletedElements;
  }
  getFramesIncludingDeleted() {
    return this.frames;
  }
  getSelectedElements(t) {
    let n = yle(t), r = (t == null ? void 0 : t.elements) || this.nonDeletedElements;
    if (this.selectedElementsCache.elements === r && this.selectedElementsCache.selectedElementIds === t.selectedElementIds) {
      let a = this.selectedElementsCache.cache.get(n);
      if (a) return a;
    } else (t == null ? void 0 : t.elements) == null && this.selectedElementsCache.cache.clear();
    let i = ct(r, { selectedElementIds: t.selectedElementIds }, t);
    return (t == null ? void 0 : t.elements) == null && (this.selectedElementsCache.selectedElementIds = t.selectedElementIds, this.selectedElementsCache.elements = this.nonDeletedElements, this.selectedElementsCache.cache.set(n, i)), i;
  }
  getNonDeletedFramesLikes() {
    return this.nonDeletedFramesLikes;
  }
  getElement(t) {
    return this.elementsMap.get(t) || null;
  }
  getNonDeletedElement(t) {
    let n = this.getElement(t);
    return n && T7(n) ? n : null;
  }
  mapElements(t) {
    let n = !1, r = this.elements.map((i) => {
      let a = t(i);
      return a !== i && (n = !0), a;
    });
    return n && this.replaceAllElements(r), n;
  }
  replaceAllElements(t) {
    let n = t instanceof Array ? t : Array.from(t.values()), r = [];
    vle(n), this.elements = xs(n), this.elementsMap.clear(), this.elements.forEach((a) => {
      Ve(a) && r.push(a), this.elementsMap.set(a.id, a), Ep.mapElementToScene(a, this);
    });
    let i = mE(this.elements);
    this.nonDeletedElements = i.elements, this.nonDeletedElementsMap = i.elementsMap, this.frames = r, this.nonDeletedFramesLikes = mE(this.frames).elements, this.triggerUpdate();
  }
  triggerUpdate() {
    this.sceneNonce = _l();
    for (let t of Array.from(this.callbacks)) t();
  }
  onUpdate(t) {
    if (this.callbacks.has(t)) throw new Error();
    return this.callbacks.add(t), () => {
      if (!this.callbacks.has(t)) throw new Error();
      this.callbacks.delete(t);
    };
  }
  destroy() {
    this.elements = [], this.nonDeletedElements = [], this.nonDeletedFramesLikes = [], this.frames = [], this.elementsMap.clear(), this.selectedElementsCache.selectedElementIds = null, this.selectedElementsCache.elements = null, this.selectedElementsCache.cache.clear(), Ep.sceneMapById.forEach((t, n) => {
      t === this && Ep.sceneMapById.delete(n);
    }), this.callbacks.clear();
  }
  insertElementAtIndex(t, n) {
    if (!Number.isFinite(n) || n < 0) throw new Error("insertElementAtIndex can only be called with index >= 0");
    let r = [...this.elements.slice(0, n), t, ...this.elements.slice(n)];
    Cl(r, Ge([t])), this.replaceAllElements(r);
  }
  insertElementsAtIndex(t, n) {
    if (!t.length) return;
    if (!Number.isFinite(n) || n < 0) throw new Error("insertElementAtIndex can only be called with index >= 0");
    let r = [...this.elements.slice(0, n), ...t, ...this.elements.slice(n)];
    Cl(r, Ge(t)), this.replaceAllElements(r);
  }
  getElementIndex(t) {
    return this.elements.findIndex((n) => n.id === t);
  }
};
$(k7, "sceneMapByElement", /* @__PURE__ */ new WeakMap()), $(k7, "sceneMapById", /* @__PURE__ */ new Map());
var wle = k7, Es = wle, le = (e, t, n = !0, r) => {
  var o, u;
  let i = !1, { points: a, fixedSegments: l, fileId: s, startBinding: c, endBinding: d } = t;
  if (Se(e) && (Object.keys(t).length === 0 || typeof a < "u" || typeof l < "u" || typeof c < "u" || typeof d < "u")) {
    let h = ta(((o = Es.getScene(e)) == null ? void 0 : o.getNonDeletedElementsMap()) ?? /* @__PURE__ */ new Map());
    t = { ...t, angle: 0, ...q8({ ...e, x: t.x || e.x, y: t.y || e.y }, h, { fixedSegments: l, points: a, startBinding: c, endBinding: d }, { isDragging: r == null ? void 0 : r.isDragging }) };
  } else typeof a < "u" && (t = { ...x0(a), ...t });
  for (let h in t) {
    let f = t[h];
    if (typeof f < "u") {
      if (e[h] === f && (typeof f != "object" || f === null || h === "groupIds" || h === "scale")) continue;
      if (h === "scale") {
        let p = e[h], g = f;
        if (p[0] === g[0] && p[1] === g[1]) continue;
      } else if (h === "points") {
        let p = e[h], g = f;
        if (p.length === g.length) {
          let b = !1, v = p.length;
          for (; --v; ) {
            let U = p[v], y = g[v];
            if (U[0] !== y[0] || U[1] !== y[1]) {
              b = !0;
              break;
            }
          }
          if (!b) continue;
        }
      }
      e[h] = f, i = !0;
    }
  }
  return i && ((typeof t.height < "u" || typeof t.width < "u" || typeof s < "u" || typeof a < "u") && wn.delete(e), e.version++, e.versionNonce = _l(), e.updated = nu(), n && ((u = Es.getScene(e)) == null || u.triggerUpdate())), e;
}, at = (e, t, n = !1) => {
  let r = !1;
  for (let i in t) {
    let a = t[i];
    if (typeof a < "u") {
      if (e[i] === a && (typeof a != "object" || a === null)) continue;
      r = !0;
    }
  }
  return !r && !n ? e : { ...e, ...t, updated: nu(), version: e.version + 1, versionNonce: _l() };
}, v2 = (e, t) => (e.version = (t ?? e.version) + 1, e.versionNonce = _l(), e.updated = nu(), e), M0 = (e) => et(e) || na(e) ? e.points.length < 2 : e.width === 0 && e.height === 0, Hm = (e, t, n, r, i) => {
  let [a, l, s, c] = Oa(e, i), d = en({ clientX: r.offsetLeft, clientY: r.offsetTop }, r), o = en({ clientX: r.offsetLeft + t, clientY: r.offsetTop + n }, r);
  return d.x <= s && d.y <= c && o.x >= a && o.y >= l;
}, Sp = (e, t, n, r, i, a) => {
  let [l, s, c, d] = Lt(e, i), o = en({ clientX: r.offsetLeft + ((a == null ? void 0 : a.left) || 0), clientY: r.offsetTop + ((a == null ? void 0 : a.top) || 0) }, r), u = en({ clientX: r.offsetLeft + t - ((a == null ? void 0 : a.right) || 0), clientY: r.offsetTop + n - ((a == null ? void 0 : a.bottom) || 0) }, r);
  return l >= o.x && s >= o.y && c <= u.x && d <= u.y;
}, bE = (e, t, n) => {
  let r = Math.abs(t), i = Math.abs(n);
  if (e === "line" || e === "arrow" || e === "freedraw") {
    let a = Math.round(Math.atan(i / r) / Eo) * Eo;
    a === 0 ? n = 0 : a === Math.PI / 2 ? t = 0 : n = r * Math.tan(a) * Math.sign(n) || n;
  } else e !== "selection" && (n = r * Math.sign(n));
  return { width: t, height: n };
}, C7 = (e, t, n, r) => {
  let i = n - e, a = r - t, l = Math.round(Math.atan(a / i) / Eo) * Eo;
  if (l === 0) a = 0;
  else if (l === Math.PI / 2) i = 0;
  else {
    let s = Math.tan(l), c = -1, d = t - s * e, o = -1 / s, u = -1, h = r - o * n, f = (c * h - u * d) / (s * u - o * c), p = (d * o - h * s) / (s * u - o * c);
    i = f - e, a = p - t;
  }
  return { width: i, height: a };
}, rD = (e) => {
  let t = { width: e.width, height: e.height, x: e.x, y: e.y };
  if (e.width < 0) {
    let n = Math.abs(e.width);
    t.width = n, t.x = e.x - n;
  }
  if (e.height < 0) {
    let n = Math.abs(e.height);
    t.height = n, t.y = e.y - n;
  }
  return t;
}, UE = { mouse: 8, pen: 16, touch: 28 }, xle = 16, iD = { e: !0, s: !0, n: !0, w: !0 }, vE = { e: !0, s: !0, n: !0, w: !0, nw: !0, se: !0 }, r5 = { e: !0, s: !0, n: !0, w: !0 }, Hl = (e, t, n, r, i, a, l) => {
  let [s, c] = te(T(e + n / 2, t + r / 2), T(i, a), l);
  return [s - n / 2, c - r / 2, n, r];
}, pU = (e) => !(e.viewport.isMobile || e.isTouchScreen && (jK || kI)), wh = (e) => pU(e) ? iD : {}, mU = ([e, t, n, r, i, a], l, s, c, d = {}, o = 4, u = Wc) => {
  let h = UE[c], f = h / s.value, p = h / s.value, g = h / s.value, b = h / s.value, v = n - e, U = r - t, y = o / s.value, w = (h - u * 2) / (2 * s.value), x = { nw: d.nw ? void 0 : Hl(e - y - g + w, t - y - b + w, f, p, i, a, l), ne: d.ne ? void 0 : Hl(n + y - w, t - y - b + w, f, p, i, a, l), sw: d.sw ? void 0 : Hl(e - y - g + w, r + y - w, f, p, i, a, l), se: d.se ? void 0 : Hl(n + y - w, r + y - w, f, p, i, a, l), rotation: d.rotation ? void 0 : Hl(e + v / 2 - f / 2, t - y - b + w - xle / s.value, f, p, i, a, l) }, E = 5 * UE.mouse / s.value;
  return Math.abs(v) > E && (d.n || (x.n = Hl(e + v / 2 - f / 2, t - y - b + w, f, p, i, a, l)), d.s || (x.s = Hl(e + v / 2 - f / 2, r + y - w, f, p, i, a, l))), Math.abs(U) > E && (d.w || (x.w = Hl(e - y - g + w, t + U / 2 - p / 2, f, p, i, a, l)), d.e || (x.e = Hl(n + y - w, t + U / 2 - p / 2, f, p, i, a, l))), x;
}, aD = (e, t, n, r = "mouse", i = iD) => {
  if (e.locked || Se(e)) return {};
  if (e.type === "freedraw" || et(e)) {
    if (e.points.length === 2) {
      let [, l] = e.points;
      l[0] === 0 || l[1] === 0 ? i = r5 : l[0] > 0 && l[1] < 0 ? i = vE : l[0] > 0 && l[1] > 0 ? i = r5 : l[0] < 0 && l[1] > 0 ? i = vE : l[0] < 0 && l[1] < 0 && (i = r5);
    }
  } else Ve(e) && (i = { ...i, rotation: !0 });
  let a = et(e) ? Wc + 8 : Mt(e) ? 0 : Wc;
  return mU(tt(e, n, !0), e.angle, t, r, i, a, Mt(e) ? 0 : void 0);
}, lD = (e, t) => {
  if (t.editingLinearElement) return !1;
  if (e.length > 1) return !0;
  let n = e[0];
  return Se(n) ? !1 : et(n) ? n.points.length > 2 : !0;
}, M7 = (e, t, n) => t >= e[0] && t <= e[0] + e[2] && n >= e[1] && n <= e[1] + e[3], Ele = (e, t, n, r, i, a, l, s) => {
  if (!n.selectedElementIds[e.id]) return !1;
  let { rotation: c, ...d } = aD(e, a, t, l, wh(s));
  if (c && M7(c, r, i)) return "rotation";
  let o = Object.keys(d).filter((u) => {
    let h = d[u];
    return h ? M7(h, r, i) : !1;
  });
  if (o.length > 0) return o[0];
  if (pU(s)) {
    let [u, h, f, p, g, b] = tt(e, t);
    if (!(et(e) && e.points.length <= 2)) {
      let v = Mt(e) ? 0 : gm / a.value, U = gm / a.value, y = sD(T(u - v, h - v), T(f + v, p + v), T(g, b), e.angle);
      for (let [w, x] of Object.entries(y)) if (Xc(T(r, i), x, U)) return w;
    }
  }
  return !1;
}, yE = (e, t, n, r, i, a, l, s) => e.reduce((c, d) => {
  if (c) return c;
  let o = Ele(d, l, t, n, r, i, a, s);
  return o ? { element: d, transformHandleType: o } : null;
}, null), wE = ([e, t, n, r], i, a, l, s, c) => {
  let d = mU([e, t, n, r, (e + n) / 2, (t + r) / 2], 0, l, s, wh(c)), o = Object.keys(d).find((u) => {
    let h = d[u];
    return h && M7(h, i, a);
  });
  if (o) return o;
  if (pU(c)) {
    let u = (e + n) / 2, h = (t + r) / 2, f = gm / l.value, p = sD(T(e - f, t - f), T(n + f, r + f), T(u, h), 0);
    for (let [g, b] of Object.entries(p)) if (Xc(T(i, a), b, f)) return g;
  }
  return !1;
}, i5 = ["ns", "nesw", "ew", "nwse"], Sle = (e, t) => {
  let n = i5.indexOf(e);
  if (n >= 0) {
    let r = Math.round(t / (Math.PI / 4));
    e = i5[(n + r) % i5.length];
  }
  return e;
}, xE = (e) => {
  let { element: t, transformHandleType: n } = e, r = t && Math.sign(t.height) * Math.sign(t.width) === -1, i = null;
  switch (n) {
    case "n":
    case "s":
      i = "ns";
      break;
    case "w":
    case "e":
      i = "ew";
      break;
    case "nw":
    case "se":
      r ? i = "nesw" : i = "nwse";
      break;
    case "ne":
    case "sw":
      r ? i = "nwse" : i = "nesw";
      break;
    case "rotation":
      return "grab";
  }
  return i && t && (i = Sle(i, t.angle)), i ? `${i}-resize` : "";
}, sD = ([e, t], [n, r], i, a) => {
  let l = te(T(e, t), i, a), s = te(T(n, t), i, a), c = te(T(e, r), i, a), d = te(T(n, r), i, a);
  return { n: [l, s], e: [s, d], s: [d, c], w: [c, l] };
}, _le = (e, t, n, r, i, a, l, s, c, d, o, u) => {
  if (n.length === 1) {
    let [h] = n;
    if (t === "rotation") Se(h) || (kle(h, r, i, c, d, a), ui(h, r));
    else {
      if (we(h) && t) return Cle(e, h, r, t, l, c, d), ui(h, r), !0;
      if (t) {
        let f = n[0].id, p = r.get(f), g = e.get(f);
        if (p && g) {
          let { nextWidth: b, nextHeight: v } = Dle(p, g, r, e, t, c, d, { shouldMaintainAspectRatio: s, shouldResizeFromCenter: l });
          lf(b, v, p, g, r, e, t, { shouldMaintainAspectRatio: s, shouldResizeFromCenter: l });
        }
      }
    }
    return !0;
  } else if (n.length > 1) {
    if (t === "rotation") return Mle(e, n, r, i, c, d, a, o, u), !0;
    if (t) {
      let { nextWidth: h, nextHeight: f, flipByX: p, flipByY: g, originalBoundingBox: b } = Lle(n, e, r, t, c, d, { shouldMaintainAspectRatio: s, shouldResizeFromCenter: l });
      return oD(n, r, t, i, e, { shouldResizeFromCenter: l, shouldMaintainAspectRatio: s, flipByX: p, flipByY: g, nextWidth: h, nextHeight: f, originalBoundingBox: b }), !0;
    }
  }
  return !1;
}, kle = (e, t, n, r, i, a) => {
  let [l, s, c, d] = tt(e, t), o = (l + c) / 2, u = (s + d) / 2, h;
  Ve(e) ? h = 0 : (h = 5 * Math.PI / 2 + Math.atan2(i - u, r - o), a && (h = h + Eo / 2, h = h - h % Eo), h = ym(h));
  let f = ys(e);
  if (le(e, { angle: h }), f) {
    let p = n.getElement(f);
    p && !dt(e) && le(p, { angle: h });
  }
}, gU = (e, t, n, r) => et(e) || na(e) ? { points: Am(0, t, Am(1, n, e.points, r), r) } : {}, bU = (e, t, n) => {
  let r = e.width;
  if (sn(e)) {
    let a = xr(e, t);
    a && (r = ws(a, e));
  }
  let i = e.fontSize * (n / r);
  return i < d8 ? null : { size: i };
}, Cle = (e, t, n, r, i, a, l) => {
  let [s, c, d, o, u, h] = tt(t, n), [f, p] = te(T(a, l), T(u, h), -t.angle), g = 0, b = 0;
  r !== "e" && r !== "w" && (r.includes("e") && (g = (f - s) / (d - s)), r.includes("w") && (g = (d - f) / (d - s)), r.includes("n") && (b = (o - p) / (o - c)), r.includes("s") && (b = (p - c) / (o - c)));
  let v = Math.max(g, b);
  if (v > 0) {
    let U = t.width * v, y = t.height * v, w = bU(t, n, U);
    if (w === null) return;
    let x = [s, c], E = [d, o], S = [u, h], _ = T(s, c);
    if (["n", "w", "nw"].includes(r) && (_ = T(E[0] - Math.abs(U), E[1] - Math.abs(y))), r === "ne") {
      let F = [x[0], E[1]];
      _ = T(F[0], F[1] - Math.abs(y));
    }
    if (r === "sw") {
      let F = [E[0], x[1]];
      _ = T(F[0] - Math.abs(U), F[1]);
    }
    ["s", "n"].includes(r) && (_[0] = S[0] - U / 2), ["e", "w"].includes(r) && (_[1] = S[1] - y / 2), i && (_[0] = S[0] - Math.abs(U) / 2, _[1] = S[1] - Math.abs(y) / 2);
    let k = t.angle, M = te(_, T(u, h), k), A = T(_[0] + Math.abs(U) / 2, _[1] + Math.abs(y) / 2), L = te(A, T(u, h), k);
    _ = te(M, L, -k);
    let [R, z] = _;
    le(t, { fontSize: w.size, width: U, height: y, x: R, y: z });
  }
  if (r === "e" || r === "w") {
    let U = e.get(t.id), [y, w, x, E] = po(U, U.width, U.height, !0), S = T(y, w), _ = T(x, E), k = Bf(S, _), M = te(T(a, l), k, -U.angle), [A, , L] = po(t, t.width, t.height, !0), R = L - A, z = _[0] - S[0], F = v8(Wt({ fontSize: t.fontSize, fontFamily: t.fontFamily }), t.lineHeight), W = z / R;
    r.includes("e") && (W = (M[0] - S[0]) / R), r.includes("w") && (W = (_[0] - M[0]) / R);
    let B = t.width * W < F ? F : t.width * W, j = cd(t.originalText, Wt(t), Math.abs(B)), V = $r(j, Wt(t), t.lineHeight), q = V.height, [oe, Ue, fe, Pe] = po(U, B, q, !0), ze = fe - oe, Oe = Pe - Ue, Be = [...S];
    ["n", "w", "nw"].includes(r) && (Be = [_[0] - Math.abs(ze), S[1]]);
    let qe = U.angle, At = te(Be, k, qe), Je = T(Be[0] + Math.abs(ze) / 2, Be[1] + Math.abs(Oe) / 2), mt = te(Je, k, qe);
    Be = te(At, mt, -qe);
    let jt = { width: Math.abs(B), height: Math.abs(V.height), x: Be[0], y: Be[1], text: j, autoResize: !1 };
    le(t, jt);
  }
}, Mle = (e, t, n, r, i, a, l, s, c) => {
  var o;
  let d = 5 * Math.PI / 2 + Math.atan2(a - c, i - s);
  l && (d += Eo / 2, d -= d % Eo);
  for (let u of t) if (!Ve(u)) {
    let [h, f, p, g] = tt(u, n), b = (h + p) / 2, v = (f + g) / 2, U = ((o = e.get(u.id)) == null ? void 0 : o.angle) ?? u.angle, [y, w] = te(T(b, v), T(s, c), d + U - u.angle);
    Se(u) ? le(u, { points: uie(u, n) }) : le(u, { x: u.x + (y - b), y: u.y + (w - v), angle: ym(d + U) }, !1), ui(u, n, { simultaneouslyUpdated: t });
    let x = lt(u, n);
    x && !dt(u) && le(x, { x: x.x + (y - b), y: x.y + (w - v), angle: ym(d + U) }, !1);
  }
  r.triggerUpdate();
}, Tle = (e, t, n, r, i) => {
  let [a, l, s, c] = t.length === 1 ? tt(t[0], n) : Lt(t), d = (a + s) / 2, o = (l + c) / 2, u = t.length === 1 ? t[0].angle : 0;
  switch ([r, i] = te(T(r, i), T(d, o), -u), e) {
    case "n":
      return te(T(r - (a + s) / 2, i - l), T(0, 0), u);
    case "s":
      return te(T(r - (a + s) / 2, i - c), T(0, 0), u);
    case "w":
      return te(T(r - a, i - (l + c) / 2), T(0, 0), u);
    case "e":
      return te(T(r - s, i - (l + c) / 2), T(0, 0), u);
    case "nw":
      return te(T(r - a, i - l), T(0, 0), u);
    case "ne":
      return te(T(r - s, i - l), T(0, 0), u);
    case "sw":
      return te(T(r - a, i - c), T(0, 0), u);
    case "se":
      return te(T(r - s, i - c), T(0, 0), u);
    default:
      return [0, 0];
  }
}, Ile = (e, t) => {
  let [, [n, r]] = t.points;
  return e === "nw" && (n < 0 || r < 0) || e === "ne" && n >= 0 || e === "sw" && n <= 0 || e === "se" && (n > 0 || r > 0) ? "end" : "origin";
}, Ale = (e, t, n) => {
  if (n) return "center";
  if (t) switch (e) {
    case "n":
      return "south-side";
    case "e":
      return "west-side";
    case "s":
      return "north-side";
    case "w":
      return "east-side";
    case "ne":
      return "bottom-left";
    case "nw":
      return "bottom-right";
    case "se":
      return "top-left";
    case "sw":
      return "top-right";
  }
  return ["e", "se", "s"].includes(e) ? "top-left" : ["n", "nw", "w"].includes(e) ? "bottom-right" : e === "ne" ? "bottom-left" : "top-right";
}, Nle = (e, t, n, r, i, a, l, s, c) => {
  let d = Ale(l, s, c), [o, u] = e;
  switch (d) {
    case "top-left":
      return { x: o + (t - r) / 2 + (r - t) / 2 * Math.cos(a) + (n - i) / 2 * Math.sin(a), y: u + (n - i) / 2 + (r - t) / 2 * Math.sin(a) + (i - n) / 2 * Math.cos(a) };
    case "top-right":
      return { x: o + (t - r) / 2 * (Math.cos(a) + 1) + (n - i) / 2 * Math.sin(a), y: u + (n - i) / 2 + (t - r) / 2 * Math.sin(a) + (i - n) / 2 * Math.cos(a) };
    case "bottom-left":
      return { x: o + (t - r) / 2 * (1 - Math.cos(a)) + (i - n) / 2 * Math.sin(a), y: u + (n - i) / 2 * (Math.cos(a) + 1) + (r - t) / 2 * Math.sin(a) };
    case "bottom-right":
      return { x: o + (t - r) / 2 * (Math.cos(a) + 1) + (i - n) / 2 * Math.sin(a), y: u + (n - i) / 2 * (Math.cos(a) + 1) + (t - r) / 2 * Math.sin(a) };
    case "center":
      return { x: o - (r - t) / 2, y: u - (i - n) / 2 };
    case "east-side":
      return { x: o + (t - r) / 2 * (Math.cos(a) + 1), y: u + (t - r) / 2 * Math.sin(a) + (n - i) / 2 };
    case "west-side":
      return { x: o + (t - r) / 2 * (1 - Math.cos(a)), y: u + (r - t) / 2 * Math.sin(a) + (n - i) / 2 };
    case "north-side":
      return { x: o + (t - r) / 2 + (n - i) / 2 * Math.sin(a), y: u + (i - n) / 2 * (Math.cos(a) - 1) };
    case "south-side":
      return { x: o + (t - r) / 2 + (i - n) / 2 * Math.sin(a), y: u + (n - i) / 2 * (Math.cos(a) + 1) };
  }
}, lf = (e, t, n, r, i, a, l, { shouldInformMutation: s = !0, shouldMaintainAspectRatio: c = !1, shouldResizeFromCenter: d = !1 } = {}) => {
  let o = {}, u = lt(n, i);
  if (u) {
    let g = a.get(u.id);
    if (g && (o = { fontSize: g.fontSize }), c) {
      let b = { ...n, width: e }, v = bU(u, i, ws(b, u));
      if (v === null) return;
      o = { fontSize: v.size };
    } else {
      let b = qI(Wt(u), u.lineHeight), v = ZI(u.fontSize, u.lineHeight);
      e = Math.max(e, b), t = Math.max(t, v);
    }
  }
  let h = gU(r, e, t, !0), f = T(r.x, r.y);
  if (et(r)) {
    let [g, b] = Oa(r, a);
    f = T(g, b);
  }
  let p = Nle(f, r.width, r.height, e, t, r.angle, l, c, d);
  if (et(r) && h.points) {
    let g = r.x - f[0], b = r.y - f[1];
    p.x += g, p.y += b;
    let v = h.points[0][0], U = h.points[0][1];
    p.x += v, p.y += U, h.points = h.points.map((y) => T(y[0] - v, y[1] - U));
  }
  if (e < 0 && (p.x = p.x + e), t < 0 && (p.y = p.y + t), "scale" in n && "scale" in r && le(n, { scale: [(Math.sign(e) || r.scale[0]) * r.scale[0], (Math.sign(t) || r.scale[1]) * r.scale[1]] }), dt(n) && u && c) {
    let g = e / n.width * u.fontSize;
    if (g < d8) return;
    o.fontSize = g;
  }
  if (e !== 0 && t !== 0 && Number.isFinite(p.x) && Number.isFinite(p.y)) {
    let g = { ...p, width: Math.abs(e), height: Math.abs(t), ...h };
    le(n, g, s), ui(n, i, { newSize: { width: e, height: t } }), u && o != null && le(u, { fontSize: o.fontSize }), Gf(n, i, l, c);
  }
}, Dle = (e, t, n, r, i, a, l, { shouldMaintainAspectRatio: s = !1, shouldResizeFromCenter: c = !1 } = {}) => {
  let [d, o, u, h] = po(t, t.width, t.height, !0), f = T(d, o), p = T(u, h), g = Bf(f, p), b = te(T(a, l), g, -t.angle), [v, U, y, w] = po(e, e.width, e.height, !0), x = y - v, E = w - U, S = p[0] - f[0], _ = p[1] - f[1], k = S / x, M = _ / E;
  i.includes("e") && (k = (b[0] - f[0]) / x), i.includes("s") && (M = (b[1] - f[1]) / E), i.includes("w") && (k = (p[0] - b[0]) / x), i.includes("n") && (M = (p[1] - b[1]) / E);
  let A = e.width * k, L = e.height * M;
  if (c && (A = 2 * A - t.width, L = 2 * L - t.height), s) {
    let R = Math.abs(A) / t.width, z = Math.abs(L) / t.height;
    if (i.length === 1 && (L *= R, A *= z), i.length === 2) {
      let F = Math.max(R, z);
      A = t.width * F * Math.sign(A), L = t.height * F * Math.sign(L);
    }
  }
  return { nextWidth: A, nextHeight: L };
}, Lle = (e, t, n, r, i, a, { shouldMaintainAspectRatio: l = !1, shouldResizeFromCenter: s = !1 } = {}) => {
  let c = e.map((R) => t.get(R.id)), d = c.reduce((R, z) => {
    if (!et(z)) return R;
    let F = ys(z);
    if (!F) return R;
    let W = t.get(F) ?? null;
    return sn(W) ? [...R, { ...W, ...Ee.getBoundTextElementPosition(z, W, n) }] : R;
  }, []), o = Na(c.map((R) => R).concat(d)), { minX: u, minY: h, maxX: f, maxY: p, midX: g, midY: b } = o, v = f - u, U = p - h, y = { ne: [u, p], se: [u, h], sw: [f, h], nw: [f, p], e: [u, h + U / 2], w: [f, h + U / 2], n: [u + v / 2, p], s: [u + v / 2, h] }, [w, x] = s ? [g, b] : y[r], E = s ? 2 : 1, S = Math.max(Math.abs(i - w) / v || 0, Math.abs(a - x) / U || 0) * E, _ = r.includes("e") || r.includes("w") ? Math.abs(i - w) * E : v, k = r.includes("n") || r.includes("s") ? Math.abs(a - x) * E : U;
  l && (_ = v * S * Math.sign(i - w), k = U * S * Math.sign(a - x));
  let M = { ne: [i < w, a > x], se: [i < w, a < x], sw: [i > w, a < x], nw: [i > w, a > x], e: [i < w, !1], w: [i > w, !1], n: [!1, a > x], s: [!1, a < x] }, [A, L] = M[r].map((R) => R);
  return { originalBoundingBox: o, nextWidth: _, nextHeight: k, flipByX: A, flipByY: L };
}, oD = (e, t, n, r, i, { shouldMaintainAspectRatio: a = !1, shouldResizeFromCenter: l = !1, flipByX: s = !1, flipByY: c = !1, nextHeight: d, nextWidth: o, originalBoundingBox: u } = {}) => {
  if (o === void 0 && d === void 0 && s === void 0 && c === void 0 || d === 0 || o === 0) return;
  i || (i = t);
  let h = e.reduce((E, S) => {
    let _ = i.get(S.id);
    return _ && E.push({ orig: _, latest: S }), E;
  }, []), f;
  if (u) f = u;
  else {
    let E = h.reduce((S, { orig: _ }) => {
      if (!et(_)) return S;
      let k = ys(_);
      if (!k) return S;
      let M = i.get(k) ?? null;
      return sn(M) ? [...S, { ...M, ...Ee.getBoundTextElementPosition(_, M, t) }] : S;
    }, []);
    f = Na(h.map(({ orig: S }) => S).concat(E));
  }
  let { minX: p, minY: g, maxX: b, maxY: v, midX: U, midY: y } = f, w = b - p, x = v - g;
  if (o === void 0 && d === void 0 && (o = w, d = x), a && (o === void 0 ? o = d * (w / x) : d === void 0 ? d = o * (x / w) : Math.abs(o / d - w / x) > 1e-3 && (o = d * (w / x))), o && d) {
    let E = n.includes("e") || n.includes("w") ? Math.abs(o) / w : 1, S = n.includes("n") || n.includes("s") ? Math.abs(d) / x : 1, _;
    n.length === 1 ? _ = n.includes("e") || n.includes("w") ? E : S : _ = Math.max(Math.abs(o) / w || 0, Math.abs(d) / x || 0);
    let k = { ne: [p, v], se: [p, g], sw: [b, g], nw: [b, v], e: [p, g + x / 2], w: [b, g + x / 2], n: [p + w / 2, v], s: [p + w / 2, g] }, [M, A] = l ? [U, y] : k[n], L = a || h.some((B) => B.latest.angle !== 0 || we(B.latest) || E0(B.latest));
    L && (E = _, S = _);
    let [R, z] = [s ? -1 : 1, c ? -1 : 1], F = [];
    for (let { orig: B, latest: j } of h) {
      if (we(B) && sn(B)) continue;
      let V = B.width * E, q = B.height * S, oe = ym(B.angle * R * z), Ue = et(B) || na(B), fe = B.x - M, Pe = B.y - A, ze = s && !Ue ? V : 0, Oe = c && !Ue ? q : 0, Be = M + R * (fe * E + ze), qe = A + z * (Pe * S + Oe), At = gU(B, V * R, q * z, !1), Je = { x: Be, y: qe, width: V, height: q, angle: oe, ...At };
      if (Se(B) && (B.startBinding && (Je.startBinding = { ...B.startBinding, fixedPoint: [s ? -B.startBinding.fixedPoint[0] + 1 : B.startBinding.fixedPoint[0], c ? -B.startBinding.fixedPoint[1] + 1 : B.startBinding.fixedPoint[1]] }), B.endBinding && (Je.endBinding = { ...B.endBinding, fixedPoint: [s ? -B.endBinding.fixedPoint[0] + 1 : B.endBinding.fixedPoint[0], c ? -B.endBinding.fixedPoint[1] + 1 : B.endBinding.fixedPoint[1]] }), B.fixedSegments && At.points && (Je.fixedSegments = B.fixedSegments.map((jt) => ({ ...jt, start: At.points[jt.index - 1], end: At.points[jt.index] })))), Mt(B) && (Je.scale = [B.scale[0] * R, B.scale[1] * z]), we(B)) {
        let jt = bU(B, t, V);
        if (!jt) return;
        Je.fontSize = jt.size;
      }
      let mt = i.get(ys(B) ?? "");
      if (mt) if (L) {
        let jt = mt.fontSize * _;
        if (jt < d8) return;
        Je.boundTextFontSize = jt;
      } else Je.boundTextFontSize = mt.fontSize;
      F.push({ element: j, update: Je });
    }
    let W = F.map(({ element: B }) => B);
    for (let { element: B, update: { boundTextFontSize: j, ...V } } of F) {
      let { width: q, height: oe, angle: Ue } = V;
      le(B, V, !1, { isDragging: !0 }), ui(B, t, { simultaneouslyUpdated: W, newSize: { width: q, height: oe } });
      let fe = lt(B, t);
      fe && j && (le(fe, { fontSize: j, angle: et(B) ? void 0 : Ue }, !1), Gf(B, t, n, !0));
    }
    r.triggerUpdate();
  }
}, Rle = (e, t, n, r, i, a) => {
  if (t.length === 1 && Se(t[0]) && (t[0].startBinding || t[0].endBinding)) return;
  let l = t.filter((u) => {
    if (Se(u) && u.startBinding && u.endBinding) {
      let h = t.find((p) => {
        var g;
        return p.id === ((g = u.startBinding) == null ? void 0 : g.elementId);
      }), f = t.find((p) => {
        var g;
        return p.id === ((g = u.endBinding) == null ? void 0 : g.elementId);
      });
      return h && f;
    }
    return !0;
  }), s = new Set(l), c = l.filter((u) => Ve(u)).map((u) => u.id);
  if (c.length > 0) for (let u of r.getNonDeletedElements()) u.frameId !== null && c.includes(u.frameId) && s.add(u);
  let d = Lt(Array.from(s).map((u) => e.originalElements.get(u.id) ?? u)), o = Ple(d, n, i, a);
  s.forEach((u) => {
    if (EE(e, u, o), !dt(u)) {
      let h = lt(u, r.getNonDeletedElementsMap());
      h && EE(e, h, o), ui(u, r.getElementsMapIncludingDeleted(), { simultaneouslyUpdated: Array.from(s) });
    }
  });
}, Ple = (e, t, n, r) => {
  let [i, a] = e, l = i + t.x + n.x, s = a + t.y + n.y;
  if (n.x === 0 || n.y === 0) {
    let [c, d] = Yn(i + t.x, a + t.y, r);
    n.x === 0 && (l = c), n.y === 0 && (s = d);
  }
  return { x: l - i, y: s - a };
}, EE = (e, t, n) => {
  let r = e.originalElements.get(t.id) ?? t, i = r.x + n.x, a = r.y + n.y;
  le(t, { x: i, y: a });
}, Ole = (e, t, n) => {
  let [r, i] = Lt(e);
  return [t - r, n - i];
}, SE = ({ newElement: e, elementType: t, originX: n, originY: r, x: i, y: a, width: l, height: s, shouldMaintainAspectRatio: c, shouldResizeFromCenter: d, zoom: o, widthAspectRatio: u = null, originOffset: h = null, informMutation: f = !0 }) => {
  c && e.type !== "selection" && (u ? s = l / u : (Math.abs(a - r) > Math.abs(i - n) ? { width: l, height: s } = bE(t, s, i < n ? -l : l) : { width: l, height: s } = bE(t, l, a < r ? -s : s), s < 0 && (s = -s)));
  let p = i < n ? n - l : n, g = a < r ? r - s : r;
  d && (l += l, s += s, p = n - l / 2, g = r - s / 2);
  let b = null;
  if (we(e)) {
    s = e.height;
    let v = v8(Wt({ fontSize: e.fontSize, fontFamily: e.fontFamily }), e.lineHeight);
    l = Math.max(l, v), Math.abs(i - n) > JK / o && (b = { autoResize: !1 }), g = r, d && (p = n - l / 2);
  }
  if (l !== 0 && s !== 0) {
    let v = null;
    Mt(e) && (v = { initialWidth: l, initialHeight: s }), le(e, { x: p + ((h == null ? void 0 : h.x) ?? 0), y: g + ((h == null ? void 0 : h.y) ?? 0), width: l, height: s, ...b, ...v }, f);
  }
}, UU = (e, t) => {
  var n;
  return !!(!e.viewModeEnabled && ((n = e.openDialog) == null ? void 0 : n.name) !== "elementLinkSelector" && (e.activeTool.type !== "custom" && (e.editingTextElement || e.activeTool.type !== "selection" && e.activeTool.type !== "eraser" && e.activeTool.type !== "hand" && e.activeTool.type !== "laser") || ct(t, e).length));
}, $le = (e) => {
  let t = 5381;
  for (let n = 0; n < e.length; n++) {
    let r = e.charCodeAt(n);
    t = (t << 5) + t + r;
  }
  return t >>> 0;
}, Fle = (e) => e.filter((t) => !t.isDeleted && !M0(t)), Jt = (e) => e.filter((t) => !t.isDeleted), T7 = (e) => !e.isDeleted, zle = (e) => Jt(e).map((t) => U8(t.type) ? { ...t, lastCommittedPoint: null } : t), cD = (e) => zle(e), dD = async (e) => {
  let t;
  if (e.type === $e.png) try {
    return await (await import("./image-7KUKJ7J4-BYoMfS0s.js")).decodePngMetadata(e);
  } catch (n) {
    throw n.message === "INVALID" ? new hc("Image doesn't contain scene", "IMAGE_NOT_CONTAINS_SCENE_DATA") : new hc("Error: cannot restore image");
  }
  else if ("text" in Blob ? t = await e.text() : t = await new Promise((n) => {
    let r = new FileReader();
    r.readAsText(e, "utf8"), r.onloadend = () => {
      r.readyState === FileReader.DONE && n(r.result);
    };
  }), e.type === $e.svg) try {
    return yae({ svg: t });
  } catch (n) {
    throw n.message === "INVALID" ? new hc("Image doesn't contain scene", "IMAGE_NOT_CONTAINS_SCENE_DATA") : new hc("Error: cannot restore image");
  }
  return t;
}, uD = (e) => {
  var t;
  return e && ((t = e.name.match(/\.(json|excalidraw|png|svg)$/)) == null ? void 0 : t[1]) || null;
}, Ble = (e) => e === "png" || e === "svg", vU = (e) => {
  let t = uD(e);
  return t === "png" || t === "svg";
}, hD = (e) => !!e && Object.values(p0).includes(e), Ec = (e) => {
  let { type: t } = e || {};
  return hD(t);
}, fD = async (e, t, n, r) => {
  let i = await dD(e), a;
  try {
    try {
      a = JSON.parse(i);
    } catch (l) {
      throw Ec(e) ? new hc("Image doesn't contain scene", "IMAGE_NOT_CONTAINS_SCENE_DATA") : l;
    }
    if (hae(a)) return { type: $e.excalidraw, data: g2({ elements: cD(a.elements || []), appState: { theme: t == null ? void 0 : t.theme, fileHandle: r || e.handle || null, ...DI(a.appState || {}), ...t ? ef(a.elements || [], t) : {} }, files: a.files }, t, n, { repairBindings: !0, refreshDimensions: !1 }) };
    if (kN(a)) return { type: $e.excalidrawlib, data: a };
    throw new Error("Error: invalid file");
  } catch (l) {
    throw l instanceof hc ? l : new Error("Error: invalid file");
  }
}, pD = async (e, t, n, r) => {
  let i = await fD(e, t, n, r);
  if (i.type !== $e.excalidraw) throw new Error("Error: invalid file");
  return i.data;
}, mD = (e, t = "unpublished") => {
  let n = JSON.parse(e);
  if (!kN(n)) throw new Error("Invalid library");
  let r = n.libraryItems || n.library;
  return rU(r, t);
}, Hle = async (e, t = "unpublished") => mD(await dD(e), t), sf = async (e) => new Promise(async (t, n) => {
  try {
    Hf(e) && (e = await e), e.toBlob((r) => {
      if (!r) return n(new cJ("Error: Canvas too big", "CANVAS_POSSIBLY_TOO_BIG"));
      t(r);
    });
  } catch (r) {
    n(r);
  }
}), Wle = async (e) => {
  try {
    let t = await window.crypto.subtle.digest("SHA-1", await pc(e));
    return KY(new Uint8Array(t));
  } catch (t) {
    return console.error(t), l8(40);
  }
}, _E = async (e) => new Promise((t, n) => {
  let r = new FileReader();
  r.onload = () => {
    let i = r.result;
    t(i);
  }, r.onerror = (i) => n(i), r.readAsDataURL(e);
}), Xle = (e, t) => `data:${t};base64,${UD(Wm(e), !0)}`, Vle = (e, t = "") => {
  let n = e.indexOf(","), r = atob(e.slice(n + 1)), i = e.slice(0, n).split(":")[1].split(";")[0], a = new ArrayBuffer(r.length), l = new Uint8Array(a);
  for (let s = 0; s < r.length; s++) l[s] = r.charCodeAt(s);
  return new File([a], t, { type: i });
}, Gle = (e) => vD(e.slice(e.indexOf(",") + 1)), I7 = async (e, t) => {
  if (e.type === $e.svg) return e;
  let [n, r] = await Promise.all([import("./pica-DeDQejbI.js").then((a) => a.p).then((a) => a.default), import("./image-blob-reduce.esm-BkjLmknz.js").then((a) => a.default)]), i = r({ pica: n({ features: ["js", "wasm"] }) });
  if (t.outputType) {
    let { outputType: a } = t;
    i._create_blob = function(l) {
      return this.pica.toBlob(l.out_canvas, a, 0.8).then((s) => (l.out_blob = s, l));
    };
  }
  if (!Ec(e)) throw new Error("Error: unsupported file type", { cause: "UNSUPPORTED" });
  return new File([await i.toBlob(e, { max: t.maxWidthOrHeight, alpha: !0 })], e.name, { type: t.outputType || e.type });
}, kE = (e, t = "") => new File([new TextEncoder().encode(e)], t, { type: $e.svg }), jle = async (e, t = "") => {
  let n;
  try {
    n = await fetch(e);
  } catch {
    throw new Error("Error: failed to fetch image", { cause: "FETCH_ERROR" });
  }
  if (!n.ok) throw new Error("Error: failed to fetch image", { cause: "FETCH_ERROR" });
  let r = await n.blob();
  if (r.type && Ec(r)) {
    let i = t || r.name || "";
    return new File([r], i, { type: r.type });
  }
  throw new Error("Error: unsupported file type", { cause: "UNSUPPORTED" });
}, Kle = async (e) => {
  let t = e.dataTransfer.files.item(0), n = await Yle(e);
  return { file: t ? await yU(t) : null, fileHandle: n };
}, Yle = async (e) => {
  if (od) try {
    return await e.dataTransfer.items[0].getAsFileSystemHandle() || null;
  } catch (t) {
    return console.warn(t.name, t.message), null;
  }
  return null;
}, CE = (e) => {
  let t = null, n = `${[...new Uint8Array(e).slice(0, 8)].join(" ")} `, r = { png: "137 80 78 71 13 10 26 10 ", jpg: "255 216 255 ", gif: "71 73 70 56 57 97 " };
  return n === r.png ? t = $e.png : n.startsWith(r.jpg) ? t = $e.jpg : n.startsWith(r.gif) && (t = $e.gif), t;
}, Zu = (e, t, n) => new File([e], n || "", { type: t }), yU = async (e) => {
  var t, n;
  if (e.type) {
    if (Ec(e)) {
      let r = await pc(e), i = CE(r);
      i && i !== e.type && (e = Zu(r, i, e.name));
    }
  } else if ((t = e == null ? void 0 : e.name) != null && t.endsWith(".excalidrawlib")) e = Zu(await pc(e), $e.excalidrawlib, e.name);
  else if ((n = e == null ? void 0 : e.name) != null && n.endsWith(".excalidraw")) e = Zu(await pc(e), $e.excalidraw, e.name);
  else {
    let r = await pc(e), i = CE(r);
    i && (e = Zu(r, i, e.name));
  }
  return e;
}, pc = (e) => "arrayBuffer" in e ? e.arrayBuffer() : new Promise((t, n) => {
  let r = new FileReader();
  r.onload = (i) => {
    var a;
    if (!((a = i.target) != null && a.result)) return n(new Error("Couldn't convert blob to ArrayBuffer"));
    t(i.target.result);
  }, r.readAsArrayBuffer(e);
}), Wm = (e) => {
  let t = typeof e == "string" ? new TextEncoder().encode(e) : e instanceof Uint8Array ? e : new Uint8Array(e), n = "";
  for (let r of t) n += String.fromCharCode(r);
  return n;
}, gD = (e) => {
  let t = new ArrayBuffer(e.length), n = new Uint8Array(t);
  for (let r = 0, i = e.length; r < i; r++) n[r] = e.charCodeAt(r);
  return t;
}, bD = (e) => new TextDecoder("utf-8").decode(gD(e)), UD = (e, t = !1) => t ? window.btoa(e) : window.btoa(Wm(e)), vD = (e, t = !1) => t ? window.atob(e) : bD(window.atob(e)), yD = ({ text: e, compress: t }) => {
  let n;
  if (t !== !1) try {
    n = Wm(VG(e));
  } catch (r) {
    console.error("encode: cannot deflate", r);
  }
  return { version: "1", encoding: "bstring", compressed: !!n, encoded: n || Wm(e) };
}, wD = (e) => {
  let t;
  switch (e.encoding) {
    case "bstring":
      t = e.compressed ? e.encoded : bD(e.encoded);
      break;
    default:
      throw new Error(`decode: unknown encoding "${e.encoding}"`);
  }
  return e.compressed ? GG(new Uint8Array(gD(t)), { to: "string" }) : t;
}, qle = async (e) => {
  let t = ST(new Uint8Array(await pc(e))).find((n) => n.name === "tEXt");
  return t ? Bg.decode(t.data) : null;
}, w4e = async ({ blob: e, metadata: t }) => {
  let n = ST(new Uint8Array(await pc(e))), r = Bg.encode($e.excalidraw, JSON.stringify(yD({ text: t, compress: !0 })));
  return n.splice(-1, 0, r), new Blob([fX(n)], { type: $e.png });
}, x4e = async (e) => {
  let t = await qle(e);
  if ((t == null ? void 0 : t.keyword) === $e.excalidraw) try {
    let n = JSON.parse(t.text);
    if (!("encoded" in n)) {
      if ("type" in n && n.type === ji.excalidraw) return t.text;
      throw new Error("FAILED");
    }
    return wD(n);
  } catch (n) {
    throw console.error(n), new Error("FAILED");
  }
  throw new Error("INVALID");
}, Zle = { paste: "Paste", pasteAsPlaintext: "Paste as plaintext", pasteCharts: "Paste charts", selectAll: "Select all", multiSelect: "Add element to selection", moveCanvas: "Move canvas", cut: "Cut", copy: "Copy", copyAsPng: "Copy to clipboard as PNG", copyAsSvg: "Copy to clipboard as SVG", copyText: "Copy to clipboard as text", copySource: "Copy source to clipboard", convertToCode: "Convert to code", bringForward: "Bring forward", sendToBack: "Send to back", bringToFront: "Bring to front", sendBackward: "Send backward", delete: "Delete", copyStyles: "Copy styles", pasteStyles: "Paste styles", stroke: "Stroke", changeStroke: "Change stroke color", background: "Background", changeBackground: "Change background color", fill: "Fill", strokeWidth: "Stroke width", strokeStyle: "Stroke style", strokeStyle_solid: "Solid", strokeStyle_dashed: "Dashed", strokeStyle_dotted: "Dotted", sloppiness: "Sloppiness", opacity: "Opacity", textAlign: "Text align", edges: "Edges", sharp: "Sharp", round: "Round", arrowheads: "Arrowheads", arrowhead_none: "None", arrowhead_arrow: "Arrow", arrowhead_bar: "Bar", arrowhead_circle: "Circle", arrowhead_circle_outline: "Circle (outline)", arrowhead_triangle: "Triangle", arrowhead_triangle_outline: "Triangle (outline)", arrowhead_diamond: "Diamond", arrowhead_diamond_outline: "Diamond (outline)", arrowhead_crowfoot_many: "Crow's foot (many)", arrowhead_crowfoot_one: "Crow's foot (one)", arrowhead_crowfoot_one_or_many: "Crow's foot (one or many)", more_options: "More options", arrowtypes: "Arrow type", arrowtype_sharp: "Sharp arrow", arrowtype_round: "Curved arrow", arrowtype_elbowed: "Elbow arrow", fontSize: "Font size", fontFamily: "Font family", addWatermark: 'Add "Made with Excalidraw"', handDrawn: "Hand-drawn", normal: "Normal", code: "Code", small: "Small", medium: "Medium", large: "Large", veryLarge: "Very large", solid: "Solid", hachure: "Hachure", zigzag: "Zigzag", crossHatch: "Cross-hatch", thin: "Thin", bold: "Bold", left: "Left", center: "Center", right: "Right", extraBold: "Extra bold", architect: "Architect", artist: "Artist", cartoonist: "Cartoonist", fileTitle: "File name", colorPicker: "Color picker", canvasColors: "Used on canvas", canvasBackground: "Canvas background", drawingCanvas: "Drawing canvas", clearCanvas: "Clear canvas", layers: "Layers", actions: "Actions", language: "Language", liveCollaboration: "Live collaboration...", duplicateSelection: "Duplicate", untitled: "Untitled", name: "Name", yourName: "Your name", madeWithExcalidraw: "Made with Excalidraw", group: "Group selection", ungroup: "Ungroup selection", collaborators: "Collaborators", toggleGrid: "Toggle grid", addToLibrary: "Add to library", removeFromLibrary: "Remove from library", libraryLoadingMessage: "Loading library…", libraries: "Browse libraries", loadingScene: "Loading scene…", loadScene: "Load scene from file", align: "Align", alignTop: "Align top", alignBottom: "Align bottom", alignLeft: "Align left", alignRight: "Align right", centerVertically: "Center vertically", centerHorizontally: "Center horizontally", distributeHorizontally: "Distribute horizontally", distributeVertically: "Distribute vertically", flipHorizontal: "Flip horizontal", flipVertical: "Flip vertical", viewMode: "View mode", share: "Share", showStroke: "Show stroke color picker", showBackground: "Show background color picker", showFonts: "Show font picker", toggleTheme: "Toggle light/dark theme", theme: "Theme", personalLib: "Personal Library", excalidrawLib: "Excalidraw Library", decreaseFontSize: "Decrease font size", increaseFontSize: "Increase font size", unbindText: "Unbind text", bindText: "Bind text to the container", createContainerFromText: "Wrap text in a container", link: { edit: "Edit link", editEmbed: "Edit embeddable link", create: "Add link", label: "Link", labelEmbed: "Link & embed", empty: "No link is set", hint: "Type or paste your link here", goToElement: "Go to target element" }, lineEditor: { edit: "Edit line", editArrow: "Edit arrow" }, elementLock: { lock: "Lock", unlock: "Unlock", lockAll: "Lock all", unlockAll: "Unlock all" }, statusPublished: "Published", sidebarLock: "Keep sidebar open", selectAllElementsInFrame: "Select all elements in frame", removeAllElementsFromFrame: "Remove all elements from frame", eyeDropper: "Pick color from canvas", textToDiagram: "Text to diagram", prompt: "Prompt", followUs: "Follow us", discordChat: "Discord chat", zoomToFitViewport: "Zoom to fit in viewport", zoomToFitSelection: "Zoom to fit selection", zoomToFit: "Zoom to fit all elements", installPWA: "Install Excalidraw locally (PWA)", autoResize: "Enable text auto-resizing", imageCropping: "Image cropping", unCroppedDimension: "Uncropped dimension", copyElementLink: "Copy link to object", linkToElement: "Link to object", wrapSelectionInFrame: "Wrap selection in frame" }, Jle = { title: "Link to object", desc: "Click on a shape on canvas or paste a link.", notFound: "Linked object wasn't found on canvas." }, Qle = { noItems: "No items added yet...", hint_emptyLibrary: "Select an item on canvas to add it here, or install a library from the public repository, below.", hint_emptyPrivateLibrary: "Select an item on canvas to add it here." }, ese = { title: "Find on canvas", noMatch: "No matches found...", singleResult: "result", multipleResults: "results", placeholder: "Find text on canvas..." }, tse = { clearReset: "Reset the canvas", exportJSON: "Export to file", exportImage: "Export image...", export: "Save to...", copyToClipboard: "Copy to clipboard", copyLink: "Copy link", save: "Save to current file", saveAs: "Save as", load: "Open", getShareableLink: "Get shareable link", close: "Close", selectLanguage: "Select language", scrollBackToContent: "Scroll back to content", zoomIn: "Zoom in", zoomOut: "Zoom out", resetZoom: "Reset zoom", menu: "Menu", done: "Done", edit: "Edit", undo: "Undo", redo: "Redo", resetLibrary: "Reset library", createNewRoom: "Create new room", fullScreen: "Full screen", darkMode: "Dark mode", lightMode: "Light mode", systemMode: "System mode", zenMode: "Zen mode", objectsSnapMode: "Snap to objects", exitZenMode: "Exit zen mode", cancel: "Cancel", clear: "Clear", remove: "Remove", embed: "Toggle embedding", publishLibrary: "Publish", submit: "Submit", confirm: "Confirm", embeddableInteractionButton: "Click to interact" }, nse = { clearReset: "This will clear the whole canvas. Are you sure?", couldNotCreateShareableLink: "Couldn't create shareable link.", couldNotCreateShareableLinkTooBig: "Couldn't create shareable link: the scene is too big", couldNotLoadInvalidFile: "Couldn't load invalid file", importBackendFailed: "Importing from backend failed.", cannotExportEmptyCanvas: "Cannot export empty canvas.", couldNotCopyToClipboard: "Couldn't copy to clipboard.", decryptFailed: "Couldn't decrypt data.", uploadedSecurly: "The upload has been secured with end-to-end encryption, which means that Excalidraw server and third parties can't read the content.", loadSceneOverridePrompt: "Loading external drawing will replace your existing content. Do you wish to continue?", collabStopOverridePrompt: `Stopping the session will overwrite your previous, locally stored drawing. Are you sure?

(If you want to keep your local drawing, simply close the browser tab instead.)`, errorAddingToLibrary: "Couldn't add item to the library", errorRemovingFromLibrary: "Couldn't remove item from the library", confirmAddLibrary: "This will add {{numShapes}} shape(s) to your library. Are you sure?", imageDoesNotContainScene: "This image does not seem to contain any scene data. Have you enabled scene embedding during export?", cannotRestoreFromImage: "Scene couldn't be restored from this image file", invalidSceneUrl: "Couldn't import scene from the supplied URL. It's either malformed, or doesn't contain valid Excalidraw JSON data.", resetLibrary: "This will clear your library. Are you sure?", removeItemsFromsLibrary: "Delete {{count}} item(s) from library?", invalidEncryptionKey: "Encryption key must be of 22 characters. Live collaboration is disabled.", collabOfflineWarning: `No internet connection available.
Your changes will not be saved!` }, rse = { unsupportedFileType: "Unsupported file type.", imageInsertError: "Couldn't insert image. Try again later...", fileTooBig: "File is too big. Maximum allowed size is {{maxSize}}.", svgImageInsertError: "Couldn't insert SVG image. The SVG markup looks invalid.", failedToFetchImage: "Failed to fetch image.", cannotResolveCollabServer: "Couldn't connect to the collab server. Please reload the page and try again.", importLibraryError: "Couldn't load library", saveLibraryError: "Couldn't save library to storage. Please save your library to a file locally to make sure you don't lose changes.", collabSaveFailed: "Couldn't save to the backend database. If problems persist, you should save your file locally to ensure you don't lose your work.", collabSaveFailed_sizeExceeded: "Couldn't save to the backend database, the canvas seems to be too big. You should save the file locally to ensure you don't lose your work.", imageToolNotSupported: "Images are disabled.", brave_measure_text_error: { line1: "Looks like you are using Brave browser with the <bold>Aggressively Block Fingerprinting</bold> setting enabled.", line2: "This could result in breaking the <bold>Text Elements</bold> in your drawings.", line3: "We strongly recommend disabling this setting. You can follow <link>these steps</link> on how to do so.", line4: "If disabling this setting doesn't fix the display of text elements, please open an <issueLink>issue</issueLink> on our GitHub, or write us on <discordLink>Discord</discordLink>" }, libraryElementTypeError: { embeddable: "Embeddable elements cannot be added to the library.", iframe: "IFrame elements cannot be added to the library.", image: "Support for adding images to the library coming soon!" }, asyncPasteFailedOnRead: "Couldn't paste (couldn't read from system clipboard).", asyncPasteFailedOnParse: "Couldn't paste.", copyToSystemClipboardFailed: "Couldn't copy to clipboard." }, ise = { selection: "Selection", image: "Insert image", rectangle: "Rectangle", diamond: "Diamond", ellipse: "Ellipse", arrow: "Arrow", line: "Line", freedraw: "Draw", text: "Text", library: "Library", lock: "Keep selected tool active after drawing", penMode: "Pen mode - prevent touch", link: "Add / Update link for a selected shape", eraser: "Eraser", frame: "Frame tool", magicframe: "Wireframe to code", embeddable: "Web Embed", laser: "Laser pointer", hand: "Hand (panning tool)", extraTools: "More tools", mermaidToExcalidraw: "Mermaid to Excalidraw" }, ase = { rectangle: "Rectangle", diamond: "Diamond", ellipse: "Ellipse", arrow: "Arrow", line: "Line", freedraw: "Freedraw", text: "Text", image: "Image", group: "Group", frame: "Frame", magicframe: "Wireframe to code", embeddable: "Web Embed", selection: "Selection", iframe: "IFrame" }, lse = { canvasActions: "Canvas actions", selectedShapeActions: "Selected shape actions", shapes: "Shapes" }, sse = { dismissSearch: "Escape to dismiss search", canvasPanning: "To move canvas, hold mouse wheel or spacebar while dragging, or use the hand tool", linearElement: "Click to start multiple points, drag for single line", arrowTool: "Click to start multiple points, drag for single line. Press {{arrowShortcut}} again to change arrow type.", freeDraw: "Click and drag, release when you're finished", text: "Tip: you can also add text by double-clicking anywhere with the selection tool", embeddable: "Click-drag to create a website embed", text_selected: "Double-click or press ENTER to edit text", text_editing: "Press Escape or CtrlOrCmd+ENTER to finish editing", linearElementMulti: "Click on last point or press Escape or Enter to finish", lockAngle: "You can constrain angle by holding SHIFT", resize: `You can constrain proportions by holding SHIFT while resizing,
hold ALT to resize from the center`, resizeImage: `You can resize freely by holding SHIFT,
hold ALT to resize from the center`, rotate: "You can constrain angles by holding SHIFT while rotating", lineEditor_info: "Hold CtrlOrCmd and Double-click or press CtrlOrCmd + Enter to edit points", lineEditor_pointSelected: `Press Delete to remove point(s),
CtrlOrCmd+D to duplicate, or drag to move`, lineEditor_nothingSelected: `Select a point to edit (hold SHIFT to select multiple),
or hold Alt and click to add new points`, placeImage: "Click to place the image, or click and drag to set its size manually", publishLibrary: "Publish your own library", bindTextToElement: "Press enter to add text", createFlowchart: "Hold CtrlOrCmd and Arrow key to create a flowchart", deepBoxSelect: "Hold CtrlOrCmd to deep select, and to prevent dragging", eraserRevert: "Hold Alt to revert the elements marked for deletion", firefox_clipboard_write: 'This feature can likely be enabled by setting the "dom.events.asyncClipboard.clipboardItem" flag to "true". To change the browser flags in Firefox, visit the "about:config" page.', disableSnapping: "Hold CtrlOrCmd to disable snapping", enterCropEditor: "Double click the image or press ENTER to crop the image", leaveCropEditor: "Click outside the image or press ENTER or ESCAPE to finish cropping" }, ose = { cannotShowPreview: "Cannot show preview", canvasTooBig: "The canvas may be too big.", canvasTooBigTip: "Tip: try moving the farthest elements a bit closer together." }, cse = { headingMain: "Encountered an error. Try <button>reloading the page</button>.", clearCanvasMessage: "If reloading doesn't work, try <button>clearing the canvas</button>.", clearCanvasCaveat: " This will result in loss of work ", trackedToSentry: "The error with identifier {{eventId}} was tracked on our system.", openIssueMessage: "We were very cautious not to include your scene information on the error. If your scene is not private, please consider following up on our <button>bug tracker</button>. Please include information below by copying and pasting into the GitHub issue.", sceneContent: "Scene content:" }, dse = { or: "Or" }, use = { desc_intro: "Invite people to collaborate on your drawing.", desc_privacy: "Don't worry, the session is end-to-end encrypted, and fully private. Not even our server can see what you draw.", button_startSession: "Start session", button_stopSession: "Stop session", desc_inProgressIntro: "Live-collaboration session is now in progress.", desc_shareLink: "Share this link with anyone you want to collaborate with:", desc_exitSession: "Stopping the session will disconnect you from the room, but you'll be able to continue working with the scene, locally. Note that this won't affect other people, and they'll still be able to collaborate on their version.", shareTitle: "Join a live collaboration session on Excalidraw" }, hse = { title: "Error" }, fse = { disk_title: "Save to disk", disk_details: "Export the scene data to a file from which you can import later.", disk_button: "Save to file", link_title: "Shareable link", link_details: "Export as a read-only link.", link_button: "Export to Link", excalidrawplus_description: "Save the scene to your Excalidraw+ workspace.", excalidrawplus_button: "Export", excalidrawplus_exportError: "Couldn't export to Excalidraw+ at this moment..." }, pse = { blog: "Read our blog", click: "click", deepSelect: "Deep select", deepBoxSelect: "Deep select within box, and prevent dragging", createFlowchart: "Create a flowchart from a generic element", navigateFlowchart: "Navigate a flowchart", curvedArrow: "Curved arrow", curvedLine: "Curved line", documentation: "Documentation", doubleClick: "double-click", drag: "drag", editor: "Editor", editLineArrowPoints: "Edit line/arrow points", editText: "Edit text / add label", github: "Found an issue? Submit", howto: "Follow our guides", or: "or", preventBinding: "Prevent arrow binding", tools: "Tools", shortcuts: "Keyboard shortcuts", textFinish: "Finish editing (text editor)", textNewLine: "Add new line (text editor)", title: "Help", view: "View", zoomToFit: "Zoom to fit all elements", zoomToSelection: "Zoom to selection", toggleElementLock: "Lock/unlock selection", movePageUpDown: "Move page up/down", movePageLeftRight: "Move page left/right", cropStart: "Crop image", cropFinish: "Finish image cropping" }, mse = { title: "Clear canvas" }, gse = { title: "Publish library", itemName: "Item name", authorName: "Author name", githubUsername: "GitHub username", twitterUsername: "Twitter username", libraryName: "Library name", libraryDesc: "Library description", website: "Website", placeholder: { authorName: "Your name or username", libraryName: "Name of your library", libraryDesc: "Description of your library to help people understand its usage", githubHandle: "GitHub handle (optional), so you can edit the library once submitted for review", twitterHandle: "Twitter username (optional), so we know who to credit when promoting over Twitter", website: "Link to your personal website or elsewhere (optional)" }, errors: { required: "Required", website: "Enter a valid URL" }, noteDescription: "Submit your library to be included in the <link>public library repository</link> for other people to use in their drawings.", noteGuidelines: "The library needs to be manually approved first. Please read the <link>guidelines</link> before submitting. You will need a GitHub account to communicate and make changes if requested, but it is not strictly required.", noteLicense: "By submitting, you agree the library will be published under the <link>MIT License</link>, which in short means anyone can use them without restrictions.", noteItems: "Each library item must have its own name so it's filterable. The following library items will be included:", atleastOneLibItem: "Please select at least one library item to get started", republishWarning: "Note: some of the selected items are marked as already published/submitted. You should only resubmit items when updating an existing library or submission." }, bse = { title: "Library submitted", content: "Thank you {{authorName}}. Your library has been submitted for review. You can track the status <link>here</link>" }, Use = { resetLibrary: "Reset library", removeItemsFromLib: "Remove selected items from library" }, vse = { header: "Export image", label: { withBackground: "Background", onlySelected: "Only selected", darkMode: "Dark mode", embedScene: "Embed scene", scale: "Scale", padding: "Padding" }, tooltip: { embedScene: `Scene data will be saved into the exported PNG/SVG file so that the scene can be restored from it.
Will increase exported file size.` }, title: { exportToPng: "Export to PNG", exportToSvg: "Export to SVG", copyPngToClipboard: "Copy PNG to clipboard" }, button: { exportToPng: "PNG", exportToSvg: "SVG", copyPngToClipboard: "Copy to clipboard" } }, yse = { tooltip: "Your drawings are end-to-end encrypted so Excalidraw's servers will never see them.", link: "Blog post on end-to-end encryption in Excalidraw" }, wse = { angle: "Angle", shapes: "Shapes", height: "Height", scene: "Scene", selected: "Selected", storage: "Storage", fullTitle: "Canvas & Shape properties", title: "Properties", generalStats: "General", elementProperties: "Shape properties", total: "Total", version: "Version", versionCopy: "Click to copy", versionNotAvailable: "Version not available", width: "Width" }, xse = { addedToLibrary: "Added to library", copyStyles: "Copied styles.", copyToClipboard: "Copied to clipboard.", copyToClipboardAsPng: `Copied {{exportSelection}} to clipboard as PNG
({{exportColorScheme}})`, copyToClipboardAsSvg: `Copied {{exportSelection}} to clipboard as SVG
({{exportColorScheme}})`, fileSaved: "File saved.", fileSavedToFilename: "Saved to {filename}", canvas: "canvas", selection: "selection", pasteAsSingleElement: `Use {{shortcut}} to paste as a single element,
or paste into an existing text editor`, unableToEmbed: "Embedding this url is currently not allowed. Raise an issue on GitHub to request the url whitelisted", unrecognizedLinkFormat: "The link you embedded does not match the expected format. Please try to paste the 'embed' string provided by the source site", elementLinkCopied: "Link copied to clipboard" }, Ese = { transparent: "Transparent", black: "Black", white: "White", red: "Red", pink: "Pink", grape: "Grape", violet: "Violet", gray: "Gray", blue: "Blue", cyan: "Cyan", teal: "Teal", green: "Green", yellow: "Yellow", orange: "Orange", bronze: "Bronze" }, Sse = { app: { center_heading: "All your data is saved locally in your browser.", center_heading_plus: "Did you want to go to the Excalidraw+ instead?", menuHint: "Export, preferences, languages, ..." }, defaults: { menuHint: "Export, preferences, and more...", center_heading: "Diagrams. Made. Simple.", toolbarHint: "Pick a tool & Start drawing!", helpHint: "Shortcuts & help" } }, _se = { mostUsedCustomColors: "Most used custom colors", colors: "Colors", shades: "Shades", hexCode: "Hex code", noShades: "No shades available for this color" }, kse = { action: { exportToImage: { title: "Export as image", button: "Export as image", description: "Export the scene data as an image from which you can import later." }, saveToDisk: { title: "Save to disk", button: "Save to disk", description: "Export the scene data to a file from which you can import later." }, excalidrawPlus: { title: "Excalidraw+", button: "Export to Excalidraw+", description: "Save the scene to your Excalidraw+ workspace." } }, modal: { loadFromFile: { title: "Load from file", button: "Load from file", description: "Loading from a file will <bold>replace your existing content</bold>.<br></br>You can back up your drawing first using one of the options below." }, shareableLink: { title: "Load from link", button: "Replace my content", description: "Loading external drawing will <bold>replace your existing content</bold>.<br></br>You can back up your drawing first by using one of the options below." } } }, Cse = { title: "Mermaid to Excalidraw", button: "Insert", description: "Currently only <flowchartLink>Flowchart</flowchartLink>,<sequenceLink> Sequence, </sequenceLink> and <classLink>Class </classLink>Diagrams are supported. The other types will be rendered as image in Excalidraw.", syntax: "Mermaid Syntax", preview: "Preview" }, Mse = { placeholder: "Quick search" }, Tse = { badge: { old: "old" }, sceneFonts: "In this scene", availableFonts: "Available fonts", empty: "No fonts found" }, Ise = { empty: "No users found", hint: { text: "Click on user to follow", followStatus: "You're currently following this user", inCall: "User is in a voice call", micMuted: "User's microphone is muted", isSpeaking: "User is speaking" } }, Ase = { title: "Command palette", shortcuts: { select: "Select", confirm: "Confirm", close: "Close" }, recents: "Recently used", search: { placeholder: "Search menus, commands, and discover hidden gems", noMatch: "No matching commands..." }, itemNotAvailable: "Command is not available...", shortcutHint: "For Command palette, use {{shortcut}}" }, xD = { labels: Zle, elementLink: Jle, library: Qle, search: ese, buttons: tse, alerts: nse, errors: rse, toolBar: ise, element: ase, headings: lse, hints: sse, canvasError: ose, errorSplash: cse, shareDialog: dse, roomDialog: use, errorDialog: hse, exportDialog: fse, helpDialog: pse, clearCanvasDialog: mse, publishDialog: gse, publishSuccessDialog: bse, confirmDialog: Use, imageExportDialog: vse, encrypted: yse, stats: wse, toast: xse, colors: Ese, welcomeScreen: Sse, colorPicker: _se, overwriteConfirm: kse, mermaid: Cse, quickSearch: Mse, fontList: Tse, userList: Ise, commandPalette: Ase }, Nse = 100, Dse = 36, Lse = { "ar-SA": 94, "az-AZ": 17, "bg-BG": 71, "bn-BD": 52, "ca-ES": 83, "cs-CZ": 86, "da-DK": 61, "de-DE": 100, "el-GR": 80, en: Nse, "es-ES": 96, "eu-ES": 97, "fa-IR": 84, "fi-FI": 76, "fr-FR": 99, "gl-ES": 86, "he-IL": 77, "hi-IN": 76, "hu-HU": 76, "id-ID": 91, "it-IT": 98, "ja-JP": 90, kaa: Dse, "kab-KAB": 76, "kk-KZ": 18, "km-KH": 83, "ko-KR": 100, "ku-TR": 87, "lt-LT": 48, "lv-LV": 77, "mr-IN": 98, "my-MM": 35, "nb-NO": 93, "nl-NL": 75, "nn-NO": 67, "oc-FR": 92, "pa-IN": 78, "pl-PL": 99, "pt-BR": 91, "pt-PT": 83, "ro-RO": 99, "ru-RU": 92, "si-LK": 7, "sk-SK": 100, "sl-SI": 100, "sv-SE": 100, "ta-IN": 81, "th-TH": 44, "tr-TR": 87, "uk-UA": 93, "vi-VN": 49, "zh-CN": 100, "zh-HK": 22, "zh-TW": 100 };
const Ss = {};
let Rse = 0;
function Sr(e, t) {
  const n = `atom${++Rse}`, r = {
    toString() {
      return (Ss ? "production" : void 0) !== "production" && this.debugLabel ? n + ":" + this.debugLabel : n;
    }
  };
  return typeof e == "function" ? r.read = e : (r.init = e, r.read = Pse, r.write = Ose), r;
}
function Pse(e) {
  return e(this);
}
function Ose(e, t, n) {
  return t(
    this,
    typeof n == "function" ? n(e(this)) : n
  );
}
const ME = (e, t) => e.unstable_is ? e.unstable_is(t) : t === e, A7 = (e) => "init" in e, a5 = (e) => !!e.write, Xm = /* @__PURE__ */ new WeakMap(), N7 = (e) => {
  var t;
  return D7(e) && !((t = Xm.get(e)) != null && t[1]);
}, $se = (e, t) => {
  const n = Xm.get(e);
  if (n)
    n[1] = !0, n[0].forEach((r) => r(t));
  else if ((Ss ? "production" : void 0) !== "production")
    throw new Error("[Bug] cancelable promise not found");
}, Fse = (e) => {
  if (Xm.has(e))
    return;
  const t = [/* @__PURE__ */ new Set(), !1];
  Xm.set(e, t);
  const n = () => {
    t[1] = !0;
  };
  e.then(n, n), e.onCancel = (r) => {
    t[0].add(r);
  };
}, D7 = (e) => typeof (e == null ? void 0 : e.then) == "function", TE = (e) => "v" in e || "e" in e, $1 = (e) => {
  if ("e" in e)
    throw e.e;
  if ((Ss ? "production" : void 0) !== "production" && !("v" in e))
    throw new Error("[Bug] atom state is not initialized");
  return e.v;
}, ED = (e, t, n) => {
  n.p.has(e) || (n.p.add(e), t.then(
    () => {
      n.p.delete(e);
    },
    () => {
      n.p.delete(e);
    }
  ));
}, IE = (e, t, n, r, i) => {
  var a;
  if ((Ss ? "production" : void 0) !== "production" && r === t)
    throw new Error("[Bug] atom cannot depend on itself");
  n.d.set(r, i.n), N7(n.v) && ED(t, n.v, i), (a = i.m) == null || a.t.add(t), e && zse(e, r, t);
}, ku = () => ({
  D: /* @__PURE__ */ new Map(),
  H: /* @__PURE__ */ new Set(),
  M: /* @__PURE__ */ new Set(),
  L: /* @__PURE__ */ new Set()
}), xh = (e, t, n) => {
  e[t].add(n);
}, AE = (e, t, n) => {
  e.D.has(t) || (e.D.set(t, /* @__PURE__ */ new Set()), xh(e, "M", () => {
    var r;
    (r = n.m) == null || r.l.forEach((i) => xh(e, "M", i));
  }));
}, zse = (e, t, n) => {
  const r = e.D.get(t);
  r && r.add(n);
}, Bse = (e, t) => e.D.get(t), jo = (e) => {
  let t, n = !1;
  const r = (i) => {
    try {
      i();
    } catch (a) {
      n || (t = a, n = !0);
    }
  };
  for (; e.H.size || e.M.size || e.L.size; )
    e.D.clear(), e.H.forEach(r), e.H.clear(), e.M.forEach(r), e.M.clear(), e.L.forEach(r), e.L.clear();
  if (n)
    throw t;
}, SD = (...[e, t, n, r]) => {
  const i = (v, U, y) => {
    const w = "v" in U, x = U.v, E = N7(U.v) ? U.v : null;
    if (D7(y)) {
      Fse(y);
      for (const S of U.d.keys())
        ED(v, y, e(S));
      U.v = y;
    } else
      U.v = y;
    delete U.e, delete U.x, (!w || !Object.is(x, U.v)) && (++U.n, E && $se(E, y));
  }, a = (v, U) => {
    var y;
    const w = e(U);
    if (TE(w) && (w.m && !w.x || Array.from(w.d).every(
      ([M, A]) => (
        // Recursively, read the atom state of the dependency, and
        // check if the atom epoch number is unchanged
        a(v, M).n === A
      )
    )))
      return w;
    w.d.clear();
    let x = !0;
    const E = (M) => {
      if (ME(U, M)) {
        const L = e(M);
        if (!TE(L))
          if (A7(M))
            i(M, L, M.init);
          else
            throw new Error("no atom init");
        return $1(L);
      }
      const A = a(v, M);
      try {
        return $1(A);
      } finally {
        if (x)
          IE(v, U, w, M, A);
        else {
          const L = ku();
          IE(L, U, w, M, A), u(L, U, w), jo(L);
        }
      }
    };
    let S, _;
    const k = {
      get signal() {
        return S || (S = new AbortController()), S.signal;
      },
      get setSelf() {
        return (Ss ? "production" : void 0) !== "production" && !a5(U) && console.warn("setSelf function cannot be used with read-only atom"), !_ && a5(U) && (_ = (...M) => {
          if ((Ss ? "production" : void 0) !== "production" && x && console.warn("setSelf function cannot be called in sync"), !x)
            return o(U, ...M);
        }), _;
      }
    };
    try {
      const M = t(U, E, k);
      if (i(U, w, M), D7(M)) {
        (y = M.onCancel) == null || y.call(M, () => S == null ? void 0 : S.abort());
        const A = () => {
          if (w.m) {
            const L = ku();
            u(L, U, w), jo(L);
          }
        };
        M.then(A, A);
      }
      return w;
    } catch (M) {
      return delete w.v, w.e = M, delete w.x, ++w.n, w;
    } finally {
      x = !1;
    }
  }, l = (v) => $1(a(void 0, v)), s = (v, U, y) => {
    var w, x;
    const E = /* @__PURE__ */ new Map();
    for (const S of ((w = y.m) == null ? void 0 : w.t) || []) {
      const _ = e(S);
      _.m && E.set(S, _);
    }
    for (const S of y.p)
      E.set(
        S,
        e(S)
      );
    return (x = Bse(v, U)) == null || x.forEach((S) => {
      E.set(S, e(S));
    }), E;
  }, c = (v, U, y) => {
    const w = [], x = /* @__PURE__ */ new Set(), E = /* @__PURE__ */ new Set(), S = [[U, y]];
    for (; S.length > 0; ) {
      const [_, k] = S[S.length - 1];
      if (E.has(_)) {
        S.pop();
        continue;
      }
      if (x.has(_)) {
        w.push([_, k, k.n]), E.add(_), k.x = !0, S.pop();
        continue;
      }
      x.add(_);
      for (const [M, A] of s(v, _, k))
        _ !== M && !x.has(M) && S.push([M, A]);
    }
    xh(v, "H", () => {
      const _ = /* @__PURE__ */ new Set([U]);
      for (let k = w.length - 1; k >= 0; --k) {
        const [M, A, L] = w[k];
        let R = !1;
        for (const z of A.d.keys())
          if (z !== M && _.has(z)) {
            R = !0;
            break;
          }
        R && (a(v, M), u(v, M, A), L !== A.n && (AE(v, M, A), _.add(M))), delete A.x;
      }
    });
  }, d = (v, U, ...y) => {
    let w = !0;
    const x = (S) => $1(a(v, S)), E = (S, ..._) => {
      const k = e(S);
      try {
        if (ME(U, S)) {
          if (!A7(S))
            throw new Error("atom not writable");
          const M = k.n, A = _[0];
          i(S, k, A), u(v, S, k), M !== k.n && (AE(v, S, k), c(v, S, k));
          return;
        } else
          return d(v, S, ..._);
      } finally {
        w || jo(v);
      }
    };
    try {
      return n(U, x, E, ...y);
    } finally {
      w = !1;
    }
  }, o = (v, ...U) => {
    const y = ku();
    try {
      return d(y, v, ...U);
    } finally {
      jo(y);
    }
  }, u = (v, U, y) => {
    if (y.m && !N7(y.v)) {
      for (const w of y.d.keys())
        y.m.d.has(w) || (h(v, w, e(w)).t.add(U), y.m.d.add(w));
      for (const w of y.m.d || [])
        if (!y.d.has(w)) {
          y.m.d.delete(w);
          const x = f(v, w, e(w));
          x == null || x.t.delete(U);
        }
    }
  }, h = (v, U, y) => {
    if (!y.m) {
      a(v, U);
      for (const w of y.d.keys())
        h(v, w, e(w)).t.add(U);
      if (y.m = {
        l: /* @__PURE__ */ new Set(),
        d: new Set(y.d.keys()),
        t: /* @__PURE__ */ new Set()
      }, a5(U)) {
        const w = y.m;
        let x;
        const E = (S, _) => {
          let k = !0;
          x = (...M) => {
            try {
              return d(S, U, ...M);
            } finally {
              k || jo(S);
            }
          };
          try {
            return _();
          } finally {
            k = !1;
          }
        };
        xh(v, "L", () => {
          const S = E(
            v,
            () => r(U, (..._) => x(..._))
          );
          S && (w.u = (_) => E(_, S));
        });
      }
    }
    return y.m;
  }, f = (v, U, y) => {
    if (y.m && !y.m.l.size && !Array.from(y.m.t).some((w) => {
      var x;
      return (x = e(w).m) == null ? void 0 : x.d.has(U);
    })) {
      const w = y.m.u;
      w && xh(v, "L", () => w(v)), delete y.m;
      for (const x of y.d.keys()) {
        const E = f(v, x, e(x));
        E == null || E.t.delete(U);
      }
      return;
    }
    return y.m;
  };
  return {
    get: l,
    set: o,
    sub: (v, U) => {
      const y = ku(), w = e(v), E = h(y, v, w).l;
      return E.add(U), jo(y), () => {
        E.delete(U);
        const S = ku();
        f(S, v, w), jo(S);
      };
    },
    unstable_derive: (v) => SD(...v(e, t, n, r))
  };
}, Hse = (e) => {
  const t = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new Set();
  let r, i = 0;
  const a = e.unstable_derive(
    (c, d, o, u) => (r = c, [
      (h) => {
        let f = t.get(h);
        if (!f) {
          const p = c(h);
          f = new Proxy(p, {
            set(g, b, v) {
              return b === "m" && n.add(h), Reflect.set(g, b, v);
            },
            deleteProperty(g, b) {
              return b === "m" && n.delete(h), Reflect.deleteProperty(g, b);
            }
          }), t.set(h, f);
        }
        return f;
      },
      d,
      (h, f, p, ...g) => i ? p(h, ...g) : o(h, f, p, ...g),
      u
    ])
  ), l = a.set;
  return Object.assign(a, {
    // store dev methods (these are tentative and subject to change without notice)
    dev4_get_internal_weak_map: () => ({
      get: (c) => {
        const d = r(c);
        if (d.n !== 0)
          return d;
      }
    }),
    dev4_get_mounted_atoms: () => n,
    dev4_restore_atoms: (c) => {
      l({
        read: () => null,
        write: (o, u) => {
          ++i;
          try {
            for (const [h, f] of c)
              A7(h) && u(h, f);
          } finally {
            --i;
          }
        }
      });
    }
  });
}, wU = () => {
  const e = /* @__PURE__ */ new WeakMap(), n = SD(
    (r) => {
      if ((Ss ? "production" : void 0) !== "production" && !r)
        throw new Error("Atom is undefined or null");
      let i = e.get(r);
      return i || (i = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 }, e.set(r, i)), i;
    },
    (r, ...i) => r.read(...i),
    (r, ...i) => r.write(...i),
    (r, ...i) => {
      var a;
      return (a = r.onMount) == null ? void 0 : a.call(r, ...i);
    }
  );
  return (Ss ? "production" : void 0) !== "production" ? Hse(n) : n;
};
let Cu;
const Wse = () => (Cu || (Cu = wU(), (Ss ? "production" : void 0) !== "production" && (globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = Cu), globalThis.__JOTAI_DEFAULT_STORE__ !== Cu && console.warn(
  "Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"
))), Cu), _D = {}, Xse = Ci(
  void 0
), y2 = (e) => {
  const t = Er(Xse);
  return (e == null ? void 0 : e.store) || t || Wse();
}, L7 = (e) => typeof (e == null ? void 0 : e.then) == "function", kD = (e) => {
  e.status = "pending", e.then(
    (t) => {
      e.status = "fulfilled", e.value = t;
    },
    (t) => {
      e.status = "rejected", e.reason = t;
    }
  );
}, Vse = pe.use || ((e) => {
  if (e.status === "pending")
    throw e;
  if (e.status === "fulfilled")
    return e.value;
  throw e.status === "rejected" ? e.reason : (kD(e), e);
}), l5 = /* @__PURE__ */ new WeakMap(), NE = (e) => {
  let t = l5.get(e);
  return t || (t = new Promise((n, r) => {
    let i = e;
    const a = (c) => (d) => {
      i === c && n(d);
    }, l = (c) => (d) => {
      i === c && r(d);
    }, s = (c) => {
      "onCancel" in c && typeof c.onCancel == "function" && c.onCancel((d) => {
        if ((_D ? "production" : void 0) !== "production" && d === c)
          throw new Error("[Bug] p is not updated even after cancelation");
        L7(d) ? (l5.set(d, t), i = d, d.then(a(d), l(d)), s(d)) : n(d);
      });
    };
    e.then(a(e), l(e)), s(e);
  }), l5.set(e, t)), t;
};
function CD(e, t) {
  const n = y2(t), [[r, i, a], l] = lk(
    (d) => {
      const o = n.get(e);
      return Object.is(d[0], o) && d[1] === n && d[2] === e ? d : [o, n, e];
    },
    void 0,
    () => [n.get(e), n, e]
  );
  let s = r;
  (i !== n || a !== e) && (l(), s = n.get(e));
  const c = t == null ? void 0 : t.delay;
  if (Y(() => {
    const d = n.sub(e, () => {
      if (typeof c == "number") {
        const o = n.get(e);
        L7(o) && kD(NE(o)), setTimeout(l, c);
        return;
      }
      l();
    });
    return l(), d;
  }, [n, e, c]), MO(s), L7(s)) {
    const d = NE(s);
    return Vse(d);
  }
  return s;
}
function MD(e, t) {
  const n = y2(t);
  return he(
    (...i) => {
      if ((_D ? "production" : void 0) !== "production" && !("write" in e))
        throw new Error("not writable atom");
      return n.set(e, ...i);
    },
    [n, e]
  );
}
function Gse(e, t) {
  return [
    CD(e, t),
    // We do wrong type assertion here, which results in throwing an error.
    MD(e, t)
  ];
}
const DE = /* @__PURE__ */ new WeakMap();
function jse(e, t) {
  const n = y2(t), r = Kse(n);
  for (const [i, a] of e)
    (!r.has(i) || t != null && t.dangerouslyForceHydrate) && (r.add(i), n.set(i, a));
}
const Kse = (e) => {
  let t = DE.get(e);
  return t || (t = /* @__PURE__ */ new WeakSet(), DE.set(e, t)), t;
};
function Xd() {
  return Xd = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Xd.apply(this, arguments);
}
function TD() {
  const e = Ci(null);
  function t({
    store: l,
    initialValues: s = [],
    children: c
  }) {
    const d = de(l);
    return d.current || (d.current = wU()), jse(s, {
      store: d.current
    }), m(e.Provider, {
      value: d.current,
      children: c
    });
  }
  const n = (l) => {
    const s = Er(e);
    if (!s) throw new Error("Missing Provider from createIsolation");
    return y2(Xd({
      store: s
    }, l));
  };
  return {
    Provider: t,
    useStore: n,
    useAtom: (l, s) => {
      const c = n();
      return Gse(l, Xd({
        store: c
      }, s));
    },
    useAtomValue: (l, s) => {
      const c = n();
      return CD(l, Xd({
        store: c
      }, s));
    },
    useSetAtom: (l, s) => {
      const c = n();
      return MD(l, Xd({
        store: c
      }, s));
    }
  };
}
process.env.NODE_ENV;
const {
  read: E4e,
  write: S4e
} = Sr(null);
Ci({
  scope: void 0,
  baseStore: void 0
});
function go(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e == null || e(i), n === !1 || !i.defaultPrevented)
      return t == null ? void 0 : t(i);
  };
}
function LE(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function ID(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((i) => {
      const a = LE(i, t);
      return !n && typeof a == "function" && (n = !0), a;
    });
    if (n)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const a = r[i];
          typeof a == "function" ? a() : LE(e[i], null);
        }
      };
  };
}
function Fo(...e) {
  return J.useCallback(ID(...e), e);
}
function AD(e, t = []) {
  let n = [];
  function r(a, l) {
    const s = J.createContext(l), c = n.length;
    n = [...n, l];
    const d = (u) => {
      var v;
      const { scope: h, children: f, ...p } = u, g = ((v = h == null ? void 0 : h[e]) == null ? void 0 : v[c]) || s, b = J.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ m(g.Provider, { value: b, children: f });
    };
    d.displayName = a + "Provider";
    function o(u, h) {
      var g;
      const f = ((g = h == null ? void 0 : h[e]) == null ? void 0 : g[c]) || s, p = J.useContext(f);
      if (p) return p;
      if (l !== void 0) return l;
      throw new Error(`\`${u}\` must be used within \`${a}\``);
    }
    return [d, o];
  }
  const i = () => {
    const a = n.map((l) => J.createContext(l));
    return function(s) {
      const c = (s == null ? void 0 : s[e]) || a;
      return J.useMemo(
        () => ({ [`__scope${e}`]: { ...s, [e]: c } }),
        [s, c]
      );
    };
  };
  return i.scopeName = e, [r, Yse(i, ...t)];
}
function Yse(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(a) {
      const l = r.reduce((s, { useScope: c, scopeName: d }) => {
        const u = c(a)[`__scope${d}`];
        return { ...s, ...u };
      }, {});
      return J.useMemo(() => ({ [`__scope${t.scopeName}`]: l }), [l]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
var xU = J.forwardRef((e, t) => {
  const { children: n, ...r } = e, i = J.Children.toArray(n), a = i.find(Zse);
  if (a) {
    const l = a.props.children, s = i.map((c) => c === a ? J.Children.count(l) > 1 ? J.Children.only(null) : J.isValidElement(l) ? l.props.children : null : c);
    return /* @__PURE__ */ m(R7, { ...r, ref: t, children: J.isValidElement(l) ? J.cloneElement(l, void 0, s) : null });
  }
  return /* @__PURE__ */ m(R7, { ...r, ref: t, children: n });
});
xU.displayName = "Slot";
var R7 = J.forwardRef((e, t) => {
  const { children: n, ...r } = e;
  if (J.isValidElement(n)) {
    const i = Qse(n), a = Jse(r, n.props);
    return n.type !== J.Fragment && (a.ref = t ? ID(t, i) : i), J.cloneElement(n, a);
  }
  return J.Children.count(n) > 1 ? J.Children.only(null) : null;
});
R7.displayName = "SlotClone";
var qse = ({ children: e }) => /* @__PURE__ */ m(ge, { children: e });
function Zse(e) {
  return J.isValidElement(e) && e.type === qse;
}
function Jse(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? i && a ? n[r] = (...s) => {
      a(...s), i(...s);
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...a } : r === "className" && (n[r] = [i, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function Qse(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var eoe = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], As = eoe.reduce((e, t) => {
  const n = J.forwardRef((r, i) => {
    const { asChild: a, ...l } = r, s = a ? xU : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m(s, { ...l, ref: i });
  });
  return n.displayName = `Primitive.${t}`, { ...e, [t]: n };
}, {});
function toe(e, t) {
  e && _c.flushSync(() => e.dispatchEvent(t));
}
function Co(e) {
  const t = J.useRef(e);
  return J.useEffect(() => {
    t.current = e;
  }), J.useMemo(() => (...n) => {
    var r;
    return (r = t.current) == null ? void 0 : r.call(t, ...n);
  }, []);
}
function noe(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Co(e);
  J.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var roe = "DismissableLayer", P7 = "dismissableLayer.update", ioe = "dismissableLayer.pointerDownOutside", aoe = "dismissableLayer.focusOutside", RE, ND = J.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), DD = J.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: i,
      onFocusOutside: a,
      onInteractOutside: l,
      onDismiss: s,
      ...c
    } = e, d = J.useContext(ND), [o, u] = J.useState(null), h = (o == null ? void 0 : o.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, f] = J.useState({}), p = Fo(t, (S) => u(S)), g = Array.from(d.layers), [b] = [...d.layersWithOutsidePointerEventsDisabled].slice(-1), v = g.indexOf(b), U = o ? g.indexOf(o) : -1, y = d.layersWithOutsidePointerEventsDisabled.size > 0, w = U >= v, x = ooe((S) => {
      const _ = S.target, k = [...d.branches].some((M) => M.contains(_));
      !w || k || (i == null || i(S), l == null || l(S), S.defaultPrevented || s == null || s());
    }, h), E = coe((S) => {
      const _ = S.target;
      [...d.branches].some((M) => M.contains(_)) || (a == null || a(S), l == null || l(S), S.defaultPrevented || s == null || s());
    }, h);
    return noe((S) => {
      U === d.layers.size - 1 && (r == null || r(S), !S.defaultPrevented && s && (S.preventDefault(), s()));
    }, h), J.useEffect(() => {
      if (o)
        return n && (d.layersWithOutsidePointerEventsDisabled.size === 0 && (RE = h.body.style.pointerEvents, h.body.style.pointerEvents = "none"), d.layersWithOutsidePointerEventsDisabled.add(o)), d.layers.add(o), PE(), () => {
          n && d.layersWithOutsidePointerEventsDisabled.size === 1 && (h.body.style.pointerEvents = RE);
        };
    }, [o, h, n, d]), J.useEffect(() => () => {
      o && (d.layers.delete(o), d.layersWithOutsidePointerEventsDisabled.delete(o), PE());
    }, [o, d]), J.useEffect(() => {
      const S = () => f({});
      return document.addEventListener(P7, S), () => document.removeEventListener(P7, S);
    }, []), /* @__PURE__ */ m(
      As.div,
      {
        ...c,
        ref: p,
        style: {
          pointerEvents: y ? w ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: go(e.onFocusCapture, E.onFocusCapture),
        onBlurCapture: go(e.onBlurCapture, E.onBlurCapture),
        onPointerDownCapture: go(
          e.onPointerDownCapture,
          x.onPointerDownCapture
        )
      }
    );
  }
);
DD.displayName = roe;
var loe = "DismissableLayerBranch", soe = J.forwardRef((e, t) => {
  const n = J.useContext(ND), r = J.useRef(null), i = Fo(t, r);
  return J.useEffect(() => {
    const a = r.current;
    if (a)
      return n.branches.add(a), () => {
        n.branches.delete(a);
      };
  }, [n.branches]), /* @__PURE__ */ m(As.div, { ...e, ref: i });
});
soe.displayName = loe;
function ooe(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Co(e), r = J.useRef(!1), i = J.useRef(() => {
  });
  return J.useEffect(() => {
    const a = (s) => {
      if (s.target && !r.current) {
        let c = function() {
          LD(
            ioe,
            n,
            d,
            { discrete: !0 }
          );
        };
        const d = { originalEvent: s };
        s.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = c, t.addEventListener("click", i.current, { once: !0 })) : c();
      } else
        t.removeEventListener("click", i.current);
      r.current = !1;
    }, l = window.setTimeout(() => {
      t.addEventListener("pointerdown", a);
    }, 0);
    return () => {
      window.clearTimeout(l), t.removeEventListener("pointerdown", a), t.removeEventListener("click", i.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function coe(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Co(e), r = J.useRef(!1);
  return J.useEffect(() => {
    const i = (a) => {
      a.target && !r.current && LD(aoe, n, { originalEvent: a }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function PE() {
  const e = new CustomEvent(P7);
  document.dispatchEvent(e);
}
function LD(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target, a = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && i.addEventListener(e, t, { once: !0 }), r ? toe(i, a) : i.dispatchEvent(a);
}
var s5 = 0;
function doe() {
  J.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? OE()), document.body.insertAdjacentElement("beforeend", e[1] ?? OE()), s5++, () => {
      s5 === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), s5--;
    };
  }, []);
}
function OE() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var o5 = "focusScope.autoFocusOnMount", c5 = "focusScope.autoFocusOnUnmount", $E = { bubbles: !1, cancelable: !0 }, uoe = "FocusScope", RD = J.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: a,
    ...l
  } = e, [s, c] = J.useState(null), d = Co(i), o = Co(a), u = J.useRef(null), h = Fo(t, (g) => c(g)), f = J.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  J.useEffect(() => {
    if (r) {
      let g = function(y) {
        if (f.paused || !s) return;
        const w = y.target;
        s.contains(w) ? u.current = w : Ks(u.current, { select: !0 });
      }, b = function(y) {
        if (f.paused || !s) return;
        const w = y.relatedTarget;
        w !== null && (s.contains(w) || Ks(u.current, { select: !0 }));
      }, v = function(y) {
        if (document.activeElement === document.body)
          for (const x of y)
            x.removedNodes.length > 0 && Ks(s);
      };
      document.addEventListener("focusin", g), document.addEventListener("focusout", b);
      const U = new MutationObserver(v);
      return s && U.observe(s, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", g), document.removeEventListener("focusout", b), U.disconnect();
      };
    }
  }, [r, s, f.paused]), J.useEffect(() => {
    if (s) {
      zE.add(f);
      const g = document.activeElement;
      if (!s.contains(g)) {
        const v = new CustomEvent(o5, $E);
        s.addEventListener(o5, d), s.dispatchEvent(v), v.defaultPrevented || (hoe(boe(PD(s)), { select: !0 }), document.activeElement === g && Ks(s));
      }
      return () => {
        s.removeEventListener(o5, d), setTimeout(() => {
          const v = new CustomEvent(c5, $E);
          s.addEventListener(c5, o), s.dispatchEvent(v), v.defaultPrevented || Ks(g ?? document.body, { select: !0 }), s.removeEventListener(c5, o), zE.remove(f);
        }, 0);
      };
    }
  }, [s, d, o, f]);
  const p = J.useCallback(
    (g) => {
      if (!n && !r || f.paused) return;
      const b = g.key === "Tab" && !g.altKey && !g.ctrlKey && !g.metaKey, v = document.activeElement;
      if (b && v) {
        const U = g.currentTarget, [y, w] = foe(U);
        y && w ? !g.shiftKey && v === w ? (g.preventDefault(), n && Ks(y, { select: !0 })) : g.shiftKey && v === y && (g.preventDefault(), n && Ks(w, { select: !0 })) : v === U && g.preventDefault();
      }
    },
    [n, r, f.paused]
  );
  return /* @__PURE__ */ m(As.div, { tabIndex: -1, ...l, ref: h, onKeyDown: p });
});
RD.displayName = uoe;
function hoe(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (Ks(r, { select: t }), document.activeElement !== n) return;
}
function foe(e) {
  const t = PD(e), n = FE(t, e), r = FE(t.reverse(), e);
  return [n, r];
}
function PD(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function FE(e, t) {
  for (const n of e)
    if (!poe(n, { upTo: t })) return n;
}
function poe(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function moe(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Ks(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && moe(e) && t && e.select();
  }
}
var zE = goe();
function goe() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), e = BE(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = BE(e, t), (n = e[0]) == null || n.resume();
    }
  };
}
function BE(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function boe(e) {
  return e.filter((t) => t.tagName !== "A");
}
var Jc = globalThis != null && globalThis.document ? J.useLayoutEffect : () => {
}, Uoe = J.useId || (() => {
}), voe = 0;
function yoe(e) {
  const [t, n] = J.useState(Uoe());
  return Jc(() => {
    n((r) => r ?? String(voe++));
  }, [e]), e || (t ? `radix-${t}` : "");
}
const woe = ["top", "right", "bottom", "left"], Mo = Math.min, yi = Math.max, Vm = Math.round, F1 = Math.floor, yl = (e) => ({
  x: e,
  y: e
}), xoe = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Eoe = {
  start: "end",
  end: "start"
};
function O7(e, t, n) {
  return yi(e, Mo(t, n));
}
function _s(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function ks(e) {
  return e.split("-")[0];
}
function au(e) {
  return e.split("-")[1];
}
function EU(e) {
  return e === "x" ? "y" : "x";
}
function SU(e) {
  return e === "y" ? "height" : "width";
}
function gl(e) {
  return ["top", "bottom"].includes(ks(e)) ? "y" : "x";
}
function _U(e) {
  return EU(gl(e));
}
function Soe(e, t, n) {
  n === void 0 && (n = !1);
  const r = au(e), i = _U(e), a = SU(i);
  let l = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[a] > t.floating[a] && (l = Gm(l)), [l, Gm(l)];
}
function _oe(e) {
  const t = Gm(e);
  return [$7(e), t, $7(t)];
}
function $7(e) {
  return e.replace(/start|end/g, (t) => Eoe[t]);
}
function koe(e, t, n) {
  const r = ["left", "right"], i = ["right", "left"], a = ["top", "bottom"], l = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? i : r : t ? r : i;
    case "left":
    case "right":
      return t ? a : l;
    default:
      return [];
  }
}
function Coe(e, t, n, r) {
  const i = au(e);
  let a = koe(ks(e), n === "start", r);
  return i && (a = a.map((l) => l + "-" + i), t && (a = a.concat(a.map($7)))), a;
}
function Gm(e) {
  return e.replace(/left|right|bottom|top/g, (t) => xoe[t]);
}
function Moe(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function OD(e) {
  return typeof e != "number" ? Moe(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function jm(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: i
  } = e;
  return {
    width: r,
    height: i,
    top: n,
    left: t,
    right: t + r,
    bottom: n + i,
    x: t,
    y: n
  };
}
function HE(e, t, n) {
  let {
    reference: r,
    floating: i
  } = e;
  const a = gl(t), l = _U(t), s = SU(l), c = ks(t), d = a === "y", o = r.x + r.width / 2 - i.width / 2, u = r.y + r.height / 2 - i.height / 2, h = r[s] / 2 - i[s] / 2;
  let f;
  switch (c) {
    case "top":
      f = {
        x: o,
        y: r.y - i.height
      };
      break;
    case "bottom":
      f = {
        x: o,
        y: r.y + r.height
      };
      break;
    case "right":
      f = {
        x: r.x + r.width,
        y: u
      };
      break;
    case "left":
      f = {
        x: r.x - i.width,
        y: u
      };
      break;
    default:
      f = {
        x: r.x,
        y: r.y
      };
  }
  switch (au(t)) {
    case "start":
      f[l] -= h * (n && d ? -1 : 1);
      break;
    case "end":
      f[l] += h * (n && d ? -1 : 1);
      break;
  }
  return f;
}
const Toe = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: a = [],
    platform: l
  } = n, s = a.filter(Boolean), c = await (l.isRTL == null ? void 0 : l.isRTL(t));
  let d = await l.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: o,
    y: u
  } = HE(d, r, c), h = r, f = {}, p = 0;
  for (let g = 0; g < s.length; g++) {
    const {
      name: b,
      fn: v
    } = s[g], {
      x: U,
      y,
      data: w,
      reset: x
    } = await v({
      x: o,
      y: u,
      initialPlacement: r,
      placement: h,
      strategy: i,
      middlewareData: f,
      rects: d,
      platform: l,
      elements: {
        reference: e,
        floating: t
      }
    });
    o = U ?? o, u = y ?? u, f = {
      ...f,
      [b]: {
        ...f[b],
        ...w
      }
    }, x && p <= 50 && (p++, typeof x == "object" && (x.placement && (h = x.placement), x.rects && (d = x.rects === !0 ? await l.getElementRects({
      reference: e,
      floating: t,
      strategy: i
    }) : x.rects), {
      x: o,
      y: u
    } = HE(d, h, c)), g = -1);
  }
  return {
    x: o,
    y: u,
    placement: h,
    strategy: i,
    middlewareData: f
  };
};
async function of(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: a,
    rects: l,
    elements: s,
    strategy: c
  } = e, {
    boundary: d = "clippingAncestors",
    rootBoundary: o = "viewport",
    elementContext: u = "floating",
    altBoundary: h = !1,
    padding: f = 0
  } = _s(t, e), p = OD(f), b = s[h ? u === "floating" ? "reference" : "floating" : u], v = jm(await a.getClippingRect({
    element: (n = await (a.isElement == null ? void 0 : a.isElement(b))) == null || n ? b : b.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(s.floating)),
    boundary: d,
    rootBoundary: o,
    strategy: c
  })), U = u === "floating" ? {
    x: r,
    y: i,
    width: l.floating.width,
    height: l.floating.height
  } : l.reference, y = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(s.floating)), w = await (a.isElement == null ? void 0 : a.isElement(y)) ? await (a.getScale == null ? void 0 : a.getScale(y)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, x = jm(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: s,
    rect: U,
    offsetParent: y,
    strategy: c
  }) : U);
  return {
    top: (v.top - x.top + p.top) / w.y,
    bottom: (x.bottom - v.bottom + p.bottom) / w.y,
    left: (v.left - x.left + p.left) / w.x,
    right: (x.right - v.right + p.right) / w.x
  };
}
const Ioe = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: i,
      rects: a,
      platform: l,
      elements: s,
      middlewareData: c
    } = t, {
      element: d,
      padding: o = 0
    } = _s(e, t) || {};
    if (d == null)
      return {};
    const u = OD(o), h = {
      x: n,
      y: r
    }, f = _U(i), p = SU(f), g = await l.getDimensions(d), b = f === "y", v = b ? "top" : "left", U = b ? "bottom" : "right", y = b ? "clientHeight" : "clientWidth", w = a.reference[p] + a.reference[f] - h[f] - a.floating[p], x = h[f] - a.reference[f], E = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(d));
    let S = E ? E[y] : 0;
    (!S || !await (l.isElement == null ? void 0 : l.isElement(E))) && (S = s.floating[y] || a.floating[p]);
    const _ = w / 2 - x / 2, k = S / 2 - g[p] / 2 - 1, M = Mo(u[v], k), A = Mo(u[U], k), L = M, R = S - g[p] - A, z = S / 2 - g[p] / 2 + _, F = O7(L, z, R), W = !c.arrow && au(i) != null && z !== F && a.reference[p] / 2 - (z < L ? M : A) - g[p] / 2 < 0, B = W ? z < L ? z - L : z - R : 0;
    return {
      [f]: h[f] + B,
      data: {
        [f]: F,
        centerOffset: z - F - B,
        ...W && {
          alignmentOffset: B
        }
      },
      reset: W
    };
  }
}), Aoe = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        middlewareData: a,
        rects: l,
        initialPlacement: s,
        platform: c,
        elements: d
      } = t, {
        mainAxis: o = !0,
        crossAxis: u = !0,
        fallbackPlacements: h,
        fallbackStrategy: f = "bestFit",
        fallbackAxisSideDirection: p = "none",
        flipAlignment: g = !0,
        ...b
      } = _s(e, t);
      if ((n = a.arrow) != null && n.alignmentOffset)
        return {};
      const v = ks(i), U = gl(s), y = ks(s) === s, w = await (c.isRTL == null ? void 0 : c.isRTL(d.floating)), x = h || (y || !g ? [Gm(s)] : _oe(s)), E = p !== "none";
      !h && E && x.push(...Coe(s, g, p, w));
      const S = [s, ...x], _ = await of(t, b), k = [];
      let M = ((r = a.flip) == null ? void 0 : r.overflows) || [];
      if (o && k.push(_[v]), u) {
        const z = Soe(i, l, w);
        k.push(_[z[0]], _[z[1]]);
      }
      if (M = [...M, {
        placement: i,
        overflows: k
      }], !k.every((z) => z <= 0)) {
        var A, L;
        const z = (((A = a.flip) == null ? void 0 : A.index) || 0) + 1, F = S[z];
        if (F && (!(u === "alignment" ? U !== gl(F) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        M.every((j) => j.overflows[0] > 0 && gl(j.placement) === U)))
          return {
            data: {
              index: z,
              overflows: M
            },
            reset: {
              placement: F
            }
          };
        let W = (L = M.filter((B) => B.overflows[0] <= 0).sort((B, j) => B.overflows[1] - j.overflows[1])[0]) == null ? void 0 : L.placement;
        if (!W)
          switch (f) {
            case "bestFit": {
              var R;
              const B = (R = M.filter((j) => {
                if (E) {
                  const V = gl(j.placement);
                  return V === U || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  V === "y";
                }
                return !0;
              }).map((j) => [j.placement, j.overflows.filter((V) => V > 0).reduce((V, q) => V + q, 0)]).sort((j, V) => j[1] - V[1])[0]) == null ? void 0 : R[0];
              B && (W = B);
              break;
            }
            case "initialPlacement":
              W = s;
              break;
          }
        if (i !== W)
          return {
            reset: {
              placement: W
            }
          };
      }
      return {};
    }
  };
};
function WE(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function XE(e) {
  return woe.some((t) => e[t] >= 0);
}
const Noe = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...i
      } = _s(e, t);
      switch (r) {
        case "referenceHidden": {
          const a = await of(t, {
            ...i,
            elementContext: "reference"
          }), l = WE(a, n.reference);
          return {
            data: {
              referenceHiddenOffsets: l,
              referenceHidden: XE(l)
            }
          };
        }
        case "escaped": {
          const a = await of(t, {
            ...i,
            altBoundary: !0
          }), l = WE(a, n.floating);
          return {
            data: {
              escapedOffsets: l,
              escaped: XE(l)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function Doe(e, t) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = e, a = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), l = ks(n), s = au(n), c = gl(n) === "y", d = ["left", "top"].includes(l) ? -1 : 1, o = a && c ? -1 : 1, u = _s(t, e);
  let {
    mainAxis: h,
    crossAxis: f,
    alignmentAxis: p
  } = typeof u == "number" ? {
    mainAxis: u,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: u.mainAxis || 0,
    crossAxis: u.crossAxis || 0,
    alignmentAxis: u.alignmentAxis
  };
  return s && typeof p == "number" && (f = s === "end" ? p * -1 : p), c ? {
    x: f * o,
    y: h * d
  } : {
    x: h * d,
    y: f * o
  };
}
const Loe = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: i,
        y: a,
        placement: l,
        middlewareData: s
      } = t, c = await Doe(t, e);
      return l === ((n = s.offset) == null ? void 0 : n.placement) && (r = s.arrow) != null && r.alignmentOffset ? {} : {
        x: i + c.x,
        y: a + c.y,
        data: {
          ...c,
          placement: l
        }
      };
    }
  };
}, Roe = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: i
      } = t, {
        mainAxis: a = !0,
        crossAxis: l = !1,
        limiter: s = {
          fn: (b) => {
            let {
              x: v,
              y: U
            } = b;
            return {
              x: v,
              y: U
            };
          }
        },
        ...c
      } = _s(e, t), d = {
        x: n,
        y: r
      }, o = await of(t, c), u = gl(ks(i)), h = EU(u);
      let f = d[h], p = d[u];
      if (a) {
        const b = h === "y" ? "top" : "left", v = h === "y" ? "bottom" : "right", U = f + o[b], y = f - o[v];
        f = O7(U, f, y);
      }
      if (l) {
        const b = u === "y" ? "top" : "left", v = u === "y" ? "bottom" : "right", U = p + o[b], y = p - o[v];
        p = O7(U, p, y);
      }
      const g = s.fn({
        ...t,
        [h]: f,
        [u]: p
      });
      return {
        ...g,
        data: {
          x: g.x - n,
          y: g.y - r,
          enabled: {
            [h]: a,
            [u]: l
          }
        }
      };
    }
  };
}, Poe = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: i,
        rects: a,
        middlewareData: l
      } = t, {
        offset: s = 0,
        mainAxis: c = !0,
        crossAxis: d = !0
      } = _s(e, t), o = {
        x: n,
        y: r
      }, u = gl(i), h = EU(u);
      let f = o[h], p = o[u];
      const g = _s(s, t), b = typeof g == "number" ? {
        mainAxis: g,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...g
      };
      if (c) {
        const y = h === "y" ? "height" : "width", w = a.reference[h] - a.floating[y] + b.mainAxis, x = a.reference[h] + a.reference[y] - b.mainAxis;
        f < w ? f = w : f > x && (f = x);
      }
      if (d) {
        var v, U;
        const y = h === "y" ? "width" : "height", w = ["top", "left"].includes(ks(i)), x = a.reference[u] - a.floating[y] + (w && ((v = l.offset) == null ? void 0 : v[u]) || 0) + (w ? 0 : b.crossAxis), E = a.reference[u] + a.reference[y] + (w ? 0 : ((U = l.offset) == null ? void 0 : U[u]) || 0) - (w ? b.crossAxis : 0);
        p < x ? p = x : p > E && (p = E);
      }
      return {
        [h]: f,
        [u]: p
      };
    }
  };
}, Ooe = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        rects: a,
        platform: l,
        elements: s
      } = t, {
        apply: c = () => {
        },
        ...d
      } = _s(e, t), o = await of(t, d), u = ks(i), h = au(i), f = gl(i) === "y", {
        width: p,
        height: g
      } = a.floating;
      let b, v;
      u === "top" || u === "bottom" ? (b = u, v = h === (await (l.isRTL == null ? void 0 : l.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (v = u, b = h === "end" ? "top" : "bottom");
      const U = g - o.top - o.bottom, y = p - o.left - o.right, w = Mo(g - o[b], U), x = Mo(p - o[v], y), E = !t.middlewareData.shift;
      let S = w, _ = x;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (_ = y), (r = t.middlewareData.shift) != null && r.enabled.y && (S = U), E && !h) {
        const M = yi(o.left, 0), A = yi(o.right, 0), L = yi(o.top, 0), R = yi(o.bottom, 0);
        f ? _ = p - 2 * (M !== 0 || A !== 0 ? M + A : yi(o.left, o.right)) : S = g - 2 * (L !== 0 || R !== 0 ? L + R : yi(o.top, o.bottom));
      }
      await c({
        ...t,
        availableWidth: _,
        availableHeight: S
      });
      const k = await l.getDimensions(s.floating);
      return p !== k.width || g !== k.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function w2() {
  return typeof window < "u";
}
function lu(e) {
  return $D(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function ki(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Ll(e) {
  var t;
  return (t = ($D(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function $D(e) {
  return w2() ? e instanceof Node || e instanceof ki(e).Node : !1;
}
function Fa(e) {
  return w2() ? e instanceof Element || e instanceof ki(e).Element : !1;
}
function Tl(e) {
  return w2() ? e instanceof HTMLElement || e instanceof ki(e).HTMLElement : !1;
}
function VE(e) {
  return !w2() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof ki(e).ShadowRoot;
}
function Yf(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = za(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i);
}
function $oe(e) {
  return ["table", "td", "th"].includes(lu(e));
}
function x2(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function kU(e) {
  const t = CU(), n = Fa(e) ? za(e) : e;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function Foe(e) {
  let t = To(e);
  for (; Tl(t) && !T0(t); ) {
    if (kU(t))
      return t;
    if (x2(t))
      return null;
    t = To(t);
  }
  return null;
}
function CU() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function T0(e) {
  return ["html", "body", "#document"].includes(lu(e));
}
function za(e) {
  return ki(e).getComputedStyle(e);
}
function E2(e) {
  return Fa(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function To(e) {
  if (lu(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    VE(e) && e.host || // Fallback.
    Ll(e)
  );
  return VE(t) ? t.host : t;
}
function FD(e) {
  const t = To(e);
  return T0(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Tl(t) && Yf(t) ? t : FD(t);
}
function cf(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = FD(e), a = i === ((r = e.ownerDocument) == null ? void 0 : r.body), l = ki(i);
  if (a) {
    const s = F7(l);
    return t.concat(l, l.visualViewport || [], Yf(i) ? i : [], s && n ? cf(s) : []);
  }
  return t.concat(i, cf(i, [], n));
}
function F7(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function zD(e) {
  const t = za(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = Tl(e), a = i ? e.offsetWidth : n, l = i ? e.offsetHeight : r, s = Vm(n) !== a || Vm(r) !== l;
  return s && (n = a, r = l), {
    width: n,
    height: r,
    $: s
  };
}
function MU(e) {
  return Fa(e) ? e : e.contextElement;
}
function Jd(e) {
  const t = MU(e);
  if (!Tl(t))
    return yl(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: a
  } = zD(t);
  let l = (a ? Vm(n.width) : n.width) / r, s = (a ? Vm(n.height) : n.height) / i;
  return (!l || !Number.isFinite(l)) && (l = 1), (!s || !Number.isFinite(s)) && (s = 1), {
    x: l,
    y: s
  };
}
const zoe = /* @__PURE__ */ yl(0);
function BD(e) {
  const t = ki(e);
  return !CU() || !t.visualViewport ? zoe : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function Boe(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== ki(e) ? !1 : t;
}
function Qc(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), a = MU(e);
  let l = yl(1);
  t && (r ? Fa(r) && (l = Jd(r)) : l = Jd(e));
  const s = Boe(a, n, r) ? BD(a) : yl(0);
  let c = (i.left + s.x) / l.x, d = (i.top + s.y) / l.y, o = i.width / l.x, u = i.height / l.y;
  if (a) {
    const h = ki(a), f = r && Fa(r) ? ki(r) : r;
    let p = h, g = F7(p);
    for (; g && r && f !== p; ) {
      const b = Jd(g), v = g.getBoundingClientRect(), U = za(g), y = v.left + (g.clientLeft + parseFloat(U.paddingLeft)) * b.x, w = v.top + (g.clientTop + parseFloat(U.paddingTop)) * b.y;
      c *= b.x, d *= b.y, o *= b.x, u *= b.y, c += y, d += w, p = ki(g), g = F7(p);
    }
  }
  return jm({
    width: o,
    height: u,
    x: c,
    y: d
  });
}
function TU(e, t) {
  const n = E2(e).scrollLeft;
  return t ? t.left + n : Qc(Ll(e)).left + n;
}
function HD(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), i = r.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    TU(e, r)
  )), a = r.top + t.scrollTop;
  return {
    x: i,
    y: a
  };
}
function Hoe(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: i
  } = e;
  const a = i === "fixed", l = Ll(r), s = t ? x2(t.floating) : !1;
  if (r === l || s && a)
    return n;
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  }, d = yl(1);
  const o = yl(0), u = Tl(r);
  if ((u || !u && !a) && ((lu(r) !== "body" || Yf(l)) && (c = E2(r)), Tl(r))) {
    const f = Qc(r);
    d = Jd(r), o.x = f.x + r.clientLeft, o.y = f.y + r.clientTop;
  }
  const h = l && !u && !a ? HD(l, c, !0) : yl(0);
  return {
    width: n.width * d.x,
    height: n.height * d.y,
    x: n.x * d.x - c.scrollLeft * d.x + o.x + h.x,
    y: n.y * d.y - c.scrollTop * d.y + o.y + h.y
  };
}
function Woe(e) {
  return Array.from(e.getClientRects());
}
function Xoe(e) {
  const t = Ll(e), n = E2(e), r = e.ownerDocument.body, i = yi(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), a = yi(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let l = -n.scrollLeft + TU(e);
  const s = -n.scrollTop;
  return za(r).direction === "rtl" && (l += yi(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: a,
    x: l,
    y: s
  };
}
function Voe(e, t) {
  const n = ki(e), r = Ll(e), i = n.visualViewport;
  let a = r.clientWidth, l = r.clientHeight, s = 0, c = 0;
  if (i) {
    a = i.width, l = i.height;
    const d = CU();
    (!d || d && t === "fixed") && (s = i.offsetLeft, c = i.offsetTop);
  }
  return {
    width: a,
    height: l,
    x: s,
    y: c
  };
}
function Goe(e, t) {
  const n = Qc(e, !0, t === "fixed"), r = n.top + e.clientTop, i = n.left + e.clientLeft, a = Tl(e) ? Jd(e) : yl(1), l = e.clientWidth * a.x, s = e.clientHeight * a.y, c = i * a.x, d = r * a.y;
  return {
    width: l,
    height: s,
    x: c,
    y: d
  };
}
function GE(e, t, n) {
  let r;
  if (t === "viewport")
    r = Voe(e, n);
  else if (t === "document")
    r = Xoe(Ll(e));
  else if (Fa(t))
    r = Goe(t, n);
  else {
    const i = BD(e);
    r = {
      x: t.x - i.x,
      y: t.y - i.y,
      width: t.width,
      height: t.height
    };
  }
  return jm(r);
}
function WD(e, t) {
  const n = To(e);
  return n === t || !Fa(n) || T0(n) ? !1 : za(n).position === "fixed" || WD(n, t);
}
function joe(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = cf(e, [], !1).filter((s) => Fa(s) && lu(s) !== "body"), i = null;
  const a = za(e).position === "fixed";
  let l = a ? To(e) : e;
  for (; Fa(l) && !T0(l); ) {
    const s = za(l), c = kU(l);
    !c && s.position === "fixed" && (i = null), (a ? !c && !i : !c && s.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || Yf(l) && !c && WD(e, l)) ? r = r.filter((o) => o !== l) : i = s, l = To(l);
  }
  return t.set(e, r), r;
}
function Koe(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = e;
  const l = [...n === "clippingAncestors" ? x2(t) ? [] : joe(t, this._c) : [].concat(n), r], s = l[0], c = l.reduce((d, o) => {
    const u = GE(t, o, i);
    return d.top = yi(u.top, d.top), d.right = Mo(u.right, d.right), d.bottom = Mo(u.bottom, d.bottom), d.left = yi(u.left, d.left), d;
  }, GE(t, s, i));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
function Yoe(e) {
  const {
    width: t,
    height: n
  } = zD(e);
  return {
    width: t,
    height: n
  };
}
function qoe(e, t, n) {
  const r = Tl(t), i = Ll(t), a = n === "fixed", l = Qc(e, !0, a, t);
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = yl(0);
  function d() {
    c.x = TU(i);
  }
  if (r || !r && !a)
    if ((lu(t) !== "body" || Yf(i)) && (s = E2(t)), r) {
      const f = Qc(t, !0, a, t);
      c.x = f.x + t.clientLeft, c.y = f.y + t.clientTop;
    } else i && d();
  a && !r && i && d();
  const o = i && !r && !a ? HD(i, s) : yl(0), u = l.left + s.scrollLeft - c.x - o.x, h = l.top + s.scrollTop - c.y - o.y;
  return {
    x: u,
    y: h,
    width: l.width,
    height: l.height
  };
}
function d5(e) {
  return za(e).position === "static";
}
function jE(e, t) {
  if (!Tl(e) || za(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return Ll(e) === n && (n = n.ownerDocument.body), n;
}
function XD(e, t) {
  const n = ki(e);
  if (x2(e))
    return n;
  if (!Tl(e)) {
    let i = To(e);
    for (; i && !T0(i); ) {
      if (Fa(i) && !d5(i))
        return i;
      i = To(i);
    }
    return n;
  }
  let r = jE(e, t);
  for (; r && $oe(r) && d5(r); )
    r = jE(r, t);
  return r && T0(r) && d5(r) && !kU(r) ? n : r || Foe(e) || n;
}
const Zoe = async function(e) {
  const t = this.getOffsetParent || XD, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: qoe(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function Joe(e) {
  return za(e).direction === "rtl";
}
const Qoe = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Hoe,
  getDocumentElement: Ll,
  getClippingRect: Koe,
  getOffsetParent: XD,
  getElementRects: Zoe,
  getClientRects: Woe,
  getDimensions: Yoe,
  getScale: Jd,
  isElement: Fa,
  isRTL: Joe
};
function VD(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function ece(e, t) {
  let n = null, r;
  const i = Ll(e);
  function a() {
    var s;
    clearTimeout(r), (s = n) == null || s.disconnect(), n = null;
  }
  function l(s, c) {
    s === void 0 && (s = !1), c === void 0 && (c = 1), a();
    const d = e.getBoundingClientRect(), {
      left: o,
      top: u,
      width: h,
      height: f
    } = d;
    if (s || t(), !h || !f)
      return;
    const p = F1(u), g = F1(i.clientWidth - (o + h)), b = F1(i.clientHeight - (u + f)), v = F1(o), y = {
      rootMargin: -p + "px " + -g + "px " + -b + "px " + -v + "px",
      threshold: yi(0, Mo(1, c)) || 1
    };
    let w = !0;
    function x(E) {
      const S = E[0].intersectionRatio;
      if (S !== c) {
        if (!w)
          return l();
        S ? l(!1, S) : r = setTimeout(() => {
          l(!1, 1e-7);
        }, 1e3);
      }
      S === 1 && !VD(d, e.getBoundingClientRect()) && l(), w = !1;
    }
    try {
      n = new IntersectionObserver(x, {
        ...y,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(x, y);
    }
    n.observe(e);
  }
  return l(!0), a;
}
function tce(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: a = !0,
    elementResize: l = typeof ResizeObserver == "function",
    layoutShift: s = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = r, d = MU(e), o = i || a ? [...d ? cf(d) : [], ...cf(t)] : [];
  o.forEach((v) => {
    i && v.addEventListener("scroll", n, {
      passive: !0
    }), a && v.addEventListener("resize", n);
  });
  const u = d && s ? ece(d, n) : null;
  let h = -1, f = null;
  l && (f = new ResizeObserver((v) => {
    let [U] = v;
    U && U.target === d && f && (f.unobserve(t), cancelAnimationFrame(h), h = requestAnimationFrame(() => {
      var y;
      (y = f) == null || y.observe(t);
    })), n();
  }), d && !c && f.observe(d), f.observe(t));
  let p, g = c ? Qc(e) : null;
  c && b();
  function b() {
    const v = Qc(e);
    g && !VD(g, v) && n(), g = v, p = requestAnimationFrame(b);
  }
  return n(), () => {
    var v;
    o.forEach((U) => {
      i && U.removeEventListener("scroll", n), a && U.removeEventListener("resize", n);
    }), u == null || u(), (v = f) == null || v.disconnect(), f = null, c && cancelAnimationFrame(p);
  };
}
const nce = Loe, rce = Roe, ice = Aoe, ace = Ooe, lce = Noe, KE = Ioe, sce = Poe, oce = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: Qoe,
    ...n
  }, a = {
    ...i.platform,
    _c: r
  };
  return Toe(e, t, {
    ...i,
    platform: a
  });
};
var cce = typeof document < "u", dce = function() {
}, _p = cce ? Bn : dce;
function Km(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!Km(e[r], t[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const a = i[r];
      if (!(a === "_owner" && e.$$typeof) && !Km(e[a], t[a]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function GD(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function YE(e, t) {
  const n = GD(e);
  return Math.round(t * n) / n;
}
function u5(e) {
  const t = J.useRef(e);
  return _p(() => {
    t.current = e;
  }), t;
}
function uce(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: a,
      floating: l
    } = {},
    transform: s = !0,
    whileElementsMounted: c,
    open: d
  } = e, [o, u] = J.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [h, f] = J.useState(r);
  Km(h, r) || f(r);
  const [p, g] = J.useState(null), [b, v] = J.useState(null), U = J.useCallback((j) => {
    j !== E.current && (E.current = j, g(j));
  }, []), y = J.useCallback((j) => {
    j !== S.current && (S.current = j, v(j));
  }, []), w = a || p, x = l || b, E = J.useRef(null), S = J.useRef(null), _ = J.useRef(o), k = c != null, M = u5(c), A = u5(i), L = u5(d), R = J.useCallback(() => {
    if (!E.current || !S.current)
      return;
    const j = {
      placement: t,
      strategy: n,
      middleware: h
    };
    A.current && (j.platform = A.current), oce(E.current, S.current, j).then((V) => {
      const q = {
        ...V,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: L.current !== !1
      };
      z.current && !Km(_.current, q) && (_.current = q, _c.flushSync(() => {
        u(q);
      }));
    });
  }, [h, t, n, A, L]);
  _p(() => {
    d === !1 && _.current.isPositioned && (_.current.isPositioned = !1, u((j) => ({
      ...j,
      isPositioned: !1
    })));
  }, [d]);
  const z = J.useRef(!1);
  _p(() => (z.current = !0, () => {
    z.current = !1;
  }), []), _p(() => {
    if (w && (E.current = w), x && (S.current = x), w && x) {
      if (M.current)
        return M.current(w, x, R);
      R();
    }
  }, [w, x, R, M, k]);
  const F = J.useMemo(() => ({
    reference: E,
    floating: S,
    setReference: U,
    setFloating: y
  }), [U, y]), W = J.useMemo(() => ({
    reference: w,
    floating: x
  }), [w, x]), B = J.useMemo(() => {
    const j = {
      position: n,
      left: 0,
      top: 0
    };
    if (!W.floating)
      return j;
    const V = YE(W.floating, o.x), q = YE(W.floating, o.y);
    return s ? {
      ...j,
      transform: "translate(" + V + "px, " + q + "px)",
      ...GD(W.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: V,
      top: q
    };
  }, [n, s, W.floating, o.x, o.y]);
  return J.useMemo(() => ({
    ...o,
    update: R,
    refs: F,
    elements: W,
    floatingStyles: B
  }), [o, R, F, W, B]);
}
const hce = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: i
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? KE({
        element: r.current,
        padding: i
      }).fn(n) : {} : r ? KE({
        element: r,
        padding: i
      }).fn(n) : {};
    }
  };
}, fce = (e, t) => ({
  ...nce(e),
  options: [e, t]
}), pce = (e, t) => ({
  ...rce(e),
  options: [e, t]
}), mce = (e, t) => ({
  ...sce(e),
  options: [e, t]
}), gce = (e, t) => ({
  ...ice(e),
  options: [e, t]
}), bce = (e, t) => ({
  ...ace(e),
  options: [e, t]
}), Uce = (e, t) => ({
  ...lce(e),
  options: [e, t]
}), vce = (e, t) => ({
  ...hce(e),
  options: [e, t]
});
var yce = "Arrow", jD = J.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: i = 5, ...a } = e;
  return /* @__PURE__ */ m(
    As.svg,
    {
      ...a,
      ref: t,
      width: r,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ m("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
jD.displayName = yce;
var wce = jD;
function xce(e) {
  const [t, n] = J.useState(void 0);
  return Jc(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const a = i[0];
        let l, s;
        if ("borderBoxSize" in a) {
          const c = a.borderBoxSize, d = Array.isArray(c) ? c[0] : c;
          l = d.inlineSize, s = d.blockSize;
        } else
          l = e.offsetWidth, s = e.offsetHeight;
        n({ width: l, height: s });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var IU = "Popper", [KD, YD] = AD(IU), [Ece, qD] = KD(IU), ZD = (e) => {
  const { __scopePopper: t, children: n } = e, [r, i] = J.useState(null);
  return /* @__PURE__ */ m(Ece, { scope: t, anchor: r, onAnchorChange: i, children: n });
};
ZD.displayName = IU;
var JD = "PopperAnchor", QD = J.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...i } = e, a = qD(JD, n), l = J.useRef(null), s = Fo(t, l);
    return J.useEffect(() => {
      a.onAnchorChange((r == null ? void 0 : r.current) || l.current);
    }), r ? null : /* @__PURE__ */ m(As.div, { ...i, ref: s });
  }
);
QD.displayName = JD;
var AU = "PopperContent", [Sce, _ce] = KD(AU), eL = J.forwardRef(
  (e, t) => {
    var Be, qe, At, Je, mt, jt;
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: i = 0,
      align: a = "center",
      alignOffset: l = 0,
      arrowPadding: s = 0,
      avoidCollisions: c = !0,
      collisionBoundary: d = [],
      collisionPadding: o = 0,
      sticky: u = "partial",
      hideWhenDetached: h = !1,
      updatePositionStrategy: f = "optimized",
      onPlaced: p,
      ...g
    } = e, b = qD(AU, n), [v, U] = J.useState(null), y = Fo(t, (_e) => U(_e)), [w, x] = J.useState(null), E = xce(w), S = (E == null ? void 0 : E.width) ?? 0, _ = (E == null ? void 0 : E.height) ?? 0, k = r + (a !== "center" ? "-" + a : ""), M = typeof o == "number" ? o : { top: 0, right: 0, bottom: 0, left: 0, ...o }, A = Array.isArray(d) ? d : [d], L = A.length > 0, R = {
      padding: M,
      boundary: A.filter(Cce),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: L
    }, { refs: z, floatingStyles: F, placement: W, isPositioned: B, middlewareData: j } = uce({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: k,
      whileElementsMounted: (..._e) => tce(..._e, {
        animationFrame: f === "always"
      }),
      elements: {
        reference: b.anchor
      },
      middleware: [
        fce({ mainAxis: i + _, alignmentAxis: l }),
        c && pce({
          mainAxis: !0,
          crossAxis: !1,
          limiter: u === "partial" ? mce() : void 0,
          ...R
        }),
        c && gce({ ...R }),
        bce({
          ...R,
          apply: ({ elements: _e, rects: rt, availableWidth: Xt, availableHeight: fr }) => {
            const { width: Qt, height: rr } = rt.reference, Kt = _e.floating.style;
            Kt.setProperty("--radix-popper-available-width", `${Xt}px`), Kt.setProperty("--radix-popper-available-height", `${fr}px`), Kt.setProperty("--radix-popper-anchor-width", `${Qt}px`), Kt.setProperty("--radix-popper-anchor-height", `${rr}px`);
          }
        }),
        w && vce({ element: w, padding: s }),
        Mce({ arrowWidth: S, arrowHeight: _ }),
        h && Uce({ strategy: "referenceHidden", ...R })
      ]
    }), [V, q] = rL(W), oe = Co(p);
    Jc(() => {
      B && (oe == null || oe());
    }, [B, oe]);
    const Ue = (Be = j.arrow) == null ? void 0 : Be.x, fe = (qe = j.arrow) == null ? void 0 : qe.y, Pe = ((At = j.arrow) == null ? void 0 : At.centerOffset) !== 0, [ze, Oe] = J.useState();
    return Jc(() => {
      v && Oe(window.getComputedStyle(v).zIndex);
    }, [v]), /* @__PURE__ */ m(
      "div",
      {
        ref: z.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...F,
          transform: B ? F.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: ze,
          "--radix-popper-transform-origin": [
            (Je = j.transformOrigin) == null ? void 0 : Je.x,
            (mt = j.transformOrigin) == null ? void 0 : mt.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((jt = j.hide) == null ? void 0 : jt.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ m(
          Sce,
          {
            scope: n,
            placedSide: V,
            onArrowChange: x,
            arrowX: Ue,
            arrowY: fe,
            shouldHideArrow: Pe,
            children: /* @__PURE__ */ m(
              As.div,
              {
                "data-side": V,
                "data-align": q,
                ...g,
                ref: y,
                style: {
                  ...g.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: B ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
eL.displayName = AU;
var tL = "PopperArrow", kce = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, nL = J.forwardRef(function(t, n) {
  const { __scopePopper: r, ...i } = t, a = _ce(tL, r), l = kce[a.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ m(
      "span",
      {
        ref: a.onArrowChange,
        style: {
          position: "absolute",
          left: a.arrowX,
          top: a.arrowY,
          [l]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[a.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[a.placedSide],
          visibility: a.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ m(
          wce,
          {
            ...i,
            ref: n,
            style: {
              ...i.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
nL.displayName = tL;
function Cce(e) {
  return e !== null;
}
var Mce = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var b, v, U;
    const { placement: n, rects: r, middlewareData: i } = t, l = ((b = i.arrow) == null ? void 0 : b.centerOffset) !== 0, s = l ? 0 : e.arrowWidth, c = l ? 0 : e.arrowHeight, [d, o] = rL(n), u = { start: "0%", center: "50%", end: "100%" }[o], h = (((v = i.arrow) == null ? void 0 : v.x) ?? 0) + s / 2, f = (((U = i.arrow) == null ? void 0 : U.y) ?? 0) + c / 2;
    let p = "", g = "";
    return d === "bottom" ? (p = l ? u : `${h}px`, g = `${-c}px`) : d === "top" ? (p = l ? u : `${h}px`, g = `${r.floating.height + c}px`) : d === "right" ? (p = `${-c}px`, g = l ? u : `${f}px`) : d === "left" && (p = `${r.floating.width + c}px`, g = l ? u : `${f}px`), { data: { x: p, y: g } };
  }
});
function rL(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var Tce = ZD, iL = QD, Ice = eL, Ace = nL, Nce = "Portal", aL = J.forwardRef((e, t) => {
  var s;
  const { container: n, ...r } = e, [i, a] = J.useState(!1);
  Jc(() => a(!0), []);
  const l = n || i && ((s = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : s.body);
  return l ? AO.createPortal(/* @__PURE__ */ m(As.div, { ...r, ref: t }), l) : null;
});
aL.displayName = Nce;
function Dce(e, t) {
  return J.useReducer((n, r) => t[n][r] ?? n, e);
}
var NU = (e) => {
  const { present: t, children: n } = e, r = Lce(t), i = typeof n == "function" ? n({ present: r.isPresent }) : J.Children.only(n), a = Fo(r.ref, Rce(i));
  return typeof n == "function" || r.isPresent ? J.cloneElement(i, { ref: a }) : null;
};
NU.displayName = "Presence";
function Lce(e) {
  const [t, n] = J.useState(), r = J.useRef({}), i = J.useRef(e), a = J.useRef("none"), l = e ? "mounted" : "unmounted", [s, c] = Dce(l, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return J.useEffect(() => {
    const d = z1(r.current);
    a.current = s === "mounted" ? d : "none";
  }, [s]), Jc(() => {
    const d = r.current, o = i.current;
    if (o !== e) {
      const h = a.current, f = z1(d);
      e ? c("MOUNT") : f === "none" || (d == null ? void 0 : d.display) === "none" ? c("UNMOUNT") : c(o && h !== f ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, c]), Jc(() => {
    if (t) {
      let d;
      const o = t.ownerDocument.defaultView ?? window, u = (f) => {
        const g = z1(r.current).includes(f.animationName);
        if (f.target === t && g && (c("ANIMATION_END"), !i.current)) {
          const b = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", d = o.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = b);
          });
        }
      }, h = (f) => {
        f.target === t && (a.current = z1(r.current));
      };
      return t.addEventListener("animationstart", h), t.addEventListener("animationcancel", u), t.addEventListener("animationend", u), () => {
        o.clearTimeout(d), t.removeEventListener("animationstart", h), t.removeEventListener("animationcancel", u), t.removeEventListener("animationend", u);
      };
    } else
      c("ANIMATION_END");
  }, [t, c]), {
    isPresent: ["mounted", "unmountSuspended"].includes(s),
    ref: J.useCallback((d) => {
      d && (r.current = getComputedStyle(d)), n(d);
    }, [])
  };
}
function z1(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function Rce(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
function Pce({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  }
}) {
  const [r, i] = Oce({ defaultProp: t, onChange: n }), a = e !== void 0, l = a ? e : r, s = Co(n), c = J.useCallback(
    (d) => {
      if (a) {
        const u = typeof d == "function" ? d(e) : d;
        u !== e && s(u);
      } else
        i(d);
    },
    [a, e, i, s]
  );
  return [l, c];
}
function Oce({
  defaultProp: e,
  onChange: t
}) {
  const n = J.useState(e), [r] = n, i = J.useRef(r), a = Co(t);
  return J.useEffect(() => {
    i.current !== r && (a(r), i.current = r);
  }, [r, i, a]), n;
}
var $ce = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, Ed = /* @__PURE__ */ new WeakMap(), B1 = /* @__PURE__ */ new WeakMap(), H1 = {}, h5 = 0, lL = function(e) {
  return e && (e.host || lL(e.parentNode));
}, Fce = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = lL(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, zce = function(e, t, n, r) {
  var i = Fce(t, Array.isArray(e) ? e : [e]);
  H1[n] || (H1[n] = /* @__PURE__ */ new WeakMap());
  var a = H1[n], l = [], s = /* @__PURE__ */ new Set(), c = new Set(i), d = function(u) {
    !u || s.has(u) || (s.add(u), d(u.parentNode));
  };
  i.forEach(d);
  var o = function(u) {
    !u || c.has(u) || Array.prototype.forEach.call(u.children, function(h) {
      if (s.has(h))
        o(h);
      else
        try {
          var f = h.getAttribute(r), p = f !== null && f !== "false", g = (Ed.get(h) || 0) + 1, b = (a.get(h) || 0) + 1;
          Ed.set(h, g), a.set(h, b), l.push(h), g === 1 && p && B1.set(h, !0), b === 1 && h.setAttribute(n, "true"), p || h.setAttribute(r, "true");
        } catch (v) {
          console.error("aria-hidden: cannot operate on ", h, v);
        }
    });
  };
  return o(t), s.clear(), h5++, function() {
    l.forEach(function(u) {
      var h = Ed.get(u) - 1, f = a.get(u) - 1;
      Ed.set(u, h), a.set(u, f), h || (B1.has(u) || u.removeAttribute(r), B1.delete(u)), f || u.removeAttribute(n);
    }), h5--, h5 || (Ed = /* @__PURE__ */ new WeakMap(), Ed = /* @__PURE__ */ new WeakMap(), B1 = /* @__PURE__ */ new WeakMap(), H1 = {});
  };
}, Bce = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), i = $ce(e);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live], script"))), zce(r, i, n, "aria-hidden")) : function() {
    return null;
  };
}, fl = function() {
  return fl = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a]);
    }
    return t;
  }, fl.apply(this, arguments);
};
function sL(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
function Hce(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, i = t.length, a; r < i; r++)
    (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);
  return e.concat(a || Array.prototype.slice.call(t));
}
var kp = "right-scroll-bar-position", Cp = "width-before-scroll-bar", Wce = "with-scroll-bars-hidden", Xce = "--removed-body-scroll-bar-size";
function f5(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function Vce(e, t) {
  var n = Q(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var Gce = typeof window < "u" ? J.useLayoutEffect : J.useEffect, qE = /* @__PURE__ */ new WeakMap();
function jce(e, t) {
  var n = Vce(null, function(r) {
    return e.forEach(function(i) {
      return f5(i, r);
    });
  });
  return Gce(function() {
    var r = qE.get(n);
    if (r) {
      var i = new Set(r), a = new Set(e), l = n.current;
      i.forEach(function(s) {
        a.has(s) || f5(s, null);
      }), a.forEach(function(s) {
        i.has(s) || f5(s, l);
      });
    }
    qE.set(n, e);
  }, [e]), n;
}
function Kce(e) {
  return e;
}
function Yce(e, t) {
  t === void 0 && (t = Kce);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(a) {
      var l = t(a, r);
      return n.push(l), function() {
        n = n.filter(function(s) {
          return s !== l;
        });
      };
    },
    assignSyncMedium: function(a) {
      for (r = !0; n.length; ) {
        var l = n;
        n = [], l.forEach(a);
      }
      n = {
        push: function(s) {
          return a(s);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(a) {
      r = !0;
      var l = [];
      if (n.length) {
        var s = n;
        n = [], s.forEach(a), l = n;
      }
      var c = function() {
        var o = l;
        l = [], o.forEach(a);
      }, d = function() {
        return Promise.resolve().then(c);
      };
      d(), n = {
        push: function(o) {
          l.push(o), d();
        },
        filter: function(o) {
          return l = l.filter(o), n;
        }
      };
    }
  };
  return i;
}
function qce(e) {
  e === void 0 && (e = {});
  var t = Yce(null);
  return t.options = fl({ async: !0, ssr: !1 }, e), t;
}
var oL = function(e) {
  var t = e.sideCar, n = sL(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return J.createElement(r, fl({}, n));
};
oL.isSideCarExport = !0;
function Zce(e, t) {
  return e.useMedium(t), oL;
}
var cL = qce(), p5 = function() {
}, S2 = J.forwardRef(function(e, t) {
  var n = J.useRef(null), r = J.useState({
    onScrollCapture: p5,
    onWheelCapture: p5,
    onTouchMoveCapture: p5
  }), i = r[0], a = r[1], l = e.forwardProps, s = e.children, c = e.className, d = e.removeScrollBar, o = e.enabled, u = e.shards, h = e.sideCar, f = e.noRelative, p = e.noIsolation, g = e.inert, b = e.allowPinchZoom, v = e.as, U = v === void 0 ? "div" : v, y = e.gapMode, w = sL(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), x = h, E = jce([n, t]), S = fl(fl({}, w), i);
  return J.createElement(
    J.Fragment,
    null,
    o && J.createElement(x, { sideCar: cL, removeScrollBar: d, shards: u, noRelative: f, noIsolation: p, inert: g, setCallbacks: a, allowPinchZoom: !!b, lockRef: n, gapMode: y }),
    l ? J.cloneElement(J.Children.only(s), fl(fl({}, S), { ref: E })) : J.createElement(U, fl({}, S, { className: c, ref: E }), s)
  );
});
S2.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
S2.classNames = {
  fullWidth: Cp,
  zeroRight: kp
};
var Jce = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function Qce() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = Jce();
  return t && e.setAttribute("nonce", t), e;
}
function ede(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function tde(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var nde = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = Qce()) && (ede(t, n), tde(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, rde = function() {
  var e = nde();
  return function(t, n) {
    J.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, dL = function() {
  var e = rde(), t = function(n) {
    var r = n.styles, i = n.dynamic;
    return e(r, i), null;
  };
  return t;
}, ide = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, m5 = function(e) {
  return parseInt(e || "", 10) || 0;
}, ade = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [m5(n), m5(r), m5(i)];
}, lde = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return ide;
  var t = ade(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, sde = dL(), Qd = "data-scroll-locked", ode = function(e, t, n, r) {
  var i = e.left, a = e.top, l = e.right, s = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(Wce, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(s, "px ").concat(r, `;
  }
  body[`).concat(Qd, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(a, `px;
    padding-right: `).concat(l, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(s, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(s, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(kp, ` {
    right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat(Cp, ` {
    margin-right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat(kp, " .").concat(kp, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Cp, " .").concat(Cp, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Qd, `] {
    `).concat(Xce, ": ").concat(s, `px;
  }
`);
}, ZE = function() {
  var e = parseInt(document.body.getAttribute(Qd) || "0", 10);
  return isFinite(e) ? e : 0;
}, cde = function() {
  J.useEffect(function() {
    return document.body.setAttribute(Qd, (ZE() + 1).toString()), function() {
      var e = ZE() - 1;
      e <= 0 ? document.body.removeAttribute(Qd) : document.body.setAttribute(Qd, e.toString());
    };
  }, []);
}, dde = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, i = r === void 0 ? "margin" : r;
  cde();
  var a = J.useMemo(function() {
    return lde(i);
  }, [i]);
  return J.createElement(sde, { styles: ode(a, !t, i, n ? "" : "!important") });
}, z7 = !1;
if (typeof window < "u")
  try {
    var W1 = Object.defineProperty({}, "passive", {
      get: function() {
        return z7 = !0, !0;
      }
    });
    window.addEventListener("test", W1, W1), window.removeEventListener("test", W1, W1);
  } catch {
    z7 = !1;
  }
var Sd = z7 ? { passive: !1 } : !1, ude = function(e) {
  return e.tagName === "TEXTAREA";
}, uL = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !ude(e) && n[t] === "visible")
  );
}, hde = function(e) {
  return uL(e, "overflowY");
}, fde = function(e) {
  return uL(e, "overflowX");
}, JE = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = hL(e, r);
    if (i) {
      var a = fL(e, r), l = a[1], s = a[2];
      if (l > s)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, pde = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, mde = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, hL = function(e, t) {
  return e === "v" ? hde(t) : fde(t);
}, fL = function(e, t) {
  return e === "v" ? pde(t) : mde(t);
}, gde = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, bde = function(e, t, n, r, i) {
  var a = gde(e, window.getComputedStyle(t).direction), l = a * r, s = n.target, c = t.contains(s), d = !1, o = l > 0, u = 0, h = 0;
  do {
    if (!s)
      break;
    var f = fL(e, s), p = f[0], g = f[1], b = f[2], v = g - b - a * p;
    (p || v) && hL(e, s) && (u += v, h += p);
    var U = s.parentNode;
    s = U && U.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? U.host : U;
  } while (
    // portaled content
    !c && s !== document.body || // self content
    c && (t.contains(s) || t === s)
  );
  return (o && Math.abs(u) < 1 || !o && Math.abs(h) < 1) && (d = !0), d;
}, X1 = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, QE = function(e) {
  return [e.deltaX, e.deltaY];
}, eS = function(e) {
  return e && "current" in e ? e.current : e;
}, Ude = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, vde = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, yde = 0, _d = [];
function wde(e) {
  var t = J.useRef([]), n = J.useRef([0, 0]), r = J.useRef(), i = J.useState(yde++)[0], a = J.useState(dL)[0], l = J.useRef(e);
  J.useEffect(function() {
    l.current = e;
  }, [e]), J.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var g = Hce([e.lockRef.current], (e.shards || []).map(eS), !0).filter(Boolean);
      return g.forEach(function(b) {
        return b.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), g.forEach(function(b) {
          return b.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var s = J.useCallback(function(g, b) {
    if ("touches" in g && g.touches.length === 2 || g.type === "wheel" && g.ctrlKey)
      return !l.current.allowPinchZoom;
    var v = X1(g), U = n.current, y = "deltaX" in g ? g.deltaX : U[0] - v[0], w = "deltaY" in g ? g.deltaY : U[1] - v[1], x, E = g.target, S = Math.abs(y) > Math.abs(w) ? "h" : "v";
    if ("touches" in g && S === "h" && E.type === "range")
      return !1;
    var _ = JE(S, E);
    if (!_)
      return !0;
    if (_ ? x = S : (x = S === "v" ? "h" : "v", _ = JE(S, E)), !_)
      return !1;
    if (!r.current && "changedTouches" in g && (y || w) && (r.current = x), !x)
      return !0;
    var k = r.current || x;
    return bde(k, b, g, k === "h" ? y : w);
  }, []), c = J.useCallback(function(g) {
    var b = g;
    if (!(!_d.length || _d[_d.length - 1] !== a)) {
      var v = "deltaY" in b ? QE(b) : X1(b), U = t.current.filter(function(x) {
        return x.name === b.type && (x.target === b.target || b.target === x.shadowParent) && Ude(x.delta, v);
      })[0];
      if (U && U.should) {
        b.cancelable && b.preventDefault();
        return;
      }
      if (!U) {
        var y = (l.current.shards || []).map(eS).filter(Boolean).filter(function(x) {
          return x.contains(b.target);
        }), w = y.length > 0 ? s(b, y[0]) : !l.current.noIsolation;
        w && b.cancelable && b.preventDefault();
      }
    }
  }, []), d = J.useCallback(function(g, b, v, U) {
    var y = { name: g, delta: b, target: v, should: U, shadowParent: xde(v) };
    t.current.push(y), setTimeout(function() {
      t.current = t.current.filter(function(w) {
        return w !== y;
      });
    }, 1);
  }, []), o = J.useCallback(function(g) {
    n.current = X1(g), r.current = void 0;
  }, []), u = J.useCallback(function(g) {
    d(g.type, QE(g), g.target, s(g, e.lockRef.current));
  }, []), h = J.useCallback(function(g) {
    d(g.type, X1(g), g.target, s(g, e.lockRef.current));
  }, []);
  J.useEffect(function() {
    return _d.push(a), e.setCallbacks({
      onScrollCapture: u,
      onWheelCapture: u,
      onTouchMoveCapture: h
    }), document.addEventListener("wheel", c, Sd), document.addEventListener("touchmove", c, Sd), document.addEventListener("touchstart", o, Sd), function() {
      _d = _d.filter(function(g) {
        return g !== a;
      }), document.removeEventListener("wheel", c, Sd), document.removeEventListener("touchmove", c, Sd), document.removeEventListener("touchstart", o, Sd);
    };
  }, []);
  var f = e.removeScrollBar, p = e.inert;
  return J.createElement(
    J.Fragment,
    null,
    p ? J.createElement(a, { styles: vde(i) }) : null,
    f ? J.createElement(dde, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function xde(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const Ede = Zce(cL, wde);
var pL = J.forwardRef(function(e, t) {
  return J.createElement(S2, fl({}, e, { ref: t, sideCar: Ede }));
});
pL.classNames = S2.classNames;
var DU = "Popover", [mL, _4e] = AD(DU, [
  YD
]), qf = YD(), [Sde, zo] = mL(DU), gL = (e) => {
  const {
    __scopePopover: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: a,
    modal: l = !1
  } = e, s = qf(t), c = J.useRef(null), [d, o] = J.useState(!1), [u = !1, h] = Pce({
    prop: r,
    defaultProp: i,
    onChange: a
  });
  return /* @__PURE__ */ m(Tce, { ...s, children: /* @__PURE__ */ m(
    Sde,
    {
      scope: t,
      contentId: yoe(),
      triggerRef: c,
      open: u,
      onOpenChange: h,
      onOpenToggle: J.useCallback(() => h((f) => !f), [h]),
      hasCustomAnchor: d,
      onCustomAnchorAdd: J.useCallback(() => o(!0), []),
      onCustomAnchorRemove: J.useCallback(() => o(!1), []),
      modal: l,
      children: n
    }
  ) });
};
gL.displayName = DU;
var bL = "PopoverAnchor", _de = J.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, i = zo(bL, n), a = qf(n), { onCustomAnchorAdd: l, onCustomAnchorRemove: s } = i;
    return J.useEffect(() => (l(), () => s()), [l, s]), /* @__PURE__ */ m(iL, { ...a, ...r, ref: t });
  }
);
_de.displayName = bL;
var UL = "PopoverTrigger", vL = J.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, i = zo(UL, n), a = qf(n), l = Fo(t, i.triggerRef), s = /* @__PURE__ */ m(
      As.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": _L(i.open),
        ...r,
        ref: l,
        onClick: go(e.onClick, i.onOpenToggle)
      }
    );
    return i.hasCustomAnchor ? s : /* @__PURE__ */ m(iL, { asChild: !0, ...a, children: s });
  }
);
vL.displayName = UL;
var LU = "PopoverPortal", [kde, Cde] = mL(LU, {
  forceMount: void 0
}), yL = (e) => {
  const { __scopePopover: t, forceMount: n, children: r, container: i } = e, a = zo(LU, t);
  return /* @__PURE__ */ m(kde, { scope: t, forceMount: n, children: /* @__PURE__ */ m(NU, { present: n || a.open, children: /* @__PURE__ */ m(aL, { asChild: !0, container: i, children: r }) }) });
};
yL.displayName = LU;
var I0 = "PopoverContent", wL = J.forwardRef(
  (e, t) => {
    const n = Cde(I0, e.__scopePopover), { forceMount: r = n.forceMount, ...i } = e, a = zo(I0, e.__scopePopover);
    return /* @__PURE__ */ m(NU, { present: r || a.open, children: a.modal ? /* @__PURE__ */ m(Mde, { ...i, ref: t }) : /* @__PURE__ */ m(Tde, { ...i, ref: t }) });
  }
);
wL.displayName = I0;
var Mde = J.forwardRef(
  (e, t) => {
    const n = zo(I0, e.__scopePopover), r = J.useRef(null), i = Fo(t, r), a = J.useRef(!1);
    return J.useEffect(() => {
      const l = r.current;
      if (l) return Bce(l);
    }, []), /* @__PURE__ */ m(pL, { as: xU, allowPinchZoom: !0, children: /* @__PURE__ */ m(
      xL,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: go(e.onCloseAutoFocus, (l) => {
          var s;
          l.preventDefault(), a.current || (s = n.triggerRef.current) == null || s.focus();
        }),
        onPointerDownOutside: go(
          e.onPointerDownOutside,
          (l) => {
            const s = l.detail.originalEvent, c = s.button === 0 && s.ctrlKey === !0, d = s.button === 2 || c;
            a.current = d;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: go(
          e.onFocusOutside,
          (l) => l.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), Tde = J.forwardRef(
  (e, t) => {
    const n = zo(I0, e.__scopePopover), r = J.useRef(!1), i = J.useRef(!1);
    return /* @__PURE__ */ m(
      xL,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (a) => {
          var l, s;
          (l = e.onCloseAutoFocus) == null || l.call(e, a), a.defaultPrevented || (r.current || (s = n.triggerRef.current) == null || s.focus(), a.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (a) => {
          var c, d;
          (c = e.onInteractOutside) == null || c.call(e, a), a.defaultPrevented || (r.current = !0, a.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const l = a.target;
          ((d = n.triggerRef.current) == null ? void 0 : d.contains(l)) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && i.current && a.preventDefault();
        }
      }
    );
  }
), xL = J.forwardRef(
  (e, t) => {
    const {
      __scopePopover: n,
      trapFocus: r,
      onOpenAutoFocus: i,
      onCloseAutoFocus: a,
      disableOutsidePointerEvents: l,
      onEscapeKeyDown: s,
      onPointerDownOutside: c,
      onFocusOutside: d,
      onInteractOutside: o,
      ...u
    } = e, h = zo(I0, n), f = qf(n);
    return doe(), /* @__PURE__ */ m(
      RD,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: i,
        onUnmountAutoFocus: a,
        children: /* @__PURE__ */ m(
          DD,
          {
            asChild: !0,
            disableOutsidePointerEvents: l,
            onInteractOutside: o,
            onEscapeKeyDown: s,
            onPointerDownOutside: c,
            onFocusOutside: d,
            onDismiss: () => h.onOpenChange(!1),
            children: /* @__PURE__ */ m(
              Ice,
              {
                "data-state": _L(h.open),
                role: "dialog",
                id: h.contentId,
                ...f,
                ...u,
                ref: t,
                style: {
                  ...u.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), EL = "PopoverClose", Ide = J.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, i = zo(EL, n);
    return /* @__PURE__ */ m(
      As.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: go(e.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
Ide.displayName = EL;
var Ade = "PopoverArrow", SL = J.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, i = qf(n);
    return /* @__PURE__ */ m(Ace, { ...i, ...r, ref: t });
  }
);
SL.displayName = Ade;
function _L(e) {
  return e ? "open" : "closed";
}
var _2 = gL, k2 = vL, Nde = yL, RU = wL, kL = SL, CL = { exports: {} };
(function(e, t) {
  (function() {
    var n = {};
    e.exports = n, n.simpleFilter = function(r, i) {
      return i.filter(function(a) {
        return n.test(r, a);
      });
    }, n.test = function(r, i) {
      return n.match(r, i) !== null;
    }, n.match = function(r, i, a) {
      a = a || {};
      var l = 0, s = [], c = i.length, d = 0, o = 0, u = a.pre || "", h = a.post || "", f = a.caseSensitive && i || i.toLowerCase(), p;
      r = a.caseSensitive && r || r.toLowerCase();
      for (var g = 0; g < c; g++)
        p = i[g], f[g] === r[l] ? (p = u + p + h, l += 1, o += 1 + o) : o = 0, d += o, s[s.length] = p;
      return l === r.length ? (d = f === r ? 1 / 0 : d, { rendered: s.join(""), score: d }) : null;
    }, n.filter = function(r, i, a) {
      return !i || i.length === 0 ? [] : typeof r != "string" ? i : (a = a || {}, i.reduce(function(l, s, c, d) {
        var o = s;
        a.extract && (o = a.extract(s));
        var u = n.match(r, o, a);
        return u != null && (l[l.length] = {
          string: u.rendered,
          score: u.score,
          index: c,
          original: s
        }), l;
      }, []).sort(function(l, s) {
        var c = s.score - l.score;
        return c || l.index - s.index;
      }));
    };
  })();
})(CL);
var Dde = CL.exports;
const Lde = /* @__PURE__ */ ad(Dde), Rde = {}, tS = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (o, u) => {
    const h = typeof o == "function" ? o(t) : o;
    if (!Object.is(h, t)) {
      const f = t;
      t = u ?? (typeof h != "object" || h === null) ? h : Object.assign({}, t, h), n.forEach((p) => p(t, f));
    }
  }, i = () => t, c = { setState: r, getState: i, getInitialState: () => d, subscribe: (o) => (n.add(o), () => n.delete(o)), destroy: () => {
    (Rde ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, d = t = e(r, i, c);
  return c;
}, Pde = (e) => e ? tS(e) : tS;
var B7 = { exports: {} }, g5 = {}, V1 = { exports: {} }, b5 = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nS;
function Ode() {
  if (nS) return b5;
  nS = 1;
  var e = pe;
  function t(u, h) {
    return u === h && (u !== 0 || 1 / u === 1 / h) || u !== u && h !== h;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, a = e.useLayoutEffect, l = e.useDebugValue;
  function s(u, h) {
    var f = h(), p = r({ inst: { value: f, getSnapshot: h } }), g = p[0].inst, b = p[1];
    return a(
      function() {
        g.value = f, g.getSnapshot = h, c(g) && b({ inst: g });
      },
      [u, f, h]
    ), i(
      function() {
        return c(g) && b({ inst: g }), u(function() {
          c(g) && b({ inst: g });
        });
      },
      [u]
    ), l(f), f;
  }
  function c(u) {
    var h = u.getSnapshot;
    u = u.value;
    try {
      var f = h();
      return !n(u, f);
    } catch {
      return !0;
    }
  }
  function d(u, h) {
    return h();
  }
  var o = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? d : s;
  return b5.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : o, b5;
}
var U5 = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rS;
function $de() {
  return rS || (rS = 1, process.env.NODE_ENV !== "production" && function() {
    function e(f, p) {
      return f === p && (f !== 0 || 1 / f === 1 / p) || f !== f && p !== p;
    }
    function t(f, p) {
      o || i.startTransition === void 0 || (o = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var g = p();
      if (!u) {
        var b = p();
        a(g, b) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), u = !0);
      }
      b = l({
        inst: { value: g, getSnapshot: p }
      });
      var v = b[0].inst, U = b[1];
      return c(
        function() {
          v.value = g, v.getSnapshot = p, n(v) && U({ inst: v });
        },
        [f, g, p]
      ), s(
        function() {
          return n(v) && U({ inst: v }), f(function() {
            n(v) && U({ inst: v });
          });
        },
        [f]
      ), d(g), g;
    }
    function n(f) {
      var p = f.getSnapshot;
      f = f.value;
      try {
        var g = p();
        return !a(f, g);
      } catch {
        return !0;
      }
    }
    function r(f, p) {
      return p();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var i = pe, a = typeof Object.is == "function" ? Object.is : e, l = i.useState, s = i.useEffect, c = i.useLayoutEffect, d = i.useDebugValue, o = !1, u = !1, h = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? r : t;
    U5.useSyncExternalStore = i.useSyncExternalStore !== void 0 ? i.useSyncExternalStore : h, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), U5;
}
var iS;
function ML() {
  return iS || (iS = 1, process.env.NODE_ENV === "production" ? V1.exports = Ode() : V1.exports = $de()), V1.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aS;
function Fde() {
  if (aS) return g5;
  aS = 1;
  var e = pe, t = ML();
  function n(d, o) {
    return d === o && (d !== 0 || 1 / d === 1 / o) || d !== d && o !== o;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, a = e.useRef, l = e.useEffect, s = e.useMemo, c = e.useDebugValue;
  return g5.useSyncExternalStoreWithSelector = function(d, o, u, h, f) {
    var p = a(null);
    if (p.current === null) {
      var g = { hasValue: !1, value: null };
      p.current = g;
    } else g = p.current;
    p = s(
      function() {
        function v(E) {
          if (!U) {
            if (U = !0, y = E, E = h(E), f !== void 0 && g.hasValue) {
              var S = g.value;
              if (f(S, E))
                return w = S;
            }
            return w = E;
          }
          if (S = w, r(y, E)) return S;
          var _ = h(E);
          return f !== void 0 && f(S, _) ? (y = E, S) : (y = E, w = _);
        }
        var U = !1, y, w, x = u === void 0 ? null : u;
        return [
          function() {
            return v(o());
          },
          x === null ? void 0 : function() {
            return v(x());
          }
        ];
      },
      [o, u, h, f]
    );
    var b = i(d, p[0], p[1]);
    return l(
      function() {
        g.hasValue = !0, g.value = b;
      },
      [b]
    ), c(b), b;
  }, g5;
}
var v5 = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lS;
function zde() {
  return lS || (lS = 1, process.env.NODE_ENV !== "production" && function() {
    function e(d, o) {
      return d === o && (d !== 0 || 1 / d === 1 / o) || d !== d && o !== o;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var t = pe, n = ML(), r = typeof Object.is == "function" ? Object.is : e, i = n.useSyncExternalStore, a = t.useRef, l = t.useEffect, s = t.useMemo, c = t.useDebugValue;
    v5.useSyncExternalStoreWithSelector = function(d, o, u, h, f) {
      var p = a(null);
      if (p.current === null) {
        var g = { hasValue: !1, value: null };
        p.current = g;
      } else g = p.current;
      p = s(
        function() {
          function v(E) {
            if (!U) {
              if (U = !0, y = E, E = h(E), f !== void 0 && g.hasValue) {
                var S = g.value;
                if (f(S, E))
                  return w = S;
              }
              return w = E;
            }
            if (S = w, r(y, E))
              return S;
            var _ = h(E);
            return f !== void 0 && f(S, _) ? (y = E, S) : (y = E, w = _);
          }
          var U = !1, y, w, x = u === void 0 ? null : u;
          return [
            function() {
              return v(o());
            },
            x === null ? void 0 : function() {
              return v(x());
            }
          ];
        },
        [o, u, h, f]
      );
      var b = i(d, p[0], p[1]);
      return l(
        function() {
          g.hasValue = !0, g.value = b;
        },
        [b]
      ), c(b), b;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), v5;
}
process.env.NODE_ENV === "production" ? B7.exports = Fde() : B7.exports = zde();
var Bde = B7.exports;
const Hde = /* @__PURE__ */ ad(Bde), TL = {}, { useDebugValue: Wde } = pe, { useSyncExternalStoreWithSelector: Xde } = Hde;
let sS = !1;
const Vde = (e) => e;
function Gde(e, t = Vde, n) {
  (TL ? "production" : void 0) !== "production" && n && !sS && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), sS = !0);
  const r = Xde(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return Wde(r), r;
}
const oS = (e) => {
  (TL ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const t = typeof e == "function" ? Pde(e) : e, n = (r, i) => Gde(t, r, i);
  return Object.assign(n, t), n;
}, jde = (e) => e ? oS(e) : oS;
var cS, dS;
const uS = typeof window < "u" && ((cS = window.document) != null && cS.createElement || ((dS = window.navigator) == null ? void 0 : dS.product) === "ReactNative") ? pe.useLayoutEffect : pe.useEffect;
function Ka() {
  const e = jde((t) => ({
    current: new Array(),
    version: 0,
    set: t
  }));
  return {
    In: ({
      children: t
    }) => {
      const n = e((i) => i.set), r = e((i) => i.version);
      return uS(() => {
        n((i) => ({
          version: i.version + 1
        }));
      }, []), uS(() => (n(({
        current: i
      }) => ({
        current: [...i, t]
      })), () => n(({
        current: i
      }) => ({
        current: i.filter((a) => a !== t)
      }))), [t, r]), null;
    },
    Out: () => {
      const t = e((n) => n.current);
      return /* @__PURE__ */ pe.createElement(pe.Fragment, null, t);
    }
  };
}
function dr() {
  return dr = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, dr.apply(null, arguments);
}
function y5(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e == null || e(i), n === !1 || !i.defaultPrevented) return t == null ? void 0 : t(i);
  };
}
function Kde(e, t = []) {
  let n = [];
  function r(a, l) {
    const s = /* @__PURE__ */ Ci(l), c = n.length;
    n = [
      ...n,
      l
    ];
    function d(u) {
      const { scope: h, children: f, ...p } = u, g = (h == null ? void 0 : h[e][c]) || s, b = Ke(
        () => p,
        Object.values(p)
      );
      return /* @__PURE__ */ zt(g.Provider, {
        value: b
      }, f);
    }
    function o(u, h) {
      const f = (h == null ? void 0 : h[e][c]) || s, p = Er(f);
      if (p) return p;
      if (l !== void 0) return l;
      throw new Error(`\`${u}\` must be used within \`${a}\``);
    }
    return d.displayName = a + "Provider", [
      d,
      o
    ];
  }
  const i = () => {
    const a = n.map((l) => /* @__PURE__ */ Ci(l));
    return function(s) {
      const c = (s == null ? void 0 : s[e]) || a;
      return Ke(
        () => ({
          [`__scope${e}`]: {
            ...s,
            [e]: c
          }
        }),
        [
          s,
          c
        ]
      );
    };
  };
  return i.scopeName = e, [
    r,
    Yde(i, ...t)
  ];
}
function Yde(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map(
      (i) => ({
        useScope: i(),
        scopeName: i.scopeName
      })
    );
    return function(a) {
      const l = r.reduce((s, { useScope: c, scopeName: d }) => {
        const u = c(a)[`__scope${d}`];
        return {
          ...s,
          ...u
        };
      }, {});
      return Ke(
        () => ({
          [`__scope${t.scopeName}`]: l
        }),
        [
          l
        ]
      );
    };
  };
  return n.scopeName = t.scopeName, n;
}
function e0(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e == null || e(i), n === !1 || !i.defaultPrevented) return t == null ? void 0 : t(i);
  };
}
function qde(e, t = []) {
  let n = [];
  function r(a, l) {
    const s = /* @__PURE__ */ Ci(l), c = n.length;
    n = [
      ...n,
      l
    ];
    function d(u) {
      const { scope: h, children: f, ...p } = u, g = (h == null ? void 0 : h[e][c]) || s, b = Ke(
        () => p,
        Object.values(p)
      );
      return /* @__PURE__ */ zt(g.Provider, {
        value: b
      }, f);
    }
    function o(u, h) {
      const f = (h == null ? void 0 : h[e][c]) || s, p = Er(f);
      if (p) return p;
      if (l !== void 0) return l;
      throw new Error(`\`${u}\` must be used within \`${a}\``);
    }
    return d.displayName = a + "Provider", [
      d,
      o
    ];
  }
  const i = () => {
    const a = n.map((l) => /* @__PURE__ */ Ci(l));
    return function(s) {
      const c = (s == null ? void 0 : s[e]) || a;
      return Ke(
        () => ({
          [`__scope${e}`]: {
            ...s,
            [e]: c
          }
        }),
        [
          s,
          c
        ]
      );
    };
  };
  return i.scopeName = e, [
    r,
    Zde(i, ...t)
  ];
}
function Zde(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map(
      (i) => ({
        useScope: i(),
        scopeName: i.scopeName
      })
    );
    return function(a) {
      const l = r.reduce((s, { useScope: c, scopeName: d }) => {
        const u = c(a)[`__scope${d}`];
        return {
          ...s,
          ...u
        };
      }, {});
      return Ke(
        () => ({
          [`__scope${t.scopeName}`]: l
        }),
        [
          l
        ]
      );
    };
  };
  return n.scopeName = t.scopeName, n;
}
function Jde(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function IL(...e) {
  return (t) => e.forEach(
    (n) => Jde(n, t)
  );
}
function hS(...e) {
  return he(IL(...e), e);
}
const H7 = /* @__PURE__ */ dn((e, t) => {
  const { children: n, ...r } = e, i = Ir.toArray(n), a = i.find(e0e);
  if (a) {
    const l = a.props.children, s = i.map((c) => c === a ? Ir.count(l) > 1 ? Ir.only(null) : /* @__PURE__ */ Yi(l) ? l.props.children : null : c);
    return /* @__PURE__ */ zt(W7, dr({}, r, {
      ref: t
    }), /* @__PURE__ */ Yi(l) ? /* @__PURE__ */ nd(l, void 0, s) : null);
  }
  return /* @__PURE__ */ zt(W7, dr({}, r, {
    ref: t
  }), n);
});
H7.displayName = "Slot";
const W7 = /* @__PURE__ */ dn((e, t) => {
  const { children: n, ...r } = e;
  return /* @__PURE__ */ Yi(n) ? /* @__PURE__ */ nd(n, {
    ...t0e(r, n.props),
    ref: IL(t, n.ref)
  }) : Ir.count(n) > 1 ? Ir.only(null) : null;
});
W7.displayName = "SlotClone";
const Qde = ({ children: e }) => /* @__PURE__ */ zt(lg, null, e);
function e0e(e) {
  return /* @__PURE__ */ Yi(e) && e.type === Qde;
}
function t0e(e, t) {
  const n = {
    ...t
  };
  for (const r in t) {
    const i = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? i && a ? n[r] = (...s) => {
      a(...s), i(...s);
    } : i && (n[r] = i) : r === "style" ? n[r] = {
      ...i,
      ...a
    } : r === "className" && (n[r] = [
      i,
      a
    ].filter(Boolean).join(" "));
  }
  return {
    ...e,
    ...n
  };
}
function n0e(e) {
  const t = e + "CollectionProvider", [n, r] = qde(t), [i, a] = n(t, {
    collectionRef: {
      current: null
    },
    itemMap: /* @__PURE__ */ new Map()
  }), l = (f) => {
    const { scope: p, children: g } = f, b = pe.useRef(null), v = pe.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ pe.createElement(i, {
      scope: p,
      itemMap: v,
      collectionRef: b
    }, g);
  }, s = e + "CollectionSlot", c = /* @__PURE__ */ pe.forwardRef((f, p) => {
    const { scope: g, children: b } = f, v = a(s, g), U = hS(p, v.collectionRef);
    return /* @__PURE__ */ pe.createElement(H7, {
      ref: U
    }, b);
  }), d = e + "CollectionItemSlot", o = "data-radix-collection-item", u = /* @__PURE__ */ pe.forwardRef((f, p) => {
    const { scope: g, children: b, ...v } = f, U = pe.useRef(null), y = hS(p, U), w = a(d, g);
    return pe.useEffect(() => (w.itemMap.set(U, {
      ref: U,
      ...v
    }), () => void w.itemMap.delete(U))), /* @__PURE__ */ pe.createElement(H7, {
      [o]: "",
      ref: y
    }, b);
  });
  function h(f) {
    const p = a(e + "CollectionConsumer", f);
    return pe.useCallback(() => {
      const b = p.collectionRef.current;
      if (!b) return [];
      const v = Array.from(b.querySelectorAll(`[${o}]`));
      return Array.from(p.itemMap.values()).sort(
        (w, x) => v.indexOf(w.ref.current) - v.indexOf(x.ref.current)
      );
    }, [
      p.collectionRef,
      p.itemMap
    ]);
  }
  return [
    {
      Provider: l,
      Slot: c,
      ItemSlot: u
    },
    h,
    r
  ];
}
function r0e(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function AL(...e) {
  return (t) => e.forEach(
    (n) => r0e(n, t)
  );
}
function i0e(...e) {
  return he(AL(...e), e);
}
function a0e(e, t = []) {
  let n = [];
  function r(a, l) {
    const s = /* @__PURE__ */ Ci(l), c = n.length;
    n = [
      ...n,
      l
    ];
    function d(u) {
      const { scope: h, children: f, ...p } = u, g = (h == null ? void 0 : h[e][c]) || s, b = Ke(
        () => p,
        Object.values(p)
      );
      return /* @__PURE__ */ zt(g.Provider, {
        value: b
      }, f);
    }
    function o(u, h) {
      const f = (h == null ? void 0 : h[e][c]) || s, p = Er(f);
      if (p) return p;
      if (l !== void 0) return l;
      throw new Error(`\`${u}\` must be used within \`${a}\``);
    }
    return d.displayName = a + "Provider", [
      d,
      o
    ];
  }
  const i = () => {
    const a = n.map((l) => /* @__PURE__ */ Ci(l));
    return function(s) {
      const c = (s == null ? void 0 : s[e]) || a;
      return Ke(
        () => ({
          [`__scope${e}`]: {
            ...s,
            [e]: c
          }
        }),
        [
          s,
          c
        ]
      );
    };
  };
  return i.scopeName = e, [
    r,
    l0e(i, ...t)
  ];
}
function l0e(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map(
      (i) => ({
        useScope: i(),
        scopeName: i.scopeName
      })
    );
    return function(a) {
      const l = r.reduce((s, { useScope: c, scopeName: d }) => {
        const u = c(a)[`__scope${d}`];
        return {
          ...s,
          ...u
        };
      }, {});
      return Ke(
        () => ({
          [`__scope${t.scopeName}`]: l
        }),
        [
          l
        ]
      );
    };
  };
  return n.scopeName = t.scopeName, n;
}
const s0e = globalThis != null && globalThis.document ? Bn : () => {
}, o0e = J.useId || (() => {
});
let c0e = 0;
function d0e(e) {
  const [t, n] = J.useState(o0e());
  return s0e(() => {
    n(
      (r) => r ?? String(c0e++)
    );
  }, [
    e
  ]), t ? `radix-${t}` : "";
}
const NL = /* @__PURE__ */ dn((e, t) => {
  const { children: n, ...r } = e, i = Ir.toArray(n), a = i.find(h0e);
  if (a) {
    const l = a.props.children, s = i.map((c) => c === a ? Ir.count(l) > 1 ? Ir.only(null) : /* @__PURE__ */ Yi(l) ? l.props.children : null : c);
    return /* @__PURE__ */ zt(X7, dr({}, r, {
      ref: t
    }), /* @__PURE__ */ Yi(l) ? /* @__PURE__ */ nd(l, void 0, s) : null);
  }
  return /* @__PURE__ */ zt(X7, dr({}, r, {
    ref: t
  }), n);
});
NL.displayName = "Slot";
const X7 = /* @__PURE__ */ dn((e, t) => {
  const { children: n, ...r } = e;
  return /* @__PURE__ */ Yi(n) ? /* @__PURE__ */ nd(n, {
    ...f0e(r, n.props),
    ref: AL(t, n.ref)
  }) : Ir.count(n) > 1 ? Ir.only(null) : null;
});
X7.displayName = "SlotClone";
const u0e = ({ children: e }) => /* @__PURE__ */ zt(lg, null, e);
function h0e(e) {
  return /* @__PURE__ */ Yi(e) && e.type === u0e;
}
function f0e(e, t) {
  const n = {
    ...t
  };
  for (const r in t) {
    const i = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? i && a ? n[r] = (...s) => {
      a(...s), i(...s);
    } : i && (n[r] = i) : r === "style" ? n[r] = {
      ...i,
      ...a
    } : r === "className" && (n[r] = [
      i,
      a
    ].filter(Boolean).join(" "));
  }
  return {
    ...e,
    ...n
  };
}
const p0e = [
  "a",
  "button",
  "div",
  "h2",
  "h3",
  "img",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], DL = p0e.reduce((e, t) => {
  const n = /* @__PURE__ */ dn((r, i) => {
    const { asChild: a, ...l } = r, s = a ? NL : t;
    return Y(() => {
      window[Symbol.for("radix-ui")] = !0;
    }, []), /* @__PURE__ */ zt(s, dr({}, l, {
      ref: i
    }));
  });
  return n.displayName = `Primitive.${t}`, {
    ...e,
    [t]: n
  };
}, {});
function PU(e) {
  const t = de(e);
  return Y(() => {
    t.current = e;
  }), Ke(
    () => (...n) => {
      var r;
      return (r = t.current) === null || r === void 0 ? void 0 : r.call(t, ...n);
    },
    []
  );
}
function m0e({ prop: e, defaultProp: t, onChange: n = () => {
} }) {
  const [r, i] = g0e({
    defaultProp: t,
    onChange: n
  }), a = e !== void 0, l = a ? e : r, s = PU(n), c = he((d) => {
    if (a) {
      const u = typeof d == "function" ? d(e) : d;
      u !== e && s(u);
    } else i(d);
  }, [
    a,
    e,
    i,
    s
  ]);
  return [
    l,
    c
  ];
}
function g0e({ defaultProp: e, onChange: t }) {
  const n = Q(e), [r] = n, i = de(r), a = PU(t);
  return Y(() => {
    i.current !== r && (a(r), i.current = r);
  }, [
    r,
    i,
    a
  ]), n;
}
const b0e = /* @__PURE__ */ Ci(void 0);
function LL(e) {
  const t = Er(b0e);
  return e || t || "ltr";
}
const w5 = "rovingFocusGroup.onEntryFocus", U0e = {
  bubbles: !1,
  cancelable: !0
}, OU = "RovingFocusGroup", [V7, RL, v0e] = n0e(OU), [y0e, PL] = a0e(OU, [
  v0e
]), [w0e, x0e] = y0e(OU), E0e = /* @__PURE__ */ dn((e, t) => /* @__PURE__ */ zt(V7.Provider, {
  scope: e.__scopeRovingFocusGroup
}, /* @__PURE__ */ zt(V7.Slot, {
  scope: e.__scopeRovingFocusGroup
}, /* @__PURE__ */ zt(S0e, dr({}, e, {
  ref: t
}))))), S0e = /* @__PURE__ */ dn((e, t) => {
  const { __scopeRovingFocusGroup: n, orientation: r, loop: i = !1, dir: a, currentTabStopId: l, defaultCurrentTabStopId: s, onCurrentTabStopIdChange: c, onEntryFocus: d, ...o } = e, u = de(null), h = i0e(t, u), f = LL(a), [p = null, g] = m0e({
    prop: l,
    defaultProp: s,
    onChange: c
  }), [b, v] = Q(!1), U = PU(d), y = RL(n), w = de(!1), [x, E] = Q(0);
  return Y(() => {
    const S = u.current;
    if (S)
      return S.addEventListener(w5, U), () => S.removeEventListener(w5, U);
  }, [
    U
  ]), /* @__PURE__ */ zt(w0e, {
    scope: n,
    orientation: r,
    dir: f,
    loop: i,
    currentTabStopId: p,
    onItemFocus: he(
      (S) => g(S),
      [
        g
      ]
    ),
    onItemShiftTab: he(
      () => v(!0),
      []
    ),
    onFocusableItemAdd: he(
      () => E(
        (S) => S + 1
      ),
      []
    ),
    onFocusableItemRemove: he(
      () => E(
        (S) => S - 1
      ),
      []
    )
  }, /* @__PURE__ */ zt(DL.div, dr({
    tabIndex: b || x === 0 ? -1 : 0,
    "data-orientation": r
  }, o, {
    ref: h,
    style: {
      outline: "none",
      ...e.style
    },
    onMouseDown: e0(e.onMouseDown, () => {
      w.current = !0;
    }),
    onFocus: e0(e.onFocus, (S) => {
      const _ = !w.current;
      if (S.target === S.currentTarget && _ && !b) {
        const k = new CustomEvent(w5, U0e);
        if (S.currentTarget.dispatchEvent(k), !k.defaultPrevented) {
          const M = y().filter(
            (F) => F.focusable
          ), A = M.find(
            (F) => F.active
          ), L = M.find(
            (F) => F.id === p
          ), z = [
            A,
            L,
            ...M
          ].filter(Boolean).map(
            (F) => F.ref.current
          );
          OL(z);
        }
      }
      w.current = !1;
    }),
    onBlur: e0(
      e.onBlur,
      () => v(!1)
    )
  })));
}), _0e = "RovingFocusGroupItem", k0e = /* @__PURE__ */ dn((e, t) => {
  const { __scopeRovingFocusGroup: n, focusable: r = !0, active: i = !1, tabStopId: a, ...l } = e, s = d0e(), c = a || s, d = x0e(_0e, n), o = d.currentTabStopId === c, u = RL(n), { onFocusableItemAdd: h, onFocusableItemRemove: f } = d;
  return Y(() => {
    if (r)
      return h(), () => f();
  }, [
    r,
    h,
    f
  ]), /* @__PURE__ */ zt(V7.ItemSlot, {
    scope: n,
    id: c,
    focusable: r,
    active: i
  }, /* @__PURE__ */ zt(DL.span, dr({
    tabIndex: o ? 0 : -1,
    "data-orientation": d.orientation
  }, l, {
    ref: t,
    onMouseDown: e0(e.onMouseDown, (p) => {
      r ? d.onItemFocus(c) : p.preventDefault();
    }),
    onFocus: e0(
      e.onFocus,
      () => d.onItemFocus(c)
    ),
    onKeyDown: e0(e.onKeyDown, (p) => {
      if (p.key === "Tab" && p.shiftKey) {
        d.onItemShiftTab();
        return;
      }
      if (p.target !== p.currentTarget) return;
      const g = T0e(p, d.orientation, d.dir);
      if (g !== void 0) {
        p.preventDefault();
        let v = u().filter(
          (U) => U.focusable
        ).map(
          (U) => U.ref.current
        );
        if (g === "last") v.reverse();
        else if (g === "prev" || g === "next") {
          g === "prev" && v.reverse();
          const U = v.indexOf(p.currentTarget);
          v = d.loop ? I0e(v, U + 1) : v.slice(U + 1);
        }
        setTimeout(
          () => OL(v)
        );
      }
    })
  })));
}), C0e = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function M0e(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function T0e(e, t, n) {
  const r = M0e(e.key, n);
  if (!(t === "vertical" && [
    "ArrowLeft",
    "ArrowRight"
  ].includes(r)) && !(t === "horizontal" && [
    "ArrowUp",
    "ArrowDown"
  ].includes(r)))
    return C0e[r];
}
function OL(e) {
  const t = document.activeElement;
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return;
}
function I0e(e, t) {
  return e.map(
    (n, r) => e[(t + r) % e.length]
  );
}
const A0e = E0e, N0e = k0e;
function D0e(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function $L(...e) {
  return (t) => e.forEach(
    (n) => D0e(n, t)
  );
}
function L0e(...e) {
  return he($L(...e), e);
}
const G7 = globalThis != null && globalThis.document ? Bn : () => {
};
function R0e(e, t) {
  return lk((n, r) => {
    const i = t[n][r];
    return i ?? n;
  }, e);
}
const FL = (e) => {
  const { present: t, children: n } = e, r = P0e(t), i = typeof n == "function" ? n({
    present: r.isPresent
  }) : Ir.only(n), a = L0e(r.ref, i.ref);
  return typeof n == "function" || r.isPresent ? /* @__PURE__ */ nd(i, {
    ref: a
  }) : null;
};
FL.displayName = "Presence";
function P0e(e) {
  const [t, n] = Q(), r = de({}), i = de(e), a = de("none"), l = e ? "mounted" : "unmounted", [s, c] = R0e(l, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return Y(() => {
    const d = G1(r.current);
    a.current = s === "mounted" ? d : "none";
  }, [
    s
  ]), G7(() => {
    const d = r.current, o = i.current;
    if (o !== e) {
      const h = a.current, f = G1(d);
      e ? c("MOUNT") : f === "none" || (d == null ? void 0 : d.display) === "none" ? c("UNMOUNT") : c(o && h !== f ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [
    e,
    c
  ]), G7(() => {
    if (t) {
      const d = (u) => {
        const f = G1(r.current).includes(u.animationName);
        u.target === t && f && ga(
          () => c("ANIMATION_END")
        );
      }, o = (u) => {
        u.target === t && (a.current = G1(r.current));
      };
      return t.addEventListener("animationstart", o), t.addEventListener("animationcancel", d), t.addEventListener("animationend", d), () => {
        t.removeEventListener("animationstart", o), t.removeEventListener("animationcancel", d), t.removeEventListener("animationend", d);
      };
    } else
      c("ANIMATION_END");
  }, [
    t,
    c
  ]), {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(s),
    ref: he((d) => {
      d && (r.current = getComputedStyle(d)), n(d);
    }, [])
  };
}
function G1(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
const zL = /* @__PURE__ */ dn((e, t) => {
  const { children: n, ...r } = e, i = Ir.toArray(n), a = i.find($0e);
  if (a) {
    const l = a.props.children, s = i.map((c) => c === a ? Ir.count(l) > 1 ? Ir.only(null) : /* @__PURE__ */ Yi(l) ? l.props.children : null : c);
    return /* @__PURE__ */ zt(j7, dr({}, r, {
      ref: t
    }), /* @__PURE__ */ Yi(l) ? /* @__PURE__ */ nd(l, void 0, s) : null);
  }
  return /* @__PURE__ */ zt(j7, dr({}, r, {
    ref: t
  }), n);
});
zL.displayName = "Slot";
const j7 = /* @__PURE__ */ dn((e, t) => {
  const { children: n, ...r } = e;
  return /* @__PURE__ */ Yi(n) ? /* @__PURE__ */ nd(n, {
    ...F0e(r, n.props),
    ref: $L(t, n.ref)
  }) : Ir.count(n) > 1 ? Ir.only(null) : null;
});
j7.displayName = "SlotClone";
const O0e = ({ children: e }) => /* @__PURE__ */ zt(lg, null, e);
function $0e(e) {
  return /* @__PURE__ */ Yi(e) && e.type === O0e;
}
function F0e(e, t) {
  const n = {
    ...t
  };
  for (const r in t) {
    const i = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? i && a ? n[r] = (...s) => {
      a(...s), i(...s);
    } : i && (n[r] = i) : r === "style" ? n[r] = {
      ...i,
      ...a
    } : r === "className" && (n[r] = [
      i,
      a
    ].filter(Boolean).join(" "));
  }
  return {
    ...e,
    ...n
  };
}
const z0e = [
  "a",
  "button",
  "div",
  "h2",
  "h3",
  "img",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], C2 = z0e.reduce((e, t) => {
  const n = /* @__PURE__ */ dn((r, i) => {
    const { asChild: a, ...l } = r, s = a ? zL : t;
    return Y(() => {
      window[Symbol.for("radix-ui")] = !0;
    }, []), /* @__PURE__ */ zt(s, dr({}, l, {
      ref: i
    }));
  });
  return n.displayName = `Primitive.${t}`, {
    ...e,
    [t]: n
  };
}, {});
function BL(e) {
  const t = de(e);
  return Y(() => {
    t.current = e;
  }), Ke(
    () => (...n) => {
      var r;
      return (r = t.current) === null || r === void 0 ? void 0 : r.call(t, ...n);
    },
    []
  );
}
function B0e({ prop: e, defaultProp: t, onChange: n = () => {
} }) {
  const [r, i] = H0e({
    defaultProp: t,
    onChange: n
  }), a = e !== void 0, l = a ? e : r, s = BL(n), c = he((d) => {
    if (a) {
      const u = typeof d == "function" ? d(e) : d;
      u !== e && s(u);
    } else i(d);
  }, [
    a,
    e,
    i,
    s
  ]);
  return [
    l,
    c
  ];
}
function H0e({ defaultProp: e, onChange: t }) {
  const n = Q(e), [r] = n, i = de(r), a = BL(t);
  return Y(() => {
    i.current !== r && (a(r), i.current = r);
  }, [
    r,
    i,
    a
  ]), n;
}
const W0e = J.useId || (() => {
});
let X0e = 0;
function V0e(e) {
  const [t, n] = J.useState(W0e());
  return G7(() => {
    n(
      (r) => r ?? String(X0e++)
    );
  }, [
    e
  ]), e || (t ? `radix-${t}` : "");
}
const HL = "Tabs", [G0e, k4e] = Kde(HL, [
  PL
]), WL = PL(), [j0e, $U] = G0e(HL), K0e = /* @__PURE__ */ dn((e, t) => {
  const { __scopeTabs: n, value: r, onValueChange: i, defaultValue: a, orientation: l = "horizontal", dir: s, activationMode: c = "automatic", ...d } = e, o = LL(s), [u, h] = B0e({
    prop: r,
    onChange: i,
    defaultProp: a
  });
  return /* @__PURE__ */ zt(j0e, {
    scope: n,
    baseId: V0e(),
    value: u,
    onValueChange: h,
    orientation: l,
    dir: o,
    activationMode: c
  }, /* @__PURE__ */ zt(C2.div, dr({
    dir: o,
    "data-orientation": l
  }, d, {
    ref: t
  })));
}), Y0e = "TabsList", q0e = /* @__PURE__ */ dn((e, t) => {
  const { __scopeTabs: n, loop: r = !0, ...i } = e, a = $U(Y0e, n), l = WL(n);
  return /* @__PURE__ */ zt(A0e, dr({
    asChild: !0
  }, l, {
    orientation: a.orientation,
    dir: a.dir,
    loop: r
  }), /* @__PURE__ */ zt(C2.div, dr({
    role: "tablist",
    "aria-orientation": a.orientation
  }, i, {
    ref: t
  })));
}), Z0e = "TabsTrigger", J0e = /* @__PURE__ */ dn((e, t) => {
  const { __scopeTabs: n, value: r, disabled: i = !1, ...a } = e, l = $U(Z0e, n), s = WL(n), c = XL(l.baseId, r), d = VL(l.baseId, r), o = r === l.value;
  return /* @__PURE__ */ zt(N0e, dr({
    asChild: !0
  }, s, {
    focusable: !i,
    active: o
  }), /* @__PURE__ */ zt(C2.button, dr({
    type: "button",
    role: "tab",
    "aria-selected": o,
    "aria-controls": d,
    "data-state": o ? "active" : "inactive",
    "data-disabled": i ? "" : void 0,
    disabled: i,
    id: c
  }, a, {
    ref: t,
    onMouseDown: y5(e.onMouseDown, (u) => {
      !i && u.button === 0 && u.ctrlKey === !1 ? l.onValueChange(r) : u.preventDefault();
    }),
    onKeyDown: y5(e.onKeyDown, (u) => {
      [
        " ",
        "Enter"
      ].includes(u.key) && l.onValueChange(r);
    }),
    onFocus: y5(e.onFocus, () => {
      const u = l.activationMode !== "manual";
      !o && !i && u && l.onValueChange(r);
    })
  })));
}), Q0e = "TabsContent", eue = /* @__PURE__ */ dn((e, t) => {
  const { __scopeTabs: n, value: r, forceMount: i, children: a, ...l } = e, s = $U(Q0e, n), c = XL(s.baseId, r), d = VL(s.baseId, r), o = r === s.value, u = de(o);
  return Y(() => {
    const h = requestAnimationFrame(
      () => u.current = !1
    );
    return () => cancelAnimationFrame(h);
  }, []), /* @__PURE__ */ zt(
    FL,
    {
      present: i || o
    },
    ({ present: h }) => /* @__PURE__ */ zt(C2.div, dr({
      "data-state": o ? "active" : "inactive",
      "data-orientation": s.orientation,
      role: "tabpanel",
      "aria-labelledby": c,
      hidden: !h,
      id: d,
      tabIndex: 0
    }, l, {
      ref: t,
      style: {
        ...e.style,
        animationDuration: u.current ? "0s" : void 0
      }
    }), h && a)
  );
});
function XL(e, t) {
  return `${e}-trigger-${t}`;
}
function VL(e, t) {
  return `${e}-content-${t}`;
}
const GL = K0e, jL = q0e, KL = J0e, YL = eue;
var tue = "Expected a function", fS = NaN, nue = "[object Symbol]", rue = /^\s+|\s+$/g, iue = /^[-+]0x[0-9a-f]+$/i, aue = /^0b[01]+$/i, lue = /^0o[0-7]+$/i, sue = parseInt, oue = typeof ya == "object" && ya && ya.Object === Object && ya, cue = typeof self == "object" && self && self.Object === Object && self, due = oue || cue || Function("return this")(), uue = Object.prototype, hue = uue.toString, fue = Math.max, pue = Math.min, x5 = function() {
  return due.Date.now();
};
function mue(e, t, n) {
  var r, i, a, l, s, c, d = 0, o = !1, u = !1, h = !0;
  if (typeof e != "function")
    throw new TypeError(tue);
  t = pS(t) || 0, K7(n) && (o = !!n.leading, u = "maxWait" in n, a = u ? fue(pS(n.maxWait) || 0, t) : a, h = "trailing" in n ? !!n.trailing : h);
  function f(E) {
    var S = r, _ = i;
    return r = i = void 0, d = E, l = e.apply(_, S), l;
  }
  function p(E) {
    return d = E, s = setTimeout(v, t), o ? f(E) : l;
  }
  function g(E) {
    var S = E - c, _ = E - d, k = t - S;
    return u ? pue(k, a - _) : k;
  }
  function b(E) {
    var S = E - c, _ = E - d;
    return c === void 0 || S >= t || S < 0 || u && _ >= a;
  }
  function v() {
    var E = x5();
    if (b(E))
      return U(E);
    s = setTimeout(v, g(E));
  }
  function U(E) {
    return s = void 0, h && r ? f(E) : (r = i = void 0, l);
  }
  function y() {
    s !== void 0 && clearTimeout(s), d = 0, r = c = i = s = void 0;
  }
  function w() {
    return s === void 0 ? l : U(x5());
  }
  function x() {
    var E = x5(), S = b(E);
    if (r = arguments, i = this, c = E, S) {
      if (s === void 0)
        return p(c);
      if (u)
        return s = setTimeout(v, t), f(c);
    }
    return s === void 0 && (s = setTimeout(v, t)), l;
  }
  return x.cancel = y, x.flush = w, x;
}
function K7(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function gue(e) {
  return !!e && typeof e == "object";
}
function bue(e) {
  return typeof e == "symbol" || gue(e) && hue.call(e) == nue;
}
function pS(e) {
  if (typeof e == "number")
    return e;
  if (bue(e))
    return fS;
  if (K7(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = K7(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(rue, "");
  var n = aue.test(e);
  return n || lue.test(e) ? sue(e.slice(2), n ? 2 : 8) : iue.test(e) ? fS : +e;
}
var Uue = mue;
const vue = /* @__PURE__ */ ad(Uue);
function yue(e, t, n, r) {
  Object.defineProperty(e, t, { get: n, set: r, enumerable: !0, configurable: !0 });
}
var wue = {};
yue(wue, "LaserPointer", () => qm);
function Pn([e, t, n], [r, i, a]) {
  return [
    e + r,
    t + i,
    n + a
  ];
}
function Ju([e, t, n], [r, i, a]) {
  return [
    e - r,
    t - i,
    n - a
  ];
}
function jn([e, t, n], r) {
  return [
    e * r,
    t * r,
    n * r
  ];
}
function kd([e, t, n]) {
  return [
    e / Math.sqrt(e ** 2 + t ** 2),
    t / Math.sqrt(e ** 2 + t ** 2),
    n
  ];
}
function Ar([e, t, n], r) {
  return [
    Math.cos(r) * e - Math.sin(r) * t,
    Math.sin(r) * e + Math.cos(r) * t,
    n
  ];
}
function xue(e, t, n) {
  return Pn(e, jn(Ju(t, e), n));
}
function mS(e, t, n) {
  return Math.atan2(n[1] - e[1], n[0] - e[0]) - Math.atan2(t[1] - e[1], t[0] - e[0]);
}
function gS(e) {
  return Math.atan2(Math.sin(e), Math.cos(e));
}
function bS([e, t]) {
  return Math.sqrt(e ** 2 + t ** 2);
}
function t0([e, t], [n, r]) {
  return Math.sqrt((n - e) ** 2 + (r - t) ** 2);
}
function Eue(e) {
  if (e.length < 2) return 0;
  let t = 0;
  for (let n = 1; n <= e.length - 1; n++) t += t0(e[n - 1], e[n]);
  return t += t0(e[e.length - 2], e[e.length - 1]), t;
}
const Sue = (e, t, n) => Math.max(t, Math.min(n, e));
function _ue(e, t, n) {
  const r = t0(t, n);
  if (r === 0) return t0(e, t);
  const i = Sue(((e[0] - t[0]) * (n[0] - t[0]) + (e[1] - t[1]) * (n[1] - t[1])) / r ** 2, 0, 1), a = [
    t[0] + i * (n[0] - t[0]),
    t[1] + i * (n[1] - t[1]),
    e[2]
  ];
  return t0(a, e);
}
function Ym(e, t) {
  if (t === 0 || e.length <= 2) return e;
  const n = e[0], r = e[e.length - 1], [i, a] = e.reduce(([l, s], c, d) => {
    const o = _ue(c, n, r);
    return o > l ? [
      o,
      d
    ] : [
      l,
      s
    ];
  }, [
    0,
    -1
  ]);
  if (i >= t) {
    const l = e[a];
    return [
      ...Ym([
        n,
        ...e.slice(1, a),
        l
      ], t).slice(0, -1),
      l,
      ...Ym([
        l,
        ...e.slice(a, -1),
        r
      ], t).slice(1)
    ];
  } else return [
    n,
    r
  ];
}
const Zs = class Zs {
  constructor(t) {
    this.originalPoints = [], this.stablePoints = [], this.tailPoints = [], this.isFresh = !0, this.options = Object.assign({}, Zs.defaults, t);
  }
  get lastPoint() {
    return this.tailPoints[this.tailPoints.length - 1] ?? this.stablePoints[this.stablePoints.length - 1];
  }
  addPoint(t) {
    const n = this.originalPoints[this.originalPoints.length - 1];
    if (!(n && n[0] === t[0] && n[1] === t[1])) {
      if (this.originalPoints.push(t), this.isFresh) {
        this.isFresh = !1, this.stablePoints.push(t);
        return;
      }
      this.options.streamline > 0 && (t = xue(this.lastPoint, t, 1 - this.options.streamline)), this.tailPoints.push(t), Eue(this.tailPoints) > Zs.constants.maxTailLength && this.stabilizeTail();
    }
  }
  close() {
    this.stabilizeTail();
  }
  stabilizeTail() {
    if (this.options.simplify > 0 && this.options.simplifyPhase == "tail") throw new Error("Not implemented yet");
    this.stablePoints.push(...this.tailPoints), this.tailPoints = [];
  }
  getSize(t, n, r, i, a) {
    return (t ?? this.options.size) * this.options.sizeMapping({
      pressure: n,
      runningLength: a,
      currentIndex: r,
      totalLength: i
    });
  }
  getStrokeOutline(t) {
    if (this.isFresh) return [];
    let n = [
      ...this.stablePoints,
      ...this.tailPoints
    ];
    this.options.simplify > 0 && this.options.simplifyPhase === "input" && (n = Ym(n, this.options.simplify));
    const r = n.length;
    if (r === 0) return [];
    if (r === 1) {
      const S = n[0], _ = this.getSize(t, S[2], 0, r, 0);
      if (_ < 0.5) return [];
      const k = [];
      for (let M = 0; M <= Math.PI * 2; M += Math.PI / 16) k.push(Pn(S, jn(Ar([
        1,
        0,
        0
      ], M), _)));
      return k.push(Pn(S, jn([
        1,
        0,
        0
      ], this.getSize(t, S[2], 0, r, 0)))), k;
    }
    if (r === 2) {
      const S = n[0], _ = n[1], k = this.getSize(t, S[2], 0, r, 0), M = this.getSize(t, _[2], 0, r, 0);
      if (k < 0.5 || M < 0.5) return [];
      const A = [], L = mS(S, [
        S[0],
        S[1] - 100,
        S[2]
      ], _);
      for (let R = L; R <= Math.PI + L; R += Math.PI / 16) A.push(Pn(S, jn(Ar([
        1,
        0,
        0
      ], R), k)));
      for (let R = Math.PI + L; R <= Math.PI * 2 + L; R += Math.PI / 16) A.push(Pn(_, jn(Ar([
        1,
        0,
        0
      ], R), M)));
      return A.push(A[0]), A;
    }
    const i = [], a = [];
    let l = 0, s = 0, c = 0, d = 0;
    for (let S = 1; S < r - 1; S++) {
      const _ = n[S - 1], k = n[S], M = n[S + 1];
      let A = k[2];
      const L = t0(_, k);
      d += L, l = s + (L - s) * 0.2;
      const R = this.getSize(t, A, S, r, d);
      if (R === 0) {
        c = S + 1;
        continue;
      }
      const z = kd(Ju(_, k)), F = kd(Ju(M, k)), W = Ar(z, Math.PI / 2), B = Ar(z, -Math.PI / 2), j = Ar(F, Math.PI / 2), V = Ar(F, -Math.PI / 2), q = Pn(k, jn(W, R)), oe = Pn(k, jn(B, R)), Ue = Pn(k, jn(j, R)), fe = Pn(k, jn(V, R)), Pe = Pn(W, V), ze = Pn(B, j), Oe = Pn(k, jn(bS(Pe) === 0 ? z : kd(Pe), R)), Be = Pn(k, jn(bS(ze) === 0 ? F : kd(ze), R)), qe = gS(mS(k, _, M)), At = Zs.constants.cornerDetectionMaxAngle / 180 * Math.PI * Zs.constants.cornerDetectionVariance(l);
      if (Math.abs(qe) < At) {
        const Je = Math.abs(gS(Math.PI - qe));
        if (Je === 0) continue;
        if (qe < 0) {
          a.push(oe, Be);
          for (let mt = 0; mt <= Je; mt += Je / 4) i.push(Pn(k, Ar(jn(W, R), mt)));
          for (let mt = Je; mt >= 0; mt -= Je / 4) a.push(Pn(k, Ar(jn(W, R), mt)));
          a.push(Be, Ue);
        } else {
          i.push(q, Oe);
          for (let mt = 0; mt <= Je; mt += Je / 4) a.push(Pn(k, Ar(jn(W, -R), -mt)));
          for (let mt = Je; mt >= 0; mt -= Je / 4) i.push(Pn(k, Ar(jn(W, -R), -mt)));
          i.push(Oe, fe);
        }
      } else
        i.push(Oe), a.push(Be);
      s = l;
    }
    if (c >= r - 2)
      if (this.options.keepHead) {
        const S = n[r - 1], _ = [];
        for (let k = 0; k <= Math.PI * 2; k += Math.PI / 16) _.push(Pn(S, jn(Ar([
          1,
          0,
          0
        ], k), this.options.size)));
        return _.push(Pn(S, jn([
          1,
          0,
          0
        ], this.options.size))), _;
      } else return [];
    const o = n[c], u = n[c + 1], h = n[r - 2], f = n[r - 1], p = kd(Ju(u, o)), g = kd(Ju(h, f)), b = Ar(p, -Math.PI / 2), v = Ar(g, Math.PI / 2), U = this.getSize(t, o[2], 0, r, 0), y = [], w = this.options.keepHead ? this.options.size : this.getSize(t, h[2], r - 2, r, d), x = [];
    if (U > 1) {
      for (let S = 0; S <= Math.PI; S += Math.PI / 16) y.unshift(Pn(o, Ar(jn(b, U), -S)));
      y.unshift(Pn(o, jn(b, -U)));
    } else y.push(o);
    for (let S = 0; S <= Math.PI * 3; S += Math.PI / 16) x.push(Pn(f, Ar(jn(v, -w), -S)));
    const E = [
      ...y,
      ...i,
      ...x.reverse(),
      ...a.reverse()
    ];
    return y.length > 0 && E.push(y[0]), this.options.simplify > 0 && this.options.simplifyPhase === "output" ? Ym(E, this.options.simplify) : E;
  }
};
Zs.defaults = {
  size: 2,
  streamline: 0.45,
  simplify: 0.1,
  simplifyPhase: "output",
  keepHead: !1,
  sizeMapping: () => 1
}, Zs.constants = {
  cornerDetectionMaxAngle: 75,
  cornerDetectionVariance: (t) => t > 35 ? 0.5 : 1,
  maxTailLength: 50
};
let qm = Zs;
var qL = TD(), { useAtom: Dn, useSetAtom: M2, useAtomValue: ZL, useStore: C4e } = qL, kue = qL.Provider, _a = wU(), Cue = qW({ "./locales/ar-SA.json": () => import("./ar-SA-G6X2FPQ2-CjQ_CveH.js"), "./locales/az-AZ.json": () => import("./az-AZ-76LH7QW2-Dt9AOy3J.js"), "./locales/bg-BG.json": () => import("./bg-BG-XCXSNQG7-BqwOQ63M.js"), "./locales/bn-BD.json": () => import("./bn-BD-2XOGV67Q-D4OhKwQp.js"), "./locales/ca-ES.json": () => import("./ca-ES-6MX7JW3Y-D3IsaxIs.js"), "./locales/cs-CZ.json": () => import("./cs-CZ-2BRQDIVT-DyCxzSfv.js"), "./locales/da-DK.json": () => import("./da-DK-5WZEPLOC-DFmmrTtg.js"), "./locales/de-DE.json": () => import("./de-DE-XR44H4JA-B6Uom52q.js"), "./locales/el-GR.json": () => import("./el-GR-BZB4AONW-CbbG1VcX.js"), "./locales/en.json": () => import("./en-B4ZKOASM-bjPOFk3l.js"), "./locales/es-ES.json": () => import("./es-ES-U4NZUMDT-xnZ06HQ5.js"), "./locales/eu-ES.json": () => import("./eu-ES-A7QVB2H4-CUAGTUDM.js"), "./locales/fa-IR.json": () => import("./fa-IR-HGAKTJCU-BkBbnsim.js"), "./locales/fi-FI.json": () => import("./fi-FI-Z5N7JZ37-DRj7OAes.js"), "./locales/fr-FR.json": () => import("./fr-FR-RHASNOE6-BoYrb9y1.js"), "./locales/gl-ES.json": () => import("./gl-ES-HMX3MZ6V-CLkRWzeO.js"), "./locales/he-IL.json": () => import("./he-IL-6SHJWFNN-CDkUqYH3.js"), "./locales/hi-IN.json": () => import("./hi-IN-IWLTKZ5I-BubESc9E.js"), "./locales/hu-HU.json": () => import("./hu-HU-A5ZG7DT2-Bdfjv1T4.js"), "./locales/id-ID.json": () => import("./id-ID-SAP4L64H-Jskn7L4e.js"), "./locales/it-IT.json": () => import("./it-IT-JPQ66NNP-CowS-1i6.js"), "./locales/ja-JP.json": () => import("./ja-JP-DBVTYXUO-DJ3lq_0R.js"), "./locales/kaa.json": () => import("./kaa-6HZHGXH3-Q-XMo6QK.js"), "./locales/kab-KAB.json": () => import("./kab-KAB-ZGHBKWFO-D_h-pHFL.js"), "./locales/kk-KZ.json": () => import("./kk-KZ-P5N5QNE5-CEeh6z4Y.js"), "./locales/km-KH.json": () => import("./km-KH-HSX4SM5Z-DvgRcA4J.js"), "./locales/ko-KR.json": () => import("./ko-KR-MTYHY66A-B9hvKmVr.js"), "./locales/ku-TR.json": () => import("./ku-TR-6OUDTVRD-oNdsyQTF.js"), "./locales/lt-LT.json": () => import("./lt-LT-XHIRWOB4-WM93XGuo.js"), "./locales/lv-LV.json": () => import("./lv-LV-5QDEKY6T-4mi6x1jT.js"), "./locales/mr-IN.json": () => import("./mr-IN-CRQNXWMA-Dmci7DlU.js"), "./locales/my-MM.json": () => import("./my-MM-5M5IBNSE-O3FT-nwz.js"), "./locales/nb-NO.json": () => import("./nb-NO-T6EIAALU-Ras9pMUT.js"), "./locales/nl-NL.json": () => import("./nl-NL-IS3SIHDZ-DgwI0ktP.js"), "./locales/nn-NO.json": () => import("./nn-NO-6E72VCQL-CFpX2Nsf.js"), "./locales/oc-FR.json": () => import("./oc-FR-POXYY2M6-CtNZllGY.js"), "./locales/pa-IN.json": () => import("./pa-IN-N4M65BXN-jD9nEESa.js"), "./locales/percentages.json": () => import("./percentages-BXMCSKIN-D-zVa7GX.js"), "./locales/pl-PL.json": () => import("./pl-PL-T2D74RX3-fhsEFVc_.js"), "./locales/pt-BR.json": () => import("./pt-BR-5N22H2LF-BYlju5R3.js"), "./locales/pt-PT.json": () => import("./pt-PT-UZXXM6DQ-BnUjBpIQ.js"), "./locales/ro-RO.json": () => import("./ro-RO-JPDTUUEW-C_kgpS5n.js"), "./locales/ru-RU.json": () => import("./ru-RU-B4JR7IUQ-JZkx2rfq.js"), "./locales/si-LK.json": () => import("./si-LK-N5RQ5JYF-DBOK5gvQ.js"), "./locales/sk-SK.json": () => import("./sk-SK-C5VTKIMK-4ReBwqaK.js"), "./locales/sl-SI.json": () => import("./sl-SI-NN7IZMDC-DH0IqCfT.js"), "./locales/sv-SE.json": () => import("./sv-SE-XGPEYMSR-Bg2ehwj9.js"), "./locales/ta-IN.json": () => import("./ta-IN-2NMHFXQM-BaeU5mKf.js"), "./locales/th-TH.json": () => import("./th-TH-HPSO5L25-e7qoMBgd.js"), "./locales/tr-TR.json": () => import("./tr-TR-DEFEU3FU-Ca_-kA6x.js"), "./locales/uk-UA.json": () => import("./uk-UA-QMV73CPH-b-ZSscn9.js"), "./locales/vi-VN.json": () => import("./vi-VN-M7AON7JQ-CsuG-UKk.js"), "./locales/zh-CN.json": () => import("./zh-CN-LNUGB5OW-B0JsSFQ4.js"), "./locales/zh-HK.json": () => import("./zh-HK-E62DVLB3-CfEhR3Mt.js"), "./locales/zh-TW.json": () => import("./zh-TW-RAJ6MFWO-bvYHaAjX.js") }), Mue = 85, su = { code: "en", label: "English" }, FU = [su, ...[{ code: "ar-SA", label: "العربية", rtl: !0 }, { code: "bg-BG", label: "Български" }, { code: "ca-ES", label: "Català" }, { code: "cs-CZ", label: "Česky" }, { code: "de-DE", label: "Deutsch" }, { code: "el-GR", label: "Ελληνικά" }, { code: "es-ES", label: "Español" }, { code: "eu-ES", label: "Euskara" }, { code: "fa-IR", label: "فارسی", rtl: !0 }, { code: "fi-FI", label: "Suomi" }, { code: "fr-FR", label: "Français" }, { code: "gl-ES", label: "Galego" }, { code: "he-IL", label: "עברית", rtl: !0 }, { code: "hi-IN", label: "हिन्दी" }, { code: "hu-HU", label: "Magyar" }, { code: "id-ID", label: "Bahasa Indonesia" }, { code: "it-IT", label: "Italiano" }, { code: "ja-JP", label: "日本語" }, { code: "kab-KAB", label: "Taqbaylit" }, { code: "kk-KZ", label: "Қазақ тілі" }, { code: "ko-KR", label: "한국어" }, { code: "ku-TR", label: "Kurdî" }, { code: "lt-LT", label: "Lietuvių" }, { code: "lv-LV", label: "Latviešu" }, { code: "my-MM", label: "Burmese" }, { code: "nb-NO", label: "Norsk bokmål" }, { code: "nl-NL", label: "Nederlands" }, { code: "nn-NO", label: "Norsk nynorsk" }, { code: "oc-FR", label: "Occitan" }, { code: "pa-IN", label: "ਪੰਜਾਬੀ" }, { code: "pl-PL", label: "Polski" }, { code: "pt-BR", label: "Português Brasileiro" }, { code: "pt-PT", label: "Português" }, { code: "ro-RO", label: "Română" }, { code: "ru-RU", label: "Русский" }, { code: "sk-SK", label: "Slovenčina" }, { code: "sv-SE", label: "Svenska" }, { code: "sl-SI", label: "Slovenščina" }, { code: "tr-TR", label: "Türkçe" }, { code: "uk-UA", label: "Українська" }, { code: "zh-CN", label: "简体中文" }, { code: "zh-TW", label: "繁體中文" }, { code: "vi-VN", label: "Tiếng Việt" }, { code: "mr-IN", label: "मराठी" }].filter((e) => Lse[e.code] >= Mue).sort((e, t) => e.label > t.label ? 1 : -1)], Zm = "__test__";
st.DEV && FU.unshift({ code: Zm, label: "test language" }, { code: `${Zm}.rtl`, label: "‪test language (rtl)‬", rtl: !0 });
var Vd = su, Mp = {}, JL = async (e) => {
  if (Vd = e, document.documentElement.dir = Vd.rtl ? "rtl" : "ltr", document.documentElement.lang = Vd.code, e.code.startsWith(Zm)) Mp = {};
  else try {
    Mp = await Cue(`./locales/${Vd.code}.json`);
  } catch (t) {
    console.error(`Failed to load language ${e.code}:`, t.message), Mp = xD;
  }
  _a.set(QL, e.code);
}, df = () => Vd, US = (e, t) => {
  for (let n = 0; n < t.length; ++n) {
    let r = t[n];
    if (e[r] === void 0) return;
    e = e[r];
  }
  if (typeof e == "string") return e;
}, N = (e, t, n) => {
  if (Vd.code.startsWith(Zm)) return `‪[[${t ? `${e}(${JSON.stringify(t).slice(1, -1)})` : e}]]‬`;
  let r = e.split("."), i = US(Mp, r) || US(xD, r) || n;
  if (i === void 0) {
    let a = `Can't find translation for ${e}`;
    return console.warn(a), "";
  }
  if (t) for (let a in t) i = i.replace(`{{${a}}}`, String(t[a]));
  return i;
}, QL = Sr(su.code), Fr = () => {
  let e = ZL(QL);
  return { t: N, langCode: e };
}, Tue = ({ size: e = "1em", circleWidth: t = 8, synchronized: n = !1, className: r = "" }) => {
  let i = -(pe.useRef(Date.now()).current % 1600);
  return m("div", { className: `Spinner ${r}`, children: m("svg", { viewBox: "0 0 100 100", style: { width: e, height: e, "--spinner-delay": n ? `${i}ms` : 0 }, children: m("circle", { cx: "50", cy: "50", r: 50 - t / 2, strokeWidth: t, fill: "none", strokeMiterlimit: "10" }) }) });
}, Cs = Tue, eR = ({ delay: e, theme: t }) => {
  let [n, r] = Q(!!e);
  return Y(() => {
    if (!e) return;
    let i = setTimeout(() => {
      r(!1);
    }, e);
    return () => clearTimeout(i);
  }, [e]), n ? null : D("div", { className: Me("LoadingMessage", { "LoadingMessage--dark": t === gt.DARK }), children: [m("div", { children: m(Cs, {}) }), m("div", { className: "LoadingMessage-text", children: N("labels.loadingScene") })] });
}, Iue = (e) => {
  let [t, n] = Q(!0);
  return Y(() => {
    let r = async () => {
      await JL(i), n(!1);
    }, i = FU.find((a) => a.code === e.langCode) || su;
    r();
  }, [e.langCode]), t ? m(eR, { theme: e.theme }) : e.children;
}, yt = pe.forwardRef(({ size: e = "medium", visible: t = !0, className: n = "", ...r }, i) => {
  let { id: a } = Ol(), l = pe.useRef(null);
  pe.useImperativeHandle(i, () => l.current);
  let s = `ToolIcon_size_${e}`, [c, d] = Q(!1), o = de(!0), u = async (f) => {
    var g;
    let p = "onClick" in r && ((g = r.onClick) == null ? void 0 : g.call(r, f));
    if (Hf(p)) try {
      d(!0), await p;
    } catch (b) {
      if (b instanceof r2) console.warn(b);
      else throw b;
    } finally {
      o.current && d(!1);
    }
  };
  Y(() => (o.current = !0, () => {
    o.current = !1;
  }), []);
  let h = de(null);
  if (r.type === "button" || r.type === "icon" || r.type === "submit") {
    let f = r.type === "icon" ? "button" : r.type;
    return D("button", { className: Me("ToolIcon_type_button", s, n, t && !r.hidden ? "ToolIcon_type_button--show" : "ToolIcon_type_button--hide", { ToolIcon: !r.hidden, "ToolIcon--selected": r.selected, "ToolIcon--plain": r.type === "icon" }), style: r.style, "data-testid": r["data-testid"], hidden: r.hidden, title: r.title, "aria-label": r["aria-label"], type: f, onClick: u, ref: l, disabled: c || r.isLoading || !!r.disabled, children: [(r.icon || r.label) && D("div", { className: "ToolIcon__icon", "aria-hidden": "true", "aria-disabled": !!r.disabled, children: [r.icon || r.label, r.keyBindingLabel && m("span", { className: "ToolIcon__keybinding", children: r.keyBindingLabel }), r.isLoading && m(Cs, {})] }), r.showAriaLabel && D("div", { className: "ToolIcon__label", children: [r["aria-label"], " ", c && m(Cs, {})] }), r.children] });
  }
  return D("label", { className: Me("ToolIcon", n), title: r.title, onPointerDown: (f) => {
    var p;
    h.current = f.pointerType || null, (p = r.onPointerDown) == null || p.call(r, { pointerType: f.pointerType || null });
  }, onPointerUp: () => {
    requestAnimationFrame(() => {
      h.current = null;
    });
  }, children: [m("input", { className: `ToolIcon_type_radio ${s}`, type: "radio", name: r.name, "aria-label": r["aria-label"], "aria-keyshortcuts": r["aria-keyshortcuts"], "data-testid": r["data-testid"], id: `${a}-${r.id}`, onChange: () => {
    var f;
    (f = r.onChange) == null || f.call(r, { pointerType: h.current });
  }, checked: r.checked, ref: l }), D("div", { className: "ToolIcon__icon", children: [r.icon, r.keyBindingLabel && m("span", { className: "ToolIcon__keybinding", children: r.keyBindingLabel })] })] });
});
yt.displayName = "ToolButton";
var Aue = (e, t, n) => {
  let r = new Set(ct(e.filter((o) => Ve(o)), t).map((o) => o.id)), i = {}, a = n.scene.getNonDeletedElementsMap(), l = /* @__PURE__ */ new Set();
  for (let o of r) {
    let u = Ml(e, o);
    for (let h of u) if (!l.has(h.id)) {
      if (sn(h)) {
        let f = xr(h, a);
        f && (i[f.id] = !0);
      } else i[h.id] = !0;
      l.add(h.id);
    }
  }
  let s = !0, c = e.map((o) => {
    if (t.selectedElementIds[o.id]) {
      let u = sn(o) ? xr(o, a) : null;
      return o.frameId && r.has(o.frameId) ? (s = !1, i[o.id] = !0, o) : u != null && u.frameId && r.has(u == null ? void 0 : u.frameId) ? o : (o.boundElements && o.boundElements.forEach((h) => {
        var p, g;
        let f = n.scene.getNonDeletedElementsMap().get(h.id);
        f && Se(f) && (le(f, { startBinding: o.id === ((p = f.startBinding) == null ? void 0 : p.elementId) ? null : f.startBinding, endBinding: o.id === ((g = f.endBinding) == null ? void 0 : g.elementId) ? null : f.endBinding }), le(f, { points: f.points }));
      }), at(o, { isDeleted: !0 }));
    }
    return o.frameId && r.has(o.frameId) ? (s = !1, sn(o) || (i[o.id] = !0), at(o, { frameId: null })) : sn(o) && t.selectedElementIds[o.containerId] ? at(o, { isDeleted: !0 }) : o;
  }), d = t.editingGroupId;
  if (s && t.editingGroupId) {
    let o = ln(c, t.editingGroupId).filter((u) => !u.isDeleted);
    if (o.length > 1) o[0] && (i[o[0].id] = !0);
    else {
      d = null, o[0] && (i[o[0].id] = !0);
      let u = o[0];
      if (u) {
        let h = u.groupIds.findIndex((p) => p === t.editingGroupId), f = u.groupIds[h + 1];
        if (f) {
          let p = ln(c, f).filter((g) => !g.isDeleted);
          p.length > 1 && (d = f, p.forEach((g) => {
            i[g.id] = !0;
          }));
        }
      }
    }
  }
  return { elements: c, appState: { ...t, ...Hr({ selectedElementIds: i, editingGroupId: d }, c, t, null) } };
}, vS = (e, t) => {
  if (e.editingGroupId) {
    let n = ln(Jt(t), e.editingGroupId);
    if (n.length) return { ...e, selectedElementIds: { [n[0].id]: !0 } };
  }
  return e;
}, tR = ve({ name: "deleteSelectedElements", label: "labels.delete", icon: jc, trackEvent: { category: "element", action: "delete" }, perform: (e, t, n, r) => {
  if (t.editingLinearElement) {
    let { elementId: l, selectedPointsIndices: s, startBindingElement: c, endBindingElement: d } = t.editingLinearElement, o = r.scene.getNonDeletedElementsMap(), u = Ee.getElement(l, o);
    if (!u || s == null) return !1;
    if (u.points.length < 2) {
      let f = e.map((g) => g.id === u.id ? at(g, { isDeleted: !0 }) : g), p = vS(t, f);
      return { elements: f, appState: { ...p, editingLinearElement: null }, captureUpdate: ne.IMMEDIATELY };
    }
    let h = { startBindingElement: s != null && s.includes(0) ? null : c, endBindingElement: s != null && s.includes(u.points.length - 1) ? null : d };
    return Ee.deletePoints(u, s), { elements: e, appState: { ...t, editingLinearElement: { ...t.editingLinearElement, ...h, selectedPointsIndices: (s == null ? void 0 : s[0]) > 0 ? [s[0] - 1] : [0] } }, captureUpdate: ne.IMMEDIATELY };
  }
  let { elements: i, appState: a } = Aue(e, t, r);
  return eN(i, i.filter((l) => l.isDeleted)), a = vS(a, i), { elements: i, appState: { ...a, activeTool: Wn(t, { type: "selection" }), multiElement: null, activeEmbeddable: null }, captureUpdate: Qn(Jt(e), t) ? ne.IMMEDIATELY : ne.EVENTUALLY };
}, keyTest: (e, t, n) => (e.key === H.BACKSPACE || e.key === H.DELETE) && !e[H.CTRL_OR_CMD], PanelComponent: ({ elements: e, appState: t, updateData: n }) => m(yt, { type: "button", icon: jc, title: N("labels.delete"), "aria-label": N("labels.delete"), onClick: () => n(null), visible: Qn(Jt(e), t) }) }), Y7 = (e, t) => e.frameId === t || e.id === t, nR = (e, t, n) => {
  let r = [], i = [], a = null, l = -1, s = Ge(n || ct(e, t, { includeBoundTextElement: !0, includeElementsInFrames: !0 }));
  for (; ++l < e.length; ) {
    let c = e[l];
    s.get(c.id) ? (i.length && (r = r.concat(i), i = []), r.push(l), a = l + 1) : c.isDeleted && a === l ? (a = l + 1, i.push(l)) : i = [];
  }
  return r;
}, Nue = (e) => {
  let t = 0;
  return e.reduce((n, r, i) => (i > 0 && e[i - 1] !== r - 1 && (t = ++t), (n[t] || (n[t] = [])).push(r), n), []);
}, yS = (e, t, n) => {
  var r, i;
  if ("containerId" in e && e.containerId) {
    let a = Es.getScene(e).getElement(e.containerId);
    if (a) return n === "left" ? Math.min(t.indexOf(a), t.indexOf(e)) : Math.max(t.indexOf(a), t.indexOf(e));
  } else {
    let a = (i = (r = e.boundElements) == null ? void 0 : r.find((l) => l.type !== "arrow")) == null ? void 0 : i.id;
    if (a) {
      let l = Es.getScene(e).getElement(a);
      if (l) return n === "left" ? Math.min(t.indexOf(l), t.indexOf(e)) : Math.max(t.indexOf(l), t.indexOf(e));
    }
  }
}, Due = (e, t) => {
  let n = -1, r = -1;
  return e.forEach((i, a) => {
    Y7(i, t) && (n === -1 && (n = a), r = a);
  }), n === -1 ? [] : e.slice(n, r + 1);
}, Lue = (e, t, n, r, i) => {
  let a = t[n], l = (u) => u.isDeleted ? !1 : i ? u.frameId === i : e.editingGroupId ? u.groupIds.includes(e.editingGroupId) : !0, s = r === "left" ? ic(t, (u) => l(u), Math.max(0, n - 1)) : zI(t, (u) => l(u), n + 1), c = t[s];
  if (!c) return -1;
  if (e.editingGroupId) {
    if ((a == null ? void 0 : a.groupIds.join("")) === (c == null ? void 0 : c.groupIds.join(""))) return yS(c, t, r) ?? s;
    if (!(c != null && c.groupIds.includes(e.editingGroupId))) return -1;
  }
  if (!i && (c.frameId || Ve(c))) {
    let u = Due(t, c.frameId || c.id);
    return r === "left" ? t.indexOf(u[0]) : t.indexOf(u[u.length - 1]);
  }
  if (!c.groupIds.length) return yS(c, t, r) ?? s;
  let d = e.editingGroupId ? c.groupIds[c.groupIds.indexOf(e.editingGroupId) - 1] : c.groupIds[c.groupIds.length - 1], o = ln(t, d);
  return o.length ? r === "left" ? t.indexOf(o[0]) : t.indexOf(o[o.length - 1]) : s;
}, rR = (e, t) => t.reduce((n, r) => {
  let i = e[r];
  return n.set(i.id, i), n;
}, /* @__PURE__ */ new Map()), iR = (e, t, n) => {
  let r = nR(e, t), i = rR(e, r), a = Nue(r);
  n === "right" && (a = a.reverse());
  let l = new Set(r.filter((s) => Ve(e[s])).map((s) => e[s].id));
  return a.forEach((s, c) => {
    var U;
    let d = s[0], o = s[s.length - 1], u = n === "left" ? d : o, h = s.some((y) => {
      let w = e[y];
      return w.frameId && l.has(w.frameId);
    }) ? null : (U = e[u]) == null ? void 0 : U.frameId, f = Lue(t, e, u, n, h);
    if (f === -1 || u === f) return;
    let p = n === "left" ? e.slice(0, f) : e.slice(0, d), g = e.slice(d, o + 1), b = n === "left" ? e.slice(f, d) : e.slice(o + 1, f + 1), v = n === "left" ? e.slice(o + 1) : e.slice(f + 1);
    e = n === "left" ? [...p, ...g, ...b, ...v] : [...p, ...b, ...g, ...v];
  }), Cl(e, i), e;
}, aR = (e, t, n, r, i) => {
  let a = nR(e, t, i), l = rR(e, a), s = [], c, d;
  if (n === "left") {
    if (r) c = zI(e, (p) => Y7(p, r));
    else if (t.editingGroupId) {
      let p = ln(e, t.editingGroupId);
      if (!p.length) return e;
      c = e.indexOf(p[0]);
    } else c = 0;
    d = a[a.length - 1];
  } else {
    if (r) d = ic(e, (p) => Y7(p, r));
    else if (t.editingGroupId) {
      let p = ln(e, t.editingGroupId);
      if (!p.length) return e;
      d = e.indexOf(p[p.length - 1]);
    } else d = e.length - 1;
    c = a[0];
  }
  c === -1 && (c = 0);
  for (let p = c; p < d + 1; p++) a.includes(p) || s.push(e[p]);
  let o = Array.from(l.values()), u = e.slice(0, c), h = e.slice(d + 1), f = n === "left" ? [...u, ...o, ...s, ...h] : [...u, ...s, ...o, ...h];
  return Cl(f, l), f;
};
function lR(e, t, n, r) {
  let i = Ge(ct(e, t, { includeBoundTextElement: !0, includeElementsInFrames: !0 })), a = { regularElements: [], frameChildren: /* @__PURE__ */ new Map() }, l = /* @__PURE__ */ new Set();
  for (let d of e) i.has(d.id) && Ve(d) && l.add(d.id);
  for (let d of e) if (i.has(d.id)) if (Ve(d) || d.frameId && l.has(d.frameId)) a.regularElements.push(d);
  else if (!d.frameId) a.regularElements.push(d);
  else {
    let o = a.frameChildren.get(d.frameId) || [];
    o.push(d), a.frameChildren.set(d.frameId, o);
  }
  let s = e, c = Array.from(a.frameChildren.entries());
  for (let [d, o] of c) s = r(e, t, n, d, o);
  return r(s, t, n, null, a.regularElements);
}
var Rue = (e, t) => iR(e, t, "left"), Pue = (e, t) => iR(e, t, "right"), Oue = (e, t) => lR(e, t, "left", aR), $ue = (e, t) => lR(e, t, "right", aR), Fue = ve({ name: "sendBackward", label: "labels.sendBackward", keywords: ["move down", "zindex", "layer"], icon: ax, trackEvent: { category: "element" }, perform: (e, t) => ({ elements: Rue(e, t), appState: t, captureUpdate: ne.IMMEDIATELY }), keyPriority: 40, keyTest: (e) => e[H.CTRL_OR_CMD] && !e.shiftKey && e.code === xt.BRACKET_LEFT, PanelComponent: ({ updateData: e, appState: t }) => m("button", { type: "button", className: "zIndexButton", onClick: () => e(null), title: `${N("labels.sendBackward")} — ${ae("CtrlOrCmd+[")}`, children: ax }) }), zue = ve({ name: "bringForward", label: "labels.bringForward", keywords: ["move up", "zindex", "layer"], icon: ix, trackEvent: { category: "element" }, perform: (e, t) => ({ elements: Pue(e, t), appState: t, captureUpdate: ne.IMMEDIATELY }), keyPriority: 40, keyTest: (e) => e[H.CTRL_OR_CMD] && !e.shiftKey && e.code === xt.BRACKET_RIGHT, PanelComponent: ({ updateData: e, appState: t }) => m("button", { type: "button", className: "zIndexButton", onClick: () => e(null), title: `${N("labels.bringForward")} — ${ae("CtrlOrCmd+]")}`, children: ix }) }), Bue = ve({ name: "sendToBack", label: "labels.sendToBack", keywords: ["move down", "zindex", "layer"], icon: sx, trackEvent: { category: "element" }, perform: (e, t) => ({ elements: Oue(e, t), appState: t, captureUpdate: ne.IMMEDIATELY }), keyTest: (e) => xl ? e[H.CTRL_OR_CMD] && e.altKey && e.code === xt.BRACKET_LEFT : e[H.CTRL_OR_CMD] && e.shiftKey && e.code === xt.BRACKET_LEFT, PanelComponent: ({ updateData: e, appState: t }) => m("button", { type: "button", className: "zIndexButton", onClick: () => e(null), title: `${N("labels.sendToBack")} — ${ae(xl ? "CtrlOrCmd+Alt+[" : "CtrlOrCmd+Shift+[")}`, children: sx }) }), Hue = ve({ name: "bringToFront", label: "labels.bringToFront", keywords: ["move up", "zindex", "layer"], icon: lx, trackEvent: { category: "element" }, perform: (e, t) => ({ elements: $ue(e, t), appState: t, captureUpdate: ne.IMMEDIATELY }), keyTest: (e) => xl ? e[H.CTRL_OR_CMD] && e.altKey && e.code === xt.BRACKET_RIGHT : e[H.CTRL_OR_CMD] && e.shiftKey && e.code === xt.BRACKET_RIGHT, PanelComponent: ({ updateData: e, appState: t }) => m("button", { type: "button", className: "zIndexButton", onClick: (n) => e(null), title: `${N("labels.bringToFront")} — ${ae(xl ? "CtrlOrCmd+Alt+]" : "CtrlOrCmd+Shift+]")}`, children: lx }) }), Wue = ve({ name: "selectAll", label: "labels.selectAll", icon: GZ, trackEvent: { category: "canvas" }, viewMode: !1, perform: (e, t, n, r) => {
  if (t.editingLinearElement) return !1;
  let i = e.filter((a) => !a.isDeleted && !(we(a) && a.containerId) && !a.locked).reduce((a, l) => (a[l.id] = !0, a), {});
  return { appState: { ...t, ...Hr({ editingGroupId: null, selectedElementIds: i }, Jt(e), t, r), selectedLinearElement: Object.keys(i).length === 1 && et(e[0]) ? new Ee(e[0]) : null }, captureUpdate: ne.IMMEDIATELY };
}, keyTest: (e) => e[H.CTRL_OR_CMD] && e.key === H.A }), Xue = (e) => {
  let t = e.slice(), n = /* @__PURE__ */ new Set(), r = (a) => {
    var d, o, u;
    let l = (o = (d = a[0]) == null ? void 0 : d.groupIds) == null ? void 0 : o.join(""), s = [a[0]], c = [];
    for (let h of a.slice(1)) ((u = h.groupIds) == null ? void 0 : u.join("")) === l ? s.push(h) : c.push(h);
    return c.length ? [...s, ...r(c)] : s;
  }, i = /* @__PURE__ */ new Map();
  return t.forEach((a, l) => {
    var s;
    if (!i.has(a.id)) if ((s = a.groupIds) != null && s.length) {
      let c = a.groupIds[a.groupIds.length - 1], d = t.slice(l).filter((o) => {
        var h;
        let u = (h = o == null ? void 0 : o.groupIds) == null ? void 0 : h.some((f) => f === c);
        return u && i.set(o.id, !0), u;
      });
      for (let o of r(d)) n.add(o);
    } else n.add(a);
  }), n.size !== e.length ? (console.error("normalizeGroupElementOrder: lost some elements... bailing!"), e) : [...n];
}, Vue = (e) => {
  let t = YY(e), n = e.slice(), r = /* @__PURE__ */ new Set();
  return n.forEach((i, a) => {
    var l, s, c;
    i && ((l = i.boundElements) != null && l.length ? (r.add(i), n[a] = null, i.boundElements.forEach((d) => {
      let o = t.get(d.id);
      o && d.type === "text" && (r.add(o[0]), n[o[1]] = null);
    })) : i.type === "text" && i.containerId && ((c = (s = t.get(i.containerId)) == null ? void 0 : s[0].boundElements) != null && c.find((d) => d.id === i.id)) || (r.add(i), n[a] = null));
  }), r.size !== e.length ? (console.error("normalizeBoundElementsOrder: lost some elements... bailing!"), e) : [...r];
}, Gue = (e) => Vue(Xue(e)), jue = ve({ name: "duplicateSelection", label: "labels.duplicateSelection", icon: l7, trackEvent: { category: "element" }, perform: (e, t, n, r) => {
  if (t.editingLinearElement) try {
    let a = Ee.duplicateSelectedPoints(t, r.scene.getNonDeletedElementsMap());
    return { elements: e, appState: a, captureUpdate: ne.IMMEDIATELY };
  } catch {
    return !1;
  }
  let i = Kue(e, t);
  if (r.props.onDuplicate && i.elements) {
    let a = r.props.onDuplicate(i.elements, e);
    a && (i.elements = a);
  }
  return { ...i, captureUpdate: ne.IMMEDIATELY };
}, keyTest: (e) => e[H.CTRL_OR_CMD] && e.key === H.D, PanelComponent: ({ elements: e, appState: t, updateData: n }) => m(yt, { type: "button", icon: l7, title: `${N("labels.duplicateSelection")} — ${ae("CtrlOrCmd+D")}`, "aria-label": N("labels.duplicateSelection"), onClick: () => n(null), visible: Qn(Jt(e), t) }) }), Kue = (e, t) => {
  let n = /* @__PURE__ */ new Map(), r = [], i = [], a = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), s = Ge(e), c = (g) => {
    let b = Jw(g).reduce((v, U) => {
      if (o.has(U.id)) return v;
      o.set(U.id, !0);
      let y = yN(t.editingGroupId, n, U, { x: U.x + bm / 2, y: U.y + bm / 2 });
      return o.set(y.id, !0), l.set(y.id, y), a.set(U.id, y.id), i.push(U), r.push(y), v.push(y), v;
    }, []);
    return Array.isArray(g) ? b : b[0] || null;
  };
  e = Gue(e);
  let d = Ge(ct(e, t, { includeBoundTextElement: !0, includeElementsInFrames: !0 })), o = /* @__PURE__ */ new Map(), u = e.slice(), h = (g, b) => {
    Or(g !== -1, "targetIndex === -1 "), !(!Array.isArray(b) && !b) && u.splice(g + 1, 0, ...Jw(b));
  }, f = new Set(e.filter((g) => d.has(g.id) && Ve(g)).map((g) => g.id));
  for (let g of e) {
    if (o.has(g.id) || !d.has(g.id)) continue;
    let b = aN(t, g);
    if (b) {
      let v = ln(e, b).flatMap((y) => Ve(y) ? [...Ml(e, y.id), y] : [y]), U = ic(u, (y) => {
        var w;
        return (w = y.groupIds) == null ? void 0 : w.includes(b);
      });
      h(U, c(v));
      continue;
    }
    if (!(g.frameId && f.has(g.frameId))) {
      if (Ve(g)) {
        let v = g.id, U = Ml(e, v), y = ic(u, (w) => w.frameId === v || w.id === v);
        h(y, c([...U, g]));
        continue;
      }
      if (ra(g)) {
        let v = lt(g, s), U = ic(u, (y) => y.id === g.id || "containerId" in y && y.containerId === g.id);
        v ? h(U, c([g, v])) : h(U, c(g));
        continue;
      }
      if (sn(g)) {
        let v = xr(g, s), U = ic(u, (y) => y.id === g.id || y.id === (v == null ? void 0 : v.id));
        v ? h(U, c([v, g])) : h(U, c(g));
        continue;
      }
      h(ic(u, (v) => v.id === g.id), c(g));
    }
  }
  dN(u, i, a), QA(u, i, a), YN(u, i, a);
  let p = hU(r);
  return { elements: u, appState: { ...t, ...Hr({ editingGroupId: t.editingGroupId, selectedElementIds: p.reduce((g, b) => (sn(b) || (g[b.id] = !0), g), {}) }, Jt(u), t, null) } };
}, Yue = /* @__PURE__ */ new Set(["command_palette", "export"]), tn = (e, t, n, r) => {
  try {
    if (typeof window > "u" || st.VITE_WORKER_ID || st.VITE_APP_ENABLE_TRACKING !== "true" || !Yue.has(e) || st.DEV) return;
    st.PROD || console.info("trackEvent", { category: e, action: t, label: n, value: r }), window.sa_event && window.sa_event(t, { category: e, label: n, value: r });
  } catch (i) {
    console.error("error during analytics", i);
  }
}, sR = dn((e, t) => {
  let { title: n, className: r, testId: i, active: a, standalone: l, icon: s, onClick: c } = e;
  return m("button", { type: "button", ref: t, title: n, "data-testid": i, className: Me(r, { standalone: l, active: a }), onClick: c, children: s }, n);
}), Rl = (e) => m("div", { className: "buttonList", children: e.options.map((t) => e.type === "button" ? m(sR, { icon: t.icon, title: t.text, testId: t.testId, active: t.active ?? e.value === t.value, onClick: (n) => e.onClick(t.value, n) }, t.text) : D("label", { className: Me({ active: e.value === t.value }), title: t.text, children: [m("input", { type: "radio", name: e.group, onChange: () => e.onChange(t.value), checked: e.value === t.value, "data-testid": t.testId }), t.icon] }, t.text)) }), que = ({ onChange: e, type: t, activeColor: n, topPicks: r }) => {
  let i;
  return t === "elementStroke" && (i = xI), t === "elementBackground" && (i = EI), t === "canvasBackground" && (i = SI), r && (i = r), i ? m("div", { className: "color-picker__top-picks", children: i.map((a) => m("button", { className: Me("color-picker__button", { active: a === n, "is-transparent": a === "transparent" || !a }), style: { "--swatch-color": a }, type: "button", title: a, onClick: () => e(a), "data-testid": `color-top-pick-${a}`, children: m("div", { className: "color-picker__button-outline" }) }, a)) }) : (console.error("Invalid type for TopPicks"), null);
}, oR = () => m("div", { style: { width: 1, height: "1rem", backgroundColor: "var(--default-border-color)", margin: "0 auto" } }), T2 = ({ palette: e, color: t }) => {
  for (let [n, r] of Object.entries(e)) if (Array.isArray(r)) {
    let i = r.indexOf(t);
    if (i > -1) return { colorName: n, shade: i };
  } else if (r === t) return { colorName: n, shade: null };
  return null;
}, q7 = [["q", "w", "e", "r", "t"], ["a", "s", "d", "f", "g"], ["z", "x", "c", "v", "b"]].flat(), cR = ({ color: e, palette: t }) => !Object.values(t).flat().includes(e), Zue = (e, t, n) => {
  let r = { elementBackground: "backgroundColor", elementStroke: "strokeColor" }, i = e.filter((l) => {
    if (l.isDeleted) return !1;
    let s = l[r[t]];
    return cR({ color: s, palette: n });
  }), a = /* @__PURE__ */ new Map();
  return i.forEach((l) => {
    let s = l[r[t]];
    a.has(s) ? a.set(s, a.get(s) + 1) : a.set(s, 1);
  }), [...a.entries()].sort((l, s) => s[1] - l[1]).map((l) => l[0]).slice(0, BK);
}, ou = Sr(null), wS = (e, t, n) => (e * 299 + t * 587 + n * 114) / 1e3 >= 160 ? "black" : "white", Jue = (e, t) => {
  if (t) {
    let a = new Option().style;
    if (a.color = e, a.color) {
      let l = a.color.replace(/^(rgb|rgba)\(/, "").replace(/\)$/, "").replace(/\s/g, "").split(","), s = parseInt(l[0]), c = parseInt(l[1]), d = parseInt(l[2]);
      return wS(s, c, d);
    }
  }
  if (e === "transparent") return "black";
  let n = parseInt(e.substring(1, 3), 16), r = parseInt(e.substring(3, 5), 16), i = parseInt(e.substring(5, 7), 16);
  return wS(n, r, i);
}, Que = ({ color: e, keyLabel: t, isCustomColor: n = !1, isShade: r = !1 }) => D("div", { className: "color-picker__button__hotkey-label", style: { color: Jue(e, n) }, children: [r && "⇧", t] }), zU = Que, ehe = ({ hex: e, onChange: t, palette: n }) => {
  let r = T2({ color: e || "transparent", palette: n }), [i, a] = Dn(ou), l = de(null);
  if (Y(() => {
    l.current && i === "shades" && l.current.focus();
  }, [r, i]), r) {
    let { colorName: s, shade: c } = r, d = n[s];
    if (Array.isArray(d)) return m("div", { className: "color-picker-content--default shades", children: d.map((o, u) => D("button", { ref: u === c && i === "shades" ? l : void 0, tabIndex: -1, type: "button", className: Me("color-picker__button color-picker__button--large", { active: u === c }), "aria-label": "Shade", title: `${s} - ${u + 1}`, style: o ? { "--swatch-color": o } : void 0, onClick: () => {
      t(o), a("shades");
    }, children: [m("div", { className: "color-picker__button-outline" }), m(zU, { color: o, keyLabel: u + 1, isShade: !0 })] }, u)) });
  }
  return D("div", { className: "color-picker-content--default", style: { position: "relative" }, tabIndex: -1, children: [m("button", { type: "button", tabIndex: -1, className: "color-picker__button color-picker__button--large color-picker__button--no-focus-visible" }), m("div", { tabIndex: -1, style: { position: "absolute", top: 0, left: 0, right: 0, bottom: 0, display: "flex", alignItems: "center", justifyContent: "center", textAlign: "center", fontSize: "0.75rem" }, children: N("colorPicker.noShades") })] });
}, the = ({ palette: e, color: t, onChange: n, label: r, activeShade: i }) => {
  let a = T2({ color: t || "transparent", palette: e }), [l, s] = Dn(ou), c = de(null);
  return Y(() => {
    c.current && l === "baseColors" && c.current.focus();
  }, [a == null ? void 0 : a.colorName, l]), m("div", { className: "color-picker-content--default", children: Object.entries(e).map(([d, o], u) => {
    let h = (Array.isArray(o) ? o[i] : o) || "transparent", f = q7[u], p = N(`colors.${d.replace(/\d+/, "")}`, null, "");
    return D("button", { ref: (a == null ? void 0 : a.colorName) === d ? c : void 0, tabIndex: -1, type: "button", className: Me("color-picker__button color-picker__button--large", { active: (a == null ? void 0 : a.colorName) === d, "is-transparent": h === "transparent" || !h }), onClick: () => {
      n(h), s("baseColors");
    }, title: `${p}${h.startsWith("#") ? ` ${h}` : ""} — ${f}`, "aria-label": `${p} — ${f}`, style: { "--swatch-color": h }, "data-testid": `color-${d}`, children: [m("div", { className: "color-picker__button-outline" }), m(zU, { color: h, keyLabel: f })] }, d);
  }) });
}, nhe = the, rhe = ({ colors: e, color: t, onChange: n, label: r }) => {
  let [i, a] = Dn(ou), l = de(null);
  return Y(() => {
    l.current && l.current.focus();
  }, [t, i]), m("div", { className: "color-picker-content--default", children: e.map((s, c) => D("button", { ref: t === s ? l : void 0, tabIndex: -1, type: "button", className: Me("color-picker__button color-picker__button--large", { active: t === s, "is-transparent": s === "transparent" || !s }), onClick: () => {
    n(s), a("custom");
  }, title: s, "aria-label": r, style: { "--swatch-color": s }, children: [m("div", { className: "color-picker__button-outline" }), m(zU, { color: s, keyLabel: c + 1, isCustomColor: !0 })] }, c)) });
}, E5 = (e, t, n) => {
  let r = Math.ceil(n / Ad);
  switch (t = t ?? -1, e) {
    case "ArrowLeft": {
      let i = t - 1;
      return i < 0 ? n - 1 : i;
    }
    case "ArrowRight":
      return (t + 1) % n;
    case "ArrowDown": {
      let i = t + Ad;
      return i >= n ? t % Ad : i;
    }
    case "ArrowUp": {
      let i = t - Ad, a = i < 0 ? Ad * r + i : i;
      return a >= n ? void 0 : a;
    }
  }
}, ihe = ({ e, colorObj: t, onChange: n, palette: r, customColors: i, setActiveColorPickerSection: a, activeShade: l }) => {
  if ((t == null ? void 0 : t.shade) != null && ["Digit1", "Digit2", "Digit3", "Digit4", "Digit5"].includes(e.code) && e.shiftKey) {
    let s = Number(e.code.slice(-1)) - 1;
    return n(r[t.colorName][s]), a("shades"), !0;
  }
  if (["1", "2", "3", "4", "5"].includes(e.key) && i[Number(e.key) - 1]) return n(i[Number(e.key) - 1]), a("custom"), !0;
  if (q7.includes(e.key)) {
    let s = q7.indexOf(e.key), c = Object.keys(r)[s], d = r[c], o = Array.isArray(d) ? d[l] : d;
    return n(o), a("baseColors"), !0;
  }
  return !1;
}, ahe = ({ event: e, activeColorPickerSection: t, palette: n, color: r, onChange: i, customColors: a, setActiveColorPickerSection: l, updateData: s, activeShade: c, onEyeDropperToggle: d, onEscape: o }) => {
  if (e[H.CTRL_OR_CMD]) return !1;
  if (e.key === H.ESCAPE) return o(e), !0;
  if (e.key === H.ALT) return d(!0), !0;
  if (e.key === H.I) return d(), !0;
  let u = T2({ color: r, palette: n });
  if (e.key === H.TAB) {
    let h = { custom: !!a.length, baseColors: !0, shades: (u == null ? void 0 : u.shade) != null, hex: !0 }, f = Object.entries(h).reduce((U, [y, w]) => (w && U.push(y), U), []), p = f.indexOf(t), g = e.shiftKey ? -1 : 1, b = p + g > f.length - 1 ? 0 : p + g < 0 ? f.length - 1 : p + g, v = f[b];
    return v && l(v), v === "custom" ? i(a[0]) : v === "baseColors" && (Object.entries(n).find(([U, y]) => Array.isArray(y) ? y.includes(r) : y === r ? U : null) || i(ht.black)), e.preventDefault(), e.stopPropagation(), !0;
  }
  if (ihe({ e, colorObj: u, onChange: i, palette: n, customColors: a, setActiveColorPickerSection: l, activeShade: c })) return !0;
  if (t === "shades" && u) {
    let { shade: h } = u, f = E5(e.key, h, Ad);
    if (f !== void 0) return i(n[u.colorName][f]), !0;
  }
  if (t === "baseColors" && u) {
    let { colorName: h } = u, f = Object.keys(n), p = f.indexOf(h), g = E5(e.key, p, f.length);
    if (g !== void 0) {
      let b = f[g], v = n[b];
      return i(Array.isArray(v) ? v[c] : v), !0;
    }
  }
  if (t === "custom") {
    let h = a.indexOf(r), f = E5(e.key, h, a.length);
    if (f !== void 0) {
      let p = a[f];
      return i(p), !0;
    }
  }
  return !1;
}, lhe = ({ children: e }) => m("div", { className: "color-picker__heading", children: e }), Tp = lhe, she = ({ color: e, onChange: t, label: n, type: r, elements: i, palette: a, updateData: l, children: s, onEyeDropperToggle: c, onEscape: d }) => {
  let [o] = pe.useState(() => r === "canvasBackground" ? [] : Zue(i, r, a)), [u, h] = Dn(ou), f = T2({ color: e, palette: a });
  Y(() => {
    if (!u) {
      let v = cR({ color: e, palette: a }), U = v && !o.includes(e);
      h(U ? "hex" : v ? "custom" : (f == null ? void 0 : f.shade) != null ? "shades" : "baseColors");
    }
  }, [u, e, a, h, f, o]);
  let [p, g] = Q((f == null ? void 0 : f.shade) ?? (r === "elementBackground" ? Gu : Vu));
  Y(() => {
    (f == null ? void 0 : f.shade) != null && g(f.shade);
    let v = (U) => {
      U.key === H.ALT && c(!1);
    };
    return document.addEventListener("keyup", v, { capture: !0 }), () => {
      document.removeEventListener("keyup", v, { capture: !0 });
    };
  }, [f, c]);
  let b = pe.useRef(null);
  return m("div", { role: "dialog", "aria-modal": "true", "aria-label": N("labels.colorPicker"), children: D("div", { ref: b, onKeyDown: (v) => {
    ahe({ event: v, activeColorPickerSection: u, palette: a, color: e, onChange: t, onEyeDropperToggle: c, customColors: o, setActiveColorPickerSection: h, updateData: l, activeShade: p, onEscape: d }) && (v.preventDefault(), v.stopPropagation());
  }, className: "color-picker-content properties-content", tabIndex: -1, children: [!!o.length && D("div", { children: [m(Tp, { children: N("colorPicker.mostUsedCustomColors") }), m(rhe, { colors: o, color: e, label: N("colorPicker.mostUsedCustomColors"), onChange: t })] }), D("div", { children: [m(Tp, { children: N("colorPicker.colors") }), m(nhe, { color: e, label: n, palette: a, onChange: t, activeShade: p })] }), D("div", { children: [m(Tp, { children: N("colorPicker.shades") }), m(ehe, { hex: e, onChange: t, palette: a })] }), s] }) });
}, dR = pe.createContext(null), Zr = () => pe.useContext(dR), uR = (e) => {
  let [t, n] = Q(null), r = ur(), { theme: i } = Zr(), { container: a } = Ol();
  return Bn(() => {
    var l;
    t && (t.className = "", t.classList.add("excalidraw", ...((l = e == null ? void 0 : e.className) == null ? void 0 : l.split(/\s+/)) || []), t.classList.toggle("excalidraw--mobile", r.editor.isMobile), t.classList.toggle("theme--dark", i === gt.DARK));
  }, [t, i, r.editor.isMobile, e == null ? void 0 : e.className]), Bn(() => {
    let l = e != null && e.parentSelector ? a == null ? void 0 : a.querySelector(e.parentSelector) : document.body;
    if (!l) return;
    let s = document.createElement("div");
    return l.appendChild(s), n(s), () => {
      l.removeChild(s);
    };
  }, [a, e == null ? void 0 : e.parentSelector]), t;
};
function BU(e, t, n) {
  Y(() => {
    function r(i) {
      let a = i;
      if (!e.current) return;
      let l = n == null ? void 0 : n(a, e.current);
      if (l !== !0) {
        if (l === !1) return t(a);
        e.current.contains(a.target) || !document.documentElement.contains(a.target) || a.target.closest("[data-radix-portal]") || a.target === document.documentElement && document.body.style.pointerEvents === "none" || a.target.closest("[data-prevent-outside-click]") || t(a);
      }
    }
    return document.addEventListener("pointerdown", r), document.addEventListener("touchstart", r), () => {
      document.removeEventListener("pointerdown", r), document.removeEventListener("touchstart", r);
    };
  }, [e, t, n]);
}
var I2 = (e) => {
  let t = de(e);
  return Object.assign(t.current, e), t.current;
}, A2 = Sr(null), ohe = ({ onCancel: e, onChange: t, onSelect: n, colorPickerType: r }) => {
  let i = uR({ className: "excalidraw-eye-dropper-backdrop", parentSelector: ".excalidraw-eye-dropper-container" }), a = Zr(), l = $2(), s = Pl(), c = ct(l, a), d = I2({ app: s, onCancel: e, onChange: t, onSelect: n, selectedElements: c }), { container: o } = Ol();
  Y(() => {
    let h = u.current;
    if (!h || !s.canvas || !i) return;
    let f = !1, p = s.canvas.getContext("2d"), g = ({ clientX: E, clientY: S }) => {
      let _ = p.getImageData((E - a.offsetLeft) * window.devicePixelRatio, (S - a.offsetTop) * window.devicePixelRatio, 1, 1).data;
      return GK(_[0], _[1], _[2]);
    }, b = ({ clientX: E, clientY: S, altKey: _ }) => {
      h.style.top = `${S + 20}px`, h.style.left = `${E + 20}px`;
      let k = g({ clientX: E, clientY: S });
      f && d.onChange(r, k, d.selectedElements, { altKey: _ }), h.style.background = k;
    }, v = () => {
      d.onCancel();
    }, U = (E, S) => {
      d.onSelect(E, S);
    }, y = (E) => {
      f = !0, E.stopImmediatePropagation();
    }, w = (E) => {
      f = !1, o == null || o.focus(), E.stopImmediatePropagation(), E.preventDefault(), U(g(E), E);
    }, x = (E) => {
      E.key === H.ESCAPE && (E.preventDefault(), E.stopImmediatePropagation(), v());
    };
    return i.tabIndex = -1, i.focus(), b({ clientX: d.app.lastViewportPosition.x, clientY: d.app.lastViewportPosition.y, altKey: !1 }), i.addEventListener("keydown", x), i.addEventListener("pointerdown", y), i.addEventListener("pointerup", w), window.addEventListener("pointermove", b, { passive: !0 }), window.addEventListener("blur", v), () => {
      f = !1, i.removeEventListener("keydown", x), i.removeEventListener("pointerdown", y), i.removeEventListener("pointerup", w), window.removeEventListener("pointermove", b), window.removeEventListener("blur", v);
    };
  }, [d, s.canvas, i, r, o, a.offsetLeft, a.offsetTop]);
  let u = de(null);
  return BU(u, () => {
    e();
  }, (h) => !!h.target.closest(".excalidraw-eye-dropper-trigger, .excalidraw-eye-dropper-backdrop")), i ? fi(m("div", { ref: u, className: "excalidraw-eye-dropper-preview" }), i) : null;
}, che = ({ color: e, onChange: t, label: n, colorPickerType: r }) => {
  let i = ur(), [a, l] = Q(e), [s, c] = Dn(ou);
  Y(() => {
    l(e);
  }, [e]);
  let d = he((p) => {
    let g = p.toLowerCase(), b = dhe(g);
    b && t(b), l(g);
  }, [t]), o = de(null), u = de(null);
  Y(() => {
    o.current && o.current.focus();
  }, [s]);
  let [h, f] = Dn(A2);
  return Y(() => () => {
    f(null);
  }, [f]), D("div", { className: "color-picker__input-label", children: [m("div", { className: "color-picker__input-hash", children: "#" }), m("input", { ref: s === "hex" ? o : void 0, style: { border: 0, padding: 0 }, spellCheck: !1, className: "color-picker-input", "aria-label": n, onChange: (p) => {
    d(p.target.value);
  }, value: (a || "").replace(/^#/, ""), onBlur: () => {
    l(e);
  }, tabIndex: -1, onFocus: () => c("hex"), onKeyDown: (p) => {
    var g;
    p.key !== H.TAB && (p.key === H.ESCAPE && ((g = u.current) == null || g.focus()), p.stopPropagation());
  } }), !i.editor.isMobile && D(ge, { children: [m("div", { style: { width: "1px", height: "1.25rem", backgroundColor: "var(--default-border-color)" } }), m("div", { ref: u, className: Me("excalidraw-eye-dropper-trigger", { selected: h }), onClick: () => f((p) => p ? null : { keepOpenOnAlt: !1, onSelect: (g) => t(g), colorPickerType: r }), title: `${N("labels.eyeDropper")} — ${H.I.toLocaleUpperCase()} or ${ae("Alt")} `, children: $Z })] })] });
}, Da = pe.forwardRef(({ children: e, padding: t, className: n, style: r }, i) => m("div", { className: Me("Island", n), style: { "--padding": t, ...r }, ref: i, children: e })), hR = pe.forwardRef(({ className: e, container: t, children: n, style: r, onClose: i, onKeyDown: a, onFocusOutside: l, onPointerLeave: s, onPointerDownOutside: c }, d) => {
  let o = ur();
  return m(Nde, { container: t, children: D(RU, { ref: d, className: Me("focus-visible-none", e), "data-prevent-outside-click": !0, side: o.editor.isMobile && !o.viewport.isLandscape ? "bottom" : "right", align: o.editor.isMobile && !o.viewport.isLandscape ? "center" : "start", alignOffset: -16, sideOffset: 20, style: { zIndex: "var(--zIndex-popup)" }, onPointerLeave: s, onKeyDown: a, onFocusOutside: l, onPointerDownOutside: c, onCloseAutoFocus: (u) => {
    u.stopPropagation(), u.preventDefault(), t && !FY(document.activeElement) && t.focus(), i();
  }, children: [m(Da, { padding: 3, style: r, children: n }), m(kL, { width: 20, height: 10, style: { fill: "var(--popup-bg-color)", filter: "drop-shadow(rgba(0, 0, 0, 0.05) 0px 3px 2px)" } })] }) });
}), xS = (e) => {
  let t = new Option().style;
  return t.color = e, !!t.color;
}, dhe = (e) => Ea(e) ? e : xS(`#${e}`) ? `#${e}` : xS(e) ? e : null, uhe = ({ type: e, color: t, onChange: n, label: r, elements: i, palette: a = ht, updateData: l }) => {
  let { container: s } = Ol(), [, c] = Dn(ou), [d, o] = Dn(A2), u = D("div", { children: [m(Tp, { children: N("colorPicker.hexCode") }), m(che, { color: t, label: r, onChange: (p) => {
    n(p);
  }, colorPickerType: e })] }), h = de(null), f = () => {
    var p, g;
    (g = (p = h.current) == null ? void 0 : p.querySelector(".color-picker-content")) == null || g.focus();
  };
  return m(hR, { container: s, style: { maxWidth: "13rem" }, onFocusOutside: (p) => {
    f(), p.preventDefault();
  }, onPointerDownOutside: (p) => {
    d && p.preventDefault();
  }, onClose: () => {
    l({ openPopup: null }), c(null);
  }, children: a ? m(she, { palette: a, color: t, onChange: (p) => {
    n(p);
  }, onEyeDropperToggle: (p) => {
    o((g) => p ? (g = g || { keepOpenOnAlt: !0, onSelect: n, colorPickerType: e }, g.keepOpenOnAlt = !0, g) : p === !1 || g ? null : { keepOpenOnAlt: !1, onSelect: n, colorPickerType: e });
  }, onEscape: (p) => {
    d ? o(null) : l({ openPopup: null });
  }, label: r, type: e, elements: i, updateData: l, children: u }) : u });
}, hhe = ({ label: e, color: t, type: n }) => m(k2, { type: "button", className: Me("color-picker__button active-color properties-trigger", { "is-transparent": t === "transparent" || !t }), "aria-label": e, style: t ? { "--swatch-color": t } : void 0, title: N(n === "elementStroke" ? "labels.showStroke" : "labels.showBackground"), children: m("div", { className: "color-picker__button-outline" }) }), HU = ({ type: e, color: t, onChange: n, label: r, elements: i, palette: a = ht, topPicks: l, updateData: s, appState: c }) => m("div", { children: D("div", { role: "dialog", "aria-modal": "true", className: "color-picker-container", children: [m(que, { activeColor: t, onChange: n, type: e, topPicks: l }), m(oR, {}), D(_2, { open: c.openPopup === e, onOpenChange: (d) => {
  s({ openPopup: d ? e : null });
}, children: [m(hhe, { color: t, label: r, type: e }), c.openPopup === e && m(uhe, { type: e, color: t, onChange: n, label: r, elements: i, palette: a, updateData: s })] })] }) }), N2 = ({ icon: e }) => m("span", { style: { width: "1em", margin: "0 0.5ex 0 0.5ex", display: "inline-block", lineHeight: 0, verticalAlign: "middle" }, children: e }), fhe = ({ label: e, open: t, openTrigger: n, children: r, className: i }) => D(ge, { children: [D("div", { style: { cursor: "pointer", display: "flex", justifyContent: "space-between", alignItems: "center" }, className: i, onClick: n, children: [e, m(N2, { icon: t ? sJ : mA })] }), t && m("div", { style: { display: "flex", flexDirection: "column" }, children: r })] }), Z7 = fhe, phe = Sr(!1);
function mhe({ options: e, value: t, label: n, onChange: r, onClose: i, numberOfOptionsToAlwaysShow: a = e.length }) {
  let l = ur(), s = (f) => {
    let p = e.find((g) => g.keyBinding === f.key.toLowerCase());
    if (!(f.metaKey || f.altKey || f.ctrlKey) && p) r(p.value), f.preventDefault();
    else if (f.key === H.TAB) {
      let g = e.findIndex((v) => v.value === t), b = f.shiftKey ? (e.length + g - 1) % e.length : (g + 1) % e.length;
      r(e[b].value);
    } else if (ju(f.key)) {
      let g = df().rtl, b = e.findIndex((v) => v.value === t);
      if (b !== -1) {
        let v = e.length, U = b;
        switch (f.key) {
          case (g ? H.ARROW_LEFT : H.ARROW_RIGHT):
            U = (b + 1) % v;
            break;
          case (g ? H.ARROW_RIGHT : H.ARROW_LEFT):
            U = (v + b - 1) % v;
            break;
          case H.ARROW_DOWN: {
            U = (b + (a ?? 1)) % v;
            break;
          }
          case H.ARROW_UP: {
            U = (v + b - (a ?? 1)) % v;
            break;
          }
        }
        r(e[U].value);
      }
      f.preventDefault();
    } else (f.key === H.ESCAPE || f.key === H.ENTER) && (f.preventDefault(), i());
    f.nativeEvent.stopImmediatePropagation(), f.stopPropagation();
  }, [c, d] = Dn(phe), o = pe.useMemo(() => e.slice(0, a), [e, a]), u = pe.useMemo(() => e.slice(a), [e, a]);
  Y(() => {
    o.some((f) => f.value === t) || d(!0);
  }, [t, o, d]);
  let h = (f) => m("div", { className: "picker-content", children: f.map((p, g) => D("button", { type: "button", className: Me("picker-option", { active: t === p.value }), onClick: (b) => {
    r(p.value);
  }, title: `${p.text} ${p.keyBinding && `— ${p.keyBinding.toUpperCase()}`}`, "aria-label": p.text || "none", "aria-keyshortcuts": p.keyBinding || void 0, ref: (b) => {
    t === p.value && setTimeout(() => {
      b == null || b.focus();
    }, 0);
  }, children: [p.icon, p.keyBinding && m("span", { className: "picker-keybinding", children: p.keyBinding })] }, p.text)) });
  return m(RU, { side: l.editor.isMobile && !l.viewport.isLandscape ? "top" : "bottom", align: "start", sideOffset: 12, style: { zIndex: "var(--zIndex-popup)" }, onKeyDown: s, children: D("div", { className: "picker", role: "dialog", "aria-modal": "true", "aria-label": n, children: [h(o), u.length > 0 && m(Z7, { label: N("labels.more_options"), open: c, openTrigger: () => {
    d((f) => !f);
  }, className: "picker-collapsible", children: h(u) })] }) });
}
function ES({ value: e, label: t, options: n, onChange: r, group: i = "", numberOfOptionsToAlwaysShow: a }) {
  var d;
  let [l, s] = pe.useState(!1), c = pe.useRef(null);
  return m("div", { children: D(_2, { open: l, onOpenChange: (o) => s(o), children: [m(k2, { name: i, type: "button", "aria-label": t, onClick: () => s(!l), ref: c, className: l ? "active" : "", children: (d = n.find((o) => o.value === e)) == null ? void 0 : d.icon }), l && m(mhe, { options: n, value: e, label: t, onChange: r, onClose: () => {
    s(!1);
  }, numberOfOptionsToAlwaysShow: a })] }) });
}
var fR = pe.forwardRef(({ className: e, placeholder: t, onChange: n }, r) => D("div", { className: Me("QuickSearch__wrapper", e), children: [Kc, m("input", { ref: r, className: "QuickSearch__input", type: "text", placeholder: t, onChange: (i) => n(i.target.value.trim().toLowerCase()) })] })), pR = ({ className: e, placeholder: t, children: n }) => {
  let r = !Ir.count(n);
  return m("div", { className: Me("ScrollableList__wrapper", e), role: "menu", children: r ? m("div", { className: "empty", children: t }) : n });
}, mR = ({ children: e, className: t = "", style: n, title: r }) => D("div", { className: `dropdown-menu-group ${t}`, style: n, children: [r && m("p", { className: "dropdown-menu-group-title", children: r }), e] }), J7 = mR;
mR.displayName = "DropdownMenuGroup";
var gR = pe.createContext({}), bR = (e = "", t = !1, n = !1) => `dropdown-menu-item dropdown-menu-item-base ${e}
  ${t ? "dropdown-menu-item--selected" : ""} ${n ? "dropdown-menu-item--hovered" : ""}`.trim(), UR = (e, t) => {
  let n = Er(gR);
  return Jg(e, (r) => {
    var a;
    let i = new CustomEvent("menu.itemSelect", { bubbles: !0, cancelable: !0 });
    t == null || t(i), i.defaultPrevented || ((a = n.onSelect) == null || a.call(n, i));
  });
}, ghe = ({ textStyle: e, icon: t, shortcut: n, children: r }) => {
  let i = ur();
  return D(ge, { children: [t && m("div", { className: "dropdown-menu-item__icon", children: t }), m("div", { style: e, className: "dropdown-menu-item__text", children: r }), n && !i.editor.isMobile && m("div", { className: "dropdown-menu-item__shortcut", children: n })] });
}, vR = ghe, WU = ({ icon: e, value: t, order: n, children: r, shortcut: i, className: a, hovered: l, selected: s, textStyle: c, onSelect: d, onClick: o, ...u }) => {
  let h = UR(o, d), f = de(null);
  return Y(() => {
    var p, g;
    l && (n === 0 ? (p = f.current) == null || p.scrollIntoView({ block: "end" }) : (g = f.current) == null || g.scrollIntoView({ block: "nearest" }));
  }, [l, n]), m("button", { ...u, ref: f, value: t, onClick: h, className: bR(a, s, l), title: u.title ?? u["aria-label"], children: m(vR, { textStyle: c, icon: e, shortcut: i, children: r }) });
};
WU.displayName = "DropdownMenuItem";
var Qu = { GREEN: "green", RED: "red", BLUE: "blue" }, XU = ({ type: e = Qu.BLUE, children: t }) => {
  let { theme: n } = e1(), r = { display: "inline-flex", marginLeft: "auto", padding: "2px 4px", borderRadius: 6, fontSize: 9, fontFamily: "Cascadia, monospace", border: n === gt.LIGHT ? "1.5px solid white" : "none" };
  switch (e) {
    case Qu.GREEN:
      Object.assign(r, { backgroundColor: "var(--background-color-badge)", color: "var(--color-badge)" });
      break;
    case Qu.RED:
      Object.assign(r, { backgroundColor: "pink", color: "darkred" });
      break;
    case Qu.BLUE:
    default:
      Object.assign(r, { background: "var(--color-promo)", color: "var(--color-surface-lowest)" });
  }
  return m("div", { className: "DropDownMenuItemBadge", style: r, children: t });
};
XU.displayName = "DropdownMenuItemBadge";
WU.Badge = XU;
var la = WU, bhe = ({ event: e, inputRef: t, hoveredFont: n, filteredFonts: r, onClose: i, onSelect: a, onHover: l }) => {
  var s, c, d;
  if (!e[H.CTRL_OR_CMD] && e.shiftKey && e.key.toLowerCase() === H.F) return (s = t.current) == null || s.focus(), !0;
  if (e.key === H.ESCAPE) return i(), !0;
  if (e.key === H.ENTER) return n != null && n.value && a(n.value), !0;
  if (e.key === H.ARROW_DOWN) return n != null && n.next ? l(n.next.value) : (c = r[0]) != null && c.value && l(r[0].value), !0;
  if (e.key === H.ARROW_UP) return n != null && n.prev ? l(n.prev.value) : (d = r[r.length - 1]) != null && d.value && l(r[r.length - 1].value), !0;
}, Uhe = pe.memo(({ selectedFontFamily: e, hoveredFontFamily: t, onSelect: n, onHover: r, onLeave: i, onOpen: a, onClose: l }) => {
  let { container: s } = Ol(), { fonts: c } = Pl(), { showDeprecatedFonts: d } = Qf(), [o, u] = Q(""), h = de(null), f = Ke(() => Array.from(ds.registered.entries()).filter(([_, { metadata: k }]) => !k.serverSide && !k.fallback).map(([_, { metadata: k, fontFaces: M }]) => {
    var L, R;
    let A = { value: _, icon: k.icon ?? Cm, text: ((R = (L = M[0]) == null ? void 0 : L.fontFace) == null ? void 0 : R.family) ?? "Unknown" };
    return k.deprecated && Object.assign(A, { deprecated: k.deprecated, badge: { type: Qu.RED, placeholder: N("fontList.badge.old") } }), A;
  }).sort((_, k) => _.text.toLowerCase() > k.text.toLowerCase() ? 1 : -1), []), p = Ke(() => new Set(c.getSceneFamilies()), [e]), g = Ke(() => f.filter((_) => p.has(_.value)), [f, p]), b = Ke(() => f.filter((_) => !p.has(_.value) && (d || !_.deprecated)), [f, p, d]), v = Ke(() => qY([...g, ...b].filter((_) => {
    var k;
    return (k = _.text) == null ? void 0 : k.toLowerCase().includes(o);
  })), [g, b, o]), U = Ke(() => {
    var k;
    let _;
    return t ? _ = v.find((M) => M.value === t) : e && (_ = v.find((M) => M.value === e)), !_ && o && ((k = v[0]) != null && k.value ? r(v[0].value) : i()), _;
  }, [t, e, o, v, r, i]), y = he((_) => {
    bhe({ event: _, inputRef: h, hoveredFont: U, filteredFonts: v, onSelect: n, onHover: r, onClose: l }) && (_.preventDefault(), _.stopPropagation());
  }, [U, v, n, r, l]);
  Y(() => (a(), () => {
    l();
  }), []);
  let w = Ke(() => v.filter((_) => p.has(_.value)), [v, p]), x = Ke(() => v.filter((_) => !p.has(_.value)), [v, p]), E = (_, k) => D(la, { icon: _.icon, value: _.value, order: k, textStyle: { fontFamily: g0({ fontFamily: _.value }) }, hovered: _.value === (U == null ? void 0 : U.value), selected: _.value === e, tabIndex: _.value === e ? 0 : -1, onClick: (M) => {
    n(Number(M.currentTarget.value));
  }, onMouseMove: () => {
    (U == null ? void 0 : U.value) !== _.value && r(_.value);
  }, children: [_.text, _.badge && m(XU, { type: _.badge.type, children: _.badge.placeholder })] }, _.value), S = [];
  return w.length && S.push(m(J7, { title: N("fontList.sceneFonts"), children: w.map(E) }, "group_1")), x.length && S.push(m(J7, { title: N("fontList.availableFonts"), children: x.map((_, k) => E(_, k + w.length)) }, "group_2")), D(hR, { className: "properties-content", container: s, style: { width: "15rem" }, onClose: l, onPointerLeave: i, onKeyDown: y, children: [m(fR, { ref: h, placeholder: N("quickSearch.placeholder"), onChange: b0(u, 20) }), m(pR, { className: "dropdown-menu fonts manual-hover", placeholder: N("fontList.empty"), children: S.length ? S : null })] });
}, (e, t) => e.selectedFontFamily === t.selectedFontFamily && e.hoveredFontFamily === t.hoveredFontFamily), vhe = ({ selectedFontFamily: e }) => {
  let t = Ke(() => !!(e && !whe(e)), [e]);
  return m(k2, { asChild: !0, children: m("div", { children: m(sR, { standalone: !0, icon: QI, title: N("labels.showFonts"), className: "properties-trigger", testId: "font-family-show-fonts", active: t, onClick: () => {
  } }) }) });
}, yR = [{ value: Un.Excalifont, icon: qh, text: N("labels.handDrawn"), testId: "font-family-hand-drawn" }, { value: Un.Nunito, icon: Cm, text: N("labels.normal"), testId: "font-family-normal" }, { value: Un["Comic Shanns"], icon: d7, text: N("labels.code"), testId: "font-family-code" }], yhe = new Set(yR.map((e) => e.value)), whe = (e) => e ? yhe.has(e) : !1, xhe = pe.memo(({ isOpened: e, selectedFontFamily: t, hoveredFontFamily: n, onSelect: r, onHover: i, onLeave: a, onPopupChange: l }) => {
  let s = Ke(() => yR, []), c = he((d) => {
    d && r(d);
  }, [r]);
  return D("div", { role: "dialog", "aria-modal": "true", className: "FontPicker__container", children: [m(Rl, { type: "button", options: s, value: t, onClick: c }), m(oR, {}), D(_2, { open: e, onOpenChange: l, children: [m(vhe, { selectedFontFamily: t }), e && m(Uhe, { selectedFontFamily: t, hoveredFontFamily: n, onSelect: c, onHover: i, onLeave: a, onOpen: () => l(!0), onClose: () => l(!1) })] })] });
}, (e, t) => e.isOpened === t.isOpened && e.selectedFontFamily === t.selectedFontFamily && e.hoveredFontFamily === t.hoveredFontFamily), Ehe = ({ updateData: e, appState: t, elements: n, testId: r }) => {
  let i = pe.useRef(null), a = pe.useRef(null), l = Yr(n, t, (s) => s.opacity, !0, t.currentItemOpacity);
  return Y(() => {
    if (i.current && a.current) {
      let s = i.current, c = a.current, d = s.offsetWidth, o = 15, u = l / 100 * (d - o) + o / 2;
      c.style.left = `${u}px`, s.style.background = `linear-gradient(to right, var(--color-slider-track) 0%, var(--color-slider-track) ${l}%, var(--button-bg) ${l}%, var(--button-bg) 100%)`;
    }
  }, [l]), D("label", { className: "control-label", children: [N("labels.opacity"), D("div", { className: "range-wrapper", children: [m("input", { ref: i, type: "range", min: "0", max: "100", step: "10", onChange: (s) => {
    e(+s.target.value);
  }, value: l, className: "range-input", "data-testid": r }), m("div", { className: "value-bubble", ref: a, children: l !== 0 ? l : null }), m("div", { className: "zero-label", children: "0" })] })] });
}, wR = 0.1, Kr = (e, t, n, r = !1) => {
  let i = Ge(ct(e, t, { includeBoundTextElement: r }));
  return e.map((a) => {
    var l;
    return i.get(a.id) || a.id === ((l = t.editingTextElement) == null ? void 0 : l.id) ? n(a) : a;
  });
}, Yr = function(e, t, n, r, i) {
  let a = t.editingTextElement, l = Jt(e), s = null;
  return a && (s = n(a)), s || (Qn(l, t) ? s = Ule(r === !0 ? l : l.filter((c) => r(c)), t, n) ?? (typeof i == "function" ? i(!0) : i) : s = typeof i == "function" ? i(!1) : i), s;
}, She = (e, t) => sn(t) || !t.autoResize ? t : le(t, { x: e.textAlign === "left" ? e.x : e.x + (e.width - t.width) / (e.textAlign === "center" ? 2 : 1), y: e.y + (e.height - t.height) / 2 }, !1), VU = (e, t, n, r, i) => {
  let a = /* @__PURE__ */ new Set(), l = Kr(e, t, (c) => {
    if (we(c)) {
      let d = r(c);
      a.add(d);
      let o = at(c, { fontSize: d });
      return jr(o, n.scene.getContainerElement(c), n.scene.getNonDeletedElementsMap()), o = She(c, o), o;
    }
    return c;
  }, !0), s = Ge(l);
  return ct(e, t, { includeBoundTextElement: !0 }).forEach((c) => {
    we(c) && ui(c, s);
  }), { elements: l, appState: { ...t, currentItemFontSize: a.size === 1 ? [...a][0] : i ?? t.currentItemFontSize }, captureUpdate: ne.IMMEDIATELY };
};
ve({ name: "changeStrokeColor", label: "labels.stroke", trackEvent: !1, perform: (e, t, n) => ({ ...n.currentItemStrokeColor && { elements: Kr(e, t, (r) => m7(r.type) ? at(r, { strokeColor: n.currentItemStrokeColor }) : r, !0) }, appState: { ...t, ...n }, captureUpdate: n.currentItemStrokeColor ? ne.IMMEDIATELY : ne.EVENTUALLY }), PanelComponent: ({ elements: e, appState: t, updateData: n, appProps: r }) => D(ge, { children: [m("h3", { "aria-hidden": "true", children: N("labels.stroke") }), m(HU, { topPicks: xI, palette: WK, type: "elementStroke", label: N("labels.stroke"), color: Yr(e, t, (i) => i.strokeColor, !0, t.currentItemStrokeColor), onChange: (i) => n({ currentItemStrokeColor: i }), elements: e, appState: t, updateData: n })] }) });
ve({ name: "changeBackgroundColor", label: "labels.changeBackground", trackEvent: !1, perform: (e, t, n) => ({ ...n.currentItemBackgroundColor && { elements: Kr(e, t, (r) => at(r, { backgroundColor: n.currentItemBackgroundColor })) }, appState: { ...t, ...n }, captureUpdate: n.currentItemBackgroundColor ? ne.IMMEDIATELY : ne.EVENTUALLY }), PanelComponent: ({ elements: e, appState: t, updateData: n, appProps: r }) => D(ge, { children: [m("h3", { "aria-hidden": "true", children: N("labels.background") }), m(HU, { topPicks: EI, palette: XK, type: "elementBackground", label: N("labels.background"), color: Yr(e, t, (i) => i.backgroundColor, !0, t.currentItemBackgroundColor), onChange: (i) => n({ currentItemBackgroundColor: i }), elements: e, appState: t, updateData: n })] }) });
ve({ name: "changeFillStyle", label: "labels.fill", trackEvent: !1, perform: (e, t, n, r) => (tn("element", "changeFillStyle", `${n} (${r.device.editor.isMobile ? "mobile" : "desktop"})`), { elements: Kr(e, t, (i) => at(i, { fillStyle: n })), appState: { ...t, currentItemFillStyle: n }, captureUpdate: ne.IMMEDIATELY }), PanelComponent: ({ elements: e, appState: t, updateData: n }) => {
  let r = ct(e, t), i = r.length > 0 && r.every((a) => a.fillStyle === "zigzag");
  return D("fieldset", { children: [m("legend", { children: N("labels.fill") }), m(Rl, { type: "button", options: [{ value: "hachure", text: `${N(i ? "labels.zigzag" : "labels.hachure")} (${ae("Alt-Click")})`, icon: i ? Zq : Jq, active: i ? !0 : void 0, testId: "fill-hachure" }, { value: "cross-hatch", text: N("labels.crossHatch"), icon: Qq, testId: "fill-cross-hatch" }, { value: "solid", text: N("labels.solid"), icon: eZ, testId: "fill-solid" }], value: Yr(e, t, (a) => a.fillStyle, (a) => a.hasOwnProperty("fillStyle"), (a) => a ? null : t.currentItemFillStyle), onClick: (a, l) => {
    let s = l.altKey && a === "hachure" && r.every((c) => c.fillStyle === "hachure") ? "zigzag" : a;
    n(s);
  } })] });
} });
ve({ name: "changeStrokeWidth", label: "labels.strokeWidth", trackEvent: !1, perform: (e, t, n) => ({ elements: Kr(e, t, (r) => at(r, { strokeWidth: n })), appState: { ...t, currentItemStrokeWidth: n }, captureUpdate: ne.IMMEDIATELY }), PanelComponent: ({ elements: e, appState: t, updateData: n }) => D("fieldset", { children: [m("legend", { children: N("labels.strokeWidth") }), m(Rl, { group: "stroke-width", options: [{ value: z6.thin, text: N("labels.thin"), icon: lA, testId: "strokeWidth-thin" }, { value: z6.bold, text: N("labels.bold"), icon: tZ, testId: "strokeWidth-bold" }, { value: z6.extraBold, text: N("labels.extraBold"), icon: nZ, testId: "strokeWidth-extraBold" }], value: Yr(e, t, (r) => r.strokeWidth, (r) => r.hasOwnProperty("strokeWidth"), (r) => r ? null : t.currentItemStrokeWidth), onChange: (r) => n(r) })] }) });
ve({ name: "changeSloppiness", label: "labels.sloppiness", trackEvent: !1, perform: (e, t, n) => ({ elements: Kr(e, t, (r) => at(r, { seed: _l(), roughness: n })), appState: { ...t, currentItemRoughness: n }, captureUpdate: ne.IMMEDIATELY }), PanelComponent: ({ elements: e, appState: t, updateData: n }) => D("fieldset", { children: [m("legend", { children: N("labels.sloppiness") }), m(Rl, { group: "sloppiness", options: [{ value: 0, text: N("labels.architect"), icon: aZ }, { value: 1, text: N("labels.artist"), icon: lZ }, { value: 2, text: N("labels.cartoonist"), icon: sZ }], value: Yr(e, t, (r) => r.roughness, (r) => r.hasOwnProperty("roughness"), (r) => r ? null : t.currentItemRoughness), onChange: (r) => n(r) })] }) });
ve({ name: "changeStrokeStyle", label: "labels.strokeStyle", trackEvent: !1, perform: (e, t, n) => ({ elements: Kr(e, t, (r) => at(r, { strokeStyle: n })), appState: { ...t, currentItemStrokeStyle: n }, captureUpdate: ne.IMMEDIATELY }), PanelComponent: ({ elements: e, appState: t, updateData: n }) => D("fieldset", { children: [m("legend", { children: N("labels.strokeStyle") }), m(Rl, { group: "strokeStyle", options: [{ value: "solid", text: N("labels.strokeStyle_solid"), icon: lA }, { value: "dashed", text: N("labels.strokeStyle_dashed"), icon: rZ }, { value: "dotted", text: N("labels.strokeStyle_dotted"), icon: iZ }], value: Yr(e, t, (r) => r.strokeStyle, (r) => r.hasOwnProperty("strokeStyle"), (r) => r ? null : t.currentItemStrokeStyle), onChange: (r) => n(r) })] }) });
ve({ name: "changeOpacity", label: "labels.opacity", trackEvent: !1, perform: (e, t, n) => ({ elements: Kr(e, t, (r) => at(r, { opacity: n }), !0), appState: { ...t, currentItemOpacity: n }, captureUpdate: ne.IMMEDIATELY }), PanelComponent: ({ elements: e, appState: t, updateData: n }) => m(Ehe, { updateData: n, elements: e, appState: t, testId: "opacity" }) });
ve({ name: "changeFontSize", label: "labels.fontSize", trackEvent: !1, perform: (e, t, n, r) => VU(e, t, r, () => n, n), PanelComponent: ({ elements: e, appState: t, updateData: n, app: r }) => D("fieldset", { children: [m("legend", { children: N("labels.fontSize") }), m(Rl, { group: "font-size", options: [{ value: 16, text: N("labels.small"), icon: xZ, testId: "fontSize-small" }, { value: 20, text: N("labels.medium"), icon: EZ, testId: "fontSize-medium" }, { value: 28, text: N("labels.large"), icon: SZ, testId: "fontSize-large" }, { value: 36, text: N("labels.veryLarge"), icon: _Z, testId: "fontSize-veryLarge" }], value: Yr(e, t, (i) => {
  if (we(i)) return i.fontSize;
  let a = lt(i, r.scene.getNonDeletedElementsMap());
  return a ? a.fontSize : null;
}, (i) => we(i) || lt(i, r.scene.getNonDeletedElementsMap()) !== null, (i) => i ? null : t.currentItemFontSize || Is), onChange: (i) => n(i) })] }) });
var SS = ve({ name: "decreaseFontSize", label: "labels.decreaseFontSize", icon: n2, trackEvent: !1, perform: (e, t, n, r) => VU(e, t, r, (i) => Math.round(1 / (1 + wR) * i.fontSize)), keyTest: (e) => e[H.CTRL_OR_CMD] && e.shiftKey && (e.key === H.CHEVRON_LEFT || e.key === H.COMMA) }), _S = ve({ name: "increaseFontSize", label: "labels.increaseFontSize", icon: n2, trackEvent: !1, perform: (e, t, n, r) => VU(e, t, r, (i) => Math.round(i.fontSize * (1 + wR))), keyTest: (e) => e[H.CTRL_OR_CMD] && e.shiftKey && (e.key === H.CHEVRON_RIGHT || e.key === H.PERIOD) });
ve({ name: "changeFontFamily", label: "labels.fontFamily", trackEvent: !1, perform: (e, t, n, r) => {
  var p;
  let { cachedElements: i, resetAll: a, resetContainers: l, ...s } = n;
  if (a) return { elements: Kr(e, t, (g) => {
    let b = i == null ? void 0 : i.get(g.id);
    return b ? at(g, { ...b }) : g;
  }, !0), appState: { ...t, ...s }, captureUpdate: ne.NEVER };
  let { currentItemFontFamily: c, currentHoveredFontFamily: d } = n, o = ne.EVENTUALLY, u, h = !1;
  if (c) u = c, o = ne.IMMEDIATELY;
  else if (d) {
    u = d, o = ne.EVENTUALLY;
    let g = ct(e, t, { includeBoundTextElement: !0 }).filter((b) => we(b));
    if (g.length > 200) h = !0;
    else {
      let b = 0, v = 0;
      for (; b < g.length && v < 5e3; ) {
        let U = g[b];
        v += (U == null ? void 0 : U.originalText.length) || 0, b++;
      }
      v > 5e3 && (h = !0);
    }
  }
  let f = { appState: { ...t, ...s }, captureUpdate: o };
  if (u && !h) {
    let g = /* @__PURE__ */ new Map(), b = /* @__PURE__ */ new Set(), v = !1, U = Array.from(ds.loadedFontsCache.values()), y = (p = Object.entries(Un).find(([E, S]) => S === u)) == null ? void 0 : p[0];
    d && y && U.some((E) => E.startsWith(y)) && (v = !0), Object.assign(f, { elements: Kr(e, t, (E) => {
      if (we(E) && (E.fontFamily !== u || c)) {
        let S = at(E, { fontFamily: u, lineHeight: Yc(u) }), _ = (i == null ? void 0 : i.get(E.containerId || "")) || {}, k = r.scene.getContainerElement(E);
        return l && k && _ && le(k, { ..._ }, !1), v || (b = /* @__PURE__ */ new Set([...b, ...Array.from(S.originalText)])), g.set(S, k), S;
      }
      return E;
    }, !0) });
    let w = `10px ${g0({ fontFamily: u })}`, x = Array.from(b.values()).join();
    if (v || window.document.fonts.check(w, x)) for (let [E, S] of g) jr(E, S, r.scene.getNonDeletedElementsMap(), !1);
    else window.document.fonts.load(w, x).then((E) => {
      for (let [S, _] of g) {
        let k = r.scene.getElement(S.id), M = _ ? r.scene.getElement(_.id) : null;
        k && jr(k, M, r.scene.getNonDeletedElementsMap(), !1);
      }
      r.fonts.onLoaded(E);
    });
  }
  return f;
}, PanelComponent: ({ elements: e, appState: t, app: n, updateData: r }) => {
  let i = de(/* @__PURE__ */ new Map()), a = de(null), [l, s] = Q({}), c = de(!0), d = Ke(() => {
    var u;
    let o = (h, f) => Yr(h, t, (p) => {
      if (we(p)) return p.fontFamily;
      let g = lt(p, f);
      return g ? g.fontFamily : null;
    }, (p) => we(p) || lt(p, f) !== null, (p) => p ? null : t.currentItemFontFamily || Oo);
    return l.openPopup === "fontFamily" && t.openPopup === "fontFamily" ? o(Array.from(((u = i.current) == null ? void 0 : u.values()) ?? []), i.current) : !l.openPopup && t.openPopup !== "fontFamily" ? o(e, n.scene.getNonDeletedElementsMap()) : a.current;
  }, [l.openPopup, t, e, n.scene]);
  return Y(() => {
    a.current = d;
  }, [d]), Y(() => {
    Object.keys(l).length && (r(l), s({}));
  }, [l]), Y(() => (c.current = !1, () => {
    c.current = !0;
  }), []), D("fieldset", { children: [m("legend", { children: N("labels.fontFamily") }), m(xhe, { isOpened: t.openPopup === "fontFamily", selectedFontFamily: d, hoveredFontFamily: t.currentHoveredFontFamily, onSelect: (o) => {
    s({ openPopup: null, currentHoveredFontFamily: null, currentItemFontFamily: o }), i.current.clear();
  }, onHover: (o) => {
    s({ currentHoveredFontFamily: o, cachedElements: new Map(i.current), resetContainers: !0 });
  }, onLeave: () => {
    s({ currentHoveredFontFamily: null, cachedElements: new Map(i.current), resetAll: !0 });
  }, onPopupChange: (o) => {
    if (o) {
      i.current.clear();
      let { editingTextElement: u } = t;
      if ((u == null ? void 0 : u.type) === "text") {
        let h = n.scene.getElement(u.id);
        i.current.set(u.id, at(h || u, {}, !0));
      } else {
        let h = ct(e, t, { includeBoundTextElement: !0 });
        for (let f of h) i.current.set(f.id, at(f, {}, !0));
      }
      s({ openPopup: "fontFamily" });
    } else {
      let u = { openPopup: null, currentHoveredFontFamily: null, cachedElements: new Map(i.current), resetAll: !0 };
      c.current ? r({ ...l, ...u }) : s(u), i.current.clear();
    }
  } })] });
} });
ve({ name: "changeTextAlign", label: "Change text alignment", trackEvent: !1, perform: (e, t, n, r) => ({ elements: Kr(e, t, (i) => {
  if (we(i)) {
    let a = at(i, { textAlign: n });
    return jr(a, r.scene.getContainerElement(i), r.scene.getNonDeletedElementsMap()), a;
  }
  return i;
}, !0), appState: { ...t, currentItemTextAlign: n }, captureUpdate: ne.IMMEDIATELY }), PanelComponent: ({ elements: e, appState: t, updateData: n, app: r }) => {
  let i = r.scene.getNonDeletedElementsMap();
  return D("fieldset", { children: [m("legend", { children: N("labels.textAlign") }), m(Rl, { group: "text-align", options: [{ value: "left", text: N("labels.left"), icon: CZ, testId: "align-left" }, { value: "center", text: N("labels.center"), icon: MZ, testId: "align-horizontal-center" }, { value: "right", text: N("labels.right"), icon: TZ, testId: "align-right" }], value: Yr(e, t, (a) => {
    if (we(a)) return a.textAlign;
    let l = lt(a, i);
    return l ? l.textAlign : null;
  }, (a) => we(a) || lt(a, i) !== null, (a) => a ? null : t.currentItemTextAlign), onChange: (a) => n(a) })] });
} });
ve({ name: "changeVerticalAlign", label: "Change vertical alignment", trackEvent: { category: "element" }, perform: (e, t, n, r) => ({ elements: Kr(e, t, (i) => {
  if (we(i)) {
    let a = at(i, { verticalAlign: n });
    return jr(a, r.scene.getContainerElement(i), r.scene.getNonDeletedElementsMap()), a;
  }
  return i;
}, !0), appState: { ...t }, captureUpdate: ne.IMMEDIATELY }), PanelComponent: ({ elements: e, appState: t, updateData: n, app: r }) => m("fieldset", { children: m(Rl, { group: "text-align", options: [{ value: Si.TOP, text: N("labels.alignTop"), icon: m(IZ, { theme: t.theme }), testId: "align-top" }, { value: Si.MIDDLE, text: N("labels.centerVertically"), icon: m(NZ, { theme: t.theme }), testId: "align-middle" }, { value: Si.BOTTOM, text: N("labels.alignBottom"), icon: m(AZ, { theme: t.theme }), testId: "align-bottom" }], value: Yr(e, t, (i) => {
  if (we(i) && i.containerId) return i.verticalAlign;
  let a = lt(i, r.scene.getNonDeletedElementsMap());
  return a ? a.verticalAlign : null;
}, (i) => we(i) || lt(i, r.scene.getNonDeletedElementsMap()) !== null, (i) => i ? null : Si.MIDDLE), onChange: (i) => n(i) }) }) });
ve({ name: "changeRoundness", label: "Change edge roundness", trackEvent: !1, perform: (e, t, n) => ({ elements: Kr(e, t, (r) => Se(r) ? r : at(r, { roundness: n === "round" ? { type: ru(r.type) ? Jn.ADAPTIVE_RADIUS : Jn.PROPORTIONAL_RADIUS } : null })), appState: { ...t, currentItemRoundness: n }, captureUpdate: ne.IMMEDIATELY }), PanelComponent: ({ elements: e, appState: t, updateData: n }) => {
  let r = nD(Jt(e), t).some((i) => {
    var a;
    return ((a = i.roundness) == null ? void 0 : a.type) === Jn.LEGACY;
  });
  return D("fieldset", { children: [m("legend", { children: N("labels.edges") }), m(Rl, { group: "edges", options: [{ value: "sharp", text: N("labels.sharp"), icon: oZ }, { value: "round", text: N("labels.round"), icon: cZ }], value: Yr(e, t, (i) => r ? null : i.roundness ? "round" : "sharp", (i) => !dt(i) && i.hasOwnProperty("roundness"), (i) => i ? null : t.currentItemRoundness), onChange: (i) => n(i) })] });
} });
var kS = (e) => [{ value: null, text: N("labels.arrowhead_none"), keyBinding: "q", icon: dZ }, { value: "arrow", text: N("labels.arrowhead_arrow"), keyBinding: "w", icon: m(uZ, { flip: e }) }, { value: "triangle", text: N("labels.arrowhead_triangle"), icon: m(mZ, { flip: e }), keyBinding: "e" }, { value: "triangle_outline", text: N("labels.arrowhead_triangle_outline"), icon: m(gZ, { flip: e }), keyBinding: "r" }, { value: "circle", text: N("labels.arrowhead_circle"), keyBinding: "a", icon: m(hZ, { flip: e }) }, { value: "circle_outline", text: N("labels.arrowhead_circle_outline"), keyBinding: "s", icon: m(fZ, { flip: e }) }, { value: "diamond", text: N("labels.arrowhead_diamond"), icon: m(bZ, { flip: e }), keyBinding: "d" }, { value: "diamond_outline", text: N("labels.arrowhead_diamond_outline"), icon: m(UZ, { flip: e }), keyBinding: "f" }, { value: "bar", text: N("labels.arrowhead_bar"), keyBinding: "z", icon: m(pZ, { flip: e }) }, { value: "crowfoot_one", text: N("labels.arrowhead_crowfoot_one"), icon: m(yZ, { flip: e }), keyBinding: "c" }, { value: "crowfoot_many", text: N("labels.arrowhead_crowfoot_many"), icon: m(vZ, { flip: e }), keyBinding: "x" }, { value: "crowfoot_one_or_many", text: N("labels.arrowhead_crowfoot_one_or_many"), icon: m(wZ, { flip: e }), keyBinding: "v" }];
ve({ name: "changeArrowhead", label: "Change arrowheads", trackEvent: !1, perform: (e, t, n) => ({ elements: Kr(e, t, (r) => {
  if (et(r)) {
    let { position: i, type: a } = n;
    if (i === "start") return at(r, { startArrowhead: a });
    if (i === "end") return at(r, { endArrowhead: a });
  }
  return r;
}), appState: { ...t, [n.position === "start" ? "currentItemStartArrowhead" : "currentItemEndArrowhead"]: n.type }, captureUpdate: ne.IMMEDIATELY }), PanelComponent: ({ elements: e, appState: t, updateData: n }) => {
  let r = df().rtl;
  return D("fieldset", { children: [m("legend", { children: N("labels.arrowheads") }), D("div", { className: "iconSelectList buttonList", children: [m(ES, { label: "arrowhead_start", options: kS(!r), value: Yr(e, t, (i) => et(i) && Im(i.type) ? i.startArrowhead : t.currentItemStartArrowhead, !0, t.currentItemStartArrowhead), onChange: (i) => n({ position: "start", type: i }), numberOfOptionsToAlwaysShow: 4 }), m(ES, { label: "arrowhead_end", group: "arrowheads", options: kS(!!r), value: Yr(e, t, (i) => et(i) && Im(i.type) ? i.endArrowhead : t.currentItemEndArrowhead, !0, t.currentItemEndArrowhead), onChange: (i) => n({ position: "end", type: i }), numberOfOptionsToAlwaysShow: 4 })] })] });
} });
ve({ name: "changeArrowType", label: "Change arrow types", trackEvent: !1, perform: (e, t, n, r) => {
  var s;
  let i = Kr(e, t, (c) => {
    if (!dt(c)) return c;
    let d = at(c, { roundness: n === br.round ? { type: Jn.PROPORTIONAL_RADIUS } : null, elbowed: n === br.elbow, points: n === br.elbow || c.elbowed ? [c.points[0], c.points[c.points.length - 1]] : c.points });
    if (Se(d)) {
      let o = r.scene.getNonDeletedElementsMap();
      r.dismissLinearEditor();
      let u = Ee.getPointAtIndexGlobalCoordinates(d, 0, o), h = Ee.getPointAtIndexGlobalCoordinates(d, -1, o), f = !d.startBinding && Sa(xa(u), e, o, t.zoom, !1, !0), p = !d.endBinding && Sa(xa(h), e, o, t.zoom, !1, !0), g = f || d.startBinding && o.get(d.startBinding.elementId), b = p || d.endBinding && o.get(d.endBinding.elementId), v = f ? Jh(d, f, "start") : u, U = p ? Jh(d, p, "end") : h;
      f && Sl(d, f, "start", o), p && Sl(d, p, "end", o), le(d, { points: [v, U].map((y) => T(y[0] - d.x, y[1] - d.y)), ...g && d.startBinding ? { startBinding: { ...d.startBinding, ...Dm(d, g, "start") } } : {}, ...b && d.endBinding ? { endBinding: { ...d.endBinding, ...Dm(d, b, "end") } } : {} }), Ee.updateEditorMidPointsCache(d, o, r.state);
    }
    return d;
  }), a = { ...t, currentItemArrowType: n }, l = (s = t.selectedLinearElement) == null ? void 0 : s.elementId;
  if (l) {
    let c = i.find((d) => d.id === l);
    c && (a.selectedLinearElement = new Ee(c));
  }
  return { elements: i, appState: a, captureUpdate: ne.IMMEDIATELY };
}, PanelComponent: ({ elements: e, appState: t, updateData: n }) => D("fieldset", { children: [m("legend", { children: N("labels.arrowtypes") }), m(Rl, { group: "arrowtypes", options: [{ value: br.sharp, text: N("labels.arrowtype_sharp"), icon: iJ, testId: "sharp-arrow" }, { value: br.round, text: N("labels.arrowtype_round"), icon: lJ, testId: "round-arrow" }, { value: br.elbow, text: N("labels.arrowtype_elbowed"), icon: aJ, testId: "elbow-arrow" }], value: Yr(e, t, (r) => dt(r) ? r.elbowed ? br.elbow : r.roundness ? br.round : br.sharp : null, (r) => dt(r), (r) => r ? null : t.currentItemArrowType), onChange: (r) => n(r) })] }) });
var mc = ({ viewportX: e, viewportY: t, nextZoom: n }, r) => {
  let i = e - r.offsetLeft, a = t - r.offsetTop, l = r.zoom.value, s = r.scrollX + (i - i / l), c = r.scrollY + (a - a / l), d = -(i - i / n), o = -(a - a / n);
  return { scrollX: s + d, scrollY: c + o, zoom: { value: n } };
}, Eh = () => {
  let e = document.querySelector(".excalidraw-tooltip");
  if (e) return e;
  let t = document.createElement("div");
  return document.body.appendChild(t), t.classList.add("excalidraw-tooltip"), t;
}, xR = (e, t, n = "bottom") => {
  let r = e.getBoundingClientRect(), i = window.innerWidth, a = window.innerHeight, l = 5, s = t.left + t.width / 2 - r.width / 2;
  s < 0 ? s = l : s + r.width >= i && (s = i - r.width - l);
  let c;
  n === "bottom" ? (c = t.top + t.height + l, c + r.height >= a && (c = t.top - r.height - l)) : (c = t.top - r.height - l, c < 0 && (c = t.top + t.height + l)), Object.assign(e.style, { top: `${c}px`, left: `${s}px` });
}, _he = (e, t, n, r) => {
  t.classList.add("excalidraw-tooltip--visible"), t.style.minWidth = r ? "50ch" : "10ch", t.style.maxWidth = r ? "50ch" : "15ch", t.textContent = n;
  let i = e.getBoundingClientRect();
  xR(t, i);
}, ed = ({ children: e, label: t, long: n = !1, style: r, disabled: i }) => (Y(() => () => Eh().classList.remove("excalidraw-tooltip--visible"), []), i ? null : m("div", { className: "excalidraw-tooltip-wrapper", onPointerEnter: (a) => _he(a.currentTarget, Eh(), t, n), onPointerLeave: () => Eh().classList.remove("excalidraw-tooltip--visible"), style: r, children: e }));
ve({ name: "changeViewBackgroundColor", label: "labels.canvasBackground", paletteName: "Change canvas background color", trackEvent: !1, predicate: (e, t, n, r) => !!r.props.UIOptions.canvasActions.changeViewBackgroundColor && !t.viewModeEnabled, perform: (e, t, n) => ({ appState: { ...t, ...n }, captureUpdate: n.viewBackgroundColor ? ne.IMMEDIATELY : ne.EVENTUALLY }), PanelComponent: ({ elements: e, appState: t, updateData: n, appProps: r }) => m(HU, { palette: null, topPicks: SI, label: N("labels.canvasBackground"), type: "canvasBackground", color: t.viewBackgroundColor, onChange: (i) => n({ viewBackgroundColor: i }), "data-testid": "canvas-background-picker", elements: e, appState: t, updateData: n }) });
var Sh = ve({ name: "clearCanvas", label: "labels.clearCanvas", paletteName: "Clear canvas", icon: jc, trackEvent: { category: "canvas" }, predicate: (e, t, n, r) => {
  var i;
  return !!r.props.UIOptions.canvasActions.clearCanvas && !t.viewModeEnabled && ((i = t.openDialog) == null ? void 0 : i.name) !== "elementLinkSelector";
}, perform: (e, t, n, r) => (r.imageCache.clear(), { elements: e.map((i) => at(i, { isDeleted: !0 })), appState: { ...El(), files: {}, theme: t.theme, penMode: t.penMode, penDetected: t.penDetected, exportBackground: t.exportBackground, exportEmbedScene: t.exportEmbedScene, gridSize: t.gridSize, gridStep: t.gridStep, gridModeEnabled: t.gridModeEnabled, stats: t.stats, pasteDialog: t.pasteDialog, activeTool: t.activeTool.type === "image" ? { ...t.activeTool, type: "selection" } : t.activeTool }, captureUpdate: ne.IMMEDIATELY }) }), CS = ve({ name: "zoomIn", label: "buttons.zoomIn", viewMode: !0, icon: Qw, trackEvent: { category: "canvas" }, perform: (e, t, n, r) => ({ appState: { ...t, ...mc({ viewportX: t.width / 2 + t.offsetLeft, viewportY: t.height / 2 + t.offsetTop, nextZoom: as(t.zoom.value + Yg) }, t), userToFollow: null }, captureUpdate: ne.EVENTUALLY }), PanelComponent: ({ updateData: e, appState: t }) => m(yt, { type: "button", className: "zoom-in-button zoom-button", icon: Qw, title: `${N("buttons.zoomIn")} — ${ae("CtrlOrCmd++")}`, "aria-label": N("buttons.zoomIn"), disabled: t.zoom.value >= f8, onClick: () => {
  e(null);
} }), keyTest: (e) => (e.code === xt.EQUAL || e.code === xt.NUM_ADD) && (e[H.CTRL_OR_CMD] || e.shiftKey) }), MS = ve({ name: "zoomOut", label: "buttons.zoomOut", icon: ex, viewMode: !0, trackEvent: { category: "canvas" }, perform: (e, t, n, r) => ({ appState: { ...t, ...mc({ viewportX: t.width / 2 + t.offsetLeft, viewportY: t.height / 2 + t.offsetTop, nextZoom: as(t.zoom.value - Yg) }, t), userToFollow: null }, captureUpdate: ne.EVENTUALLY }), PanelComponent: ({ updateData: e, appState: t }) => m(yt, { type: "button", className: "zoom-out-button zoom-button", icon: ex, title: `${N("buttons.zoomOut")} — ${ae("CtrlOrCmd+-")}`, "aria-label": N("buttons.zoomOut"), disabled: t.zoom.value <= h8, onClick: () => {
  e(null);
} }), keyTest: (e) => (e.code === xt.MINUS || e.code === xt.NUM_SUBTRACT) && (e[H.CTRL_OR_CMD] || e.shiftKey) }), TS = ve({ name: "resetZoom", label: "buttons.resetZoom", icon: Oq, viewMode: !0, trackEvent: { category: "canvas" }, perform: (e, t, n, r) => ({ appState: { ...t, ...mc({ viewportX: t.width / 2 + t.offsetLeft, viewportY: t.height / 2 + t.offsetTop, nextZoom: as(1) }, t), userToFollow: null }, captureUpdate: ne.EVENTUALLY }), PanelComponent: ({ updateData: e, appState: t }) => m(ed, { label: N("buttons.resetZoom"), style: { height: "100%" }, children: D(yt, { type: "button", className: "reset-zoom-button zoom-button", title: N("buttons.resetZoom"), "aria-label": N("buttons.resetZoom"), onClick: () => {
  e(null);
}, children: [(t.zoom.value * 100).toFixed(0), "%"] }) }), keyTest: (e) => (e.code === xt.ZERO || e.code === xt.NUM_ZERO) && (e[H.CTRL_OR_CMD] || e.shiftKey) }), khe = (e, t, n = 1) => {
  let [r, i, a, l] = e, s = a - r, c = t.width / s, d = l - i, o = t.height / d, u = Math.min(c, o) * ft(n, 0.1, 1);
  return Math.min(u, 1);
}, Che = ({ bounds: e, appState: t, canvasOffsets: n, fitToViewport: r = !1, viewportZoomFactor: i = 1, minZoom: a = -1 / 0, maxZoom: l = 1 / 0 }) => {
  i = ft(i, h8, f8);
  let [s, c, d, o] = e, u = (s + d) / 2, h = (c + o) / 2, f = (n == null ? void 0 : n.left) ?? 0, p = (n == null ? void 0 : n.top) ?? 0, g = (n == null ? void 0 : n.right) ?? 0, b = (n == null ? void 0 : n.bottom) ?? 0, v = t.width - f - g, U = t.height - p - b, y;
  if (r) {
    let E = d - s, S = o - c;
    y = Math.min(v / E, U / S) * i;
  } else y = khe(e, { width: v, height: U }, i);
  let w = as(ft(kY(y, Yg, "floor"), a, l)), x = tN({ scenePoint: { x: u, y: h }, viewportDimensions: { width: t.width, height: t.height }, offsets: n, zoom: { value: w } });
  return { appState: { ...t, scrollX: x.scrollX, scrollY: x.scrollY, zoom: { value: w } }, captureUpdate: ne.EVENTUALLY };
}, D2 = ({ canvasOffsets: e, targetElements: t, appState: n, fitToViewport: r, viewportZoomFactor: i, minZoom: a, maxZoom: l }) => {
  let s = Lt(Jt(t));
  return Che({ canvasOffsets: e, bounds: s, appState: n, fitToViewport: r, viewportZoomFactor: i, minZoom: a, maxZoom: l });
};
ve({ name: "zoomToFitSelectionInViewport", label: "labels.zoomToFitViewport", icon: T8, trackEvent: { category: "canvas" }, perform: (e, t, n, r) => {
  let i = r.scene.getSelectedElements(t);
  return D2({ targetElements: i.length ? i : e, appState: { ...t, userToFollow: null }, fitToViewport: !1, canvasOffsets: r.getEditorUIOffsets() });
}, keyTest: (e) => e.code === xt.TWO && e.shiftKey && !e.altKey && !e[H.CTRL_OR_CMD] });
ve({ name: "zoomToFitSelection", label: "helpDialog.zoomToSelection", icon: T8, trackEvent: { category: "canvas" }, perform: (e, t, n, r) => {
  let i = r.scene.getSelectedElements(t);
  return D2({ targetElements: i.length ? i : e, appState: { ...t, userToFollow: null }, fitToViewport: !0, canvasOffsets: r.getEditorUIOffsets() });
}, keyTest: (e) => e.code === xt.THREE && e.shiftKey && !e.altKey && !e[H.CTRL_OR_CMD] });
ve({ name: "zoomToFit", label: "helpDialog.zoomToFit", icon: T8, viewMode: !0, trackEvent: { category: "canvas" }, perform: (e, t, n, r) => D2({ targetElements: e, appState: { ...t, userToFollow: null }, fitToViewport: !1, canvasOffsets: r.getEditorUIOffsets() }), keyTest: (e) => e.code === xt.ONE && e.shiftKey && !e.altKey && !e[H.CTRL_OR_CMD] });
var Jm = ve({ name: "toggleTheme", label: (e, t) => t.theme === gt.DARK ? "buttons.lightMode" : "buttons.darkMode", keywords: ["toggle", "dark", "light", "mode", "theme"], icon: (e) => e.theme === gt.LIGHT ? s7 : o7, viewMode: !0, trackEvent: { category: "canvas" }, perform: (e, t, n) => ({ appState: { ...t, theme: n || (t.theme === gt.LIGHT ? gt.DARK : gt.LIGHT) }, captureUpdate: ne.EVENTUALLY }), keyTest: (e) => e.altKey && e.shiftKey && e.code === xt.D, predicate: (e, t, n, r) => !!r.props.UIOptions.canvasActions.toggleTheme });
ve({ name: "toggleEraserTool", label: "toolBar.eraser", trackEvent: { category: "toolbar" }, perform: (e, t) => {
  let n;
  return tl(t) ? n = Wn(t, { ...t.activeTool.lastActiveTool || { type: "selection" }, lastActiveToolBeforeEraser: null }) : n = Wn(t, { type: "eraser", lastActiveToolBeforeEraser: t.activeTool }), { appState: { ...t, selectedElementIds: {}, selectedGroupIds: {}, activeEmbeddable: null, activeTool: n }, captureUpdate: ne.IMMEDIATELY };
}, keyTest: (e) => e.key === H.E });
var Mhe = ve({ name: "toggleHandTool", label: "toolBar.hand", paletteName: "Toggle hand tool", trackEvent: { category: "toolbar" }, icon: oA, viewMode: !1, perform: (e, t, n, r) => {
  let i;
  return m0(t) ? i = Wn(t, { ...t.activeTool.lastActiveTool || { type: "selection" }, lastActiveToolBeforeEraser: null }) : (i = Wn(t, { type: "hand", lastActiveToolBeforeEraser: t.activeTool }), Ht(r.interactiveCanvas, Ot.GRAB)), { appState: { ...t, selectedElementIds: {}, selectedGroupIds: {}, activeEmbeddable: null, activeTool: i }, captureUpdate: ne.IMMEDIATELY };
}, keyTest: (e) => !e.altKey && !e[H.CTRL_OR_CMD] && e.key === H.H }), ca = ve({ name: "finalize", label: "", trackEvent: !1, perform: (e, t, n, r) => {
  var h;
  let { interactiveCanvas: i, focusContainer: a, scene: l } = r, s = l.getNonDeletedElementsMap();
  if (t.editingLinearElement) {
    let { elementId: f, startBindingElement: p, endBindingElement: g } = t.editingLinearElement, b = Ee.getElement(f, s);
    if (b) return hl(b) && s2(b, p, g, s, l), { elements: b.points.length < 2 || M0(b) ? e.filter((v) => v.id !== b.id) : void 0, appState: { ...t, cursorButton: "up", editingLinearElement: null }, captureUpdate: ne.IMMEDIATELY };
  }
  let c = e, d = t.pendingImageElementId && l.getElement(t.pendingImageElementId);
  d && le(d, { isDeleted: !0 }, !1), window.document.activeElement instanceof HTMLElement && a();
  let o = t.multiElement ? t.multiElement : ((h = t.newElement) == null ? void 0 : h.type) === "freedraw" ? t.newElement : null;
  if (o) {
    if (o.type !== "freedraw" && t.lastPointerDownWith !== "touch") {
      let { points: p, lastCommittedPoint: g } = o;
      (!g || p[p.length - 1] !== g) && le(o, { points: o.points.slice(0, -1) });
    }
    M0(o) && (c = c.filter((p) => p.id !== o.id));
    let f = Us(o.points, t.zoom.value);
    if ((o.type === "line" || o.type === "freedraw") && f) {
      let p = o.points, g = p[0];
      le(o, { points: p.map((b, v) => v === p.length - 1 ? T(g[0], g[1]) : b) });
    }
    if (hl(o) && !f && o.points.length > 1) {
      let [p, g] = Ee.getPointAtIndexGlobalCoordinates(o, -1, Ge(e));
      b7(o, t, { x: p, y: g }, s, e);
    }
  }
  (!t.activeTool.locked && t.activeTool.type !== "freedraw" || !o) && fa(i);
  let u;
  return t.activeTool.type === "eraser" ? u = Wn(t, { ...t.activeTool.lastActiveTool || { type: "selection" }, lastActiveToolBeforeEraser: null }) : u = Wn(t, { type: "selection" }), { elements: c, appState: { ...t, cursorButton: "up", activeTool: (t.activeTool.locked || t.activeTool.type === "freedraw") && o ? t.activeTool : u, activeEmbeddable: null, newElement: null, selectionElement: null, multiElement: null, editingTextElement: null, startBoundElement: null, suggestedBindings: [], selectedElementIds: o && !t.activeTool.locked && t.activeTool.type !== "freedraw" ? { ...t.selectedElementIds, [o.id]: !0 } : t.selectedElementIds, selectedLinearElement: o && et(o) ? new Ee(o) : t.selectedLinearElement, pendingImageElementId: null }, captureUpdate: ne.IMMEDIATELY };
}, keyTest: (e, t) => e.key === H.ESCAPE && (t.editingLinearElement !== null || !t.newElement && t.multiElement === null) || (e.key === H.ESCAPE || e.key === H.ENTER) && t.multiElement !== null, PanelComponent: ({ appState: e, updateData: t, data: n }) => m(yt, { type: "button", icon: jq, title: N("buttons.done"), "aria-label": N("buttons.done"), onClick: t, visible: e.multiElement != null, size: (n == null ? void 0 : n.size) || "medium", style: { pointerEvents: "all" } }) }), The = (e) => {
  let { id: t } = Ol(), [n, r] = Q(e.value), i = (l) => {
    e.ignoreFocus || jY(l.target);
    let s = l.target.value;
    s !== e.value && e.onChange(s);
  }, a = (l) => {
    if (l.key === H.ENTER) {
      if (l.preventDefault(), l.nativeEvent.isComposing || l.keyCode === 229) return;
      l.currentTarget.blur();
    }
  };
  return D("div", { className: "ProjectName", children: [m("label", { className: "ProjectName-label", htmlFor: "filename", children: `${e.label}:` }), m("input", { type: "text", className: "TextInput", onBlur: i, onKeyDown: a, id: `${t}-filename`, value: n, onChange: (l) => r(l.target.value) })] });
}, Ihe = (e) => {
  let t = e.title || (e.value === gt.DARK ? N("buttons.lightMode") : N("buttons.darkMode"));
  return m(yt, { type: "icon", icon: e.value === gt.LIGHT ? IS.MOON : IS.SUN, title: t, "aria-label": t, onClick: () => e.onChange(e.value === gt.DARK ? gt.LIGHT : gt.DARK), "data-testid": "toggle-dark-mode" });
}, IS = { SUN: m("svg", { width: "512", height: "512", className: "rtl-mirror", viewBox: "0 0 512 512", children: m("path", { fill: "currentColor", d: "M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z" }) }), MOON: m("svg", { width: "512", height: "512", className: "rtl-mirror", viewBox: "0 0 512 512", children: m("path", { fill: "currentColor", d: "M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z" }) }) }, L2 = (e, { selectedElementIds: t }, n) => {
  e = Jt(e);
  let r = n && Qn(e, { selectedElementIds: t }), i = null, a = r ? ct(e, { selectedElementIds: t }, { includeBoundTextElement: !0 }) : e;
  return r && (a.length === 1 && Ve(a[0]) ? (i = a[0], a = uU(e, i)) : a.length > 1 && (a = ct(e, { selectedElementIds: t }, { includeBoundTextElement: !0, includeElementsInFrames: !0 }))), { exportingFrame: i, exportedElements: cs(a) };
}, R2 = async (e, t, n, r, { exportBackground: i, exportPadding: a = tu, viewBackgroundColor: l, name: s = n.name || AI, fileHandle: c = null, exportingFrame: d = null }) => {
  if (t.length === 0) throw new Error(N("alerts.cannotExportEmptyCanvas"));
  if (e === "svg" || e === "clipboard-svg") {
    let u = j8(t, { exportBackground: i, exportWithDarkMode: n.exportWithDarkMode, viewBackgroundColor: l, exportPadding: a, exportScale: n.exportScale, exportEmbedScene: n.exportEmbedScene && e === "svg" }, r, { exportingFrame: d });
    if (e === "svg") return $m(u.then((h) => new Blob([h.outerHTML], { type: $e.svg })), { description: "Export to SVG", name: s, extension: n.exportEmbedScene ? "excalidraw.svg" : "svg", mimeTypes: [p0.svg], fileHandle: c });
    if (e === "clipboard-svg") {
      let h = await u.then((f) => f.outerHTML);
      try {
        await jf(h);
      } catch {
        throw new Error(N("errors.copyToSystemClipboardFailed"));
      }
      return;
    }
  }
  let o = BN(t, n, r, { exportBackground: i, viewBackgroundColor: l, exportPadding: a, exportingFrame: d });
  if (e === "png") {
    let u = sf(o);
    return n.exportEmbedScene && (u = u.then((h) => import("./image-7KUKJ7J4-BYoMfS0s.js").then(({ encodePngMetadata: f }) => f({ blob: h, metadata: W8(t, n, r) })))), $m(u, { description: "Export to PNG", name: s, extension: n.exportEmbedScene ? "excalidraw.png" : "png", mimeTypes: [p0.png], fileHandle: c });
  } else if (e === "clipboard") try {
    let u = sf(o);
    await ile(u);
  } catch (u) {
    throw console.warn(u), u.name === "CANVAS_POSSIBLY_TOO_BIG" ? new Error(N("canvasError.canvasTooBig")) : Vh && u.name === "TypeError" ? new Error(`${N("alerts.couldNotCopyToClipboard")}

${N("hints.firefox_clipboard_write")}`) : new Error(N("alerts.couldNotCopyToClipboard"));
  }
  else throw new Error("Unsupported export type");
}, Ahe = async (e, t, n, r) => {
  let { exportBackground: i, viewBackgroundColor: a, fileHandle: l } = t, s = uD(l);
  if (!l || !Ble(s)) throw new Error("fileHandle should exist and should be of type svg or png when resaving");
  t = { ...t, exportEmbedScene: !0 };
  let { exportedElements: c, exportingFrame: d } = L2(e, t, !1);
  return await R2(s, c, t, n, { exportBackground: i, viewBackgroundColor: a, name: r, fileHandle: l, exportingFrame: d }), { fileHandle: l };
}, GU = ({ children: e, checked: t, onChange: n, className: r }) => D("div", { className: Me("Checkbox", r, { "is-checked": t }), onClick: (i) => {
  n(!t, i), i.currentTarget.querySelector(".Checkbox-box").focus();
}, children: [m("button", { type: "button", className: "Checkbox-box", role: "checkbox", "aria-checked": t, children: Hq }), m("div", { className: "Checkbox-label", children: e })] }), Nhe = ve({ name: "changeProjectName", label: "labels.fileTitle", trackEvent: !1, perform: (e, t, n) => ({ appState: { ...t, name: n }, captureUpdate: ne.EVENTUALLY }), PanelComponent: ({ appState: e, updateData: t, appProps: n, data: r, app: i }) => m(The, { label: N("labels.fileTitle"), value: i.getName(), onChange: (a) => t(a), ignoreFocus: (r == null ? void 0 : r.ignoreFocus) ?? !1 }) }), Dhe = ve({ name: "changeExportScale", label: "imageExportDialog.scale", trackEvent: { category: "export", action: "scale" }, perform: (e, t, n) => ({ appState: { ...t, exportScale: n }, captureUpdate: ne.EVENTUALLY }), PanelComponent: ({ elements: e, appState: t, updateData: n }) => {
  let r = Jt(e), i = Qn(r, t) ? ct(r, t) : r;
  return m(ge, { children: m8.map((a) => {
    let [l, s] = wae(i, tu, a), c = `${N("imageExportDialog.label.scale")} ${a}x (${l}x${s})`;
    return m(yt, { size: "small", type: "radio", icon: `${a}x`, name: "export-canvas-scale", title: c, "aria-label": c, id: "export-canvas-scale", checked: a === t.exportScale, onChange: () => n(a) }, a);
  }) });
} }), Lhe = ve({ name: "changeExportBackground", label: "imageExportDialog.label.withBackground", trackEvent: { category: "export", action: "toggleBackground" }, perform: (e, t, n) => ({ appState: { ...t, exportBackground: n }, captureUpdate: ne.EVENTUALLY }), PanelComponent: ({ appState: e, updateData: t }) => m(GU, { checked: e.exportBackground, onChange: (n) => t(n), children: N("imageExportDialog.label.withBackground") }) }), ER = ve({ name: "changeExportEmbedScene", label: "imageExportDialog.tooltip.embedScene", trackEvent: { category: "export", action: "embedScene" }, perform: (e, t, n) => ({ appState: { ...t, exportEmbedScene: n }, captureUpdate: ne.EVENTUALLY }), PanelComponent: ({ appState: e, updateData: t }) => D(GU, { checked: e.exportEmbedScene, onChange: (n) => t(n), children: [N("imageExportDialog.label.embedScene"), m(ed, { label: N("imageExportDialog.tooltip.embedScene"), long: !0, children: m("div", { className: "excalidraw-tooltip-icon", children: Kq }) })] }) }), AS = ve({ name: "saveToActiveFile", label: "buttons.save", icon: t2, trackEvent: { category: "export" }, predicate: (e, t, n, r) => !!r.props.UIOptions.canvasActions.saveToActiveFile && !!t.fileHandle && !t.viewModeEnabled, perform: async (e, t, n, r) => {
  let i = !!t.fileHandle;
  try {
    let { fileHandle: a } = vU(t.fileHandle) ? await Ahe(e, t, r.files, r.getName()) : await _N(e, t, r.files, r.getName());
    return { captureUpdate: ne.EVENTUALLY, appState: { ...t, fileHandle: a, toast: i ? { message: a != null && a.name ? N("toast.fileSavedToFilename").replace("{filename}", `"${a.name}"`) : N("toast.fileSaved") } : null } };
  } catch (a) {
    return (a == null ? void 0 : a.name) !== "AbortError" ? console.error(a) : console.warn(a), { captureUpdate: ne.EVENTUALLY };
  }
}, keyTest: (e) => e.key === H.S && e[H.CTRL_OR_CMD] && !e.shiftKey }), SR = ve({ name: "saveFileToDisk", label: "exportDialog.disk_title", icon: t2, viewMode: !0, trackEvent: { category: "export" }, perform: async (e, t, n, r) => {
  try {
    let { fileHandle: i } = await _N(e, { ...t, fileHandle: null }, r.files, r.getName());
    return { captureUpdate: ne.EVENTUALLY, appState: { ...t, openDialog: null, fileHandle: i, toast: { message: N("toast.fileSaved") } } };
  } catch (i) {
    return (i == null ? void 0 : i.name) !== "AbortError" ? console.error(i) : console.warn(i), { captureUpdate: ne.EVENTUALLY };
  }
}, keyTest: (e) => e.key === H.S && e.shiftKey && e[H.CTRL_OR_CMD], PanelComponent: ({ updateData: e }) => m(yt, { type: "button", icon: Xq, title: N("buttons.saveAs"), "aria-label": N("buttons.saveAs"), showAriaLabel: ur().editor.isMobile, hidden: !od, onClick: () => e(null), "data-testid": "save-as-button" }) }), Q7 = ve({ name: "loadScene", label: "buttons.load", trackEvent: { category: "export" }, predicate: (e, t, n, r) => !!r.props.UIOptions.canvasActions.loadScene && !t.viewModeEnabled, perform: async (e, t, n, r) => {
  try {
    let { elements: i, appState: a, files: l } = await uae(t, e);
    return { elements: i, appState: a, files: l, captureUpdate: ne.IMMEDIATELY };
  } catch (i) {
    return (i == null ? void 0 : i.name) === "AbortError" ? (console.warn(i), !1) : { elements: e, appState: { ...t, errorMessage: i.message }, files: r.files, captureUpdate: ne.EVENTUALLY };
  }
}, keyTest: (e) => e[H.CTRL_OR_CMD] && e.key === H.O }), Rhe = ve({ name: "exportWithDarkMode", label: "imageExportDialog.label.darkMode", trackEvent: { category: "export", action: "toggleTheme" }, perform: (e, t, n) => ({ appState: { ...t, exportWithDarkMode: n }, captureUpdate: ne.EVENTUALLY }), PanelComponent: ({ appState: e, updateData: t }) => m("div", { style: { display: "flex", justifyContent: "flex-end", marginTop: "-45px", marginBottom: "10px" }, children: m(Ihe, { value: e.exportWithDarkMode ? gt.DARK : gt.LIGHT, onChange: (n) => {
  t(n === gt.DARK);
}, title: N("imageExportDialog.label.darkMode") }) }) }), _R = "{}", Phe = ve({ name: "copyStyles", label: "labels.copyStyles", icon: pA, trackEvent: { category: "element" }, perform: (e, t, n, r) => {
  let i = [], a = e.find((l) => t.selectedElementIds[l.id]);
  if (i.push(a), a && ra(a)) {
    let l = lt(a, r.scene.getNonDeletedElementsMap());
    i.push(l);
  }
  return a && (_R = JSON.stringify(i)), { appState: { ...t, toast: { message: N("toast.copyStyles") } }, captureUpdate: ne.EVENTUALLY };
}, keyTest: (e) => e[H.CTRL_OR_CMD] && e.altKey && e.code === xt.C }), Ohe = ve({ name: "pasteStyles", label: "labels.pasteStyles", icon: pA, trackEvent: { category: "element" }, perform: (e, t, n, r) => {
  let i = JSON.parse(_R), a = i[0], l = i[1];
  if (!jI(a)) return { elements: e, captureUpdate: ne.EVENTUALLY };
  let s = ct(e, t, { includeBoundTextElement: !0 }), c = s.map((d) => d.id);
  return { elements: e.map((d) => {
    if (c.includes(d.id)) {
      let o = a;
      if (we(d) && d.containerId && (o = l), !o) return d;
      let u = at(d, { backgroundColor: o == null ? void 0 : o.backgroundColor, strokeWidth: o == null ? void 0 : o.strokeWidth, strokeColor: o == null ? void 0 : o.strokeColor, strokeStyle: o == null ? void 0 : o.strokeStyle, fillStyle: o == null ? void 0 : o.fillStyle, opacity: o == null ? void 0 : o.opacity, roughness: o == null ? void 0 : o.roughness, roundness: o.roundness ? iq(o.roundness.type, d) ? o.roundness : aq(d) : null });
      if (we(u)) {
        let h = o.fontSize || Is, f = o.fontFamily || Oo;
        u = at(u, { fontSize: h, fontFamily: f, textAlign: o.textAlign || Ff, lineHeight: o.lineHeight || Yc(f) });
        let p = null;
        u.containerId && (p = s.find((g) => we(u) && g.id === u.containerId) || null), jr(u, p, r.scene.getNonDeletedElementsMap());
      }
      return u.type === "arrow" && dt(o) && (u = at(u, { startArrowhead: o.startArrowhead, endArrowhead: o.endArrowhead })), Ve(d) && (u = at(u, { roundness: null, backgroundColor: "transparent" })), u;
    }
    return d;
  }), captureUpdate: ne.IMMEDIATELY };
}, keyTest: (e) => e[H.CTRL_OR_CMD] && e.altKey && e.code === xt.V });
ve({ name: "toggleCanvasMenu", label: "buttons.menu", trackEvent: { category: "menu" }, perform: (e, t) => ({ appState: { ...t, openMenu: t.openMenu === "canvas" ? null : "canvas" }, captureUpdate: ne.EVENTUALLY }), PanelComponent: ({ appState: e, updateData: t }) => m(yt, { type: "button", icon: eA, "aria-label": N("buttons.menu"), onClick: t, selected: e.openMenu === "canvas" }) });
ve({ name: "toggleEditMenu", label: "buttons.edit", trackEvent: { category: "menu" }, perform: (e, t) => ({ appState: { ...t, openMenu: t.openMenu === "shape" ? null : "shape" }, captureUpdate: ne.EVENTUALLY }), PanelComponent: ({ elements: e, appState: t, updateData: n }) => m(yt, { visible: UU(t, Jt(e)), type: "button", icon: Vq, "aria-label": N("buttons.edit"), onClick: n, selected: t.openMenu === "shape" }) });
var jU = ve({ name: "toggleShortcuts", label: "welcomeScreen.defaults.helpHint", icon: Fq, viewMode: !0, trackEvent: { category: "menu", action: "toggleHelpDialog" }, perform: (e, t, n, { focusContainer: r }) => {
  var i, a;
  return ((i = t.openDialog) == null ? void 0 : i.name) === "help" && r(), { appState: { ...t, openDialog: ((a = t.openDialog) == null ? void 0 : a.name) === "help" ? null : { name: "help" } }, captureUpdate: ne.EVENTUALLY };
}, keyTest: (e) => e.key === H.QUESTION_MARK }), $he = (e) => {
  if (e.length >= 2) {
    let t = e[0].groupIds;
    for (let n of t) if (e.reduce((r, i) => r && tf(i, n), !0)) return !0;
  }
  return !1;
}, NS = (e, t, n) => {
  let r = n.scene.getSelectedElements({ selectedElementIds: t.selectedElementIds, includeBoundTextElement: !0 });
  return r.length >= 2 && !$he(r) && !eD(r);
}, Fhe = ve({ name: "group", label: "labels.group", icon: (e) => m(px, { theme: e.theme }), trackEvent: { category: "element" }, perform: (e, t, n, r) => {
  let i = dU(r.scene.getSelectedElements({ selectedElementIds: t.selectedElementIds, includeBoundTextElement: !0 }));
  if (i.length < 2) return { appState: t, elements: e, captureUpdate: ne.EVENTUALLY };
  let a = wc(t);
  if (a.length === 1) {
    let g = a[0], b = new Set(ln(e, g).map((U) => U.id)), v = new Set(i.map((U) => U.id));
    if ((/* @__PURE__ */ new Set([...Array.from(b), ...Array.from(v)])).size === b.size) return { appState: t, elements: e, captureUpdate: ne.EVENTUALLY };
  }
  let l = [...e];
  new Set(i.map((g) => g.frameId)).size > 1 && ple(i).forEach((g, b) => {
    b2(g, r.scene.getNonDeletedElementsMap());
  });
  let s = ia(), c = Ge(i);
  l = l.map((g) => c.get(g.id) ? at(g, { groupIds: bie(g.groupIds, s, t.editingGroupId) }) : g);
  let d = ln(l, s), o = d[d.length - 1], u = l.lastIndexOf(o), h = l.slice(u + 1), f = l.slice(0, u).filter((g) => !tf(g, s)), p = Cl([...f, ...d, ...h], Ge(d));
  return { appState: { ...t, ...rN(s, { ...t, selectedGroupIds: {} }, Jt(l)) }, elements: p, captureUpdate: ne.IMMEDIATELY };
}, predicate: (e, t, n, r) => NS(e, t, r), keyTest: (e) => !e.shiftKey && e[H.CTRL_OR_CMD] && e.key === H.G, PanelComponent: ({ elements: e, appState: t, updateData: n, app: r }) => m(yt, { hidden: !NS(e, t, r), type: "button", icon: m(px, { theme: t.theme }), onClick: () => n(null), title: `${N("labels.group")} — ${ae("CtrlOrCmd+G")}`, "aria-label": N("labels.group"), visible: Qn(Jt(e), t) }) }), zhe = ve({ name: "ungroup", label: "labels.ungroup", icon: (e) => m(mx, { theme: e.theme }), trackEvent: { category: "element" }, perform: (e, t, n, r) => {
  let i = wc(t), a = Ge(e);
  if (i.length === 0) return { appState: t, elements: e, captureUpdate: ne.EVENTUALLY };
  let l = [...e], s = [];
  l = l.map((u) => {
    sn(u) && s.push(u.id);
    let h = Uie(u.groupIds, t.selectedGroupIds);
    return h.length === u.groupIds.length ? u : at(u, { groupIds: h });
  });
  let c = Hr(t, Jt(l), t, null), d = r.scene.getSelectedElements(t), o = new Set(d.filter((u) => u.frameId).map((u) => u.frameId));
  return cU(e).filter((u) => o.has(u.id)).forEach((u) => {
    u && (l = JN(l, xp(l, u, t, a), u, r));
  }), c.selectedElementIds = Object.entries(c.selectedElementIds).reduce((u, [h, f]) => (f && !s.includes(h) && (u[h] = !0), u), {}), { appState: { ...t, ...c }, elements: l, captureUpdate: ne.IMMEDIATELY };
}, keyTest: (e) => e.shiftKey && e[H.CTRL_OR_CMD] && e.key === H.G.toUpperCase(), predicate: (e, t) => wc(t).length > 0, PanelComponent: ({ elements: e, appState: t, updateData: n }) => m(yt, { type: "button", hidden: wc(t).length === 0, icon: m(mx, { theme: t.theme }), onClick: () => n(null), title: `${N("labels.ungroup")} — ${ae("CtrlOrCmd+Shift+G")}`, "aria-label": N("labels.ungroup"), visible: Qn(Jt(e), t) }) }), kR = (e, t, n, r, i, a, l) => {
  e.beginPath(), e.moveTo(t + a, n), e.lineTo(t + r - a, n), e.quadraticCurveTo(t + r, n, t + r, n + a), e.lineTo(t + r, n + i - a), e.quadraticCurveTo(t + r, n + i, t + r - a, n + i), e.lineTo(t + a, n + i), e.quadraticCurveTo(t, n + i, t, n + i - a), e.lineTo(t, n + a), e.quadraticCurveTo(t, n, t + a, n), e.closePath(), e.fill(), l && (e.strokeStyle = l), e.stroke();
};
function Bhe(e) {
  let t = 0;
  if (e.length === 0) return t;
  for (let n = 0; n < e.length; n++) {
    let r = e.charCodeAt(n);
    t = (t << 5) - t + r;
  }
  return t;
}
var P2 = (e, t) => `hsl(${Math.abs(Bhe((t == null ? void 0 : t.id) || e)) % 37 * 10}, 100%, 83%)`, Hhe = (e) => {
  var n;
  let t = (n = e == null ? void 0 : e.trim()) == null ? void 0 : n.codePointAt(0);
  return (t ? String.fromCodePoint(t) : "?").toUpperCase();
}, Whe = ({ context: e, renderConfig: t, appState: n, normalizedWidth: r, normalizedHeight: i }) => {
  for (let [a, l] of t.remotePointerViewportCoords) {
    let { x: s, y: c } = l, d = n.collaborators.get(a);
    s -= n.offsetLeft, c -= n.offsetTop;
    let o = 11, u = 14, h = s < 0 || s > r - o || c < 0 || c > i - u;
    s = Math.max(s, 0), s = Math.min(s, r - o), c = Math.max(c, 0), c = Math.min(c, i - u);
    let f = P2(a, d);
    e.save(), e.strokeStyle = f, e.fillStyle = f;
    let p = t.remotePointerUserStates.get(a), g = h || p === "idle" || p === "away";
    g && (e.globalAlpha = 0.3), t.remotePointerButton.get(a) === "down" && (e.beginPath(), e.arc(s, c, 15, 0, 2 * Math.PI, !1), e.lineWidth = 3, e.strokeStyle = "#ffffff88", e.stroke(), e.closePath(), e.beginPath(), e.arc(s, c, 15, 0, 2 * Math.PI, !1), e.lineWidth = 1, e.strokeStyle = f, e.stroke(), e.closePath());
    let b = n.theme === gt.DARK ? "#2f6330" : aY, v = d == null ? void 0 : d.isSpeaking;
    v && (e.fillStyle = b, e.strokeStyle = b, e.lineWidth = 10, e.lineJoin = "round", e.beginPath(), e.moveTo(s, c), e.lineTo(s + 0, c + 14), e.lineTo(s + 4, c + 9), e.lineTo(s + 11, c + 8), e.closePath(), e.stroke(), e.fill()), e.fillStyle = I1, e.strokeStyle = I1, e.lineWidth = 6, e.lineJoin = "round", e.beginPath(), e.moveTo(s, c), e.lineTo(s + 0, c + 14), e.lineTo(s + 4, c + 9), e.lineTo(s + 11, c + 8), e.closePath(), e.stroke(), e.fill(), e.fillStyle = f, e.strokeStyle = f, e.lineWidth = 2, e.lineJoin = "round", e.beginPath(), g ? (e.moveTo(s - 1, c - 1), e.lineTo(s - 1, c + 15), e.lineTo(s + 5, c + 10), e.lineTo(s + 12, c + 9), e.closePath(), e.fill()) : (e.moveTo(s, c), e.lineTo(s + 0, c + 14), e.lineTo(s + 4, c + 9), e.lineTo(s + 11, c + 8), e.closePath(), e.fill(), e.stroke());
    let U = t.remotePointerUsernames.get(a) || "";
    if (!h && U) {
      e.font = "600 12px sans-serif";
      let y = (v ? s + 0 : s) + o / 2, w = (v ? c + 0 : c) + u + 2, x = 5, E = 3, S = e.measureText(U), _ = S.actualBoundingBoxDescent + S.actualBoundingBoxAscent, k = Math.max(_, 12), M = y - 1, A = w - 1, L = S.width + 2 + x * 2 + 2, R = k + 2 + E * 2 + 2;
      if (e.roundRect ? (e.beginPath(), e.roundRect(M, A, L, R, 8), e.fillStyle = f, e.fill(), e.strokeStyle = I1, e.stroke(), v && (e.beginPath(), e.roundRect(M - 2, A - 2, L + 4, R + 4, 8), e.strokeStyle = b, e.stroke())) : kR(e, M, A, L, R, 8, I1), e.fillStyle = iY, e.fillText(U, y + x + 1, w + E + S.actualBoundingBoxAscent + Math.floor((k - _) / 2) + 2), v) {
        e.fillStyle = b;
        let z = 8, F = 8, W = 5;
        e.fillRect(M + L + F, A + (R / 2 - z / 2), 2, z), e.fillRect(M + L + F + W, A + (R / 2 - z * 2 / 2), 2, z * 2), e.fillRect(M + L + F + W * 2, A + (R / 2 - z / 2), 2, z);
      }
    }
    e.restore(), e.closePath();
  }
}, DS = ({ color: e, onClick: t, name: n, src: r, className: i }) => {
  let a = Hhe(n), [l, s] = Q(!1), c = !l && r, d = c ? void 0 : { background: e };
  return m("div", { className: Me("Avatar", i), style: d, onClick: t, children: c ? m("img", { className: "Avatar-img", src: r, alt: a, referrerPolicy: "no-referrer", onError: () => s(!0) }) : a });
};
ve({ name: "goToCollaborator", label: "Go to a collaborator", viewMode: !0, trackEvent: { category: "collab" }, perform: (e, t, n) => {
  var r;
  return !n.socketId || ((r = t.userToFollow) == null ? void 0 : r.socketId) === n.socketId || n.isCurrentUser ? { appState: { ...t, userToFollow: null }, captureUpdate: ne.EVENTUALLY } : { appState: { ...t, userToFollow: { socketId: n.socketId, username: n.username || "" }, openMenu: t.openMenu === "canvas" ? null : t.openMenu }, captureUpdate: ne.EVENTUALLY };
}, PanelComponent: ({ updateData: e, data: t, appState: n }) => {
  let { socketId: r, collaborator: i, withName: a, isBeingFollowed: l } = t, s = P2(r, i), c = Me({ "is-followed": l, "is-current-user": i.isCurrentUser === !0, "is-speaking": i.isSpeaking, "is-in-call": i.isInCall, "is-muted": i.isMuted }), d = i.isInCall ? i.isSpeaking ? D("div", { className: "UserList__collaborator-status-icon-speaking-indicator", title: N("userList.hint.isSpeaking"), children: [m("div", {}), m("div", {}), m("div", {})] }) : i.isMuted ? m("div", { className: "UserList__collaborator-status-icon-microphone-muted", title: N("userList.hint.micMuted"), children: VZ }) : m("div", { title: N("userList.hint.inCall"), children: XZ }) : null;
  return a ? D("div", { className: `dropdown-menu-item dropdown-menu-item-base UserList__collaborator ${c}`, style: { "--avatar-size": "1.5rem" }, onClick: () => e(i), children: [m(DS, { color: s, onClick: () => {
  }, name: i.username || "", src: i.avatarUrl, className: c }), m("div", { className: "UserList__collaborator-name", children: i.username }), D("div", { className: "UserList__collaborator-status-icons", "aria-hidden": !0, children: [l && m("div", { className: "UserList__collaborator-status-icon-is-followed", title: N("userList.hint.followStatus"), children: M8 }), d] })] }) : D("div", { className: `UserList__collaborator UserList__collaborator--avatar-only ${c}`, children: [m(DS, { color: s, onClick: () => {
    e(i);
  }, name: i.username || "", src: i.avatarUrl, className: c }), d && m("div", { className: "UserList__collaborator-status-icon", children: d })] });
} });
var Xhe = ve({ name: "addToLibrary", trackEvent: { category: "element" }, perform: (e, t, n, r) => {
  let i = r.scene.getSelectedElements({ selectedElementIds: t.selectedElementIds, includeBoundTextElement: !0, includeElementsInFrames: !0 });
  for (let a of II) if (i.some((l) => l.type === a)) return { captureUpdate: ne.EVENTUALLY, appState: { ...t, errorMessage: N(`errors.libraryElementTypeError.${a}`) } };
  return r.library.getLatestLibrary().then((a) => r.library.setLibrary([{ id: ia(), status: "unpublished", elements: i.map(dd), created: Date.now() }, ...a])).then(() => ({ captureUpdate: ne.EVENTUALLY, appState: { ...t, toast: { message: N("toast.addedToLibrary") } } })).catch((a) => ({ captureUpdate: ne.EVENTUALLY, appState: { ...t, errorMessage: a.message } }));
}, label: "labels.addToLibrary" }), Vhe = (e, t, n, r) => {
  let i = u2(e, t), a = Na(e);
  return i.flatMap((l) => {
    let s = Ghe(l, a, n);
    return l.map((c) => {
      let d = le(c, { x: c.x + s.x, y: c.y + s.y });
      return ui(c, r.getNonDeletedElementsMap(), { simultaneouslyUpdated: l }), d;
    });
  });
}, Ghe = (e, t, { axis: n, position: r }) => {
  let i = Na(e), [a, l] = n === "x" ? ["minX", "maxX"] : ["minY", "maxY"], s = { x: 0, y: 0 };
  return r === "start" ? { ...s, [n]: t[a] - i[a] } : r === "end" ? { ...s, [n]: t[l] - i[l] } : { ...s, [n]: (t[a] + t[l]) / 2 - (i[a] + i[l]) / 2 };
}, Ni = (e, t) => {
  let n = t.scene.getSelectedElements(e);
  return n.length > 1 && !n.some((r) => Ve(r));
}, cu = (e, t, n, r) => {
  let i = n.scene.getSelectedElements(t), a = Ge(e), l = Vhe(i, a, r, n.scene), s = Ge(l);
  return C0(e.map((c) => s.get(c.id) || c), t, n);
};
ve({ name: "alignTop", label: "labels.alignTop", icon: ox, trackEvent: { category: "element" }, predicate: (e, t, n, r) => Ni(t, r), perform: (e, t, n, r) => ({ appState: t, elements: cu(e, t, r, { position: "start", axis: "y" }), captureUpdate: ne.IMMEDIATELY }), keyTest: (e) => e[H.CTRL_OR_CMD] && e.shiftKey && e.key === H.ARROW_UP, PanelComponent: ({ elements: e, appState: t, updateData: n, app: r }) => m(yt, { hidden: !Ni(t, r), type: "button", icon: ox, onClick: () => n(null), title: `${N("labels.alignTop")} — ${ae("CtrlOrCmd+Shift+Up")}`, "aria-label": N("labels.alignTop"), visible: Qn(Jt(e), t) }) });
ve({ name: "alignBottom", label: "labels.alignBottom", icon: cx, trackEvent: { category: "element" }, predicate: (e, t, n, r) => Ni(t, r), perform: (e, t, n, r) => ({ appState: t, elements: cu(e, t, r, { position: "end", axis: "y" }), captureUpdate: ne.IMMEDIATELY }), keyTest: (e) => e[H.CTRL_OR_CMD] && e.shiftKey && e.key === H.ARROW_DOWN, PanelComponent: ({ elements: e, appState: t, updateData: n, app: r }) => m(yt, { hidden: !Ni(t, r), type: "button", icon: cx, onClick: () => n(null), title: `${N("labels.alignBottom")} — ${ae("CtrlOrCmd+Shift+Down")}`, "aria-label": N("labels.alignBottom"), visible: Qn(Jt(e), t) }) });
ve({ name: "alignLeft", label: "labels.alignLeft", icon: dx, trackEvent: { category: "element" }, predicate: (e, t, n, r) => Ni(t, r), perform: (e, t, n, r) => ({ appState: t, elements: cu(e, t, r, { position: "start", axis: "x" }), captureUpdate: ne.IMMEDIATELY }), keyTest: (e) => e[H.CTRL_OR_CMD] && e.shiftKey && e.key === H.ARROW_LEFT, PanelComponent: ({ elements: e, appState: t, updateData: n, app: r }) => m(yt, { hidden: !Ni(t, r), type: "button", icon: dx, onClick: () => n(null), title: `${N("labels.alignLeft")} — ${ae("CtrlOrCmd+Shift+Left")}`, "aria-label": N("labels.alignLeft"), visible: Qn(Jt(e), t) }) });
ve({ name: "alignRight", label: "labels.alignRight", icon: ux, trackEvent: { category: "element" }, predicate: (e, t, n, r) => Ni(t, r), perform: (e, t, n, r) => ({ appState: t, elements: cu(e, t, r, { position: "end", axis: "x" }), captureUpdate: ne.IMMEDIATELY }), keyTest: (e) => e[H.CTRL_OR_CMD] && e.shiftKey && e.key === H.ARROW_RIGHT, PanelComponent: ({ elements: e, appState: t, updateData: n, app: r }) => m(yt, { hidden: !Ni(t, r), type: "button", icon: ux, onClick: () => n(null), title: `${N("labels.alignRight")} — ${ae("CtrlOrCmd+Shift+Right")}`, "aria-label": N("labels.alignRight"), visible: Qn(Jt(e), t) }) });
ve({ name: "alignVerticallyCentered", label: "labels.centerVertically", icon: hx, trackEvent: { category: "element" }, predicate: (e, t, n, r) => Ni(t, r), perform: (e, t, n, r) => ({ appState: t, elements: cu(e, t, r, { position: "center", axis: "y" }), captureUpdate: ne.IMMEDIATELY }), PanelComponent: ({ elements: e, appState: t, updateData: n, app: r }) => m(yt, { hidden: !Ni(t, r), type: "button", icon: hx, onClick: () => n(null), title: N("labels.centerVertically"), "aria-label": N("labels.centerVertically"), visible: Qn(Jt(e), t) }) });
ve({ name: "alignHorizontallyCentered", label: "labels.centerHorizontally", icon: fx, trackEvent: { category: "element" }, predicate: (e, t, n, r) => Ni(t, r), perform: (e, t, n, r) => ({ appState: t, elements: cu(e, t, r, { position: "center", axis: "x" }), captureUpdate: ne.IMMEDIATELY }), PanelComponent: ({ elements: e, appState: t, updateData: n, app: r }) => m(yt, { hidden: !Ni(t, r), type: "button", icon: fx, onClick: () => n(null), title: N("labels.centerHorizontally"), "aria-label": N("labels.centerHorizontally"), visible: Qn(Jt(e), t) }) });
var jhe = (e, t, n) => {
  let [r, i, a, l] = n.axis === "x" ? ["minX", "midX", "maxX", "width"] : ["minY", "midY", "maxY", "height"], s = Na(e), c = u2(e, t).map((h) => [h, Na(h)]).sort((h, f) => h[1][i] - f[1][i]), d = 0;
  for (let h of c) d += h[1][l];
  let o = (s[l] - d) / (c.length - 1);
  if (o < 0) {
    let h = c.findIndex((b) => b[1][r] === s[r]), f = c.findIndex((b) => b[1][a] === s[a]), p = (c[f][1][i] - c[h][1][i]) / (c.length - 1), g = c[h][1][i];
    return c.flatMap(([b, v], U) => {
      let y = { x: 0, y: 0 };
      return U !== h && U !== f && (g += p, y[n.axis] = g - v[i]), b.map((w) => at(w, { x: w.x + y.x, y: w.y + y.y }));
    });
  }
  let u = s[r];
  return c.flatMap(([h, f]) => {
    let p = { x: 0, y: 0 };
    return p[n.axis] = u - f[r], u += o, u += f[l], h.map((g) => at(g, { x: g.x + p.x, y: g.y + p.y }));
  });
}, CR = (e, t) => {
  let n = t.scene.getSelectedElements(e);
  return n.length > 1 && !n.some((r) => Ve(r));
}, MR = (e, t, n, r) => {
  let i = n.scene.getSelectedElements(t), a = jhe(i, n.scene.getNonDeletedElementsMap(), r), l = Ge(a);
  return C0(e.map((s) => l.get(s.id) || s), t, n);
};
ve({ name: "distributeHorizontally", label: "labels.distributeHorizontally", trackEvent: { category: "element" }, perform: (e, t, n, r) => ({ appState: t, elements: MR(e, t, r, { axis: "x" }), captureUpdate: ne.IMMEDIATELY }), keyTest: (e) => !e[H.CTRL_OR_CMD] && e.altKey && e.code === xt.H, PanelComponent: ({ elements: e, appState: t, updateData: n, app: r }) => m(yt, { hidden: !CR(t, r), type: "button", icon: Yq, onClick: () => n(null), title: `${N("labels.distributeHorizontally")} — ${ae("Alt+H")}`, "aria-label": N("labels.distributeHorizontally"), visible: Qn(Jt(e), t) }) });
ve({ name: "distributeVertically", label: "labels.distributeVertically", trackEvent: { category: "element" }, perform: (e, t, n, r) => ({ appState: t, elements: MR(e, t, r, { axis: "y" }), captureUpdate: ne.IMMEDIATELY }), keyTest: (e) => !e[H.CTRL_OR_CMD] && e.altKey && e.code === xt.V, PanelComponent: ({ elements: e, appState: t, updateData: n, app: r }) => m(yt, { hidden: !CR(t, r), type: "button", icon: qq, onClick: () => n(null), title: `${N("labels.distributeVertically")} — ${ae("Alt+V")}`, "aria-label": N("labels.distributeVertically"), visible: Qn(Jt(e), t) }) });
var Khe = ve({ name: "flipHorizontal", label: "labels.flipHorizontal", icon: YZ, trackEvent: { category: "element" }, perform: (e, t, n, r) => ({ elements: C0(TR(e, r.scene.getNonDeletedElementsMap(), t, "horizontal", r), t, r), appState: t, captureUpdate: ne.IMMEDIATELY }), keyTest: (e) => e.shiftKey && e.code === xt.H }), Yhe = ve({ name: "flipVertical", label: "labels.flipVertical", icon: KZ, trackEvent: { category: "element" }, perform: (e, t, n, r) => ({ elements: C0(TR(e, r.scene.getNonDeletedElementsMap(), t, "vertical", r), t, r), appState: t, captureUpdate: ne.IMMEDIATELY }), keyTest: (e) => e.shiftKey && e.code === xt.V && !e[H.CTRL_OR_CMD] }), TR = (e, t, n, r, i) => {
  let a = ct(Jt(e), n, { includeBoundTextElement: !0, includeElementsInFrames: !0 }), l = qhe(a, t, n, r, i), s = Ge(l);
  return e.map((c) => s.get(c.id) || c);
}, qhe = (e, t, n, r, i) => {
  if (e.every((f) => dt(f) && (f.startBinding || f.endBinding))) return e.map((f) => {
    let p = f;
    return at(p, { startArrowhead: p.endArrowhead, endArrowhead: p.startArrowhead });
  });
  let { midX: a, midY: l } = Na(e);
  oD(e, t, "nw", i.scene, new Map(Array.from(t.values()).map((f) => [f.id, dd(f)])), { flipByX: r === "horizontal", flipByY: r === "vertical", shouldResizeFromCenter: !0, shouldMaintainAspectRatio: !0 }), Nm(e.filter(et), t, i.scene.getNonDeletedElements(), i.scene, fc(n), [], n.zoom);
  let { elbowArrows: s, otherElements: c } = e.reduce((f, p) => Se(p) ? { ...f, elbowArrows: f.elbowArrows.concat(p) } : { ...f, otherElements: f.otherElements.concat(p) }, { elbowArrows: [], otherElements: [] }), { midX: d, midY: o } = Na(e), [u, h] = [a - d, l - o];
  return c.forEach((f) => le(f, { x: f.x + u, y: f.y + h })), s.forEach((f) => le(f, { x: f.x + u, y: f.y + h })), e;
}, Ip = ve({ name: "copy", label: "labels.copy", icon: l7, trackEvent: { category: "element" }, perform: async (e, t, n, r) => {
  let i = r.scene.getSelectedElements({ selectedElementIds: t.selectedElementIds, includeBoundTextElement: !0, includeElementsInFrames: !0 });
  try {
    await Qae(i, r.files, n);
  } catch (a) {
    return { captureUpdate: ne.EVENTUALLY, appState: { ...t, errorMessage: a.message } };
  }
  return { captureUpdate: ne.EVENTUALLY };
}, keyTest: void 0 }), LS = ve({ name: "paste", label: "labels.paste", trackEvent: { category: "element" }, perform: async (e, t, n, r) => {
  let i;
  try {
    i = await nle();
  } catch (a) {
    return a.name === "AbortError" || a.name === "NotAllowedError" ? !1 : (console.error(`actionPaste ${a.name}: ${a.message}`), Vh ? { captureUpdate: ne.EVENTUALLY, appState: { ...t, errorMessage: N("hints.firefox_clipboard_write") } } : { captureUpdate: ne.EVENTUALLY, appState: { ...t, errorMessage: N("errors.asyncPasteFailedOnRead") } });
  }
  try {
    r.pasteFromClipboard(Zae({ types: i }));
  } catch (a) {
    return console.error(a), { captureUpdate: ne.EVENTUALLY, appState: { ...t, errorMessage: N("errors.asyncPasteFailedOnParse") } };
  }
  return { captureUpdate: ne.EVENTUALLY };
}, keyTest: void 0 }), RS = ve({ name: "cut", label: "labels.cut", icon: LZ, trackEvent: { category: "element" }, perform: (e, t, n, r) => (Ip.perform(e, t, n, r), tR.perform(e, t, null, r)), keyTest: (e) => e[H.CTRL_OR_CMD] && e.key === H.X }), PS = ve({ name: "copyAsSvg", label: "labels.copyAsSvg", icon: qZ, trackEvent: { category: "element" }, perform: async (e, t, n, r) => {
  if (!r.canvas) return { captureUpdate: ne.EVENTUALLY };
  let { exportedElements: i, exportingFrame: a } = L2(e, t, !0);
  try {
    await R2("clipboard-svg", i, t, r.files, { ...t, exportingFrame: a, name: r.getName() });
    let l = r.scene.getSelectedElements({ selectedElementIds: t.selectedElementIds, includeBoundTextElement: !0, includeElementsInFrames: !0 });
    return { appState: { toast: { message: N("toast.copyToClipboardAsSvg", { exportSelection: l.length ? N("toast.selection") : N("toast.canvas"), exportColorScheme: t.exportWithDarkMode ? N("buttons.darkMode") : N("buttons.lightMode") }) } }, captureUpdate: ne.EVENTUALLY };
  } catch (l) {
    return console.error(l), { appState: { errorMessage: l.message }, captureUpdate: ne.EVENTUALLY };
  }
}, predicate: (e) => iU && e.length > 0, keywords: ["svg", "clipboard", "copy"] }), OS = ve({ name: "copyAsPng", label: "labels.copyAsPng", icon: ZZ, trackEvent: { category: "element" }, perform: async (e, t, n, r) => {
  if (!r.canvas) return { captureUpdate: ne.EVENTUALLY };
  let i = r.scene.getSelectedElements({ selectedElementIds: t.selectedElementIds, includeBoundTextElement: !0, includeElementsInFrames: !0 }), { exportedElements: a, exportingFrame: l } = L2(e, t, !0);
  try {
    return await R2("clipboard", a, t, r.files, { ...t, exportingFrame: l, name: r.getName() }), { appState: { ...t, toast: { message: N("toast.copyToClipboardAsPng", { exportSelection: i.length ? N("toast.selection") : N("toast.canvas"), exportColorScheme: t.exportWithDarkMode ? N("buttons.darkMode") : N("buttons.lightMode") }) } }, captureUpdate: ne.EVENTUALLY };
  } catch (s) {
    return console.error(s), { appState: { ...t, errorMessage: s.message }, captureUpdate: ne.EVENTUALLY };
  }
}, predicate: (e) => aU && e.length > 0, keyTest: (e) => e.code === xt.C && e.altKey && e.shiftKey, keywords: ["png", "clipboard", "copy"] }), $S = ve({ name: "copyText", label: "labels.copyText", trackEvent: { category: "element" }, perform: (e, t, n, r) => {
  let i = r.scene.getSelectedElements({ selectedElementIds: t.selectedElementIds, includeBoundTextElement: !0 });
  try {
    jf($ie(i));
  } catch {
    throw new Error(N("errors.copyToSystemClipboardFailed"));
  }
  return { captureUpdate: ne.EVENTUALLY };
}, predicate: (e, t, n, r) => iU && r.scene.getSelectedElements({ selectedElementIds: t.selectedElementIds, includeBoundTextElement: !0 }).some(we), keywords: ["text", "clipboard", "copy"] }), FS = ve({ name: "gridMode", icon: nJ, keywords: ["snap"], label: "labels.toggleGrid", viewMode: !0, trackEvent: { category: "canvas", predicate: (e) => e.gridModeEnabled }, perform(e, t) {
  return { appState: { ...t, gridModeEnabled: !this.checked(t), objectsSnapModeEnabled: !1 }, captureUpdate: ne.EVENTUALLY };
}, checked: (e) => e.gridModeEnabled, predicate: (e, t, n) => n.gridModeEnabled === void 0, keyTest: (e) => e[H.CTRL_OR_CMD] && e.code === xt.QUOTE }), e3 = ve({ name: "zenMode", label: "buttons.zenMode", icon: QZ, paletteName: "Toggle zen mode", viewMode: !0, trackEvent: { category: "canvas", predicate: (e) => !e.zenModeEnabled }, perform(e, t) {
  return { appState: { ...t, zenModeEnabled: !this.checked(t) }, captureUpdate: ne.EVENTUALLY };
}, checked: (e) => e.zenModeEnabled, predicate: (e, t, n) => typeof n.zenModeEnabled > "u", keyTest: (e) => !e[H.CTRL_OR_CMD] && e.altKey && e.code === xt.Z }), Zhe = ve({ name: "objectsSnapMode", label: "buttons.objectsSnapMode", icon: JZ, viewMode: !1, trackEvent: { category: "canvas", predicate: (e) => !e.objectsSnapModeEnabled }, perform(e, t) {
  return { appState: { ...t, objectsSnapModeEnabled: !this.checked(t), gridModeEnabled: !1 }, captureUpdate: ne.EVENTUALLY };
}, checked: (e) => e.objectsSnapModeEnabled, predicate: (e, t, n) => typeof n.objectsSnapModeEnabled > "u", keyTest: (e) => !e[H.CTRL_OR_CMD] && e.altKey && e.code === xt.S }), t3 = ve({ name: "stats", label: "stats.fullTitle", icon: jZ, paletteName: "Toggle stats", viewMode: !0, trackEvent: { category: "menu" }, keywords: ["edit", "attributes", "customize"], perform(e, t) {
  return { appState: { ...t, stats: { ...t.stats, open: !this.checked(t) } }, captureUpdate: ne.EVENTUALLY };
}, checked: (e) => e.stats.open, keyTest: (e) => !e[H.CTRL_OR_CMD] && e.altKey && e.code === xt.SLASH }), Jhe = ve({ name: "unbindText", label: "labels.unbindText", trackEvent: { category: "element" }, predicate: (e, t, n, r) => r.scene.getSelectedElements(t).some((i) => ra(i)), perform: (e, t, n, r) => {
  let i = r.scene.getSelectedElements(t), a = r.scene.getNonDeletedElementsMap();
  return i.forEach((l) => {
    var c;
    let s = lt(l, a);
    if (s) {
      let { width: d, height: o } = $r(s.originalText, Wt(s), s.lineHeight), u = Aie(l.id);
      cN(l.id);
      let { x: h, y: f } = f2(l, s, a);
      le(s, { containerId: null, width: d, height: o, text: s.originalText, x: h, y: f }), le(l, { boundElements: (c = l.boundElements) == null ? void 0 : c.filter((p) => p.id !== s.id), height: u || l.height });
    }
  }), { elements: e, appState: t, captureUpdate: ne.IMMEDIATELY };
} }), Qhe = ve({ name: "bindText", label: "labels.bindText", trackEvent: { category: "element" }, predicate: (e, t, n, r) => {
  let i = r.scene.getSelectedElements(t);
  if (i.length === 2) {
    let a = we(i[0]) || we(i[1]), l;
    if (yc(i[0]) ? l = i[0] : yc(i[1]) && (l = i[1]), a && l && lt(l, r.scene.getNonDeletedElementsMap()) === null) return !0;
  }
  return !1;
}, perform: (e, t, n, r) => {
  let i = r.scene.getSelectedElements(t), a, l;
  we(i[0]) && yc(i[1]) ? (a = i[0], l = i[1]) : (a = i[1], l = i[0]), le(a, { containerId: l.id, verticalAlign: Si.MIDDLE, textAlign: jh.CENTER, autoResize: !0 }), le(l, { boundElements: (l.boundElements || []).concat({ type: "text", id: a.id }) });
  let s = l.height;
  return jr(a, l, r.scene.getNonDeletedElementsMap()), Lm(l.id, s), { elements: efe(e, l, a), appState: { ...t, selectedElementIds: { [l.id]: !0 } }, captureUpdate: ne.IMMEDIATELY };
} }), efe = (e, t, n) => {
  let r = e.slice(), i = r.findIndex((l) => l.id === n.id);
  r.splice(i, 1);
  let a = r.findIndex((l) => l.id === t.id);
  return r.splice(a + 1, 0, n), Cl(r, Ge([t, n])), r;
}, tfe = (e, t, n) => {
  let r = e.slice(), i = r.findIndex((l) => l.id === t.id);
  r.splice(i, 1);
  let a = r.findIndex((l) => l.id === n.id);
  return r.splice(a, 0, t), Cl(r, Ge([t, n])), r;
}, nfe = ve({ name: "wrapTextInContainer", label: "labels.createContainerFromText", trackEvent: { category: "element" }, predicate: (e, t, n, r) => {
  let i = r.scene.getSelectedElements(t), a = i.every((l) => we(l));
  return i.length > 0 && a;
}, perform: (e, t, n, r) => {
  var s;
  let i = r.scene.getSelectedElements(t), a = e.slice(), l = {};
  for (let c of i) if (we(c)) {
    let d = kl({ type: "rectangle", backgroundColor: t.currentItemBackgroundColor, boundElements: [...c.boundElements || [], { id: c.id, type: "text" }], angle: c.angle, fillStyle: t.currentItemFillStyle, strokeColor: t.currentItemStrokeColor, roughness: t.currentItemRoughness, strokeWidth: t.currentItemStrokeWidth, strokeStyle: t.currentItemStrokeStyle, roundness: t.currentItemRoundness === "round" ? { type: ru("rectangle") ? Jn.ADAPTIVE_RADIUS : Jn.PROPORTIONAL_RADIUS } : null, opacity: 100, locked: !1, x: c.x - Zn, y: c.y - Zn, width: Zc(c.width, "rectangle"), height: Zc(c.height, "rectangle"), groupIds: c.groupIds, frameId: c.frameId });
    if ((s = c.boundElements) != null && s.length) {
      let o = c.boundElements.filter((u) => u.type === "arrow").map((u) => u.id);
      a.filter((u) => o.includes(u.id)).forEach((u) => {
        let h = u.startBinding, f = u.endBinding;
        (h == null ? void 0 : h.elementId) === c.id && (h = { ...h, elementId: d.id }), (f == null ? void 0 : f.elementId) === c.id && (f = { ...f, elementId: d.id }), (h || f) && le(u, { startBinding: h, endBinding: f }, !1);
      });
    }
    le(c, { containerId: d.id, verticalAlign: Si.MIDDLE, boundElements: null, textAlign: jh.CENTER, autoResize: !0 }, !1), jr(c, d, r.scene.getNonDeletedElementsMap()), a = tfe([...a, d], d, c), l[d.id] = !0;
  }
  return { elements: a, appState: { ...t, selectedElementIds: l }, captureUpdate: ne.IMMEDIATELY };
} }), KU = 380, rfe = 42, n3 = 5, IR = 85, ife = 500, r3 = !1, j1 = /* @__PURE__ */ new Map(), afe = ({ element: e, elementsMap: t, setAppState: n, onLinkOpen: r, setToast: i, updateEmbedValidationStatus: a }) => {
  let l = e1(), s = Qf(), c = ur(), d = e.link || "", [o, u] = Q(d), h = de(null), f = l.showHyperlinkPopup === "editor", p = he(() => {
    var w;
    if (!h.current) return;
    let y = _i(h.current.value) || null;
    if (!e.link && y && tn("hyperlink", "create"), ri(e)) {
      if (((w = l.activeEmbeddable) == null ? void 0 : w.element) === e && n({ activeEmbeddable: null }), !y) {
        le(e, { link: null }), a(e, !1);
        return;
      }
      if (!yp(y, s.validateEmbeddable)) y && i({ message: N("toast.unableToEmbed"), closable: !0 }), e.link && j1.set(e.id, e.link), le(e, { link: y }), a(e, !1);
      else {
        let { width: x, height: E } = e, S = Wd(y);
        (S == null ? void 0 : S.error) instanceof URIError && i({ message: N("toast.unrecognizedLinkFormat"), closable: !0 });
        let _ = S ? S.intrinsicSize.w / S.intrinsicSize.h : 1, k = j1.get(e.id) !== e.link;
        le(e, { ...k ? { width: (S == null ? void 0 : S.type) === "video" ? x > E ? x : E * _ : x, height: (S == null ? void 0 : S.type) === "video" && x > E ? x / _ : E } : {}, link: y }), a(e, !0), j1.has(e.id) && j1.delete(e.id);
      }
    } else le(e, { link: y });
  }, [e, i, s.validateEmbeddable, l.activeEmbeddable, n, a]);
  Bn(() => () => {
    p();
  }, [p]), Y(() => {
    f && (h != null && h.current) && !(c.viewport.isMobile || c.isTouchScreen) && h.current.select();
  }, [f, c.viewport.isMobile, c.isTouchScreen]), Y(() => {
    let y = null, w = (x) => {
      f || (y && clearTimeout(y), ofe(e, t, l, T(x.clientX, x.clientY)) && (y = window.setTimeout(() => {
        n({ showHyperlinkPopup: !1 });
      }, ife)));
    };
    return window.addEventListener("pointermove", w, !1), () => {
      window.removeEventListener("pointermove", w, !1), y && clearTimeout(y);
    };
  }, [l, e, f, n, t]);
  let g = he(() => {
    tn("hyperlink", "delete"), le(e, { link: null }), n({ showHyperlinkPopup: !1 });
  }, [n, e]), b = () => {
    tn("hyperlink", "edit", "popup-ui"), n({ showHyperlinkPopup: "editor" });
  }, { x: v, y: U } = AR(e, l, t);
  return l.contextMenu || l.selectedElementsAreBeingDragged || l.resizingElement || l.isRotating || l.openMenu || l.viewModeEnabled ? null : D("div", { className: "excalidraw-hyperlinkContainer", style: { top: `${U}px`, left: `${v}px`, width: KU, padding: n3 }, children: [f ? m("input", { className: Me("excalidraw-hyperlinkContainer-input"), placeholder: N("labels.link.hint"), ref: h, value: o, onChange: (y) => u(y.target.value), autoFocus: !0, onKeyDown: (y) => {
    y.stopPropagation(), y[H.CTRL_OR_CMD] && y.key === H.K && y.preventDefault(), (y.key === H.ENTER || y.key === H.ESCAPE) && (p(), n({ showHyperlinkPopup: "info" }));
  } }) : e.link ? m("a", { href: _i(e.link || ""), className: "excalidraw-hyperlinkContainer-link", target: uN(e.link) ? "_self" : "_blank", onClick: (y) => {
    if (e.link && r) {
      let w = HI("excalidraw-link", y.nativeEvent);
      r({ ...e, link: _i(e.link) }, w), w.defaultPrevented && y.preventDefault();
    }
  }, rel: "noopener noreferrer", children: e.link }) : m("div", { className: "excalidraw-hyperlinkContainer-link", children: N("labels.link.empty") }), D("div", { className: "excalidraw-hyperlinkContainer__buttons", children: [!f && m(yt, { type: "button", title: N("buttons.edit"), "aria-label": N("buttons.edit"), label: N("buttons.edit"), onClick: b, className: "excalidraw-hyperlinkContainer--edit", icon: qh }), m(yt, { type: "button", title: N("labels.linkToElement"), "aria-label": N("labels.linkToElement"), label: N("labels.linkToElement"), onClick: () => {
    n({ openDialog: { name: "elementLinkSelector", sourceElementId: e.id } });
  }, icon: gA }), d && !ri(e) && m(yt, { type: "button", title: N("buttons.remove"), "aria-label": N("buttons.remove"), label: N("buttons.remove"), onClick: g, className: "excalidraw-hyperlinkContainer--remove", icon: jc })] })] });
}, AR = (e, t, n) => {
  let [r, i] = tt(e, n), { x: a, y: l } = wa({ sceneX: r + e.width / 2, sceneY: i }, t), s = a - t.offsetLeft - KU / 2, c = l - t.offsetTop - IR;
  return { x: s, y: c };
}, zS = (e, t) => {
  var r;
  let n = ct(e, t);
  return ri(n[0]) ? "labels.link.editEmbed" : (r = n[0]) != null && r.link ? "labels.link.edit" : "labels.link.create";
}, _h = null, lfe = (e, t, n) => {
  _h && clearTimeout(_h), _h = window.setTimeout(() => sfe(e, t, n), uY);
}, sfe = (e, t, n) => {
  if (!e.link) return;
  let r = Eh();
  r.classList.add("excalidraw-tooltip--visible"), r.style.maxWidth = "20rem", r.textContent = vh(e.link) ? N("labels.link.goToElement") : e.link;
  let [i, a, l, s] = tt(e, n), [c, d, o, u] = X8([i, a, l, s], e.angle, t), h = wa({ sceneX: c, sceneY: d }, t);
  xR(r, { left: h.x, top: h.y, width: o, height: u }, "top"), tn("hyperlink", "tooltip", "link-icon"), r3 = !0;
}, BS = () => {
  _h && clearTimeout(_h), r3 && (r3 = !1, Eh().classList.remove("excalidraw-tooltip--visible"));
}, ofe = (e, t, n, [r, i]) => {
  let { x: a, y: l } = en({ clientX: r, clientY: i }, n), s = 15 / n.zoom.value;
  if (A8(a, l, e, t)) return !1;
  let [c, d, o] = tt(e, t);
  if (a >= c && a <= o && l >= d - IR && l <= d) return !1;
  let { x: u, y: h } = AR(e, n, t);
  return !(r >= u - s && r <= u + KU + n3 * 2 + s && i >= h - s && i <= h + s + n3 * 2 + rfe);
}, NR = ve({ name: "hyperlink", label: (e, t) => zS(e, t), icon: c7, perform: (e, t) => t.showHyperlinkPopup === "editor" ? !1 : { elements: e, appState: { ...t, showHyperlinkPopup: "editor", openMenu: null }, captureUpdate: ne.IMMEDIATELY }, trackEvent: { category: "hyperlink", action: "click" }, keyTest: (e) => e[H.CTRL_OR_CMD] && e.key === H.K, predicate: (e, t) => ct(e, t).length === 1, PanelComponent: ({ elements: e, appState: t, updateData: n }) => {
  let r = ct(e, t);
  return m(yt, { type: "button", icon: c7, "aria-label": N(zS(e, t)), title: `${ri(e[0]) ? N("labels.link.labelEmbed") : N("labels.link.label")} - ${ae("CtrlOrCmd+K")}`, onClick: () => n(null), selected: r.length === 1 && !!r[0].link });
} }), S5 = (e) => e.every((t) => !t.locked), cfe = ve({ name: "toggleElementLock", label: (e, t, n) => {
  let r = n.scene.getSelectedElements({ selectedElementIds: t.selectedElementIds, includeBoundTextElement: !1 });
  return r.length === 1 && !Ve(r[0]) ? r[0].locked ? "labels.elementLock.unlock" : "labels.elementLock.lock" : S5(r) ? "labels.elementLock.lockAll" : "labels.elementLock.unlockAll";
}, icon: (e, t) => {
  let n = ct(t, e);
  return S5(n) ? S8 : e2;
}, trackEvent: { category: "element" }, predicate: (e, t, n, r) => {
  let i = r.scene.getSelectedElements(t);
  return i.length > 0 && !i.some((a) => a.locked && a.frameId);
}, perform: (e, t, n, r) => {
  let i = r.scene.getSelectedElements({ selectedElementIds: t.selectedElementIds, includeBoundTextElement: !0, includeElementsInFrames: !0 });
  if (!i.length) return !1;
  let a = S5(i), l = Ge(i);
  return { elements: e.map((s) => l.has(s.id) ? at(s, { locked: a }) : s), appState: { ...t, selectedLinearElement: a ? null : t.selectedLinearElement }, captureUpdate: ne.IMMEDIATELY };
}, keyTest: (e, t, n, r) => e.key.toLocaleLowerCase() === H.L && e[H.CTRL_OR_CMD] && e.shiftKey && r.scene.getSelectedElements({ selectedElementIds: t.selectedElementIds, includeBoundTextElement: !1 }).length > 0 }), dfe = ve({ name: "unlockAllElements", paletteName: "Unlock all elements", trackEvent: { category: "canvas" }, viewMode: !1, icon: e2, predicate: (e, t) => ct(e, t).length === 0 && e.some((n) => n.locked), perform: (e, t) => {
  let n = e.filter((r) => r.locked);
  return { elements: e.map((r) => r.locked ? at(r, { locked: !1 }) : r), appState: { ...t, selectedElementIds: Object.fromEntries(n.map((r) => [r.id, !0])) }, captureUpdate: ne.IMMEDIATELY };
}, label: "labels.elementLock.unlockAll" }), ufe = () => {
  let [e, t] = Q(null), n = he((r) => t(r), []);
  return [e, n];
}, hfe = (e) => {
  let { closeOnClickOutside: t = !0 } = e, n = uR({ className: "excalidraw-modal-container" }), r = de(document.body.classList.contains("excalidraw-animations-disabled"));
  if (!n) return null;
  let i = (a) => {
    a.key === H.ESCAPE && (a.nativeEvent.stopImmediatePropagation(), a.stopPropagation(), e.onCloseRequest());
  };
  return fi(D("div", { className: Me("Modal", e.className, { "animations-disabled": r.current }), role: "dialog", "aria-modal": "true", onKeyDown: i, "aria-labelledby": e.labelledBy, "data-prevent-outside-click": !0, children: [m("div", { className: "Modal__background", onClick: t ? e.onCloseRequest : void 0 }), m("div", { className: "Modal__content", style: { "--max-width": `${e.maxWidth}px` }, tabIndex: 0, children: e.children })] }), n);
}, DR = Sr(/* @__PURE__ */ new Map()), HS = async (e) => await KN({ elements: e, appState: { exportBackground: !1, viewBackgroundColor: ht.white }, files: null, renderEmbeddables: !1, skipInliningFonts: !0 }), ffe = (e, t, n) => {
  let [r, i] = Q();
  return Y(() => {
    if (t) if (e) {
      let a = n.get(e);
      a ? i(a) : (async () => {
        var s;
        let l = await HS(t);
        (s = l.querySelector(".style-fonts")) == null || s.remove(), l && (n.set(e, l), i(l));
      })();
    } else (async () => {
      let a = await HS(t);
      i(a);
    })();
  }, [e, t, n, i]), r;
}, LR = () => {
  let [e] = Dn(DR);
  return { clearLibraryCache: () => e.clear(), deleteItemsFromLibraryCache: (t) => {
    t.forEach((n) => e.delete(n));
  }, svgCache: e };
}, pfe = class {
  constructor() {
    $(this, "jobs", []), $(this, "running", !1);
  }
  tick() {
    if (this.running) return;
    let e = this.jobs.shift();
    e ? (this.running = !0, e.promise.resolve(U0(e.jobFactory, ...e.args).finally(() => {
      this.running = !1, this.tick();
    }))) : this.running = !1;
  }
  push(e, ...t) {
    let n = VY();
    return this.jobs.push({ jobFactory: e, promise: n, args: t }), this.tick(), n;
  }
}, mfe = new nl(), uf = Sr({ status: "loaded", isInitialized: !1, libraryItems: [] }), Mu = (e) => cs(e), gfe = (e, t) => !e.find((n) => n.elements.length !== t.elements.length ? !1 : n.elements.every((r, i) => r.id === t.elements[i].id && r.versionNonce === t.elements[i].versionNonce)), bfe = (e, t) => {
  let n = [];
  for (let r of t) gfe(e, r) && n.push(r);
  return [...n, ...e];
}, Ufe = (e, t) => {
  let n = Ge(t), r = { deletedItems: /* @__PURE__ */ new Map(), addedItems: /* @__PURE__ */ new Map() };
  for (let a of e) n.has(a.id) || r.deletedItems.set(a.id, a);
  let i = Ge(e);
  for (let a of t) i.has(a.id) || r.addedItems.set(a.id, a);
  return r;
}, vfe = class {
  constructor(e) {
    $(this, "currLibraryItems", []), $(this, "prevLibraryItems", Mu(this.currLibraryItems)), $(this, "app"), $(this, "updateQueue", []), $(this, "getLastUpdateTask", () => this.updateQueue[this.updateQueue.length - 1]), $(this, "notifyListeners", () => {
      var t, n;
      if (this.updateQueue.length > 0) _a.set(uf, (r) => ({ status: "loading", libraryItems: this.currLibraryItems, isInitialized: r.isInitialized }));
      else {
        _a.set(uf, { status: "loaded", libraryItems: this.currLibraryItems, isInitialized: !0 });
        try {
          let r = this.prevLibraryItems;
          this.prevLibraryItems = Mu(this.currLibraryItems);
          let i = Mu(this.currLibraryItems);
          (n = (t = this.app.props).onLibraryChange) == null || n.call(t, i), mfe.trigger(Ufe(r, i), i);
        } catch (r) {
          console.error(r);
        }
      }
    }), $(this, "destroy", () => {
      this.updateQueue = [], this.currLibraryItems = [], _a.set(DR, /* @__PURE__ */ new Map());
    }), $(this, "resetLibrary", () => this.setLibrary([])), $(this, "getLatestLibrary", () => new Promise(async (t) => {
      try {
        let n = await (this.getLastUpdateTask() || this.currLibraryItems);
        this.updateQueue.length > 0 ? t(this.getLatestLibrary()) : t(Mu(n));
      } catch {
        return t(this.currLibraryItems);
      }
    })), $(this, "updateLibrary", async ({ libraryItems: t, prompt: n = !1, merge: r = !1, openLibraryMenu: i = !1, defaultStatus: a = "unpublished" }) => (i && this.app.setState({ openSidebar: { name: Ia.name, tab: Um } }), this.setLibrary(() => new Promise(async (l, s) => {
      try {
        let c = await (typeof t == "function" && !(t instanceof Blob) ? t(this.currLibraryItems) : t), d;
        c instanceof Blob ? d = await Hle(c, a) : d = rU(c, a), !n || window.confirm(N("alerts.confirmAddLibrary", { numShapes: d.length })) ? (n && this.app.focusContainer(), l(r ? bfe(this.currLibraryItems, d) : d)) : s(new r2());
      } catch (c) {
        s(c);
      }
    })))), $(this, "setLibrary", (t) => {
      let n = new Promise(async (r, i) => {
        try {
          await this.getLastUpdateTask(), typeof t == "function" && (t = t(this.currLibraryItems)), this.currLibraryItems = Mu(await t), r(this.currLibraryItems);
        } catch (a) {
          i(a);
        }
      }).catch((r) => {
        if (r.name === "AbortError") return console.warn("Library update aborted by user"), this.currLibraryItems;
        throw r;
      }).finally(() => {
        this.updateQueue = this.updateQueue.filter((r) => r !== n), this.notifyListeners();
      });
      return this.updateQueue.push(n), this.notifyListeners(), n;
    }), this.app = e;
  }
}, yfe = vfe, RR = (e) => {
  let t = Math.ceil(Math.sqrt(e.length)), n = [], r = (h) => e.slice(h * t, h * t + t).reduce((f, p) => {
    let { height: g } = Na(p.elements);
    return Math.max(f, g);
  }, 0), i = (h) => {
    let f = 0, p = 0, g = 0;
    for (let b of e) {
      if (f % t === 0 && (p = 0), p === h) {
        let { width: v } = Na(b.elements);
        g = Math.max(g, v);
      }
      f++, p++;
    }
    return g;
  }, a = 0, l = 0, s = 0, c = 0, d = 0, o = 0, u = 0;
  for (let h of e) {
    d && d % t === 0 && (l += s + 50, a = 0, o = 0, u++), o === 0 && (s = r(u)), c = i(o);
    let { minX: f, minY: p, width: g, height: b } = Na(h.elements), v = (c - g) / 2, U = (s - b) / 2;
    n.push(...h.elements.map((y) => ({ ...y, x: y.x + a + v - f, y: y.y + l + U - p }))), a += c + 50, d++, o++;
  }
  return n;
}, K1 = class i3 {
  constructor(t) {
    $(this, "adapter"), this.adapter = t;
  }
  static async getLibraryItems(t, n, r = !0) {
    let i = () => new Promise(async (a, l) => {
      try {
        let s = await t.load({ source: n });
        a(rU((s == null ? void 0 : s.libraryItems) || [], "published"));
      } catch (s) {
        l(s);
      }
    });
    return r ? i3.queue.push(i) : i();
  }
  getLibraryItems(t) {
    return i3.getLibraryItems(this.adapter, t, !1);
  }
};
$(K1, "queue", new pfe()), $(K1, "run", async (e, t) => {
  let n = new K1(e);
  return K1.queue.push(() => t(n));
});
var wfe = dn(({ children: e, gap: t, align: n, justifyContent: r, className: i, style: a }, l) => m("div", { className: Me("Stack Stack_horizontal", i), style: { "--gap": t, alignItems: n, justifyContent: r, ...a }, ref: l, children: e })), xfe = dn(({ children: e, gap: t, align: n, justifyContent: r, className: i, style: a }, l) => m("div", { className: Me("Stack Stack_vertical", i), style: { "--gap": t, justifyItems: n, justifyContent: r, ...a }, ref: l, children: e })), Wi = { Row: wfe, Col: xfe }, Efe = ({ theme: e, id: t, libraryReturnUrl: n }) => {
  let r = n || window.location.origin + window.location.pathname;
  return m("a", { className: "library-menu-browse-button", href: `${st.VITE_APP_LIBRARY_URL}?target=${window.name || "_blank"}&referrer=${r}&useHash=true&token=${t}&theme=${e}&version=${qg.excalidrawLibrary}`, target: "_excalidraw_libraries", children: N("labels.libraries") });
}, Sfe = Efe, PR = ({ libraryReturnUrl: e, theme: t, id: n, style: r, children: i, className: a }) => D("div", { className: Me("library-menu-control-buttons", a), style: r, children: [m(Sfe, { id: n, libraryReturnUrl: e, theme: t }), i] }), _fe = /({{[\w-]+}})|(<[\w-]+>)|(<\/[\w-]+>)/g, kfe = /{{([\w-]+)}}/, Cfe = /<([\w-]+)>/, Mfe = /<\/([\w-]+)>/, Tfe = (e, t) => {
  let n = [{ name: "", children: [] }];
  return e.split(_fe).filter(Boolean).forEach((r) => {
    let i = r.match(Cfe), a = r.match(Mfe), l = r.match(kfe);
    if (i !== null) {
      let s = i[1];
      t.hasOwnProperty(s) ? n.push({ name: s, children: [] }) : console.warn(`Trans: missed to pass in prop ${s} for interpolating ${e}`);
    } else if (a !== null) if (a[1] === n[n.length - 1].name) {
      let s = n.pop(), c = pe.createElement(pe.Fragment, {}, ...s.children), d = t[s.name];
      typeof d == "function" && n[n.length - 1].children.push(d(c));
    } else console.warn(`Trans: unexpected end tag ${r} for interpolating ${e}`);
    else if (l !== null) {
      let s = l[1];
      t.hasOwnProperty(s) ? n[n.length - 1].children.push(t[s]) : console.warn(`Trans: key ${s} not in props for interpolating ${e}`);
    } else n[n.length - 1].children.push(r);
  }), n.length !== 1 && console.warn(`Trans: stack not empty for interpolating ${e}`), n[0].children;
}, Ife = ({ i18nKey: e, children: t, ...n }) => {
  let { t: r } = Fr();
  return pe.createElement(pe.Fragment, {}, ...Tfe(r(e), n));
}, bl = Ife, Afe = ({ label: e, onClick: t, className: n, children: r, actionType: i, type: a = "button", isLoading: l, ...s }) => {
  let c = i ? `Dialog__action-button--${i}` : "";
  return D("button", { className: Me("Dialog__action-button", c, n), type: a, "aria-label": e, onClick: t, ...s, children: [r && m("div", { style: l ? { visibility: "hidden" } : {}, children: r }), m("div", { style: l ? { visibility: "hidden" } : {}, children: e }), l && m("div", { style: { position: "absolute", inset: 0 }, children: m(Cs, {}) })] });
}, A0 = Afe, Nfe = (e) => {
  let { onConfirm: t, onCancel: n, children: r, confirmText: i = N("buttons.confirm"), cancelText: a = N("buttons.cancel"), className: l = "", ...s } = e, c = hr(), d = M2(YU), { container: o } = Ol();
  return D(Wa, { onCloseRequest: n, size: "small", ...s, className: `confirm-dialog ${l}`, children: [r, D("div", { className: "confirm-dialog-buttons", children: [m(A0, { label: a, onClick: () => {
    c({ openMenu: null }), d(!1), ga(() => {
      n();
    }), o == null || o.focus();
  } }), m(A0, { label: i, onClick: () => {
    c({ openMenu: null }), d(!1), ga(() => {
      t();
    }), o == null || o.focus();
  }, actionType: "danger" })] })] });
}, OR = Nfe, Sc = class {
  static has(e) {
    try {
      return !!window.localStorage.getItem(e);
    } catch (t) {
      return console.warn(`localStorage.getItem error: ${t.message}`), !1;
    }
  }
  static get(e) {
    try {
      let t = window.localStorage.getItem(e);
      return t ? JSON.parse(t) : null;
    } catch (t) {
      return console.warn(`localStorage.getItem error: ${t.message}`), null;
    }
  }
};
$(Sc, "set", (e, t) => {
  try {
    return window.localStorage.setItem(e, JSON.stringify(t)), !0;
  } catch (n) {
    return console.warn(`localStorage.setItem error: ${n.message}`), !1;
  }
}), $(Sc, "delete", (e) => {
  try {
    window.localStorage.removeItem(e);
  } catch (t) {
    console.warn(`localStorage.removeItem error: ${t.message}`);
  }
});
var Dfe = async (e) => {
  let t = Math.round(8), n = Math.max(Math.round(128 / 64), 2), r = BY(e, 6), i = document.createElement("canvas");
  i.width = r[0].length * 128 + (r[0].length + 1) * (t * 2) - t * 2, i.height = r.length * 128 + (r.length + 1) * (t * 2) - t * 2;
  let a = i.getContext("2d");
  a.fillStyle = wr.white, a.fillRect(0, 0, i.width, i.height);
  for (let [l, s] of e.entries()) {
    let c = await lU({ elements: s.elements, files: null, maxWidthOrHeight: 128 }), { width: d, height: o } = c, u = Math.floor(l / 6) * (128 + t * 2), h = l % 6 * (128 + t * 2);
    a.drawImage(c, h + (128 - d) / 2 + t, u + (128 - o) / 2 + t), a.lineWidth = n, a.strokeStyle = wr.gray[4], a.strokeRect(h + t / 2, u + t / 2, 128 + t, 128 + t);
  }
  return await I7(new File([await sf(i)], "preview", { type: $e.png }), { outputType: $e.jpg, maxWidthOrHeight: 5e3 });
}, Lfe = ({ libItem: e, appState: t, index: n, onChange: r, onRemove: i }) => {
  let a = de(null), l = de(null);
  return Y(() => {
    let s = a.current;
    s && (async () => {
      let c = await KN({ elements: e.elements, appState: { ...t, viewBackgroundColor: wr.white, exportBackground: !0 }, files: null, skipInliningFonts: !0 });
      s.innerHTML = c.outerHTML;
    })();
  }, [e.elements, t]), D("div", { className: "single-library-item", children: [e.status === "published" && m("span", { className: "single-library-item-status", children: N("labels.statusPublished") }), m("div", { ref: a, className: "single-library-item__svg" }), m(yt, { "aria-label": N("buttons.remove"), type: "button", icon: iu, className: "single-library-item--remove", onClick: i.bind(null, e.id), title: N("buttons.remove") }), D("div", { style: { display: "flex", margin: "0.8rem 0", width: "100%", fontSize: "14px", fontWeight: 500, flexDirection: "column" }, children: [D("label", { style: { display: "flex", justifyContent: "space-between", flexDirection: "column" }, children: [D("div", { style: { padding: "0.5em 0" }, children: [m("span", { style: { fontWeight: 500, color: wr.gray[6] }, children: N("publishDialog.itemName") }), m("span", { "aria-hidden": "true", className: "required", children: "*" })] }), m("input", { type: "text", ref: l, style: { width: "80%", padding: "0.2rem" }, defaultValue: e.name, placeholder: "Item name", onChange: (s) => {
    r(s.target.value, n);
  } })] }), m("span", { className: "error", children: e.error })] })] });
}, Rfe = ({ onClose: e, libraryItems: t, appState: n, onSuccess: r, onError: i, updateItemsInStorage: a, onRemove: l }) => {
  let [s, c] = Q({ authorName: "", githubHandle: "", name: "", description: "", twitterHandle: "", website: "" }), [d, o] = Q(!1);
  Y(() => {
    let y = Sc.get(fh.PUBLISH_LIBRARY);
    y && c(y);
  }, []);
  let [u, h] = Q(t.slice());
  Y(() => {
    h(t.slice());
  }, [t]);
  let f = (y) => {
    c({ ...s, [y.target.name]: y.target.value });
  }, p = async (y) => {
    y.preventDefault(), o(!0);
    let w = [], x = !1;
    if (u.forEach((A) => {
      let L = "";
      A.name || (L = N("publishDialog.errors.required"), x = !0), w.push({ ...A, error: L });
    }), x) {
      h(w), o(!1);
      return;
    }
    let E = await Dfe(u), S = { type: ji.excalidrawLibrary, version: qg.excalidrawLibrary, source: u8, libraryItems: u }, _ = JSON.stringify(S, null, 2), k = new Blob([_], { type: "application/json" }), M = new FormData();
    M.append("excalidrawLib", k), M.append("previewImage", E), M.append("previewImageType", E.type), M.append("title", s.name), M.append("authorName", s.authorName), M.append("githubHandle", s.githubHandle), M.append("name", s.name), M.append("description", s.description), M.append("twitterHandle", s.twitterHandle), M.append("website", s.website), fetch(`${st.VITE_APP_LIBRARY_BACKEND}/submit`, { method: "post", body: M }).then((A) => A.ok ? A.json().then(({ url: L }) => {
      Sc.delete(fh.PUBLISH_LIBRARY), r({ url: L, authorName: s.authorName, items: u });
    }) : A.json().catch(() => {
      throw new Error(A.statusText || "something went wrong");
    }).then((L) => {
      throw new Error(L.message || A.statusText || "something went wrong");
    }), (A) => {
      console.error(A), i(A), o(!1);
    }).catch((A) => {
      console.error(A), i(A), o(!1);
    });
  }, g = () => {
    let y = [];
    return u.forEach((w, x) => {
      y.push(m("div", { className: "single-library-item-wrapper", children: m(Lfe, { libItem: w, appState: n, index: x, onChange: (E, S) => {
        let _ = u.slice();
        _[S].name = E, h(_);
      }, onRemove: l }) }, x));
    }), m("div", { className: "selected-library-items", children: y });
  }, b = he(() => {
    a(u), Sc.set(fh.PUBLISH_LIBRARY, s), e();
  }, [u, e, a, s]), v = !!t.length, U = t.some((y) => y.status === "published");
  return m(Wa, { onCloseRequest: b, title: N("publishDialog.title"), className: "publish-library", children: v ? D("form", { onSubmit: p, children: [m("div", { className: "publish-library-note", children: m(bl, { i18nKey: "publishDialog.noteDescription", link: (y) => m("a", { href: "https://libraries.excalidraw.com", target: "_blank", rel: "noopener noreferrer", children: y }) }) }), m("span", { className: "publish-library-note", children: m(bl, { i18nKey: "publishDialog.noteGuidelines", link: (y) => m("a", { href: "https://github.com/excalidraw/excalidraw-libraries#guidelines", target: "_blank", rel: "noopener noreferrer", children: y }) }) }), m("div", { className: "publish-library-note", children: N("publishDialog.noteItems") }), U && m("span", { className: "publish-library-note publish-library-warning", children: N("publishDialog.republishWarning") }), g(), D("div", { className: "publish-library__fields", children: [D("label", { children: [D("div", { children: [m("span", { children: N("publishDialog.libraryName") }), m("span", { "aria-hidden": "true", className: "required", children: "*" })] }), m("input", { type: "text", name: "name", required: !0, value: s.name, onChange: f, placeholder: N("publishDialog.placeholder.libraryName") })] }), D("label", { style: { alignItems: "flex-start" }, children: [D("div", { children: [m("span", { children: N("publishDialog.libraryDesc") }), m("span", { "aria-hidden": "true", className: "required", children: "*" })] }), m("textarea", { name: "description", rows: 4, required: !0, value: s.description, onChange: f, placeholder: N("publishDialog.placeholder.libraryDesc") })] }), D("label", { children: [D("div", { children: [m("span", { children: N("publishDialog.authorName") }), m("span", { "aria-hidden": "true", className: "required", children: "*" })] }), m("input", { type: "text", name: "authorName", required: !0, value: s.authorName, onChange: f, placeholder: N("publishDialog.placeholder.authorName") })] }), D("label", { children: [m("span", { children: N("publishDialog.githubUsername") }), m("input", { type: "text", name: "githubHandle", value: s.githubHandle, onChange: f, placeholder: N("publishDialog.placeholder.githubHandle") })] }), D("label", { children: [m("span", { children: N("publishDialog.twitterUsername") }), m("input", { type: "text", name: "twitterHandle", value: s.twitterHandle, onChange: f, placeholder: N("publishDialog.placeholder.twitterHandle") })] }), D("label", { children: [m("span", { children: N("publishDialog.website") }), m("input", { type: "text", name: "website", pattern: "https?://.+", title: N("publishDialog.errors.website"), value: s.website, onChange: f, placeholder: N("publishDialog.placeholder.website") })] }), m("span", { className: "publish-library-note", children: m(bl, { i18nKey: "publishDialog.noteLicense", link: (y) => m("a", { href: "https://github.com/excalidraw/excalidraw-libraries/blob/main/LICENSE", target: "_blank", rel: "noopener noreferrer", children: y }) }) })] }), D("div", { className: "publish-library__buttons", children: [m(A0, { label: N("buttons.cancel"), onClick: b, "data-testid": "cancel-clear-canvas-button" }), m(A0, { type: "submit", label: N("buttons.submit"), actionType: "primary", isLoading: d })] })] }) : m("p", { style: { padding: "1em", textAlign: "center", fontWeight: 500 }, children: N("publishDialog.atleastOneLibItem") }) });
}, Pfe = Rfe, $R = ({ className: e = "", children: t, onToggle: n, title: r, ...i }) => {
  let a = ur(), l = Me(`dropdown-menu-button ${e}`, "zen-mode-transition", { "dropdown-menu-button--mobile": a.editor.isMobile }).trim();
  return m("button", { "data-prevent-outside-click": !0, className: l, onClick: n, type: "button", "data-testid": "dropdown-menu-button", title: r, ...i, children: t });
}, Ofe = $R;
$R.displayName = "DropdownMenuTrigger";
var FR = () => m("div", { style: { height: "1px", backgroundColor: "var(--default-border-color)", margin: ".5rem 0" } }), $fe = FR;
FR.displayName = "DropdownMenuSeparator";
var zR = ({ children: e, onClickOutside: t, className: n = "", onSelect: r, style: i }) => {
  let a = ur(), l = de(null), s = I2({ onClickOutside: t });
  BU(l, () => {
    var d;
    (d = s.onClickOutside) == null || d.call(s);
  }), Y(() => {
    let d = (u) => {
      var h;
      u.key === H.ESCAPE && (u.stopImmediatePropagation(), (h = s.onClickOutside) == null || h.call(s));
    }, o = { capture: !0 };
    return document.addEventListener("keydown", d, o), () => {
      document.removeEventListener("keydown", d, o);
    };
  }, [s]);
  let c = Me(`dropdown-menu ${n}`, { "dropdown-menu--mobile": a.editor.isMobile }).trim();
  return m(gR.Provider, { value: { onSelect: r }, children: m("div", { ref: l, className: c, style: i, "data-testid": "dropdown-menu", children: a.editor.isMobile ? m(Wi.Col, { className: "dropdown-menu-container", children: e }) : m(Da, { className: "dropdown-menu-container", padding: 2, style: { zIndex: 2 }, children: e }) }) });
};
zR.displayName = "DropdownMenuContent";
var Ffe = zR, BR = ({ icon: e, shortcut: t, href: n, children: r, onSelect: i, className: a = "", selected: l, rel: s = "noreferrer", ...c }) => {
  let d = UR(c.onClick, i);
  return m("a", { ...c, href: n, target: "_blank", rel: "noreferrer", className: bR(a, l), title: c.title ?? c["aria-label"], onClick: d, children: m(vR, { icon: e, shortcut: t, children: r }) });
}, Ap = BR;
BR.displayName = "DropdownMenuItemLink";
var zfe = ({ children: e, className: t = "", selected: n, ...r }) => m("div", { ...r, className: `dropdown-menu-item-base dropdown-menu-item-custom ${t} ${n ? "dropdown-menu-item--selected" : ""}`.trim(), children: e }), Bfe = zfe, Hfe = (e) => pe.Children.toArray(e).find((n) => pe.isValidElement(n) && typeof n.type != "string" && (n == null ? void 0 : n.type.displayName) && n.type.displayName === "DropdownMenuTrigger") || null, Wfe = (e) => pe.Children.toArray(e).find((n) => pe.isValidElement(n) && typeof n.type != "string" && (n == null ? void 0 : n.type.displayName) && n.type.displayName === "DropdownMenuContent") || null, Ns = ({ children: e, open: t }) => {
  let n = Hfe(e), r = Wfe(e);
  return D(ge, { children: [n, t && r] });
};
Ns.Trigger = Ofe;
Ns.Content = Ffe;
Ns.Item = la;
Ns.ItemLink = Ap;
Ns.ItemCustom = Bfe;
Ns.Group = J7;
Ns.Separator = $fe;
var hn = Ns;
Ns.displayName = "DropdownMenu";
var Xfe = (e, t) => e.filter((n) => t.includes(n.id)), Vfe = ({ setAppState: e, selectedItems: t, library: n, onRemoveFromLibrary: r, resetLibrary: i, onSelectItems: a, appState: l, className: s }) => {
  let [c] = Dn(uf), [d, o] = Dn(YU), u = () => {
    let M = t.length ? N("alerts.removeItemsFromsLibrary", { count: t.length }) : N("alerts.resetLibrary"), A = t.length ? N("confirmDialog.removeItemsFromLib") : N("confirmDialog.resetLibrary");
    return m(OR, { onConfirm: () => {
      t.length ? r() : i(), f(!1);
    }, onCancel: () => {
      f(!1);
    }, title: A, children: m("p", { children: M }) });
  }, [h, f] = Q(!1), p = !!t.length, g = p ? c.libraryItems.filter((M) => t.includes(M.id)) : c.libraryItems, b = N(p ? "buttons.remove" : "buttons.resetLibrary"), [v, U] = Q(!1), [y, w] = Q(null), x = he(() => D(Wa, { onCloseRequest: () => w(null), title: N("publishSuccessDialog.title"), className: "publish-library-success", size: "small", children: [m("p", { children: m(bl, { i18nKey: "publishSuccessDialog.content", authorName: y.authorName, link: (M) => m("a", { href: y == null ? void 0 : y.url, target: "_blank", rel: "noopener noreferrer", children: M }) }) }), m(yt, { type: "button", title: N("buttons.close"), "aria-label": N("buttons.close"), label: N("buttons.close"), onClick: () => w(null), "data-testid": "publish-library-success-close", className: "publish-library-success-close" })] }), [w, y]), E = (M, A) => {
    U(!1), w({ url: M.url, authorName: M.authorName });
    let L = A.slice();
    L.forEach((R) => {
      t.includes(R.id) && (R.status = "published");
    }), n.setLibrary(L);
  }, S = async () => {
    try {
      await n.updateLibrary({ libraryItems: H8({ description: "Excalidraw library files" }), merge: !0, openLibraryMenu: !0 });
    } catch (M) {
      if ((M == null ? void 0 : M.name) === "AbortError") {
        console.warn(M);
        return;
      }
      e({ errorMessage: N("errors.importLibraryError") });
    }
  }, _ = async () => {
    let M = p ? g : await n.getLatestLibrary();
    fae(M).catch(FI).catch((A) => {
      e({ errorMessage: A.message });
    });
  }, k = () => D(hn, { open: d, children: [m(hn.Trigger, { onToggle: () => o(!d), children: Eq }), D(hn.Content, { onClickOutside: () => o(!1), onSelect: () => o(!1), className: "library-menu", children: [!p && m(hn.Item, { onSelect: S, icon: k8, "data-testid": "lib-dropdown--load", children: N("buttons.load") }), !!g.length && m(hn.Item, { onSelect: _, icon: t2, "data-testid": "lib-dropdown--export", children: N("buttons.export") }), !!g.length && m(hn.Item, { onSelect: () => f(!0), icon: jc, children: b }), p && m(hn.Item, { icon: DZ, onSelect: () => U(!0), "data-testid": "lib-dropdown--remove", children: N("buttons.publishLibrary") })] })] });
  return D("div", { className: Me("library-menu-dropdown-container", s), children: [k(), t.length > 0 && m("div", { className: "library-actions-counter", children: t.length }), h && u(), v && m(Pfe, { onClose: () => U(!1), libraryItems: Xfe(c.libraryItems, t), appState: l, onSuccess: (M) => E(M, c.libraryItems), onError: (M) => window.alert(M), updateItemsInStorage: () => n.setLibrary(c.libraryItems), onRemove: (M) => a(t.filter((A) => A !== M)) }), y && x()] });
}, WS = ({ selectedItems: e, onSelectItems: t, className: n }) => {
  let { library: r } = Pl(), { clearLibraryCache: i, deleteItemsFromLibraryCache: a } = LR(), l = Zr(), s = hr(), [c] = Dn(uf), d = async (o) => {
    let u = o.filter((h) => !e.includes(h.id));
    r.setLibrary(u).catch(() => {
      s({ errorMessage: N("alerts.errorRemovingFromLibrary") });
    }), a(e), t([]);
  };
  return m(Vfe, { appState: l, setAppState: s, selectedItems: e, onSelectItems: t, library: r, onRemoveFromLibrary: () => d(c.libraryItems), resetLibrary: () => {
    r.resetLibrary(), i();
  }, className: n });
}, Gfe = D0(({ id: e, elements: t, isPending: n, onClick: r, selected: i, onToggle: a, onDrag: l, svgCache: s }) => {
  let c = de(null), d = ffe(e, t, s);
  Y(() => {
    let p = c.current;
    if (p) return d && (p.innerHTML = d.outerHTML), () => {
      p.innerHTML = "";
    };
  }, [d]);
  let [o, u] = Q(!1), h = ur().editor.isMobile, f = n && m("div", { className: "library-unit__adder", children: xq });
  return D("div", { className: Me("library-unit", { "library-unit__active": t, "library-unit--hover": t && o, "library-unit--selected": i, "library-unit--skeleton": !d }), onMouseEnter: () => u(!0), onMouseLeave: () => u(!1), children: [m("div", { className: Me("library-unit__dragger", { "library-unit__pulse": !!n }), ref: c, draggable: !!t, onClick: t || n ? (p) => {
    e && p.shiftKey ? a(e, p) : r(e);
  } : void 0, onDragStart: (p) => {
    if (!e) {
      p.preventDefault();
      return;
    }
    u(!1), l(e, p);
  } }), f, e && t && (o || h || i) && m(GU, { checked: i, onChange: (p, g) => a(e, g), className: "library-unit__checkbox" })] });
}), jfe = () => m("div", { className: "library-unit library-unit--skeleton" });
function Kfe() {
  return [!1, he((e) => e(), [])];
}
var Yfe = pe.useTransition || Kfe, XS = ({ children: e }) => m("div", { className: "library-menu-items-container__grid", children: e }), _5 = D0(({ items: e, onItemSelectToggle: t, onItemDrag: n, isItemSelected: r, onClick: i, svgCache: a, itemsRenderedPerBatch: l }) => {
  let [, s] = Yfe(), [c, d] = Q(0);
  return Y(() => {
    c < e.length && s(() => {
      d(c + l);
    });
  }, [c, e.length, s, l]), m(ge, { children: e.map((o, u) => u < c ? m(Gfe, { elements: o == null ? void 0 : o.elements, isPending: !(o != null && o.id) && !!(o != null && o.elements), onClick: i, svgCache: a, id: o == null ? void 0 : o.id, selected: r(o.id), onToggle: t, onDrag: n }, (o == null ? void 0 : o.id) ?? u) : m(jfe, {}, u)) });
}), qfe = Sr(0), Zfe = (e) => {
  let [t, n] = Dn(qfe);
  return Y(() => {
    let { current: r } = e;
    if (!r) return;
    let i = Of(() => {
      let { scrollTop: a } = r;
      n(a);
    }, 200);
    return r.addEventListener("scroll", i), () => {
      i.cancel(), r.removeEventListener("scroll", i);
    };
  }, [e, n]), t;
}, Jfe = 17, Qfe = 64;
function e1e({ isLoading: e, libraryItems: t, onAddToLibrary: n, onInsertLibraryItems: r, pendingElements: i, theme: a, id: l, libraryReturnUrl: s, onSelectItems: c, selectedItems: d }) {
  let o = de(null), u = Zfe(o);
  Y(() => {
    var M;
    u > 0 && ((M = o.current) == null || M.scrollTo(0, u));
  }, []);
  let { svgCache: h } = LR(), f = Ke(() => t.filter((M) => M.status !== "published"), [t]), p = Ke(() => t.filter((M) => M.status === "published"), [t]), g = !t.length && !i.length, b = !i.length && !f.length && !p.length, [v, U] = Q(null), y = he((M, A) => {
    let L = !d.includes(M), R = [...f, ...p];
    if (L) {
      if (A.shiftKey && v) {
        let z = R.findIndex((j) => j.id === v), F = R.findIndex((j) => j.id === M);
        if (z === -1 || F === -1) {
          c([...d, M]);
          return;
        }
        let W = Ge(d), B = R.reduce((j, V, q) => ((q >= z && q <= F || W.has(V.id)) && j.push(V.id), j), []);
        c(B);
      } else c([...d, M]);
      U(M);
    } else U(null), c(d.filter((z) => z !== M));
  }, [v, c, p, d, f]), w = he((M) => {
    let A;
    return d.includes(M) ? A = t.filter((L) => d.includes(L.id)) : A = t.filter((L) => L.id === M), A.map((L) => ({ ...L, elements: wN(L.elements, { randomizeSeed: !0 }) }));
  }, [t, d]), x = he((M, A) => {
    A.dataTransfer.setData($e.excalidrawlib, CN(w(M)));
  }, [w]), E = he((M) => M ? d.includes(M) : !1, [d]), S = he(() => {
    n(i);
  }, [i, n]), _ = he((M) => {
    M && r(w(M));
  }, [w, r]), k = h.size >= t.length ? Qfe : Jfe;
  return D("div", { className: "library-menu-items-container", style: i.length || f.length || p.length ? { justifyContent: "flex-start" } : { borderBottom: 0 }, children: [!b && m(WS, { selectedItems: d, onSelectItems: c, className: "library-menu-dropdown-container--in-heading" }), D(Wi.Col, { className: "library-menu-items-container__items", align: "start", gap: 1, style: { flex: p.length > 0 ? 1 : "0 1 auto", marginBottom: 0 }, ref: o, children: [D(ge, { children: [!b && m("div", { className: "library-menu-items-container__header", children: N("labels.personalLib") }), e && m("div", { style: { position: "absolute", top: "var(--container-padding-y)", right: "var(--container-padding-x)", transform: "translateY(50%)" }, children: m(Cs, {}) }), !i.length && !f.length ? D("div", { className: "library-menu-items__no-items", children: [m("div", { className: "library-menu-items__no-items__label", children: N("library.noItems") }), m("div", { className: "library-menu-items__no-items__hint", children: p.length > 0 ? N("library.hint_emptyPrivateLibrary") : N("library.hint_emptyLibrary") })] }) : D(XS, { children: [i.length > 0 && m(_5, { itemsRenderedPerBatch: k, items: [{ id: null, elements: i }], onItemSelectToggle: y, onItemDrag: x, onClick: S, isItemSelected: E, svgCache: h }), m(_5, { itemsRenderedPerBatch: k, items: f, onItemSelectToggle: y, onItemDrag: x, onClick: _, isItemSelected: E, svgCache: h })] })] }), D(ge, { children: [(p.length > 0 || i.length > 0 || f.length > 0) && m("div", { className: "library-menu-items-container__header library-menu-items-container__header--excal", children: N("labels.excalidrawLib") }), p.length > 0 ? m(XS, { children: m(_5, { itemsRenderedPerBatch: k, items: p, onItemSelectToggle: y, onItemDrag: x, onClick: _, isItemSelected: E, svgCache: h }) }) : f.length > 0 ? m("div", { style: { margin: "1rem 0", display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", width: "100%", fontSize: ".9rem" }, children: N("library.noItems") }) : null] }), g && m(PR, { style: { padding: "16px 0", width: "100%" }, id: l, libraryReturnUrl: s, theme: a, children: m(WS, { selectedItems: d, onSelectItems: c }) })] })] });
}
var YU = Sr(!1), VS = ({ children: e }) => m("div", { className: "layer-ui__library", children: e }), t1e = D0(({ onInsertLibraryItems: e, pendingElements: t, onAddToLibrary: n, setAppState: r, libraryReturnUrl: i, library: a, id: l, theme: s, selectedItems: c, onSelectItems: d }) => {
  let [o] = Dn(uf), u = he((p) => {
    (async (g, b) => {
      tn("element", "addToLibrary", "ui");
      for (let U of II) if (g.some((y) => y.type === U)) return r({ errorMessage: N(`errors.libraryElementTypeError.${U}`) });
      let v = [{ status: "unpublished", elements: g, id: ia(), created: Date.now() }, ...b];
      n(), a.setLibrary(v).catch(() => {
        r({ errorMessage: N("alerts.errorAddingToLibrary") });
      });
    })(p, o.libraryItems);
  }, [n, a, r, o.libraryItems]), h = Ke(() => o.libraryItems, [o]);
  if (o.status === "loading" && !o.isInitialized) return m(VS, { children: m("div", { className: "layer-ui__library-message", children: D("div", { children: [m(Cs, { size: "2em" }), m("span", { children: N("labels.libraryLoadingMessage") })] }) }) });
  let f = o.libraryItems.length > 0 || t.length > 0;
  return D(VS, { children: [m(e1e, { isLoading: o.status === "loading", libraryItems: h, onAddToLibrary: u, onInsertLibraryItems: e, pendingElements: t, id: l, libraryReturnUrl: i, theme: s, onSelectItems: d, selectedItems: c }), f && m(PR, { className: "library-menu-control-buttons--at-bottom", style: { padding: "16px 12px 0 12px" }, id: l, libraryReturnUrl: i, theme: s })] });
}), k5 = (e, t) => ({ elements: e, pending: ct(e, { selectedElementIds: t }, { includeBoundTextElement: !0, includeElementsInFrames: !0 }), selectedElementIds: t }), n1e = (e, t) => {
  let n = $2(), [r, i] = Q(() => k5(n, e.selectedElementIds)), a = de(/* @__PURE__ */ new Map());
  return Y(() => {
    for (let l of r.pending) a.current.set(l.id, l.version);
  }, [r.pending]), Y(() => {
    t.state.cursorButton === "up" && t.state.activeTool.type === "selection" && i((l) => {
      var c;
      if (!Tr(l.selectedElementIds, e.selectedElementIds)) return a.current.clear(), k5(n, e.selectedElementIds);
      let s = t.scene.getNonDeletedElementsMap();
      for (let d of Object.keys(e.selectedElementIds)) {
        let o = (c = s.get(d)) == null ? void 0 : c.version;
        if (o && o !== a.current.get(d)) return k5(n, e.selectedElementIds);
      }
      return l;
    });
  }, [t, t.state.cursorButton, t.state.activeTool.type, e.selectedElementIds, n]), r.pending;
}, r1e = D0(() => {
  let e = Pl(), { onInsertElements: t } = e, n = Qf(), r = Zr(), i = hr(), [a, l] = Q([]), s = Ke(() => e.library, [e.library]), c = n1e(r, e), d = he((u) => {
    t(RR(u));
  }, [t]), o = he(() => {
    i({ selectedElementIds: {}, selectedGroupIds: {}, activeEmbeddable: null });
  }, [i]);
  return m(t1e, { pendingElements: c, onInsertLibraryItems: d, onAddToLibrary: o, setAppState: i, libraryReturnUrl: n.libraryReturnUrl, library: s, id: e.id, theme: r.theme, selectedItems: a, onSelectItems: l });
});
function i1e(e) {
  if (e && typeof e == "number") return e;
  switch (e) {
    case "small":
      return 550;
    case "wide":
      return 1024;
    case "regular":
    default:
      return 800;
  }
}
var Wa = (e) => {
  let [t, n] = ufe(), [r] = Q(document.activeElement), { id: i } = Ol(), a = ur().viewport.isMobile;
  Y(() => {
    if (!t) return;
    let d = a7(t);
    setTimeout(() => {
      d.length > 0 && e.autofocus !== !1 && (d[1] || d[0]).focus();
    });
    let o = (u) => {
      if (u.key === H.TAB) {
        let h = a7(t), { activeElement: f } = document, p = h.findIndex((g) => g === f);
        p === 0 && u.shiftKey ? (h[h.length - 1].focus(), u.preventDefault()) : p === h.length - 1 && !u.shiftKey && (h[0].focus(), u.preventDefault());
      }
    };
    return t.addEventListener("keydown", o), () => t.removeEventListener("keydown", o);
  }, [t, e.autofocus]);
  let l = hr(), s = M2(YU), c = () => {
    l({ openMenu: null }), s(!1), r.focus(), e.onCloseRequest();
  };
  return m(hfe, { className: Me("Dialog", e.className, { "Dialog--fullscreen": a }), labelledBy: "dialog-title", maxWidth: i1e(e.size), onCloseRequest: c, closeOnClickOutside: e.closeOnClickOutside, children: D(Da, { ref: n, children: [e.title && m("h2", { id: `${i}-dialog-title`, className: "Dialog__title", children: m("span", { className: "Dialog__titleContent", children: e.title }) }), a && m("button", { className: "Dialog__close", onClick: c, title: N("buttons.close"), "aria-label": N("buttons.close"), type: "button", children: iu }), m("div", { className: "Dialog__content", children: e.children })] }) });
}, N0 = ({ type: e = "button", onSelect: t, selected: n, children: r, className: i = "", ...a }) => m("button", { onClick: Jg(a.onClick, (l) => {
  t();
}), type: e, className: Me("excalidraw-button", i, { selected: n }), ...a, children: r }), qU = dn(({ onChange: e, label: t, fullWidth: n, placeholder: r, readonly: i, selectOnRender: a, onKeyDown: l, isRedacted: s = !1, icon: c, className: d, ...o }, u) => {
  let h = de(null);
  y3(u, () => h.current), Bn(() => {
    var g, b;
    a && ((g = h.current) == null || g.focus(), (b = h.current) == null || b.select());
  }, [a]);
  let [f, p] = Q(!1);
  return D("div", { className: Me("ExcTextField", d, { "ExcTextField--fullWidth": n, "ExcTextField--hasIcon": !!c }), onClick: () => {
    var g;
    (g = h.current) == null || g.focus();
  }, children: [c, t && m("div", { className: "ExcTextField__label", children: t }), D("div", { className: Me("ExcTextField__input", { "ExcTextField__input--readonly": i }), children: [m("input", { className: Me({ "is-redacted": "value" in o && o.value && s && !f }), readOnly: i, value: "value" in o ? o.value : void 0, defaultValue: "defaultValue" in o ? o.defaultValue : void 0, placeholder: r, ref: h, onChange: (g) => e == null ? void 0 : e(g.target.value), onKeyDown: l }), s && m(N0, { onSelect: () => p(!f), style: { border: 0, userSelect: "none" }, children: f ? BZ : M8 })] })] });
}), a1e = { toggleTheme: [ae("Shift+Alt+D")], saveScene: [ae("CtrlOrCmd+S")], loadScene: [ae("CtrlOrCmd+O")], clearCanvas: [ae("CtrlOrCmd+Delete")], imageExport: [ae("CtrlOrCmd+Shift+E")], commandPalette: [ae("CtrlOrCmd+/"), ae("CtrlOrCmd+Shift+P")], cut: [ae("CtrlOrCmd+X")], copy: [ae("CtrlOrCmd+C")], paste: [ae("CtrlOrCmd+V")], copyStyles: [ae("CtrlOrCmd+Alt+C")], pasteStyles: [ae("CtrlOrCmd+Alt+V")], selectAll: [ae("CtrlOrCmd+A")], deleteSelectedElements: [ae("Delete")], duplicateSelection: [ae("CtrlOrCmd+D"), ae(`Alt+${N("helpDialog.drag")}`)], sendBackward: [ae("CtrlOrCmd+[")], bringForward: [ae("CtrlOrCmd+]")], sendToBack: [ae(xl ? "CtrlOrCmd+Alt+[" : "CtrlOrCmd+Shift+[")], bringToFront: [ae(xl ? "CtrlOrCmd+Alt+]" : "CtrlOrCmd+Shift+]")], copyAsPng: [ae("Shift+Alt+C")], group: [ae("CtrlOrCmd+G")], ungroup: [ae("CtrlOrCmd+Shift+G")], gridMode: [ae("CtrlOrCmd+'")], zenMode: [ae("Alt+Z")], objectsSnapMode: [ae("Alt+S")], stats: [ae("Alt+/")], addToLibrary: [], flipHorizontal: [ae("Shift+H")], flipVertical: [ae("Shift+V")], viewMode: [ae("Alt+R")], hyperlink: [ae("CtrlOrCmd+K")], toggleElementLock: [ae("CtrlOrCmd+Shift+L")], resetZoom: [ae("CtrlOrCmd+0")], zoomOut: [ae("CtrlOrCmd+-")], zoomIn: [ae("CtrlOrCmd++")], zoomToFitSelection: [ae("Shift+3")], zoomToFit: [ae("Shift+1")], zoomToFitSelectionInViewport: [ae("Shift+2")], toggleEraserTool: [ae("E")], toggleHandTool: [ae("H")], setFrameAsActiveTool: [ae("F")], saveFileToDisk: [ae("CtrlOrCmd+S")], saveToActiveFile: [ae("CtrlOrCmd+S")], toggleShortcuts: [ae("?")], searchMenu: [ae("CtrlOrCmd+F")], wrapSelectionInFrame: [] }, Pr = (e, t = 0) => {
  let n = a1e[e];
  return n && n.length > 0 ? n[t] || n[0] : "";
}, l1e = "\\u0300-\\u036f", s1e = "\\ufe20-\\ufe2f", o1e = "\\u20d0-\\u20ff", c1e = l1e + s1e + o1e, d1e = `[${c1e}]`, u1e = RegExp(d1e, "g"), h1e = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, f1e = { À: "A", Á: "A", Â: "A", Ã: "A", Ä: "A", Å: "A", à: "a", á: "a", â: "a", ã: "a", ä: "a", å: "a", Ç: "C", ç: "c", Ð: "D", ð: "d", È: "E", É: "E", Ê: "E", Ë: "E", è: "e", é: "e", ê: "e", ë: "e", Ì: "I", Í: "I", Î: "I", Ï: "I", ì: "i", í: "i", î: "i", ï: "i", Ñ: "N", ñ: "n", Ò: "O", Ó: "O", Ô: "O", Õ: "O", Ö: "O", Ø: "O", ò: "o", ó: "o", ô: "o", õ: "o", ö: "o", ø: "o", Ù: "U", Ú: "U", Û: "U", Ü: "U", ù: "u", ú: "u", û: "u", ü: "u", Ý: "Y", ý: "y", ÿ: "y", Æ: "E", æ: "e", Þ: "T", þ: "t", ß: "s", Ā: "A", Ă: "A", Ą: "A", ā: "a", ă: "a", ą: "a", Ć: "C", Ĉ: "C", Ċ: "C", Č: "C", ć: "c", ĉ: "c", ċ: "c", č: "c", Ď: "D", Đ: "D", ď: "d", đ: "d", Ē: "E", Ĕ: "E", Ė: "E", Ę: "E", Ě: "E", ē: "e", ĕ: "e", ė: "e", ę: "e", ě: "e", Ĝ: "G", Ğ: "G", Ġ: "G", Ģ: "G", ĝ: "g", ğ: "g", ġ: "g", ģ: "g", Ĥ: "H", Ħ: "H", ĥ: "h", ħ: "h", Ĩ: "I", Ī: "I", Ĭ: "I", Į: "I", İ: "I", ĩ: "i", ī: "i", ĭ: "i", į: "i", ı: "i", Ĵ: "J", ĵ: "j", Ķ: "K", ķ: "k", ĸ: "k", Ĺ: "L", Ļ: "L", Ľ: "L", Ŀ: "L", Ł: "L", ĺ: "l", ļ: "l", ľ: "l", ŀ: "l", ł: "l", Ń: "N", Ņ: "N", Ň: "N", Ŋ: "N", ń: "n", ņ: "n", ň: "n", ŋ: "n", Ō: "O", Ŏ: "O", Ő: "O", ō: "o", ŏ: "o", ő: "o", Ŕ: "R", Ŗ: "R", Ř: "R", ŕ: "r", ŗ: "r", ř: "r", Ś: "S", Ŝ: "S", Ş: "S", Š: "S", ś: "s", ŝ: "s", ş: "s", š: "s", Ţ: "T", Ť: "T", Ŧ: "T", ţ: "t", ť: "t", ŧ: "t", Ũ: "U", Ū: "U", Ŭ: "U", Ů: "U", Ű: "U", Ų: "U", ũ: "u", ū: "u", ŭ: "u", ů: "u", ű: "u", ų: "u", Ŵ: "W", ŵ: "w", Ŷ: "Y", ŷ: "y", Ÿ: "Y", Ź: "Z", Ż: "Z", Ž: "Z", ź: "z", ż: "z", ž: "z", Ĳ: "I", ĳ: "i", Œ: "E", œ: "e", ŉ: "n", ſ: "s" }, GS = (e) => e.replace(h1e, (t) => f1e[t] || t).replace(u1e, ""), HR = pe.createContext(null), Li = () => pe.useContext(HR), p1e = TD(), m1e = () => pe.useMemo(() => ({ MainMenuTunnel: Ka(), WelcomeScreenMenuHintTunnel: Ka(), WelcomeScreenToolbarHintTunnel: Ka(), WelcomeScreenHelpHintTunnel: Ka(), WelcomeScreenCenterTunnel: Ka(), FooterCenterTunnel: Ka(), DefaultSidebarTriggerTunnel: Ka(), DefaultSidebarTabTriggersTunnel: Ka(), OverwriteConfirmDialogTunnel: Ka(), TTDDialogTriggerTunnel: Ka(), tunnelsJotai: p1e }), []), WR = (e, t) => {
  var r;
  let n = ((r = t[0]) == null ? void 0 : r.type) || null;
  for (let i of t) if (i.type !== n) {
    n = null;
    break;
  }
  return m7(e.activeTool.type) && e.activeTool.type !== "image" && n !== "image" && n !== "frame" && n !== "magicframe" || t.some((i) => m7(i.type));
}, XR = (e, t) => w0(e.activeTool.type) || t.some((n) => w0(n.type)), VR = ({ appState: e, elementsMap: t, renderAction: n, app: r }) => {
  let i = nD(t, e), a = !1;
  i.length === 2 && (ra(i[0]) || ra(i[1])) && (a = !0);
  let l = !!(e.editingTextElement || e.newElement), s = ur(), c = document.documentElement.getAttribute("dir") === "rtl", d = w0(e.activeTool.type) && !Ea(e.currentItemBackgroundColor) || i.some((p) => w0(p.type) && !Ea(p.backgroundColor)), o = i.length === 1 || a, u = !e.editingLinearElement && i.length === 1 && et(i[0]) && !Se(i[0]), h = !e.croppingElementId && i.length === 1 && Mt(i[0]), f = !a && Ni(e, r);
  return D("div", { className: "panelColumn", children: [m("div", { children: WR(e, i) && n("changeStrokeColor") }), XR(e, i) && m("div", { children: n("changeBackgroundColor") }), d && n("changeFillStyle"), (xx(e.activeTool.type) || i.some((p) => xx(p.type))) && n("changeStrokeWidth"), (e.activeTool.type === "freedraw" || i.some((p) => p.type === "freedraw")) && n("changeStrokeShape"), (Ex(e.activeTool.type) || i.some((p) => Ex(p.type))) && D(ge, { children: [n("changeStrokeStyle"), n("changeSloppiness")] }), (g7(e.activeTool.type) || i.some((p) => g7(p.type))) && m(ge, { children: n("changeRoundness") }), (Sx(e.activeTool.type) || i.some((p) => Sx(p.type))) && m(ge, { children: n("changeArrowType") }), (e.activeTool.type === "text" || i.some(we)) && D(ge, { children: [n("changeFontFamily"), n("changeFontSize"), (e.activeTool.type === "text" || Rie(i, t)) && n("changeTextAlign")] }), Lie(i, t) && n("changeVerticalAlign"), (Im(e.activeTool.type) || i.some((p) => Im(p.type))) && m(ge, { children: n("changeArrowhead") }), n("changeOpacity"), D("fieldset", { children: [m("legend", { children: N("labels.layers") }), D("div", { className: "buttonList", children: [n("sendToBack"), n("sendBackward"), n("bringForward"), n("bringToFront")] })] }), f && !a && D("fieldset", { children: [m("legend", { children: N("labels.align") }), D("div", { className: "buttonList", children: [c ? D(ge, { children: [n("alignRight"), n("alignHorizontallyCentered"), n("alignLeft")] }) : D(ge, { children: [n("alignLeft"), n("alignHorizontallyCentered"), n("alignRight")] }), i.length > 2 && n("distributeHorizontally"), m("div", { style: { flexBasis: "100%", height: 0 } }), D("div", { style: { display: "flex", flexWrap: "wrap", gap: ".5rem", marginTop: "-0.5rem" }, children: [n("alignTop"), n("alignVerticallyCentered"), n("alignBottom"), i.length > 2 && n("distributeVertically")] })] })] }), !l && i.length > 0 && D("fieldset", { children: [m("legend", { children: N("labels.actions") }), D("div", { className: "buttonList", children: [!s.editor.isMobile && n("duplicateSelection"), !s.editor.isMobile && n("deleteSelectedElements"), n("group"), n("ungroup"), o && n("hyperlink"), h && n("cropEditor"), u && n("toggleLinearEditor")] })] })] });
}, GR = ({ activeTool: e, appState: t, app: n, UIOptions: r }) => {
  let [i, a] = Q(!1), l = e.type === "frame", s = e.type === "laser", c = e.type === "embeddable", { TTDDialogTriggerTunnel: d } = Li();
  return D(ge, { children: [N8.map(({ value: o, icon: u, key: h, numericKey: f, fillable: p }, g) => {
    var y;
    if (((y = r.tools) == null ? void 0 : y[o]) === !1) return null;
    let b = N(`toolBar.${o}`), v = h && gh(typeof h == "string" ? h : h[0]), U = v ? `${v} ${N("helpDialog.or")} ${f}` : `${f}`;
    return m(yt, { className: Me("Shape", { fillable: p }), type: "radio", icon: u, checked: e.type === o, name: "editor-current-shape", title: `${gh(b)} — ${U}`, keyBindingLabel: f || v, "aria-label": gh(b), "aria-keyshortcuts": U, "data-testid": `toolbar-${o}`, onPointerDown: ({ pointerType: w }) => {
      !t.penDetected && w === "pen" && n.togglePenMode(!0);
    }, onChange: ({ pointerType: w }) => {
      t.activeTool.type !== o && tn("toolbar", o, "ui"), o === "image" ? n.setActiveTool({ type: o, insertOnCanvasDirectly: w !== "mouse" }) : n.setActiveTool({ type: o });
    } }, o);
  }), m("div", { className: "App-toolbar__divider" }), D(hn, { open: i, children: [m(hn.Trigger, { className: Me("App-toolbar__extra-tools-trigger", { "App-toolbar__extra-tools-trigger--selected": l || c || s && !n.props.isCollaborating }), onToggle: () => a(!i), title: N("toolBar.extraTools"), children: FZ }), D(hn.Content, { onClickOutside: () => a(!1), onSelect: () => a(!1), className: "App-toolbar__extra-tools-dropdown", children: [m(hn.Item, { onSelect: () => n.setActiveTool({ type: "frame" }), icon: cA, shortcut: H.F.toLocaleUpperCase(), "data-testid": "toolbar-frame", selected: l, children: N("toolBar.frame") }), m(hn.Item, { onSelect: () => n.setActiveTool({ type: "embeddable" }), icon: $q, "data-testid": "toolbar-embeddable", selected: c, children: N("toolBar.embeddable") }), m(hn.Item, { onSelect: () => n.setActiveTool({ type: "laser" }), icon: uA, "data-testid": "toolbar-laser", selected: s, shortcut: H.K.toLocaleUpperCase(), children: N("toolBar.laser") }), m("div", { style: { margin: "6px 0", fontSize: 14, fontWeight: 600 }, children: "Generate" }), n.props.aiEnabled !== !1 && m(d.Out, {}), m(hn.Item, { onSelect: () => n.setOpenDialog({ name: "ttd", tab: "mermaid" }), icon: dA, "data-testid": "toolbar-embeddable", children: N("toolBar.mermaidToExcalidraw") }), n.props.aiEnabled !== !1 && n.plugins.diagramToCode && m(ge, { children: D(hn.Item, { onSelect: () => n.onMagicframeToolSelect(), icon: hA, "data-testid": "toolbar-magicframe", children: [N("toolBar.magicframe"), m(hn.Item.Badge, { children: "AI" })] }) })] })] })] });
}, g1e = ({ renderAction: e, zoom: t }) => m(Wi.Col, { gap: 1, className: f0.ZOOM_ACTIONS, children: D(Wi.Row, { align: "center", children: [e("zoomOut"), e("resetZoom"), e("zoomIn")] }) }), b1e = ({ renderAction: e, className: t }) => D("div", { className: `undo-redo-buttons ${t}`, children: [m("div", { className: "undo-button-container", children: m(ed, { label: N("buttons.undo"), children: e("undo") }) }), m("div", { className: "redo-button-container", children: D(ed, { label: N("buttons.redo"), children: [" ", e("redo")] }) })] }), U1e = ({ actionManager: e, showExitZenModeBtn: t }) => m("button", { type: "button", className: Me("disable-zen-mode", { "disable-zen-mode--visible": t }), onClick: () => e.executeAction(e3), children: N("buttons.exitZenMode") }), v1e = ({ renderAction: e, className: t }) => m("div", { className: `finalize-button ${t}`, children: e("finalize", { size: "small" }) }), jS = (e) => {
  let t = de({ userFn: e });
  return t.current.userFn = e, t.current.stableFn || (t.current.stableFn = (...n) => t.current.userFn(...n)), t.current.stableFn;
}, O2 = Sr(null), y1e = () => {
  let [e, t] = Dn(O2), n = mi();
  return e && e === "clearCanvas" ? m(OR, { onConfirm: () => {
    n.executeAction(Sh), t(null);
  }, onCancel: () => t(null), title: N("clearCanvasDialog.title"), children: D("p", { className: "clear-canvas__content", children: [" ", N("alerts.clearReset")] }) }) : null;
}, jR = {};
ET(jR, { toggleTheme: () => w1e });
var w1e = { ...Jm, category: "App", label: "Toggle theme", perform: ({ actionManager: e }) => {
  e.executeAction(Jm, "commandPalette");
} }, KR = ve({ name: "copyElementLink", label: "labels.copyElementLink", icon: C8, trackEvent: { category: "element" }, perform: async (e, t, n, r) => {
  let i = ct(e, t);
  try {
    if (window.location) {
      let a = RN(i, t);
      return a ? (await jf(r.props.generateLinkForSelection ? r.props.generateLinkForSelection(a.id, a.type) : LN(a.id, a.type)), { appState: { toast: { message: N("toast.elementLinkCopied"), closable: !0 } }, captureUpdate: ne.EVENTUALLY }) : { appState: t, elements: e, app: r, captureUpdate: ne.EVENTUALLY };
    }
  } catch (a) {
    console.error(a);
  }
  return { appState: t, elements: e, app: r, captureUpdate: ne.EVENTUALLY };
}, predicate: (e, t) => Fm(ct(e, t)) }), x1e = ve({ name: "linkToElement", label: "labels.linkToElement", icon: gA, perform: (e, t, n, r) => {
  let i = ct(e, t);
  return i.length !== 1 || !Fm(i) ? { elements: e, appState: t, app: r, captureUpdate: ne.EVENTUALLY } : { appState: { ...t, openDialog: { name: "elementLinkSelector", sourceElementId: ct(e, t)[0].id } }, captureUpdate: ne.IMMEDIATELY };
}, predicate: (e, t, n, r) => {
  var a;
  let i = ct(e, t);
  return ((a = t.openDialog) == null ? void 0 : a.name) !== "elementLinkSelector" && i.length === 1 && Fm(i);
}, trackEvent: !1 }), E1e = Sr(null), On = { app: "App", export: "Export", tools: "Tools", editor: "Editor", elements: "Elements", links: "Links" }, S1e = (e) => {
  switch (e) {
    case On.app:
      return 1;
    case On.export:
      return 2;
    case On.editor:
      return 3;
    case On.tools:
      return 4;
    case On.elements:
      return 5;
    case On.links:
      return 6;
    default:
      return 10;
  }
}, Np = ({ shortcut: e, className: t, children: n }) => {
  let r = e.replace("++", "+$").split("+");
  return D("div", { className: Me("shortcut", t), children: [r.map((i, a) => m("div", { className: "shortcut-wrapper", children: m("div", { className: "shortcut-key", children: i === "$" ? "+" : i }) }, i)), m("div", { className: "shortcut-desc", children: n })] });
}, YR = (e) => !e.altKey && e[H.CTRL_OR_CMD] && (e.shiftKey && e.key.toLowerCase() === H.P || e.key === H.SLASH);
Object.assign((e) => {
  var r;
  let t = Zr(), n = hr();
  return Y(() => {
    let i = (a) => {
      YR(a) && (a.preventDefault(), a.stopPropagation(), n((l) => {
        var c;
        let s = ((c = l.openDialog) == null ? void 0 : c.name) === "commandPalette" ? null : { name: "commandPalette" };
        return s && tn("command_palette", "open", "shortcut"), { openDialog: s };
      }));
    };
    return window.addEventListener("keydown", i, { capture: !0 }), () => window.removeEventListener("keydown", i, { capture: !0 });
  }, [n]), ((r = t.openDialog) == null ? void 0 : r.name) !== "commandPalette" ? null : m(_1e, { ...e });
}, { defaultItems: jR });
function _1e({ customCommandPaletteItems: e }) {
  let t = Pl(), n = Zr(), r = hr(), i = Qf(), a = mi(), [l, s] = Dn(E1e), [c, d] = Q(null), o = de(null), u = I2({ uiAppState: n, customCommandPaletteItems: e, appProps: i });
  Y(() => {
    let { uiAppState: E, customCommandPaletteItems: S, appProps: _ } = u, k = (R) => {
      let z = "";
      return R.label && (typeof R.label == "function" ? z = N(R.label(t.scene.getNonDeletedElements(), E, t)) : z = N(R.label)), z;
    }, M = (R) => typeof R.icon == "function" ? R.icon(E, t.scene.getNonDeletedElements()) : R.icon, A = [], L = (R, z, F) => {
      let W = { label: k(R), icon: M(R), category: z, shortcut: Pr(R.name), keywords: R.keywords, predicate: R.predicate, viewMode: R.viewMode, perform: () => {
        a.executeAction(R, "commandPalette");
      } };
      return F ? F(W, R) : W;
    };
    if (E && t.scene && a) {
      let R = [a.actions.group, a.actions.ungroup, a.actions.cut, a.actions.copy, a.actions.deleteSelectedElements, a.actions.wrapSelectionInFrame, a.actions.copyStyles, a.actions.pasteStyles, a.actions.bringToFront, a.actions.bringForward, a.actions.sendBackward, a.actions.sendToBack, a.actions.alignTop, a.actions.alignBottom, a.actions.alignLeft, a.actions.alignRight, a.actions.alignVerticallyCentered, a.actions.alignHorizontallyCentered, a.actions.duplicateSelection, a.actions.flipHorizontal, a.actions.flipVertical, a.actions.zoomToFitSelection, a.actions.zoomToFitSelectionInViewport, a.actions.increaseFontSize, a.actions.decreaseFontSize, a.actions.toggleLinearEditor, a.actions.cropEditor, NR, KR, x1e].map((V) => L(V, On.elements, (q, oe) => ({ ...q, predicate: oe.predicate ? oe.predicate : (Ue, fe, Pe, ze) => ct(Ue, fe).length > 0 }))), z = [a.actions.toggleHandTool, a.actions.setFrameAsActiveTool].map((V) => L(V, On.tools)), F = [a.actions.undo, a.actions.redo, a.actions.zoomIn, a.actions.zoomOut, a.actions.resetZoom, a.actions.zoomToFit, a.actions.zenMode, a.actions.viewMode, a.actions.gridMode, a.actions.objectsSnapMode, a.actions.toggleShortcuts, a.actions.selectAll, a.actions.toggleElementLock, a.actions.unlockAllElements, a.actions.stats].map((V) => L(V, On.editor)), W = [a.actions.saveToActiveFile, a.actions.saveFileToDisk, a.actions.copyAsPng, a.actions.copyAsSvg].map((V) => L(V, On.export));
      A = [...R, ...F, { label: k(Sh), icon: M(Sh), shortcut: Pr(Sh.name), category: On.editor, keywords: ["delete", "destroy"], viewMode: !1, perform: () => {
        _a.set(O2, "clearCanvas");
      } }, { label: N("buttons.exportImage"), category: On.export, icon: nA, shortcut: Pr("imageExport"), keywords: ["export", "image", "png", "jpeg", "svg", "clipboard", "picture"], perform: () => {
        r({ openDialog: { name: "imageExport" } });
      } }, ...W];
      let B = [{ label: N("toolBar.library"), category: On.app, icon: E8, viewMode: !1, perform: () => {
        E.openSidebar ? r({ openSidebar: null }) : r({ openSidebar: { name: Ia.name, tab: Ia.defaultTab } });
      } }, { label: N("search.title"), category: On.app, icon: Kc, viewMode: !0, perform: () => {
        a.executeAction(qR);
      } }, { label: N("labels.changeStroke"), keywords: ["color", "outline"], category: On.elements, icon: V6, viewMode: !1, predicate: (V, q) => {
        let oe = ct(V, q);
        return oe.length > 0 && WR(q, oe);
      }, perform: () => {
        r((V) => ({ openMenu: V.openMenu === "shape" ? null : "shape", openPopup: "elementStroke" }));
      } }, { label: N("labels.changeBackground"), keywords: ["color", "fill"], icon: V6, category: On.elements, viewMode: !1, predicate: (V, q) => {
        let oe = ct(V, q);
        return oe.length > 0 && XR(q, oe);
      }, perform: () => {
        r((V) => ({ openMenu: V.openMenu === "shape" ? null : "shape", openPopup: "elementBackground" }));
      } }, { label: N("labels.canvasBackground"), keywords: ["color"], icon: V6, category: On.editor, viewMode: !1, perform: () => {
        r((V) => ({ openMenu: V.openMenu === "canvas" ? null : "canvas", openPopup: "canvasBackground" }));
      } }, ...N8.reduce((V, q) => {
        var Be;
        let { value: oe, icon: Ue, key: fe, numericKey: Pe } = q;
        if (((Be = _.UIOptions.tools) == null ? void 0 : Be[oe]) === !1) return V;
        let ze = fe && gh(typeof fe == "string" ? fe : fe[0]) || Pe, Oe = { label: N(`toolBar.${oe}`), category: On.tools, shortcut: ze, icon: Ue, keywords: ["toolbar"], viewMode: !1, perform: ({ event: qe }) => {
          oe === "image" ? t.setActiveTool({ type: oe, insertOnCanvasDirectly: qe.type === "keydown" }) : t.setActiveTool({ type: oe });
        } };
        return V.push(Oe), V;
      }, []), ...z, { label: N("toolBar.lock"), category: On.tools, icon: E.activeTool.locked ? S8 : e2, shortcut: H.Q.toLocaleUpperCase(), viewMode: !1, perform: () => {
        t.toggleLock();
      } }, { label: `${N("labels.textToDiagram")}...`, category: On.tools, icon: HZ, viewMode: !1, predicate: _.aiEnabled, perform: () => {
        r((V) => ({ ...V, openDialog: { name: "ttd", tab: "text-to-diagram" } }));
      } }, { label: `${N("toolBar.mermaidToExcalidraw")}...`, category: On.tools, icon: dA, viewMode: !1, predicate: _.aiEnabled, perform: () => {
        r((V) => ({ ...V, openDialog: { name: "ttd", tab: "mermaid" } }));
      } }], j = [...A, ...B, ...S || []].map((V) => {
        var q;
        return { ...V, icon: V.icon || fA, order: V.order ?? S1e(V.category), haystack: `${GS(V.label.toLocaleLowerCase())} ${((q = V.keywords) == null ? void 0 : q.join(" ")) || ""}` };
      });
      d(j), s(j.find((V) => V.label === (l == null ? void 0 : l.label)) ?? null);
    }
  }, [u, t, a, d, l == null ? void 0 : l.label, s, r]);
  let [h, f] = Q(""), [p, g] = Q(null), [b, v] = Q({}), U = (E) => {
    r({ openDialog: null }, E), f("");
  }, y = (E, S) => {
    var _;
    ((_ = n.openDialog) == null ? void 0 : _.name) === "commandPalette" && (S.stopPropagation(), S.preventDefault(), document.body.classList.add("excalidraw-animations-disabled"), U(() => {
      E.perform({ actionManager: a, event: S }), s(E), requestAnimationFrame(() => {
        document.body.classList.remove("excalidraw-animations-disabled");
      });
    }));
  }, w = jS((E) => E.viewMode === !1 && n.viewModeEnabled ? !1 : typeof E.predicate == "function" ? E.predicate(t.scene.getNonDeletedElements(), n, i, t) : E.predicate === void 0 || E.predicate), x = jS((E) => {
    var M;
    let S = rc(E.target) || YR(E) || E.key === H.ESCAPE;
    if (S && E.key !== H.ARROW_UP && E.key !== H.ARROW_DOWN && E.key !== H.ENTER) return;
    let _ = Object.values(b).flat(), k = l && !h && w(l);
    if (E.key === H.ARROW_UP) {
      E.preventDefault();
      let A = _.findIndex((z) => z.label === (p == null ? void 0 : p.label));
      if (k) {
        if (A === 0) {
          g(l);
          return;
        }
        if (p === l) {
          let z = _[_.length - 1];
          z && g(z);
          return;
        }
      }
      let L;
      A === -1 ? L = _.length - 1 : L = A === 0 ? _.length - 1 : (A - 1) % _.length;
      let R = _[L];
      R && g(R);
      return;
    }
    if (E.key === H.ARROW_DOWN) {
      E.preventDefault();
      let A = _.findIndex((z) => z.label === (p == null ? void 0 : p.label));
      if (k) {
        if (!p || A === _.length - 1) {
          g(l);
          return;
        }
        if (p === l) {
          let z = _[0];
          z && g(z);
          return;
        }
      }
      let L = (A + 1) % _.length, R = _[L];
      R && g(R);
      return;
    }
    if (E.key === H.ENTER && p && setTimeout(() => {
      y(p, E);
    }), !S) {
      if (E.stopPropagation(), /^[a-zA-Z0-9]$/.test(E.key)) {
        (M = o == null ? void 0 : o.current) == null || M.focus();
        return;
      }
      E.preventDefault();
    }
  });
  return Y(() => (window.addEventListener("keydown", x, { capture: !0 }), () => window.removeEventListener("keydown", x, { capture: !0 })), [x]), Y(() => {
    if (!c) return;
    let E = (M) => {
      let A = {};
      for (let L of M) A[L.category] ? A[L.category].push(L) : A[L.category] = [L];
      return A;
    }, S = c.filter(w).sort((M, A) => M.order - A.order), _ = !h && l && w(l);
    if (!h) {
      v(E(_ ? S.filter((M) => M.label !== (l == null ? void 0 : l.label)) : S)), g(_ ? l : S[0] || null);
      return;
    }
    let k = GS(h.toLocaleLowerCase().replace(/[<>_| -]/g, ""));
    S = Lde.filter(k, S, { extract: (M) => M.haystack }).sort((M, A) => A.score - M.score).map((M) => M.original), v(E(S)), g(S[0] ?? null);
  }, [h, c, w, l]), D(Wa, { onCloseRequest: () => U(), closeOnClickOutside: !0, title: !1, size: 720, autofocus: !0, className: "command-palette-dialog", children: [m(qU, { value: h, placeholder: N("commandPalette.search.placeholder"), onChange: (E) => {
    f(E);
  }, selectOnRender: !0, ref: o }), !t.device.viewport.isMobile && D("div", { className: "shortcuts-wrapper", children: [m(Np, { shortcut: "↑↓", children: N("commandPalette.shortcuts.select") }), m(Np, { shortcut: "↵", children: N("commandPalette.shortcuts.confirm") }), m(Np, { shortcut: ae("Esc"), children: N("commandPalette.shortcuts.close") })] }), D("div", { className: "commands", children: [l && !h && D("div", { className: "command-category", children: [D("div", { className: "command-category-title", children: [N("commandPalette.recents"), m("div", { className: "icon", style: { marginLeft: "6px" }, children: WZ })] }), m(KS, { command: l, isSelected: l.label === (p == null ? void 0 : p.label), onClick: (E) => y(l, E), disabled: !w(l), onMouseMove: () => g(l), showShortcut: !t.device.viewport.isMobile, appState: n })] }), Object.keys(b).length > 0 ? Object.keys(b).map((E, S) => D("div", { className: "command-category", children: [m("div", { className: "command-category-title", children: E }), b[E].map((_) => m(KS, { command: _, isSelected: _.label === (p == null ? void 0 : p.label), onClick: (k) => y(_, k), onMouseMove: () => g(_), showShortcut: !t.device.viewport.isMobile, appState: n }, _.label))] }, E)) : c ? D("div", { className: "no-match", children: [m("div", { className: "icon", children: Kc }), " ", N("commandPalette.search.noMatch")] }) : null] })] });
}
var KS = ({ command: e, isSelected: t, disabled: n, onMouseMove: r, onClick: i, showShortcut: a, appState: l }) => {
  let s = () => {
  };
  return D("div", { className: Me("command-item", { "item-selected": t, "item-disabled": n }), ref: (c) => {
    var d;
    t && !n && ((d = c == null ? void 0 : c.scrollIntoView) == null || d.call(c, { block: "nearest" }));
  }, onClick: n ? s : i, onMouseMove: n ? s : r, title: n ? N("commandPalette.itemNotAvailable") : "", children: [D("div", { className: "name", children: [e.icon && m(N2, { icon: typeof e.icon == "function" ? e.icon(l) : e.icon }), e.label] }), a && e.shortcut && m(Np, { shortcut: e.shortcut })] });
}, k1e = ve({ name: "toggleLinearEditor", category: On.elements, label: (e, t, n) => {
  var r;
  return ((r = n.scene.getSelectedElements({ selectedElementIds: t.selectedElementIds })[0]) == null ? void 0 : r.type) === "arrow" ? "labels.lineEditor.editArrow" : "labels.lineEditor.edit";
}, keywords: ["line"], trackEvent: { category: "element" }, predicate: (e, t, n, r) => {
  let i = r.scene.getSelectedElements(t);
  return !!(!t.editingLinearElement && i.length === 1 && et(i[0]) && !Se(i[0]));
}, perform(e, t, n, r) {
  var l;
  let i = r.scene.getSelectedElements({ selectedElementIds: t.selectedElementIds, includeBoundTextElement: !0 })[0], a = ((l = t.editingLinearElement) == null ? void 0 : l.elementId) === i.id ? null : new Ee(i);
  return { appState: { ...t, editingLinearElement: a }, captureUpdate: ne.IMMEDIATELY };
}, PanelComponent: ({ appState: e, updateData: t, app: n }) => {
  let r = n.scene.getSelectedElements({ selectedElementIds: e.selectedElementIds })[0], i = N(r.type === "arrow" ? "labels.lineEditor.editArrow" : "labels.lineEditor.edit");
  return m(yt, { type: "button", icon: rJ, title: i, "aria-label": i, onClick: () => t(null) });
} }), qR = ve({ name: "searchMenu", icon: Kc, keywords: ["search", "find"], label: "search.title", viewMode: !0, trackEvent: { category: "search_menu", action: "toggle", predicate: (e) => e.gridModeEnabled }, perform(e, t, n, r) {
  var i, a;
  if (((i = t.openSidebar) == null ? void 0 : i.name) === Ia.name && t.openSidebar.tab === Zd) {
    let l = (a = r.excalidrawContainerValue.container) == null ? void 0 : a.querySelector(`.${f0.SEARCH_MENU_INPUT_WRAPPER} input`);
    return l != null && l.matches(":focus") ? { appState: { ...t, openSidebar: null }, captureUpdate: ne.EVENTUALLY } : (l == null || l.focus(), l == null || l.select(), !1);
  }
  return { appState: { ...t, openSidebar: { name: Ia.name, tab: Zd }, openDialog: null }, captureUpdate: ne.EVENTUALLY };
}, checked: (e) => e.gridModeEnabled, predicate: (e, t, n) => n.gridModeEnabled === void 0, keyTest: (e) => e[H.CTRL_OR_CMD] && e.key === H.F }), C1e = ve({ name: "cropEditor", label: "helpDialog.cropStart", icon: bx, viewMode: !0, trackEvent: { category: "menu" }, keywords: ["image", "crop"], perform(e, t, n, r) {
  let i = r.scene.getSelectedElements({ selectedElementIds: t.selectedElementIds, includeBoundTextElement: !0 })[0];
  return { appState: { ...t, isCropping: !1, croppingElementId: i.id }, captureUpdate: ne.IMMEDIATELY };
}, predicate: (e, t, n, r) => {
  let i = r.scene.getSelectedElements(t);
  return !!(!t.croppingElementId && i.length === 1 && Mt(i[0]));
}, PanelComponent: ({ appState: e, updateData: t, app: n }) => {
  let r = N("helpDialog.cropStart");
  return m(yt, { type: "button", icon: bx, title: r, "aria-label": r, onClick: () => t(null) });
} }), Qm = class {
  constructor(e = !0, t = !0) {
    this.isUndoStackEmpty = e, this.isRedoStackEmpty = t;
  }
}, YS = class eh {
  constructor() {
    $(this, "onHistoryChangedEmitter", new nl()), $(this, "undoStack", []), $(this, "redoStack", []);
  }
  get isUndoStackEmpty() {
    return this.undoStack.length === 0;
  }
  get isRedoStackEmpty() {
    return this.redoStack.length === 0;
  }
  clear() {
    this.undoStack.length = 0, this.redoStack.length = 0;
  }
  record(t, n) {
    let r = M1e.create(n, t);
    r.isEmpty() || (this.undoStack.push(r.inverse()), r.elementsChange.isEmpty() || (this.redoStack.length = 0), this.onHistoryChangedEmitter.trigger(new Qm(this.isUndoStackEmpty, this.isRedoStackEmpty)));
  }
  undo(t, n, r) {
    return this.perform(t, n, r, () => eh.pop(this.undoStack), (i) => eh.push(this.redoStack, i, t));
  }
  redo(t, n, r) {
    return this.perform(t, n, r, () => eh.pop(this.redoStack), (i) => eh.push(this.undoStack, i, t));
  }
  perform(t, n, r, i, a) {
    try {
      let l = i();
      if (l === null) return;
      let s = t, c = n, d = !1;
      for (; l; ) {
        try {
          [s, c, d] = l.applyTo(s, c, r);
        } finally {
          a(l);
        }
        if (d) break;
        l = i();
      }
      return [s, c];
    } finally {
      this.onHistoryChangedEmitter.trigger(new Qm(this.isUndoStackEmpty, this.isRedoStackEmpty));
    }
  }
  static pop(t) {
    if (!t.length) return null;
    let n = t.pop();
    return n !== void 0 ? n : null;
  }
  static push(t, n, r) {
    let i = n.inverse().applyLatestChanges(r);
    return t.push(i);
  }
}, M1e = class Dp {
  constructor(t, n) {
    this.appStateChange = t, this.elementsChange = n;
  }
  static create(t, n) {
    return new Dp(t, n);
  }
  inverse() {
    return new Dp(this.appStateChange.inverse(), this.elementsChange.inverse());
  }
  applyTo(t, n, r) {
    let [i, a] = this.elementsChange.applyTo(t, r.elements), [l, s] = this.appStateChange.applyTo(n, i);
    return [i, l, a || s];
  }
  applyLatestChanges(t) {
    let n = this.elementsChange.applyLatestChanges(t);
    return Dp.create(this.appStateChange, n);
  }
  isEmpty() {
    return this.appStateChange.isEmpty() && this.elementsChange.isEmpty();
  }
}, ZR = (e, t) => {
  let [n, r] = Q(t);
  return Y(() => {
    let i = e.on((a) => {
      r(a);
    });
    return () => {
      i();
    };
  }, [e]), n;
}, JR = (e, t, n) => {
  if (!t.multiElement && !t.resizingElement && !t.editingTextElement && !t.newElement && !t.selectedElementsAreBeingDragged && !t.selectionElement && !e.flowChartCreator.isCreatingChart) {
    let r = n();
    if (!r) return { captureUpdate: ne.EVENTUALLY };
    let [i, a] = r, l = Array.from(i.values());
    return { appState: a, elements: l, captureUpdate: ne.NEVER };
  }
  return { captureUpdate: ne.EVENTUALLY };
}, T1e = (e, t) => ({ name: "undo", label: "buttons.undo", icon: nx, trackEvent: { category: "history" }, viewMode: !1, perform: (n, r, i, a) => JR(a, r, () => e.undo(Ge(n), r, t.snapshot)), keyTest: (n) => n[H.CTRL_OR_CMD] && f7(n, H.Z) && !n.shiftKey, PanelComponent: ({ updateData: n, data: r }) => {
  let { isUndoStackEmpty: i } = ZR(e.onHistoryChangedEmitter, new Qm(e.isUndoStackEmpty, e.isRedoStackEmpty));
  return m(yt, { type: "button", icon: nx, "aria-label": N("buttons.undo"), onClick: n, size: (r == null ? void 0 : r.size) || "medium", disabled: i, "data-testid": "button-undo" });
} }), I1e = (e, t) => ({ name: "redo", label: "buttons.redo", icon: rx, trackEvent: { category: "history" }, viewMode: !1, perform: (n, r, i, a) => JR(a, r, () => e.redo(Ge(n), r, t.snapshot)), keyTest: (n) => n[H.CTRL_OR_CMD] && n.shiftKey && f7(n, H.Z) || _I && n.ctrlKey && !n.shiftKey && f7(n, H.Y), PanelComponent: ({ updateData: n, data: r }) => {
  let { isRedoStackEmpty: i } = ZR(e.onHistoryChangedEmitter, new Qm(e.isUndoStackEmpty, e.isRedoStackEmpty));
  return m(yt, { type: "button", icon: rx, "aria-label": N("buttons.redo"), onClick: n, size: (r == null ? void 0 : r.size) || "medium", disabled: i, "data-testid": "button-redo" });
} }), C5 = (e, t, n, r, i, a) => {
  if (e.trackEvent) try {
    typeof e.trackEvent == "object" && (!e.trackEvent.predicate || e.trackEvent.predicate(n, r, a)) && tn(e.trackEvent.category, e.trackEvent.action || e.name, `${t} (${i.device.editor.isMobile ? "mobile" : "desktop"})`);
  } catch (l) {
    console.error("error while logging action:", l);
  }
}, A1e = class {
  constructor(e, t, n, r) {
    $(this, "actions", {}), $(this, "updater"), $(this, "getAppState"), $(this, "getElementsIncludingDeleted"), $(this, "app"), $(this, "renderAction", (i, a) => {
      let l = this.app.props.UIOptions.canvasActions;
      if (this.actions[i] && "PanelComponent" in this.actions[i] && (!(i in l) || l[i])) {
        let s = this.actions[i], c = s.PanelComponent;
        c.displayName = "PanelComponent";
        let d = this.getElementsIncludingDeleted(), o = this.getAppState(), u = (h) => {
          C5(s, "ui", o, d, this.app, h), this.updater(s.perform(this.getElementsIncludingDeleted(), this.getAppState(), h, this.app));
        };
        return m(c, { elements: this.getElementsIncludingDeleted(), appState: this.getAppState(), updateData: u, appProps: this.app.props, app: this.app, data: a });
      }
      return null;
    }), $(this, "isActionEnabled", (i) => {
      let a = this.getElementsIncludingDeleted(), l = this.getAppState();
      return !i.predicate || i.predicate(a, l, this.app.props, this.app);
    }), this.updater = (i) => {
      if (Hf(i)) i.then((a) => e(a));
      else return e(i);
    }, this.getAppState = t, this.getElementsIncludingDeleted = n, this.app = r;
  }
  registerAction(e) {
    this.actions[e.name] = e;
  }
  registerAll(e) {
    e.forEach((t) => this.registerAction(t));
  }
  handleKeyDown(e) {
    let t = this.app.props.UIOptions.canvasActions, n = Object.values(this.actions).sort((s, c) => (c.keyPriority || 0) - (s.keyPriority || 0)).filter((s) => (s.name in t ? t[s.name] : !0) && s.keyTest && s.keyTest(e, this.getAppState(), this.getElementsIncludingDeleted(), this.app));
    if (n.length !== 1) return n.length > 1 && console.warn("Canceling as multiple actions match this shortcut", n), !1;
    let r = n[0];
    if (this.getAppState().viewModeEnabled && r.viewMode !== !0) return !1;
    let i = this.getElementsIncludingDeleted(), a = this.getAppState();
    return C5(r, "keyboard", a, i, this.app, null), e.preventDefault(), e.stopPropagation(), this.updater(n[0].perform(i, a, null, this.app)), !0;
  }
  executeAction(e, t = "api", n = null) {
    let r = this.getElementsIncludingDeleted(), i = this.getAppState();
    C5(e, t, i, r, this.app, n), this.updater(e.perform(r, i, n, this.app));
  }
}, qS = (e) => {
  let t = Array.from(e.values());
  return { x: JS(t, (n) => n.x) / t.length, y: JS(t, (n) => n.y) / t.length };
}, ZS = ([e, t]) => Math.hypot(e.x - t.x, e.y - t.y), JS = (e, t) => e.reduce((n, r) => n + t(r), 0), N1e = ({ children: e, left: t, top: n, onCloseRequest: r, fitInViewport: i = !1, offsetLeft: a = 0, offsetTop: l = 0, viewportWidth: s = window.innerWidth, viewportHeight: c = window.innerHeight }) => {
  let d = de(null);
  Y(() => {
    let u = d.current;
    if (!u) return;
    u.contains(document.activeElement) || u.focus();
    let h = (f) => {
      var p, g, b;
      if (f.key === H.TAB) {
        let v = a7(u), { activeElement: U } = document, y = v.findIndex((w) => w === U);
        U === u ? (f.shiftKey ? (p = v[v.length - 1]) == null || p.focus() : v[0].focus(), f.preventDefault(), f.stopImmediatePropagation()) : y === 0 && f.shiftKey ? ((g = v[v.length - 1]) == null || g.focus(), f.preventDefault(), f.stopImmediatePropagation()) : y === v.length - 1 && !f.shiftKey && ((b = v[0]) == null || b.focus(), f.preventDefault(), f.stopImmediatePropagation());
      }
    };
    return u.addEventListener("keydown", h), () => u.removeEventListener("keydown", h);
  }, []);
  let o = de(null);
  return Bn(() => {
    var u, h;
    if (i && d.current && n != null && t != null) {
      let f = d.current, { width: p, height: g } = f.getBoundingClientRect();
      if (((u = o.current) == null ? void 0 : u.top) === n && ((h = o.current) == null ? void 0 : h.left) === t) return;
      o.current = { top: n, left: t }, p >= s ? (f.style.width = `${s}px`, f.style.left = "0px", f.style.overflowX = "scroll") : t + p - a > s ? f.style.left = `${s - p - 10}px` : f.style.left = `${t}px`, g >= c ? (f.style.height = `${c - 20}px`, f.style.top = "10px", f.style.overflowY = "scroll") : n + g - l > c ? f.style.top = `${c - g}px` : f.style.top = `${n}px`;
    }
  }, [n, t, i, s, c, a, l]), Y(() => {
    if (r) {
      let u = (h) => {
        var f;
        (f = d.current) != null && f.contains(h.target) || w3(() => r(h));
      };
      return document.addEventListener("pointerdown", u, !1), () => document.removeEventListener("pointerdown", u, !1);
    }
  }, [r]), m("div", { className: "popover", ref: d, tabIndex: -1, children: e });
}, ir = "separator", D1e = pe.memo(({ actionManager: e, items: t, top: n, left: r, onClose: i }) => {
  let a = e1(), l = $2(), s = t.reduce((c, d) => (d && (d === ir || !d.predicate || d.predicate(l, a, e.app.props, e.app)) && c.push(d), c), []);
  return m(N1e, { onCloseRequest: () => {
    i();
  }, top: n, left: r, fitInViewport: !0, offsetLeft: a.offsetLeft, offsetTop: a.offsetTop, viewportWidth: a.width, viewportHeight: a.height, children: m("ul", { className: "context-menu", onContextMenu: (c) => c.preventDefault(), children: s.map((c, d) => {
    var h;
    if (c === ir) return !s[d - 1] || s[d - 1] === ir ? null : m("hr", { className: "context-menu-item-separator" }, d);
    let o = c.name, u = "";
    return c.label && (typeof c.label == "function" ? u = N(c.label(l, a, e.app)) : u = N(c.label)), m("li", { "data-testid": o, onClick: () => {
      i(() => {
        e.executeAction(c, "contextMenu");
      });
    }, children: D("button", { type: "button", className: Me("context-menu-item", { dangerous: o === "deleteSelectedElements", checkmark: (h = c.checked) == null ? void 0 : h.call(c, a) }), children: [m("div", { className: "context-menu-item__label", children: u }), m("kbd", { className: "context-menu-item__shortcut", children: o ? Pr(o) : "" })] }) }, d);
  }) }) });
}), L1e = ({ children: e, onClose: t }) => {
  let [n, r] = Q(!!e), { container: i } = Ol(), a = pe.useCallback(() => {
    r(!1), t && t(), i == null || i.focus();
  }, [t, i]);
  return m(ge, { children: n && m(Wa, { size: "small", onCloseRequest: a, title: N("errorDialog.title"), children: m("div", { style: { whiteSpace: "pre-wrap" }, children: e }) }) });
}, QR = function({ onChange: e, value: t, choices: n, name: r }) {
  return m("div", { className: "RadioGroup", children: n.map((i) => D("div", { className: Me("RadioGroup__choice", { active: i.value === t }), title: i.ariaLabel, children: [m("input", { name: r, type: "radio", checked: i.value === t, onChange: () => e(i.value), "aria-label": i.ariaLabel }), i.label] }, String(i.value))) });
}, Y1 = ({ title: e, name: t, checked: n, onChange: r, disabled: i = !1 }) => m("div", { className: Me("Switch", { toggled: n, disabled: i }), children: m("input", { name: t, id: t, title: e, type: "checkbox", checked: n, disabled: i, onChange: () => r(!n), onKeyDown: (a) => {
  a.key === " " && r(!n);
} }) }), kh = dn(({ children: e, icon: t, onClick: n, label: r, variant: i = "filled", color: a = "primary", size: l = "medium", fullWidth: s, className: c, status: d }, o) => {
  let [u, h] = Q(!1), f = async (g) => {
    let b = n == null ? void 0 : n(g);
    if (Hf(b)) {
      let v = window.setTimeout(() => {
        h(!0);
      }, 50);
      try {
        await b;
      } catch (U) {
        if (U instanceof r2) console.warn(U);
        else throw U;
      } finally {
        clearTimeout(v), h(!1);
      }
    }
  }, p = u ? "loading" : d;
  return a = p === "success" ? "success" : a, m("button", { className: Me("ExcButton", `ExcButton--color-${a}`, `ExcButton--variant-${i}`, `ExcButton--size-${l}`, `ExcButton--status-${p}`, { "ExcButton--fullWidth": s }, c), onClick: f, type: "button", "aria-label": r, ref: o, disabled: p === "loading" || p === "success", children: D("div", { className: "ExcButton__contents", children: [p === "loading" ? m(Cs, { className: "ExcButton__statusIcon" }) : p === "success" && m("div", { className: "ExcButton__statusIcon", children: PZ }), t && m("div", { className: "ExcButton__icon", "aria-hidden": !0, children: t }), i !== "icon" && (e ?? r)] }) });
}), R1e = 2e3, P1e = () => {
  let [e, t] = Q(null), n = de(0), r = () => {
    clearTimeout(n.current), t("success"), n.current = window.setTimeout(() => {
      t(null);
    }, R1e);
  }, i = he(() => {
    t(null);
  }, []);
  return { copyStatus: e, resetCopyStatus: i, onCopy: r };
}, O1e = "filter" in document.createElement("canvas").getContext("2d"), $1e = () => D("div", { children: [m("h3", { children: N("canvasError.cannotShowPreview") }), m("p", { children: m("span", { children: N("canvasError.canvasTooBig") }) }), D("em", { children: ["(", N("canvasError.canvasTooBigTip"), ")"] })] }), F1e = ({ appStateSnapshot: e, elementsSnapshot: t, files: n, actionManager: r, onExportImage: i, name: a }) => {
  let l = Qn(t, e), [s, c] = Q(a), [d, o] = Q(l), [u, h] = Q(e.exportBackground), [f, p] = Q(e.exportWithDarkMode), [g, b] = Q(e.exportEmbedScene), [v, U] = Q(e.exportScale), y = de(null), [w, x] = Q(null), { onCopy: E, copyStatus: S, resetCopyStatus: _ } = P1e();
  Y(() => {
    _();
  }, [s, u, f, v, g, _]);
  let { exportedElements: k, exportingFrame: M } = L2(t, e, d);
  return Y(() => {
    let A = y.current;
    if (!A) return;
    let L = A.offsetWidth, R = A.offsetHeight;
    L && lU({ elements: k, appState: { ...e, name: s, exportBackground: u, exportWithDarkMode: f, exportScale: v, exportEmbedScene: g }, files: n, exportPadding: tu, maxWidthOrHeight: Math.max(L, R), exportingFrame: M }).then((z) => (x(null), sf(z).then(() => {
      A.replaceChildren(z);
    }).catch((F) => {
      throw F.name === "CANVAS_POSSIBLY_TOO_BIG" ? new Error(N("canvasError.canvasTooBig")) : F;
    }))).catch((z) => {
      console.error(z), x(z);
    });
  }, [e, n, k, M, s, u, f, v, g]), D("div", { className: "ImageExportModal", children: [m("h3", { children: N("imageExportDialog.header") }), D("div", { className: "ImageExportModal__preview", children: [m("div", { className: "ImageExportModal__preview__canvas", ref: y, children: w && m($1e, {}) }), m("div", { className: "ImageExportModal__preview__filename", children: !od && m("input", { type: "text", className: "TextInput", value: s, style: { width: "30ch" }, onChange: (A) => {
    c(A.target.value), r.executeAction(Nhe, "ui", A.target.value);
  } }) })] }), D("div", { className: "ImageExportModal__settings", children: [m("h3", { children: N("imageExportDialog.header") }), l && m(Tu, { label: N("imageExportDialog.label.onlySelected"), name: "exportOnlySelected", children: m(Y1, { name: "exportOnlySelected", checked: d, onChange: (A) => {
    o(A);
  } }) }), m(Tu, { label: N("imageExportDialog.label.withBackground"), name: "exportBackgroundSwitch", children: m(Y1, { name: "exportBackgroundSwitch", checked: u, onChange: (A) => {
    h(A), r.executeAction(Lhe, "ui", A);
  } }) }), O1e && m(Tu, { label: N("imageExportDialog.label.darkMode"), name: "exportDarkModeSwitch", children: m(Y1, { name: "exportDarkModeSwitch", checked: f, onChange: (A) => {
    p(A), r.executeAction(Rhe, "ui", A);
  } }) }), m(Tu, { label: N("imageExportDialog.label.embedScene"), tooltip: N("imageExportDialog.tooltip.embedScene"), name: "exportEmbedSwitch", children: m(Y1, { name: "exportEmbedSwitch", checked: g, onChange: (A) => {
    b(A), r.executeAction(ER, "ui", A);
  } }) }), m(Tu, { label: N("imageExportDialog.label.scale"), name: "exportScale", children: m(QR, { name: "exportScale", value: v, onChange: (A) => {
    U(A), r.executeAction(Dhe, "ui", A);
  }, choices: m8.map((A) => ({ value: A, label: `${A}×` })) }) }), D("div", { className: "ImageExportModal__settings__buttons", children: [m(kh, { className: "ImageExportModal__settings__buttons__button", label: N("imageExportDialog.title.exportToPng"), onClick: () => i($6.png, k, { exportingFrame: M }), icon: gx, children: N("imageExportDialog.button.exportToPng") }), m(kh, { className: "ImageExportModal__settings__buttons__button", label: N("imageExportDialog.title.exportToSvg"), onClick: () => i($6.svg, k, { exportingFrame: M }), icon: gx, children: N("imageExportDialog.button.exportToSvg") }), (aU || Vh) && m(kh, { className: "ImageExportModal__settings__buttons__button", label: N("imageExportDialog.title.copyPngToClipboard"), status: S, onClick: async () => {
    await i($6.clipboard, k, { exportingFrame: M }), E();
  }, icon: C8, children: N("imageExportDialog.button.copyPngToClipboard") })] })] })] });
}, Tu = ({ label: e, children: t, tooltip: n, name: r }) => D("div", { className: "ImageExportModal__settings__setting", title: e, children: [D("label", { htmlFor: r, className: "ImageExportModal__settings__setting__label", children: [e, n && m(ed, { label: n, long: !0, children: RZ })] }), m("div", { className: "ImageExportModal__settings__setting__content", children: t })] }), z1e = ({ elements: e, appState: t, files: n, actionManager: r, onExportImage: i, onCloseRequest: a, name: l }) => {
  let [{ appStateSnapshot: s, elementsSnapshot: c }] = Q(() => ({ appStateSnapshot: cs(t), elementsSnapshot: cs(e) }));
  return m(Wa, { onCloseRequest: a, size: "wide", title: !1, children: m(F1e, { elementsSnapshot: c, appStateSnapshot: s, files: n, actionManager: r, onExportImage: i, name: l }) });
}, eP = ({ children: e, side: t, className: n }) => m("div", { className: Me("FixedSideContainer", `FixedSideContainer_side_${t}`, n), children: e }), n0 = 100, r0 = 100, QS = (e) => {
  switch (e) {
    case H.ARROW_UP:
      return "up";
    case H.ARROW_DOWN:
      return "down";
    case H.ARROW_RIGHT:
      return "right";
    case H.ARROW_LEFT:
      return "left";
    default:
      return "right";
  }
}, tP = (e, t, n, r) => {
  let i = [...n.values()].reduce((a, l) => {
    var c;
    let s;
    if (Se(l) && (s = l[e === "predecessors" ? "startBinding" : "endBinding"]) && ((c = l[e === "predecessors" ? "endBinding" : "startBinding"]) == null ? void 0 : c.elementId) === t.id) {
      let d = n.get(s.elementId);
      if (!d) return a;
      Or(Pa(d), "not an ExcalidrawBindableElement");
      let o = e === "predecessors" ? l.points[l.points.length - 1] : [0, 0], u = WA(t, sl(t), [o[0] + l.x, o[1] + l.y]);
      a.push({ relative: d, heading: u });
    }
    return a;
  }, []);
  switch (r) {
    case "up":
      return i.filter((a) => Nn(a.heading, li)).map((a) => a.relative);
    case "down":
      return i.filter((a) => Nn(a.heading, yr)).map((a) => a.relative);
    case "right":
      return i.filter((a) => Nn(a.heading, In)).map((a) => a.relative);
    case "left":
      return i.filter((a) => Nn(a.heading, ai)).map((a) => a.relative);
  }
}, a3 = (e, t, n) => tP("successors", e, t, n), l3 = (e, t, n) => tP("predecessors", e, t, n), B1e = (e, t, n) => {
  let r = r0 + e.width;
  if (n === "up" || n === "down") {
    let s = n0 + e.height, c = e.x, d = e.x + e.width;
    if (t.every((o) => o.x + o.width < c || o.x > d)) return { x: 0, y: s * (n === "up" ? -1 : 1) };
  } else if (n === "right" || n === "left") {
    let s = e.y, c = e.y + e.height;
    if (t.every((d) => d.y + d.height < s || d.y > c)) return { x: (r0 + e.width) * (n === "left" ? -1 : 1), y: 0 };
  }
  if (n === "up" || n === "down") {
    let s = n0 + e.height, c = (t.length, s), d = t.length === 0 ? 0 : (t.length + 1) % 2 === 0 ? (t.length + 1) / 2 * r : t.length / 2 * r * -1;
    return n === "up" ? { x: d, y: c * -1 } : { x: d, y: c };
  }
  let i = n0 + e.height, a = (t.length, r0 + e.width), l = t.length === 0 ? 0 : (t.length + 1) % 2 === 0 ? (t.length + 1) / 2 * i : t.length / 2 * i * -1;
  return n === "left" ? { x: a * -1, y: l } : { x: a, y: l };
}, H1e = (e, t, n, r) => {
  let i = a3(e, t, r), a = l3(e, t, r), l = B1e(e, [...i, ...a], r), s = kl({ type: e.type, x: e.x + l.x, y: e.y + l.y, width: e.width, height: e.height, roundness: e.roundness, roughness: e.roughness, backgroundColor: e.backgroundColor, strokeColor: e.strokeColor, strokeWidth: e.strokeWidth, opacity: e.opacity, fillStyle: e.fillStyle, strokeStyle: e.strokeStyle });
  Or(Qg(s), "not an ExcalidrawFlowchartNodeElement");
  let c = nP(e, s, t, r, n);
  return { nextNode: s, bindingArrow: c };
}, W1e = (e, t, n, r, i) => {
  let a = [];
  for (let l = 0; l < i; l++) {
    let s, c;
    if (r === "left" || r === "right") {
      let u = n0 * (i - 1) + i * e.height, h = e.y + e.height / 2 - u / 2, f = r0 + e.width;
      r === "left" && (f *= -1), s = e.x + f;
      let p = (n0 + e.height) * l;
      c = h + p;
    } else {
      let u = r0 * (i - 1) + i * e.width, h = e.x + e.width / 2 - u / 2, f = n0 + e.height;
      r === "up" && (f *= -1), c = e.y + f;
      let p = (r0 + e.width) * l;
      s = h + p;
    }
    let d = kl({ type: e.type, x: s, y: c, width: e.width, height: e.height, roundness: e.roundness, roughness: e.roughness, backgroundColor: e.backgroundColor, strokeColor: e.strokeColor, strokeWidth: e.strokeWidth, opacity: e.opacity, fillStyle: e.fillStyle, strokeStyle: e.strokeStyle });
    Or(Qg(d), "not an ExcalidrawFlowchartNodeElement");
    let o = nP(e, d, t, r, n);
    a.push(d), a.push(o);
  }
  return a;
}, nP = (e, t, n, r, i) => {
  let a, l;
  switch (r) {
    case "up": {
      a = e.x + e.width / 2, l = e.y - 6;
      break;
    }
    case "down": {
      a = e.x + e.width / 2, l = e.y + e.height + 6;
      break;
    }
    case "right": {
      a = e.x + e.width + 6, l = e.y + e.height / 2;
      break;
    }
    case "left": {
      a = e.x - 6, l = e.y + e.height / 2;
      break;
    }
  }
  let s, c;
  switch (r) {
    case "up": {
      s = t.x + t.width / 2 - a, c = t.y + t.height - l + 6;
      break;
    }
    case "down": {
      s = t.x + t.width / 2 - a, c = t.y - l - 6;
      break;
    }
    case "right": {
      s = t.x - a - 6, c = t.y - l + t.height / 2;
      break;
    }
    case "left": {
      s = t.x + t.width - a + 6, c = t.y - l + t.height / 2;
      break;
    }
  }
  let d = z8({ type: "arrow", x: a, y: l, startArrowhead: null, endArrowhead: i.currentItemEndArrowhead, strokeColor: e.strokeColor, strokeStyle: e.strokeStyle, strokeWidth: e.strokeWidth, opacity: e.opacity, roughness: e.roughness, points: [T(0, 0), T(s, c)], elbowed: !0 });
  Sl(d, e, "start", n), Sl(d, t, "end", n);
  let o = /* @__PURE__ */ new Map();
  o.set(e.id, e), o.set(t.id, t), o.set(d.id, d), Ee.movePoints(d, [{ index: 1, point: d.points[1] }]);
  let u = q8(d, ta(new Map([...n.entries(), [e.id, e], [t.id, t], [d.id, d]])), { points: d.points });
  return { ...d, ...u };
}, X1e = class {
  constructor() {
    $(this, "isExploring", !1), $(this, "sameLevelNodes", []), $(this, "sameLevelIndex", 0), $(this, "direction", null), $(this, "visitedNodes", /* @__PURE__ */ new Set());
  }
  clear() {
    this.isExploring = !1, this.sameLevelNodes = [], this.sameLevelIndex = 0, this.direction = null, this.visitedNodes.clear();
  }
  exploreByDirection(e, t, n) {
    if (!Pa(e)) return null;
    if (n !== this.direction && this.clear(), this.visitedNodes.has(e.id) || this.visitedNodes.add(e.id), this.isExploring && n === this.direction && this.sameLevelNodes.length > 1) return this.sameLevelIndex = (this.sameLevelIndex + 1) % this.sameLevelNodes.length, this.sameLevelNodes[this.sameLevelIndex].id;
    let r = [...a3(e, t, n), ...l3(e, t, n)];
    if (r.length > 0) return this.sameLevelIndex = 0, this.isExploring = !0, this.sameLevelNodes = r, this.direction = n, this.visitedNodes.add(r[0].id), r[0].id;
    if (n === this.direction || !this.isExploring) {
      this.isExploring || this.visitedNodes.add(e.id);
      let i = ["up", "right", "down", "left"].filter((a) => a !== n).map((a) => [...a3(e, t, a), ...l3(e, t, a)]).flat().filter((a) => !this.visitedNodes.has(a.id));
      for (let a of i) if (!this.visitedNodes.has(a.id)) return this.visitedNodes.add(a.id), this.isExploring = !0, this.direction = n, a.id;
    }
    return null;
  }
}, V1e = class {
  constructor() {
    $(this, "isCreatingChart", !1), $(this, "numberOfNodes", 0), $(this, "direction", "right"), $(this, "pendingNodes", null);
  }
  createNodes(e, t, n, r) {
    if (r !== this.direction) {
      let { nextNode: i, bindingArrow: a } = H1e(e, t, n, r);
      this.numberOfNodes = 1, this.isCreatingChart = !0, this.direction = r, this.pendingNodes = [i, a];
    } else {
      this.numberOfNodes += 1;
      let i = W1e(e, t, n, r, this.numberOfNodes);
      this.isCreatingChart = !0, this.direction = r, this.pendingNodes = i;
    }
    if (e.frameId) {
      let i = t.get(e.frameId);
      Or(i && VI(i), "not an ExcalidrawFrameElement"), i && this.pendingNodes.every((a) => Kf([a], i, t) || ko(a, i, t)) && (this.pendingNodes = this.pendingNodes.map((a) => le(a, { frameId: e.frameId }, !1)));
    }
  }
  clear() {
    this.isCreatingChart = !1, this.pendingNodes = null, this.direction = null, this.numberOfNodes = 0;
  }
}, G1e = (e, t) => {
  var n, r;
  for (let [, i] of t) if (i.type === "arrow" && (((n = i.startBinding) == null ? void 0 : n.elementId) === e.id || ((r = i.endBinding) == null ? void 0 : r.elementId) === e.id)) return !0;
  return !1;
}, j1e = ({ appState: e, isMobile: t, device: n, app: r }) => {
  var o, u;
  let { activeTool: i, isResizing: a, isRotating: l, lastPointerDownWith: s } = e, c = e.multiElement !== null;
  if (((o = e.openSidebar) == null ? void 0 : o.name) === Ia.name && e.openSidebar.tab === Zd && ((u = e.searchMatches) != null && u.length)) return N("hints.dismissSearch");
  if (e.openSidebar && !n.editor.canFitSidebar) return null;
  if (tl(e)) return N("hints.eraserRevert");
  if (i.type === "arrow" || i.type === "line") return c ? N("hints.linearElementMulti") : i.type === "arrow" ? N("hints.arrowTool", { arrowShortcut: ae("A") }) : N("hints.linearElement");
  if (i.type === "freedraw") return N("hints.freeDraw");
  if (i.type === "text") return N("hints.text");
  if (i.type === "embeddable") return N("hints.embeddable");
  if (e.activeTool.type === "image" && e.pendingImageElementId) return N("hints.placeImage");
  let d = r.scene.getSelectedElements(e);
  if (a && s === "mouse" && d.length === 1) {
    let h = d[0];
    return et(h) && h.points.length === 2 ? N("hints.lockAngle") : Mt(h) ? N("hints.resizeImage") : N("hints.resize");
  }
  if (l && s === "mouse") return N("hints.rotate");
  if (d.length === 1 && we(d[0])) return N("hints.text_selected");
  if (e.editingTextElement) return N("hints.text_editing");
  if (e.croppingElementId) return N("hints.leaveCropEditor");
  if (d.length === 1 && Mt(d[0])) return N("hints.enterCropEditor");
  if (i.type === "selection") {
    if (e.selectionElement && !d.length && !e.editingTextElement && !e.editingLinearElement) return N("hints.deepBoxSelect");
    if (nf(r) && e.selectedElementsAreBeingDragged) return N("hints.disableSnapping");
    if (!d.length && !t) return N("hints.canvasPanning");
    if (d.length === 1) {
      if (et(d[0])) return e.editingLinearElement ? e.editingLinearElement.selectedPointsIndices ? N("hints.lineEditor_pointSelected") : N("hints.lineEditor_nothingSelected") : N("hints.lineEditor_info");
      if (!e.newElement && !e.selectedElementsAreBeingDragged && yc(d[0])) return Qg(d[0]) ? G1e(d[0], r.scene.getNonDeletedElementsMap()) ? [N("hints.bindTextToElement"), N("hints.createFlowchart")] : [N("hints.bindTextToElement"), N("hints.createFlowchart")] : N("hints.bindTextToElement");
    }
  }
  return null;
}, rP = ({ appState: e, isMobile: t, device: n, app: r }) => {
  let i = j1e({ appState: e, isMobile: t, device: n, app: r });
  if (!i) return null;
  let a = Array.isArray(i) ? i.map((l) => ae(l).replace(/\. ?$/, "")).join(". ") : ae(i);
  return m("div", { className: "HintViewer", children: m("span", { children: a }) });
}, K1e = "medium", e_ = { CHECKED: S8, UNCHECKED: e2 }, iP = (e) => D("label", { className: Me("ToolIcon ToolIcon__lock", `ToolIcon_size_${K1e}`, { "is-mobile": e.isMobile }), title: `${e.title} — Q`, children: [m("input", { className: "ToolIcon_type_checkbox", type: "checkbox", name: e.name, onChange: e.onChange, checked: e.checked, "aria-label": e.title, "data-testid": "toolbar-lock" }), m("div", { className: "ToolIcon__icon", children: e.checked ? e_.CHECKED : e_.UNCHECKED })] }), hf = ({ heading: e, children: t, ...n }) => {
  let { id: r } = Ol(), i = m("h2", { className: "visually-hidden", id: `${r}-${e}-title`, children: N(`headings.${e}`) });
  return m("section", { ...n, "aria-labelledby": `${r}-${e}-title`, children: typeof t == "function" ? t(i) : D(ge, { children: [i, t] }) });
}, rl = 4, ao = 6, Y1e = "rgba(0,0,0,0.3)", q1e = (e, t, n, r) => {
  if (!e.length) return { horizontal: null, vertical: null };
  let [i, a, l, s] = Lt(e), c = t / r.zoom.value, d = n / r.zoom.value, o = t - c, u = n - d, h = { top: parseInt(D1("sat")) || 0, bottom: parseInt(D1("sab")) || 0, left: parseInt(D1("sal")) || 0, right: parseInt(D1("sar")) || 0 }, f = df().rtl, p = -r.scrollX + o / 2 + h.left, g = -r.scrollY + u / 2 + h.top, b = p + c - h.right, v = g + d - h.bottom, U = Math.min(i, p), y = Math.min(a, g), w = Math.max(l, b), x = Math.max(s, v);
  return { horizontal: p === U && b === w ? null : { x: Math.max(h.left, rl) + (p - U) / (w - U) * t, y: n - ao - Math.max(rl, h.bottom), width: (b - p) / (w - U) * t - Math.max(rl * 2, h.left + h.right), height: ao }, vertical: g === y && v === x ? null : { x: f ? Math.max(h.left, rl) : t - ao - Math.max(h.right, rl), y: (g - y) / (x - y) * n + Math.max(h.top, rl), width: ao, height: (v - g) / (x - y) * n - Math.max(rl * 2, h.top + h.bottom) } };
}, t_ = (e, t, n) => {
  let [r, i] = [e.horizontal, e.vertical].map((a) => a != null && a.x <= t && t <= a.x + a.width && a.y <= n && n <= a.y + a.height);
  return { isOverEither: r || i, isOverHorizontal: r, isOverVertical: i };
}, Z1e = "medium", aP = (e) => e.penDetected ? D("label", { className: Me("ToolIcon ToolIcon__penMode", `ToolIcon_size_${Z1e}`, { "is-mobile": e.isMobile }), title: `${e.title}`, children: [m("input", { className: "ToolIcon_type_checkbox", type: "checkbox", name: e.name, onChange: e.onChange, checked: e.checked, "aria-label": e.title }), m("div", { className: "ToolIcon__icon", children: Lq })] }) : null, lP = (e) => m(yt, { className: Me("Shape", { fillable: !1 }), type: "radio", icon: oA, name: "editor-current-shape", checked: e.checked, title: `${e.title} — H`, keyBindingLabel: e.isMobile ? void 0 : H.H.toLocaleUpperCase(), "aria-label": `${e.title} — H`, "aria-keyshortcuts": H.H, "data-testid": "toolbar-hand", onChange: () => {
  var t;
  return (t = e.onChange) == null ? void 0 : t.call(e);
} }), J1e = ({ appState: e, elements: t, actionManager: n, setAppState: r, onLockToggle: i, onHandToolToggle: a, onPenModeToggle: l, renderTopRightUI: s, renderCustomStats: c, renderSidebars: d, device: o, renderWelcomeScreen: u, UIOptions: h, app: f }) => {
  var y, w;
  let { WelcomeScreenCenterTunnel: p, MainMenuTunnel: g, DefaultSidebarTriggerTunnel: b } = Li(), v = () => D(eP, { side: "top", className: "App-top-bar", children: [u && m(p.Out, {}), m(hf, { heading: "shapes", children: (x) => {
    var E;
    return m(Wi.Col, { gap: 4, align: "center", children: D(Wi.Row, { gap: 1, className: "App-toolbar-container", children: [D(Da, { padding: 1, className: "App-toolbar App-toolbar--mobile", children: [x, m(Wi.Row, { gap: 1, children: m(GR, { appState: e, activeTool: e.activeTool, UIOptions: h, app: f }) })] }), s && s(!0, e), D("div", { className: "mobile-misc-tools-container", children: [!e.viewModeEnabled && ((E = e.openDialog) == null ? void 0 : E.name) !== "elementLinkSelector" && m(b.Out, {}), m(aP, { checked: e.penMode, onChange: () => l(null), title: N("toolBar.penMode"), isMobile: !0, penDetected: e.penDetected }), m(iP, { checked: e.activeTool.locked, onChange: i, title: N("toolBar.lock"), isMobile: !0 }), m(lP, { checked: m0(e), onChange: () => a(), title: N("toolBar.hand"), isMobile: !0 })] })] }) });
  } }), m(rP, { appState: e, isMobile: !0, device: o, app: f })] }), U = () => {
    var x;
    return e.viewModeEnabled || ((x = e.openDialog) == null ? void 0 : x.name) === "elementLinkSelector" ? m("div", { className: "App-toolbar-content", children: m(g.Out, {}) }) : D("div", { className: "App-toolbar-content", children: [m(g.Out, {}), n.renderAction("toggleEditMenu"), n.renderAction(e.multiElement ? "finalize" : "duplicateSelection"), n.renderAction("deleteSelectedElements"), D("div", { children: [n.renderAction("undo"), n.renderAction("redo")] })] });
  };
  return D(ge, { children: [d(), !e.viewModeEnabled && ((y = e.openDialog) == null ? void 0 : y.name) !== "elementLinkSelector" && v(), m("div", { className: "App-bottom-bar", style: { marginBottom: ao + rl * 2, marginLeft: ao + rl * 2, marginRight: ao + rl * 2 }, children: D(Da, { padding: 0, children: [e.openMenu === "shape" && !e.viewModeEnabled && ((w = e.openDialog) == null ? void 0 : w.name) !== "elementLinkSelector" && UU(e, t) ? m(hf, { className: "App-mobile-menu", heading: "selectedShapeActions", children: m(VR, { appState: e, elementsMap: f.scene.getNonDeletedElementsMap(), renderAction: n.renderAction, app: f }) }) : null, D("footer", { className: "App-toolbar", children: [U(), e.scrolledOutside && !e.openMenu && !e.openSidebar && m("button", { type: "button", className: "scroll-back-to-content", onClick: () => {
    r((x) => ({ ...ef(t, x) }));
  }, children: N("buttons.scrollBackToContent") })] })] }) })] });
}, n_ = (e) => {
  let t = de(null), [n, r] = Q(null);
  return Bn(() => {
    if (!e.spreadsheet) return;
    let i = Yae(e.chartType, e.spreadsheet, 0, 0);
    r(i);
    let a, l = t.current;
    return (async () => {
      var s;
      return a = await j8(i, { exportBackground: !1, viewBackgroundColor: wr.white }, null, { skipInliningFonts: !0 }), (s = a.querySelector(".style-fonts")) == null || s.remove(), l.replaceChildren(), l.appendChild(a), e.selected && l.parentNode.focus();
    })(), () => {
      l.replaceChildren();
    };
  }, [e.spreadsheet, e.chartType, e.selected]), m("button", { type: "button", className: "ChartPreview", onClick: () => {
    n && e.onClick(e.chartType, n);
  }, children: m("div", { ref: t }) });
}, Q1e = ({ setAppState: e, appState: t, onClose: n }) => {
  let { onInsertElements: r } = Pl(), i = pe.useCallback(() => {
    n && n();
  }, [n]), a = (l, s) => {
    r(s), tn("paste", "chart", l), e({ currentChartType: l, pasteDialog: { shown: !1, data: null } });
  };
  return m(Wa, { size: "small", onCloseRequest: i, title: N("labels.pasteCharts"), className: "PasteChartDialog", autofocus: !1, children: D("div", { className: "container", children: [m(n_, { chartType: "bar", spreadsheet: t.pasteDialog.data, selected: t.currentChartType === "bar", onClick: a }), m(n_, { chartType: "line", spreadsheet: t.pasteDialog.data, selected: t.currentChartType === "line", onClick: a })] }) });
}, epe = () => D("div", { className: "HelpDialog__header", children: [D("a", { className: "HelpDialog__btn", href: "https://docs.excalidraw.com", target: "_blank", rel: "noopener noreferrer", children: [m("div", { className: "HelpDialog__link-icon", children: tx }), N("helpDialog.documentation")] }), D("a", { className: "HelpDialog__btn", href: "https://plus.excalidraw.com/blog", target: "_blank", rel: "noopener noreferrer", children: [m("div", { className: "HelpDialog__link-icon", children: tx }), N("helpDialog.blog")] }), D("a", { className: "HelpDialog__btn", href: "https://github.com/excalidraw/excalidraw/issues", target: "_blank", rel: "noopener noreferrer", children: [m("div", { className: "HelpDialog__link-icon", children: tA }), N("helpDialog.github")] }), D("a", { className: "HelpDialog__btn", href: "https://youtube.com/@excalidraw", target: "_blank", rel: "noopener noreferrer", children: [m("div", { className: "HelpDialog__link-icon", children: tJ }), "YouTube"] })] }), tpe = (e) => D(ge, { children: [m("h3", { children: e.title }), m("div", { className: "HelpDialog__islands-container", children: e.children })] }), M5 = (e) => D("div", { className: `HelpDialog__island ${e.className}`, children: [m("h4", { className: "HelpDialog__island-title", children: e.caption }), m("div", { className: "HelpDialog__island-content", children: e.children })] });
function* npe(e, t) {
  let n = !0;
  for (let r of e) n || (yield t), n = !1, yield r;
}
var rpe = (e) => e.replace(/\b[a-z]\b/, (t) => t.toUpperCase()), ke = ({ label: e, shortcuts: t, isOr: n = !0 }) => {
  let r = t.map((i) => (i.endsWith("++") ? [...i.slice(0, -2).split("+"), "+"] : i.split("+")).map((a) => m(ipe, { children: rpe(a) }, a)));
  return D("div", { className: "HelpDialog__shortcut", children: [m("div", { children: e }), m("div", { className: "HelpDialog__key-container", children: [...npe(r, n ? N("helpDialog.or") : null)] })] });
}, ipe = (e) => m("kbd", { className: "HelpDialog__key", ...e }), ape = ({ onClose: e }) => {
  let t = pe.useCallback(() => {
    e && e();
  }, [e]);
  return m(ge, { children: D(Wa, { onCloseRequest: t, title: N("helpDialog.title"), className: "HelpDialog", children: [m(epe, {}), D(tpe, { title: N("helpDialog.shortcuts"), children: [D(M5, { className: "HelpDialog__island--tools", caption: N("helpDialog.tools"), children: [m(ke, { label: N("toolBar.hand"), shortcuts: [H.H] }), m(ke, { label: N("toolBar.selection"), shortcuts: [H.V, H[1]] }), m(ke, { label: N("toolBar.rectangle"), shortcuts: [H.R, H[2]] }), m(ke, { label: N("toolBar.diamond"), shortcuts: [H.D, H[3]] }), m(ke, { label: N("toolBar.ellipse"), shortcuts: [H.O, H[4]] }), m(ke, { label: N("toolBar.arrow"), shortcuts: [H.A, H[5]] }), m(ke, { label: N("toolBar.line"), shortcuts: [H.L, H[6]] }), m(ke, { label: N("toolBar.freedraw"), shortcuts: [H.P, H[7]] }), m(ke, { label: N("toolBar.text"), shortcuts: [H.T, H[8]] }), m(ke, { label: N("toolBar.image"), shortcuts: [H[9]] }), m(ke, { label: N("toolBar.eraser"), shortcuts: [H.E, H[0]] }), m(ke, { label: N("toolBar.frame"), shortcuts: [H.F] }), m(ke, { label: N("toolBar.laser"), shortcuts: [H.K] }), m(ke, { label: N("labels.eyeDropper"), shortcuts: [H.I, "Shift+S", "Shift+G"] }), m(ke, { label: N("helpDialog.editLineArrowPoints"), shortcuts: [ae("CtrlOrCmd+Enter")] }), m(ke, { label: N("helpDialog.editText"), shortcuts: [ae("Enter")] }), m(ke, { label: N("helpDialog.textNewLine"), shortcuts: [ae("Enter"), ae("Shift+Enter")] }), m(ke, { label: N("helpDialog.textFinish"), shortcuts: [ae("Esc"), ae("CtrlOrCmd+Enter")] }), m(ke, { label: N("helpDialog.curvedArrow"), shortcuts: ["A", N("helpDialog.click"), N("helpDialog.click"), N("helpDialog.click")], isOr: !1 }), m(ke, { label: N("helpDialog.curvedLine"), shortcuts: ["L", N("helpDialog.click"), N("helpDialog.click"), N("helpDialog.click")], isOr: !1 }), m(ke, { label: N("helpDialog.cropStart"), shortcuts: [N("helpDialog.doubleClick"), ae("Enter")], isOr: !0 }), m(ke, { label: N("helpDialog.cropFinish"), shortcuts: [ae("Enter"), ae("Escape")], isOr: !0 }), m(ke, { label: N("toolBar.lock"), shortcuts: [H.Q] }), m(ke, { label: N("helpDialog.preventBinding"), shortcuts: [ae("CtrlOrCmd")] }), m(ke, { label: N("toolBar.link"), shortcuts: [ae("CtrlOrCmd+K")] })] }), D(M5, { className: "HelpDialog__island--view", caption: N("helpDialog.view"), children: [m(ke, { label: N("buttons.zoomIn"), shortcuts: [ae("CtrlOrCmd++")] }), m(ke, { label: N("buttons.zoomOut"), shortcuts: [ae("CtrlOrCmd+-")] }), m(ke, { label: N("buttons.resetZoom"), shortcuts: [ae("CtrlOrCmd+0")] }), m(ke, { label: N("helpDialog.zoomToFit"), shortcuts: ["Shift+1"] }), m(ke, { label: N("helpDialog.zoomToSelection"), shortcuts: ["Shift+2"] }), m(ke, { label: N("helpDialog.movePageUpDown"), shortcuts: ["PgUp/PgDn"] }), m(ke, { label: N("helpDialog.movePageLeftRight"), shortcuts: ["Shift+PgUp/PgDn"] }), m(ke, { label: N("buttons.zenMode"), shortcuts: [ae("Alt+Z")] }), m(ke, { label: N("buttons.objectsSnapMode"), shortcuts: [ae("Alt+S")] }), m(ke, { label: N("labels.toggleGrid"), shortcuts: [ae("CtrlOrCmd+'")] }), m(ke, { label: N("labels.viewMode"), shortcuts: [ae("Alt+R")] }), m(ke, { label: N("labels.toggleTheme"), shortcuts: [ae("Alt+Shift+D")] }), m(ke, { label: N("stats.fullTitle"), shortcuts: [ae("Alt+/")] }), m(ke, { label: N("search.title"), shortcuts: [Pr("searchMenu")] }), m(ke, { label: N("commandPalette.title"), shortcuts: Vh ? [Pr("commandPalette")] : [Pr("commandPalette"), Pr("commandPalette", 1)] })] }), D(M5, { className: "HelpDialog__island--editor", caption: N("helpDialog.editor"), children: [m(ke, { label: N("helpDialog.createFlowchart"), shortcuts: [ae("CtrlOrCmd+Arrow Key")], isOr: !0 }), m(ke, { label: N("helpDialog.navigateFlowchart"), shortcuts: [ae("Alt+Arrow Key")], isOr: !0 }), m(ke, { label: N("labels.moveCanvas"), shortcuts: [ae(`Space+${N("helpDialog.drag")}`), ae(`Wheel+${N("helpDialog.drag")}`)], isOr: !0 }), m(ke, { label: N("buttons.clearReset"), shortcuts: [ae("CtrlOrCmd+Delete")] }), m(ke, { label: N("labels.delete"), shortcuts: [ae("Delete")] }), m(ke, { label: N("labels.cut"), shortcuts: [ae("CtrlOrCmd+X")] }), m(ke, { label: N("labels.copy"), shortcuts: [ae("CtrlOrCmd+C")] }), m(ke, { label: N("labels.paste"), shortcuts: [ae("CtrlOrCmd+V")] }), m(ke, { label: N("labels.pasteAsPlaintext"), shortcuts: [ae("CtrlOrCmd+Shift+V")] }), m(ke, { label: N("labels.selectAll"), shortcuts: [ae("CtrlOrCmd+A")] }), m(ke, { label: N("labels.multiSelect"), shortcuts: [ae(`Shift+${N("helpDialog.click")}`)] }), m(ke, { label: N("helpDialog.deepSelect"), shortcuts: [ae(`CtrlOrCmd+${N("helpDialog.click")}`)] }), m(ke, { label: N("helpDialog.deepBoxSelect"), shortcuts: [ae(`CtrlOrCmd+${N("helpDialog.drag")}`)] }), (aU || Vh) && m(ke, { label: N("labels.copyAsPng"), shortcuts: [ae("Shift+Alt+C")] }), m(ke, { label: N("labels.copyStyles"), shortcuts: [ae("CtrlOrCmd+Alt+C")] }), m(ke, { label: N("labels.pasteStyles"), shortcuts: [ae("CtrlOrCmd+Alt+V")] }), m(ke, { label: N("labels.sendToBack"), shortcuts: [ae(xl ? "CtrlOrCmd+Alt+[" : "CtrlOrCmd+Shift+[")] }), m(ke, { label: N("labels.bringToFront"), shortcuts: [ae(xl ? "CtrlOrCmd+Alt+]" : "CtrlOrCmd+Shift+]")] }), m(ke, { label: N("labels.sendBackward"), shortcuts: [ae("CtrlOrCmd+[")] }), m(ke, { label: N("labels.bringForward"), shortcuts: [ae("CtrlOrCmd+]")] }), m(ke, { label: N("labels.alignTop"), shortcuts: [ae("CtrlOrCmd+Shift+Up")] }), m(ke, { label: N("labels.alignBottom"), shortcuts: [ae("CtrlOrCmd+Shift+Down")] }), m(ke, { label: N("labels.alignLeft"), shortcuts: [ae("CtrlOrCmd+Shift+Left")] }), m(ke, { label: N("labels.alignRight"), shortcuts: [ae("CtrlOrCmd+Shift+Right")] }), m(ke, { label: N("labels.duplicateSelection"), shortcuts: [ae("CtrlOrCmd+D"), ae(`Alt+${N("helpDialog.drag")}`)] }), m(ke, { label: N("helpDialog.toggleElementLock"), shortcuts: [ae("CtrlOrCmd+Shift+L")] }), m(ke, { label: N("buttons.undo"), shortcuts: [ae("CtrlOrCmd+Z")] }), m(ke, { label: N("buttons.redo"), shortcuts: _I ? [ae("CtrlOrCmd+Y"), ae("CtrlOrCmd+Shift+Z")] : [ae("CtrlOrCmd+Shift+Z")] }), m(ke, { label: N("labels.group"), shortcuts: [ae("CtrlOrCmd+G")] }), m(ke, { label: N("labels.ungroup"), shortcuts: [ae("CtrlOrCmd+Shift+G")] }), m(ke, { label: N("labels.flipHorizontal"), shortcuts: [ae("Shift+H")] }), m(ke, { label: N("labels.flipVertical"), shortcuts: [ae("Shift+V")] }), m(ke, { label: N("labels.showStroke"), shortcuts: [ae("S")] }), m(ke, { label: N("labels.showBackground"), shortcuts: [ae("G")] }), m(ke, { label: N("labels.showFonts"), shortcuts: [ae("Shift+F")] }), m(ke, { label: N("labels.decreaseFontSize"), shortcuts: [ae("CtrlOrCmd+Shift+<")] }), m(ke, { label: N("labels.increaseFontSize"), shortcuts: [ae("CtrlOrCmd+Shift+>")] })] })] })] }) });
}, lpe = 4, spe = 8, ope = ({ shouldWrap: e, children: t, username: n }) => e ? m(ed, { label: n || "Unknown user", children: t }) : m(ge, { children: t }), T5 = ({ actionManager: e, collaborator: t, socketId: n, withName: r = !1, shouldWrapWithTooltip: i = !1, isBeingFollowed: a }) => {
  let l = { socketId: n, collaborator: t, withName: r, isBeingFollowed: a }, s = e.renderAction("goToCollaborator", l);
  return m(ope, { username: t.username, shouldWrap: i, children: s }, n);
}, cpe = ["avatarUrl", "id", "socketId", "username", "isInCall", "isSpeaking", "isMuted"], sP = pe.memo(({ className: e, mobile: t, collaborators: n, userToFollow: r }) => {
  let i = mi(), a = /* @__PURE__ */ new Map();
  n.forEach((p, g) => {
    let b = p.id || g;
    a.set(b, { ...p, socketId: g });
  });
  let l = Array.from(a.values()).filter((p) => {
    var g;
    return (g = p.username) == null ? void 0 : g.trim();
  }), [s, c] = pe.useState(""), d = l.filter((p) => {
    var g;
    return (g = p.username) == null ? void 0 : g.toLowerCase().includes(s);
  }), o = pe.useRef(null);
  Bn(() => {
    if (o.current) {
      let p = (b) => {
        let v = Math.max(1, Math.min(8, Math.floor(b / 38)));
        h(v);
      };
      if (p(o.current.clientWidth), !t7) return;
      let g = new ResizeObserver((b) => {
        for (let v of b) {
          let { width: U } = v.contentRect;
          p(U);
        }
      });
      return g.observe(o.current), () => {
        g.disconnect();
      };
    }
  }, []);
  let [u, h] = pe.useState(lpe), f = l.slice(0, u - 1).map((p) => T5({ actionManager: i, collaborator: p, socketId: p.socketId, shouldWrapWithTooltip: !0, isBeingFollowed: p.socketId === r }));
  return t ? m("div", { className: Me("UserList UserList_mobile", e), children: l.map((p) => T5({ actionManager: i, collaborator: p, socketId: p.socketId, shouldWrapWithTooltip: !0, isBeingFollowed: p.socketId === r })) }) : m("div", { className: "UserList__wrapper", ref: o, children: D("div", { className: Me("UserList", e), style: { "--max-avatars": u }, children: [f, l.length > u - 1 && D(_2, { children: [D(k2, { className: "UserList__more", children: ["+", l.length - u + 1] }), m(RU, { style: { zIndex: 2, width: "15rem", textAlign: "left" }, align: "end", sideOffset: 10, children: D(Da, { padding: 2, children: [l.length >= spe && m(fR, { placeholder: N("quickSearch.placeholder"), onChange: c }), m(pR, { className: "dropdown-menu UserList__collaborators", placeholder: N("userList.empty"), children: d.length > 0 ? [m("div", { className: "hint", children: N("userList.hint.text") }), d.map((p) => T5({ actionManager: i, collaborator: p, socketId: p.socketId, withName: !0, isBeingFollowed: p.socketId === r }))] : [] }), m(kL, { width: 20, height: 10, style: { fill: "var(--popup-bg-color)", filter: "drop-shadow(rgba(0, 0, 0, 0.05) 0px 3px 2px)" } })] }) })] })] }) });
}, (e, t) => {
  if (e.collaborators.size !== t.collaborators.size || e.mobile !== t.mobile || e.className !== t.className || e.userToFollow !== t.userToFollow) return !1;
  let n = t.collaborators.keys();
  for (let [r, i] of e.collaborators) {
    let a = t.collaborators.get(r);
    if (!a || r !== n.next().value || !Tr(i, a, cpe)) return !1;
  }
  return !0;
}), r_ = ({ children: e, color: t }) => m("div", { className: "Card", style: { "--card-color": t === "primary" ? "var(--color-primary)" : wr[t][7], "--card-color-darker": t === "primary" ? "var(--color-primary-darker)" : wr[t][8], "--card-color-darkest": t === "primary" ? "var(--color-primary-darkest)" : wr[t][9] }, children: e }), dpe = ({ elements: e, appState: t, setAppState: n, files: r, actionManager: i, exportOpts: a, canvas: l, onCloseRequest: s }) => {
  let { onExportToBackend: c } = a;
  return m("div", { className: "ExportDialog ExportDialog--json", children: D("div", { className: "ExportDialog-cards", children: [a.saveFileToDisk && D(r_, { color: "lime", children: [m("div", { className: "Card-icon", children: Gq }), m("h2", { children: N("exportDialog.disk_title") }), D("div", { className: "Card-details", children: [N("exportDialog.disk_details"), !od && i.renderAction("changeProjectName")] }), m(yt, { className: "Card-button", type: "button", title: N("exportDialog.disk_button"), "aria-label": N("exportDialog.disk_button"), showAriaLabel: !0, onClick: () => {
    i.executeAction(SR, "ui");
  } })] }), c && D(r_, { color: "pink", children: [m("div", { className: "Card-icon", children: c7 }), m("h2", { children: N("exportDialog.link_title") }), m("div", { className: "Card-details", children: N("exportDialog.link_details") }), m(yt, { className: "Card-button", type: "button", title: N("exportDialog.link_button"), "aria-label": N("exportDialog.link_button"), showAriaLabel: !0, onClick: async () => {
    try {
      tn("export", "link", `ui (${JY()})`), await c(e, t, r), s();
    } catch (d) {
      n({ errorMessage: d.message });
    }
  } })] }), a.renderCustomUI && a.renderCustomUI(e, t, r, l)] }) });
}, upe = ({ elements: e, appState: t, files: n, actionManager: r, exportOpts: i, canvas: a, setAppState: l }) => {
  var c;
  let s = pe.useCallback(() => {
    l({ openDialog: null });
  }, [l]);
  return m(ge, { children: ((c = t.openDialog) == null ? void 0 : c.name) === "jsonExport" && m(Wa, { onCloseRequest: s, title: N("buttons.export"), children: m(dpe, { elements: e, appState: t, setAppState: l, files: n, actionManager: r, onCloseRequest: s, exportOpts: i, canvas: a }) }) });
}, hpe = (e) => m("button", { className: "help-icon", onClick: e.onClick, type: "button", title: `${N("helpDialog.title")} — ?`, "aria-label": N("helpDialog.title"), children: _8 }), oP = ({ appState: e, actionManager: t, showExitZenModeBtn: n, renderWelcomeScreen: r }) => {
  let { FooterCenterTunnel: i, WelcomeScreenHelpHintTunnel: a } = Li(), l = ur(), s = !e.viewModeEnabled && e.multiElement && l.isTouchScreen;
  return D("footer", { role: "contentinfo", className: "layer-ui__wrapper__footer App-menu App-menu_bottom", children: [m("div", { className: Me("layer-ui__wrapper__footer-left zen-mode-transition", { "layer-ui__wrapper__footer-left--transition-left": e.zenModeEnabled }), children: m(Wi.Col, { gap: 2, children: D(hf, { heading: "canvasActions", children: [m(g1e, { renderAction: t.renderAction, zoom: e.zoom }), !e.viewModeEnabled && m(b1e, { renderAction: t.renderAction, className: Me("zen-mode-transition", { "layer-ui__wrapper__footer-left--transition-bottom": e.zenModeEnabled }) }), s && m(v1e, { renderAction: t.renderAction, className: Me("zen-mode-transition", { "layer-ui__wrapper__footer-left--transition-left": e.zenModeEnabled }) })] }) }) }), m(i.Out, {}), m("div", { className: Me("layer-ui__wrapper__footer-right zen-mode-transition", { "transition-right": e.zenModeEnabled }), children: D("div", { style: { position: "relative" }, children: [r && m(a.Out, {}), m(hpe, { onClick: () => t.executeAction(jU) })] }) }), m(U1e, { actionManager: t, showExitZenModeBtn: n })] });
}, fpe = oP;
oP.displayName = "Footer";
var cP = pe.createContext({}), dP = ({ children: e, className: t }) => {
  let n = ur(), r = Er(cP), i = !!(n.editor.canFitSidebar && r.shouldRenderDockButton);
  return D("div", { className: Me("sidebar__header", t), "data-testid": "sidebar-header", children: [e, D("div", { className: "sidebar__header__buttons", children: [i && m(ed, { label: N("labels.sidebarLock"), children: m(N0, { onSelect: () => {
    var a;
    return (a = r.onDock) == null ? void 0 : a.call(r, !r.docked);
  }, selected: !!r.docked, className: "sidebar__dock", "data-testid": "sidebar-dock", "aria-label": N("labels.sidebarLock"), children: Sq }) }), m(N0, { "data-testid": "sidebar-close", className: "sidebar__close", onSelect: r.onCloseRequest, "aria-label": N("buttons.close"), children: iu })] })] });
};
dP.displayName = "SidebarHeader";
var uP = ({ name: e, tab: t, icon: n, title: r, children: i, onToggle: a, className: l, style: s }) => {
  var o;
  let c = hr(), d = Zr();
  return D("label", { title: r, className: "sidebar-trigger__label-element", children: [m("input", { className: "ToolIcon_type_checkbox", type: "checkbox", onChange: (u) => {
    var f;
    (f = document.querySelector(".layer-ui__wrapper")) == null || f.classList.remove("animate");
    let h = u.target.checked;
    c({ openSidebar: h ? { name: e, tab: t } : null }), a == null || a(h);
  }, checked: ((o = d.openSidebar) == null ? void 0 : o.name) === e, "aria-label": r, "aria-keyshortcuts": "0" }), D("div", { className: Me("sidebar-trigger", l), style: s, children: [n && m("div", { children: n }), i && m("div", { className: "sidebar-trigger__label", children: i })] })] });
};
uP.displayName = "SidebarTrigger";
var hP = ({ children: e, ...t }) => m(jL, { className: "sidebar-triggers", ...t, children: e });
hP.displayName = "SidebarTabTriggers";
var fP = ({ children: e, tab: t, onSelect: n, ...r }) => m(KL, { value: t, asChild: !0, onSelect: n, children: m("button", { type: "button", className: "excalidraw-button sidebar-tab-trigger", ...r, children: e }) });
fP.displayName = "SidebarTabTrigger";
var pP = ({ children: e, ...t }) => {
  let n = Zr(), r = hr();
  if (!n.openSidebar) return null;
  let { name: i } = n.openSidebar;
  return m(GL, { className: "sidebar-tabs-root", value: n.openSidebar.tab, onValueChange: (a) => r((l) => ({ ...l, openSidebar: { ...l.openSidebar, name: i, tab: a } })), ...t, children: e });
};
pP.displayName = "SidebarTabs";
var mP = ({ tab: e, children: t, ...n }) => m(YL, { ...n, value: e, "data-testid": e, children: t });
mP.displayName = "SidebarTab";
var ZU = Sr(!1), gP = dn(({ name: e, children: t, onDock: n, docked: r, className: i, ...a }, l) => {
  st.DEV && n && r == null && console.warn("Sidebar: `docked` must be set when `onDock` is supplied for the sidebar to be user-dockable. To hide this message, either pass `docked` or remove `onDock`");
  let s = hr(), c = M2(ZU);
  Bn(() => (c(!!r), () => {
    c(!1);
  }), [c, r]);
  let d = de({});
  d.current.onCloseRequest = () => {
    s({ openSidebar: null });
  }, d.current.onDock = (f) => n == null ? void 0 : n(f), d.current = hp(d.current, { docked: r, shouldRenderDockButton: !!n && r != null });
  let o = de(null);
  y3(l, () => o.current);
  let u = ur(), h = he(() => {
    document.querySelector(".Dialog") || s({ openSidebar: null });
  }, [s]);
  return BU(o, he((f) => {
    f.target.closest(".sidebar-trigger") || (!r || !u.editor.canFitSidebar) && h();
  }, [h, r, u.editor.canFitSidebar])), Y(() => {
    let f = (p) => {
      p.key === H.ESCAPE && (!r || !u.editor.canFitSidebar) && h();
    };
    return document.addEventListener("keydown", f), () => {
      document.removeEventListener("keydown", f);
    };
  }, [h, r, u.editor.canFitSidebar]), m(Da, { ...a, className: Me("sidebar", { "sidebar--docked": r }, i), ref: o, children: m(cP.Provider, { value: d.current, children: t }) });
});
gP.displayName = "SidebarInner";
var el = Object.assign(dn((e, t) => {
  var s;
  let n = Zr(), { onStateChange: r } = e, i = de(n.openSidebar);
  Y(() => {
    var c, d, o, u, h;
    (!n.openSidebar && ((c = i == null ? void 0 : i.current) == null ? void 0 : c.name) === e.name || ((d = n.openSidebar) == null ? void 0 : d.name) === e.name && ((o = i == null ? void 0 : i.current) == null ? void 0 : o.name) !== e.name || ((u = i.current) == null ? void 0 : u.name) === e.name) && n.openSidebar !== i.current && (r == null || r(((h = n.openSidebar) == null ? void 0 : h.name) !== e.name ? null : n.openSidebar)), i.current = n.openSidebar;
  }, [n.openSidebar, r, e.name]);
  let [a, l] = Q(!1);
  return Bn(() => (l(!0), () => l(!1)), []), a && ((s = n.openSidebar) == null ? void 0 : s.name) === e.name ? zt(gP, { ...e, ref: t, key: e.name }) : null;
}), { Header: dP, TabTriggers: hP, TabTrigger: fP, Tabs: pP, Tab: mP, Trigger: uP });
el.displayName = "Sidebar";
var bP = {};
ET(bP, { ChangeCanvasBackground: () => MP, ClearCanvas: () => kP, CommandPalette: () => EP, Export: () => TP, Help: () => _P, LiveCollaborationTrigger: () => AP, LoadScene: () => yP, SaveAsImage: () => xP, SaveToActiveFile: () => wP, SearchMenu: () => SP, Socials: () => IP, ToggleTheme: () => CP });
var UP = Sr({ active: !1 });
async function ppe({ title: e, description: t, actionLabel: n, color: r }) {
  return new Promise((i) => {
    _a.set(UP, { active: !0, onConfirm: () => i(!0), onClose: () => i(!1), onReject: () => i(!1), title: e, description: t, actionLabel: n, color: r });
  });
}
var vP = ({ value: e, shortcut: t, onChange: n, choices: r, children: i, name: a }) => {
  let l = ur();
  return D(ge, { children: [D("div", { className: "dropdown-menu-item-base dropdown-menu-item-bare", children: [m("label", { className: "dropdown-menu-item__text", htmlFor: a, children: i }), m(QR, { name: a, value: e, onChange: n, choices: r })] }), t && !l.editor.isMobile && m("div", { className: "dropdown-menu-item__shortcut dropdown-menu-item__shortcut--orphaned", children: t })] });
};
vP.displayName = "DropdownMenuItemContentRadio";
var mpe = vP, yP = () => {
  let { t: e } = Fr(), t = mi(), n = $2();
  return t.isActionEnabled(Q7) ? m(la, { icon: k8, onSelect: async () => {
    (!n.length || await ppe({ title: e("overwriteConfirm.modal.loadFromFile.title"), actionLabel: e("overwriteConfirm.modal.loadFromFile.button"), color: "warning", description: m(bl, { i18nKey: "overwriteConfirm.modal.loadFromFile.description", bold: (r) => m("strong", { children: r }), br: () => m("br", {}) }) })) && t.executeAction(Q7);
  }, "data-testid": "load-button", shortcut: Pr("loadScene"), "aria-label": e("buttons.load"), children: e("buttons.load") }) : null;
};
yP.displayName = "LoadScene";
var wP = () => {
  let { t: e } = Fr(), t = mi();
  return t.isActionEnabled(AS) ? m(la, { shortcut: Pr("saveScene"), "data-testid": "save-button", onSelect: () => t.executeAction(AS), icon: Wq, "aria-label": `${e("buttons.save")}`, children: `${e("buttons.save")}` }) : null;
};
wP.displayName = "SaveToActiveFile";
var xP = () => {
  let e = hr(), { t } = Fr();
  return m(la, { icon: nA, "data-testid": "image-export-button", onSelect: () => e({ openDialog: { name: "imageExport" } }), shortcut: Pr("imageExport"), "aria-label": t("buttons.exportImage"), children: t("buttons.exportImage") });
};
xP.displayName = "SaveAsImage";
var EP = (e) => {
  let t = hr(), { t: n } = Fr();
  return m(la, { icon: fA, "data-testid": "command-palette-button", onSelect: () => {
    tn("command_palette", "open", "menu"), t({ openDialog: { name: "commandPalette" } });
  }, shortcut: Pr("commandPalette"), "aria-label": n("commandPalette.title"), className: e == null ? void 0 : e.className, children: n("commandPalette.title") });
};
EP.displayName = "CommandPalette";
var SP = (e) => {
  let { t } = Fr(), n = mi();
  return m(la, { icon: Kc, "data-testid": "search-menu-button", onSelect: () => {
    n.executeAction(qR);
  }, shortcut: Pr("searchMenu"), "aria-label": t("search.title"), className: e == null ? void 0 : e.className, children: t("search.title") });
};
SP.displayName = "SearchMenu";
var _P = () => {
  let { t: e } = Fr(), t = mi();
  return m(la, { "data-testid": "help-menu-item", icon: _8, onSelect: () => t.executeAction(jU), shortcut: "?", "aria-label": e("helpDialog.title"), children: e("helpDialog.title") });
};
_P.displayName = "Help";
var kP = () => {
  let { t: e } = Fr(), t = M2(O2);
  return mi().isActionEnabled(Sh) ? m(la, { icon: jc, onSelect: () => t("clearCanvas"), "data-testid": "clear-canvas-button", "aria-label": e("buttons.clearReset"), children: e("buttons.clearReset") }) : null;
};
kP.displayName = "ClearCanvas";
var CP = (e) => {
  let { t } = Fr(), n = Zr(), r = mi(), i = Pr("toggleTheme");
  return r.isActionEnabled(Jm) ? e != null && e.allowSystemTheme ? m(mpe, { name: "theme", value: e.theme, onChange: (a) => e.onSelect(a), choices: [{ value: gt.LIGHT, label: o7, ariaLabel: `${t("buttons.lightMode")} - ${i}` }, { value: gt.DARK, label: s7, ariaLabel: `${t("buttons.darkMode")} - ${i}` }, { value: "system", label: eJ, ariaLabel: t("buttons.systemMode") }], children: t("labels.theme") }) : m(la, { onSelect: (a) => {
    if (a.preventDefault(), e == null ? void 0 : e.onSelect) e.onSelect(n.theme === gt.DARK ? gt.LIGHT : gt.DARK);
    else return r.executeAction(Jm);
  }, icon: n.theme === gt.DARK ? o7 : s7, "data-testid": "toggle-dark-mode", shortcut: i, "aria-label": n.theme === gt.DARK ? t("buttons.lightMode") : t("buttons.darkMode"), children: n.theme === gt.DARK ? t("buttons.lightMode") : t("buttons.darkMode") }) : null;
};
CP.displayName = "ToggleTheme";
var MP = () => {
  let { t: e } = Fr(), t = Zr(), n = mi(), r = Qf();
  return t.viewModeEnabled || !r.UIOptions.canvasActions.changeViewBackgroundColor ? null : D("div", { style: { marginTop: "0.5rem" }, children: [m("div", { "data-testid": "canvas-background-label", style: { fontSize: ".75rem", marginBottom: ".5rem" }, children: e("labels.canvasBackground") }), m("div", { style: { padding: "0 0.625rem" }, children: n.renderAction("changeViewBackgroundColor") })] });
};
MP.displayName = "ChangeCanvasBackground";
var TP = () => {
  let { t: e } = Fr(), t = hr();
  return m(la, { icon: t2, onSelect: () => {
    t({ openDialog: { name: "jsonExport" } });
  }, "data-testid": "json-export-button", "aria-label": e("buttons.export"), children: e("buttons.export") });
};
TP.displayName = "Export";
var IP = () => {
  let { t: e } = Fr();
  return D(ge, { children: [m(Ap, { icon: tA, href: "https://github.com/excalidraw/excalidraw", "aria-label": "GitHub", children: "GitHub" }), m(Ap, { icon: Bq, href: "https://x.com/excalidraw", "aria-label": "X", children: e("labels.followUs") }), m(Ap, { icon: zq, href: "https://discord.gg/UexuTaE", "aria-label": "Discord", children: e("labels.discordChat") })] });
};
IP.displayName = "Socials";
var AP = ({ onSelect: e, isCollaborating: t }) => {
  let { t: n } = Fr();
  return m(la, { "data-testid": "collab-button", icon: aA, className: Me({ "active-collab": t }), onSelect: e, children: n("labels.liveCollaboration") });
};
AP.displayName = "LiveCollaborationTrigger";
var Zf = (e, t) => {
  let n = Sr(0), r = (i) => {
    let { tunnelsJotai: { useAtom: a } } = Li(), [, l] = a(n), s = de({ preferHost: !1, counter: 0 });
    return Bn(() => {
      let c = s.current;
      return l((d) => {
        let o = d + 1;
        return c.counter = o, o;
      }), () => {
        l((d) => {
          let o = d - 1;
          return c.counter = o, o || (c.preferHost = !1), o;
        });
      };
    }, [l]), i.__fallback || (s.current.preferHost = !0), !s.current.counter && i.__fallback && s.current.preferHost || s.current.counter > 1 && i.__fallback ? null : m(t, { ...i });
  };
  return r.displayName = e, r;
}, gpe = Object.assign(Zf("MainMenu", ({ children: e, onSelect: t }) => {
  var s;
  let { MainMenuTunnel: n } = Li(), r = ur(), i = Zr(), a = hr(), l = r.editor.isMobile ? void 0 : () => a({ openMenu: null });
  return m(n.In, { children: D(hn, { open: i.openMenu === "canvas", children: [m(hn.Trigger, { onToggle: () => {
    a({ openMenu: i.openMenu === "canvas" ? null : "canvas" });
  }, "data-testid": "main-menu-trigger", className: "main-menu-trigger", children: eA }), D(hn.Content, { onClickOutside: l, onSelect: Jg(t, () => {
    a({ openMenu: null });
  }), children: [e, r.editor.isMobile && i.collaborators.size > 0 && D("fieldset", { className: "UserList-Wrapper", children: [m("legend", { children: N("labels.collaborators") }), m(sP, { mobile: !0, collaborators: i.collaborators, userToFollow: ((s = i.userToFollow) == null ? void 0 : s.socketId) || null })] })] })] }) });
}), { Trigger: hn.Trigger, Item: hn.Item, ItemLink: hn.ItemLink, ItemCustom: hn.ItemCustom, Group: hn.Group, Separator: hn.Separator, DefaultItems: bP }), Qr = gpe, JU = ({ title: e, children: t, actionLabel: n, onClick: r }) => D("div", { className: "OverwriteConfirm__Actions__Action", children: [m("h4", { children: e }), m("div", { className: "OverwriteConfirm__Actions__Action__content", children: t }), m(kh, { variant: "outlined", color: "muted", label: n, size: "large", fullWidth: !0, onClick: r })] }), bpe = () => {
  let { t: e } = Fr(), t = mi(), n = hr();
  return m(JU, { title: e("overwriteConfirm.action.exportToImage.title"), actionLabel: e("overwriteConfirm.action.exportToImage.button"), onClick: () => {
    t.executeAction(ER, "ui", !0), n({ openDialog: { name: "imageExport" } });
  }, children: e("overwriteConfirm.action.exportToImage.description") });
}, Upe = () => {
  let { t: e } = Fr(), t = mi();
  return m(JU, { title: e("overwriteConfirm.action.saveToDisk.title"), actionLabel: e("overwriteConfirm.action.saveToDisk.button"), onClick: () => {
    t.executeAction(SR, "ui");
  }, children: e("overwriteConfirm.action.saveToDisk.description") });
}, i_ = Object.assign(({ children: e }) => m("div", { className: "OverwriteConfirm__Actions", children: e }), { ExportToImage: bpe, SaveToDisk: Upe }), I5 = Object.assign(Zf("OverwriteConfirmDialog", ({ children: e }) => {
  let { OverwriteConfirmDialogTunnel: t } = Li(), [n, r] = Dn(UP);
  if (!n.active) return null;
  let i = () => {
    n.onClose(), r((l) => ({ ...l, active: !1 }));
  }, a = () => {
    n.onConfirm(), r((l) => ({ ...l, active: !1 }));
  };
  return m(t.In, { children: m(Wa, { onCloseRequest: i, title: !1, size: 916, children: D("div", { className: "OverwriteConfirm", children: [m("h3", { children: n.title }), D("div", { className: `OverwriteConfirm__Description OverwriteConfirm__Description--color-${n.color}`, children: [m("div", { className: "OverwriteConfirm__Description__icon", children: OZ }), m("div", { children: n.description }), m("div", { className: "OverwriteConfirm__Description__spacer" }), m(kh, { color: n.color, size: "large", label: n.actionLabel, onClick: a })] }), m(i_, { children: e })] }) }) });
}), { Actions: i_, Action: JU }), vpe = Sr(""), NP = Sr(null), ype = 350, wpe = () => {
  let e = Pl(), t = hr(), n = de(null), [r, i] = Dn(vpe), a = r.trim(), [l, s] = Q(!1), [c, d] = Q({ nonce: null, items: [] }), o = de(null), u = de(void 0), [h, f] = Dn(NP), p = e.scene.getNonDeletedElementsMap();
  Y(() => {
    l || (a !== o.current || e.scene.getSceneNonce() !== u.current) && (o.current = null, a_(a, e, (y, w) => {
      d({ nonce: _l(), items: y }), o.current = a, u.current = e.scene.getSceneNonce(), t({ searchMatches: y.map((x) => ({ id: x.textElement.id, focus: !1, matchedLines: x.matchedLines })) });
    }));
  }, [l, a, p, e, t, f, u]);
  let g = () => {
    c.items.length > 0 && f((y) => y === null ? 0 : (y + 1) % c.items.length);
  }, b = () => {
    c.items.length > 0 && f((y) => y === null ? 0 : y - 1 < 0 ? c.items.length - 1 : y - 1);
  };
  Y(() => {
    t((y) => ({ searchMatches: y.searchMatches.map((w, x) => x === h ? { ...w, focus: !0 } : { ...w, focus: !1 }) }));
  }, [h, t]), Y(() => {
    var y, w, x, E;
    if (c.items.length > 0 && h !== null) {
      let S = c.items[h];
      if (S) {
        let _ = e.state.zoom.value, k = Ai({ text: S.searchQuery, x: S.textElement.x + (((y = S.matchedLines[0]) == null ? void 0 : y.offsetX) ?? 0), y: S.textElement.y + (((w = S.matchedLines[0]) == null ? void 0 : w.offsetY) ?? 0), width: (x = S.matchedLines[0]) == null ? void 0 : x.width, height: (E = S.matchedLines[0]) == null ? void 0 : E.height, fontSize: S.textElement.fontSize, fontFamily: S.textElement.fontFamily }), M = 14, A = S.textElement.fontSize, L = A * _ < M;
        if (!Sp([k], e.canvas.width / window.devicePixelRatio, e.canvas.height / window.devicePixelRatio, { offsetLeft: e.state.offsetLeft, offsetTop: e.state.offsetTop, scrollX: e.state.scrollX, scrollY: e.state.scrollY, zoom: e.state.zoom }, e.scene.getNonDeletedElementsMap(), e.getEditorUIOffsets()) || L) {
          let R;
          L ? A >= M ? R = { fitToContent: !0 } : R = { fitToViewport: !0, maxZoom: vl(M / A, 1) } : R = { fitToContent: !0 }, e.scrollToContent(k, { animate: !0, duration: 300, ...R, canvasOffsets: e.getEditorUIOffsets() });
        }
      }
    }
  }, [h, c, e]), Y(() => () => {
    f(null), o.current = null, u.current = void 0, t({ searchMatches: [] }), s(!1);
  }, [t, f]);
  let v = I2({ goToNextItem: g, goToPreviousItem: b, searchMatches: c });
  Y(() => gn(window, "keydown", (w) => {
    var x, E, S;
    if (w.key === H.ESCAPE && !e.state.openDialog && !e.state.openPopup) {
      w.preventDefault(), w.stopPropagation(), t({ openSidebar: null });
      return;
    }
    w[H.CTRL_OR_CMD] && w.key === H.F && (w.preventDefault(), w.stopPropagation(), (x = n.current) != null && x.matches(":focus") ? t({ openSidebar: null }) : (e.state.openDialog && t({ openDialog: null }), (E = n.current) == null || E.focus(), (S = n.current) == null || S.select())), w.target instanceof HTMLElement && w.target.closest(".layer-ui__search") && v.searchMatches.items.length && (w.key === H.ENTER && (w.stopPropagation(), v.goToNextItem()), w.key === H.ARROW_UP ? (w.stopPropagation(), v.goToPreviousItem()) : w.key === H.ARROW_DOWN && (w.stopPropagation(), v.goToNextItem()));
  }, { capture: !0, passive: !1 }), [t, v, e]);
  let U = `${c.items.length} ${c.items.length === 1 ? N("search.singleResult") : N("search.multipleResults")}`;
  return D("div", { className: "layer-ui__search", children: [m("div", { className: "layer-ui__search-header", children: m(qU, { className: f0.SEARCH_MENU_INPUT_WRAPPER, value: r, ref: n, placeholder: N("search.placeholder"), icon: Kc, onChange: (y) => {
    i(y), s(!0);
    let w = y.trim();
    a_(w, e, (x, E) => {
      d({ nonce: _l(), items: x }), f(E), o.current = w, u.current = e.scene.getSceneNonce(), t({ searchMatches: x.map((S) => ({ id: S.textElement.id, focus: !1, matchedLines: S.matchedLines })) }), s(!1);
    });
  }, selectOnRender: !0 }) }), D("div", { className: "layer-ui__search-count", children: [c.items.length > 0 && D(ge, { children: [h !== null && h > -1 ? D("div", { children: [h + 1, " / ", U] }) : m("div", { children: U }), D("div", { className: "result-nav", children: [m(N0, { onSelect: () => {
    g();
  }, className: "result-nav-btn", children: mA }), m(N0, { onSelect: () => {
    b();
  }, className: "result-nav-btn", children: oJ })] })] }), c.items.length === 0 && a && o.current && m("div", { style: { margin: "1rem auto" }, children: N("search.noMatch") })] }), m(_pe, { matches: c, onItemClick: f, focusIndex: h, searchQuery: a })] });
}, xpe = (e) => {
  let t = [e.preview.moreBefore ? "..." : "", e.preview.previewText.slice(0, e.preview.indexInSearchQuery), e.preview.previewText.slice(e.preview.indexInSearchQuery, e.preview.indexInSearchQuery + e.searchQuery.length), e.preview.previewText.slice(e.preview.indexInSearchQuery + e.searchQuery.length), e.preview.moreAfter ? "..." : ""];
  return m("div", { tabIndex: -1, className: Me("layer-ui__result-item", { active: e.highlighted }), onClick: e.onClick, ref: (n) => {
    e.highlighted && (n == null || n.scrollIntoView({ behavior: "auto", block: "nearest" }));
  }, children: m("div", { className: "preview-text", children: t.flatMap((n, r) => m(lg, { children: r === 2 ? m("b", { children: n }) : n }, r)) }) });
}, Epe = (e) => m("div", { className: "layer-ui__search-result-container", children: e.matches.items.map((t, n) => m(xpe, { searchQuery: e.searchQuery, preview: t.preview, highlighted: n === e.focusIndex, onClick: () => e.onItemClick(n) }, t.textElement.id + t.index)) }), Spe = (e, t) => e.matches.nonce === t.matches.nonce && e.focusIndex === t.focusIndex, _pe = D0(Epe, Spe), kpe = (e, t, n) => {
  let r = e.slice(0, t), i = r.split(/\s+/), a = r.endsWith(" "), l = i.length - 2 - 1 - (a ? 0 : 1), s = i.slice(l <= 0 ? 0 : l).join(" ") + (a ? " " : ""), c = 20;
  s = s.length > c ? s.slice(-c) : s;
  let d = e.slice(t + n.length), o = d.split(/\s+/), u = !d.startsWith(" "), h = u ? 6 : 5, f = (u ? "" : " ") + o.slice(0, h).join(" ");
  return { indexInSearchQuery: s.length, previewText: s + n + f, moreBefore: l > 0, moreAfter: o.length > h };
}, Cpe = (e, t) => {
  let n = e.split(`
`), r = [], i = 0;
  for (let a = 0; a < n.length; a++) {
    let l = n[a], s = n[a + 1];
    if (s) {
      let c = t.indexOf(s, i);
      if (c > l.length + i) {
        let d = c - (l.length + i);
        for (; d > 0; ) l += " ", d--;
      }
    }
    r.push(l), i = i + l.length;
  }
  return r.join(`
`);
}, Mpe = (e, t, n) => {
  let r = Cpe(e.text, e.originalText).split(`
`), i = [], a = 0, l = 0;
  for (let o of r) {
    let u = a, h = u + o.length - 1;
    i.push({ line: o, startIndex: u, endIndex: h, lineNumber: l }), a = h + 1, l++;
  }
  let s = n, c = e.originalText.slice(n, n + t.length), d = [];
  for (let o of i) {
    if (c === "") break;
    if (s >= o.startIndex && s <= o.endIndex) {
      let u = o.endIndex + 1 - s, h = o.line.slice(0, s - o.startIndex), f = c.slice(0, u);
      c = c.slice(u);
      let p = $r(h, Wt(e), e.lineHeight);
      if (h === "" && (p.width = 0), e.textAlign !== "left" && o.line.length > 0) {
        let y = $r(o.line, Wt(e), e.lineHeight), w = e.textAlign === "center" ? (e.width - y.width) / 2 : e.width - y.width;
        p.width += w;
      }
      let { width: g, height: b } = $r(f, Wt(e), e.lineHeight), v = p.width, U = o.lineNumber * p.height;
      d.push({ offsetX: v, offsetY: U, width: g, height: b }), s += u;
    }
  }
  return d;
}, Tpe = (e) => e.replace(/[.*+?^${}()|[\]\\-]/g, "\\$&"), a_ = vue((e, t, n) => {
  if (!e || e === "") {
    n([], null);
    return;
  }
  let r = t.scene.getNonDeletedElements().filter((c) => we(c));
  r.sort((c, d) => c.y - d.y);
  let i = [], a = new RegExp(Tpe(e), "gi");
  for (let c of r) {
    let d = null, o = c.originalText;
    for (; (d = a.exec(o)) !== null; ) {
      let u = kpe(o, d.index, e), h = Mpe(c, e, d.index);
      h.length > 0 && i.push({ textElement: c, searchQuery: e, preview: u, index: d.index, matchedLines: h });
    }
  }
  let l = new Set(t.visibleElements.map((c) => c.id)), s = i.findIndex((c) => l.has(c.textElement.id)) ?? null;
  n(i, s);
}, ype), DP = Zf("DefaultSidebarTrigger", (e) => {
  let { DefaultSidebarTriggerTunnel: t } = Li();
  return m(t.In, { children: m(el.Trigger, { ...e, className: "default-sidebar-trigger", name: Ia.name }) });
});
DP.displayName = "DefaultSidebarTrigger";
var LP = ({ children: e }) => {
  let { DefaultSidebarTabTriggersTunnel: t } = Li();
  return m(t.In, { children: e });
};
LP.displayName = "DefaultTabTriggers";
var l_ = Object.assign(Zf("DefaultSidebar", ({ children: e, className: t, onDock: n, docked: r, ...i }) => {
  var d;
  let a = Zr(), l = hr(), { DefaultSidebarTabTriggersTunnel: s } = Li(), c = ((d = a.openSidebar) == null ? void 0 : d.tab) === Zd;
  return zt(el, { ...i, name: "default", key: "default", className: Me("default-sidebar", t), docked: c || (r ?? a.defaultSidebarDockedPreference), onDock: c || n === !1 || !n && r != null ? void 0 : Jg(n, (o) => {
    l({ defaultSidebarDockedPreference: o });
  }) }, D(el.Tabs, { children: [m(el.Header, { children: D(el.TabTriggers, { children: [m(el.TabTrigger, { tab: Zd, children: Kc }), m(el.TabTrigger, { tab: Um, children: E8 }), m(s.Out, {})] }) }), m(el.Tab, { tab: Um, children: m(r1e, {}) }), m(el.Tab, { tab: Zd, children: m(wpe, {}) }), e] }));
}), { Trigger: DP, TabTriggers: LP }), Ipe = "small", Ape = (e) => D("label", { className: Me("ToolIcon ToolIcon__LaserPointer", `ToolIcon_size_${Ipe}`, { "is-mobile": e.isMobile }), title: `${e.title}`, children: [m("input", { className: "ToolIcon_type_checkbox", type: "checkbox", name: e.name, onChange: e.onChange, checked: e.checked, "aria-label": e.title, "data-testid": "toolbar-LaserPointer" }), m("div", { className: "ToolIcon__icon", children: uA })] }), Npe = ({ canvasRef: e, setError: t }) => {
  let n = e.current;
  if (!n) return;
  let r = n.parentElement;
  r && (r.style.background = "", t(null), n.replaceChildren());
}, RP = async ({ canvasRef: e, mermaidToExcalidrawLib: t, mermaidDefinition: n, setError: r, data: i }) => {
  let a = e.current, l = a == null ? void 0 : a.parentElement;
  if (!(!a || !l)) {
    if (!n) {
      Npe({ canvasRef: e, setError: r });
      return;
    }
    try {
      let s = await t.api, c;
      try {
        c = await s.parseMermaidToExcalidraw(n);
      } catch {
        c = await s.parseMermaidToExcalidraw(n.replace(/"/g, "'"));
      }
      let { elements: d, files: o } = c;
      r(null), i.current = { elements: d3(d, { regenerateIds: !0 }), files: o };
      let u = await lU({ elements: i.current.elements, files: i.current.files, exportPadding: tu, maxWidthOrHeight: Math.max(l.offsetWidth, l.offsetHeight) * window.devicePixelRatio });
      try {
        await sf(u);
      } catch (h) {
        throw h.name === "CANVAS_POSSIBLY_TOO_BIG" ? new Error(N("canvasError.canvasTooBig")) : h;
      }
      l.style.background = "var(--default-bg-color)", a.replaceChildren(u);
    } catch (s) {
      throw l.style.background = "var(--default-bg-color)", n && r(s), s;
    }
  }
}, QU = (e) => {
  Sc.set(fh.MERMAID_TO_EXCALIDRAW, e);
}, PP = ({ app: e, data: t, text: n, shouldSaveMermaidDataToStorage: r }) => {
  let { elements: i, files: a } = t.current;
  i.length && (e.addElementsFromPasteOrLibrary({ elements: i, files: a, position: "center", fitToContent: !0 }), e.setOpenDialog(null), r && n && QU(n));
}, OP = ({ children: e }) => m("div", { className: "ttd-dialog-panels", children: e }), eg = ({ label: e, children: t, panelAction: n, panelActionDisabled: r = !1, onTextSubmitInProgess: i, renderTopRight: a, renderSubmitShortcut: l, renderBottomRight: s }) => D("div", { className: "ttd-dialog-panel", children: [D("div", { className: "ttd-dialog-panel__header", children: [m("label", { children: e }), a == null ? void 0 : a()] }), t, D("div", { className: Me("ttd-dialog-panel-button-container", { invisible: !n }), style: { display: "flex", alignItems: "center" }, children: [D(N0, { className: "ttd-dialog-panel-button", onSelect: n ? n.action : () => {
}, disabled: r || i, children: [D("div", { className: Me({ invisible: i }), children: [n == null ? void 0 : n.label, (n == null ? void 0 : n.icon) && m("span", { children: n.icon })] }), i && m(Cs, {})] }), !r && !i && (l == null ? void 0 : l()), s == null ? void 0 : s()] })] }), $P = ({ input: e, placeholder: t, onChange: n, onKeyboardSubmit: r }) => {
  let i = de(null), a = de(r);
  return a.current = r, Y(() => {
    if (!a.current) return;
    let l = i.current;
    if (l) {
      let s = (c) => {
        var d;
        c[H.CTRL_OR_CMD] && c.key === H.ENTER && (c.preventDefault(), (d = a.current) == null || d.call(a));
      };
      return l.addEventListener("keydown", s), () => {
        l.removeEventListener("keydown", s);
      };
    }
  }, []), m("textarea", { className: "ttd-dialog-input", onChange: n, value: e, placeholder: t, autoFocus: !0, ref: i });
}, Dpe = ({ error: e }) => D("div", { "data-testid": "ttd-dialog-output-error", className: "ttd-dialog-output-error", children: ["Error! ", m("p", { children: e })] }), FP = ({ error: e, canvasRef: t, loaded: n }) => D("div", { className: "ttd-dialog-output-wrapper", children: [e && m(Dpe, { error: e.message }), n ? m("div", { ref: t, style: { opacity: e ? "0.15" : 1 }, className: "ttd-dialog-output-canvas-container" }) : m(Cs, { size: "2rem" })] }), zP = () => D("div", { className: "ttd-dialog-submit-shortcut", children: [m("div", { className: "ttd-dialog-submit-shortcut__key", children: ae("CtrlOrCmd") }), m("div", { className: "ttd-dialog-submit-shortcut__key", children: ae("Enter") })] }), Lpe = `flowchart TD
 A[Christmas] -->|Get money| B(Go shopping)
 B --> C{Let me think}
 C -->|One| D[Laptop]
 C -->|Two| E[iPhone]
 C -->|Three| F[Car]`, s_ = b0(QU, 300), Rpe = ({ mermaidToExcalidrawLib: e }) => {
  let [t, n] = Q(() => Sc.get(fh.MERMAID_TO_EXCALIDRAW) || Lpe), r = IO(t.trim()), [i, a] = Q(null), l = de(null), s = de({ elements: [], files: null }), c = Pl();
  Y(() => {
    RP({ canvasRef: l, data: s, mermaidToExcalidrawLib: e, setError: a, mermaidDefinition: r }).catch((o) => {
      BI() && console.error("Failed to parse mermaid definition", o);
    }), s_(r);
  }, [r, e]), Y(() => () => {
    s_.flush();
  }, []);
  let d = () => {
    PP({ app: c, data: s, text: t, shouldSaveMermaidDataToStorage: !0 });
  };
  return D(ge, { children: [m("div", { className: "ttd-dialog-desc", children: m(bl, { i18nKey: "mermaid.description", flowchartLink: (o) => m("a", { href: "https://mermaid.js.org/syntax/flowchart.html", children: o }), sequenceLink: (o) => m("a", { href: "https://mermaid.js.org/syntax/sequenceDiagram.html", children: o }), classLink: (o) => m("a", { href: "https://mermaid.js.org/syntax/classDiagram.html", children: o }) }) }), D(OP, { children: [m(eg, { label: N("mermaid.syntax"), children: m($P, { input: t, placeholder: "Write Mermaid diagram defintion here...", onChange: (o) => n(o.target.value), onKeyboardSubmit: () => {
    d();
  } }) }), m(eg, { label: N("mermaid.preview"), panelAction: { action: () => {
    d();
  }, label: N("mermaid.button"), icon: mp }, renderSubmitShortcut: () => m(zP, {}), children: m(FP, { canvasRef: l, loaded: e.loaded, error: i }) })] })] });
}, Ppe = Rpe, BP = (e) => {
  let t = hr(), n = de(null), r = de(0);
  return m(GL, { ref: n, className: "ttd-dialog-tabs-root", value: e.tab, onValueChange: (i) => {
    var l;
    if (!i) return;
    let a = (l = n.current) == null ? void 0 : l.closest(".Modal__content");
    if (a) {
      let s = a.offsetHeight || 0;
      s > r.current && (r.current = s, a.style.minHeight = `min(${r.current}px, 100%)`);
    }
    e.dialog === "ttd" && WI(["text-to-diagram", "mermaid"], i) && t({ openDialog: { name: e.dialog, tab: i } });
  }, children: e.children });
};
BP.displayName = "TTDDialogTabs";
var Ope = BP, HP = ({ children: e, ...t }) => m(jL, { className: "ttd-dialog-triggers", ...t, children: e });
HP.displayName = "TTDDialogTabTriggers";
var s3 = ({ children: e, tab: t, onSelect: n, ...r }) => m(KL, { value: t, asChild: !0, onSelect: n, children: m("button", { type: "button", className: "ttd-dialog-tab-trigger", ...r, children: e }) });
s3.displayName = "TTDDialogTabTrigger";
var o3 = ({ tab: e, children: t, ...n }) => m(YL, { ...n, value: e, children: t });
o3.displayName = "TTDDialogTab";
var A5 = 3, Cd = 1e3, $pe = Sr(null), Fpe = Sr(null), zpe = (e) => {
  var n;
  let t = Zr();
  return ((n = t.openDialog) == null ? void 0 : n.name) !== "ttd" ? null : m(Bpe, { ...e, tab: t.openDialog.tab });
}, Bpe = Zf("TTDDialogBase", ({ tab: e, ...t }) => {
  let n = Pl(), r = hr(), i = de(null), [a, l] = Dn(Fpe), [s, c] = Q((a == null ? void 0 : a.prompt) ?? ""), d = s.trim(), o = (E) => {
    c(E.target.value), l((S) => ({ generatedResponse: (S == null ? void 0 : S.generatedResponse) ?? null, prompt: E.target.value }));
  }, [u, h] = Q(!1), [f, p] = Dn($pe), g = async () => {
    if (d.length > Cd || d.length < A5 || u || (f == null ? void 0 : f.rateLimitRemaining) === 0 || "__fallback" in t) {
      d.length < A5 && x(new Error(`Prompt is too short (min ${A5} characters)`)), d.length > Cd && x(new Error(`Prompt is too long (max ${Cd} characters)`));
      return;
    }
    try {
      h(!0), tn("ai", "generate", "ttd");
      let { generatedResponse: E, error: S, rateLimit: _, rateLimitRemaining: k } = await t.onTextSubmit(d);
      if (typeof E == "string" && l((M) => ({ generatedResponse: E, prompt: (M == null ? void 0 : M.prompt) ?? null })), ph(_) && ph(k) && p({ rateLimit: _, rateLimitRemaining: k }), S) {
        x(S);
        return;
      }
      if (!E) {
        x(new Error("Generation failed"));
        return;
      }
      try {
        await RP({ canvasRef: i, data: y, mermaidToExcalidrawLib: v, setError: x, mermaidDefinition: E }), tn("ai", "mermaid parse success", "ttd");
      } catch (M) {
        console.info(`%cTTD mermaid render errror: ${M.message}`, "color: red"), console.info(`>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
TTD mermaid definition render errror: ${M.message}`, "color: yellow"), tn("ai", "mermaid parse failed", "ttd"), x(new Error("Generated an invalid diagram :(. You may also try a different prompt."));
      }
    } catch (E) {
      let S = E.message;
      (!S || S === "Failed to fetch") && (S = "Request failed"), x(new Error(S));
    } finally {
      h(!1);
    }
  }, b = de(g);
  b.current = g;
  let [v, U] = Q({ loaded: !1, api: import("./index-CGAOqTVC.js").then((E) => E.b1) });
  Y(() => {
    (async () => (await v.api, U((E) => ({ ...E, loaded: !0 }))))();
  }, [v.api]);
  let y = de({ elements: [], files: null }), [w, x] = Q(null);
  return m(Wa, { className: "ttd-dialog", onCloseRequest: () => {
    n.setOpenDialog(null);
  }, size: 1200, title: !1, ...t, autofocus: !1, children: D(Ope, { dialog: "ttd", tab: e, children: ["__fallback" in t && t.__fallback ? m("p", { className: "dialog-mermaid-title", children: N("mermaid.title") }) : D(HP, { children: [m(s3, { tab: "text-to-diagram", children: D("div", { style: { display: "flex", alignItems: "center" }, children: [N("labels.textToDiagram"), m("div", { style: { display: "flex", alignItems: "center", justifyContent: "center", padding: "1px 6px", marginLeft: "10px", fontSize: 10, borderRadius: "12px", background: "var(--color-promo)", color: "var(--color-surface-lowest)" }, children: "AI Beta" })] }) }), m(s3, { tab: "mermaid", children: "Mermaid" })] }), m(o3, { className: "ttd-dialog-content", tab: "mermaid", children: m(Ppe, { mermaidToExcalidrawLib: v }) }), !("__fallback" in t) && D(o3, { className: "ttd-dialog-content", tab: "text-to-diagram", children: [m("div", { className: "ttd-dialog-desc", children: "Currently we use Mermaid as a middle step, so you'll get best results if you describe a diagram, workflow, flow chart, and similar." }), D(OP, { children: [m(eg, { label: N("labels.prompt"), panelAction: { action: g, label: "Generate", icon: mp }, onTextSubmitInProgess: u, panelActionDisabled: d.length > Cd || (f == null ? void 0 : f.rateLimitRemaining) === 0, renderTopRight: () => f ? D("div", { className: "ttd-dialog-rate-limit", style: { fontSize: 12, marginLeft: "auto", color: f.rateLimitRemaining === 0 ? "var(--color-danger)" : void 0 }, children: [f.rateLimitRemaining, " requests left today"] }) : null, renderSubmitShortcut: () => m(zP, {}), renderBottomRight: () => {
    if (typeof (a == null ? void 0 : a.generatedResponse) == "string") return D("div", { className: "excalidraw-link", style: { marginLeft: "auto", fontSize: 14 }, onClick: () => {
      typeof (a == null ? void 0 : a.generatedResponse) == "string" && (QU(a.generatedResponse), r({ openDialog: { name: "ttd", tab: "mermaid" } }));
    }, children: ["View as Mermaid", m(N2, { icon: mp })] });
    let E = d.length / Cd;
    return E > 0.8 ? D("div", { style: { marginLeft: "auto", fontSize: 12, fontFamily: "monospace", color: E > 1 ? "var(--color-danger)" : void 0 }, children: ["Length: ", d.length, "/", Cd] }) : null;
  }, children: m($P, { onChange: o, input: s, placeholder: "Describe what you want to see...", onKeyboardSubmit: () => {
    b.current();
  } }) }), m(eg, { label: "Preview", panelAction: { action: () => {
    console.info("Panel action clicked"), PP({ app: n, data: y });
  }, label: "Insert", icon: mp }, children: m(FP, { canvasRef: i, error: w, loaded: v.loaded }) })] })] })] }) });
}), Hpe = 0.01, Ms = (e, t) => !(t === "height" && we(e) || t === "width" && we(e) || t === "angle" && Ve(e)), Lr = (e, t) => {
  let n = e + t / 2;
  return n - n % t;
}, tg = (e, t, n) => Object.keys(e).map((r) => ({ original: (n ?? t).get(r), latest: t.get(r) })).filter((r) => r.original !== void 0 && r.latest !== void 0), ff = (e, t, n, r, i, a, l, s = !0) => {
  let c = r.get(n.id);
  if (!c) return;
  let [d, o] = [n.x + n.width / 2, n.y + n.height / 2], [u, h] = te(T(n.x, n.y), T(d, o), n.angle), f = e - u, p = t - h, [g, b] = te(T(e, t), T(d + f, o + p), -n.angle);
  le(c, { x: g, y: b }, s), c3(c, r, i, a);
  let v = lt(n, l);
  if (v) {
    let U = r.get(v.id);
    U && le(U, { x: v.x + f, y: v.y + p }, s);
  }
}, e9 = (e, t) => {
  let n = wc(t).map((r) => ln(e, r).reduce((i, a) => (i[a.id] = !0, i), {}));
  return e.filter((r) => !E0(r)).forEach((r) => {
    n.push({ [r.id]: !0 });
  }), n;
}, c3 = (e, t, n, r, i) => {
  et(e) ? Nm([e], t, n, r, !0, [], i == null ? void 0 : i.zoom) : ui(e, t, i);
}, Wpe = ({ label: e, icon: t, dragInputCallback: n, value: r, elements: i, editable: a = !0, shouldKeepAspectRatio: l, property: s, scene: c, appState: d, sensitivity: o = 1 }) => {
  let u = Pl(), h = de(null), f = de(null), [p, g] = Q(r.toString()), b = de(null);
  b.current || (b.current = { originalAppState: cs(d), originalElements: i, lastUpdatedValue: p, updatePending: !1 }), Y(() => {
    let y = r.toString();
    g(y), b.current.lastUpdatedValue = y;
  }, [r]);
  let v = (y, w, x) => {
    if (!b.current.updatePending) return !1;
    b.current.updatePending = !1;
    let E = Number(y);
    if (isNaN(E)) {
      g(r.toString());
      return;
    }
    let S = Number(E.toFixed(2)), _ = Number(r);
    (isNaN(_) || Math.abs(S - _) >= Hpe) && (b.current.lastUpdatedValue = y, n({ accumulatedChange: 0, instantChange: 0, originalElements: w, originalElementsMap: u.scene.getNonDeletedElementsMap(), shouldKeepAspectRatio: l, shouldChangeByStepSize: !1, scene: c, nextValue: S, property: s, originalAppState: x, setInputValue: (k) => g(String(k)) }), u.syncActionResult({ captureUpdate: ne.IMMEDIATELY }));
  }, U = de({});
  return U.current.handleInputValue = v, Y(() => {
    let y = h.current, w = U.current;
    return () => {
      var E;
      let x = y == null ? void 0 : y.value;
      x && ((E = w.handleInputValue) == null || E.call(w, x, b.current.originalElements, b.current.originalAppState)), window.removeEventListener("pointermove", w.onPointerMove, !1), window.removeEventListener("pointerup", w.onPointerUp, !1);
    };
  }, [a]), a ? D("div", { className: Me("drag-input-container", !a && "disabled"), "data-testid": e, children: [m("div", { className: "drag-input-label", ref: f, onPointerDown: (y) => {
    if (h.current && a) {
      document.body.classList.add("excalidraw-cursor-resize"), Number(h.current.value);
      let w = null, x = u.scene.getNonDeletedElements().reduce((L, R) => (L.set(R.id, dd(R)), L), /* @__PURE__ */ new Map()), E = i.map((L) => x.get(L.id)), S = cs(d), _ = 0, k = 0, M = (L) => {
        if (w && x !== null && E !== null) {
          let R = L.clientX - w.x;
          R !== 0 && (k += R, Math.abs(k) >= o && (k = Math.sign(k) * Math.floor(Math.abs(k) / o), _ += k, n({ accumulatedChange: _, instantChange: k, originalElements: E, originalElementsMap: x, shouldKeepAspectRatio: l, shouldChangeByStepSize: L.shiftKey, property: s, scene: c, originalAppState: S, setInputValue: (z) => g(String(z)) }), k = 0));
        }
        w = { x: L.clientX, y: L.clientY };
      }, A = () => {
        window.removeEventListener("pointermove", M, !1), u.syncActionResult({ captureUpdate: ne.IMMEDIATELY }), w = null, _ = 0, k = 0, E = null, x = null, document.body.classList.remove("excalidraw-cursor-resize"), window.removeEventListener("pointerup", A, !1);
      };
      U.current.onPointerMove = M, U.current.onPointerUp = A, window.addEventListener("pointermove", M, !1), window.addEventListener("pointerup", A, !1);
    }
  }, onPointerEnter: () => {
    f.current && (f.current.style.cursor = "ew-resize");
  }, children: t ? m(N2, { icon: t }) : e }), m("input", { className: "drag-input", autoComplete: "off", spellCheck: "false", onKeyDown: (y) => {
    if (a) {
      let w = y.target;
      w instanceof HTMLInputElement && y.key === H.ENTER && (v(w.value, i, d), u.focusContainer());
    }
  }, ref: h, value: p, onChange: (y) => {
    b.current.updatePending = !0, g(y.target.value);
  }, onFocus: (y) => {
    y.target.select(), b.current.originalElements = i, b.current.originalAppState = cs(d);
  }, onBlur: (y) => {
    p ? a && v(y.target.value, b.current.originalElements, b.current.originalAppState) : g(r.toString());
  }, disabled: !a })] }) : null;
}, Ds = Wpe, o_ = 10, Xpe = (e) => e.type === "image", Vpe = ({ accumulatedChange: e, originalElements: t, originalElementsMap: n, shouldKeepAspectRatio: r, shouldChangeByStepSize: i, nextValue: a, property: l, originalAppState: s, instantChange: c, scene: d }) => {
  let o = d.getNonDeletedElementsMap(), u = t[0], h = o.get(u.id);
  if (u && h) {
    let f = r || Xpe(u), p = u.width / u.height;
    if (s.croppingElementId === u.id) {
      let y = o.get(u.id);
      if (!y || !Mt(y) || !y.crop) return;
      let w = y.crop, x = { ...w }, E = y.scale[0] === -1, S = y.scale[1] === -1, { width: _, height: k } = vs(y), M = w.naturalWidth / _, A = w.naturalHeight / k, L = E ? w.width + w.x : w.naturalWidth - w.x, R = S ? w.height + w.y : w.naturalHeight - w.y, z = pr * M, F = pr * A;
      if (a !== void 0) {
        if (l === "width") {
          let q = a * M, oe = ft(q, z, L);
          x = { ...x, width: oe, x: E ? w.x + w.width - oe : w.x };
        } else if (l === "height") {
          let q = a * A, oe = ft(q, F, R);
          x = { ...x, height: oe, y: S ? w.y + w.height - oe : w.y };
        }
        le(y, { crop: x, width: x.width / (w.naturalWidth / _), height: x.height / (w.naturalHeight / k) });
        return;
      }
      let W = l === "width" ? c : 0, B = l === "height" ? c : 0, j = ft(w.width + W, z, L), V = ft(w.height + B, z, R);
      x = { ...w, x: E ? w.x + w.width - j : w.x, y: S ? w.y + w.height - V : w.y, width: j, height: V }, le(y, { crop: x, width: x.width / (w.naturalWidth / _), height: x.height / (w.naturalHeight / k) });
      return;
    }
    if (a !== void 0) {
      let y = Math.max(l === "width" ? a : f ? a * p : u.width, $i), w = Math.max(l === "height" ? a : f ? a / p : u.height, $i);
      lf(y, w, h, u, o, n, l === "width" ? "e" : "s", { shouldMaintainAspectRatio: f });
      return;
    }
    let g = l === "width" ? e : 0, b = l === "height" ? e : 0, v = Math.max(0, u.width + g);
    l === "width" && (i ? v = Lr(v, o_) : v = Math.round(v));
    let U = Math.max(0, u.height + b);
    l === "height" && (i ? U = Lr(U, o_) : U = Math.round(U)), f && (l === "width" ? U = Math.round(v / p * 100) / 100 : v = Math.round(U * p * 100) / 100), U = Math.max($i, U), v = Math.max($i, v), lf(v, U, h, u, o, n, l === "width" ? "e" : "s", { shouldMaintainAspectRatio: f });
  }
}, Gpe = ({ property: e, element: t, scene: n, appState: r }) => {
  let i = vl(e === "width" ? t.width : t.height, 2);
  if (r.croppingElementId && r.croppingElementId === t.id && Mt(t) && t.crop) {
    let { width: a, height: l } = vs(t);
    if (e === "width") {
      let s = a / t.crop.naturalWidth;
      i = vl(t.crop.width * s, 2);
    }
    if (e === "height") {
      let s = l / t.crop.naturalHeight;
      i = vl(t.crop.height * s, 2);
    }
  }
  return m(Ds, { label: e === "width" ? "W" : "H", elements: [t], dragInputCallback: Vpe, value: i, editable: Ms(t, e), scene: n, appState: r, property: e });
}, c_ = Gpe, jpe = 15, Kpe = ({ accumulatedChange: e, originalElements: t, shouldChangeByStepSize: n, nextValue: r, scene: i }) => {
  let a = i.getNonDeletedElementsMap(), l = i.getNonDeletedElements(), s = t[0];
  if (s && !Se(s)) {
    let c = a.get(s.id);
    if (!c) return;
    if (r !== void 0) {
      let p = Uc(r);
      le(c, { angle: p }), c3(c, a, l, i);
      let g = lt(c, a);
      g && !dt(c) && le(g, { angle: p });
      return;
    }
    let d = Math.round(zf(s.angle) * 100) / 100, o = Math.round(e), u = (d + o) % 360;
    n && (u = Lr(u, jpe)), u = u < 0 ? u + 360 : u;
    let h = Uc(u);
    le(c, { angle: h }), c3(c, a, l, i);
    let f = lt(c, a);
    f && !dt(c) && le(f, { angle: h });
  }
}, Ype = ({ element: e, scene: t, appState: n, property: r }) => m(Ds, { label: "A", icon: sA, value: Math.round(zf(e.angle) % 360 * 100) / 100, elements: [e], dragInputCallback: Kpe, editable: Ms(e, "angle"), scene: t, appState: n, property: r }), qpe = Ype, d_ = 4, Zpe = 4, Jpe = ({ accumulatedChange: e, originalElements: t, shouldChangeByStepSize: n, nextValue: r, scene: i }) => {
  let a = i.getNonDeletedElementsMap(), l = t[0];
  if (l) {
    let s = a.get(l.id);
    if (!s || !we(s)) return;
    let c;
    if (r !== void 0) c = Math.max(Math.round(r), d_);
    else if (l.type === "text") {
      let d = Math.round(l.fontSize), o = Math.round(e);
      c = Math.max(d + o, d_), n && (c = Lr(c, Zpe));
    }
    c && (le(s, { fontSize: c }), jr(s, i.getContainerElement(s), i.getNonDeletedElementsMap()));
  }
}, Qpe = ({ element: e, scene: t, appState: n, property: r }) => {
  let i = we(e) ? e : ra(e) ? lt(e, t.getNonDeletedElementsMap()) : null;
  return i ? m(Ds, { label: "F", value: Math.round(i.fontSize * 10) / 10, elements: [i], dragInputCallback: Jpe, icon: n2, appState: n, scene: t, property: r }) : null;
}, eme = Qpe, Md = 10, tme = (e, t, n, r) => {
  let i = r.x - e, a = r.y - t, l = r.width * n, s = r.height * n, c = e + i * n, d = t + a * n;
  return { width: l, height: s, x: c, y: d, ...gU(r, l, s, !1), ...we(r) ? { fontSize: r.fontSize * n } : {} };
}, nme = (e, t, n, r, i, a, l, s) => {
  let c = tme(e, t, r, a);
  le(i, c, !1);
  let d = lt(a, s);
  if (d) {
    let o = d.fontSize * r;
    ui(i, l, { newSize: { width: c.width, height: c.height } });
    let u = l.get(d.id);
    u && we(u) && (le(u, { fontSize: o }, !1), Gf(i, l, n === "width" ? "e" : "s", !0));
  }
}, u_ = (e, t, n, r, i, a, l, s, c, d) => {
  a === "width" ? t = Math.round(e / r * 100) / 100 : e = Math.round(t * r * 100) / 100;
  let o = t / n;
  for (let u = 0; u < s.length; u++) {
    let h = s[u], f = l[u];
    nme(i[0], i[1], a, o, f, h, c, d);
  }
}, rme = ({ accumulatedChange: e, originalElements: t, originalElementsMap: n, originalAppState: r, shouldChangeByStepSize: i, nextValue: a, scene: l, property: s }) => {
  let c = l.getNonDeletedElementsMap(), d = e9(t, r);
  if (a !== void 0) {
    for (let h of d) {
      let f = tg(h, c, n);
      if (f.length > 1) {
        let p = f.map((k) => k.latest), g = f.map((k) => k.original), [b, v, U, y] = Lt(g), w = U - b, x = y - v, E = w / x, S = Math.max($i, s === "width" ? Math.max(0, a) : w), _ = Math.max($i, s === "height" ? Math.max(0, a) : x);
        u_(S, _, x, E, T(b, v), s, p, g, c, n);
      } else {
        let [p] = f, g = p == null ? void 0 : p.latest, b = p == null ? void 0 : p.original;
        if (g && b && Ms(g, s)) {
          let v = s === "width" ? Math.max(0, a) : g.width;
          s === "width" && (i ? v = Lr(v, Md) : v = Math.round(v));
          let U = s === "height" ? Math.max(0, a) : g.height;
          s === "height" && (i ? U = Lr(U, Md) : U = Math.round(U)), v = Math.max($i, v), U = Math.max($i, U), lf(v, U, g, b, c, n, s === "width" ? "e" : "s", { shouldInformMutation: !1 });
        }
      }
    }
    l.triggerUpdate();
    return;
  }
  let o = s === "width" ? e : 0, u = s === "height" ? e : 0;
  for (let h of d) {
    let f = tg(h, c, n);
    if (f.length > 1) {
      let p = f.map((k) => k.latest), g = f.map((k) => k.original), [b, v, U, y] = Lt(g), w = U - b, x = y - v, E = w / x, S = Math.max(0, w + o);
      s === "width" && (i ? S = Lr(S, Md) : S = Math.round(S));
      let _ = Math.max(0, x + u);
      s === "height" && (i ? _ = Lr(_, Md) : _ = Math.round(_)), S = Math.max($i, S), _ = Math.max($i, _), u_(S, _, x, E, T(b, v), s, p, g, c, n);
    } else {
      let [p] = f, g = p == null ? void 0 : p.latest, b = p == null ? void 0 : p.original;
      if (g && b && Ms(g, s)) {
        let v = Math.max(0, b.width + o);
        s === "width" && (i ? v = Lr(v, Md) : v = Math.round(v));
        let U = Math.max(0, b.height + u);
        s === "height" && (i ? U = Lr(U, Md) : U = Math.round(U)), v = Math.max($i, v), U = Math.max($i, U), lf(v, U, g, b, c, n, s === "width" ? "e" : "s", { shouldInformMutation: !1 });
      }
    }
  }
  l.triggerUpdate();
}, ime = ({ property: e, elements: t, elementsMap: n, atomicUnits: r, scene: i, appState: a }) => {
  let l = Ke(() => r.map((d) => {
    let o = tg(d, n);
    if (o.length > 1) {
      let [h, f, p, g] = Lt(o.map((b) => b.latest));
      return Math.round((e === "width" ? p - h : g - f) * 100) / 100;
    }
    let [u] = o;
    return Math.round((e === "width" ? u.latest.width : u.latest.height) * 100) / 100;
  }), [n, r, e]), s = new Set(l).size === 1 ? Math.round(l[0] * 100) / 100 : "Mixed", c = l.length > 0;
  return m(Ds, { label: e === "width" ? "W" : "H", elements: t, dragInputCallback: rme, value: s, editable: c, appState: a, property: e, scene: i });
}, h_ = ime, ame = 15, lme = ({ accumulatedChange: e, originalElements: t, shouldChangeByStepSize: n, nextValue: r, property: i, scene: a }) => {
  let l = a.getNonDeletedElementsMap(), s = t.map((d) => l.get(d.id)).filter((d) => d && !E0(d) && Ms(d, i)), c = t.filter((d) => !E0(d) && Ms(d, i));
  if (r !== void 0) {
    let d = Uc(r);
    for (let o of s) {
      if (!o) continue;
      le(o, { angle: d }, !1);
      let u = lt(o, l);
      u && !dt(o) && le(u, { angle: d }, !1);
    }
    a.triggerUpdate();
    return;
  }
  for (let d = 0; d < s.length; d++) {
    let o = s[d];
    if (!o) continue;
    let u = c[d], h = Math.round(zf(u.angle) * 100) / 100, f = Math.round(e), p = (h + f) % 360;
    n && (p = Lr(p, ame)), p = p < 0 ? p + 360 : p;
    let g = Uc(p);
    le(o, { angle: g }, !1);
    let b = lt(o, l);
    b && !dt(o) && le(b, { angle: g }, !1);
  }
  a.triggerUpdate();
}, sme = ({ elements: e, scene: t, appState: n, property: r }) => {
  let i = e.filter((c) => !E0(c) && Ms(c, "angle")), a = i.map((c) => Math.round(zf(c.angle) % 360 * 100) / 100), l = new Set(a).size === 1 ? a[0] : "Mixed", s = i.some((c) => Ms(c, "angle"));
  return m(Ds, { label: "A", icon: sA, value: l, elements: e, dragInputCallback: lme, editable: s, appState: n, scene: t, property: r });
}, ome = sme, f_ = 4, cme = 4, dme = (e, t) => e.reduce((n, r) => {
  if (!r || E0(r)) return n;
  if (we(r)) return n.push(r), n;
  if (ra(r)) {
    let i = lt(r, t);
    if (i) return n.push(i), n;
  }
  return n;
}, []), ume = ({ accumulatedChange: e, originalElements: t, shouldChangeByStepSize: n, nextValue: r, scene: i }) => {
  let a = i.getNonDeletedElementsMap(), l = t.map((c) => a.get(c.id)), s;
  if (r) {
    s = Math.max(Math.round(r), f_);
    for (let c of l) le(c, { fontSize: s }, !1), jr(c, i.getContainerElement(c), a, !1);
    i.triggerUpdate();
  } else {
    let c = t;
    for (let d = 0; d < l.length; d++) {
      let o = l[d], u = c[d], h = Math.round(u.fontSize), f = Math.round(e), p = Math.max(h + f, f_);
      n && (p = Lr(p, cme)), le(o, { fontSize: p }, !1), jr(o, i.getContainerElement(o), a, !1);
    }
    i.triggerUpdate();
  }
}, hme = ({ elements: e, scene: t, appState: n, property: r, elementsMap: i }) => {
  let a = dme(e, i);
  if (!a.length) return null;
  let l = a.map((d) => Math.round(d.fontSize * 10) / 10), s = new Set(l).size === 1 ? l[0] : "Mixed", c = l.length > 0;
  return m(Ds, { label: "F", icon: n2, elements: a, dragInputCallback: ume, value: s, editable: c, scene: t, property: r, appState: n });
}, fme = hme, p_ = 10, pme = ({ accumulatedChange: e, instantChange: t, originalElements: n, originalElementsMap: r, shouldChangeByStepSize: i, nextValue: a, property: l, scene: s, originalAppState: c }) => {
  let d = s.getNonDeletedElementsMap(), o = s.getNonDeletedElements(), u = n[0], [h, f] = [u.x + u.width / 2, u.y + u.height / 2], [p, g] = te(T(u.x, u.y), T(h, f), u.angle);
  if (c.croppingElementId === u.id) {
    let w = d.get(u.id);
    if (!w || !Mt(w) || !w.crop) return;
    let x = w.crop, E = x, S = w.scale[0] === -1, _ = w.scale[1] === -1, { width: k, height: M } = vs(w);
    if (a !== void 0) {
      if (l === "x") {
        let R = a * (x.naturalWidth / k);
        S ? E = { ...x, x: ft(x.naturalWidth - R - x.width, 0, x.naturalWidth - x.width) } : E = { ...x, x: ft(a * (x.naturalWidth / k), 0, x.naturalWidth - x.width) };
      }
      l === "y" && (E = { ...x, y: ft(a * (x.naturalHeight / M), 0, x.naturalHeight - x.height) }), le(w, { crop: E });
      return;
    }
    let A = (l === "x" ? t : 0) * (S ? -1 : 1), L = (l === "y" ? t : 0) * (_ ? -1 : 1);
    E = { ...x, x: ft(x.x + A, 0, x.naturalWidth - x.width), y: ft(x.y + L, 0, x.naturalHeight - x.height) }, le(w, { crop: E });
    return;
  }
  if (a !== void 0) {
    ff(l === "x" ? a : p, l === "y" ? a : g, u, d, o, s, r);
    return;
  }
  let b = l === "x" ? e : 0, v = l === "y" ? e : 0, U = l === "x" ? Math.round(i ? Lr(u.x + b, p_) : p + b) : p, y = l === "y" ? Math.round(i ? Lr(u.y + v, p_) : g + v) : g;
  ff(U, y, u, d, o, s, r);
}, mme = ({ property: e, element: t, elementsMap: n, scene: r, appState: i }) => {
  let [a, l] = te(T(t.x, t.y), T(t.x + t.width / 2, t.y + t.height / 2), t.angle), s = vl(e === "x" ? a : l, 2);
  if (i.croppingElementId === t.id && Mt(t) && t.crop) {
    let c = gre(t);
    c && (s = vl(e === "x" ? c.x : c.y, 2));
  }
  return m(Ds, { label: e === "x" ? "X" : "Y", elements: [t], dragInputCallback: pme, scene: r, value: s, property: e, appState: i });
}, m_ = mme, gme = 10, bme = (e, t, n, r, i, a, l, s) => {
  for (let c = 0; c < r.length; c++) {
    let d = i[c], [o, u] = [d.x + d.width / 2, d.y + d.height / 2], [h, f] = te(T(d.x, d.y), T(o, u), d.angle), p = e === "x" ? Math.round(h + t) : h, g = e === "y" ? Math.round(f + n) : f;
    ff(p, g, d, a, r, s, l, !1);
  }
}, Ume = (e, t, n, r, i, a, l) => {
  let [s, c, ,] = Lt(n), d = e - s, o = t - c;
  for (let u = 0; u < n.length; u++) {
    let h = n[u], f = r.get(h.id);
    if (f && (!we(f) || !f.containerId)) {
      let [p, g] = [f.x + f.width / 2, f.y + f.height / 2], [b, v] = te(T(f.x, f.y), T(p, g), f.angle);
      ff(b + d, v + o, h, r, i, l, a, !1);
    }
  }
}, vme = ({ accumulatedChange: e, originalElements: t, originalElementsMap: n, shouldChangeByStepSize: r, nextValue: i, property: a, scene: l, originalAppState: s }) => {
  var u, h;
  let c = l.getNonDeletedElementsMap(), d = l.getNonDeletedElements();
  if (i !== void 0) {
    for (let f of e9(t, s)) {
      let p = tg(f, c, n);
      if (p.length > 1) {
        let [g, b, ,] = Lt(p.map((v) => v.latest));
        Ume(a === "x" ? i : g, a === "y" ? i : b, p.map((v) => v.original), c, d, n, l);
      } else {
        let g = (u = p[0]) == null ? void 0 : u.original, b = (h = p[0]) == null ? void 0 : h.latest;
        if (g && b && Ms(b, a)) {
          let [v, U] = [g.x + g.width / 2, g.y + g.height / 2], [y, w] = te(T(g.x, g.y), T(v, U), g.angle);
          ff(a === "x" ? i : y, a === "y" ? i : w, g, c, d, l, n, !1);
        }
      }
    }
    l.triggerUpdate();
    return;
  }
  let o = r ? Lr(e, gme) : e;
  bme(a, a === "x" ? o : 0, a === "y" ? o : 0, t, t, c, n, l), l.triggerUpdate();
}, yme = ({ property: e, elements: t, elementsMap: n, atomicUnits: r, scene: i, appState: a }) => {
  let l = Ke(() => r.map((c) => {
    let d = Object.keys(c).map((g) => n.get(g)).filter((g) => g !== void 0);
    if (d.length > 1) {
      let [g, b] = Lt(d);
      return Math.round((e === "x" ? g : b) * 100) / 100;
    }
    let [o] = d, [u, h] = [o.x + o.width / 2, o.y + o.height / 2], [f, p] = te(T(o.x, o.y), T(u, h), o.angle);
    return Math.round((e === "x" ? f : p) * 100) / 100;
  }), [r, n, e]), s = new Set(l).size === 1 ? l[0] : "Mixed";
  return m(Ds, { label: e === "x" ? "X" : "Y", elements: t, dragInputCallback: vme, value: s, property: e, scene: i, appState: a });
}, g_ = yme, b_ = 5, wme = ({ property: e, scene: t, appState: n, setAppState: r }) => m(Ds, { label: "Grid step", sensitivity: 8, elements: [], dragInputCallback: ({ nextValue: i, instantChange: a, shouldChangeByStepSize: l, setInputValue: s }) => {
  r((c) => {
    let d;
    return i ? d = i : a && (d = l ? Lr(c.gridStep + b_ * Math.sign(a), b_) : c.gridStep + a), d ? (d = nN(d), s(d), { gridStep: d }) : (s(c.gridStep), null);
  });
}, scene: t, value: n.gridStep, property: e, appState: n }), xme = wme, Eme = 50, t9 = (e) => {
  let t = e1(), n = e.app.scene.getSceneNonce() || 1, r = e.app.scene.getSelectedElements({ selectedElementIds: t.selectedElementIds, includeBoundTextElement: !1 }), i = nf(e.app);
  return m(Sme, { ...e, appState: t, sceneNonce: n, selectedElements: r, gridModeEnabled: i });
}, rn = ({ children: e, columns: t = 1, heading: n, style: r, ...i }) => m("div", { className: Me("exc-stats__row", { "exc-stats__row--heading": n }), style: { gridTemplateColumns: `repeat(${t}, 1fr)`, ...r }, ...i, children: e });
rn.displayName = "StatsRow";
var ng = ({ children: e, order: t, style: n, ...r }) => m("div", { className: "exc-stats__rows", style: { order: t, ...n }, ...r, children: e });
ng.displayName = "StatsRows";
t9.StatsRow = rn;
t9.StatsRows = ng;
var Sme = D0(({ app: e, onClose: t, renderCustomStats: n, selectedElements: r, appState: i, sceneNonce: a, gridModeEnabled: l }) => {
  let s = e.scene, c = s.getNonDeletedElements(), d = s.getNonDeletedElementsMap(), o = hr(), u = r.length === 1 ? r[0] : null, h = r.length > 1 ? r : null, f = i.croppingElementId && Mt(u), p = f ? vs(u) : null, [g, b] = Q({ width: 0, height: 0 }), v = Ke(() => Of((w) => {
    let x = Lt(w);
    b({ width: Math.round(x[2]) - Math.round(x[0]), height: Math.round(x[3]) - Math.round(x[1]) });
  }, Eme), []);
  Y(() => {
    v(c);
  }, [a, c, v]), Y(() => () => v.cancel(), [v]);
  let U = Ke(() => e9(r, i), [r, i]), y = Ke(() => eD(r), [r]);
  return m("div", { className: "exc-stats", children: D(Da, { padding: 3, children: [D("div", { className: "title", children: [m("h2", { children: N("stats.title") }), m("div", { className: "close", onClick: t, children: iu })] }), D(Z7, { label: m("h3", { children: N("stats.generalStats") }), open: !!(i.stats.panels & Fd.generalStats), openTrigger: () => o((w) => ({ stats: { open: !0, panels: w.stats.panels ^ Fd.generalStats } })), children: [D(ng, { children: [m(rn, { heading: !0, children: N("stats.scene") }), D(rn, { columns: 2, children: [m("div", { children: N("stats.shapes") }), m("div", { children: c.length })] }), D(rn, { columns: 2, children: [m("div", { children: N("stats.width") }), m("div", { children: g.width })] }), D(rn, { columns: 2, children: [m("div", { children: N("stats.height") }), m("div", { children: g.height })] }), l && D(ge, { children: [m(rn, { heading: !0, children: "Canvas" }), m(rn, { children: m(xme, { property: "gridStep", scene: s, appState: i, setAppState: o }) })] })] }), n == null ? void 0 : n(c, i)] }), !y && r.length > 0 && m("div", { id: "elementStats", style: { marginTop: 12 }, children: m(Z7, { label: m("h3", { children: N("stats.elementProperties") }), open: !!(i.stats.panels & Fd.elementProperties), openTrigger: () => o((w) => ({ stats: { open: !0, panels: w.stats.panels ^ Fd.elementProperties } })), children: D(ng, { children: [u && D(ge, { children: [f && m(rn, { heading: !0, children: N("labels.unCroppedDimension") }), i.croppingElementId && Mt(u) && p && D(rn, { columns: 2, children: [m("div", { children: N("stats.width") }), m("div", { children: vl(p.width, 2) })] }), i.croppingElementId && Mt(u) && p && D(rn, { columns: 2, children: [m("div", { children: N("stats.height") }), m("div", { children: vl(p.height, 2) })] }), m(rn, { heading: !0, "data-testid": "stats-element-type", children: i.croppingElementId ? N("labels.imageCropping") : N(`element.${u.type}`) }), m(rn, { children: m(m_, { element: u, property: "x", elementsMap: d, scene: s, appState: i }) }), m(rn, { children: m(m_, { element: u, property: "y", elementsMap: d, scene: s, appState: i }) }), m(rn, { children: m(c_, { property: "width", element: u, scene: s, appState: i }) }), m(rn, { children: m(c_, { property: "height", element: u, scene: s, appState: i }) }), !Se(u) && m(rn, { children: m(qpe, { property: "angle", element: u, scene: s, appState: i }) }), m(rn, { children: m(eme, { property: "fontSize", element: u, scene: s, appState: i }) })] }), h && D(ge, { children: [sN(h) && m(rn, { heading: !0, children: N("element.group") }), D(rn, { columns: 2, style: { margin: "0.3125rem 0" }, children: [m("div", { children: N("stats.shapes") }), m("div", { children: r.length })] }), m(rn, { children: m(g_, { property: "x", elements: h, elementsMap: d, atomicUnits: U, scene: s, appState: i }) }), m(rn, { children: m(g_, { property: "y", elements: h, elementsMap: d, atomicUnits: U, scene: s, appState: i }) }), m(rn, { children: m(h_, { property: "width", elements: h, elementsMap: d, atomicUnits: U, scene: s, appState: i }) }), m(rn, { children: m(h_, { property: "height", elements: h, elementsMap: d, atomicUnits: U, scene: s, appState: i }) }), m(rn, { children: m(ome, { property: "angle", elements: h, scene: s, appState: i }) }), m(rn, { children: m(fme, { property: "fontSize", elements: h, scene: s, appState: i, elementsMap: d }) })] })] }) }) })] }) });
}, (e, t) => e.sceneNonce === t.sceneNonce && e.selectedElements === t.selectedElements && e.appState.stats.panels === t.appState.stats.panels && e.gridModeEnabled === t.gridModeEnabled && e.appState.gridStep === t.appState.gridStep && e.appState.croppingElementId === t.appState.croppingElementId), _me = ({ sourceElementId: e, onClose: t, elementsMap: n, appState: r, generateLinkForSelection: i = LN }) => {
  var u;
  let a = ((u = n.get(e)) == null ? void 0 : u.link) ?? null, [l, s] = Q(a), [c, d] = Q(!1);
  Y(() => {
    let h = ct(n, r), f = a;
    if (h.length > 0 && i) {
      let p = RN(h, r);
      p && (f = _i(i(p.id, p.type)));
    }
    s(f);
  }, [n, r, r.selectedElementIds, a, i]);
  let o = he(() => {
    var h;
    if (l && l !== ((h = n.get(e)) == null ? void 0 : h.link)) {
      let f = n.get(e);
      f && le(f, { link: l });
    }
    if (!l && c && e) {
      let f = n.get(e);
      f && le(f, { link: null });
    }
    t == null || t();
  }, [e, l, n, c, t]);
  return Y(() => {
    let h = (f) => {
      var p, g;
      ((p = r.openDialog) == null ? void 0 : p.name) === "elementLinkSelector" && f.key === H.ENTER && o(), ((g = r.openDialog) == null ? void 0 : g.name) === "elementLinkSelector" && f.key === H.ESCAPE && (t == null || t());
    };
    return window.addEventListener("keydown", h), () => {
      window.removeEventListener("keydown", h);
    };
  }, [r, t, o]), D("div", { className: "ElementLinkDialog", children: [D("div", { className: "ElementLinkDialog__header", children: [m("h2", { children: N("elementLink.title") }), m("p", { children: N("elementLink.desc") })] }), D("div", { className: "ElementLinkDialog__input", children: [m(qU, { value: l ?? "", onChange: (h) => {
    c || d(!0), s(h);
  }, onKeyDown: (h) => {
    h.key === H.ENTER && o();
  }, className: "ElementLinkDialog__input-field", selectOnRender: !0 }), a && l && m(yt, { type: "button", title: N("buttons.remove"), "aria-label": N("buttons.remove"), label: N("buttons.remove"), onClick: () => {
    s(null), d(!0);
  }, className: "ElementLinkDialog__remove", icon: jc })] }), D("div", { className: "ElementLinkDialog__actions", children: [m(A0, { label: N("buttons.cancel"), onClick: () => {
    t == null || t();
  }, style: { marginRight: 10 } }), m(A0, { label: N("buttons.confirm"), onClick: o, actionType: "primary" })] })] });
}, kme = _me, Cme = ({ UIOptions: e }) => D(Qr, { __fallback: !0, children: [m(Qr.DefaultItems.LoadScene, {}), m(Qr.DefaultItems.SaveToActiveFile, {}), e.canvasActions.export && m(Qr.DefaultItems.Export, {}), e.canvasActions.saveAsImage && m(Qr.DefaultItems.SaveAsImage, {}), m(Qr.DefaultItems.SearchMenu, {}), m(Qr.DefaultItems.Help, {}), m(Qr.DefaultItems.ClearCanvas, {}), m(Qr.Separator, {}), m(Qr.Group, { title: "Excalidraw links", children: m(Qr.DefaultItems.Socials, {}) }), m(Qr.Separator, {}), m(Qr.DefaultItems.ToggleTheme, {}), m(Qr.DefaultItems.ChangeCanvasBackground, {})] }), Mme = () => D(I5, { __fallback: !0, children: [m(I5.Actions.SaveToDisk, {}), m(I5.Actions.ExportToImage, {})] }), Tme = ({ actionManager: e, appState: t, files: n, setAppState: r, elements: i, canvas: a, onLockToggle: l, onHandToolToggle: s, onPenModeToggle: c, showExitZenModeBtn: d, renderTopRightUI: o, renderCustomStats: u, UIOptions: h, onExportImage: f, renderWelcomeScreen: p, children: g, app: b, isCollaborating: v, generateLinkForSelection: U }) => {
  var W, B, j;
  let y = ur(), w = m1e(), x = w.tunnelsJotai.Provider, [E, S] = Dn(A2), _ = () => h.canvasActions.export ? m(upe, { elements: i, appState: t, files: n, actionManager: e, exportOpts: h.canvasActions.export, canvas: a, setAppState: r }) : null, k = () => {
    var V;
    return !h.canvasActions.saveAsImage || ((V = t.openDialog) == null ? void 0 : V.name) !== "imageExport" ? null : m(z1e, { elements: i, appState: t, files: n, actionManager: e, onExportImage: f, onCloseRequest: () => r({ openDialog: null }), name: b.getName() });
  }, M = () => D("div", { style: { position: "relative" }, children: [m(w.MainMenuTunnel.Out, {}), p && m(w.WelcomeScreenMenuHintTunnel.Out, {})] }), A = () => m(hf, { heading: "selectedShapeActions", className: Me("selected-shape-actions zen-mode-transition", { "transition-left": t.zenModeEnabled }), children: m(Da, { className: f0.SHAPE_ACTIONS_MENU, padding: 2, style: { maxHeight: `${t.height - 166}px` }, children: m(VR, { appState: t, elementsMap: b.scene.getNonDeletedElementsMap(), renderAction: e.renderAction, app: b }) }) }), L = () => {
    var oe, Ue, fe, Pe, ze;
    let V = UU(t, i), q = t.stats.open && !t.zenModeEnabled && !t.viewModeEnabled && ((oe = t.openDialog) == null ? void 0 : oe.name) !== "elementLinkSelector";
    return m(eP, { side: "top", children: D("div", { className: "App-menu App-menu_top", children: [D(Wi.Col, { gap: 6, className: Me("App-menu_top__left"), children: [M(), V && A()] }), !t.viewModeEnabled && ((Ue = t.openDialog) == null ? void 0 : Ue.name) !== "elementLinkSelector" && m(hf, { heading: "shapes", className: "shapes-section", children: (Oe) => D("div", { style: { position: "relative" }, children: [p && m(w.WelcomeScreenToolbarHintTunnel.Out, {}), m(Wi.Col, { gap: 4, align: "start", children: D(Wi.Row, { gap: 1, className: Me("App-toolbar-container", { "zen-mode": t.zenModeEnabled }), children: [D(Da, { padding: 1, className: Me("App-toolbar", { "zen-mode": t.zenModeEnabled }), children: [m(rP, { appState: t, isMobile: y.editor.isMobile, device: y, app: b }), Oe, D(Wi.Row, { gap: 1, children: [m(aP, { zenModeEnabled: t.zenModeEnabled, checked: t.penMode, onChange: () => c(null), title: N("toolBar.penMode"), penDetected: t.penDetected }), m(iP, { checked: t.activeTool.locked, onChange: l, title: N("toolBar.lock") }), m("div", { className: "App-toolbar__divider" }), m(lP, { checked: m0(t), onChange: () => s(), title: N("toolBar.hand"), isMobile: !0 }), m(GR, { appState: t, activeTool: t.activeTool, UIOptions: h, app: b })] })] }), v && m(Da, { style: { marginLeft: 8, alignSelf: "center", height: "fit-content" }, children: m(Ape, { title: N("toolBar.laser"), checked: t.activeTool.type === lr.laser, onChange: () => b.setActiveTool({ type: lr.laser }), isMobile: !0 }) })] }) })] }) }), D("div", { className: Me("layer-ui__wrapper__top-right zen-mode-transition", { "transition-right": t.zenModeEnabled }), children: [t.collaborators.size > 0 && m(sP, { collaborators: t.collaborators, userToFollow: ((fe = t.userToFollow) == null ? void 0 : fe.socketId) || null }), o == null ? void 0 : o(y.editor.isMobile, t), !t.viewModeEnabled && ((Pe = t.openDialog) == null ? void 0 : Pe.name) !== "elementLinkSelector" && (!z || ((ze = t.openSidebar) == null ? void 0 : ze.name) !== Ia.name) && m(w.DefaultSidebarTriggerTunnel.Out, {}), q && m(t9, { app: b, onClose: () => {
      e.executeAction(t3);
    }, renderCustomStats: u })] })] }) });
  }, R = () => m(l_, { __fallback: !0, onDock: (V) => {
    tn("sidebar", `toggleDock (${V ? "dock" : "undock"})`, `(${y.editor.isMobile ? "mobile" : "desktop"})`);
  } }), z = ZL(ZU), F = D(ge, { children: [g, m(Cme, { UIOptions: h }), m(l_.Trigger, { __fallback: !0, icon: E8, title: gh(N("toolBar.library")), onToggle: (V) => {
    V && tn("sidebar", `${Ia.name} (open)`, `button (${y.editor.isMobile ? "mobile" : "desktop"})`);
  }, tab: Ia.defaultTab, children: N("toolBar.library") }), m(Mme, {}), ((W = t.openDialog) == null ? void 0 : W.name) === "ttd" && m(zpe, { __fallback: !0 }), t.isLoading && m(eR, { delay: 250 }), t.errorMessage && m(L1e, { onClose: () => r({ errorMessage: null }), children: t.errorMessage }), E && !y.editor.isMobile && m(ohe, { colorPickerType: E.colorPickerType, onCancel: () => {
    S(null);
  }, onChange: (V, q, oe, { altKey: Ue }) => {
    var fe;
    if (!(V !== "elementBackground" && V !== "elementStroke")) if (oe.length) {
      for (let Pe of oe) le(Pe, { [Ue && E.swapPreviewOnAlt ? V === "elementBackground" ? "strokeColor" : "backgroundColor" : V === "elementBackground" ? "backgroundColor" : "strokeColor"]: q }, !1), wn.delete(Pe);
      (fe = Es.getScene(oe[0])) == null || fe.triggerUpdate();
    } else r(V === "elementBackground" ? { currentItemBackgroundColor: q } : { currentItemStrokeColor: q });
  }, onSelect: (V, q) => {
    var oe;
    S((Ue) => Ue != null && Ue.keepOpenOnAlt && q.altKey ? Ue : null), (oe = E == null ? void 0 : E.onSelect) == null || oe.call(E, V, q);
  } }), ((B = t.openDialog) == null ? void 0 : B.name) === "help" && m(ape, { onClose: () => {
    r({ openDialog: null });
  } }), m(y1e, {}), ((j = t.openDialog) == null ? void 0 : j.name) === "elementLinkSelector" && m(kme, { sourceElementId: t.openDialog.sourceElementId, onClose: () => {
    r({ openDialog: null });
  }, elementsMap: b.scene.getNonDeletedElementsMap(), appState: t, generateLinkForSelection: U }), m(w.OverwriteConfirmDialogTunnel.Out, {}), k(), _(), t.pasteDialog.shown && m(Q1e, { setAppState: r, appState: t, onClose: () => r({ pasteDialog: { shown: !1, data: null } }) }), y.editor.isMobile && m(J1e, { app: b, appState: t, elements: i, actionManager: e, renderJSONExportDialog: _, renderImageExportDialog: k, setAppState: r, onLockToggle: l, onHandToolToggle: s, onPenModeToggle: c, renderTopRightUI: o, renderCustomStats: u, renderSidebars: R, device: y, renderWelcomeScreen: p, UIOptions: h }), !y.editor.isMobile && D(ge, { children: [D("div", { className: "layer-ui__wrapper", style: t.openSidebar && z && y.editor.canFitSidebar ? { width: "calc(100% - var(--right-sidebar-width))" } : {}, children: [p && m(w.WelcomeScreenCenterTunnel.Out, {}), L(), m(fpe, { appState: t, actionManager: e, showExitZenModeBtn: d, renderWelcomeScreen: p }), t.scrolledOutside && m("button", { type: "button", className: "scroll-back-to-content", onClick: () => {
    r((V) => ({ ...ef(i, V) }));
  }, children: N("buttons.scrollBackToContent") })] }), R()] })] });
  return m(dR.Provider, { value: t, children: m(x, { children: m(HR.Provider, { value: w, children: F }) }) });
}, U_ = (e) => {
  let { suggestedBindings: t, startBoundElement: n, cursorButton: r, scrollX: i, scrollY: a, ...l } = e;
  return l;
}, Ime = (e, t) => {
  if (e.children !== t.children) return !1;
  let { canvas: n, appState: r, ...i } = e, { canvas: a, appState: l, ...s } = t;
  return Tr(U_(r), U_(l), { selectedElementIds: Tr, selectedGroupIds: Tr }) && Tr(i, s);
}, Ame = pe.memo(Tme, Ime), Nme = 5e3, Dme = ({ message: e, onClose: t, closable: n = !1, duration: r = Nme, style: i }) => {
  let a = de(0), l = r !== 1 / 0, s = he(() => {
    l && (a.current = window.setTimeout(() => t(), r));
  }, [t, r, l]);
  return Y(() => {
    if (l) return s(), () => clearTimeout(a.current);
  }, [s, e, r, l]), D("div", { className: "Toast", onMouseEnter: l ? () => clearTimeout(a == null ? void 0 : a.current) : void 0, onMouseLeave: l ? s : void 0, style: i, children: [m("p", { className: "Toast__message", children: e }), n && m(yt, { icon: iu, "aria-label": "close", type: "icon", onClick: t, className: "close" })] });
}, v_ = ve({ name: "viewMode", label: "labels.viewMode", paletteName: "Toggle view mode", icon: M8, viewMode: !0, trackEvent: { category: "canvas", predicate: (e) => !e.viewModeEnabled }, perform(e, t) {
  return { appState: { ...t, viewModeEnabled: !this.checked(t) }, captureUpdate: ne.EVENTUALLY };
}, checked: (e) => e.viewModeEnabled, predicate: (e, t, n) => typeof n.viewModeEnabled > "u", keyTest: (e) => !e[H.CTRL_OR_CMD] && e.altKey && e.code === xt.R }), WP = (e, t) => {
  let n = t.scene.getSelectedElements(e);
  return n.length === 1 && Ve(n[0]);
}, Lme = ve({ name: "selectAllElementsInFrame", label: "labels.selectAllElementsInFrame", trackEvent: { category: "canvas" }, perform: (e, t, n, r) => {
  let i = r.scene.getSelectedElements(t).at(0) || null;
  if (Ve(i)) {
    let a = Ml(Jt(e), i.id).filter((l) => !(l.type === "text" && l.containerId));
    return { elements: e, appState: { ...t, selectedElementIds: a.reduce((l, s) => (l[s.id] = !0, l), {}) }, captureUpdate: ne.IMMEDIATELY };
  }
  return { elements: e, appState: t, captureUpdate: ne.EVENTUALLY };
}, predicate: (e, t, n, r) => WP(t, r) }), Rme = ve({ name: "removeAllElementsFromFrame", label: "labels.removeAllElementsFromFrame", trackEvent: { category: "history" }, perform: (e, t, n, r) => {
  let i = r.scene.getSelectedElements(t).at(0) || null;
  return Ve(i) ? { elements: ZN(e, i), appState: { ...t, selectedElementIds: { [i.id]: !0 } }, captureUpdate: ne.IMMEDIATELY } : { elements: e, appState: t, captureUpdate: ne.EVENTUALLY };
}, predicate: (e, t, n, r) => WP(t, r) });
ve({ name: "updateFrameRendering", label: "labels.updateFrameRendering", viewMode: !0, trackEvent: { category: "canvas" }, perform: (e, t) => ({ elements: e, appState: { ...t, frameRendering: { ...t.frameRendering, enabled: !t.frameRendering.enabled } }, captureUpdate: ne.EVENTUALLY }), checked: (e) => e.frameRendering.enabled });
ve({ name: "setFrameAsActiveTool", label: "toolBar.frame", trackEvent: { category: "toolbar" }, icon: cA, viewMode: !1, perform: (e, t, n, r) => {
  let i = Wn(t, { type: "frame" });
  return Qa(r.interactiveCanvas, { ...t, activeTool: i }), { elements: e, appState: { ...t, activeTool: Wn(t, { type: "frame" }) }, captureUpdate: ne.EVENTUALLY };
}, keyTest: (e) => !e[H.CTRL_OR_CMD] && !e.shiftKey && !e.altKey && e.key.toLocaleLowerCase() === H.F });
var Pme = ve({ name: "wrapSelectionInFrame", label: "labels.wrapSelectionInFrame", trackEvent: { category: "element" }, predicate: (e, t, n, r) => {
  let i = ct(e, t);
  return i.length > 0 && !i.some((a) => Ve(a));
}, perform: (e, t, n, r) => {
  let i = ct(e, t), [a, l, s, c] = Lt(i, r.scene.getNonDeletedElementsMap()), d = 16, o = F8({ x: a - d, y: l - d, width: s - a + d * 2, height: c - l + d * 2 });
  if (t.editingGroupId) {
    let u = ln(i, t.editingGroupId);
    for (let h of u) {
      let f = h.groupIds.indexOf(t.editingGroupId);
      le(h, { groupIds: h.groupIds.slice(0, f) }, !1);
    }
  }
  return { elements: yh([...r.scene.getElementsIncludingDeleted(), o], i, o, t), appState: { selectedElementIds: { [o.id]: !0 } }, captureUpdate: ne.IMMEDIATELY };
} }), Ome = () => D("div", { "data-testid": "brave-measure-text-error", children: [m("p", { children: m(bl, { i18nKey: "errors.brave_measure_text_error.line1", bold: (e) => m("span", { style: { fontWeight: 600 }, children: e }) }) }), m("p", { children: m(bl, { i18nKey: "errors.brave_measure_text_error.line2", bold: (e) => m("span", { style: { fontWeight: 600 }, children: e }) }) }), m("p", { children: m(bl, { i18nKey: "errors.brave_measure_text_error.line3", link: (e) => m("a", { href: "http://docs.excalidraw.com/docs/@excalidraw/excalidraw/faq#turning-off-aggresive-block-fingerprinting-in-brave-browser", children: e }) }) }), m("p", { children: m(bl, { i18nKey: "errors.brave_measure_text_error.line4", issueLink: (e) => m("a", { href: "https://github.com/excalidraw/excalidraw/issues/new", children: e }), discordLink: (e) => D("a", { href: "https://discord.gg/UexuTaE", children: [e, "."] }) }) })] }), $me = Ome, q1 = { width: 100, height: 0 }, lo = 100, Fme = (e, t, n) => {
  let r = Ai({ x: 0, y: 0, textAlign: jh.CENTER, verticalAlign: Si.MIDDLE, ...t, containerId: e.id, strokeColor: t.strokeColor || e.strokeColor });
  return Object.assign(e, { boundElements: (e.boundElements || []).concat({ type: "text", id: r.id }) }), jr(r, e, n), [e, r];
}, y_ = (e, t, n, r, i) => {
  let a, l;
  if (Object.assign(e, { startBinding: (e == null ? void 0 : e.startBinding) || null, endBinding: e.endBinding || null }), t) {
    let o = (t == null ? void 0 : t.width) ?? lo, u = (t == null ? void 0 : t.height) ?? lo, h;
    t.id && (h = r.getElement(t.id), h || console.error(`No element for start binding with id ${t.id} found`));
    let f = t.x || e.x - o, p = t.y || e.y - u / 2, g = h ? h.type : t.type;
    if (g) {
      if (g === "text") {
        let b = "";
        h && h.type === "text" ? b = h.text : t.type === "text" && (b = t.text), b || console.error(`No text found for start binding text element for ${e.id}`), a = Ai({ x: f, y: p, type: "text", ...h, ...t, text: b }), Object.assign(a, { x: t.x || e.x - a.width, y: t.y || e.y - a.height / 2 });
      } else switch (g) {
        case "rectangle":
        case "ellipse":
        case "diamond": {
          a = kl({ x: f, y: p, width: o, height: u, ...h, ...t, type: g });
          break;
        }
        default:
          Vc(e, `Unhandled element start type "${t.type}"`, !0);
      }
      Sl(e, a, "start", i);
    }
  }
  if (n) {
    let o = (n == null ? void 0 : n.height) ?? lo, u = (n == null ? void 0 : n.width) ?? lo, h;
    n.id && (h = r.getElement(n.id), h || console.error(`No element for end binding with id ${n.id} found`));
    let f = n.x || e.x + e.width, p = n.y || e.y - o / 2, g = h ? h.type : n.type;
    if (g) {
      if (g === "text") {
        let b = "";
        h && h.type === "text" ? b = h.text : n.type === "text" && (b = n.text), b || console.error(`No text found for end binding text element for ${e.id}`), l = Ai({ x: f, y: p, type: "text", ...h, ...n, text: b }), Object.assign(l, { y: n.y || e.y - l.height / 2 });
      } else switch (g) {
        case "rectangle":
        case "ellipse":
        case "diamond": {
          l = kl({ x: f, y: p, width: u, height: o, ...h, ...n, type: g });
          break;
        }
        default:
          Vc(e, `Unhandled element end type "${g}"`, !0);
      }
      Sl(e, l, "end", i);
    }
  }
  if (e.points.length < 2) return { linearElement: e, startBoundElement: a, endBoundElement: l };
  let s = e.points.length - 1, c = 0.5, d = cs(e.points);
  return e.points[s][0] > e.points[s - 1][0] && (d[0][0] = c, d[s][0] -= c), e.points[s][0] < e.points[s - 1][0] && (d[0][0] = -c, d[s][0] += c), e.points[s][1] > e.points[s - 1][1] && (d[0][1] = c, d[s][1] -= c), e.points[s][1] < e.points[s - 1][1] && (d[0][1] = -c, d[s][1] += c), Object.assign(e, { points: d }), { linearElement: e, startBoundElement: a, endBoundElement: l };
}, zme = class {
  constructor() {
    $(this, "excalidrawElements", /* @__PURE__ */ new Map()), $(this, "add", (e) => {
      e && this.excalidrawElements.set(e.id, e);
    }), $(this, "getElements", () => xs(Array.from(this.excalidrawElements.values()))), $(this, "getElementsMap", () => ta(Ge(this.getElements()))), $(this, "getElement", (e) => this.excalidrawElements.get(e));
  }
}, d3 = (e, t) => {
  var s, c, d;
  if (!e) return [];
  let n = cs(e), r = new zme(), i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
  for (let o of n) {
    let u, h = o.id;
    switch ((t == null ? void 0 : t.regenerateIds) !== !1 && Object.assign(o, { id: ia() }), o.type) {
      case "rectangle":
      case "ellipse":
      case "diamond": {
        let f = (s = o == null ? void 0 : o.label) != null && s.text && o.width === void 0 ? 0 : (o == null ? void 0 : o.width) || lo, p = (c = o == null ? void 0 : o.label) != null && c.text && o.height === void 0 ? 0 : (o == null ? void 0 : o.height) || lo;
        u = kl({ ...o, width: f, height: p });
        break;
      }
      case "line": {
        let f = o.width || q1.width, p = o.height || q1.height;
        u = xc({ width: f, height: p, points: [T(0, 0), T(f, p)], ...o });
        break;
      }
      case "arrow": {
        let f = o.width || q1.width, p = o.height || q1.height;
        u = z8({ width: f, height: p, endArrowhead: "arrow", points: [T(0, 0), T(f, p)], ...o, type: "arrow" }), Object.assign(u, x0(u.points));
        break;
      }
      case "text": {
        let f = (o == null ? void 0 : o.fontFamily) || Oo, p = (o == null ? void 0 : o.fontSize) || Is, g = (o == null ? void 0 : o.lineHeight) || Yc(f), b = o.text ?? "", v = v0(b), U = $r(v, Wt({ fontFamily: f, fontSize: p }), g);
        u = Ai({ width: U.width, height: U.height, fontFamily: f, fontSize: p, ...o });
        break;
      }
      case "image": {
        u = UN({ width: (o == null ? void 0 : o.width) || lo, height: (o == null ? void 0 : o.height) || lo, ...o });
        break;
      }
      case "frame": {
        u = F8({ x: 0, y: 0, ...o });
        break;
      }
      case "magicframe": {
        u = y7({ x: 0, y: 0, ...o });
        break;
      }
      case "freedraw":
      case "iframe":
      case "embeddable": {
        u = o;
        break;
      }
      default:
        u = o, Vc(o, `Unhandled element type "${o.type}"`, !0);
    }
    r.getElement(u.id) ? console.error(`Duplicate id found for ${u.id}`) : (r.add(u), i.set(u.id, o), h && a.set(h, u.id));
  }
  let l = r.getElementsMap();
  for (let [o, u] of i) {
    let h = r.getElement(o);
    switch (u.type) {
      case "rectangle":
      case "ellipse":
      case "diamond":
      case "arrow": {
        if ((d = u.label) != null && d.text) {
          let [f, p] = Fme(h, u == null ? void 0 : u.label, l);
          if (r.add(f), r.add(p), dt(f)) {
            let g = u.type === "arrow" ? u == null ? void 0 : u.start : void 0, b = u.type === "arrow" ? u == null ? void 0 : u.end : void 0;
            if (g && g.id) {
              let w = a.get(g.id);
              w && Object.assign(g, { id: w });
            }
            if (b && b.id) {
              let w = a.get(b.id);
              w && Object.assign(b, { id: w });
            }
            let { linearElement: v, startBoundElement: U, endBoundElement: y } = y_(f, g, b, r, l);
            f = v, r.add(v), r.add(U), r.add(y);
          }
        } else switch (u.type) {
          case "arrow": {
            let { start: f, end: p } = u;
            if (f && f.id) {
              let U = a.get(f.id);
              Object.assign(f, { id: U });
            }
            if (p && p.id) {
              let U = a.get(p.id);
              Object.assign(p, { id: U });
            }
            let { linearElement: g, startBoundElement: b, endBoundElement: v } = y_(h, f, p, r, l);
            r.add(g), r.add(b), r.add(v);
            break;
          }
        }
        break;
      }
    }
  }
  for (let [o, u] of i) {
    if (u.type !== "frame" && u.type !== "magicframe") continue;
    let h = r.getElement(o);
    if (!h) throw new Error(`Excalidraw element with id ${o} doesn't exist`);
    let f = [];
    u.children.forEach((S) => {
      var M;
      let _ = a.get(S);
      if (!_) throw new Error(`Element with ${S} wasn't mapped correctly`);
      let k = r.getElement(_);
      if (!k) throw new Error(`Frame element with id ${_} doesn't exist`);
      Object.assign(k, { frameId: h.id }), (M = k == null ? void 0 : k.boundElements) == null || M.forEach((A) => {
        let L = r.getElement(A.id);
        if (!L) throw new Error(`Bound element with id ${A.id} doesn't exist`);
        Object.assign(L, { frameId: h.id }), f.push(L);
      }), f.push(k);
    });
    let [p, g, b, v] = Lt(f), U = 10;
    p = p - U, g = g - U, b = b + U, v = v + U;
    let y = (h == null ? void 0 : h.x) || p, w = (h == null ? void 0 : h.y) || g, x = (h == null ? void 0 : h.width) || b - p, E = (h == null ? void 0 : h.height) || v - g;
    Object.assign(h, { x: y, y: w, width: x, height: E }), BI() && u.children.length && (h != null && h.x || h != null && h.y || h != null && h.width || h != null && h.height) && console.info("User provided frame attributes are being considered, if you find this inaccurate, please remove any of the attributes - x, y, width and height so frame coordinates and dimensions are calculated automatically");
  }
  return r.getElements();
}, _n = (e) => (t) => {
  w3(e, t);
}, N5 = (e) => Zg((t) => {
  w3(e, t);
}), n9 = (() => {
  let e;
  try {
    let n = TO.split(".");
    e = Number(n[0]) > 17;
  } catch {
    e = !1;
  }
  let t = !1;
  return () => window.EXCALIDRAW_THROTTLE_RENDER === !0 ? e ? !0 : (t || (t = !0, console.warn("Excalidraw: render throttling is disabled on React versions < 18.")), !1) : !1;
})(), Bme = "#ff6b6b", Hme = "#ff0000", w_ = 1, x_ = 2, Wme = (e, t) => {
  if (!t.snapLines.length) return;
  let n = t.theme === gt.LIGHT || t.zenModeEnabled ? Bme : Hme, r = (t.zenModeEnabled ? w_ * 1.5 : w_) / t.zoom.value;
  e.save(), e.translate(t.scrollX, t.scrollY);
  for (let i of t.snapLines) i.type === "pointer" ? (e.lineWidth = r, e.strokeStyle = n, Vme(i, e, t)) : i.type === "gap" ? (e.lineWidth = r, e.strokeStyle = n, Gme(i.points[0], i.points[1], i.direction, t, e)) : i.type === "points" && (e.lineWidth = r, e.strokeStyle = n, Xme(i, e, t));
  e.restore();
}, Xme = (e, t, n) => {
  if (!n.zenModeEnabled) {
    let r = e.points[0], i = e.points[e.points.length - 1];
    Pi(r, i, t);
  }
  for (let r of e.points) XP(r, n, t);
}, Vme = (e, t, n) => {
  XP(e.points[0], n, t), n.zenModeEnabled || Pi(e.points[0], e.points[1], t);
}, XP = ([e, t], n, r) => {
  r.save();
  let i = (n.zenModeEnabled ? x_ * 1.5 : x_) / n.zoom.value;
  r.beginPath(), r.moveTo(e - i, t - i), r.lineTo(e + i, t + i), r.moveTo(e + i, t - i), r.lineTo(e - i, t + i), r.stroke(), r.restore();
}, Pi = (e, t, n) => {
  n.beginPath(), n.lineTo(e[0], e[1]), n.lineTo(t[0], t[1]), n.stroke();
}, Gme = (e, t, n, r, i) => {
  let a = 8 / r.zoom.value, l = a / 2, s = a / 4;
  if (n === "horizontal") {
    let c = [(e[0] + t[0]) / 2, e[1]];
    r.zenModeEnabled || Pi(T(e[0], e[1] - a), T(e[0], e[1] + a), i), Pi(T(c[0] - s, c[1] - l), T(c[0] - s, c[1] + l), i), Pi(T(c[0] + s, c[1] - l), T(c[0] + s, c[1] + l), i), r.zenModeEnabled || (Pi(T(t[0], t[1] - a), T(t[0], t[1] + a), i), Pi(e, t, i));
  } else {
    let c = [e[0], (e[1] + t[1]) / 2];
    r.zenModeEnabled || Pi(T(e[0] - a, e[1]), T(e[0] + a, e[1]), i), Pi(T(c[0] - l, c[1] - s), T(c[0] + l, c[1] - s), i), Pi(T(c[0] - l, c[1] + s), T(c[0] + l, c[1] + s), i), r.zenModeEnabled || (Pi(T(t[0] - a, t[1]), T(t[0] + a, t[1]), i), Pi(e, t, i));
  }
}, jme = (e, t) => {
  Or(t.selectedLinearElement, "selectedLinearElement is null");
  let { segmentMidPointHoveredCoords: n } = t.selectedLinearElement;
  Or(n, "midPointCoords is null"), e.save(), e.translate(t.scrollX, t.scrollY), VP(n, e, t), e.restore();
}, Kme = (e, t, n) => {
  var s, c;
  let { elementId: r, hoverPointIndex: i } = t.selectedLinearElement;
  if ((c = (s = t.editingLinearElement) == null ? void 0 : s.selectedPointsIndices) != null && c.includes(i)) return;
  let a = Ee.getElement(r, n);
  if (!a) return;
  let l = Ee.getPointAtIndexGlobalCoordinates(a, i, n);
  e.save(), e.translate(t.scrollX, t.scrollY), VP(l, e, t), e.restore();
}, VP = (e, t, n) => {
  t.fillStyle = "rgba(105, 101, 219, 0.4)", m2(t, e[0], e[1], Ee.POINT_HANDLE_SIZE / n.zoom.value, !1);
}, Jf = (e, t, n, r, i, a, l, s, c = !1, d = 0) => {
  e.save(), e.translate(a, l), e.rotate(s), c && e.fillRect(t - a, n - l, r, i), d && e.roundRect ? (e.beginPath(), e.roundRect(t - a, n - l, r, i, d), e.stroke(), e.closePath()) : e.strokeRect(t - a, n - l, r, i), e.restore();
}, Yme = (e, t, n, r, i, a) => {
  e.save(), e.translate(r, i), e.rotate(a), e.beginPath(), e.moveTo(0, n / 2), e.lineTo(t / 2, 0), e.lineTo(0, -n / 2), e.lineTo(-t / 2, 0), e.closePath(), e.stroke(), e.restore();
}, D5 = (e, t, n, r, i, a = !1) => {
  e.strokeStyle = "#5e5ad8", e.setLineDash([]), e.fillStyle = "rgba(255, 255, 255, 0.9)", i ? e.fillStyle = "rgba(134, 131, 226, 0.9)" : a && (e.fillStyle = "rgba(177, 151, 252, 0.7)"), m2(e, n[0], n[1], r / t.zoom.value, !a);
}, qme = (e, t, n, r, i, a) => {
  e.beginPath(), e.ellipse(r, i, t / 2, n / 2, a, 0, Math.PI * 2), e.stroke();
}, Zme = (e, t, n, r) => {
  let [i, a, l, s] = tt(t, n), c = l - i, d = s - a;
  e.strokeStyle = "rgba(0,0,0,.05)";
  let o = r.value < 1 ? r.value : 1;
  e.lineWidth = P8 / o;
  let u = e.lineWidth / 2 + O8, h = Aa(Math.min(t.width, t.height), t);
  switch (t.type) {
    case "rectangle":
    case "text":
    case "image":
    case "iframe":
    case "embeddable":
    case "frame":
    case "magicframe":
      Jf(e, i - u, a - u, c + u * 2, d + u * 2, i + c / 2, a + d / 2, t.angle, void 0, h);
      break;
    case "diamond":
      let f = Math.hypot(c, d), p = u * f / d, g = u * f / c;
      Yme(e, c + p * 2, d + g * 2, i + c / 2, a + d / 2, t.angle);
      break;
    case "ellipse":
      qme(e, c + u * 2, d + u * 2, i + c / 2, a + d / 2, t.angle);
      break;
  }
}, Jme = (e, t, n, r) => {
  let [i, a, l] = t, s = Vf(l, l.width, l.height, r);
  e.strokeStyle = "rgba(0,0,0,0)", e.fillStyle = "rgba(0,0,0,.05)", (a === "both" ? [0, -1] : a === "start" ? [0] : [-1]).forEach((c) => {
    let [d, o] = Ee.getPointAtIndexGlobalCoordinates(i, c, n);
    m2(e, d, o, s);
  });
}, GP = (e, t, n) => {
  let { angle: r, x1: i, y1: a, x2: l, y2: s, selectionColors: c, cx: d, cy: o, dashed: u, activeEmbeddable: h } = n, f = l - i, p = s - a, g = (n.padding ?? Wc * 2) / t.zoom.value, b = 8 / t.zoom.value, v = 4 / t.zoom.value;
  e.save(), e.translate(t.scrollX, t.scrollY), e.lineWidth = (h ? 4 : 1) / t.zoom.value;
  let U = c.length;
  for (let y = 0; y < U; ++y) e.strokeStyle = c[y], u && e.setLineDash([b, v + (b + v) * (U - 1)]), e.lineDashOffset = (b + v) * y, Jf(e, i - g, a - g, f + g * 2, p + g * 2, d, o, r);
  e.restore();
}, Qme = (e, t, n, r) => {
  let i = Array.isArray(n) ? Jme : Zme;
  e.save(), e.translate(t.scrollX, t.scrollY), i(e, n, r, t.zoom), e.restore();
}, ege = (e, t, n, r) => {
  let [i, a, l, s] = tt(n, r), c = l - i, d = s - a;
  e.strokeStyle = "rgb(0,118,255)", e.lineWidth = vn.strokeWidth / t.zoom.value, e.save(), e.translate(t.scrollX, t.scrollY), Jf(e, i, a, c, d, i + c / 2, a + d / 2, n.angle, !1, vn.radius / t.zoom.value), e.restore();
}, tge = (e, t, n) => {
  let r = n.filter((s) => s.groupIds.length === 0), i = n.filter((s) => s.groupIds.length > 0), a = (s) => {
    let [c, d, o, u] = Lt(s);
    return { angle: 0, x1: c, x2: o, y1: d, y2: u, selectionColors: ["rgb(0,118,255)"], dashed: !1, cx: c + (o - c) / 2, cy: d + (u - d) / 2, activeEmbeddable: !1 };
  }, l = (s) => {
    let c = ln(n, s);
    return a(c);
  };
  Object.entries(lN(i, t)).filter(([s, c]) => c).map(([s, c]) => s).map((s) => l(s)).concat(r.map((s) => a([s]))).forEach((s) => GP(e, t, s));
}, L5 = (e, t, n, r) => {
  var s;
  if (!t.selectedLinearElement) return;
  e.save(), e.translate(t.scrollX, t.scrollY), e.lineWidth = 1 / t.zoom.value;
  let i = Ee.getPointsGlobalCoordinates(n, r), { POINT_HANDLE_SIZE: a } = Ee, l = t.editingLinearElement ? a : a / 2;
  if (i.forEach((c, d) => {
    var u, h;
    if (Se(n) && d !== 0 && d !== i.length - 1) return;
    let o = !!((h = (u = t.editingLinearElement) == null ? void 0 : u.selectedPointsIndices) != null && h.includes(d));
    D5(e, t, c, l, o);
  }), Se(n)) {
    let c = ((s = n.fixedSegments) == null ? void 0 : s.map((d) => d.index)) || [];
    i.slice(0, -1).forEach((d, o) => {
      Ee.isSegmentTooShort(n, i[o + 1], i[o], o, t.zoom) || D5(e, t, T((d[0] + i[o + 1][0]) / 2, (d[1] + i[o + 1][1]) / 2), a / 2, !1, !c.includes(o + 1));
    });
  } else Ee.getEditorMidPoints(n, r, t).filter((c, d, o) => c !== null && !(Se(n) && (d === 0 || d === o.length - 1))).forEach((c) => {
    (t.editingLinearElement || i.length === 2) && D5(e, t, c, a / 2, !1, !0);
  });
  e.restore();
}, E_ = (e, t, n, r, i) => {
  Object.keys(r).forEach((a) => {
    let l = r[a];
    if (l !== void 0) {
      let [s, c, d, o] = l;
      e.save(), e.lineWidth = 1 / n.zoom.value, t.selectionColor && (e.strokeStyle = t.selectionColor), a === "rotation" ? m2(e, s + d / 2, c + o / 2, d / 2) : e.roundRect ? (e.beginPath(), e.roundRect(s, c, d, o, 2 / n.zoom.value), e.fill(), e.stroke()) : Jf(e, s, c, d, o, s + d / 2, c + o / 2, i, !0), e.restore();
    }
  });
}, nge = (e, t, n, r, i) => {
  let [a, l, , , s, c] = tt(r, i), d = 3, o = 20, u = d / n.zoom.value, h = u / 2, f = s - a + u, p = c - l + u, g = Math.min(o / n.zoom.value, f), b = Math.min(o / n.zoom.value, p);
  e.save(), e.fillStyle = t.selectionColor, e.strokeStyle = t.selectionColor, e.lineWidth = u, [[[-f, -p], [0, h], [g, h], [h, 0], [h, b]], [[f - h, -p], [h, h], [-g + h, h], [0, 0], [0, b]], [[-f, p], [0, -h], [g, -h], [h, 0], [h, -b]], [[f - h, p], [h, -h], [-g + h, -h], [0, 0], [0, -b]]].forEach((v) => {
    let [[U, y], [w, x], [E, S], [_, k], [M, A]] = v;
    e.save(), e.translate(s, c), e.rotate(r.angle), e.beginPath(), e.moveTo(U + w, y + x), e.lineTo(U + E, y + S), e.stroke(), e.beginPath(), e.moveTo(U + _, y + k), e.lineTo(U + M, y + A), e.stroke(), e.restore();
  }), e.restore();
}, rge = (e, t, n, r) => {
  t.save();
  let i = Wc * 2 / n.zoom.value, a = e.width + i * 2, l = e.height + i * 2, s = e.x + a / 2, c = e.y + l / 2, d = -(a / 2 + i), o = -(l / 2 + i);
  t.translate(s + n.scrollX, c + n.scrollY), t.rotate(e.angle), t.lineWidth = 1 / n.zoom.value, t.strokeStyle = r, t.strokeRect(d, o, a, l), t.restore();
}, jP = ({ canvas: e, elementsMap: t, visibleElements: n, selectedElements: r, allElementsMap: i, scale: a, appState: l, renderConfig: s, device: c }) => {
  var g, b, v;
  if (e === null) return { atLeastOneVisibleElement: !1, elementsMap: t };
  let [d, o] = V8(e, a), u = G8({ canvas: e, scale: a, normalizedWidth: d, normalizedHeight: o });
  u.save(), u.scale(l.zoom.value, l.zoom.value);
  let h;
  if (n.forEach((U) => {
    var y;
    ((y = l.editingLinearElement) == null ? void 0 : y.elementId) === U.id && U && (h = U);
  }), h && L5(u, l, h, t), l.selectionElement && !l.isCropping) try {
    wre(l.selectionElement, u, l, s.selectionColor);
  } catch (U) {
    console.error(U);
  }
  if (l.editingTextElement && we(l.editingTextElement)) {
    let U = i.get(l.editingTextElement.id);
    U && !U.autoResize && rge(U, u, l, s.selectionColor);
  }
  l.isBindingEnabled && l.suggestedBindings.filter((U) => U != null).forEach((U) => {
    Qme(u, l, U, t);
  }), l.frameToHighlight && ege(u, l, l.frameToHighlight, t), l.elementsToHighlight && tge(u, l, l.elementsToHighlight);
  let f = r.some((U) => Ve(U));
  if (r.length === 1 && ((g = l.editingLinearElement) == null ? void 0 : g.elementId) === r[0].id && L5(u, l, r[0], t), Se(r[0]) && l.selectedLinearElement && l.selectedLinearElement.segmentMidPointHoveredCoords ? jme(u, l) : l.selectedLinearElement && l.selectedLinearElement.hoverPointIndex >= 0 && !(Se(r[0]) && l.selectedLinearElement.hoverPointIndex > 0 && l.selectedLinearElement.hoverPointIndex < r[0].points.length - 1) && Kme(u, l, t), !l.multiElement && !l.editingLinearElement) {
    let U = lD(r, l), y = r.length === 1 && et(r[0]);
    y && ((b = l.selectedLinearElement) == null ? void 0 : b.elementId) === r[0].id && !r[0].locked && L5(u, l, r[0], t);
    let w = s.selectionColor || wr.black;
    if (U) {
      let x = Ge(r), E = [];
      for (let _ of t.values()) {
        let k = [], M = s.remoteSelectedElementIds.get(_.id);
        if (y && Se(_) && (_.startBinding || _.endBinding) || (x.has(_.id) && !iN(l, _) && k.push(w), M && k.push(...M.map((A) => P2(A, l.collaborators.get(A))))), k.length) {
          let [A, L, R, z, F, W] = tt(_, t, !0);
          E.push({ angle: _.angle, x1: A, y1: L, x2: R, y2: z, selectionColors: k, dashed: !!M, cx: F, cy: W, activeEmbeddable: ((v = l.activeEmbeddable) == null ? void 0 : v.element) === _ && l.activeEmbeddable.state === "active", padding: _.id === l.croppingElementId || Mt(_) ? 0 : void 0 });
        }
      }
      let S = (_) => {
        let k = ln(t, _), [M, A, L, R] = Lt(k);
        E.push({ angle: 0, x1: M, x2: L, y1: A, y2: R, selectionColors: [wr.black], dashed: !0, cx: M + (L - M) / 2, cy: A + (R - A) / 2, activeEmbeddable: !1 });
      };
      for (let _ of wc(l)) S(_);
      l.editingGroupId && S(l.editingGroupId), E.forEach((_) => GP(u, l, _));
    }
    if (u.save(), u.translate(l.scrollX, l.scrollY), r.length === 1) {
      u.fillStyle = wr.white;
      let x = aD(r[0], l.zoom, t, "mouse", wh(c));
      if (!l.viewModeEnabled && U && !we(l.editingTextElement) && !l.croppingElementId && E_(u, s, l, x, r[0].angle), l.croppingElementId && !l.isCropping) {
        let E = t.get(l.croppingElementId);
        E && Mt(E) && nge(u, s, l, E, t);
      }
    } else if (r.length > 1 && !l.isRotating) {
      let x = Wc * 2 / l.zoom.value;
      u.fillStyle = wr.white;
      let [E, S, _, k] = Lt(r), M = u.getLineDash();
      u.setLineDash([2 / l.zoom.value]);
      let A = u.lineWidth;
      u.lineWidth = 1 / l.zoom.value, u.strokeStyle = w, Jf(u, E - x, S - x, _ - E + x * 2, k - S + x * 2, (E + _) / 2, (S + k) / 2, 0), u.lineWidth = A, u.setLineDash(M);
      let L = mU([E, S, _, k, (E + _) / 2, (S + k) / 2], 0, l.zoom, "mouse", f ? { ...wh(c), rotation: !0 } : wh(c));
      r.some((R) => !R.locked) && E_(u, s, l, L, 0);
    }
    u.restore();
  }
  l.searchMatches.forEach(({ id: U, focus: y, matchedLines: w }) => {
    let x = t.get(U);
    if (x && we(x)) {
      let [E, S, , , _, k] = tt(x, t, !0);
      u.save(), l.theme === gt.LIGHT ? y ? u.fillStyle = "rgba(255, 124, 0, 0.4)" : u.fillStyle = "rgba(255, 226, 0, 0.4)" : y ? u.fillStyle = "rgba(229, 82, 0, 0.4)" : u.fillStyle = "rgba(99, 52, 0, 0.4)", u.translate(l.scrollX, l.scrollY), u.translate(_, k), u.rotate(x.angle), w.forEach((M) => {
        u.fillRect(E + M.offsetX - _, S + M.offsetY - k, M.width, M.height);
      }), u.restore();
    }
  }), Wme(u, l), u.restore(), Whe({ context: u, renderConfig: s, appState: l, normalizedWidth: d, normalizedHeight: o });
  let p;
  return s.renderScrollbars && (p = q1e(n, d, o, l), u.save(), u.fillStyle = Y1e, u.strokeStyle = "rgba(255,255,255,0.8)", [p.horizontal, p.vertical].forEach((U) => {
    U && kR(u, U.x, U.y, U.width, U.height, ao / 2);
  }), u.restore()), { scrollBars: p, atLeastOneVisibleElement: n.length > 0, elementsMap: t };
}, KP = Zg((e) => {
  var n;
  let t = jP(e);
  (n = e.callback) == null || n.call(e, t);
}, { trailing: !0 }), ige = (e, t) => {
  if (t) {
    KP(e);
    return;
  }
  let n = jP(e);
  return e.callback(n), n;
}, age = (e) => {
  let t = de(!1);
  return Y(() => {
    var c;
    if (!t.current) {
      t.current = !0;
      return;
    }
    let n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map();
    e.appState.collaborators.forEach((d, o) => {
      if (d.selectedElementIds) for (let u of Object.keys(d.selectedElementIds)) i.has(u) || i.set(u, []), i.get(u).push(o);
      !d.pointer || d.pointer.renderCursor === !1 || (d.username && a.set(o, d.username), d.userState && l.set(o, d.userState), r.set(o, wa({ sceneX: d.pointer.x, sceneY: d.pointer.y }, e.appState)), n.set(o, d.button));
    });
    let s = ((c = e.containerRef) == null ? void 0 : c.current) && getComputedStyle(e.containerRef.current).getPropertyValue("--color-selection") || "#6965db";
    ige({ canvas: e.canvas, elementsMap: e.elementsMap, visibleElements: e.visibleElements, selectedElements: e.selectedElements, allElementsMap: e.allElementsMap, scale: window.devicePixelRatio, appState: e.appState, renderConfig: { remotePointerViewportCoords: r, remotePointerButton: n, remoteSelectedElementIds: i, remotePointerUsernames: a, remotePointerUserStates: l, selectionColor: s, renderScrollbars: !1 }, device: e.device, callback: e.renderInteractiveSceneCallback }, n9());
  }), m("canvas", { className: "excalidraw__canvas interactive", style: { width: e.appState.width, height: e.appState.height, cursor: e.appState.viewModeEnabled ? Ot.GRAB : Ot.AUTO }, width: e.appState.width * e.scale, height: e.appState.height * e.scale, ref: e.handleCanvasRef, onContextMenu: e.onContextMenu, onPointerMove: e.onPointerMove, onPointerUp: e.onPointerUp, onPointerCancel: e.onPointerCancel, onTouchMove: e.onTouchMove, onPointerDown: e.onPointerDown, onDoubleClick: e.appState.viewModeEnabled ? void 0 : e.onDoubleClick, children: N("labels.drawingCanvas") });
}, S_ = (e) => ({ zoom: e.zoom, scrollX: e.scrollX, scrollY: e.scrollY, width: e.width, height: e.height, viewModeEnabled: e.viewModeEnabled, openDialog: e.openDialog, editingGroupId: e.editingGroupId, editingLinearElement: e.editingLinearElement, selectedElementIds: e.selectedElementIds, frameToHighlight: e.frameToHighlight, offsetLeft: e.offsetLeft, offsetTop: e.offsetTop, theme: e.theme, pendingImageElementId: e.pendingImageElementId, selectionElement: e.selectionElement, selectedGroupIds: e.selectedGroupIds, selectedLinearElement: e.selectedLinearElement, multiElement: e.multiElement, isBindingEnabled: e.isBindingEnabled, suggestedBindings: e.suggestedBindings, isRotating: e.isRotating, elementsToHighlight: e.elementsToHighlight, collaborators: e.collaborators, activeEmbeddable: e.activeEmbeddable, snapLines: e.snapLines, zenModeEnabled: e.zenModeEnabled, editingTextElement: e.editingTextElement, isCropping: e.isCropping, croppingElementId: e.croppingElementId, searchMatches: e.searchMatches }), lge = (e, t) => e.selectionNonce !== t.selectionNonce || e.sceneNonce !== t.sceneNonce || e.scale !== t.scale || e.elementsMap !== t.elementsMap || e.visibleElements !== t.visibleElements || e.selectedElements !== t.selectedElements ? !1 : Tr(S_(e.appState), S_(t.appState)), sge = pe.memo(age, lge), oge = (e) => {
  let t = de(null), n = de(!1);
  return Y(() => {
    let r = t.current;
    if (!r) return;
    let i = e.canvas;
    n.current || (n.current = !0, r.replaceChildren(i), i.classList.add("excalidraw__canvas", "static"));
    let a = `${e.appState.width}px`, l = `${e.appState.height}px`;
    i.style.width !== a && (i.style.width = a), i.style.height !== l && (i.style.height = l);
    let s = e.appState.width * e.scale, c = e.appState.height * e.scale;
    i.width !== s && (i.width = s), i.height !== c && (i.height = c), $N({ canvas: i, rc: e.rc, scale: e.scale, elementsMap: e.elementsMap, allElementsMap: e.allElementsMap, visibleElements: e.visibleElements, appState: e.appState, renderConfig: e.renderConfig }, n9());
  }), m("div", { className: "excalidraw__canvas-wrapper", ref: t });
}, __ = (e) => ({ zoom: e.zoom, scrollX: e.scrollX, scrollY: e.scrollY, width: e.width, height: e.height, viewModeEnabled: e.viewModeEnabled, openDialog: e.openDialog, hoveredElementIds: e.hoveredElementIds, offsetLeft: e.offsetLeft, offsetTop: e.offsetTop, theme: e.theme, pendingImageElementId: e.pendingImageElementId, shouldCacheIgnoreZoom: e.shouldCacheIgnoreZoom, viewBackgroundColor: e.viewBackgroundColor, exportScale: e.exportScale, selectedElementsAreBeingDragged: e.selectedElementsAreBeingDragged, gridSize: e.gridSize, gridStep: e.gridStep, frameRendering: e.frameRendering, selectedElementIds: e.selectedElementIds, frameToHighlight: e.frameToHighlight, editingGroupId: e.editingGroupId, currentHoveredFontFamily: e.currentHoveredFontFamily, croppingElementId: e.croppingElementId }), cge = (e, t) => e.sceneNonce !== t.sceneNonce || e.scale !== t.scale || e.elementsMap !== t.elementsMap || e.visibleElements !== t.visibleElements ? !1 : Tr(__(e.appState), __(t.appState)) && Tr(e.renderConfig, t.renderConfig), dge = pe.memo(oge, cge), k_ = class {
  constructor(e) {
    $(this, "scene"), $(this, "getRenderableElements", (() => {
      let t = ({ elementsMap: r, zoom: i, offsetLeft: a, offsetTop: l, scrollX: s, scrollY: c, height: d, width: o }) => {
        let u = [];
        for (let h of r.values()) Hm(h, o, d, { zoom: i, offsetLeft: a, offsetTop: l, scrollX: s, scrollY: c }, r) && u.push(h);
        return u;
      }, n = ({ elements: r, editingTextElement: i, newElementId: a, pendingImageElementId: l }) => {
        let s = ta(/* @__PURE__ */ new Map());
        for (let c of r) Mt(c) && l === c.id || a !== c.id && (!i || i.type !== "text" || c.id !== i.id) && s.set(c.id, c);
        return s;
      };
      return QY(({ zoom: r, offsetLeft: i, offsetTop: a, scrollX: l, scrollY: s, height: c, width: d, editingTextElement: o, newElementId: u, pendingImageElementId: h, sceneNonce: f }) => {
        let p = this.scene.getNonDeletedElements(), g = n({ elements: p, editingTextElement: o, newElementId: u, pendingImageElementId: h }), b = t({ elementsMap: g, zoom: r, offsetLeft: i, offsetTop: a, scrollX: l, scrollY: s, height: c, width: d });
        return { elementsMap: g, visibleElements: b };
      });
    })()), this.scene = e;
  }
  destroy() {
    KP.cancel(), ON.cancel(), this.getRenderableElements.clear();
  }
}, uge = ({ trails: e }) => {
  let t = de(null);
  return Y(() => {
    if (t.current) for (let n of e) n.start(t.current);
    return () => {
      for (let n of e) n.stop();
    };
  }, e), m("div", { className: "SVGLayer", children: m("svg", { ref: t }) });
}, hge = 5, fge = (e, t, n) => {
  let [r, i] = tt(e, n), { x: a, y: l } = wa({ sceneX: r + e.width, sceneY: i }, t), s = a - t.offsetLeft + 10, c = l - t.offsetTop;
  return { x: s, y: c };
}, C_ = ({ children: e, element: t, elementsMap: n }) => {
  let r = e1();
  if (r.contextMenu || r.newElement || r.resizingElement || r.isRotating || r.openMenu || r.viewModeEnabled) return null;
  let { x: i, y: a } = fge(t, r, n);
  return m("div", { className: "excalidraw-canvas-buttons", style: { top: `${a}px`, left: `${i}px`, padding: hge }, children: e });
}, pge = "small", R5 = (e) => D("label", { className: Me("ToolIcon ToolIcon__MagicButton", `ToolIcon_size_${pge}`, { "is-mobile": e.isMobile }), title: `${e.title}`, children: [m("input", { className: "ToolIcon_type_checkbox", type: "checkbox", name: e.name, onChange: e.onChange, checked: e.checked, "aria-label": e.title }), m("div", { className: "ToolIcon__icon", children: e.icon })] }), mge = ({ height: e, width: t, userToFollow: n, onDisconnect: r }) => m("div", { className: "follow-mode", style: { width: t, height: e }, children: D("div", { className: "follow-mode__badge", children: [D("div", { className: "follow-mode__badge__label", children: ["Following", " ", m("span", { className: "follow-mode__badge__username", title: n.username, children: n.username })] }), m("button", { type: "button", onClick: r, className: "follow-mode__disconnect-btn", children: iu })] }) }), gge = mge, bge = class {
  constructor() {
    $(this, "targets", /* @__PURE__ */ new WeakMap()), $(this, "rafIds", /* @__PURE__ */ new WeakMap());
  }
  register(e, t) {
    this.targets.set(e, { callback: t, stopped: !0 });
  }
  start(e) {
    let t = this.targets.get(e);
    t && (this.rafIds.has(e) || (this.targets.set(e, { ...t, stopped: !1 }), this.scheduleFrame(e)));
  }
  stop(e) {
    let t = this.targets.get(e);
    t && !t.stopped && this.targets.set(e, { ...t, stopped: !0 }), this.cancelFrame(e);
  }
  constructFrame(e) {
    return (t) => {
      let n = this.targets.get(e);
      if (!n) return;
      let r = this.onFrame(n, t);
      !n.stopped && !r ? this.scheduleFrame(e) : this.cancelFrame(e);
    };
  }
  scheduleFrame(e) {
    let t = requestAnimationFrame(this.constructFrame(e));
    this.rafIds.set(e, t);
  }
  cancelFrame(e) {
    if (this.rafIds.has(e)) {
      let t = this.rafIds.get(e);
      cancelAnimationFrame(t);
    }
    this.rafIds.delete(e);
  }
  onFrame(e, t) {
    return e.callback(t) ?? !1;
  }
}, u3 = class {
  constructor(e, t, n) {
    this.animationFrameHandler = e, this.app = t, this.options = n, $(this, "currentTrail"), $(this, "pastTrails", []), $(this, "container"), $(this, "trailElement"), this.animationFrameHandler.register(this, this.onFrame.bind(this)), this.trailElement = document.createElementNS(Et, "path");
  }
  get hasCurrentTrail() {
    return !!this.currentTrail;
  }
  hasLastPoint(e, t) {
    if (this.currentTrail) {
      let n = this.currentTrail.originalPoints.length;
      return this.currentTrail.originalPoints[n - 1][0] === e && this.currentTrail.originalPoints[n - 1][1] === t;
    }
    return !1;
  }
  start(e) {
    e && (this.container = e), this.trailElement.parentNode !== this.container && this.container && this.container.appendChild(this.trailElement), this.animationFrameHandler.start(this);
  }
  stop() {
    var e;
    this.animationFrameHandler.stop(this), this.trailElement.parentNode === this.container && ((e = this.container) == null || e.removeChild(this.trailElement));
  }
  startPath(e, t) {
    this.currentTrail = new qm(this.options), this.currentTrail.addPoint([e, t, performance.now()]), this.update();
  }
  addPointToPath(e, t) {
    this.currentTrail && (this.currentTrail.addPoint([e, t, performance.now()]), this.update());
  }
  endPath() {
    this.currentTrail && (this.currentTrail.close(), this.currentTrail.options.keepHead = !1, this.pastTrails.push(this.currentTrail), this.currentTrail = void 0, this.update());
  }
  update() {
    this.start();
  }
  onFrame() {
    let e = [];
    for (let n of this.pastTrails) e.push(this.drawTrail(n, this.app.state));
    if (this.currentTrail) {
      let n = this.drawTrail(this.currentTrail, this.app.state);
      e.push(n);
    }
    this.pastTrails = this.pastTrails.filter((n) => n.getStrokeOutline().length !== 0), e.length === 0 && this.stop();
    let t = e.join(" ").trim();
    this.trailElement.setAttribute("d", t), this.trailElement.setAttribute("fill", (this.options.fill ?? (() => "black"))(this));
  }
  drawTrail(e, t) {
    let n = e.getStrokeOutline(e.options.size / t.zoom.value).map(([r, i]) => {
      let a = wa({ sceneX: r, sceneY: i }, t);
      return [a.x, a.y];
    });
    return eq(n, !0);
  }
}, Uge = class {
  constructor(e, t) {
    this.animationFrameHandler = e, this.app = t, $(this, "localTrail"), $(this, "collabTrails", /* @__PURE__ */ new Map()), $(this, "container"), this.animationFrameHandler.register(this, this.onFrame.bind(this)), this.localTrail = new u3(e, t, { ...this.getTrailOptions(), fill: () => tY });
  }
  getTrailOptions() {
    return { simplify: 0, streamline: 0.4, sizeMapping: (e) => {
      let t = Math.max(0, 1 - (performance.now() - e.pressure) / 1e3), n = (50 - Math.min(50, e.totalLength - e.currentIndex)) / 50;
      return Math.min(vc(n), vc(t));
    } };
  }
  startPath(e, t) {
    this.localTrail.startPath(e, t);
  }
  addPointToPath(e, t) {
    this.localTrail.addPointToPath(e, t);
  }
  endPath() {
    this.localTrail.endPath();
  }
  start(e) {
    this.container = e, this.animationFrameHandler.start(this), this.localTrail.start(e);
  }
  stop() {
    this.animationFrameHandler.stop(this), this.localTrail.stop();
  }
  onFrame() {
    this.updateCollabTrails();
  }
  updateCollabTrails() {
    if (!(!this.container || this.app.state.collaborators.size === 0)) {
      for (let [e, t] of this.app.state.collaborators.entries()) {
        let n;
        this.collabTrails.has(e) ? n = this.collabTrails.get(e) : (n = new u3(this.animationFrameHandler, this.app, { ...this.getTrailOptions(), fill: () => {
          var r;
          return ((r = t.pointer) == null ? void 0 : r.laserColor) || P2(e, t);
        } }), n.start(this.container), this.collabTrails.set(e, n)), t.pointer && t.pointer.tool === "laser" && (t.button === "down" && !n.hasCurrentTrail && n.startPath(t.pointer.x, t.pointer.y), t.button === "down" && n.hasCurrentTrail && !n.hasLastPoint(t.pointer.x, t.pointer.y) && n.addPointToPath(t.pointer.x, t.pointer.y), t.button === "up" && n.hasCurrentTrail && (n.addPointToPath(t.pointer.x, t.pointer.y), n.endPath()));
      }
      for (let e of this.collabTrails.keys()) this.app.state.collaborators.has(e) || (this.collabTrails.get(e).stop(), this.collabTrails.delete(e));
    }
  }
}, vge = (e, t, n, r, i, a) => {
  let { zoom: l } = r, s = 180 * n / Math.PI, c = e * (l.value - 1) / 2, d = t * (l.value - 1) / 2;
  return e > i && l.value !== 1 && (c = i * (l.value - 1) / 2), t > a && l.value !== 1 && (d = a * (l.value - 1) / 2), `translate(${c}px, ${d}px) scale(${l.value}) rotate(${s}deg)`;
}, yge = ({ id: e, onChange: t, onSubmit: n, getViewportCoords: r, element: i, canvas: a, excalidrawContainer: l, app: s, autoSelect: c = !0 }) => {
  let d = (F, W) => {
    if (!W.style.fontFamily || !W.style.fontSize) return !1;
    let B = W.style.fontFamily.replace(/"/g, "");
    return g0({ fontFamily: F.fontFamily }) !== B || `${F.fontSize}px` !== W.style.fontSize;
  }, o = () => {
    var q;
    let F = s.state, W = (q = Es.getScene(i)) == null ? void 0 : q.getElement(e);
    if (!W) return;
    let { textAlign: B, verticalAlign: j } = W, V = s.scene.getNonDeletedElementsMap();
    if (W && we(W)) {
      let oe = W.x, Ue = W.y, fe = xr(W, s.scene.getNonDeletedElementsMap()), Pe = W.width, ze = W.height, Oe = W.width, Be = W.height;
      if (fe && W.containerId) {
        if (dt(fe)) {
          let Qt = Ee.getBoundTextElementPosition(fe, W, V);
          oe = Qt.x, Ue = Qt.y;
        }
        let Xt = d(W, u), fr;
        if (Xt ? fr = Lm(fe.id, fe.height) : (fr = _0[fe.id], fr || (fr = Lm(fe.id, fe.height))), Oe = ws(fe, W), Be = p2(fe, W), !dt(fe) && ze > Be) {
          let Qt = Zc(ze, fe.type);
          le(fe, { height: Qt });
          return;
        } else if (!dt(fe) && fe.height > fr.height && ze < Be) {
          let Qt = Zc(ze, fe.type);
          le(fe, { height: Qt });
        } else {
          let { y: Qt } = f2(fe, W, V);
          Ue = Qt;
        }
      }
      let [qe, At] = r(oe, Ue), Je = u.selectionStart, mt = u.selectionEnd, jt = u.value.length;
      if (Je === mt && mt !== jt) {
        let Xt = jt - mt;
        u.selectionStart = u.value.length - Xt, u.selectionEnd = u.value.length - Xt;
      }
      fe ? Pe += 0.5 : (Oe = (F.width - 8 - qe) / F.zoom.value, Pe = Math.min(Pe, Oe)), ze *= 1.05;
      let _e = Wt(W), rt = (F.height - At) / F.zoom.value;
      Object.assign(u.style, { font: _e, lineHeight: W.lineHeight, width: `${Pe}px`, height: `${ze}px`, left: `${qe}px`, top: `${At}px`, transform: vge(Pe, ze, Die(W, fe), F, Oe, rt), textAlign: B, verticalAlign: j, color: W.strokeColor, opacity: W.opacity / 100, filter: "var(--theme-filter)", maxHeight: `${rt}px` }), u.scrollTop = 0, bs() && (u.style.fontFamily = g0(W)), le(W, { x: oe, y: Ue });
    }
  }, u = document.createElement("textarea");
  u.dir = "auto", u.tabIndex = 0, u.dataset.type = "wysiwyg", u.wrap = "off", u.classList.add("excalidraw-wysiwyg");
  let h = "pre", f = "normal";
  (sn(i) || !i.autoResize) && (h = "pre-wrap", f = "break-word"), Object.assign(u.style, { position: "absolute", display: "inline-block", minHeight: "1em", backfaceVisibility: "hidden", margin: 0, padding: 0, border: 0, outline: 0, resize: "none", background: "transparent", overflow: "hidden", zIndex: "var(--zIndex-wysiwyg)", wordBreak: f, whiteSpace: h, overflowWrap: "break-word", boxSizing: "content-box" }), u.value = i.originalText, o(), t && (u.onpaste = async (F) => {
    let W = await jN(F, !0);
    if (!W.text) return;
    let B = v0(W.text);
    if (!B) return;
    let j = xr(i, s.scene.getNonDeletedElementsMap()), V = Wt({ fontSize: s.state.currentItemFontSize, fontFamily: s.state.currentItemFontFamily });
    if (j) {
      let q = lt(j, s.scene.getNonDeletedElementsMap()), oe = cd(`${u.value}${B}`, V, ws(j, q)), Ue = w8(oe, V);
      u.style.width = `${Ue}px`;
    }
  }, u.oninput = () => {
    let F = v0(u.value);
    if (u.value !== F) {
      let W = u.selectionStart;
      u.value = F, u.selectionStart = W, u.selectionEnd = W;
    }
    t(u.value);
  }), u.onkeydown = (F) => {
    if (!F.shiftKey && CS.keyTest(F)) F.preventDefault(), s.actionManager.executeAction(CS), o();
    else if (!F.shiftKey && MS.keyTest(F)) F.preventDefault(), s.actionManager.executeAction(MS), o();
    else if (!F.shiftKey && TS.keyTest(F)) F.preventDefault(), s.actionManager.executeAction(TS), o();
    else if (SS.keyTest(F)) s.actionManager.executeAction(SS);
    else if (_S.keyTest(F)) s.actionManager.executeAction(_S);
    else if (F.key === H.ESCAPE) F.preventDefault(), x = !0, E();
    else if (F.key === H.ENTER && F[H.CTRL_OR_CMD]) {
      if (F.preventDefault(), F.isComposing || F.keyCode === 229) return;
      x = !0, E();
    } else if (F.key === H.TAB || F[H.CTRL_OR_CMD] && (F.code === xt.BRACKET_LEFT || F.code === xt.BRACKET_RIGHT)) {
      if (F.preventDefault(), F.isComposing) return;
      F.shiftKey || F.code === xt.BRACKET_LEFT ? U() : v(), u.dispatchEvent(new Event("input"));
    }
  };
  let p = 4, g = " ".repeat(p), b = new RegExp(`^ {1,${p}}`), v = () => {
    let { selectionStart: F, selectionEnd: W } = u, B = y(), j = u.value;
    B.forEach((V) => {
      let q = j.slice(0, V), oe = j.slice(V);
      j = `${q}${g}${oe}`;
    }), u.value = j, u.selectionStart = F + p, u.selectionEnd = W + p * B.length;
  }, U = () => {
    let { selectionStart: F, selectionEnd: W } = u, B = y(), j = [], V = u.value;
    B.forEach((q) => {
      let oe = V.slice(q, q + p).match(b);
      if (oe) {
        let Ue = V.slice(0, q), fe = V.slice(q + oe[0].length);
        V = `${Ue}${fe}`, j.push(q);
      }
    }), u.value = V, j.length && (F > j[j.length - 1] ? u.selectionStart = Math.max(F - p, j[j.length - 1]) : u.selectionStart = F, u.selectionEnd = Math.max(u.selectionStart, W - p * j.length));
  }, y = () => {
    let { selectionStart: F, selectionEnd: W, value: B } = u, j = B.slice(0, F).match(/[^\n]*$/)[0].length;
    return F = F - j, B.slice(F, W).split(`
`).reduce((V, q, oe, Ue) => V.concat(oe ? V[oe - 1] + Ue[oe - 1].length + 1 : F), []).reverse();
  }, w = (F) => {
    F.target instanceof HTMLCanvasElement && (F.preventDefault(), F.stopPropagation());
  }, x = !1, E = () => {
    var B, j;
    if (R) return;
    R = !0, S();
    let F = (B = Es.getScene(i)) == null ? void 0 : B.getElement(i.id);
    if (!F) return;
    let W = xr(F, s.scene.getNonDeletedElementsMap());
    if (W) {
      if (u.value.trim()) {
        let V = ys(W);
        !V || V !== i.id ? le(W, { boundElements: (W.boundElements || []).concat({ type: "text", id: i.id }) }) : dt(W) && v2(W);
      } else le(W, { boundElements: (j = W.boundElements) == null ? void 0 : j.filter((V) => !we(V)) });
      jr(F, W, s.scene.getNonDeletedElementsMap());
    }
    n({ viaKeyboard: x, nextOriginalText: u.value });
  }, S = () => {
    u.onblur = null, u.oninput = null, u.onkeydown = null, z && z.disconnect(), window.removeEventListener("resize", o), window.removeEventListener("wheel", w, !0), window.removeEventListener("pointerdown", M), window.removeEventListener("pointerup", _), window.removeEventListener("blur", E), window.removeEventListener("beforeunload", E), A(), L(), u.remove();
  }, _ = (F) => {
    window.removeEventListener("pointerup", _);
    let W = F == null ? void 0 : F.target, B = W instanceof HTMLElement && W.classList.contains("properties-trigger");
    setTimeout(() => {
      u.onblur = E, B || u.focus();
    });
  }, k = () => {
    u.onblur = null, window.addEventListener("pointerup", _), window.addEventListener("blur", E);
  }, M = (F) => {
    let W = F == null ? void 0 : F.target;
    if (F.button === Vs.WHEEL) {
      W instanceof HTMLTextAreaElement && (F.preventDefault(), s.handleCanvasPanUsingWheelOrSpaceDrag(F)), k();
      return;
    }
    let B = W instanceof HTMLElement && W.classList.contains("properties-trigger");
    (F.target instanceof HTMLElement || F.target instanceof SVGElement) && F.target.closest(`.${f0.SHAPE_ACTIONS_MENU}, .${f0.ZOOM_ACTIONS}`) && !rc(F.target) || B ? k() : F.target instanceof HTMLCanvasElement && !bs() && requestAnimationFrame(() => {
      E();
    });
  }, A = s.scene.onUpdate(() => {
    var F;
    o(), (F = document.activeElement) != null && F.closest(".properties-content") || u.focus();
  }), L = s.onScrollChangeEmitter.on(() => {
    o();
  }), R = !1;
  c && u.select(), _();
  let z = null;
  a && "ResizeObserver" in window ? (z = new window.ResizeObserver(() => {
    o();
  }), z.observe(a)) : window.addEventListener("resize", o), u.onpointerdown = (F) => F.stopPropagation(), requestAnimationFrame(() => {
    window.addEventListener("pointerdown", M, { capture: !0 });
  }), window.addEventListener("beforeunload", E), l == null || l.querySelector(".excalidraw-textEditorContainer").appendChild(u);
}, wge = ve({ name: "autoResize", label: "labels.autoResize", icon: null, trackEvent: { category: "element" }, predicate: (e, t, n, r) => {
  let i = ct(e, t);
  return i.length === 1 && we(i[0]) && !i[0].autoResize;
}, perform: (e, t, n, r) => {
  let i = ct(e, t);
  return { appState: t, elements: e.map((a) => {
    if (a.id === i[0].id && we(a)) {
      let l = $r(a.originalText, Wt(a), a.lineHeight);
      return at(a, { autoResize: !0, width: l.width, height: l.height, text: a.originalText });
    }
    return a;
  }), captureUpdate: ne.IMMEDIATELY };
} }), xge = (e) => {
  let t = ["flowchart", "graph", "sequenceDiagram", "classDiagram", "stateDiagram", "stateDiagram-v2", "erDiagram", "journey", "gantt", "pie", "quadrantChart", "requirementDiagram", "gitGraph", "C4Context", "mindmap", "timeline", "zenuml", "sankey", "xychart", "block"];
  return new RegExp(`^(?:%%{.*?}%%[\\s\\n]*)?\\b(?:${t.map((n) => `\\s*${n}(-beta)?`).join("|")})\\b`).test(e.trim());
}, YP = ({ canvas: e, rc: t, newElement: n, elementsMap: r, allElementsMap: i, scale: a, appState: l, renderConfig: s }) => {
  if (e) {
    let [c, d] = V8(e, a), o = G8({ canvas: e, scale: a, normalizedWidth: c, normalizedHeight: d });
    o.save(), o.scale(l.zoom.value, l.zoom.value), n && n.type !== "selection" ? tc(n, r, i, t, o, s, l) : o.clearRect(0, 0, c, d);
  }
}, Ege = Zg((e) => {
  YP(e);
}, { trailing: !0 }), Sge = (e, t) => {
  if (t) {
    Ege(e);
    return;
  }
  YP(e);
}, _ge = (e) => {
  let t = de(null);
  return Y(() => {
    t.current && Sge({ canvas: t.current, scale: e.scale, newElement: e.appState.newElement, elementsMap: e.elementsMap, allElementsMap: e.allElementsMap, rc: e.rc, renderConfig: e.renderConfig, appState: e.appState }, n9());
  }), m("canvas", { className: "excalidraw__canvas", style: { width: e.appState.width, height: e.appState.height }, width: e.appState.width * e.scale, height: e.appState.height * e.scale, ref: t });
}, kge = _ge, qP = pe.createContext(null), ZP = pe.createContext(null), JP = { viewport: { isMobile: !1, isLandscape: !1 }, editor: { isMobile: !1, canFitSidebar: !1 }, isTouchScreen: !1 }, r9 = pe.createContext(JP);
r9.displayName = "DeviceContext";
var i9 = pe.createContext({ container: null, id: null });
i9.displayName = "ExcalidrawContainerContext";
var a9 = pe.createContext([]);
a9.displayName = "ExcalidrawElementsContext";
var l9 = pe.createContext({ ...El(), width: 0, height: 0, offsetLeft: 0, offsetTop: 0 });
l9.displayName = "ExcalidrawAppStateContext";
var s9 = pe.createContext(() => {
  console.warn("Uninitialized ExcalidrawSetAppStateContext context!");
});
s9.displayName = "ExcalidrawSetAppStateContext";
var o9 = pe.createContext(null);
o9.displayName = "ExcalidrawActionManagerContext";
var Pl = () => Er(qP), Qf = () => Er(ZP), ur = () => Er(r9), Ol = () => Er(i9), $2 = () => Er(a9), e1 = () => Er(l9), hr = () => Er(s9), mi = () => Er(o9), Iu = !1, P5 = 0, Ko = !1, Au = !1, O5 = !1, $5 = { horizontal: null, vertical: null }, Hs = 0, Nu = !1, F5 = /* @__PURE__ */ new Map(), Z1 = !1, M_ = 0, T_ = !1, Yo = null, _t = { pointers: /* @__PURE__ */ new Map(), lastCenter: null, initialDistance: null, initialScale: null }, Cge = class QP extends pe.Component {
  constructor(t) {
    super(t), $(this, "canvas"), $(this, "interactiveCanvas", null), $(this, "rc"), $(this, "unmounted", !1), $(this, "actionManager"), $(this, "device", JP), $(this, "excalidrawContainerRef", pe.createRef()), $(this, "scene"), $(this, "fonts"), $(this, "renderer"), $(this, "visibleElements"), $(this, "resizeObserver"), $(this, "nearestScrollableContainer"), $(this, "library"), $(this, "libraryItemsFromStorage"), $(this, "id"), $(this, "store"), $(this, "history"), $(this, "excalidrawContainerValue"), $(this, "files", {}), $(this, "imageCache", /* @__PURE__ */ new Map()), $(this, "iFrameRefs", /* @__PURE__ */ new Map()), $(this, "embedsValidationStatus", /* @__PURE__ */ new Map()), $(this, "initializedEmbeds", /* @__PURE__ */ new Set()), $(this, "elementsPendingErasure", /* @__PURE__ */ new Set()), $(this, "flowChartCreator", new V1e()), $(this, "flowChartNavigator", new X1e()), $(this, "hitLinkElement"), $(this, "lastPointerDownEvent", null), $(this, "lastPointerUpEvent", null), $(this, "lastPointerMoveEvent", null), $(this, "lastPointerMoveCoords", null), $(this, "lastViewportPosition", { x: 0, y: 0 }), $(this, "animationFrameHandler", new bge()), $(this, "laserTrails", new Uge(this.animationFrameHandler, this)), $(this, "eraserTrail", new u3(this.animationFrameHandler, this, { streamline: 0.2, size: 5, keepHead: !0, sizeMapping: (o) => {
      let u = Math.max(0, 1 - (performance.now() - o.pressure) / 200), h = (10 - Math.min(10, o.totalLength - o.currentIndex)) / 10;
      return Math.min(vc(h), vc(u));
    }, fill: () => this.state.theme === gt.LIGHT ? "rgba(0, 0, 0, 0.2)" : "rgba(255, 255, 255, 0.2)" })), $(this, "onChangeEmitter", new nl()), $(this, "onPointerDownEmitter", new nl()), $(this, "onPointerUpEmitter", new nl()), $(this, "onUserFollowEmitter", new nl()), $(this, "onScrollChangeEmitter", new nl()), $(this, "missingPointerEventCleanupEmitter", new nl()), $(this, "onRemoveEventListenersEmitter", new nl()), $(this, "getEffectiveGridSize", () => nf(this) ? this.state.gridSize : null), $(this, "updateEmbedValidationStatus", (o, u) => {
      this.embedsValidationStatus.set(o.id, u), wn.delete(o);
    }), $(this, "updateEmbeddables", () => {
      let o = /* @__PURE__ */ new Set(), u = !1;
      this.scene.getNonDeletedElements().filter((h) => {
        if (ri(h)) {
          if (o.add(h.id), !this.embedsValidationStatus.has(h.id)) {
            u = !0;
            let f = yp(h.link, this.props.validateEmbeddable);
            this.updateEmbedValidationStatus(h, f);
          }
        } else qs(h) && o.add(h.id);
        return !1;
      }), u && this.scene.triggerUpdate(), this.iFrameRefs.forEach((h, f) => {
        o.has(f) || this.iFrameRefs.delete(f);
      });
    }), $(this, "getFrameNameDOMId", (o) => `${this.id}-frame-name-${o.id}`), $(this, "frameNameBoundsCache", { get: (o) => {
      let u = this.frameNameBoundsCache._cache.get(o.id);
      if (!u || u.zoom !== this.state.zoom.value || u.versionNonce !== o.versionNonce) {
        let h = document.getElementById(this.getFrameNameDOMId(o));
        if (h) {
          let f = h.getBoundingClientRect(), p = en({ clientX: f.x, clientY: f.y }, this.state), g = en({ clientX: f.right, clientY: f.bottom }, this.state);
          return u = { x: p.x, y: p.y, width: g.x - p.x, height: g.y - p.y, angle: 0, zoom: this.state.zoom.value, versionNonce: o.versionNonce }, this.frameNameBoundsCache._cache.set(o.id, u), u;
        }
        return null;
      }
      return u;
    }, _cache: /* @__PURE__ */ new Map() }), $(this, "resetEditingFrame", (o) => {
      var u;
      o && le(o, { name: ((u = o.name) == null ? void 0 : u.trim()) || null }), this.setState({ editingFrame: null });
    }), $(this, "renderFrameNames", () => {
      if (!this.state.frameRendering.enabled || !this.state.frameRendering.name) return this.state.editingFrame && this.resetEditingFrame(null), null;
      let o = this.state.theme === gt.DARK;
      return this.scene.getNonDeletedFramesLikes().map((u) => {
        if (!Hm(u, this.canvas.width / window.devicePixelRatio, this.canvas.height / window.devicePixelRatio, { offsetLeft: this.state.offsetLeft, offsetTop: this.state.offsetTop, scrollX: this.state.scrollX, scrollY: this.state.scrollY, zoom: this.state.zoom }, this.scene.getNonDeletedElementsMap())) return this.state.editingFrame === u.id && this.resetEditingFrame(u), null;
        let { x: h, y: f } = wa({ sceneX: u.x, sceneY: u.y }, this.state), p = 6, g, b = QN(u);
        if (u.id === this.state.editingFrame) {
          let v = b;
          g = m("input", { autoFocus: !0, value: v, onChange: (U) => {
            le(u, { name: U.target.value });
          }, onFocus: (U) => U.target.select(), onBlur: () => this.resetEditingFrame(u), onKeyDown: (U) => {
            (U.key === H.ESCAPE || U.key === H.ENTER) && this.resetEditingFrame(u);
          }, style: { background: this.state.viewBackgroundColor, filter: o ? p8 : "none", zIndex: 2, border: "none", display: "block", padding: `${p}px`, borderRadius: 4, boxShadow: "inset 0 0 0 1px var(--color-primary)", fontFamily: "Assistant", fontSize: "14px", transform: `translate(-${p}px, ${p}px)`, color: "var(--color-gray-80)", overflow: "hidden", maxWidth: `${document.body.clientWidth - h - p}px` }, size: v.length + 1 || 1, dir: "auto", autoComplete: "off", autoCapitalize: "off", autoCorrect: "off" });
        } else g = b;
        return m("div", { id: this.getFrameNameDOMId(u), style: { position: "absolute", bottom: `${this.state.height + vn.nameOffsetY - f + this.state.offsetTop}px`, left: `${h - this.state.offsetLeft}px`, zIndex: 2, fontSize: vn.nameFontSize, color: o ? vn.nameColorDarkTheme : vn.nameColorLightTheme, lineHeight: vn.nameLineHeight, width: "max-content", maxWidth: `${u.width}px`, overflow: u.id === this.state.editingFrame ? "visible" : "hidden", whiteSpace: "nowrap", textOverflow: "ellipsis", cursor: Ot.MOVE, pointerEvents: this.state.viewModeEnabled ? yd.disabled : yd.enabled }, onPointerDown: (v) => this.handleCanvasPointerDown(v), onWheel: (v) => this.handleWheel(v), onContextMenu: this.handleCanvasContextMenu, onDoubleClick: () => {
          this.setState({ editingFrame: u.id });
        }, children: g }, u.id);
      });
    }), $(this, "focusContainer", () => {
      var o;
      (o = this.excalidrawContainerRef.current) == null || o.focus();
    }), $(this, "getSceneElementsIncludingDeleted", () => this.scene.getElementsIncludingDeleted()), $(this, "getSceneElements", () => this.scene.getNonDeletedElements()), $(this, "onInsertElements", (o) => {
      this.addElementsFromPasteOrLibrary({ elements: o, position: "center", files: null });
    }), $(this, "onExportImage", async (o, u, h) => {
      tn("export", o, "ui");
      let f = await R2(o, u, this.state, this.files, { exportBackground: this.state.exportBackground, name: this.getName(), viewBackgroundColor: this.state.viewBackgroundColor, exportingFrame: h.exportingFrame }).catch(FI).catch((p) => {
        console.error(p), this.setState({ errorMessage: p.message });
      });
      this.state.exportEmbedScene && f && vU(f) && this.setState({ fileHandle: f });
    }), $(this, "magicGenerations", /* @__PURE__ */ new Map()), $(this, "updateMagicGeneration", ({ frameElement: o, data: u }) => {
      u.status === "pending" ? le(o, { customData: { generationData: void 0 } }, !1) : le(o, { customData: { generationData: u } }, !1), this.magicGenerations.set(o.id, u), this.triggerRender();
    }), $(this, "plugins", {}), $(this, "onMagicframeToolSelect", () => {
      let o = this.scene.getSelectedElements({ selectedElementIds: this.state.selectedElementIds });
      if (o.length === 0) this.setActiveTool({ type: lr.magicframe }), tn("ai", "tool-select (empty-selection)", "d2c");
      else {
        let u = o.length === 1 && pp(o[0]) && o[0];
        if (!u && o.some((f) => Ve(f) || f.frameId)) {
          this.setActiveTool({ type: lr.magicframe });
          return;
        }
        tn("ai", "tool-select (existing selection)", "d2c");
        let h;
        if (u) h = u;
        else {
          let [f, p, g, b] = Lt(o), v = 50;
          h = y7({ ...vn, x: f - v, y: p - v, width: g - f + v * 2, height: b - p + v * 2, opacity: 100, locked: !1 }), this.scene.insertElement(h);
          for (let U of o) le(U, { frameId: h.id });
          this.setState({ selectedElementIds: { [h.id]: !0 } });
        }
        this.onMagicFrameGenerate(h, "upstream");
      }
    }), $(this, "openEyeDropper", ({ type: o }) => {
      _a.set(A2, { swapPreviewOnAlt: !0, colorPickerType: o === "stroke" ? "elementStroke" : "elementBackground", onSelect: (u, h) => {
        let f = o === "background" && h.altKey || o === "stroke" && !h.altKey;
        !this.scene.getSelectedElements(this.state).length || this.state.activeTool.type !== "selection" ? f ? this.syncActionResult({ appState: { ...this.state, currentItemStrokeColor: u }, captureUpdate: ne.IMMEDIATELY }) : this.syncActionResult({ appState: { ...this.state, currentItemBackgroundColor: u }, captureUpdate: ne.IMMEDIATELY }) : this.updateScene({ elements: this.scene.getElementsIncludingDeleted().map((p) => this.state.selectedElementIds[p.id] ? at(p, { [f ? "strokeColor" : "backgroundColor"]: u }) : p), captureUpdate: ne.IMMEDIATELY });
      }, keepOpenOnAlt: !1 });
    }), $(this, "dismissLinearEditor", () => {
      setTimeout(() => {
        this.setState({ editingLinearElement: null });
      });
    }), $(this, "syncActionResult", _n((o) => {
      var f, p, g, b, v, U;
      if (this.unmounted || o === !1) return;
      o.captureUpdate === ne.NEVER ? this.store.shouldUpdateSnapshot() : o.captureUpdate === ne.IMMEDIATELY && this.store.shouldCaptureIncrement();
      let u = !1, h = null;
      if (o.elements && (this.scene.replaceAllElements(o.elements), u = !0), o.files && (this.addMissingFiles(o.files, o.replaceFiles), this.addNewImagesToImageCache()), o.appState || h || this.state.contextMenu) {
        let y = ((f = o == null ? void 0 : o.appState) == null ? void 0 : f.viewModeEnabled) || !1, w = ((p = o == null ? void 0 : o.appState) == null ? void 0 : p.zenModeEnabled) || !1, x = ((g = o == null ? void 0 : o.appState) == null ? void 0 : g.theme) || this.props.theme || gt.LIGHT, E = ((b = o == null ? void 0 : o.appState) == null ? void 0 : b.name) ?? this.state.name, S = ((v = o == null ? void 0 : o.appState) == null ? void 0 : v.errorMessage) ?? this.state.errorMessage;
        typeof this.props.viewModeEnabled < "u" && (y = this.props.viewModeEnabled), typeof this.props.zenModeEnabled < "u" && (w = this.props.zenModeEnabled), h = ((U = o.appState) == null ? void 0 : U.editingTextElement) || null, o.elements && h && o.elements.forEach((_) => {
          (h == null ? void 0 : h.id) === _.id && h !== _ && T7(_) && we(_) && (h = _);
        }), h != null && h.isDeleted && (h = null), this.setState((_) => {
          let k = o.appState || {};
          return { ..._, ...k, contextMenu: null, editingTextElement: h, viewModeEnabled: y, zenModeEnabled: w, theme: x, name: E, errorMessage: S };
        }), u = !0;
      }
      !u && o.captureUpdate !== ne.EVENTUALLY && this.scene.triggerUpdate();
    })), $(this, "onBlur", _n(() => {
      Ko = !1, this.setState({ isBindingEnabled: !0 });
    })), $(this, "onUnload", () => {
      this.onBlur();
    }), $(this, "disableEvent", (o) => {
      o.preventDefault();
    }), $(this, "resetHistory", () => {
      this.history.clear();
    }), $(this, "resetStore", () => {
      this.store.clear();
    }), $(this, "resetScene", _n((o) => {
      this.scene.replaceAllElements([]), this.setState((u) => ({ ...El(), isLoading: o != null && o.resetLoadingState ? !1 : u.isLoading, theme: this.state.theme })), this.resetStore(), this.resetHistory();
    })), $(this, "initializeScene", async () => {
      var h;
      "launchQueue" in window && "LaunchParams" in window && window.launchQueue.setConsumer(async (f) => {
        if (!f.files.length) return;
        let p = f.files[0], g = await p.getFile();
        this.loadFileToCanvas(new File([g], g.name || "", { type: g.type }), p);
      }), this.props.theme && this.setState({ theme: this.props.theme }), this.state.isLoading || this.setState({ isLoading: !0 });
      let o = null;
      try {
        typeof this.props.initialData == "function" ? o = await this.props.initialData() || null : o = await this.props.initialData || null, o != null && o.libraryItems && this.library.updateLibrary({ libraryItems: o.libraryItems, merge: !0 }).catch((f) => {
          console.error(f);
        });
      } catch (f) {
        console.error(f), o = { appState: { errorMessage: f.message || "Encountered an error during importing or restoring scene data" } };
      }
      let u = g2(o, null, null, { repairBindings: !0 });
      u.appState = { ...u.appState, theme: this.props.theme || u.appState.theme, openSidebar: ((h = u.appState) == null ? void 0 : h.openSidebar) || this.state.openSidebar, activeTool: u.appState.activeTool.type === "image" ? { ...u.appState.activeTool, type: "selection" } : u.appState.activeTool, isLoading: !1, toast: this.state.toast }, o != null && o.scrollToContent && (u.appState = { ...u.appState, ...ef(u.elements, { ...u.appState, width: this.state.width, height: this.state.height, offsetTop: this.state.offsetTop, offsetLeft: this.state.offsetLeft }) }), this.resetStore(), this.resetHistory(), this.syncActionResult({ ...u, captureUpdate: ne.NEVER }), this.clearImageShapeCache(), this.fonts.loadSceneFonts().then((f) => {
        this.fonts.onLoaded(f);
      }), vh(window.location.href) && this.scrollToContent(window.location.href, { animate: !1 });
    }), $(this, "isMobileBreakpoint", (o, u) => o < hY || u < pY && o < fY), $(this, "refreshViewportBreakpoints", () => {
      if (!this.excalidrawContainerRef.current) return;
      let { clientWidth: o, clientHeight: u } = document.body, h = this.device.viewport, f = hp(h, { isLandscape: o > u, isMobile: this.isMobileBreakpoint(o, u) });
      return h !== f ? (this.device = { ...this.device, viewport: f }, !0) : !1;
    }), $(this, "refreshEditorBreakpoints", () => {
      let o = this.excalidrawContainerRef.current;
      if (!o) return;
      let { width: u, height: h } = o.getBoundingClientRect(), f = this.props.UIOptions.dockedSidebarBreakpoint != null ? this.props.UIOptions.dockedSidebarBreakpoint : mY, p = this.device.editor, g = hp(p, { isMobile: this.isMobileBreakpoint(u, h), canFitSidebar: u > f });
      return p !== g ? (this.device = { ...this.device, editor: g }, !0) : !1;
    }), $(this, "onResize", _n(() => {
      this.scene.getElementsIncludingDeleted().forEach((o) => wn.delete(o)), this.refreshViewportBreakpoints(), this.updateDOMRect(), t7 || this.refreshEditorBreakpoints(), this.setState({});
    })), $(this, "onFullscreenChange", () => {
      var o;
      !document.fullscreenElement && ((o = this.state.activeEmbeddable) == null ? void 0 : o.state) === "active" && this.setState({ activeEmbeddable: null });
    }), $(this, "renderInteractiveSceneCallback", ({ atLeastOneVisibleElement: o, scrollBars: u, elementsMap: h }) => {
      u && ($5 = u);
      let f = this.state.editingTextElement ? !1 : !o && h.size > 0;
      this.state.scrolledOutside !== f && this.setState({ scrolledOutside: f }), this.scheduleImageRefresh();
    }), $(this, "onScroll", b0(() => {
      let { offsetTop: o, offsetLeft: u } = this.getCanvasOffsets();
      this.setState((h) => h.offsetLeft === u && h.offsetTop === o ? null : { offsetTop: o, offsetLeft: u });
    }, dY)), $(this, "onCut", _n((o) => {
      var u;
      !((u = this.excalidrawContainerRef.current) != null && u.contains(document.activeElement)) || rc(o.target) || (this.actionManager.executeAction(RS, "keyboard", o), o.preventDefault(), o.stopPropagation());
    })), $(this, "onCopy", _n((o) => {
      var u;
      !((u = this.excalidrawContainerRef.current) != null && u.contains(document.activeElement)) || rc(o.target) || (this.actionManager.executeAction(Ip, "keyboard", o), o.preventDefault(), o.stopPropagation());
    })), $(this, "onTouchStart", (o) => {
      if (kI && o.preventDefault(), !Iu) {
        Iu = !0, clearTimeout(P5), P5 = window.setTimeout(QP.resetTapTwice, oY);
        return;
      }
      if (Iu && o.touches.length === 1) {
        let u = o.touches[0];
        this.handleCanvasDoubleClick({ clientX: u.clientX, clientY: u.clientY }), Iu = !1, clearTimeout(P5);
      }
      o.touches.length === 2 && this.setState({ selectedElementIds: kt({}, this.state), activeEmbeddable: null });
    }), $(this, "onTouchEnd", (o) => {
      this.resetContextMenuTimer(), o.touches.length > 0 ? this.setState({ previousSelectedElementIds: {}, selectedElementIds: kt(this.state.previousSelectedElementIds, this.state) }) : _t.pointers.clear();
    }), $(this, "pasteFromClipboard", _n(async (o) => {
      var y, w;
      let u = !!Z1, h = document.activeElement, f = (y = this.excalidrawContainerRef.current) == null ? void 0 : y.contains(h);
      if (o && !f) return;
      let p = document.elementFromPoint(this.lastViewportPosition.x, this.lastViewportPosition.y);
      if (o && (!(p instanceof HTMLCanvasElement) || rc(h))) return;
      let { x: g, y: b } = en({ clientX: this.lastViewportPosition.x, clientY: this.lastViewportPosition.y }, this.state), v = (w = o == null ? void 0 : o.clipboardData) == null ? void 0 : w.files[0], U = await jN(o, u);
      if (!v && !u) {
        if (U.mixedContent) return this.addElementsFromMixedContentPaste(U.mixedContent, { isPlainPaste: u, sceneX: g, sceneY: b });
        if (U.text) {
          let x = U.text.trim();
          x.startsWith("<svg") && x.endsWith("</svg>") && (v = kE(x));
        }
      }
      if (Ec(v) && !U.spreadsheet) {
        if (!this.isToolSupported("image")) {
          this.setState({ errorMessage: N("errors.imageToolNotSupported") });
          return;
        }
        let x = this.createImageElement({ sceneX: g, sceneY: b });
        this.insertImageElement(x, v), this.initializeImageDimensions(x), this.setState({ selectedElementIds: kt({ [x.id]: !0 }, this.state) });
        return;
      }
      if (this.props.onPaste) try {
        if (await this.props.onPaste(U, o) === !1) return;
      } catch (x) {
        console.error(x);
      }
      if (U.errorMessage) this.setState({ errorMessage: U.errorMessage });
      else if (U.spreadsheet && !u) this.setState({ pasteDialog: { data: U.spreadsheet, shown: !0 } });
      else if (U.elements) {
        let x = U.programmaticAPI ? d3(U.elements) : U.elements;
        this.addElementsFromPasteOrLibrary({ elements: x, files: U.files || null, position: "cursor", retainSeed: u });
      } else if (U.text) {
        if (U.text && xge(U.text)) {
          let S = await import("./index-CGAOqTVC.js").then((_) => _.b1);
          try {
            let { elements: _, files: k } = await S.parseMermaidToExcalidraw(U.text), M = d3(_, { regenerateIds: !0 });
            this.addElementsFromPasteOrLibrary({ elements: M, files: k, position: "cursor" });
            return;
          } catch (_) {
            console.warn(`parsing pasted text as mermaid definition failed: ${_.message}`);
          }
        }
        let x = XI(U.text).split(/\n+/).map((S) => S.trim()).filter(Boolean), E = x.map((S) => oae(S)).filter((S) => {
          var _;
          return yp(S, this.props.validateEmbeddable) && (/^(http|https):\/\/[^\s/$.?#].[^\s]*$/.test(S) || ((_ = Wd(S)) == null ? void 0 : _.type) === "video");
        });
        if (!Z1 && E.length > 0 && E.length === x.length) {
          let S = [];
          for (let _ of E) {
            let k = S[S.length - 1], M = this.insertEmbeddableElement({ sceneX: k ? k.x + k.width + 20 : g, sceneY: b, link: _i(_) });
            M && S.push(M);
          }
          S.length && this.setState({ selectedElementIds: Object.fromEntries(S.map((_) => [_.id, !0])) });
          return;
        }
        this.addTextFromPaste(U.text, u);
      }
      this.setActiveTool({ type: "selection" }), o == null || o.preventDefault();
    })), $(this, "addElementsFromPasteOrLibrary", (o) => {
      var F, W;
      let u = nU(o.elements, null, void 0), [h, f, p, g] = Lt(u), b = Dr(h, p) / 2, v = Dr(f, g) / 2, U = typeof o.position == "object" ? o.position.clientX : o.position === "cursor" ? this.lastViewportPosition.x : this.state.width / 2 + this.state.offsetLeft, y = typeof o.position == "object" ? o.position.clientY : o.position === "cursor" ? this.lastViewportPosition.y : this.state.height / 2 + this.state.offsetTop, { x: w, y: x } = en({ clientX: U, clientY: y }, this.state), E = w - b, S = x - v, [_, k] = Yn(E, S, this.getEffectiveGridSize()), M = wN(u.map((B) => at(B, { x: B.x + _ - h, y: B.y + k - f })), { randomizeSeed: !o.retainSeed }), A = this.scene.getElementsIncludingDeleted(), L = [...A, ...M];
      L = ((W = (F = this.props).onDuplicate) == null ? void 0 : W.call(F, L, A)) || L, Cl(L, Ge(M));
      let R = this.getTopLayerFrameAtSceneCoords({ x: w, y: x });
      if (R) {
        let B = ble(M, R);
        yh(L, B, R, this.state);
      }
      this.scene.replaceAllElements(L), M.forEach((B) => {
        if (we(B) && sn(B)) {
          let j = xr(B, this.scene.getElementsMapIncludingDeleted());
          jr(B, j, this.scene.getElementsMapIncludingDeleted());
        }
      }), YK && ds.loadElementsFonts(M).then((B) => {
        this.fonts.onLoaded(B);
      }), o.files && this.addMissingFiles(o.files), this.store.shouldCaptureIncrement();
      let z = hU(M);
      this.setState({ ...this.state, openSidebar: this.state.openSidebar && this.device.editor.canFitSidebar && _a.get(ZU) ? this.state.openSidebar : null, ...Hr({ editingGroupId: null, selectedElementIds: z.reduce((B, j) => (sn(j) || (B[j.id] = !0), B), {}) }, this.scene.getNonDeletedElements(), this.state, this) }, () => {
        o.files && this.addNewImagesToImageCache();
      }), this.setActiveTool({ type: "selection" }), o.fitToContent && this.scrollToContent(M, { fitToContent: !0, canvasOffsets: this.getEditorUIOffsets() });
    }), $(this, "setAppState", (o, u) => {
      this.setState(o, u);
    }), $(this, "removePointer", (o) => {
      Hs && this.resetContextMenuTimer(), _t.pointers.delete(o.pointerId);
    }), $(this, "toggleLock", (o = "ui") => {
      this.state.activeTool.locked || tn("toolbar", "toggleLock", `${o} (${this.device.editor.isMobile ? "mobile" : "desktop"})`), this.setState((u) => ({ activeTool: { ...u.activeTool, ...Wn(this.state, u.activeTool.locked ? { type: "selection" } : u.activeTool), locked: !u.activeTool.locked } }));
    }), $(this, "updateFrameRendering", (o) => {
      this.setState((u) => {
        let h = typeof o == "function" ? o(u.frameRendering) : o;
        return { frameRendering: { enabled: (h == null ? void 0 : h.enabled) ?? u.frameRendering.enabled, clip: (h == null ? void 0 : h.clip) ?? u.frameRendering.clip, name: (h == null ? void 0 : h.name) ?? u.frameRendering.name, outline: (h == null ? void 0 : h.outline) ?? u.frameRendering.outline } };
      });
    }), $(this, "togglePenMode", (o) => {
      this.setState((u) => ({ penMode: o ?? !u.penMode, penDetected: !0 }));
    }), $(this, "onHandToolToggle", () => {
      this.actionManager.executeAction(Mhe);
    }), $(this, "zoomCanvas", (o) => {
      this.setState({ ...mc({ viewportX: this.state.width / 2 + this.state.offsetLeft, viewportY: this.state.height / 2 + this.state.offsetTop, nextZoom: as(o) }, this.state) });
    }), $(this, "cancelInProgressAnimation", null), $(this, "scrollToContent", (o = this.scene.getNonDeletedElements(), u) => {
      var b;
      if (typeof o == "string") {
        let v;
        if (vh(o) ? v = mae(o) : v = o, v) {
          let U = this.scene.getElementsFromId(v);
          U != null && U.length ? this.scrollToContent(U, { fitToContent: (u == null ? void 0 : u.fitToContent) ?? !0, animate: (u == null ? void 0 : u.animate) ?? !0 }) : vh(o) && this.setState({ toast: { message: N("elementLink.notFound"), duration: 3e3, closable: !0 } });
        }
        return;
      }
      (b = this.cancelInProgressAnimation) == null || b.call(this);
      let h = Array.isArray(o) ? o : [o], f = this.state.zoom, p = this.state.scrollX, g = this.state.scrollY;
      if (u != null && u.fitToContent || u != null && u.fitToViewport) {
        let { appState: v } = D2({ canvasOffsets: u.canvasOffsets, targetElements: h, appState: this.state, fitToViewport: !!(u != null && u.fitToViewport), viewportZoomFactor: u == null ? void 0 : u.viewportZoomFactor, minZoom: u == null ? void 0 : u.minZoom, maxZoom: u == null ? void 0 : u.maxZoom });
        f = v.zoom, p = v.scrollX, g = v.scrollY;
      } else {
        let v = ef(h, this.state);
        p = v.scrollX, g = v.scrollY;
      }
      if (u != null && u.animate) {
        let v = this.state.scrollX, U = this.state.scrollY, y = this.state.zoom.value, w = zY({ fromValues: { scrollX: v, scrollY: U, zoom: y }, toValues: { scrollX: p, scrollY: g, zoom: f.value }, interpolateValue: (x, E, S, _) => {
          if (_ === "zoom") return x * Math.pow(E / x, vc(S));
        }, onStep: ({ scrollX: x, scrollY: E, zoom: S }) => {
          this.setState({ scrollX: x, scrollY: E, zoom: { value: S } });
        }, onStart: () => {
          this.setState({ shouldCacheIgnoreZoom: !0 });
        }, onEnd: () => {
          this.setState({ shouldCacheIgnoreZoom: !1 });
        }, onCancel: () => {
          this.setState({ shouldCacheIgnoreZoom: !1 });
        }, duration: (u == null ? void 0 : u.duration) ?? 500 });
        this.cancelInProgressAnimation = () => {
          w(), this.cancelInProgressAnimation = null;
        };
      } else this.setState({ scrollX: p, scrollY: g, zoom: f });
    }), $(this, "maybeUnfollowRemoteUser", () => {
      this.state.userToFollow && this.setState({ userToFollow: null });
    }), $(this, "translateCanvas", (o) => {
      var u;
      (u = this.cancelInProgressAnimation) == null || u.call(this), this.maybeUnfollowRemoteUser(), this.setState(o);
    }), $(this, "setToast", (o) => {
      this.setState({ toast: o });
    }), $(this, "restoreFileFromShare", async () => {
      try {
        let o = await caches.open("web-share-target"), u = await o.match("shared-file");
        if (u) {
          let h = await u.blob(), f = new File([h], h.name || "", { type: h.type });
          this.loadFileToCanvas(f, null), await o.delete("shared-file"), window.history.replaceState(null, ZK, window.location.pathname);
        }
      } catch (o) {
        this.setState({ errorMessage: o.message });
      }
    }), $(this, "addFiles", _n((o) => {
      let { addedFiles: u } = this.addMissingFiles(o);
      this.clearImageShapeCache(u), this.scene.triggerUpdate(), this.addNewImagesToImageCache();
    })), $(this, "addMissingFiles", (o, u = !1) => {
      let h = u ? {} : { ...this.files }, f = {}, p = Array.isArray(o) ? o : Object.values(o);
      for (let g of p) if (!h[g.id] && (f[g.id] = g, h[g.id] = g, g.mimeType === $e.svg)) try {
        let b = Xle(Zx(Gle(g.dataURL)), $e.svg);
        g.dataURL !== b && (g.version = (g.version ?? 1) + 1, g.dataURL = b);
      } catch (b) {
        console.error(b);
      }
      return this.files = h, { addedFiles: f };
    }), $(this, "updateScene", _n((o) => {
      let u = xs(o.elements ?? []);
      if (o.captureUpdate && o.captureUpdate !== ne.EVENTUALLY) {
        let h = this.store.snapshot.appState, f = this.store.snapshot.elements, p = o.appState ? Object.assign({}, h, o.appState) : h, g = o.elements ? this.store.filterUncomittedElements(this.scene.getElementsMapIncludingDeleted(), Ge(u)) : f;
        o.captureUpdate === ne.IMMEDIATELY ? this.store.captureIncrement(g, p) : o.captureUpdate === ne.NEVER && this.store.updateSnapshot(g, p);
      }
      o.appState && this.setState(o.appState), o.elements && this.scene.replaceAllElements(u), o.collaborators && this.setState({ collaborators: o.collaborators });
    })), $(this, "triggerRender", (o) => {
      o === !0 ? this.scene.triggerUpdate() : this.setState({});
    }), $(this, "toggleSidebar", ({ name: o, tab: u, force: h }) => {
      var g, b;
      let f;
      h === void 0 ? f = ((g = this.state.openSidebar) == null ? void 0 : g.name) === o && ((b = this.state.openSidebar) == null ? void 0 : b.tab) === u ? null : o : f = h ? o : null;
      let p = f ? { name: f } : null;
      return p && u && (p.tab = u), this.setState({ openSidebar: p }), !!f;
    }), $(this, "updateCurrentCursorPosition", _n((o) => {
      this.lastViewportPosition.x = o.clientX, this.lastViewportPosition.y = o.clientY;
    })), $(this, "getEditorUIOffsets", () => {
      var p, g, b, v, U, y, w, x, E, S;
      let o = ((v = (b = (g = (p = this.excalidrawContainerRef) == null ? void 0 : p.current) == null ? void 0 : g.querySelector(".App-toolbar")) == null ? void 0 : b.getBoundingClientRect()) == null ? void 0 : v.bottom) ?? 0, u = (w = (y = (U = this.excalidrawContainerRef) == null ? void 0 : U.current) == null ? void 0 : y.querySelector(".sidebar")) == null ? void 0 : w.getBoundingClientRect(), h = (S = (E = (x = this.excalidrawContainerRef) == null ? void 0 : x.current) == null ? void 0 : E.querySelector(".App-menu__left")) == null ? void 0 : S.getBoundingClientRect(), f = 16;
      return df().rtl ? { top: o + f, right: Math.max(this.state.width - ((h == null ? void 0 : h.left) ?? this.state.width), 0) + f, bottom: f, left: Math.max((u == null ? void 0 : u.right) ?? 0, 0) + f } : { top: o + f, right: Math.max(this.state.width - ((u == null ? void 0 : u.left) ?? this.state.width) + f, 0), bottom: f, left: Math.max((h == null ? void 0 : h.right) ?? 0, 0) + f };
    }), $(this, "onKeyDown", _n((o) => {
      var p, g;
      if ("Proxy" in window && (!o.shiftKey && /^[A-Z]$/.test(o.key) || o.shiftKey && /^[a-z]$/.test(o.key)) && (o = new Proxy(o, { get(b, v) {
        let U = b[v];
        return typeof U == "function" ? U.bind(b) : v === "key" ? o.shiftKey ? b.key.toUpperCase() : b.key.toLowerCase() : U;
      } })), !i7(o.target)) {
        if ((o.key === H.ESCAPE || o.key === H.ENTER) && this.state.croppingElementId) {
          this.finishImageCropping();
          return;
        }
        let b = ct(this.scene.getNonDeletedElementsMap(), this.state);
        if (b.length === 1 && Mt(b[0]) && o.key === H.ENTER) {
          this.startImageCropping(b[0]);
          return;
        }
        if (o.key === H.ESCAPE && this.flowChartCreator.isCreatingChart) {
          this.flowChartCreator.clear(), this.triggerRender(!0);
          return;
        }
        let v = ju(o.key);
        if (o[H.CTRL_OR_CMD] && v && !o.shiftKey) {
          o.preventDefault();
          let U = ct(this.scene.getNonDeletedElementsMap(), this.state);
          U.length === 1 && Qg(U[0]) && this.flowChartCreator.createNodes(U[0], this.scene.getNonDeletedElementsMap(), this.state, QS(o.key)), (p = this.flowChartCreator.pendingNodes) != null && p.length && !Sp(this.flowChartCreator.pendingNodes, this.canvas.width / window.devicePixelRatio, this.canvas.height / window.devicePixelRatio, { offsetLeft: this.state.offsetLeft, offsetTop: this.state.offsetTop, scrollX: this.state.scrollX, scrollY: this.state.scrollY, zoom: this.state.zoom }, this.scene.getNonDeletedElementsMap(), this.getEditorUIOffsets()) && this.scrollToContent(this.flowChartCreator.pendingNodes, { animate: !0, duration: 300, fitToContent: !0, canvasOffsets: this.getEditorUIOffsets() });
          return;
        }
        if (o.altKey) {
          let U = ct(this.scene.getNonDeletedElementsMap(), this.state);
          if (U.length === 1 && v) {
            o.preventDefault();
            let y = this.flowChartNavigator.exploreByDirection(U[0], this.scene.getNonDeletedElementsMap(), QS(o.key));
            if (y) {
              this.setState((x) => ({ selectedElementIds: kt({ [y]: !0 }, x) }));
              let w = this.scene.getNonDeletedElementsMap().get(y);
              w && !Sp([w], this.canvas.width / window.devicePixelRatio, this.canvas.height / window.devicePixelRatio, { offsetLeft: this.state.offsetLeft, offsetTop: this.state.offsetTop, scrollX: this.state.scrollX, scrollY: this.state.scrollY, zoom: this.state.zoom }, this.scene.getNonDeletedElementsMap(), this.getEditorUIOffsets()) && this.scrollToContent(w, { animate: !0, duration: 300, canvasOffsets: this.getEditorUIOffsets() });
            }
            return;
          }
        }
      }
      if (o[H.CTRL_OR_CMD] && o.key === H.P && !o.shiftKey && !o.altKey) {
        this.setToast({ message: N("commandPalette.shortcutHint", { shortcut: Pr("commandPalette") }) }), o.preventDefault();
        return;
      }
      if (o[H.CTRL_OR_CMD] && o.key.toLowerCase() === H.V && (Z1 = o.shiftKey, clearTimeout(M_), M_ = window.setTimeout(() => {
        Z1 = !1;
      }, 100)), o[H.CTRL_OR_CMD] && rc(o.target) && (o.code === xt.MINUS || o.code === xt.EQUAL)) {
        o.preventDefault();
        return;
      }
      if (rc(o.target) && o.key !== H.ESCAPE || ju(o.key) && i7(o.target)) return;
      if (o.key === H.QUESTION_MARK) {
        this.setState({ openDialog: { name: "help" } });
        return;
      } else if (o.key.toLowerCase() === H.E && o.shiftKey && o[H.CTRL_OR_CMD]) {
        o.preventDefault(), this.setState({ openDialog: { name: "imageExport" } });
        return;
      }
      if (o.key === H.PAGE_UP || o.key === H.PAGE_DOWN) {
        let b = (o.shiftKey ? this.state.width : this.state.height) / this.state.zoom.value;
        o.key === H.PAGE_DOWN && (b = -b), o.shiftKey ? this.translateCanvas((v) => ({ scrollX: v.scrollX + b })) : this.translateCanvas((v) => ({ scrollY: v.scrollY + b }));
      }
      if (((g = this.state.openDialog) == null ? void 0 : g.name) === "elementLinkSelector" || this.actionManager.handleKeyDown(o) || this.state.viewModeEnabled) return;
      if (o[H.CTRL_OR_CMD] && this.state.isBindingEnabled && this.setState({ isBindingEnabled: !1 }), ju(o.key)) {
        let b = this.scene.getSelectedElements({ selectedElementIds: this.state.selectedElementIds, includeBoundTextElement: !0, includeElementsInFrames: !0 }), v = b.find(Se), U = /* @__PURE__ */ new Set();
        b.filter(Se).filter((E) => {
          let S = E.startBinding && !b.some((k) => {
            var M;
            return k.id === ((M = E.startBinding) == null ? void 0 : M.elementId);
          }), _ = E.endBinding && !b.some((k) => {
            var M;
            return k.id === ((M = E.endBinding) == null ? void 0 : M.elementId);
          });
          return S || _;
        }).forEach((E) => U.add(E.id)), b = b.filter((E) => !U.has(E.id));
        let y = this.getEffectiveGridSize() && (o.shiftKey ? zw : this.getEffectiveGridSize()) || (o.shiftKey ? QK : zw), w = 0, x = 0;
        o.key === H.ARROW_LEFT ? w = -y : o.key === H.ARROW_RIGHT ? w = y : o.key === H.ARROW_UP ? x = -y : o.key === H.ARROW_DOWN && (x = y), b.forEach((E) => {
          le(E, { x: E.x + w, y: E.y + x }, !1), ui(E, this.scene.getNonDeletedElementsMap(), { simultaneouslyUpdated: b });
        }), this.setState({ suggestedBindings: Z6(b.filter((E) => E.id !== (v == null ? void 0 : v.id) || y !== 0), this.scene.getNonDeletedElementsMap(), this.state.zoom) }), this.scene.triggerUpdate(), o.preventDefault();
      } else if (o.key === H.ENTER) {
        let b = this.scene.getSelectedElements(this.state);
        if (b.length === 1) {
          let v = b[0];
          if (o[H.CTRL_OR_CMD]) et(v) && (!this.state.editingLinearElement || this.state.editingLinearElement.elementId !== b[0].id) && (this.store.shouldCaptureIncrement(), Se(v) || this.setState({ editingLinearElement: new Ee(v) }));
          else if (we(v) || Oie(v)) {
            let U;
            we(v) || (U = v);
            let y = J6(v, this.state, this.scene.getNonDeletedElementsMap()), w = y.x, x = y.y;
            this.startTextEditing({ sceneX: w, sceneY: x, container: U }), o.preventDefault();
            return;
          } else Ve(v) && this.setState({ editingFrame: v.id });
        }
      } else if (!o.ctrlKey && !o.altKey && !o.metaKey && !this.state.newElement && !this.state.selectionElement && !this.state.selectedElementsAreBeingDragged) {
        let b = ore(o.key);
        b ? (this.state.activeTool.type !== b && tn("toolbar", b, `keyboard (${this.device.editor.isMobile ? "mobile" : "desktop"})`), b === "arrow" && this.state.activeTool.type === "arrow" && this.setState((v) => ({ currentItemArrowType: v.currentItemArrowType === br.sharp ? br.round : v.currentItemArrowType === br.round ? br.elbow : br.sharp })), this.setActiveTool({ type: b }), o.stopPropagation()) : o.key === H.Q && (this.toggleLock("keyboard"), o.stopPropagation());
      }
      if (o.key === H.SPACE && _t.pointers.size === 0 && (Ko = !0, Ht(this.interactiveCanvas, Ot.GRAB), o.preventDefault()), (o.key === H.G || o.key === H.S) && !o.altKey && !o[H.CTRL_OR_CMD]) {
        let b = this.scene.getSelectedElements(this.state);
        if (this.state.activeTool.type === "selection" && !b.length) return;
        o.key === H.G && (w0(this.state.activeTool.type) || b.some((v) => w0(v.type))) && (this.setState({ openPopup: "elementBackground" }), o.stopPropagation()), o.key === H.S && (this.setState({ openPopup: "elementStroke" }), o.stopPropagation());
      }
      if (!o[H.CTRL_OR_CMD] && o.shiftKey && o.key.toLowerCase() === H.F) {
        let b = this.scene.getSelectedElements(this.state);
        if (this.state.activeTool.type === "selection" && !b.length) return;
        (this.state.activeTool.type === "text" || b.find((v) => we(v) || lt(v, this.scene.getNonDeletedElementsMap()))) && (o.preventDefault(), this.setState({ openPopup: "fontFamily" }));
      }
      if (o.key === H.K && !o.altKey && !o[H.CTRL_OR_CMD]) {
        this.state.activeTool.type === "laser" ? this.setActiveTool({ type: "selection" }) : this.setActiveTool({ type: "laser" });
        return;
      }
      o[H.CTRL_OR_CMD] && (o.key === H.BACKSPACE || o.key === H.DELETE) && _a.set(O2, "clearCanvas");
      let u = o.key.toLocaleLowerCase(), h = u === H.S && o.shiftKey, f = o.key === H.I || u === H.G && o.shiftKey;
      (h || f) && this.openEyeDropper({ type: h ? "stroke" : "background" });
    })), $(this, "onKeyUp", _n((o) => {
      var u, h, f, p;
      if (o.key === H.SPACE && (this.state.viewModeEnabled || ((u = this.state.openDialog) == null ? void 0 : u.name) === "elementLinkSelector" ? Ht(this.interactiveCanvas, Ot.GRAB) : this.state.activeTool.type === "selection" ? fa(this.interactiveCanvas) : (Qa(this.interactiveCanvas, this.state), this.setState({ selectedElementIds: kt({}, this.state), selectedGroupIds: {}, editingGroupId: null, activeEmbeddable: null })), Ko = !1), !o[H.CTRL_OR_CMD] && !this.state.isBindingEnabled && this.setState({ isBindingEnabled: !0 }), ju(o.key) && (Nm(this.scene.getSelectedElements(this.state).filter(et), this.scene.getNonDeletedElementsMap(), this.scene.getNonDeletedElements(), this.scene, fc(this.state), ((h = this.state.selectedLinearElement) == null ? void 0 : h.selectedPointsIndices) ?? [], this.state.zoom), this.setState({ suggestedBindings: [] })), o.altKey || this.flowChartNavigator.isExploring && (this.flowChartNavigator.clear(), this.syncActionResult({ captureUpdate: ne.IMMEDIATELY })), !o[H.CTRL_OR_CMD] && this.flowChartCreator.isCreatingChart) {
        (f = this.flowChartCreator.pendingNodes) != null && f.length && this.scene.insertElements(this.flowChartCreator.pendingNodes);
        let g = (p = this.flowChartCreator.pendingNodes) == null ? void 0 : p[0];
        g && (this.setState((b) => ({ selectedElementIds: kt({ [g.id]: !0 }, b) })), Sp([g], this.canvas.width / window.devicePixelRatio, this.canvas.height / window.devicePixelRatio, { offsetLeft: this.state.offsetLeft, offsetTop: this.state.offsetTop, scrollX: this.state.scrollX, scrollY: this.state.scrollY, zoom: this.state.zoom }, this.scene.getNonDeletedElementsMap(), this.getEditorUIOffsets()) || this.scrollToContent(g, { animate: !0, duration: 300, canvasOffsets: this.getEditorUIOffsets() })), this.flowChartCreator.clear(), this.syncActionResult({ captureUpdate: ne.IMMEDIATELY });
      }
    })), $(this, "isToolSupported", (o) => {
      var u;
      return ((u = this.props.UIOptions.tools) == null ? void 0 : u[o]) !== !1;
    }), $(this, "setActiveTool", (o) => {
      if (!this.isToolSupported(o.type)) {
        console.warn(`"${o.type}" tool is disabled via "UIOptions.canvasActions.tools.${o.type}"`);
        return;
      }
      let u = Wn(this.state, o);
      u.type === "hand" ? Ht(this.interactiveCanvas, Ot.GRAB) : Ko || Qa(this.interactiveCanvas, { ...this.state, activeTool: u }), $Y(document.activeElement) && this.focusContainer(), U8(u.type) || this.setState({ suggestedBindings: [] }), u.type === "image" && this.onImageAction({ insertOnCanvasDirectly: (o.type === "image" && o.insertOnCanvasDirectly) ?? !1 }), this.setState((h) => {
        let f = { snapLines: h.snapLines.length ? [] : h.snapLines, originSnapOffset: null, activeEmbeddable: null };
        return u.type === "freedraw" && this.store.shouldCaptureIncrement(), u.type !== "selection" ? { ...h, activeTool: u, selectedElementIds: kt({}, h), selectedGroupIds: kt({}, h), editingGroupId: null, multiElement: null, ...f } : { ...h, activeTool: u, ...f };
      });
    }), $(this, "setOpenDialog", (o) => {
      this.setState({ openDialog: o });
    }), $(this, "setCursor", (o) => {
      Ht(this.interactiveCanvas, o);
    }), $(this, "resetCursor", () => {
      fa(this.interactiveCanvas);
    }), $(this, "isTouchScreenMultiTouchGesture", () => _t.pointers.size >= 2), $(this, "getName", () => this.state.name || this.props.name || `${N("labels.untitled")}-${Kw()}`), $(this, "onGestureStart", _n((o) => {
      o.preventDefault(), this.isTouchScreenMultiTouchGesture() && this.setState({ selectedElementIds: kt({}, this.state), activeEmbeddable: null }), _t.initialScale = this.state.zoom.value;
    })), $(this, "onGestureChange", _n((o) => {
      if (o.preventDefault(), this.isTouchScreenMultiTouchGesture()) return;
      let u = _t.initialScale;
      u && this.setState((h) => ({ ...mc({ viewportX: this.lastViewportPosition.x, viewportY: this.lastViewportPosition.y, nextZoom: as(u * o.scale) }, h) }));
    })), $(this, "onGestureEnd", _n((o) => {
      o.preventDefault(), this.isTouchScreenMultiTouchGesture() && this.setState({ previousSelectedElementIds: {}, selectedElementIds: kt(this.state.previousSelectedElementIds, this.state) }), _t.initialScale = null;
    })), $(this, "startTextEditing", ({ sceneX: o, sceneY: u, insertAtParentCenter: h = !0, container: f, autoEdit: p = !0 }) => {
      let g = !1, b = h && this.getTextWysiwygSnappedToCenterPosition(o, u, this.state, f);
      f && b && (lt(f, this.scene.getNonDeletedElementsMap()) || (g = !0));
      let v = null, U = this.scene.getSelectedElements(this.state);
      U.length === 1 ? we(U[0]) ? v = U[0] : f ? v = lt(U[0], this.scene.getNonDeletedElementsMap()) : v = this.getTextElementAtPosition(o, u) : v = this.getTextElementAtPosition(o, u);
      let y = (v == null ? void 0 : v.fontFamily) || this.state.currentItemFontFamily, w = (v == null ? void 0 : v.lineHeight) || Yc(y), x = this.state.currentItemFontSize;
      if (!v && g && f && !dt(f)) {
        let _ = qI(Wt({ fontSize: x, fontFamily: y }), w), k = ZI(x, w), M = Math.max(f.height, k), A = Math.max(f.width, _);
        le(f, { height: M, width: A }), o = f.x + A / 2, u = f.y + M / 2, b && (b = this.getTextWysiwygSnappedToCenterPosition(o, u, this.state, f));
      }
      let E = this.getTopLayerFrameAtSceneCoords({ x: o, y: u }), S = v || Ai({ x: b ? b.elementCenterX : o, y: b ? b.elementCenterY : u, strokeColor: this.state.currentItemStrokeColor, backgroundColor: this.state.currentItemBackgroundColor, fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roughness: this.state.currentItemRoughness, opacity: this.state.currentItemOpacity, text: "", fontSize: x, fontFamily: y, textAlign: b ? "center" : this.state.currentItemTextAlign, verticalAlign: b ? Si.MIDDLE : mm, containerId: g ? f == null ? void 0 : f.id : void 0, groupIds: (f == null ? void 0 : f.groupIds) ?? [], lineHeight: w, angle: (f == null ? void 0 : f.angle) ?? 0, frameId: E ? E.id : null });
      if (!v && g && f && le(f, { boundElements: (f.boundElements || []).concat({ type: "text", id: S.id }) }), this.setState({ editingTextElement: S }), !v) if (f && g) {
        let _ = this.scene.getElementIndex(f.id);
        this.scene.insertElementAtIndex(S, _ + 1);
      } else this.scene.insertElement(S);
      p || v || f ? this.handleTextWysiwyg(S, { isExistingElement: !!v }) : this.setState({ newElement: S, multiElement: null });
    }), $(this, "startImageCropping", (o) => {
      this.store.shouldCaptureIncrement(), this.setState({ croppingElementId: o.id });
    }), $(this, "finishImageCropping", () => {
      this.state.croppingElementId && (this.store.shouldCaptureIncrement(), this.setState({ croppingElementId: null }));
    }), $(this, "handleCanvasDoubleClick", (o) => {
      if (this.state.multiElement || this.state.activeTool.type !== "selection") return;
      let u = this.scene.getSelectedElements(this.state), { x: h, y: f } = en(o, this.state);
      if (u.length === 1 && et(u[0])) {
        if (o[H.CTRL_OR_CMD] && (!this.state.editingLinearElement || this.state.editingLinearElement.elementId !== u[0].id) && !Se(u[0])) {
          this.store.shouldCaptureIncrement(), this.setState({ editingLinearElement: new Ee(u[0]) });
          return;
        } else if (this.state.selectedLinearElement && Se(u[0])) {
          let p = Ee.getSegmentMidpointHitCoords(this.state.selectedLinearElement, { x: h, y: f }, this.state, this.scene.getNonDeletedElementsMap()), g = p ? Ee.getSegmentMidPointIndex(this.state.selectedLinearElement, this.state, p, this.scene.getNonDeletedElementsMap()) : -1;
          if (g && g > -1) {
            this.store.shouldCaptureIncrement(), Ee.deleteFixedSegment(u[0], g);
            let b = Ee.getSegmentMidpointHitCoords({ ...this.state.selectedLinearElement, segmentMidPointHoveredCoords: null }, { x: h, y: f }, this.state, this.scene.getNonDeletedElementsMap()), v = b ? Ee.getSegmentMidPointIndex(this.state.selectedLinearElement, this.state, b, this.scene.getNonDeletedElementsMap()) : null;
            this.setState({ selectedLinearElement: { ...this.state.selectedLinearElement, pointerDownState: { ...this.state.selectedLinearElement.pointerDownState, segmentMidpoint: { index: v, value: p, added: !1 } }, segmentMidPointHoveredCoords: b } });
            return;
          }
        }
      }
      if (u.length === 1 && Mt(u[0])) {
        this.startImageCropping(u[0]);
        return;
      }
      if (fa(this.interactiveCanvas), wc(this.state).length > 0) {
        let p = this.getElementAtPosition(h, f), g = p && mie(p, this.state.selectedGroupIds);
        if (g) {
          this.store.shouldCaptureIncrement(), this.setState((b) => ({ ...b, ...Hr({ editingGroupId: g, selectedElementIds: { [p.id]: !0 } }, this.scene.getNonDeletedElements(), b, this) }));
          return;
        }
      }
      if (fa(this.interactiveCanvas), !o[H.CTRL_OR_CMD] && !this.state.viewModeEnabled) {
        let p = this.getElementAtPosition(h, f);
        if (Bi(p)) {
          this.setState({ activeEmbeddable: { element: p, state: "active" } });
          return;
        }
        let g = this.getTextBindableContainerAtPosition(h, f);
        if (g && (ra(g) || !Ea(g.backgroundColor) || Nd({ x: h, y: f, element: g, shape: Jl(g, this.scene.getNonDeletedElementsMap()), threshold: this.getElementHitThreshold() }))) {
          let b = J6(g, this.state, this.scene.getNonDeletedElementsMap());
          h = b.x, f = b.y;
        }
        this.startTextEditing({ sceneX: h, sceneY: f, insertAtParentCenter: !o.altKey, container: g });
      }
    }), $(this, "getElementLinkAtPosition", (o, u) => {
      let h = this.scene.getNonDeletedElements(), f = -1;
      for (let p = h.length - 1; p >= 0; p--) {
        let g = h[p];
        if (u && g.id === u.id && (f = p), g.link && p >= f && Q6(g, this.scene.getNonDeletedElementsMap(), this.state, T(o.x, o.y), this.device.editor.isMobile)) return g;
      }
    }), $(this, "redirectToLink", (o, u) => {
      let h = Tt(T(this.lastPointerDownEvent.clientX, this.lastPointerDownEvent.clientY), T(this.lastPointerUpEvent.clientX, this.lastPointerUpEvent.clientY));
      if (!this.hitLinkElement || h > ec) return;
      let f = en(this.lastPointerDownEvent, this.state), p = this.scene.getNonDeletedElementsMap(), g = Q6(this.hitLinkElement, p, this.state, T(f.x, f.y), this.device.editor.isMobile), b = en(this.lastPointerUpEvent, this.state), v = Q6(this.hitLinkElement, p, this.state, T(b.x, b.y), this.device.editor.isMobile);
      if (g && v) {
        BS();
        let U = this.hitLinkElement.link;
        if (U) {
          U = _i(U);
          let y;
          if (this.props.onLinkOpen && (y = HI("excalidraw-link", o.nativeEvent), this.props.onLinkOpen({ ...this.hitLinkElement, link: U }, y)), !(y != null && y.defaultPrevented)) {
            let w = uN(U) ? "_self" : "_blank", x = window.open(void 0, w);
            x && (x.opener = null, x.location = U);
          }
        }
      }
    }), $(this, "getTopLayerFrameAtSceneCoords", (o) => {
      let u = this.scene.getNonDeletedElementsMap(), h = this.scene.getNonDeletedFramesLikes().filter((f) => fE(o, f, u));
      return h.length ? h[h.length - 1] : null;
    }), $(this, "handleCanvasPointerMove", (o) => {
      var y, w, x, E, S, _;
      this.savePointer(o.clientX, o.clientY, this.state.cursorButton), this.lastPointerMoveEvent = o.nativeEvent, _t.pointers.has(o.pointerId) && _t.pointers.set(o.pointerId, { x: o.clientX, y: o.clientY });
      let u = _t.initialScale;
      if (_t.pointers.size === 2 && _t.lastCenter && u && _t.initialDistance) {
        let k = qS(_t.pointers), M = k.x - _t.lastCenter.x, A = k.y - _t.lastCenter.y;
        _t.lastCenter = k;
        let L = ZS(Array.from(_t.pointers.values())), R = this.state.activeTool.type === "freedraw" && this.state.penMode ? 1 : L / _t.initialDistance, z = R ? as(u * R) : this.state.zoom.value;
        this.setState((F) => {
          let W = mc({ viewportX: k.x, viewportY: k.y, nextZoom: z }, F);
          this.translateCanvas({ zoom: W.zoom, scrollX: W.scrollX + 2 * (M / z), scrollY: W.scrollY + 2 * (A / z), shouldCacheIgnoreZoom: !0 });
        }), this.resetShouldCacheIgnoreZoomDebounced();
      } else _t.lastCenter = _t.initialDistance = _t.initialScale = null;
      if (Ko || Au || O5 || m0(this.state)) return;
      let h = t_($5, o.clientX - this.state.offsetLeft, o.clientY - this.state.offsetTop).isOverEither;
      !this.state.newElement && !this.state.selectionElement && !this.state.selectedElementsAreBeingDragged && !this.state.multiElement && (h ? fa(this.interactiveCanvas) : Qa(this.interactiveCanvas, this.state));
      let f = en(o, this.state), { x: p, y: g } = f;
      if (!this.state.newElement && Tie(this.state.activeTool.type)) {
        let { originOffset: k, snapLines: M } = Mie(this.scene.getNonDeletedElements(), this, { x: p, y: g }, o, this.scene.getNonDeletedElementsMap());
        this.setState((A) => {
          let L = xu(A.snapLines, M), R = A.originSnapOffset ? xu(A.originSnapOffset, k) : k;
          return A.snapLines === L && A.originSnapOffset === R ? null : { snapLines: L, originSnapOffset: R };
        });
      } else !this.state.newElement && !this.state.selectedElementsAreBeingDragged && !this.state.selectionElement && this.setState((k) => k.snapLines.length ? { snapLines: [] } : null);
      if (this.state.editingLinearElement && !this.state.editingLinearElement.isDragging) {
        let k = Ee.handlePointerMove(o, p, g, this, this.scene.getNonDeletedElementsMap());
        k && k !== this.state.editingLinearElement && ga(() => {
          this.setState({ editingLinearElement: k });
        }), (k == null ? void 0 : k.lastUncommittedPoint) != null ? this.maybeSuggestBindingAtCursor(f, k.elbowed) : ga(() => {
          this.setState({ suggestedBindings: [] });
        });
      }
      if (GI(this.state.activeTool.type)) {
        let { newElement: k } = this.state;
        hl(k, !1) ? this.maybeSuggestBindingsForLinearElementAtCoords(k, [f], this.state.startBoundElement) : this.maybeSuggestBindingAtCursor(f, !1);
      }
      if (this.state.multiElement) {
        let { multiElement: k } = this.state, { x: M, y: A } = k, { points: L, lastCommittedPoint: R } = k, z = L[L.length - 1];
        if (Qa(this.interactiveCanvas, this.state), z === R) Tt(T(p - M, g - A), z) >= up ? le(k, { points: [...L, T(p - M, g - A)] }, !1) : Ht(this.interactiveCanvas, Ot.POINTER);
        else if (L.length > 2 && R && Tt(T(p - M, g - A), R) < up) Ht(this.interactiveCanvas, Ot.POINTER), le(k, { points: L.slice(0, -1) }, !1);
        else {
          let [F, W] = Yn(p, g, o[H.CTRL_OR_CMD] || Se(k) ? null : this.getEffectiveGridSize()), [B, j] = (k == null ? void 0 : k.lastCommittedPoint) ?? [0, 0], V = F - M - B, q = W - A - j;
          bh(o) && ({ width: V, height: q } = C7(B + M, j + A, F, W)), Us(L, this.state.zoom.value) && Ht(this.interactiveCanvas, Ot.POINTER), le(k, { points: [...L.slice(0, -1), T(B + V, j + q)] }, !1, { isDragging: !0 }), this.triggerRender(!1);
        }
        return;
      }
      if (o.buttons || this.state.activeTool.type !== "selection" && this.state.activeTool.type !== "text" && this.state.activeTool.type !== "eraser") return;
      let b = this.scene.getNonDeletedElements(), v = this.scene.getSelectedElements(this.state);
      if (v.length === 1 && !h && !this.state.editingLinearElement) {
        if (this.state.selectedLinearElement && this.handleHoverSelectedLinearElement(this.state.selectedLinearElement, p, g), (!this.state.selectedLinearElement || this.state.selectedLinearElement.hoverPointIndex === -1) && ((y = this.state.openDialog) == null ? void 0 : y.name) !== "elementLinkSelector" && !(v.length === 1 && Se(v[0]))) {
          let k = yE(b, this.state, p, g, this.state.zoom, o.pointerType, this.scene.getNonDeletedElementsMap(), this.device);
          if (k && k.transformHandleType) {
            Ht(this.interactiveCanvas, xE(k));
            return;
          }
        }
      } else if (v.length > 1 && !h && ((w = this.state.openDialog) == null ? void 0 : w.name) !== "elementLinkSelector") {
        let k = wE(Lt(v), p, g, this.state.zoom, o.pointerType, this.device);
        if (k) {
          Ht(this.interactiveCanvas, xE({ transformHandleType: k }));
          return;
        }
      }
      let U = this.getElementAtPosition(f.x, f.y);
      this.hitLinkElement = this.getElementLinkAtPosition(f, U), !tl(this.state) && (this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id] ? (Ht(this.interactiveCanvas, Ot.POINTER), lfe(this.hitLinkElement, this.state, this.scene.getNonDeletedElementsMap())) : (BS(), U && (U.link || ri(U)) && this.state.selectedElementIds[U.id] && !this.state.contextMenu && !this.state.showHyperlinkPopup ? this.setState({ showHyperlinkPopup: "info" }) : this.state.activeTool.type === "text" ? Ht(this.interactiveCanvas, we(U) ? Ot.TEXT : Ot.CROSSHAIR) : this.state.viewModeEnabled ? Ht(this.interactiveCanvas, Ot.GRAB) : ((x = this.state.openDialog) == null ? void 0 : x.name) === "elementLinkSelector" ? Ht(this.interactiveCanvas, Ot.AUTO) : h ? Ht(this.interactiveCanvas, Ot.AUTO) : this.state.selectedLinearElement ? this.handleHoverSelectedLinearElement(this.state.selectedLinearElement, p, g) : o[H.CTRL_OR_CMD] ? Ht(this.interactiveCanvas, Ot.AUTO) : (U || this.isHittingCommonBoundingBoxOfSelectedElements(f, v)) && !(U != null && U.locked) && (U && Bi(U) && this.isIframeLikeElementCenter(U, o, p, g) ? (Ht(this.interactiveCanvas, Ot.POINTER), this.setState({ activeEmbeddable: { element: U, state: "hover" } })) : (!U || !Se(U)) && (Ht(this.interactiveCanvas, Ot.MOVE), ((E = this.state.activeEmbeddable) == null ? void 0 : E.state) === "hover" && this.setState({ activeEmbeddable: null })))), ((S = this.state.openDialog) == null ? void 0 : S.name) === "elementLinkSelector" && U ? this.setState((k) => ({ hoveredElementIds: xu(k.hoveredElementIds, Hr({ editingGroupId: k.editingGroupId, selectedElementIds: { [U.id]: !0 } }, this.scene.getNonDeletedElements(), k, this).selectedElementIds) })) : ((_ = this.state.openDialog) == null ? void 0 : _.name) === "elementLinkSelector" && !U && this.setState((k) => ({ hoveredElementIds: xu(k.hoveredElementIds, {}) })));
    }), $(this, "handleEraser", (o, u, h) => {
      this.eraserTrail.addPointToPath(h.x, h.y);
      let f = !1, p = /* @__PURE__ */ new Set(), g = this.scene.getNonDeletedElements(), b = (x) => {
        var E;
        for (let S of x) {
          if (S.locked) return;
          if (o.altKey ? this.elementsPendingErasure.delete(S.id) && (f = !0) : this.elementsPendingErasure.has(S.id) || (f = !0, this.elementsPendingErasure.add(S.id)), f && ((E = S.groupIds) == null ? void 0 : E.length)) {
            let _ = S.groupIds.at(-1);
            if (!p.has(_)) {
              p.add(_);
              let k = ln(g, _);
              for (let M of k) o.altKey ? this.elementsPendingErasure.delete(M.id) : this.elementsPendingErasure.add(M.id);
            }
          }
        }
      }, v = Tt(T(u.lastCoords.x, u.lastCoords.y), T(h.x, h.y)), U = this.getElementHitThreshold(), y = { ...u.lastCoords }, w = 0;
      for (; w <= v; ) {
        let x = this.getElementsAtPosition(y.x, y.y);
        if (b(x), w === v) break;
        w = Math.min(w + U, v);
        let E = w / v, S = (1 - E) * y.x + E * h.x, _ = (1 - E) * y.y + E * h.y;
        y.x = S, y.y = _;
      }
      if (u.lastCoords.x = h.x, u.lastCoords.y = h.y, f) {
        for (let x of this.scene.getNonDeletedElements()) sn(x) && (this.elementsPendingErasure.has(x.id) || this.elementsPendingErasure.has(x.containerId)) && (o.altKey ? (this.elementsPendingErasure.delete(x.id), this.elementsPendingErasure.delete(x.containerId)) : (this.elementsPendingErasure.add(x.id), this.elementsPendingErasure.add(x.containerId)));
        this.elementsPendingErasure = new Set(this.elementsPendingErasure), this.triggerRender();
      }
    }), $(this, "handleTouchMove", (o) => {
      Nu = !0;
    }), $(this, "handleCanvasPointerDown", (o) => {
      var U, y, w;
      let u = o.target;
      if (u.setPointerCapture && u.setPointerCapture(o.pointerId), this.maybeCleanupAfterMissingPointerUp(o.nativeEvent), this.maybeUnfollowRemoteUser(), this.state.searchMatches && (this.setState((x) => ({ searchMatches: x.searchMatches.map((E) => ({ ...E, focus: !1 })) })), _a.set(NP, null)), this.state.contextMenu && this.setState({ contextMenu: null }), this.state.snapLines && this.setAppState({ snapLines: [] }), this.updateGestureOnPointerDown(o), o.pointerType === "touch" && this.state.newElement && this.state.newElement.type === "freedraw") {
        let x = this.state.newElement;
        this.updateScene({ ...x.points.length < 10 ? { elements: this.scene.getElementsIncludingDeleted().filter((E) => E.id !== x.id) } : {}, appState: { newElement: null, editingTextElement: null, startBoundElement: null, suggestedBindings: [], selectedElementIds: kt(Object.keys(this.state.selectedElementIds).filter((E) => E !== x.id).reduce((E, S) => (E[S] = this.state.selectedElementIds[S], E), {}), this.state) }, captureUpdate: ((U = this.state.openDialog) == null ? void 0 : U.name) === "elementLinkSelector" ? ne.EVENTUALLY : ne.NEVER });
        return;
      }
      let h = document.getSelection();
      if (h != null && h.anchorNode && h.removeAllRanges(), this.maybeOpenContextMenuAfterPointerDownOnTouchDevices(o), !this.state.penDetected && o.pointerType === "pen" && this.setState((x) => ({ penMode: !0, penDetected: !0 })), !this.device.isTouchScreen && ["pen", "touch"].includes(o.pointerType) && (this.device = hp(this.device, { isTouchScreen: !0 })), Au || (this.lastPointerDownEvent = o, this.handleCanvasPanUsingWheelOrSpaceDrag(o))) return;
      if (this.setState({ lastPointerDownWith: o.pointerType, cursorButton: "down" }), this.savePointer(o.clientX, o.clientY, "down"), o.button === Vs.ERASER && this.state.activeTool.type !== lr.eraser) {
        this.setState({ activeTool: Wn(this.state, { type: lr.eraser, lastActiveToolBeforeEraser: this.state.activeTool }) }, () => {
          this.handleCanvasPointerDown(o);
          let x = () => {
            E(), S == null || S(), tl(this.state) && this.setState({ activeTool: Wn(this.state, { ...this.state.activeTool.lastActiveTool || { type: lr.selection }, lastActiveToolBeforeEraser: null }) });
          }, E = gn(window, "pointerup", x, { once: !0 }), S;
          requestAnimationFrame(() => {
            S = this.missingPointerEventCleanupEmitter.once(x);
          });
        });
        return;
      }
      if (o.button !== Vs.MAIN && o.button !== Vs.TOUCH && o.button !== Vs.ERASER || _t.pointers.size > 1) return;
      let f = this.initialPointerDownState(o);
      if (this.setState({ selectedElementsAreBeingDragged: !1 }), this.handleDraggingScrollBar(o, f) || (this.clearSelectionIfNotUsingSelection(), this.updateBindingEnabledOnPointerMove(o), this.handleSelectionOnPointerDown(o, f)) || !(!this.state.penMode || o.pointerType !== "touch" || this.state.activeTool.type === "selection" || this.state.activeTool.type === "text" || this.state.activeTool.type === "image")) return;
      if (this.state.activeTool.type === "text") this.handleTextOnPointerDown(o, f);
      else if (this.state.activeTool.type === "arrow" || this.state.activeTool.type === "line") this.handleLinearElementOnPointerDown(o, this.state.activeTool.type, f);
      else if (this.state.activeTool.type === "image") {
        Ht(this.interactiveCanvas, Ot.CROSSHAIR);
        let x = this.state.pendingImageElementId && this.scene.getElement(this.state.pendingImageElementId);
        if (!x) return;
        this.setState({ newElement: x, pendingImageElementId: null, multiElement: null });
        let { x: E, y: S } = en(o, this.state), _ = this.getTopLayerFrameAtSceneCoords({ x: E, y: S });
        le(x, { x: E, y: S, frameId: _ ? _.id : null });
      } else this.state.activeTool.type === "freedraw" ? this.handleFreeDrawElementOnPointerDown(o, this.state.activeTool.type, f) : this.state.activeTool.type === "custom" ? Qa(this.interactiveCanvas, this.state) : this.state.activeTool.type === lr.frame || this.state.activeTool.type === lr.magicframe ? this.createFrameElementOnPointerDown(f, this.state.activeTool.type) : this.state.activeTool.type === "laser" ? this.laserTrails.startPath(f.lastCoords.x, f.lastCoords.y) : this.state.activeTool.type !== "eraser" && this.state.activeTool.type !== "hand" && this.createGenericElementOnPointerDown(this.state.activeTool.type, f);
      (w = (y = this.props) == null ? void 0 : y.onPointerDown) == null || w.call(y, this.state.activeTool, f), this.onPointerDownEmitter.trigger(this.state.activeTool, f, o), this.state.activeTool.type === "eraser" && this.eraserTrail.startPath(f.lastCoords.x, f.lastCoords.y);
      let p = this.onPointerMoveFromPointerDownHandler(f), g = this.onPointerUpFromPointerDownHandler(f), b = this.onKeyDownFromPointerDownHandler(f), v = this.onKeyUpFromPointerDownHandler(f);
      this.missingPointerEventCleanupEmitter.once((x) => g(x || o.nativeEvent)), (!this.state.viewModeEnabled || this.state.activeTool.type === "laser") && (window.addEventListener("pointermove", p), window.addEventListener("pointerup", g), window.addEventListener("keydown", b), window.addEventListener("keyup", v), f.eventListeners.onMove = p, f.eventListeners.onUp = g, f.eventListeners.onKeyUp = v, f.eventListeners.onKeyDown = b);
    }), $(this, "handleCanvasPointerUp", (o) => {
      var f;
      this.removePointer(o), this.lastPointerUpEvent = o;
      let u = en({ clientX: o.clientX, clientY: o.clientY }, this.state), h = o.timeStamp - (((f = this.lastPointerDownEvent) == null ? void 0 : f.timeStamp) ?? 0);
      if (this.device.editor.isMobile && h < 300) {
        let p = this.getElementAtPosition(u.x, u.y);
        if (Bi(p) && this.isIframeLikeElementCenter(p, o, u.x, u.y)) {
          this.handleEmbeddableCenterClick(p);
          return;
        }
      }
      if (this.device.isTouchScreen) {
        let p = this.getElementAtPosition(u.x, u.y);
        this.hitLinkElement = this.getElementLinkAtPosition(u, p);
      }
      this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id] ? h < 300 && Bi(this.hitLinkElement) && !DN(this.hitLinkElement, this.scene.getNonDeletedElementsMap(), this.state, T(u.x, u.y)) ? this.handleEmbeddableCenterClick(this.hitLinkElement) : this.redirectToLink(o, this.device.isTouchScreen) : this.state.viewModeEnabled && this.setState({ activeEmbeddable: null, selectedElementIds: {} });
    }), $(this, "maybeOpenContextMenuAfterPointerDownOnTouchDevices", (o) => {
      o.pointerType === "touch" && (Nu = !1, Hs ? Nu = !0 : Hs = window.setTimeout(() => {
        Hs = 0, Nu || this.handleCanvasContextMenu(o);
      }, cY));
    }), $(this, "resetContextMenuTimer", () => {
      clearTimeout(Hs), Hs = 0, Nu = !1;
    }), $(this, "maybeCleanupAfterMissingPointerUp", (o) => {
      Yo == null || Yo(), this.missingPointerEventCleanupEmitter.trigger(o).clear();
    }), $(this, "handleCanvasPanUsingWheelOrSpaceDrag", (o) => {
      if (!(_t.pointers.size <= 1 && (o.button === Vs.WHEEL || o.button === Vs.MAIN && Ko || m0(this.state) || this.state.viewModeEnabled))) return !1;
      Au = !0, this.focusContainer(), this.state.editingTextElement || o.preventDefault();
      let u = !1, h = typeof window === void 0 ? !1 : /Linux/.test(window.navigator.platform);
      Ht(this.interactiveCanvas, Ot.GRABBING);
      let { clientX: f, clientY: p } = o, g = N5((v) => {
        let U = f - v.clientX, y = p - v.clientY;
        if (f = v.clientX, p = v.clientY, h && !u && (Math.abs(U) > 1 || Math.abs(y) > 1)) {
          u = !0;
          let w = (E) => {
            document.body.removeEventListener("paste", w), E.stopPropagation();
          }, x = () => {
            setTimeout(() => {
              document.body.removeEventListener("paste", w), window.removeEventListener("pointerup", x);
            }, 100);
          };
          document.body.addEventListener("paste", w), window.addEventListener("pointerup", x);
        }
        this.translateCanvas({ scrollX: this.state.scrollX - U / this.state.zoom.value, scrollY: this.state.scrollY - y / this.state.zoom.value });
      }), b = _n(Yo = () => {
        Yo = null, Au = !1, Ko || (this.state.viewModeEnabled ? Ht(this.interactiveCanvas, Ot.GRAB) : Qa(this.interactiveCanvas, this.state)), this.setState({ cursorButton: "up" }), this.savePointer(o.clientX, o.clientY, "up"), window.removeEventListener("pointermove", g), window.removeEventListener("pointerup", b), window.removeEventListener("blur", b), g.flush();
      });
      return window.addEventListener("blur", b), window.addEventListener("pointermove", g, { passive: !0 }), window.addEventListener("pointerup", b), !0;
    }), $(this, "clearSelectionIfNotUsingSelection", () => {
      this.state.activeTool.type !== "selection" && this.setState({ selectedElementIds: kt({}, this.state), selectedGroupIds: {}, editingGroupId: null, activeEmbeddable: null });
    }), $(this, "handleSelectionOnPointerDown", (o, u) => {
      var h;
      if (this.state.activeTool.type === "selection") {
        let f = this.scene.getNonDeletedElements(), p = this.scene.getNonDeletedElementsMap(), g = this.scene.getSelectedElements(this.state);
        if (g.length === 1 && !this.state.editingLinearElement && !Se(g[0]) && !(this.state.selectedLinearElement && this.state.selectedLinearElement.hoverPointIndex !== -1)) {
          let b = yE(f, this.state, u.origin.x, u.origin.y, this.state.zoom, o.pointerType, this.scene.getNonDeletedElementsMap(), this.device);
          b != null && (b.transformHandleType === "rotation" ? (this.setState({ resizingElement: b.element }), u.resize.handleType = b.transformHandleType) : (this.state.croppingElementId || this.setState({ resizingElement: b.element }), u.resize.handleType = b.transformHandleType));
        } else g.length > 1 && (u.resize.handleType = wE(Lt(g), u.origin.x, u.origin.y, this.state.zoom, o.pointerType, this.device));
        if (u.resize.handleType) u.resize.isResizing = !0, u.resize.offset = xa(Tle(u.resize.handleType, g, p, u.origin.x, u.origin.y)), g.length === 1 && et(g[0]) && g[0].points.length === 2 && (u.resize.arrowDirection = Ile(u.resize.handleType, g[0]));
        else {
          if (this.state.selectedLinearElement) {
            let U = this.state.editingLinearElement || this.state.selectedLinearElement, y = Ee.handlePointerDown(o, this, this.store, u.origin, U, this.scene);
            if (y.hitElement && (u.hit.element = y.hitElement), y.linearElementEditor && (this.setState({ selectedLinearElement: y.linearElementEditor }), this.state.editingLinearElement && this.setState({ editingLinearElement: y.linearElementEditor })), y.didAddPoint) return !0;
          }
          if (u.hit.element = u.hit.element ?? this.getElementAtPosition(u.origin.x, u.origin.y), this.hitLinkElement = this.getElementLinkAtPosition(u.origin, u.hit.element), this.hitLinkElement) return !0;
          if (this.state.croppingElementId && ((h = u.hit.element) == null ? void 0 : h.id) !== this.state.croppingElementId && this.finishImageCropping(), u.hit.element && this.getElementLinkAtPosition({ x: u.origin.x, y: u.origin.y }, u.hit.element)) return !1;
          u.hit.allHitElements = this.getElementsAtPosition(u.origin.x, u.origin.y);
          let b = u.hit.element, v = u.hit.allHitElements.some((U) => this.isASelectedElement(U));
          if ((b === null || !v) && !o.shiftKey && !u.hit.hasHitCommonBoundingBoxOfSelectedElements && this.clearSelection(b), this.state.editingLinearElement) this.setState({ selectedElementIds: kt({ [this.state.editingLinearElement.elementId]: !0 }, this.state) });
          else if (b != null) {
            if (o[H.CTRL_OR_CMD]) return this.state.selectedElementIds[b.id] || (u.hit.wasAddedToSelection = !0), this.setState((U) => ({ ...pie(U, b), previousSelectedElementIds: this.state.selectedElementIds })), !1;
            this.state.selectedElementIds[b.id] || (this.state.editingGroupId && !tf(b, this.state.editingGroupId) && this.setState({ selectedElementIds: kt({}, this.state), selectedGroupIds: {}, editingGroupId: null, activeEmbeddable: null }), !v && !u.hit.hasHitCommonBoundingBoxOfSelectedElements && (this.setState((U) => {
              var x;
              let y = { ...U.selectedElementIds, [b.id]: !0 }, w = [];
              if (Object.keys(U.selectedElementIds).forEach((E) => {
                let S = this.scene.getElement(E);
                S && w.push(S);
              }), Ve(b)) Ml(w, b.id).forEach((E) => {
                delete y[E.id];
              });
              else if (b.frameId) y[b.frameId] && delete y[b.id];
              else {
                let E = b.groupIds, S = new Set(E.flatMap((_) => ln(this.scene.getNonDeletedElements(), _)).filter((_) => Ve(_)).map((_) => _.id));
                S.size > 0 && w.forEach((_) => {
                  _.frameId && S.has(_.frameId) && (delete y[_.id], _.groupIds.flatMap((k) => ln(this.scene.getNonDeletedElements(), k)).forEach((k) => {
                    delete y[k.id];
                  }));
                });
              }
              return ((x = U.openDialog) == null ? void 0 : x.name) === "elementLinkSelector" && (b.groupIds.some((E) => U.selectedGroupIds[E]) || (y = { [b.id]: !0 })), { ...Hr({ editingGroupId: U.editingGroupId, selectedElementIds: y }, this.scene.getNonDeletedElements(), U, this), showHyperlinkPopup: b.link || ri(b) ? "info" : !1 };
            }), u.hit.wasAddedToSelection = !0));
          }
          this.setState({ previousSelectedElementIds: this.state.selectedElementIds });
        }
      }
      return !1;
    }), $(this, "handleTextOnPointerDown", (o, u) => {
      if (this.state.editingTextElement) return;
      let h = u.origin.x, f = u.origin.y, p = this.getElementAtPosition(h, f, { includeBoundTextElement: !0 }), g = this.getTextBindableContainerAtPosition(h, f);
      ra(p) && (g = p, h = p.x + p.width / 2, f = p.y + p.height / 2), this.startTextEditing({ sceneX: h, sceneY: f, insertAtParentCenter: !o.altKey, container: g, autoEdit: !1 }), fa(this.interactiveCanvas), this.state.activeTool.locked || this.setState({ activeTool: Wn(this.state, { type: "selection" }) });
    }), $(this, "handleFreeDrawElementOnPointerDown", (o, u, h) => {
      let [f, p] = Yn(h.origin.x, h.origin.y, null), g = this.getTopLayerFrameAtSceneCoords({ x: f, y: p }), b = o.pressure === 0.5, v = jie({ type: u, x: f, y: p, strokeColor: this.state.currentItemStrokeColor, backgroundColor: this.state.currentItemBackgroundColor, fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roughness: this.state.currentItemRoughness, opacity: this.state.currentItemOpacity, roundness: null, simulatePressure: b, locked: !1, frameId: g ? g.id : null, points: [T(0, 0)], pressures: b ? [] : [o.pressure] });
      this.scene.insertElement(v), this.setState((y) => {
        let w = { ...y.selectedElementIds };
        return delete w[v.id], { selectedElementIds: kt(w, y) };
      });
      let U = Sa(h.origin, this.scene.getNonDeletedElements(), this.scene.getNonDeletedElementsMap(), this.state.zoom);
      this.setState({ newElement: v, startBoundElement: U, suggestedBindings: [] });
    }), $(this, "insertIframeElement", ({ sceneX: o, sceneY: u, width: h, height: f }) => {
      var v;
      let [p, g] = Yn(o, u, (v = this.lastPointerDownEvent) != null && v[H.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), b = Xie({ type: "iframe", x: p, y: g, strokeColor: "transparent", backgroundColor: "transparent", fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roughness: this.state.currentItemRoughness, roundness: this.getCurrentItemRoundness("iframe"), opacity: this.state.currentItemOpacity, locked: !1, width: h, height: f });
      return this.scene.insertElement(b), b;
    }), $(this, "insertEmbeddableElement", ({ sceneX: o, sceneY: u, link: h }) => {
      var v;
      let [f, p] = Yn(o, u, (v = this.lastPointerDownEvent) != null && v[H.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), g = Wd(h);
      if (!g) return;
      g.error instanceof URIError && this.setToast({ message: N("toast.unrecognizedLinkFormat"), closable: !0 });
      let b = zx({ type: "embeddable", x: f, y: p, strokeColor: "transparent", backgroundColor: "transparent", fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roughness: this.state.currentItemRoughness, roundness: this.getCurrentItemRoundness("embeddable"), opacity: this.state.currentItemOpacity, locked: !1, width: g.intrinsicSize.w, height: g.intrinsicSize.h, link: h });
      return this.scene.insertElement(b), b;
    }), $(this, "createImageElement", ({ sceneX: o, sceneY: u, addToFrameUnderCursor: h = !0 }) => {
      var b;
      let [f, p] = Yn(o, u, (b = this.lastPointerDownEvent) != null && b[H.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), g = h ? this.getTopLayerFrameAtSceneCoords({ x: f, y: p }) : null;
      return UN({ type: "image", x: f, y: p, strokeColor: this.state.currentItemStrokeColor, backgroundColor: this.state.currentItemBackgroundColor, fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roughness: this.state.currentItemRoughness, roundness: null, opacity: this.state.currentItemOpacity, locked: !1, frameId: g ? g.id : null });
    }), $(this, "handleLinearElementOnPointerDown", (o, u, h) => {
      if (this.state.multiElement) {
        let { multiElement: f } = this.state;
        if (f.type === "line" && Us(f.points, this.state.zoom.value)) {
          le(f, { lastCommittedPoint: f.points[f.points.length - 1] }), this.actionManager.executeAction(ca);
          return;
        }
        if (Se(f) && f.points.length > 1) {
          le(f, { lastCommittedPoint: f.points[f.points.length - 1] }), this.actionManager.executeAction(ca);
          return;
        }
        let { x: p, y: g, lastCommittedPoint: b } = f;
        if (f.points.length > 1 && b && Tt(T(h.origin.x - p, h.origin.y - g), b) < up) {
          this.actionManager.executeAction(ca);
          return;
        }
        this.setState((v) => ({ selectedElementIds: kt({ ...v.selectedElementIds, [f.id]: !0 }, v) })), le(f, { lastCommittedPoint: f.points[f.points.length - 1] }), Ht(this.interactiveCanvas, Ot.POINTER);
      } else {
        let [f, p] = Yn(h.origin.x, h.origin.y, o[H.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), g = this.getTopLayerFrameAtSceneCoords({ x: f, y: p }), { currentItemStartArrowhead: b, currentItemEndArrowhead: v } = this.state, [U, y] = u === "arrow" ? [b, v] : [null, null], w = u === "arrow" ? z8({ type: u, x: f, y: p, strokeColor: this.state.currentItemStrokeColor, backgroundColor: this.state.currentItemBackgroundColor, fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roughness: this.state.currentItemRoughness, opacity: this.state.currentItemOpacity, roundness: this.state.currentItemArrowType === br.round ? { type: Jn.PROPORTIONAL_RADIUS } : null, startArrowhead: U, endArrowhead: y, locked: !1, frameId: g ? g.id : null, elbowed: this.state.currentItemArrowType === br.elbow, fixedSegments: this.state.currentItemArrowType === br.elbow ? [] : null }) : xc({ type: u, x: f, y: p, strokeColor: this.state.currentItemStrokeColor, backgroundColor: this.state.currentItemBackgroundColor, fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roughness: this.state.currentItemRoughness, opacity: this.state.currentItemOpacity, roundness: this.state.currentItemRoundness === "round" ? { type: Jn.PROPORTIONAL_RADIUS } : null, locked: !1, frameId: g ? g.id : null });
        this.setState((E) => {
          let S = { ...E.selectedElementIds };
          return delete S[w.id], { selectedElementIds: kt(S, E) };
        }), le(w, { points: [...w.points, T(0, 0)] });
        let x = Sa(h.origin, this.scene.getNonDeletedElements(), this.scene.getNonDeletedElementsMap(), this.state.zoom, Se(w), Se(w));
        this.scene.insertElement(w), this.setState({ newElement: w, startBoundElement: x, suggestedBindings: [] });
      }
    }), $(this, "createGenericElementOnPointerDown", (o, u) => {
      var v;
      let [h, f] = Yn(u.origin.x, u.origin.y, (v = this.lastPointerDownEvent) != null && v[H.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), p = this.getTopLayerFrameAtSceneCoords({ x: h, y: f }), g = { x: h, y: f, strokeColor: this.state.currentItemStrokeColor, backgroundColor: this.state.currentItemBackgroundColor, fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roughness: this.state.currentItemRoughness, opacity: this.state.currentItemOpacity, roundness: this.getCurrentItemRoundness(o), locked: !1, frameId: p ? p.id : null }, b;
      o === "embeddable" ? b = zx({ type: "embeddable", ...g }) : b = kl({ type: o, ...g }), b.type === "selection" ? this.setState({ selectionElement: b }) : (this.scene.insertElement(b), this.setState({ multiElement: null, newElement: b }));
    }), $(this, "createFrameElementOnPointerDown", (o, u) => {
      var b;
      let [h, f] = Yn(o.origin.x, o.origin.y, (b = this.lastPointerDownEvent) != null && b[H.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), p = { x: h, y: f, opacity: this.state.currentItemOpacity, locked: !1, ...vn }, g = u === lr.magicframe ? y7(p) : F8(p);
      this.scene.insertElement(g), this.setState({ multiElement: null, newElement: g });
    }), $(this, "restoreReadyToEraseElements", () => {
      this.elementsPendingErasure = /* @__PURE__ */ new Set(), this.triggerRender();
    }), $(this, "eraseElements", () => {
      let o = !1, u = this.scene.getElementsIncludingDeleted().map((h) => this.elementsPendingErasure.has(h.id) || h.frameId && this.elementsPendingErasure.has(h.frameId) || sn(h) && this.elementsPendingErasure.has(h.containerId) ? (o = !0, at(h, { isDeleted: !0 })) : h);
      this.elementsPendingErasure = /* @__PURE__ */ new Set(), o && (this.store.shouldCaptureIncrement(), this.scene.replaceAllElements(u));
    }), $(this, "initializeImage", async ({ imageFile: o, imageElement: u, showCursorImagePreview: h = !1 }) => {
      var v, U, y, w, x;
      if (!Ec(o)) throw new Error(N("errors.unsupportedFileType"));
      let f = o.type;
      if (Ht(this.interactiveCanvas, "wait"), f === $e.svg) try {
        o = kE(Zx(await o.text()), o.name);
      } catch (E) {
        throw console.warn(E), new Error(N("errors.svgImageInsertError"));
      }
      let p = await (((U = (v = this.props).generateIdForFile) == null ? void 0 : U.call(v, o)) || Wle(o));
      if (!p) throw console.warn("Couldn't generate file id or the supplied `generateIdForFile` didn't resolve to one."), new Error(N("errors.imageInsertError"));
      if (!((y = this.files[p]) != null && y.dataURL)) {
        try {
          o = await I7(o, { maxWidthOrHeight: gY });
        } catch (E) {
          console.error("Error trying to resizing image file on insertion", E);
        }
        if (o.size > Hw) throw new Error(N("errors.fileTooBig", { maxSize: `${Math.trunc(Hw / 1024 / 1024)}MB` }));
      }
      if (h) {
        let E = (w = this.files[p]) == null ? void 0 : w.dataURL, S = E && Vle(E);
        this.setImagePreviewCursor(S || o);
      }
      let g = ((x = this.files[p]) == null ? void 0 : x.dataURL) || await _E(o), b = le(u, { fileId: p }, !1);
      return new Promise(async (E, S) => {
        var _;
        try {
          this.addMissingFiles([{ mimeType: f, id: p, dataURL: g, created: Date.now(), lastRetrieved: Date.now() }]);
          let k = this.imageCache.get(p);
          k || (this.addNewImagesToImageCache(), await this.updateImageCache([b])), (k == null ? void 0 : k.image) instanceof Promise && await k.image, this.state.pendingImageElementId !== b.id && ((_ = this.state.newElement) == null ? void 0 : _.id) !== b.id && this.initializeImageDimensions(b, !0), E(b);
        } catch (k) {
          console.error(k), S(new Error(N("errors.imageInsertError")));
        } finally {
          h || fa(this.interactiveCanvas);
        }
      });
    }), $(this, "insertImageElement", async (o, u, h) => {
      if (!this.isToolSupported("image")) {
        this.setState({ errorMessage: N("errors.imageToolNotSupported") });
        return;
      }
      this.scene.insertElement(o);
      try {
        return await this.initializeImage({ imageFile: u, imageElement: o, showCursorImagePreview: h });
      } catch (f) {
        return le(o, { isDeleted: !0 }), this.actionManager.executeAction(ca), this.setState({ errorMessage: f.message || N("errors.imageInsertError") }), null;
      }
    }), $(this, "setImagePreviewCursor", async (o) => {
      let u;
      try {
        u = await I7(o, { maxWidthOrHeight: 96 });
      } catch (f) {
        throw f.cause === "UNSUPPORTED" ? new Error(N("errors.unsupportedFileType")) : f;
      }
      let h = await _E(u);
      if (o.type === $e.svg) {
        let f = await MN(h), p = Math.min(f.height, 96), g = p * (f.width / f.height);
        g > 96 && (g = 96, p = g * (f.height / f.width));
        let b = document.createElement("canvas");
        b.height = p, b.width = g, b.getContext("2d").drawImage(f, 0, 0, g, p), h = b.toDataURL($e.svg);
      }
      this.state.pendingImageElementId && Ht(this.interactiveCanvas, `url(${h}) 4 4, auto`);
    }), $(this, "onImageAction", async ({ insertOnCanvasDirectly: o }) => {
      try {
        let u = this.state.width / 2 + this.state.offsetLeft, h = this.state.height / 2 + this.state.offsetTop, { x: f, y: p } = en({ clientX: u, clientY: h }, this.state), g = await H8({ description: "Image", extensions: Object.keys(p0) }), b = this.createImageElement({ sceneX: f, sceneY: p, addToFrameUnderCursor: !1 });
        o ? (this.insertImageElement(b, g), this.initializeImageDimensions(b), this.setState({ selectedElementIds: kt({ [b.id]: !0 }, this.state) }, () => {
          this.actionManager.executeAction(ca);
        })) : this.setState({ pendingImageElementId: b.id }, () => {
          this.insertImageElement(b, g, !0);
        });
      } catch (u) {
        u.name !== "AbortError" ? console.error(u) : console.warn(u), this.setState({ pendingImageElementId: null, newElement: null, activeTool: Wn(this.state, { type: "selection" }) }, () => {
          this.actionManager.executeAction(ca);
        });
      }
    }), $(this, "initializeImageDimensions", (o, u = !1) => {
      var f;
      let h = zi(o) && ((f = this.imageCache.get(o.fileId)) == null ? void 0 : f.image);
      if (!h || h instanceof Promise) {
        if (o.width < ec / this.state.zoom.value && o.height < ec / this.state.zoom.value) {
          let p = 100 / this.state.zoom.value;
          le(o, { x: o.x - p / 2, y: o.y - p / 2, width: p, height: p });
        }
        return;
      }
      if (u || o.width < ec / this.state.zoom.value && o.height < ec / this.state.zoom.value) {
        let p = Math.max(this.state.height - 120, 160), g = Math.min(p, Math.floor(this.state.height * 0.5) / this.state.zoom.value), b = Math.min(h.naturalHeight, g), v = b * (h.naturalWidth / h.naturalHeight), U = o.x + o.width / 2 - v / 2, y = o.y + o.height / 2 - b / 2;
        le(o, { x: U, y, width: v, height: b, crop: null });
      }
    }), $(this, "updateImageCache", async (o, u = this.files) => {
      let { updatedFiles: h, erroredFiles: f } = await TN({ imageCache: this.imageCache, fileIds: o.map((p) => p.fileId), files: u });
      if (h.size || f.size) for (let p of o) h.has(p.fileId) && wn.delete(p);
      return f.size && this.scene.replaceAllElements(this.scene.getElementsIncludingDeleted().map((p) => zi(p) && f.has(p.fileId) ? at(p, { status: "error" }) : p)), { updatedFiles: h, erroredFiles: f };
    }), $(this, "addNewImagesToImageCache", async (o = IN(this.scene.getNonDeletedElements()), u = this.files) => {
      let h = o.filter((f) => !f.isDeleted && !this.imageCache.has(f.fileId));
      if (h.length) {
        let { updatedFiles: f } = await this.updateImageCache(h, u);
        f.size && this.scene.triggerUpdate();
      }
    }), $(this, "scheduleImageRefresh", Of(() => {
      this.addNewImagesToImageCache();
    }, sY)), $(this, "updateBindingEnabledOnPointerMove", (o) => {
      let u = Wre(o);
      this.state.isBindingEnabled !== u && this.setState({ isBindingEnabled: u });
    }), $(this, "maybeSuggestBindingAtCursor", (o, u) => {
      let h = Sa(o, this.scene.getNonDeletedElements(), this.scene.getNonDeletedElementsMap(), this.state.zoom, !1, u);
      this.setState({ suggestedBindings: h != null ? [h] : [] });
    }), $(this, "maybeSuggestBindingsForLinearElementAtCoords", (o, u, h) => {
      if (!u.length) return;
      let f = u.reduce((p, g) => {
        let b = Sa(g, this.scene.getNonDeletedElements(), this.scene.getNonDeletedElementsMap(), this.state.zoom, Se(o), Se(o));
        return b != null && !qA(o, h == null ? void 0 : h.id, b) && p.push(b), p;
      }, []);
      this.setState({ suggestedBindings: f });
    }), $(this, "handleInteractiveCanvasRef", (o) => {
      var u, h;
      o !== null ? (this.interactiveCanvas = o, this.interactiveCanvas.addEventListener("touchstart", this.onTouchStart, { passive: !1 }), this.interactiveCanvas.addEventListener("touchend", this.onTouchEnd)) : ((u = this.interactiveCanvas) == null || u.removeEventListener("touchstart", this.onTouchStart), (h = this.interactiveCanvas) == null || h.removeEventListener("touchend", this.onTouchEnd));
    }), $(this, "handleAppOnDrop", async (o) => {
      var b, v, U, y;
      let { file: u, fileHandle: h } = await Kle(o), { x: f, y: p } = en(o, this.state);
      try {
        if (Ec(u) && this.isToolSupported("image")) {
          if ((u == null ? void 0 : u.type) === $e.png || (u == null ? void 0 : u.type) === $e.svg) try {
            let x = await pD(u, this.state, this.scene.getElementsIncludingDeleted(), h);
            this.syncActionResult({ ...x, appState: { ...x.appState || this.state, isLoading: !1 }, replaceFiles: !0, captureUpdate: ne.IMMEDIATELY });
            return;
          } catch (x) {
            if (x.name !== "EncodingError") throw new Error(N("alerts.couldNotLoadInvalidFile"));
          }
          let w = this.createImageElement({ sceneX: f, sceneY: p });
          this.insertImageElement(w, u), this.initializeImageDimensions(w), this.setState({ selectedElementIds: kt({ [w.id]: !0 }, this.state) });
          return;
        }
      } catch (w) {
        return this.setState({ isLoading: !1, errorMessage: w.message });
      }
      let g = o.dataTransfer.getData($e.excalidrawlib);
      if (g && typeof g == "string") {
        try {
          let w = mD(g);
          this.addElementsFromPasteOrLibrary({ elements: RR(w), position: o, files: null });
        } catch (w) {
          this.setState({ errorMessage: w.message });
        }
        return;
      }
      if (u && await this.loadFileToCanvas(u, h), (v = (b = o.dataTransfer) == null ? void 0 : b.types) == null ? void 0 : v.includes("text/plain")) {
        let w = (U = o.dataTransfer) == null ? void 0 : U.getData("text");
        if (w && yp(w, this.props.validateEmbeddable) && (/^(http|https):\/\/[^\s/$.?#].[^\s]*$/.test(w) || ((y = Wd(w)) == null ? void 0 : y.type) === "video")) {
          let x = this.insertEmbeddableElement({ sceneX: f, sceneY: p, link: _i(w) });
          x && this.setState({ selectedElementIds: { [x.id]: !0 } });
        }
      }
    }), $(this, "loadFileToCanvas", async (o, u) => {
      o = await yU(o);
      try {
        let h = this.scene.getElementsIncludingDeleted(), f;
        try {
          f = await fD(o, this.state, h, u);
        } catch (p) {
          let g = p instanceof hc;
          if (g && p.code === "IMAGE_NOT_CONTAINS_SCENE_DATA" && !this.isToolSupported("image")) {
            this.setState({ isLoading: !1, errorMessage: N("errors.imageToolNotSupported") });
            return;
          }
          let b = N(g ? "alerts.cannotRestoreFromImage" : "alerts.couldNotLoadInvalidFile");
          this.setState({ isLoading: !1, errorMessage: b });
        }
        if (!f) return;
        f.type === $e.excalidraw ? (xs(h.concat(f.data.elements)), this.store.updateSnapshot(Ge(h), this.state), this.setState({ isLoading: !0 }), this.syncActionResult({ ...f.data, appState: { ...f.data.appState || this.state, isLoading: !1 }, replaceFiles: !0, captureUpdate: ne.IMMEDIATELY })) : f.type === $e.excalidrawlib && await this.library.updateLibrary({ libraryItems: o, merge: !0, openLibraryMenu: !0 }).catch((p) => {
          console.error(p), this.setState({ errorMessage: N("errors.importLibraryError") });
        });
      } catch (h) {
        this.setState({ isLoading: !1, errorMessage: h.message });
      }
    }), $(this, "handleCanvasContextMenu", (o) => {
      if (o.preventDefault(), ("pointerType" in o.nativeEvent && o.nativeEvent.pointerType === "touch" || "pointerType" in o.nativeEvent && o.nativeEvent.pointerType === "pen" && o.button !== Vs.SECONDARY) && this.state.activeTool.type !== "selection") return;
      let { x: u, y: h } = en(o, this.state), f = this.getElementAtPosition(u, h, { preferSelected: !0, includeLockedElements: !0 }), p = this.scene.getSelectedElements(this.state), g = this.isHittingCommonBoundingBoxOfSelectedElements({ x: u, y: h }, p), b = f || g ? "element" : "canvas", v = this.excalidrawContainerRef.current, { top: U, left: y } = v.getBoundingClientRect(), w = o.clientX - y, x = o.clientY - U;
      tn("contextMenu", "openContextMenu", b), this.setState({ ...f && !this.state.selectedElementIds[f.id] ? { ...this.state, ...Hr({ editingGroupId: this.state.editingGroupId, selectedElementIds: { [f.id]: !0 } }, this.scene.getNonDeletedElements(), this.state, this), selectedLinearElement: et(f) ? new Ee(f) : null } : this.state, showHyperlinkPopup: !1 }, () => {
        this.setState({ contextMenu: { top: x, left: w, items: this.getContextMenuItems(b) } });
      });
    }), $(this, "maybeDragNewGenericElement", (o, u, h = !0) => {
      var E, S, _;
      let f = this.state.selectionElement, p = o.lastCoords;
      if (f && this.state.activeTool.type !== "eraser") {
        SE({ newElement: f, elementType: this.state.activeTool.type, originX: o.origin.x, originY: o.origin.y, x: p.x, y: p.y, width: Dr(o.origin.x, p.x), height: Dr(o.origin.y, p.y), shouldMaintainAspectRatio: Eu(u), shouldResizeFromCenter: Y6(u), zoom: this.state.zoom.value, informMutation: h });
        return;
      }
      let g = this.state.newElement;
      if (!g) return;
      let [b, v] = Yn(p.x, p.y, u[H.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), U = zi(g) && ((E = this.imageCache.get(g.fileId)) == null ? void 0 : E.image), y = U && !(U instanceof Promise) ? U.width / U.height : null;
      this.maybeCacheReferenceSnapPoints(u, [g]);
      let { snapOffset: w, snapLines: x } = Cie(g, this, u, { x: o.originInGrid.x + (((S = this.state.originSnapOffset) == null ? void 0 : S.x) ?? 0), y: o.originInGrid.y + (((_ = this.state.originSnapOffset) == null ? void 0 : _.y) ?? 0) }, { x: b - o.originInGrid.x, y: v - o.originInGrid.y }, this.scene.getNonDeletedElementsMap());
      b += w.x, v += w.y, this.setState({ snapLines: x }), SE({ newElement: g, elementType: this.state.activeTool.type, originX: o.originInGrid.x, originY: o.originInGrid.y, x: b, y: v, width: Dr(o.originInGrid.x, b), height: Dr(o.originInGrid.y, v), shouldMaintainAspectRatio: Mt(g) ? !Eu(u) : Eu(u), shouldResizeFromCenter: Y6(u), zoom: this.state.zoom.value, widthAspectRatio: y, originOffset: this.state.originSnapOffset, informMutation: h }), this.setState({ newElement: g }), (this.state.activeTool.type === lr.frame || this.state.activeTool.type === lr.magicframe) && this.setState({ elementsToHighlight: xp(this.scene.getNonDeletedElements(), g, this.state, this.scene.getNonDeletedElementsMap()) });
    }), $(this, "maybeHandleCrop", (o, u) => {
      var v;
      if (!this.state.croppingElementId) return !1;
      let h = o.resize.handleType, f = o.lastCoords, [p, g] = Yn(f.x - o.resize.offset.x, f.y - o.resize.offset.y, u[H.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), b = this.scene.getNonDeletedElementsMap().get(this.state.croppingElementId);
      if (h && b && Mt(b)) {
        let U = o.originalElements.get(b.id), y = zi(b) && ((v = this.imageCache.get(b.fileId)) == null ? void 0 : v.image);
        if (U && Mt(U) && y && !(y instanceof Promise)) {
          let [w, x] = Yn(f.x, f.y, u[H.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), E = { x: w - o.originInGrid.x, y: x - o.originInGrid.y };
          this.maybeCacheReferenceSnapPoints(u, [b]);
          let { snapOffset: S, snapLines: _ } = $x([b], [U], this, u, E, h);
          le(b, hre(b, h, y.naturalWidth, y.naturalHeight, p + S.x, g + S.y, u.shiftKey ? U.width / U.height : void 0)), ui(b, this.scene.getNonDeletedElementsMap(), { newSize: { width: b.width, height: b.height } }), this.setState({ isCropping: h && h !== "rotation", snapLines: _ });
        }
        return !0;
      }
      return !1;
    }), $(this, "maybeHandleResize", (o, u) => {
      let h = this.scene.getSelectedElements(this.state), f = h.filter((y) => Ve(y)), p = o.resize.handleType;
      if (f.length > 0 && p === "rotation" || h.length === 1 && Se(h[0]) || this.state.croppingElementId) return !1;
      this.setState({ isResizing: p && p !== "rotation", isRotating: p === "rotation", activeEmbeddable: null });
      let g = o.lastCoords, [b, v] = Yn(g.x - o.resize.offset.x, g.y - o.resize.offset.y, u[H.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), U = /* @__PURE__ */ new Map();
      if (f.forEach((y) => {
        Ml(this.scene.getNonDeletedElements(), y.id).forEach((w) => {
          U.set(y.id + w.id, { x: w.x - y.x, y: w.y - y.y });
        });
      }), !this.state.selectedElementsAreBeingDragged) {
        let [y, w] = Yn(g.x, g.y, u[H.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), x = { x: y - o.originInGrid.x, y: w - o.originInGrid.y }, E = [...o.originalElements.values()];
        this.maybeCacheReferenceSnapPoints(u, h);
        let { snapOffset: S, snapLines: _ } = $x(h, ct(E, this.state), this, u, x, p);
        b += S.x, v += S.y, this.setState({ snapLines: _ });
      }
      if (_le(o.originalElements, p, h, this.scene.getElementsMapIncludingDeleted(), this.scene, bh(u), Y6(u), h.some((y) => Mt(y)) ? !Eu(u) : Eu(u), b, v, o.resize.center.x, o.resize.center.y)) {
        let y = Z6(h, this.scene.getNonDeletedElementsMap(), this.state.zoom), w = /* @__PURE__ */ new Set();
        return f.forEach((x) => {
          xp(this.scene.getNonDeletedElements(), x, this.state, this.scene.getNonDeletedElementsMap()).forEach((E) => w.add(E));
        }), this.setState({ elementsToHighlight: [...w], suggestedBindings: y }), !0;
      }
      return !1;
    }), $(this, "getContextMenuItems", (o) => {
      let u = [];
      return u.push(OS, PS), o === "canvas" ? this.state.viewModeEnabled ? [...u, FS, e3, v_, t3] : [LS, ir, OS, PS, $S, ir, Wue, dfe, ir, FS, Zhe, e3, v_, t3] : (u.push($S), this.state.viewModeEnabled ? [Ip, ...u] : [ir, RS, Ip, LS, ir, Lme, Rme, Pme, ir, C1e, ir, ...u, ir, Phe, Ohe, ir, Fhe, wge, Jhe, Qhe, nfe, zhe, ir, Xhe, ir, Fue, zue, Bue, Hue, ir, Khe, Yhe, ir, k1e, ir, NR, KR, ir, jue, cfe, ir, tR]);
    }), $(this, "handleWheel", _n((o) => {
      if (!(o.target instanceof HTMLCanvasElement || o.target instanceof HTMLTextAreaElement || o.target instanceof HTMLIFrameElement)) {
        o[H.CTRL_OR_CMD] && o.preventDefault();
        return;
      }
      if (o.preventDefault(), Au) return;
      let { deltaX: u, deltaY: h } = o;
      if (o.metaKey || o.ctrlKey) {
        let f = Math.sign(h), p = Yg * 100, g = Math.abs(h), b = h;
        g > p && (b = p * f);
        let v = this.state.zoom.value - b / 100;
        v += Math.log10(Math.max(1, this.state.zoom.value)) * -f * Math.min(1, g / 20), this.translateCanvas((U) => ({ ...mc({ viewportX: this.lastViewportPosition.x, viewportY: this.lastViewportPosition.y, nextZoom: as(v) }, U), shouldCacheIgnoreZoom: !0 })), this.resetShouldCacheIgnoreZoomDebounced();
        return;
      }
      if (o.shiftKey) {
        this.translateCanvas(({ zoom: f, scrollX: p }) => ({ scrollX: p - (h || u) / f.value }));
        return;
      }
      this.translateCanvas(({ zoom: f, scrollX: p, scrollY: g }) => ({ scrollX: p - u / f.value, scrollY: g - h / f.value }));
    })), $(this, "savePointer", (o, u, h) => {
      var b, v;
      if (!o || !u) return;
      let { x: f, y: p } = en({ clientX: o, clientY: u }, this.state), g = { x: f, y: p, tool: this.state.activeTool.type === "laser" ? "laser" : "pointer" };
      (v = (b = this.props).onPointerUpdate) == null || v.call(b, { pointer: g, button: h, pointersMap: _t.pointers });
    }), $(this, "resetShouldCacheIgnoreZoomDebounced", b0(() => {
      this.unmounted || this.setState({ shouldCacheIgnoreZoom: !1 });
    }, 300)), $(this, "updateDOMRect", (o) => {
      var u;
      if ((u = this.excalidrawContainerRef) != null && u.current) {
        let h = this.excalidrawContainerRef.current, { width: f, height: p, left: g, top: b } = h.getBoundingClientRect(), { width: v, height: U, offsetTop: y, offsetLeft: w } = this.state;
        if (f === v && p === U && g === w && b === y) {
          o && o();
          return;
        }
        this.setState({ width: f, height: p, offsetLeft: g, offsetTop: b }, () => {
          o && o();
        });
      }
    }), $(this, "refresh", () => {
      this.setState({ ...this.getCanvasOffsets() });
    });
    let n = El(), { excalidrawAPI: r, viewModeEnabled: i = !1, zenModeEnabled: a = !1, gridModeEnabled: l = !1, objectsSnapModeEnabled: s = !1, theme: c = n.theme, name: d = `${N("labels.untitled")}-${Kw()}` } = t;
    if (this.state = { ...n, theme: c, isLoading: !0, ...this.getCanvasOffsets(), viewModeEnabled: i, zenModeEnabled: a, objectsSnapModeEnabled: s, gridModeEnabled: l ?? n.gridModeEnabled, name: d, width: window.innerWidth, height: window.innerHeight }, this.id = l8(), this.library = new yfe(this), this.actionManager = new A1e(this.syncActionResult, () => this.state, () => this.scene.getElementsIncludingDeleted(), this), this.scene = new Es(), this.canvas = document.createElement("canvas"), this.rc = Po.canvas(this.canvas), this.renderer = new k_(this.scene), this.visibleElements = [], this.store = new Qie(), this.history = new YS(), r) {
      let o = { updateScene: this.updateScene, updateLibrary: this.library.updateLibrary, addFiles: this.addFiles, resetScene: this.resetScene, getSceneElementsIncludingDeleted: this.getSceneElementsIncludingDeleted, history: { clear: this.resetHistory }, scrollToContent: this.scrollToContent, getSceneElements: this.getSceneElements, getAppState: () => this.state, getFiles: () => this.files, getName: this.getName, registerAction: (u) => {
        this.actionManager.registerAction(u);
      }, refresh: this.refresh, setToast: this.setToast, id: this.id, setActiveTool: this.setActiveTool, setCursor: this.setCursor, resetCursor: this.resetCursor, updateFrameRendering: this.updateFrameRendering, toggleSidebar: this.toggleSidebar, onChange: (u) => this.onChangeEmitter.on(u), onPointerDown: (u) => this.onPointerDownEmitter.on(u), onPointerUp: (u) => this.onPointerUpEmitter.on(u), onScrollChange: (u) => this.onScrollChangeEmitter.on(u), onUserFollow: (u) => this.onUserFollowEmitter.on(u) };
      typeof r == "function" ? r(o) : console.error("excalidrawAPI should be a function!");
    }
    this.excalidrawContainerValue = { container: this.excalidrawContainerRef.current, id: this.id }, this.fonts = new ds(this.scene), this.history = new YS(), this.actionManager.registerAll(v7), this.actionManager.registerAction(T1e(this.history, this.store)), this.actionManager.registerAction(I1e(this.history, this.store));
  }
  onWindowMessage(t) {
    if (t.origin !== "https://player.vimeo.com" && t.origin !== "https://www.youtube.com") return;
    let n = null;
    try {
      n = JSON.parse(t.data);
    } catch {
    }
    if (n) switch (t.origin) {
      case "https://player.vimeo.com":
        if (n.method === "paused") {
          let r = null, i = document.body.querySelectorAll("iframe.excalidraw__embeddable");
          if (!i) break;
          for (let a of i) a.contentWindow === t.source && (r = a.contentWindow);
          r == null || r.postMessage(JSON.stringify({ method: n.value ? "play" : "pause", value: !0 }), "*");
        }
        break;
      case "https://www.youtube.com":
        if (n.event === "infoDelivery" && n.info && n.id && typeof n.info.playerState == "number") {
          let r = n.id, i = n.info.playerState;
          Object.values(T1).includes(i) && F5.set(r, i);
        }
        break;
    }
  }
  cacheEmbeddableRef(t, n) {
    n && this.iFrameRefs.set(t.id, n);
  }
  getHTMLIFrameElement(t) {
    return this.iFrameRefs.get(t.id);
  }
  handleEmbeddableCenterClick(t) {
    var r, i, a, l;
    if (((r = this.state.activeEmbeddable) == null ? void 0 : r.element) === t && ((i = this.state.activeEmbeddable) == null ? void 0 : i.state) === "active" || (setTimeout(() => {
      this.setState({ activeEmbeddable: { element: t, state: "active" }, selectedElementIds: { [t.id]: !0 }, newElement: null, selectionElement: null });
    }, 100), qs(t))) return;
    let n = this.getHTMLIFrameElement(t);
    if (n != null && n.contentWindow) {
      if (n.src.includes("youtube")) {
        let s = F5.get(t.id);
        switch (s || (F5.set(t.id, T1.UNSTARTED), n.contentWindow.postMessage(JSON.stringify({ event: "listening", id: t.id }), "*")), s) {
          case T1.PLAYING:
          case T1.BUFFERING:
            (a = n.contentWindow) == null || a.postMessage(JSON.stringify({ event: "command", func: "pauseVideo", args: "" }), "*");
            break;
          default:
            (l = n.contentWindow) == null || l.postMessage(JSON.stringify({ event: "command", func: "playVideo", args: "" }), "*");
        }
      }
      n.src.includes("player.vimeo.com") && n.contentWindow.postMessage(JSON.stringify({ method: "paused" }), "*");
    }
  }
  isIframeLikeElementCenter(t, n, r, i) {
    var a, l;
    return t && !n.altKey && !n.shiftKey && !n.metaKey && !n.ctrlKey && (((a = this.state.activeEmbeddable) == null ? void 0 : a.element) !== t || ((l = this.state.activeEmbeddable) == null ? void 0 : l.state) === "hover" || !this.state.activeEmbeddable) && r >= t.x + t.width / 3 && r <= t.x + 2 * t.width / 3 && i >= t.y + t.height / 3 && i <= t.y + 2 * t.height / 3;
  }
  renderEmbeddables() {
    let t = this.state.zoom.value, n = this.state.width, r = this.state.height, i = this.scene.getNonDeletedElements().filter((a) => ri(a) && this.embedsValidationStatus.get(a.id) === !0 || qs(a));
    return m(ge, { children: i.map((a) => {
      var f, p, g, b, v, U, y, w, x;
      let { x: l, y: s } = wa({ sceneX: a.x, sceneY: a.y }, this.state), c = Hm(a, n, r, this.state, this.scene.getNonDeletedElementsMap()), d = this.initializedEmbeds.has(a.id);
      if (c && !d && this.initializedEmbeds.add(a.id), !(c || d)) return null;
      let o;
      if (qs(a)) {
        o = null;
        let E = (((f = a.customData) == null ? void 0 : f.generationData) ?? this.magicGenerations.get(a.id)) || { status: "error", message: "No generation data", code: "ERR_NO_GENERATION_DATA" };
        if (E.status === "done") {
          let S = E.html;
          o = { intrinsicSize: { w: a.width, h: a.height }, type: "document", srcdoc: () => S };
        } else if (E.status === "pending") o = { intrinsicSize: { w: a.width, h: a.height }, type: "document", srcdoc: () => Uh(`
                    <style>
                      html, body {
                        width: 100%;
                        height: 100%;
                        color: ${this.state.theme === gt.DARK ? "white" : "black"};
                      }
                      body {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-direction: column;
                        gap: 1rem;
                      }

                      .Spinner {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        margin-left: auto;
                        margin-right: auto;
                      }

                      .Spinner svg {
                        animation: rotate 1.6s linear infinite;
                        transform-origin: center center;
                        width: 40px;
                        height: 40px;
                      }

                      .Spinner circle {
                        stroke: currentColor;
                        animation: dash 1.6s linear 0s infinite;
                        stroke-linecap: round;
                      }

                      @keyframes rotate {
                        100% {
                          transform: rotate(360deg);
                        }
                      }

                      @keyframes dash {
                        0% {
                          stroke-dasharray: 1, 300;
                          stroke-dashoffset: 0;
                        }
                        50% {
                          stroke-dasharray: 150, 300;
                          stroke-dashoffset: -200;
                        }
                        100% {
                          stroke-dasharray: 1, 300;
                          stroke-dashoffset: -280;
                        }
                      }
                    </style>
                    <div class="Spinner">
                      <svg
                        viewBox="0 0 100 100"
                      >
                        <circle
                          cx="50"
                          cy="50"
                          r="46"
                          stroke-width="8"
                          fill="none"
                          stroke-miter-limit="10"
                        />
                      </svg>
                    </div>
                    <div>Generating...</div>
                  `) };
        else {
          let S;
          E.code === "ERR_GENERATION_INTERRUPTED" ? S = "Generation was interrupted..." : S = E.message || "Generation failed", o = { intrinsicSize: { w: a.width, h: a.height }, type: "document", srcdoc: () => Uh(`
                    <style>
                    html, body {
                      height: 100%;
                    }
                      body {
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        color: ${ht.red[3]};
                      }
                      h1, h3 {
                        margin-top: 0;
                        margin-bottom: 0.5rem;
                      }
                    </style>
                    <h1>Error!</h1>
                    <h3>${S}</h3>
                  `) };
        }
      } else o = Wd(hN(a.link || ""));
      let u = ((p = this.state.activeEmbeddable) == null ? void 0 : p.element) === a && ((g = this.state.activeEmbeddable) == null ? void 0 : g.state) === "active", h = ((b = this.state.activeEmbeddable) == null ? void 0 : b.element) === a && ((v = this.state.activeEmbeddable) == null ? void 0 : v.state) === "hover";
      return m("div", { className: Me("excalidraw__embeddable-container", { "is-hovered": h }), style: { transform: c ? `translate(${l - this.state.offsetLeft}px, ${s - this.state.offsetTop}px) scale(${t})` : "none", display: c ? "block" : "none", opacity: OA(a, hi(a, this.scene.getNonDeletedElementsMap()), this.elementsPendingErasure, null, ((U = this.state.openDialog) == null ? void 0 : U.name) === "elementLinkSelector" ? NI : 1), "--embeddable-radius": `${Aa(Math.min(a.width, a.height), a)}px` }, children: D("div", { className: "excalidraw__embeddable-container__inner", style: { width: c ? `${a.width}px` : 0, height: c ? `${a.height}px` : 0, transform: c ? `rotate(${a.angle}rad)` : "none", pointerEvents: u ? yd.enabled : yd.disabled }, children: [h && m("div", { className: "excalidraw__embeddable-hint", children: N("buttons.embeddableInteractionButton") }), m("div", { className: "excalidraw__embeddable__outer", style: { padding: `${a.strokeWidth}px` }, children: (ri(a) ? (w = (y = this.props).renderEmbeddable) == null ? void 0 : w.call(y, a, this.state) : null) ?? m("iframe", { ref: (E) => this.cacheEmbeddableRef(a, E), className: "excalidraw__embeddable", srcDoc: (o == null ? void 0 : o.type) === "document" ? o.srcdoc(this.state.theme) : void 0, src: (o == null ? void 0 : o.type) !== "document" ? (o == null ? void 0 : o.link) ?? "" : void 0, scrolling: "no", referrerPolicy: "no-referrer-when-downgrade", title: "Excalidraw Embedded Content", allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture", allowFullScreen: !0, sandbox: `${(x = o == null ? void 0 : o.sandbox) != null && x.allowSameOrigin ? "allow-same-origin" : ""} allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox allow-presentation allow-downloads` }) })] }) }, a.id);
    }) });
  }
  toggleOverscrollBehavior(t) {
    document.documentElement.style.overscrollBehaviorX = t.type === "pointerenter" ? "none" : "auto";
  }
  render() {
    var o, u, h, f, p, g, b, v;
    let t = this.scene.getSelectedElements(this.state), { renderTopRightUI: n, renderCustomStats: r } = this.props, i = this.scene.getSceneNonce(), { elementsMap: a, visibleElements: l } = this.renderer.getRenderableElements({ sceneNonce: i, zoom: this.state.zoom, offsetLeft: this.state.offsetLeft, offsetTop: this.state.offsetTop, scrollX: this.state.scrollX, scrollY: this.state.scrollY, height: this.state.height, width: this.state.width, editingTextElement: this.state.editingTextElement, newElementId: (o = this.state.newElement) == null ? void 0 : o.id, pendingImageElementId: this.state.pendingImageElementId });
    this.visibleElements = l;
    let s = this.scene.getNonDeletedElementsMap(), c = "setPointerCapture" in HTMLElement.prototype ? !1 : this.state.selectionElement || this.state.newElement || this.state.selectedElementsAreBeingDragged || this.state.resizingElement || this.state.activeTool.type === "laser" && this.state.cursorButton === "down", d = t[0];
    return m("div", { className: Me("excalidraw excalidraw-container", { "excalidraw--view-mode": this.state.viewModeEnabled || ((u = this.state.openDialog) == null ? void 0 : u.name) === "elementLinkSelector", "excalidraw--mobile": this.device.editor.isMobile }), style: { "--ui-pointerEvents": c ? yd.disabled : yd.enabled, "--right-sidebar-width": "302px" }, ref: this.excalidrawContainerRef, onDrop: this.handleAppOnDrop, tabIndex: 0, onKeyDown: this.props.handleKeyboardGlobally ? void 0 : this.onKeyDown, onPointerEnter: this.toggleOverscrollBehavior, onPointerLeave: this.toggleOverscrollBehavior, children: m(qP.Provider, { value: this, children: m(ZP.Provider, { value: this.props, children: m(i9.Provider, { value: this.excalidrawContainerValue, children: m(r9.Provider, { value: this.device, children: m(s9.Provider, { value: this.setAppState, children: m(l9.Provider, { value: this.state, children: D(a9.Provider, { value: this.scene.getNonDeletedElements(), children: [D(o9.Provider, { value: this.actionManager, children: [m(Ame, { canvas: this.canvas, appState: this.state, files: this.files, setAppState: this.setAppState, actionManager: this.actionManager, elements: this.scene.getNonDeletedElements(), onLockToggle: this.toggleLock, onPenModeToggle: this.togglePenMode, onHandToolToggle: this.onHandToolToggle, langCode: df().code, renderTopRightUI: n, renderCustomStats: r, showExitZenModeBtn: typeof ((h = this.props) == null ? void 0 : h.zenModeEnabled) > "u" && this.state.zenModeEnabled, UIOptions: this.props.UIOptions, onExportImage: this.onExportImage, renderWelcomeScreen: !this.state.isLoading && this.state.showWelcomeScreen && this.state.activeTool.type === "selection" && !this.state.zenModeEnabled && !this.scene.getElementsIncludingDeleted().length, app: this, isCollaborating: this.props.isCollaborating, generateLinkForSelection: this.props.generateLinkForSelection, children: this.props.children }), m("div", { className: "excalidraw-textEditorContainer" }), m("div", { className: "excalidraw-contextMenuContainer" }), m("div", { className: "excalidraw-eye-dropper-container" }), m(uge, { trails: [this.laserTrails, this.eraserTrail] }), t.length === 1 && ((f = this.state.openDialog) == null ? void 0 : f.name) !== "elementLinkSelector" && this.state.showHyperlinkPopup && m(afe, { element: d, elementsMap: s, setAppState: this.setAppState, onLinkOpen: this.props.onLinkOpen, setToast: this.setToast, updateEmbedValidationStatus: this.updateEmbedValidationStatus }, d.id), this.props.aiEnabled !== !1 && t.length === 1 && pp(d) && m(C_, { element: d, elementsMap: a, children: m(R5, { title: N("labels.convertToCode"), icon: hA, checked: !1, onChange: () => this.onMagicFrameGenerate(d, "button") }) }), t.length === 1 && qs(d) && ((g = (p = d.customData) == null ? void 0 : p.generationData) == null ? void 0 : g.status) === "done" && D(C_, { element: d, elementsMap: a, children: [m(R5, { title: N("labels.copySource"), icon: C8, checked: !1, onChange: () => this.onIframeSrcCopy(d) }), m(R5, { title: "Enter fullscreen", icon: zZ, checked: !1, onChange: () => {
      let U = this.getHTMLIFrameElement(d);
      if (U) try {
        U.requestFullscreen(), this.setState({ activeEmbeddable: { element: d, state: "active" }, selectedElementIds: { [d.id]: !0 }, newElement: null, selectionElement: null });
      } catch (y) {
        console.warn(y), this.setState({ errorMessage: "Couldn't enter fullscreen" });
      }
    } })] }), this.state.toast !== null && m(Dme, { message: this.state.toast.message, onClose: () => this.setToast(null), duration: this.state.toast.duration, closable: this.state.toast.closable }), this.state.contextMenu && m(D1e, { items: this.state.contextMenu.items, top: this.state.contextMenu.top, left: this.state.contextMenu.left, actionManager: this.actionManager, onClose: (U) => {
      this.setState({ contextMenu: null }, () => {
        this.focusContainer(), U == null || U();
      });
    } }), m(dge, { canvas: this.canvas, rc: this.rc, elementsMap: a, allElementsMap: s, visibleElements: l, sceneNonce: i, selectionNonce: (b = this.state.selectionElement) == null ? void 0 : b.versionNonce, scale: window.devicePixelRatio, appState: this.state, renderConfig: { imageCache: this.imageCache, isExporting: !1, renderGrid: nf(this), canvasBackgroundColor: this.state.viewBackgroundColor, embedsValidationStatus: this.embedsValidationStatus, elementsPendingErasure: this.elementsPendingErasure, pendingFlowchartNodes: this.flowChartCreator.pendingNodes } }), this.state.newElement && m(kge, { appState: this.state, scale: window.devicePixelRatio, rc: this.rc, elementsMap: a, allElementsMap: s, renderConfig: { imageCache: this.imageCache, isExporting: !1, renderGrid: !1, canvasBackgroundColor: this.state.viewBackgroundColor, embedsValidationStatus: this.embedsValidationStatus, elementsPendingErasure: this.elementsPendingErasure, pendingFlowchartNodes: null } }), m(sge, { containerRef: this.excalidrawContainerRef, canvas: this.interactiveCanvas, elementsMap: a, visibleElements: l, allElementsMap: s, selectedElements: t, sceneNonce: i, selectionNonce: (v = this.state.selectionElement) == null ? void 0 : v.versionNonce, scale: window.devicePixelRatio, appState: this.state, device: this.device, renderInteractiveSceneCallback: this.renderInteractiveSceneCallback, handleCanvasRef: this.handleInteractiveCanvasRef, onContextMenu: this.handleCanvasContextMenu, onPointerMove: this.handleCanvasPointerMove, onPointerUp: this.handleCanvasPointerUp, onPointerCancel: this.removePointer, onTouchMove: this.handleTouchMove, onPointerDown: this.handleCanvasPointerDown, onDoubleClick: this.handleCanvasDoubleClick }), this.state.userToFollow && m(gge, { width: this.state.width, height: this.state.height, userToFollow: this.state.userToFollow, onDisconnect: this.maybeUnfollowRemoteUser }), this.renderFrameNames()] }), this.renderEmbeddables()] }) }) }) }) }) }) }) });
  }
  setPlugins(t) {
    Object.assign(this.plugins, t);
  }
  async onMagicFrameGenerate(t, n) {
    var l;
    let r = (l = this.plugins.diagramToCode) == null ? void 0 : l.generate;
    if (!r) {
      this.setState({ errorMessage: "No diagram to code plugin found" });
      return;
    }
    let i = uU(this.scene.getNonDeletedElements(), t).filter((s) => !pp(s));
    if (!i.length) {
      n === "button" ? (this.setState({ errorMessage: "Cannot generate from an empty frame" }), tn("ai", "generate (no-children)", "d2c")) : this.setActiveTool({ type: "magicframe" });
      return;
    }
    let a = this.insertIframeElement({ sceneX: t.x + t.width + 30, sceneY: t.y, width: t.width, height: t.height });
    if (a) {
      this.updateMagicGeneration({ frameElement: a, data: { status: "pending" } }), this.setState({ selectedElementIds: { [a.id]: !0 } }), tn("ai", "generate (start)", "d2c");
      try {
        let { html: s } = await r({ frame: t, children: i });
        if (tn("ai", "generate (success)", "d2c"), !s.trim()) {
          this.updateMagicGeneration({ frameElement: a, data: { status: "error", code: "ERR_OAI", message: "Nothing genereated :(" } });
          return;
        }
        let c = s.includes("<!DOCTYPE html>") && s.includes("</html>") ? s.slice(s.indexOf("<!DOCTYPE html>"), s.indexOf("</html>") + 7) : s;
        this.updateMagicGeneration({ frameElement: a, data: { status: "done", html: c } });
      } catch (s) {
        tn("ai", "generate (failed)", "d2c"), this.updateMagicGeneration({ frameElement: a, data: { status: "error", code: "ERR_OAI", message: s.message || "Unknown error during generation" } });
      }
    }
  }
  onIframeSrcCopy(t) {
    var n, r;
    ((r = (n = t.customData) == null ? void 0 : n.generationData) == null ? void 0 : r.status) === "done" && (jf(t.customData.generationData.html), this.setToast({ message: "copied to clipboard", closable: !1, duration: 1500 }));
  }
  clearImageShapeCache(t) {
    let n = t ?? this.files;
    this.scene.getNonDeletedElements().forEach((r) => {
      zi(r) && n[r.fileId] && (this.imageCache.delete(r.fileId), wn.delete(r));
    });
  }
  async componentDidMount() {
    var t;
    this.unmounted = !1, this.excalidrawContainerValue.container = this.excalidrawContainerRef.current, (st.MODE === oi.TEST || st.DEV) && (this.setState.bind(this), Object.defineProperties(window.h, { state: { configurable: !0, get: () => this.state }, setState: { configurable: !0, value: (...n) => this.setState(...n) }, app: { configurable: !0, value: this }, history: { configurable: !0, value: this.history }, store: { configurable: !0, value: this.store }, fonts: { configurable: !0, value: this.fonts } })), this.store.onStoreIncrementEmitter.on((n) => {
      this.history.record(n.elementsChange, n.appStateChange);
    }), this.scene.onUpdate(this.triggerRender), this.addEventListeners(), this.props.autoFocus && this.excalidrawContainerRef.current && this.focusContainer(), bs() || (this.refreshViewportBreakpoints(), this.refreshEditorBreakpoints()), t7 && this.excalidrawContainerRef.current && (this.resizeObserver = new ResizeObserver(() => {
      this.refreshEditorBreakpoints(), this.updateDOMRect();
    }), (t = this.resizeObserver) == null || t.observe(this.excalidrawContainerRef.current)), new URLSearchParams(window.location.search.slice(1)).has("web-share-target") ? this.restoreFileFromShare() : this.updateDOMRect(this.initializeScene), qK() && !lq() && this.setState({ errorMessage: m($me, {}) });
  }
  componentWillUnmount() {
    var t, n;
    (t = window.launchQueue) == null || t.setConsumer(() => {
    }), this.renderer.destroy(), this.scene.destroy(), this.scene = new Es(), this.fonts = new ds(this.scene), this.renderer = new k_(this.scene), this.files = {}, this.imageCache.clear(), (n = this.resizeObserver) == null || n.disconnect(), this.unmounted = !0, this.removeEventListeners(), this.library.destroy(), this.laserTrails.stop(), this.eraserTrail.stop(), this.onChangeEmitter.clear(), this.store.onStoreIncrementEmitter.clear(), wn.destroy(), Gl.destroy(), clearTimeout(Hs), Qn.clearCache(), Hr.clearCache(), Hs = 0, document.documentElement.style.overscrollBehaviorX = "";
  }
  removeEventListeners() {
    this.onRemoveEventListenersEmitter.trigger();
  }
  addEventListeners() {
    this.removeEventListeners(), this.props.handleKeyboardGlobally && this.onRemoveEventListenersEmitter.once(gn(document, "keydown", this.onKeyDown, !1)), this.onRemoveEventListenersEmitter.once(gn(this.excalidrawContainerRef.current, "wheel", this.handleWheel, { passive: !1 }), gn(window, "message", this.onWindowMessage, !1), gn(document, "pointerup", this.removePointer, { passive: !1 }), gn(document, "copy", this.onCopy, { passive: !1 }), gn(document, "keyup", this.onKeyUp, { passive: !0 }), gn(document, "pointermove", this.updateCurrentCursorPosition, { passive: !1 }), gn(document.fonts, "loadingdone", (t) => {
      let n = t.fontfaces;
      this.fonts.onLoaded(n);
    }, { passive: !1 }), gn(document, "gesturestart", this.onGestureStart, !1), gn(document, "gesturechange", this.onGestureChange, !1), gn(document, "gestureend", this.onGestureEnd, !1), gn(window, "focus", () => {
      this.maybeCleanupAfterMissingPointerUp(null), this.triggerRender(!0);
    }, { passive: !1 })), !this.state.viewModeEnabled && (this.onRemoveEventListenersEmitter.once(gn(document, "fullscreenchange", this.onFullscreenChange, { passive: !1 }), gn(document, "paste", this.pasteFromClipboard, { passive: !1 }), gn(document, "cut", this.onCut, { passive: !1 }), gn(window, "resize", this.onResize, !1), gn(window, "unload", this.onUnload, !1), gn(window, "blur", this.onBlur, !1), gn(this.excalidrawContainerRef.current, "wheel", this.handleWheel, { passive: !1 }), gn(this.excalidrawContainerRef.current, "dragover", this.disableEvent, !1), gn(this.excalidrawContainerRef.current, "drop", this.disableEvent, !1)), this.props.detectScroll && this.onRemoveEventListenersEmitter.once(gn(GY(this.excalidrawContainerRef.current), "scroll", this.onScroll, { passive: !1 })));
  }
  componentDidUpdate(t, n) {
    var s, c, d, o, u, h, f, p, g, b;
    this.updateEmbeddables();
    let r = this.scene.getElementsIncludingDeleted(), i = this.scene.getElementsMapIncludingDeleted(), a = this.scene.getNonDeletedElementsMap();
    !this.state.showWelcomeScreen && !r.length && this.setState({ showWelcomeScreen: !0 }), t.UIOptions.dockedSidebarBreakpoint !== this.props.UIOptions.dockedSidebarBreakpoint && this.refreshEditorBreakpoints(), n.userToFollow && !this.state.collaborators.has(n.userToFollow.socketId) && this.maybeUnfollowRemoteUser(), (n.zoom.value !== this.state.zoom.value || n.scrollX !== this.state.scrollX || n.scrollY !== this.state.scrollY) && ((c = (s = this.props) == null ? void 0 : s.onScrollChange) == null || c.call(s, this.state.scrollX, this.state.scrollY, this.state.zoom), this.onScrollChangeEmitter.trigger(this.state.scrollX, this.state.scrollY, this.state.zoom)), n.userToFollow !== this.state.userToFollow && (n.userToFollow && this.onUserFollowEmitter.trigger({ userToFollow: n.userToFollow, action: "UNFOLLOW" }), this.state.userToFollow && this.onUserFollowEmitter.trigger({ userToFollow: this.state.userToFollow, action: "FOLLOW" })), Object.keys(this.state.selectedElementIds).length && tl(this.state) && this.setState({ activeTool: Wn(this.state, { type: "selection" }) }), this.state.activeTool.type === "eraser" && n.theme !== this.state.theme && mN(this.interactiveCanvas, this.state.theme), n.activeTool.type === "selection" && this.state.activeTool.type !== "selection" && this.state.showHyperlinkPopup && this.setState({ showHyperlinkPopup: !1 }), t.langCode !== this.props.langCode && this.updateLanguage(), tl(n) && !tl(this.state) && this.eraserTrail.endPath(), t.viewModeEnabled !== this.props.viewModeEnabled && this.setState({ viewModeEnabled: !!this.props.viewModeEnabled }), n.viewModeEnabled !== this.state.viewModeEnabled && (this.addEventListeners(), this.deselectElements()), (((d = n.openDialog) == null ? void 0 : d.name) === "elementLinkSelector" || ((o = this.state.openDialog) == null ? void 0 : o.name) === "elementLinkSelector") && ((u = n.openDialog) == null ? void 0 : u.name) !== ((h = this.state.openDialog) == null ? void 0 : h.name) && (this.deselectElements(), this.setState({ hoveredElementIds: {} })), t.zenModeEnabled !== this.props.zenModeEnabled && this.setState({ zenModeEnabled: !!this.props.zenModeEnabled }), t.theme !== this.props.theme && this.props.theme && this.setState({ theme: this.props.theme }), (f = this.excalidrawContainerRef.current) == null || f.classList.toggle("theme--dark", this.state.theme === gt.DARK), this.state.editingLinearElement && !this.state.selectedElementIds[this.state.editingLinearElement.elementId] && setTimeout(() => {
      this.state.editingLinearElement && this.actionManager.executeAction(ca);
    }), (p = this.state.editingTextElement) != null && p.isDeleted && this.setState({ editingTextElement: null }), this.state.selectedLinearElement && !this.state.selectedElementIds[this.state.selectedLinearElement.elementId] && this.setState({ selectedLinearElement: null });
    let { multiElement: l } = n;
    n.activeTool !== this.state.activeTool && l != null && fc(this.state) && hl(l, !1) && b7(l, this.state, xa(Ee.getPointAtIndexGlobalCoordinates(l, -1, a)), this.scene.getNonDeletedElementsMap(), this.scene.getNonDeletedElements()), this.store.commit(i, this.state), this.state.isLoading || ((b = (g = this.props).onChange) == null || b.call(g, r, this.state, this.files), this.onChangeEmitter.trigger(r, this.state, this.files));
  }
  static resetTapTwice() {
    Iu = !1;
  }
  async addElementsFromMixedContentPaste(t, { isPlainPaste: n, sceneX: r, sceneY: i }) {
    if (!n && t.some((a) => a.type === "imageUrl") && this.isToolSupported("image")) {
      let a = t.filter((u) => u.type === "imageUrl").map((u) => u.value), l = await Promise.all(a.map(async (u) => {
        try {
          return { file: await jle(u) };
        } catch (h) {
          let f = h.message;
          return h.cause === "FETCH_ERROR" ? f = N("errors.failedToFetchImage") : h.cause === "UNSUPPORTED" && (f = N("errors.unsupportedFileType")), { errorMessage: f };
        }
      })), s = i, c = !1, d = {};
      for (let u of l) if (u.file) {
        let h = this.createImageElement({ sceneX: r, sceneY: s }), f = await this.insertImageElement(h, u.file);
        f && (c || (c = !0, s -= f.height / 2), le(f, { y: s }, !1), s = h.y + h.height + 25, d[h.id] = !0);
      }
      this.setState({ selectedElementIds: kt(d, this.state) });
      let o = l.find((u) => !!u.errorMessage);
      o && o.errorMessage && this.setState({ errorMessage: o.errorMessage });
    } else {
      let a = t.filter((l) => l.type === "text");
      a.length && this.addTextFromPaste(a.map((l) => l.value).join(`

`), n);
    }
  }
  addTextFromPaste(t, n = !1) {
    let { x: r, y: i } = en({ clientX: this.lastViewportPosition.x, clientY: this.lastViewportPosition.y }, this.state), a = { x: r, y: i, strokeColor: this.state.currentItemStrokeColor, backgroundColor: this.state.currentItemBackgroundColor, fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roundness: null, roughness: this.state.currentItemRoughness, opacity: this.state.currentItemOpacity, text: t, fontSize: this.state.currentItemFontSize, fontFamily: this.state.currentItemFontFamily, textAlign: Ff, verticalAlign: mm, locked: !1 }, l = Wt({ fontSize: a.fontSize, fontFamily: a.fontFamily }), s = Yc(a.fontFamily), [c, , d] = $re(this.state), o = Math.max(Math.min((d - c) * 0.5, 800), 200), u = 10, h = i, f = n ? [t] : t.split(`
`), p = f.reduce((g, b, v) => {
      var y;
      let U = v0(b).trim();
      if (U.length) {
        let w = this.getTopLayerFrameAtSceneCoords({ x: r, y: h }), x = $r(U, l, s), E = x.width > o, S = E ? cd(U, l, o) : U;
        x = E ? $r(S, l, s) : x;
        let _ = r - x.width / 2, k = h - x.height / 2, M = Ai({ ...a, x: _, y: k, text: S, originalText: U, lineHeight: s, autoResize: !E, frameId: w ? w.id : null });
        g.push(M), h += M.height + u;
      } else (y = f[v - 1]) != null && y.trim() && (h += Wf(a.fontSize, s) + u);
      return g;
    }, []);
    p.length !== 0 && (this.scene.insertElements(p), this.setState({ selectedElementIds: kt(Object.fromEntries(p.map((g) => [g.id, !0])), this.state) }), !n && p.length > 1 && T_ === !1 && !this.device.editor.isMobile && (this.setToast({ message: N("toast.pasteAsSingleElement", { shortcut: ae("CtrlOrCmd+Shift+V") }), duration: 5e3 }), T_ = !0), this.store.shouldCaptureIncrement());
  }
  handleTextWysiwyg(t, { isExistingElement: n = !1 }) {
    let r = this.scene.getElementsMapIncludingDeleted(), i = (a, l) => {
      this.scene.replaceAllElements([...this.scene.getElementsIncludingDeleted().map((s) => s.id === t.id && we(s) ? at(s, { originalText: a, isDeleted: l ?? s.isDeleted, ...bN(s, xr(s, r), r, a) }) : s)]);
    };
    yge({ id: t.id, canvas: this.canvas, getViewportCoords: (a, l) => {
      let { x: s, y: c } = wa({ sceneX: a, sceneY: l }, this.state);
      return [s - this.state.offsetLeft, c - this.state.offsetTop];
    }, onChange: _n((a) => {
      i(a, !1), T7(t) && ui(t, this.scene.getNonDeletedElementsMap());
    }), onSubmit: _n(({ viaKeyboard: a, nextOriginalText: l }) => {
      let s = !l.trim();
      if (i(l, s), !s && a) {
        let c = t.containerId ? t.containerId : t.id;
        ga(() => {
          this.setState((d) => ({ selectedElementIds: kt({ ...d.selectedElementIds, [c]: !0 }, d) }));
        });
      }
      s && eN(this.scene.getNonDeletedElements(), [t]), (!s || n) && this.store.shouldCaptureIncrement(), ga(() => {
        this.setState({ newElement: null, editingTextElement: null });
      }), this.state.activeTool.locked && Qa(this.interactiveCanvas, this.state), this.focusContainer();
    }), element: t, excalidrawContainer: this.excalidrawContainerRef.current, app: this, autoSelect: !this.device.isTouchScreen }), this.deselectElements(), i(t.originalText, !1);
  }
  deselectElements() {
    this.setState({ selectedElementIds: kt({}, this.state), selectedGroupIds: {}, editingGroupId: null, activeEmbeddable: null });
  }
  getTextElementAtPosition(t, n) {
    let r = this.getElementAtPosition(t, n, { includeBoundTextElement: !0 });
    return r && we(r) && !r.isDeleted ? r : null;
  }
  getElementAtPosition(t, n, r) {
    let i = this.getElementsAtPosition(t, n, r == null ? void 0 : r.includeBoundTextElement, r == null ? void 0 : r.includeLockedElements);
    if (i.length > 1) {
      if (r != null && r.preferSelected) {
        for (let l = i.length - 1; l > -1; l--) if (this.state.selectedElementIds[i[l].id]) return i[l];
      }
      let a = i[i.length - 1];
      return Nd({ x: t, y: n, element: a, shape: Jl(a, this.scene.getNonDeletedElementsMap()), threshold: this.getElementHitThreshold() / 2, frameNameBound: Ve(a) ? this.frameNameBoundsCache.get(a) : null }) ? a : i[i.length - 2];
    }
    return i.length === 1 ? i[0] : null;
  }
  getElementsAtPosition(t, n, r = !1, i = !1) {
    let a = [], l = this.scene.getNonDeletedElementsMap();
    return (r && i ? this.scene.getNonDeletedElements() : this.scene.getNonDeletedElements().filter((s) => (i || !s.locked) && (r || !(we(s) && s.containerId)))).filter((s) => this.hitElement(t, n, s)).filter((s) => {
      let c = hi(s, l);
      return c && this.state.frameRendering.enabled && this.state.frameRendering.clip ? fE({ x: t, y: n }, c, l) : !0;
    }).filter((s) => qs(s) ? (a.push(s), !1) : !0).concat(a);
  }
  getElementHitThreshold() {
    return rY / this.state.zoom.value;
  }
  hitElement(t, n, r, i = !0) {
    if (i && this.state.selectedElementIds[r.id] && lD([r], this.state)) {
      let a = Hne(r, this.scene.getNonDeletedElementsMap(), Mt(r) ? 0 : this.getElementHitThreshold());
      if (Tm(T(t, n), a)) return !0;
    }
    return MA(t, n, IA(r, this.scene.getNonDeletedElementsMap())) ? !0 : Nd({ x: t, y: n, element: r, shape: Jl(r, this.scene.getNonDeletedElementsMap()), threshold: this.getElementHitThreshold(), frameNameBound: Ve(r) ? this.frameNameBoundsCache.get(r) : null });
  }
  getTextBindableContainerAtPosition(t, n) {
    let r = this.scene.getNonDeletedElements(), i = this.scene.getSelectedElements(this.state);
    if (i.length === 1) return yc(i[0], !1) ? i[0] : null;
    let a = null;
    for (let l = r.length - 1; l >= 0; --l) {
      if (r[l].isDeleted) continue;
      let [s, c, d, o] = tt(r[l], this.scene.getNonDeletedElementsMap());
      if (dt(r[l]) && Nd({ x: t, y: n, element: r[l], shape: Jl(r[l], this.scene.getNonDeletedElementsMap()), threshold: this.getElementHitThreshold() })) {
        a = r[l];
        break;
      } else if (s < t && t < d && c < n && n < o) {
        a = r[l];
        break;
      }
    }
    return yc(a, !1) ? a : null;
  }
  handleHoverSelectedLinearElement(t, n, r) {
    let i = this.scene.getNonDeletedElementsMap(), a = Ee.getElement(t.elementId, i);
    if (a) if (this.state.selectedLinearElement) {
      let l = -1, s = null;
      Nd({ x: n, y: r, element: a, shape: Jl(a, this.scene.getNonDeletedElementsMap()) }) ? (l = Ee.getPointIndexUnderCursor(a, i, this.state.zoom, n, r), s = Ee.getSegmentMidpointHitCoords(t, { x: n, y: r }, this.state, this.scene.getNonDeletedElementsMap()), (Se(a) ? l === 0 || l === a.points.length - 1 : l >= 0) || s ? Ht(this.interactiveCanvas, Ot.POINTER) : this.hitElement(n, r, a) && Ht(this.interactiveCanvas, Ot.MOVE)) : this.hitElement(n, r, a) && (!Se(a) || !(a.startBinding || a.endBinding)) && Ht(this.interactiveCanvas, Ot.MOVE), this.state.selectedLinearElement.hoverPointIndex !== l && this.setState({ selectedLinearElement: { ...this.state.selectedLinearElement, hoverPointIndex: l } }), Ee.arePointsEqual(this.state.selectedLinearElement.segmentMidPointHoveredCoords, s) || this.setState({ selectedLinearElement: { ...this.state.selectedLinearElement, segmentMidPointHoveredCoords: s } });
    } else Ht(this.interactiveCanvas, Ot.AUTO);
  }
  updateGestureOnPointerDown(t) {
    _t.pointers.set(t.pointerId, { x: t.clientX, y: t.clientY }), _t.pointers.size === 2 && (_t.lastCenter = qS(_t.pointers), _t.initialScale = this.state.zoom.value, _t.initialDistance = ZS(Array.from(_t.pointers.values())));
  }
  initialPointerDownState(t) {
    let n = en(t, this.state), r = this.scene.getSelectedElements(this.state), [i, a, l, s] = Lt(r), c = r.findIndex(Se) === 0;
    return { origin: n, withCmdOrCtrl: t[H.CTRL_OR_CMD], originInGrid: xa(Yn(n.x, n.y, t[H.CTRL_OR_CMD] || c ? null : this.getEffectiveGridSize())), scrollbars: t_($5, t.clientX - this.state.offsetLeft, t.clientY - this.state.offsetTop), lastCoords: { ...n }, originalElements: this.scene.getNonDeletedElements().reduce((d, o) => (d.set(o.id, dd(o)), d), /* @__PURE__ */ new Map()), resize: { handleType: !1, isResizing: !1, offset: { x: 0, y: 0 }, arrowDirection: "origin", center: { x: (l + i) / 2, y: (s + a) / 2 } }, hit: { element: null, allHitElements: [], wasAddedToSelection: !1, hasBeenDuplicated: !1, hasHitCommonBoundingBoxOfSelectedElements: this.isHittingCommonBoundingBoxOfSelectedElements(n, r) }, drag: { hasOccurred: !1, offset: null }, eventListeners: { onMove: null, onUp: null, onKeyUp: null, onKeyDown: null }, boxSelection: { hasOccurred: !1 } };
  }
  handleDraggingScrollBar(t, n) {
    if (!(n.scrollbars.isOverEither && !this.state.multiElement)) return !1;
    O5 = !0, n.lastCoords.x = t.clientX, n.lastCoords.y = t.clientY;
    let r = N5((a) => {
      a.target instanceof HTMLElement && this.handlePointerMoveOverScrollbars(a, n);
    }), i = _n(() => {
      Yo = null, O5 = !1, Qa(this.interactiveCanvas, this.state), this.setState({ cursorButton: "up" }), this.savePointer(t.clientX, t.clientY, "up"), window.removeEventListener("pointermove", r), window.removeEventListener("pointerup", i), r.flush();
    });
    return Yo = i, window.addEventListener("pointermove", r), window.addEventListener("pointerup", i), !0;
  }
  isASelectedElement(t) {
    return t != null && this.state.selectedElementIds[t.id];
  }
  isHittingCommonBoundingBoxOfSelectedElements(t, n) {
    if (n.length < 2) return !1;
    let r = this.getElementHitThreshold(), [i, a, l, s] = Lt(n);
    return t.x > i - r && t.x < l + r && t.y > a - r && t.y < s + r;
  }
  getCurrentItemRoundness(t) {
    return this.state.currentItemRoundness === "round" ? { type: ru(t) ? Jn.ADAPTIVE_RADIUS : Jn.PROPORTIONAL_RADIUS } : null;
  }
  maybeCacheReferenceSnapPoints(t, n, r = !1) {
    So({ event: t, app: this, selectedElements: n }) && (r || !Gl.getReferenceSnapPoints()) && Gl.setReferenceSnapPoints(Eie(this.scene.getNonDeletedElements(), n, this.state, this.scene.getNonDeletedElementsMap()));
  }
  maybeCacheVisibleGaps(t, n, r = !1) {
    So({ event: t, app: this, selectedElements: n }) && (r || !Gl.getVisibleGaps()) && Gl.setVisibleGaps(xie(this.scene.getNonDeletedElements(), n, this.state, this.scene.getNonDeletedElementsMap()));
  }
  onKeyDownFromPointerDownHandler(t) {
    return _n((n) => {
      this.maybeHandleResize(t, n) || this.maybeDragNewGenericElement(t, n);
    });
  }
  onKeyUpFromPointerDownHandler(t) {
    return _n((n) => {
      n.key === H.ALT && n.preventDefault(), !this.maybeHandleResize(t, n) && this.maybeDragNewGenericElement(t, n);
    });
  }
  onPointerMoveFromPointerDownHandler(t) {
    return N5((n) => {
      var o, u, h, f, p, g;
      if (((o = this.state.openDialog) == null ? void 0 : o.name) === "elementLinkSelector") return;
      let r = en(n, this.state);
      if (this.state.selectedLinearElement && this.state.selectedLinearElement.elbowed && this.state.selectedLinearElement.pointerDownState.segmentMidpoint.index) {
        let [b, v] = Yn(r.x, r.y, n[H.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), U = this.state.selectedLinearElement.pointerDownState.segmentMidpoint.index;
        if (U < 0) {
          let w = Ee.getSegmentMidpointHitCoords({ ...this.state.selectedLinearElement, segmentMidPointHoveredCoords: null }, { x: b, y: v }, this.state, this.scene.getNonDeletedElementsMap());
          U = w ? Ee.getSegmentMidPointIndex(this.state.selectedLinearElement, this.state, w, this.scene.getNonDeletedElementsMap()) : -1;
        }
        let y = Ee.moveFixedSegment(this.state.selectedLinearElement, U, b, v, this.scene.getNonDeletedElementsMap());
        ga(() => {
          this.state.selectedLinearElement && this.setState({ selectedLinearElement: { ...this.state.selectedLinearElement, segmentMidPointHoveredCoords: y.segmentMidPointHoveredCoords, pointerDownState: y.pointerDownState } });
        });
        return;
      }
      let i = this.lastPointerMoveCoords ?? t.origin;
      if (this.lastPointerMoveCoords = r, t.drag.offset === null && (t.drag.offset = xa(Ole(this.scene.getSelectedElements(this.state), t.origin.x, t.origin.y))), !(n.target instanceof HTMLElement) || this.handlePointerMoveOverScrollbars(n, t)) return;
      if (tl(this.state)) {
        this.handleEraser(n, t, r);
        return;
      }
      this.state.activeTool.type === "laser" && this.laserTrails.addPointToPath(r.x, r.y);
      let [a, l] = Yn(r.x, r.y, n[H.CTRL_OR_CMD] ? null : this.getEffectiveGridSize());
      if (!t.drag.hasOccurred && (this.state.activeTool.type === "arrow" || this.state.activeTool.type === "line") && Tt(T(r.x, r.y), T(t.origin.x, t.origin.y)) < ec) return;
      if (t.resize.isResizing && (t.lastCoords.x = r.x, t.lastCoords.y = r.y, this.maybeHandleCrop(t, n) || this.maybeHandleResize(t, n))) return !0;
      let s = this.scene.getNonDeletedElementsMap();
      if (this.state.selectedLinearElement) {
        let b = this.state.editingLinearElement || this.state.selectedLinearElement;
        if (Ee.shouldAddMidpoint(this.state.selectedLinearElement, r, this.state, s)) {
          let v = Ee.addMidpoint(this.state.selectedLinearElement, r, this, !n[H.CTRL_OR_CMD], s);
          if (!v) return;
          ga(() => {
            this.state.selectedLinearElement && this.setState({ selectedLinearElement: { ...this.state.selectedLinearElement, pointerDownState: v.pointerDownState, selectedPointsIndices: v.selectedPointsIndices } }), this.state.editingLinearElement && this.setState({ editingLinearElement: { ...this.state.editingLinearElement, pointerDownState: v.pointerDownState, selectedPointsIndices: v.selectedPointsIndices } });
          });
          return;
        } else if (b.pointerDownState.segmentMidpoint.value !== null && !b.pointerDownState.segmentMidpoint.added) return;
        if (Ee.handlePointDragging(n, this, r.x, r.y, (v, U) => {
          this.maybeSuggestBindingsForLinearElementAtCoords(v, U);
        }, b, this.scene)) {
          t.lastCoords.x = r.x, t.lastCoords.y = r.y, t.drag.hasOccurred = !0, this.state.editingLinearElement && !this.state.editingLinearElement.isDragging && this.setState({ editingLinearElement: { ...this.state.editingLinearElement, isDragging: !0 } }), this.state.selectedLinearElement.isDragging || this.setState({ selectedLinearElement: { ...this.state.selectedLinearElement, isDragging: !0 } });
          return;
        }
      }
      let c = t.hit.allHitElements.some((b) => this.isASelectedElement(b)), d = this.state.editingLinearElement && n.shiftKey && this.state.editingLinearElement.elementId === ((u = t.hit.element) == null ? void 0 : u.id);
      if ((c || t.hit.hasHitCommonBoundingBoxOfSelectedElements) && !d) {
        let b = this.scene.getSelectedElements(this.state);
        if (b.every((w) => w.locked)) return;
        let v = b.find((w) => Ve(w)), U = this.getTopLayerFrameAtSceneCoords(r), y = U && !v ? U : null;
        if (this.state.frameToHighlight !== y && ga(() => {
          this.setState({ frameToHighlight: y });
        }), t.drag.hasOccurred = !0, b.length > 0 && !t.withCmdOrCtrl && !this.state.editingTextElement && ((h = this.state.activeEmbeddable) == null ? void 0 : h.state) !== "active") {
          let w = { x: r.x - t.origin.x, y: r.y - t.origin.y }, x = [...t.originalElements.values()], E = n.shiftKey;
          if (E) {
            let k = Math.abs(w.x), M = Math.abs(w.y), A = E && k < M, L = E && k > M;
            A && (w.x = 0), L && (w.y = 0);
          }
          if (this.state.croppingElementId) {
            let k = this.scene.getNonDeletedElementsMap().get(this.state.croppingElementId);
            if (k && Mt(k) && k.crop !== null && t.hit.element === k) {
              let M = k.crop, A = zi(k) && ((f = this.imageCache.get(k.fileId)) == null ? void 0 : f.image);
              if (A && !(A instanceof Promise)) {
                let L = An(_r(r.x - i.x, r.y - i.y), Math.max(this.state.zoom.value, 2)), [R, z, F, W, B, j] = tt(k, s), V = Le(te(T(R, z), T(B, j), k.angle)), q = Le(te(T(F, z), T(B, j), k.angle)), oe = Le(te(T(R, W), T(B, j), k.angle)), Ue = Rr(wm(q, V)), fe = Rr(wm(oe, V)), Pe = _r(Xw(L, Ue), Xw(L, fe)), ze = { ...M, x: ft(M.x - Pe[0] * Math.sign(k.scale[0]), 0, A.naturalWidth - M.width), y: ft(M.y - Pe[1] * Math.sign(k.scale[1]), 0, A.naturalHeight - M.height) };
                le(k, { crop: ze });
                return;
              }
            }
          }
          this.maybeCacheVisibleGaps(n, b), this.maybeCacheReferenceSnapPoints(n, b);
          let { snapOffset: S, snapLines: _ } = Sie(x, w, this, n, this.scene.getNonDeletedElementsMap());
          if (this.setState({ snapLines: _ }), this.state.editingFrame || Rle(t, b, w, this.scene, S, n[H.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), this.setState({ selectedElementsAreBeingDragged: !0, selectionElement: null }), (b.length !== 1 || !Se(b[0])) && this.setState({ suggestedBindings: Z6(b, this.scene.getNonDeletedElementsMap(), this.state.zoom) }), n.altKey && !t.hit.hasBeenDuplicated) {
            t.hit.hasBeenDuplicated = !0;
            let k = [], M = [], A = /* @__PURE__ */ new Map(), L = /* @__PURE__ */ new Map(), R = t.hit.element, z = new Set(this.scene.getSelectedElements({ selectedElementIds: this.state.selectedElementIds, includeBoundTextElement: !0, includeElementsInFrames: !0 }).map((B) => B.id)), F = this.scene.getElementsIncludingDeleted();
            for (let B of F) {
              let j = z.has(B.id) || B.id === (R == null ? void 0 : R.id) && t.hit.wasAddedToSelection;
              if (Math.abs(B.x) > 1e7 || Math.abs(B.x) > 1e7 || Math.abs(B.width) > 1e7 || Math.abs(B.height) > 1e7) {
                console.error("Alt+dragging element in scene with invalid dimensions", B.x, B.y, B.width, B.height, j);
                return;
              }
              if (j) {
                let V = yN(this.state.editingGroupId, A, B);
                if (Math.abs(V.x) > 1e7 || Math.abs(V.x) > 1e7 || Math.abs(V.width) > 1e7 || Math.abs(V.height) > 1e7) {
                  console.error("Alt+dragging duplicated element with invalid dimensions", V.x, V.y, V.width, V.height);
                  return;
                }
                let q = t.originalElements.get(B.id);
                if (Math.abs(q.x) > 1e7 || Math.abs(q.x) > 1e7 || Math.abs(q.width) > 1e7 || Math.abs(q.height) > 1e7) {
                  console.error("Alt+dragging duplicated element with invalid dimensions", q.x, q.y, q.width, q.height);
                  return;
                }
                le(V, { x: q.x, y: q.y }), t.originalElements.set(V.id, V), k.push(V), M.push(B), L.set(B.id, V.id);
              } else k.push(B);
            }
            let W = [...k, ...M];
            W = ((g = (p = this.props).onDuplicate) == null ? void 0 : g.call(p, W, F)) || W, Cl(W, Ge(M)), dN(k, M, L), QA(W, M, L, "duplicatesServeAsOld"), YN(W, M, L), this.scene.replaceAllElements(W), this.maybeCacheVisibleGaps(n, b, !0), this.maybeCacheReferenceSnapPoints(n, b, !0);
          }
          return;
        }
      }
      if (this.state.selectionElement) t.lastCoords.x = r.x, t.lastCoords.y = r.y, this.maybeDragNewGenericElement(t, n);
      else {
        let b = this.state.newElement;
        if (!b) return;
        if (b.type === "freedraw") {
          let v = b.points, U = r.x - b.x, y = r.y - b.y, w = v.length > 0 && v[v.length - 1];
          if (!(w && w[0] === U && w[1] === y)) {
            let x = b.simulatePressure ? b.pressures : [...b.pressures, n.pressure];
            le(b, { points: [...v, T(U, y)], pressures: x }, !1), this.setState({ newElement: b });
          }
        } else if (et(b)) {
          t.drag.hasOccurred = !0;
          let v = b.points, U = a - b.x, y = l - b.y;
          bh(n) && v.length === 2 && ({ width: U, height: y } = C7(b.x, b.y, r.x, r.y)), v.length === 1 ? le(b, { points: [...v, T(U, y)] }, !1) : (v.length === 2 || v.length > 1 && Se(b)) && le(b, { points: [...v.slice(0, -1), T(U, y)] }, !1, { isDragging: !0 }), this.setState({ newElement: b }), hl(b, !1) && this.maybeSuggestBindingsForLinearElementAtCoords(b, [r], this.state.startBoundElement);
        } else t.lastCoords.x = r.x, t.lastCoords.y = r.y, this.maybeDragNewGenericElement(t, n, !1);
      }
      if (this.state.activeTool.type === "selection") {
        t.boxSelection.hasOccurred = !0;
        let b = this.scene.getNonDeletedElements();
        if (this.state.editingLinearElement) Ee.handleBoxSelection(n, this.state, this.setState.bind(this), this.scene.getNonDeletedElementsMap());
        else {
          let v = !0;
          !n.shiftKey && Qn(b, this.state) && (t.withCmdOrCtrl && t.hit.element ? this.setState((y) => Hr({ ...y, selectedElementIds: { [t.hit.element.id]: !0 } }, this.scene.getNonDeletedElements(), y, this)) : v = !1);
          let U = this.state.selectionElement ? fU(b, this.state.selectionElement, this.scene.getNonDeletedElementsMap(), !1) : [];
          this.setState((y) => {
            let w = { ...v && y.selectedElementIds, ...U.reduce((x, E) => (x[E.id] = !0, x), {}) };
            return t.hit.element && (U.length ? delete w[t.hit.element.id] : w[t.hit.element.id] = !0), y = v ? y : { ...y, selectedGroupIds: {}, editingGroupId: null }, { ...Hr({ editingGroupId: y.editingGroupId, selectedElementIds: w }, this.scene.getNonDeletedElements(), y, this), selectedLinearElement: U.length === 1 && et(U[0]) ? new Ee(U[0]) : null, showHyperlinkPopup: U.length === 1 && (U[0].link || ri(U[0])) ? "info" : !1 };
          });
        }
      }
    });
  }
  handlePointerMoveOverScrollbars(t, n) {
    if (n.scrollbars.isOverHorizontal) {
      let r = t.clientX, i = r - n.lastCoords.x;
      return this.translateCanvas({ scrollX: this.state.scrollX - i / this.state.zoom.value }), n.lastCoords.x = r, !0;
    }
    if (n.scrollbars.isOverVertical) {
      let r = t.clientY, i = r - n.lastCoords.y;
      return this.translateCanvas({ scrollY: this.state.scrollY - i / this.state.zoom.value }), n.lastCoords.y = r, !0;
    }
    return !1;
  }
  onPointerUpFromPointerDownHandler(t) {
    return _n((n) => {
      var g, b, v, U, y, w, x, E, S, _, k, M;
      this.removePointer(n), t.eventListeners.onMove && t.eventListeners.onMove.flush();
      let { newElement: r, resizingElement: i, croppingElementId: a, multiElement: l, activeTool: s, isResizing: c, isRotating: d, isCropping: o } = this.state;
      this.setState((A) => ({ isResizing: !1, isRotating: !1, isCropping: !1, resizingElement: null, selectionElement: null, frameToHighlight: null, elementsToHighlight: null, cursorButton: "up", snapLines: xu(A.snapLines, []), originSnapOffset: null })), this.lastPointerMoveCoords = null, Gl.setReferenceSnapPoints(null), Gl.setVisibleGaps(null), this.savePointer(n.clientX, n.clientY, "up"), this.setState({ selectedElementsAreBeingDragged: !1 });
      let u = this.scene.getNonDeletedElementsMap();
      if (t.drag.hasOccurred && ((b = (g = t.hit) == null ? void 0 : g.element) != null && b.id)) {
        let A = u.get(t.hit.element.id);
        Pa(A) && ((v = A.boundElements) == null || v.filter((L) => L.type === "arrow").map((L) => u.get(L.id)).filter((L) => Se(L)).forEach((L) => {
          L && le(L, {}, !0);
        }));
      }
      if (this.state.editingLinearElement) if (!t.boxSelection.hasOccurred && ((y = (U = t.hit) == null ? void 0 : U.element) == null ? void 0 : y.id) !== this.state.editingLinearElement.elementId) this.actionManager.executeAction(ca);
      else {
        let A = Ee.handlePointerUp(n, this.state.editingLinearElement, this.state, this.scene);
        A !== this.state.editingLinearElement && this.setState({ editingLinearElement: A, suggestedBindings: [] });
      }
      else if (this.state.selectedLinearElement) {
        if (this.state.selectedLinearElement.elbowed) {
          let A = Ee.getElement(this.state.selectedLinearElement.elementId, this.scene.getNonDeletedElementsMap());
          A && le(A, {}, !0);
        }
        if (((x = (w = t.hit) == null ? void 0 : w.element) == null ? void 0 : x.id) !== this.state.selectedLinearElement.elementId) this.scene.getSelectedElements(this.state).length > 1 && this.setState({ selectedLinearElement: null });
        else {
          let A = Ee.handlePointerUp(n, this.state.selectedLinearElement, this.state, this.scene), { startBindingElement: L, endBindingElement: R } = A, z = this.scene.getElement(A.elementId);
          hl(z) && s2(z, L, R, u, this.scene), A !== this.state.selectedLinearElement && this.setState({ selectedLinearElement: { ...A, selectedPointsIndices: null }, suggestedBindings: [] });
        }
      }
      if (this.missingPointerEventCleanupEmitter.clear(), window.removeEventListener("pointermove", t.eventListeners.onMove), window.removeEventListener("pointerup", t.eventListeners.onUp), window.removeEventListener("keydown", t.eventListeners.onKeyDown), window.removeEventListener("keyup", t.eventListeners.onKeyUp), this.state.pendingImageElementId && this.setState({ pendingImageElementId: null }), (S = (E = this.props) == null ? void 0 : E.onPointerUp) == null || S.call(E, s, t), this.onPointerUpEmitter.trigger(this.state.activeTool, t, n), (r == null ? void 0 : r.type) === "freedraw") {
        let A = en(n, this.state), L = r.points, R = A.x - r.x, z = A.y - r.y;
        R === L[0][0] && z === L[0][1] && (z += 1e-4, R += 1e-4);
        let F = r.simulatePressure ? [] : [...r.pressures, n.pressure];
        le(r, { points: [...L, T(R, z)], pressures: F, lastCommittedPoint: T(R, z) }), this.actionManager.executeAction(ca);
        return;
      }
      if (Mt(r)) {
        let A = r;
        try {
          this.initializeImageDimensions(A), this.setState({ selectedElementIds: kt({ [A.id]: !0 }, this.state) }, () => {
            this.actionManager.executeAction(ca);
          });
        } catch (L) {
          console.error(L), this.scene.replaceAllElements(this.scene.getElementsIncludingDeleted().filter((R) => R.id !== A.id)), this.actionManager.executeAction(ca);
        }
        return;
      }
      if (et(r)) {
        r.points.length > 1 && this.store.shouldCaptureIncrement();
        let A = en(n, this.state);
        !t.drag.hasOccurred && r && !l ? (le(r, { points: [...r.points, T(A.x - r.x, A.y - r.y)] }), this.setState({ multiElement: r, newElement: r })) : t.drag.hasOccurred && !l && (fc(this.state) && hl(r, !1) && b7(r, this.state, A, this.scene.getNonDeletedElementsMap(), this.scene.getNonDeletedElements()), this.setState({ suggestedBindings: [], startBoundElement: null }), s.locked ? this.setState((L) => ({ newElement: null })) : (fa(this.interactiveCanvas), this.setState((L) => ({ newElement: null, activeTool: Wn(this.state, { type: "selection" }), selectedElementIds: kt({ ...L.selectedElementIds, [r.id]: !0 }, L), selectedLinearElement: new Ee(r) }))), this.scene.triggerUpdate());
        return;
      }
      if (we(r)) {
        let A = v8(Wt({ fontSize: r.fontSize, fontFamily: r.fontFamily }), r.lineHeight);
        r.width < A && le(r, { autoResize: !0 }), this.resetCursor(), this.handleTextWysiwyg(r, { isExistingElement: !0 });
      }
      if (s.type !== "selection" && r && M0(r)) {
        this.updateScene({ elements: this.scene.getElementsIncludingDeleted().filter((A) => A.id !== r.id), appState: { newElement: null }, captureUpdate: ne.NEVER });
        return;
      }
      if (Ve(r)) {
        let A = mle(this.scene.getElementsIncludingDeleted(), r, this.scene.getNonDeletedElementsMap());
        this.scene.replaceAllElements(yh(this.scene.getElementsMapIncludingDeleted(), A, r, this.state));
      }
      if (r && (le(r, rD(r)), this.scene.triggerUpdate()), t.drag.hasOccurred) {
        let A = en(n, this.state);
        if (this.state.selectedLinearElement && this.state.selectedLinearElement.isDragging) {
          let L = this.scene.getElement(this.state.selectedLinearElement.elementId);
          if (L != null && L.frameId) {
            let R = hi(L, u);
            R && L && (ko(L, R, this.scene.getNonDeletedElementsMap()) || (le(L, { groupIds: [] }), b2([L], this.scene.getNonDeletedElementsMap()), this.scene.triggerUpdate()));
          }
        } else {
          let L = this.getTopLayerFrameAtSceneCoords(A), R = this.scene.getSelectedElements(this.state), z = this.scene.getElementsMapIncludingDeleted(), F = (W) => {
            if (W.length > 0) {
              for (let B of W) {
                let j = B.groupIds.indexOf(this.state.editingGroupId);
                le(B, { groupIds: B.groupIds.slice(0, j) }, !1);
              }
              z.forEach((B) => {
                B.groupIds.length && ln(z, B.groupIds[B.groupIds.length - 1]).length < 2 && le(B, { groupIds: [] }, !1);
              }), this.setState({ editingGroupId: null });
            }
          };
          if (L && !this.state.selectedElementIds[L.id]) {
            let W = R.filter((B) => B.frameId !== L.id && Bm(B, z, this.state));
            this.state.editingGroupId && F(W), z = yh(z, W, L, this.state);
          } else if (!L && this.state.editingGroupId) {
            let W = R.filter((B) => B.frameId && !Bm(B, z, this.state));
            F(W);
          }
          z = C0(z, this.state, this), this.scene.replaceAllElements(z);
        }
      }
      if (i && this.store.shouldCaptureIncrement(), i && M0(i) && this.updateScene({ elements: this.scene.getElementsIncludingDeleted().filter((A) => A.id !== i.id), captureUpdate: ne.NEVER }), t.resize.isResizing) {
        let A = C0(this.scene.getElementsIncludingDeleted(), this.state, this), L = this.scene.getSelectedElements(this.state).filter((R) => Ve(R));
        for (let R of L) A = JN(A, xp(this.scene.getElementsIncludingDeleted(), R, this.state, u), R, this);
        this.scene.replaceAllElements(A);
      }
      let h = t.hit.element;
      ((_ = this.state.selectedLinearElement) == null ? void 0 : _.elementId) !== (h == null ? void 0 : h.id) && et(h) && this.scene.getSelectedElements(this.state).length === 1 && this.setState({ selectedLinearElement: new Ee(h) }), (!a || a && (!h && !o || h && h.id !== a)) && this.finishImageCropping();
      let f = this.lastPointerDownEvent, p = this.lastPointerUpEvent || this.lastPointerMoveEvent;
      if (tl(this.state) && f && p) {
        if (this.eraserTrail.endPath(), Tt(T(f.clientX, f.clientY), T(p.clientX, p.clientY)) === 0) {
          let A = en({ clientX: p.clientX, clientY: p.clientY }, this.state);
          this.getElementsAtPosition(A.x, A.y).forEach((L) => this.elementsPendingErasure.add(L.id));
        }
        this.eraseElements();
        return;
      } else this.elementsPendingErasure.size && this.restoreReadyToEraseElements();
      if (h && !t.drag.hasOccurred && !t.hit.wasAddedToSelection && (!this.state.editingLinearElement || !t.boxSelection.hasOccurred) && (n.shiftKey && !this.state.editingLinearElement ? this.state.selectedElementIds[h.id] ? iN(this.state, h) ? this.setState((A) => {
        let L = { ...A.selectedElementIds };
        for (let R of h.groupIds.flatMap((z) => ln(this.scene.getNonDeletedElements(), z))) delete L[R.id];
        return { selectedGroupIds: { ...A.selectedElementIds, ...h.groupIds.map((R) => ({ [R]: !1 })).reduce((R, z) => ({ ...R, ...z }), {}) }, selectedElementIds: kt(L, A) };
      }) : (k = this.state.selectedLinearElement) != null && k.isDragging || this.setState((A) => {
        let L = { ...A.selectedElementIds };
        delete L[h.id];
        let R = ct(this.scene.getNonDeletedElements(), { selectedElementIds: L });
        return { ...Hr({ editingGroupId: A.editingGroupId, selectedElementIds: L }, this.scene.getNonDeletedElements(), A, this), selectedLinearElement: R.length === 1 && et(R[0]) ? new Ee(R[0]) : A.selectedLinearElement };
      }) : h.frameId && this.state.selectedElementIds[h.frameId] ? this.setState((A) => {
        var R;
        let L = { ...A.selectedElementIds, [h.id]: !0 };
        return delete L[h.frameId], (((R = this.scene.getElement(h.frameId)) == null ? void 0 : R.groupIds) ?? []).flatMap((z) => ln(this.scene.getNonDeletedElements(), z)).forEach((z) => {
          delete L[z.id];
        }), { ...Hr({ editingGroupId: A.editingGroupId, selectedElementIds: L }, this.scene.getNonDeletedElements(), A, this), showHyperlinkPopup: h.link || ri(h) ? "info" : !1 };
      }) : this.setState((A) => ({ selectedElementIds: kt({ ...A.selectedElementIds, [h.id]: !0 }, A) })) : this.setState((A) => {
        var L;
        return { ...Hr({ editingGroupId: A.editingGroupId, selectedElementIds: { [h.id]: !0 } }, this.scene.getNonDeletedElements(), A, this), selectedLinearElement: et(h) && ((L = A.selectedLinearElement) == null ? void 0 : L.elementId) !== h.id ? new Ee(h) : A.selectedLinearElement };
      })), !(h && Se(h)) && !t.drag.hasOccurred && !this.state.isResizing && (h && nre({ x: t.origin.x, y: t.origin.y, element: h, shape: Jl(h, this.scene.getNonDeletedElementsMap()), threshold: this.getElementHitThreshold(), frameNameBound: Ve(h) ? this.frameNameBoundsCache.get(h) : null }, u) || !h && t.hit.hasHitCommonBoundingBoxOfSelectedElements)) {
        this.state.editingLinearElement ? this.setState({ editingLinearElement: null }) : this.setState({ selectedElementIds: kt({}, this.state), selectedGroupIds: {}, editingGroupId: null, activeEmbeddable: null }), Ht(this.interactiveCanvas, Ot.AUTO);
        return;
      }
      if (!s.locked && s.type !== "freedraw" && r && this.setState((A) => ({ selectedElementIds: kt({ ...A.selectedElementIds, [r.id]: !0 }, A), showHyperlinkPopup: ri(r) && !r.link ? "editor" : A.showHyperlinkPopup })), (s.type !== "selection" || Qn(this.scene.getNonDeletedElements(), this.state) || !Tr(this.state.previousSelectedElementIds, this.state.selectedElementIds)) && this.store.shouldCaptureIncrement(), t.drag.hasOccurred || c || d || o) {
        let A = this.scene.getSelectedElements(this.state).filter(et);
        Nm(A, this.scene.getNonDeletedElementsMap(), this.scene.getNonDeletedElements(), this.scene, fc(this.state), ((M = this.state.selectedLinearElement) == null ? void 0 : M.selectedPointsIndices) ?? [], this.state.zoom);
      }
      if (s.type === "laser") {
        this.laserTrails.endPath();
        return;
      }
      !s.locked && s.type !== "freedraw" ? (fa(this.interactiveCanvas), this.setState({ newElement: null, suggestedBindings: [], activeTool: Wn(this.state, { type: "selection" }) })) : this.setState({ newElement: null, suggestedBindings: [] }), h && this.lastPointerUpEvent && this.lastPointerDownEvent && this.lastPointerUpEvent.timeStamp - this.lastPointerDownEvent.timeStamp < 300 && _t.pointers.size <= 1 && Bi(h) && this.isIframeLikeElementCenter(h, this.lastPointerUpEvent, t.origin.x, t.origin.y) && this.handleEmbeddableCenterClick(h);
    });
  }
  clearSelection(t) {
    this.setState((n) => ({ selectedElementIds: kt({}, n), activeEmbeddable: null, selectedGroupIds: {}, editingGroupId: n.editingGroupId && t != null && tf(t, n.editingGroupId) ? n.editingGroupId : null })), this.setState({ selectedElementIds: kt({}, this.state), activeEmbeddable: null, previousSelectedElementIds: this.state.selectedElementIds });
  }
  getTextWysiwygSnappedToCenterPosition(t, n, r, i) {
    if (i) {
      let a = i.x + i.width / 2, l = i.y + i.height / 2, s = J6(i, r, this.scene.getNonDeletedElementsMap());
      if (s && (a = s.x, l = s.y), Math.hypot(t - a, n - l) < eY) {
        let { x: c, y: d } = wa({ sceneX: a, sceneY: l }, r);
        return { viewportX: c, viewportY: d, elementCenterX: a, elementCenterY: l };
      }
    }
  }
  getCanvasOffsets() {
    var t;
    if ((t = this.excalidrawContainerRef) != null && t.current) {
      let n = this.excalidrawContainerRef.current, { left: r, top: i } = n.getBoundingClientRect();
      return { offsetLeft: r, offsetTop: i };
    }
    return { offsetLeft: 0, offsetTop: 0 };
  }
  async updateLanguage() {
    let t = FU.find((n) => n.code === this.props.langCode) || su;
    await JL(t), this.setAppState({});
  }
}, Mge = () => {
  (st.MODE === oi.TEST || st.DEV) && (window.h = window.h || {}, Object.defineProperties(window.h, { elements: { configurable: !0, get() {
    var e;
    return (e = this.app) == null ? void 0 : e.scene.getElementsIncludingDeleted();
  }, set(e) {
    var t;
    return (t = this.app) == null ? void 0 : t.scene.replaceAllElements(xs(e));
  } }, scene: { configurable: !0, get() {
    var e;
    return (e = this.app) == null ? void 0 : e.scene;
  } } }));
};
Mge();
var Tge = Cge, Ige = () => {
  Array.prototype.at || Object.defineProperty(Array.prototype, "at", { value: function(e) {
    if (e = Math.trunc(e) || 0, e < 0 && (e += this.length), !(e < 0 || e >= this.length)) return this[e];
  }, writable: !0, enumerable: !1, configurable: !0 }), Element.prototype.replaceChildren || (Element.prototype.replaceChildren = function(...e) {
    this.innerHTML = "", this.append(...e);
  });
}, Age = Ige, Nge = () => m("svg", { viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: "ExcalidrawLogo-icon", children: m("path", { d: "M39.9 32.889a.326.326 0 0 0-.279-.056c-2.094-3.083-4.774-6-7.343-8.833l-.419-.472a.212.212 0 0 0-.056-.139.586.586 0 0 0-.167-.111l-.084-.083-.056-.056c-.084-.167-.28-.278-.475-.167-.782.39-1.507.973-2.206 1.528-.92.722-1.842 1.445-2.708 2.25a8.405 8.405 0 0 0-.977 1.028c-.14.194-.028.361.14.444-.615.611-1.23 1.223-1.843 1.861a.315.315 0 0 0-.084.223c0 .083.056.166.111.194l1.09.833v.028c1.535 1.528 4.244 3.611 7.12 5.861.418.334.865.667 1.284 1 .195.223.39.473.558.695.084.11.28.139.391.055.056.056.14.111.196.167a.398.398 0 0 0 .167.056.255.255 0 0 0 .224-.111.394.394 0 0 0 .055-.167c.029 0 .028.028.056.028a.318.318 0 0 0 .224-.084l5.082-5.528a.309.309 0 0 0 0-.444Zm-14.63-1.917a.485.485 0 0 0 .111.14c.586.5 1.2 1 1.843 1.555l-2.569-1.945-.251-.166c-.056-.028-.112-.084-.168-.111l-.195-.167.056-.056.055-.055.112-.111c.866-.861 2.346-2.306 3.1-3.028-.81.805-2.43 3.167-2.095 3.944Zm8.767 6.89-2.122-1.612a44.713 44.713 0 0 0-2.625-2.5c1.145.861 2.122 1.611 2.262 1.75 1.117.972 1.06.806 1.815 1.445l.921.666a1.06 1.06 0 0 1-.251.25Zm.558.416-.056-.028c.084-.055.168-.111.252-.194l-.196.222ZM1.089 5.75c.055.361.14.722.195 1.056.335 1.833.67 3.5 1.284 4.75l.252.944c.084.361.223.806.363.917 1.424 1.25 3.602 3.11 5.947 4.889a.295.295 0 0 0 .363 0s0 .027.028.027a.254.254 0 0 0 .196.084.318.318 0 0 0 .223-.084c2.988-3.305 5.221-6.027 6.813-8.305.112-.111.14-.278.14-.417.111-.111.195-.25.307-.333.111-.111.111-.306 0-.39l-.028-.027c0-.055-.028-.139-.084-.167-.698-.666-1.2-1.138-1.731-1.638-.922-.862-1.871-1.75-3.881-3.75l-.028-.028c-.028-.028-.056-.056-.112-.056-.558-.194-1.703-.389-3.127-.639C6.087 2.223 3.21 1.723.614.944c0 0-.168 0-.196.028l-.083.084c-.028.027-.056.055-.224.11h.056-.056c.028.167.028.278.084.473 0 .055.112.5.112.555l.782 3.556Zm15.496 3.278-.335-.334c.084.112.196.195.335.334Zm-3.546 4.666-.056.056c0-.028.028-.056.056-.056Zm-2.038-10c.168.167.866.834 1.033.973-.726-.334-2.54-1.167-3.379-1.445.838.167 1.983.334 2.346.472ZM1.424 2.306c.419.722.754 3.222 1.089 5.666-.196-.778-.335-1.555-.503-2.278-.251-1.277-.503-2.416-.838-3.416.056 0 .14 0 .252.028Zm-.168-.584c-.112 0-.223-.028-.307-.028 0-.027 0-.055-.028-.055.14 0 .223.028.335.083Zm-1.089.222c0-.027 0-.027 0 0ZM39.453 1.333c.028-.11-.558-.61-.363-.639.42-.027.42-.666 0-.666-.558.028-1.144.166-1.675.25-.977.194-1.982.389-2.96.61-2.205.473-4.383.973-6.561 1.557-.67.194-1.424.333-2.066.666-.224.111-.196.333-.084.472-.056.028-.084.028-.14.056-.195.028-.363.056-.558.083-.168.028-.252.167-.224.334 0 .027.028.083.028.11-1.173 1.556-2.485 3.195-3.909 4.945-1.396 1.611-2.876 3.306-4.356 5.056-4.719 5.5-10.052 11.75-15.943 17.25a.268.268 0 0 0 0 .389c.028.027.056.055.084.055-.084.084-.168.14-.252.222-.056.056-.084.111-.084.167a.605.605 0 0 0-.111.139c-.112.111-.112.305.028.389.111.11.307.11.39-.028.029-.028.029-.056.056-.056a.44.44 0 0 1 .615 0c.335.362.67.723.977 1.028l-.698-.583c-.112-.111-.307-.083-.39.028-.113.11-.085.305.027.389l7.427 6.194c.056.056.112.056.196.056s.14-.028.195-.084l.168-.166c.028.027.083.027.111.027.084 0 .14-.027.196-.083 10.052-10.055 18.15-17.639 27.42-24.417.083-.055.111-.166.111-.25.112 0 .196-.083.251-.194 1.704-5.194 2.039-9.806 2.15-12.083v-.028c0-.028.028-.056.028-.083.028-.056.028-.084.028-.084a1.626 1.626 0 0 0-.111-1.028ZM21.472 9.5c.446-.5.893-1.028 1.34-1.5-2.876 3.778-7.65 9.583-14.408 16.5 4.607-5.083 9.242-10.333 13.068-15ZM5.193 35.778h.084-.084Zm3.462 3.194c-.027-.028-.027-.028 0-.028v.028Zm4.16-3.583c.224-.25.448-.472.699-.722 0 0 0 .027.028.027-.252.223-.475.445-.726.695Zm1.146-1.111c.14-.14.279-.334.446-.5l.028-.028c1.648-1.694 3.351-3.389 5.082-5.111l.028-.028c.419-.333.921-.694 1.368-1.028a379.003 379.003 0 0 0-6.952 6.695ZM24.794 6.472c-.921 1.195-1.954 2.778-2.82 4.028-2.736 3.944-11.532 13.583-11.727 13.75a1976.983 1976.983 0 0 1-8.042 7.639l-.167.167c-.14-.167-.14-.417.028-.556C14.49 19.861 22.03 10.167 25.074 5.917c-.084.194-.14.36-.28.555Zm4.83 5.695c-1.116-.64-1.646-1.64-1.34-2.611l.084-.334c.028-.083.084-.194.14-.277.307-.5.754-.917 1.257-1.167.027 0 .055 0 .083-.028-.028-.056-.028-.139-.028-.222.028-.167.14-.278.335-.278.335 0 1.369.306 1.76.639.111.083.223.194.335.305.14.167.363.445.474.667.056.028.112.306.196.445.056.222.111.472.084.694-.028.028 0 .194-.028.194a2.668 2.668 0 0 1-.363 1.028c-.028.028-.028.056-.056.084l-.028.027c-.14.223-.335.417-.53.556-.643.444-1.369.583-2.095.389 0 0-.195-.084-.28-.111Zm8.154-.834a39.098 39.098 0 0 1-.893 3.167c0 .028-.028.083 0 .111-.056 0-.084.028-.14.056-2.206 1.61-4.356 3.305-6.506 5.028 1.843-1.64 3.686-3.306 5.613-4.945.558-.5.949-1.139 1.06-1.861l.28-1.667v-.055c.14-.334.67-.195.586.166Z", fill: "currentColor" }) }), Dge = () => D("svg", { viewBox: "0 0 450 55", xmlns: "http://www.w3.org/2000/svg", fill: "none", className: "ExcalidrawLogo-text", children: [m("path", { d: "M429.27 96.74c2.47-1.39 4.78-3.02 6.83-4.95 1.43-1.35 2.73-2.86 3.81-4.51-.66.9-1.4 1.77-2.23 2.59-2.91 2.84-5.72 5.09-8.42 6.87h.01ZM343.6 69.36c.33 3.13.58 6.27.79 9.4.09 1.37.18 2.75.25 4.12-.12-4.46-.27-8.93-.5-13.39-.11-2.08-.24-4.16-.4-6.24-.06 1.79-.11 3.85-.13 6.11h-.01ZM378.47 98.34c.01-.37.07-1.13.01-6.51-.11 1.9-.22 3.81-.31 5.71-.07 1.42-.22 2.91-.16 4.35.39.03.78.07 1.17.1-.92-.85-.76-2.01-.72-3.66l.01.01ZM344.09 86.12c-.09-2.41-.22-4.83-.39-7.24v12.21c.15-.05.32-.09.47-.14.05-1.61-.03-3.23-.09-4.83h.01ZM440.69 66.79c-.22-.34-.45-.67-.69-.99-3.71-4.87-9.91-7.14-15.65-8.55-1.05-.26-2.12-.49-3.18-.71 2.29.59 4.48 1.26 6.64 2.02 7.19 2.54 10.57 5.41 12.88 8.23ZM305.09 72.46l1.2 3.6c.84 2.53 1.67 5.06 2.46 7.61.24.78.5 1.57.73 2.36.22-.04.44-.08.67-.12a776.9 776.9 0 0 1-5.01-13.57c-.02.04-.03.09-.05.13v-.01ZM345.49 90.25v.31c1.48-.42 3.05-.83 4.66-1.2-1.56.25-3.12.52-4.66.89ZM371.02 90.22c0-.57-.04-1.14-.11-1.71-.06-.02-.12-.04-.19-.05-.21-.05-.43-.08-.65-.11.42.16.74.88.95 1.87ZM398.93 54.23c-.13 0-.27-.01-.4-.02l.03.4c.11-.15.23-.27.37-.38ZM401.57 62.28v-.15c-1.22-.24-2.86-.61-3.23-1.25-.09-.15-.18-.51-.27-.98-.09.37-.2.73-.33 1.09 1.24.56 2.52.98 3.83 1.29ZM421.73 88.68c-2.97 1.65-6.28 3.12-9.69 3.68v.18c4.72-.14 11.63-3.85 16.33-8.38-2.04 1.75-4.33 3.24-6.63 4.53l-.01-.01ZM411.28 80.92c-.05-1.2-.09-2.4-.15-3.6-.21 5.66-.46 11.38-.47 14.51.24-.02.48-.04.71-.07.15-3.61.05-7.23-.09-10.83v-.01Z", transform: "translate(-144.023 -51.76)" }), m("path", { d: "M425.38 67.41c-3.5-1.45-7.19-2.57-14.06-3.62.09 1.97.06 4.88-.03 8.12.03.04.06.09.06.15.19 1.36.28 2.73.37 4.1.25 3.77.39 7.55.41 11.33 0 1.38-.01 2.76-.07 4.13 1.4-.25 2.78-.65 4.12-1.15 4.07-1.5 7.94-3.78 11.28-6.54 2.33-1.92 5.13-4.49 5.88-7.58.63-3.53-2.45-6.68-7.97-8.96l.01.02ZM411.35 92.53v-.06l-.34.03c.11.01.22.03.34.03ZM314.26 64.06c-.23-.59-.47-1.17-.7-1.75.57 1.62 1.11 3.25 1.6 4.9l.15.54 2.35 6.05c.32.82.66 1.64.98 2.46-1.38-4.1-2.83-8.17-4.39-12.2h.01ZM156.82 103.07c-.18.13-.38.23-.58.33 1.32-.03 2.66-.2 3.93-.34.86-.09 1.72-.22 2.58-.33-2.12.1-4.12.17-5.94.34h.01ZM210.14 68.88s.03.04.05.07c.18-.31.39-.64.58-.96-.21.3-.42.6-.64.89h.01ZM201.65 82.8c-.5.77-1.02 1.56-1.49 2.37 1.11-1.55 2.21-3.1 3.2-4.59-.23.23-.49.51-.75.79-.32.47-.65.95-.96 1.43ZM194.03 98.66c-.33-.4-.65-.84-1.05-1.17-.24-.2-.07-.49.17-.56-.23-.26-.42-.5-.63-.75 1.51-2.55 3.93-5.87 6.4-9.28-.17-.08-.29-.28-.2-.49.04-.09.09-.17.13-.26-1.21 1.78-2.42 3.55-3.61 5.33-.87 1.31-1.74 2.64-2.54 4-.29.5-.63 1.04-.87 1.61.81.65 1.63 1.27 2.47 1.88-.09-.11-.18-.21-.27-.32v.01ZM307.79 82.93c-1-3.17-2.05-6.32-3.1-9.48-1.62 4.08-3.69 9.17-6.16 15.19 3.32-1.04 6.77-1.87 10.27-2.5-.32-1.08-.67-2.15-1.01-3.21ZM149.5 80.7c.05-1.71.04-3.43 0-5.14-.1 2.26-.16 4.51-.22 6.77-.02.73-.03 1.46-.04 2.19.14-1.27.2-2.55.24-3.82h.02ZM228.98 98.3c.39 1.25.91 3.03.94 3.91.06-.03.12-.07.17-.1.08-1.29-.55-2.65-1.11-3.81ZM307.72 53.36c.81.5 1.53 1.04 2.07 1.49-.38-.8-.78-1.58-1.21-2.35-.17.03-.34.06-.51.11-.43.12-.86.26-1.29.41.35-.01.53.1.94.34ZM283.69 96.14c3.91-7.25 6.89-13.35 8.88-18.15l1.1-2.66c-1.27 2.64-2.56 5.27-3.83 7.9-1.53 3.15-3.06 6.31-4.58 9.47-.87 1.81-1.76 3.62-2.54 5.47.04.02.07.04.11.07.05.05.1.09.15.14.05-.73.27-1.48.71-2.24ZM289.92 103.23s-.04.01-.05.03c0-.02.04-.03.05-.04.05-.05.11-.1.16-.15l.21-.21c-.55 0-1.5-.27-2.55-.72.4.26.8.51 1.22.74.24.13.48.26.73.37.05.02.1.03.14.05a.27.27 0 0 1 .08-.07h.01ZM269.23 68.49c-.39-.19-.82-.48-1.33-.87-3.06-1.56-6.31-2.78-9.36-2.35-3.5.49-5.7 1.11-7.74 2.44 5.71-2.6 12.82-2.07 18.44.79l-.01-.01ZM177.87 53.69l1.06.03c-.96-.22-2-.25-2.89-.3-4.95-.26-9.99.33-14.86 1.19-2.44.43-4.88.95-7.28 1.59 9.09-1.76 15.69-2.77 23.97-2.51ZM219.85 55.51c-.18.12-.36.27-.56.45-.45.53-.86 1.11-1.26 1.66-1.91 2.61-3.71 5.31-5.57 7.95l-.12.18 8.05-10.11c-.18-.05-.36-.1-.55-.13h.01ZM510.71 54.1c.12-.15.29-.3.53-.45.69-.4 3.72-.63 5.87-.74-.36-.02-.73-.04-1.09-.05-1.84-.03-3.67.09-5.49.35.05.3.12.59.18.88v.01ZM510.76 86.02c1.37-3.07 2.49-6.27 3.57-9.46.55-1.64 1.12-3.3 1.6-4.97-1.59 4.01-3.67 9.14-6.2 15.3.24-.08.5-.14.74-.22.1-.22.19-.44.29-.65ZM566.95 75.76c.11-.02.23.03.31.11-.05-.13-.09-.26-.14-.39-.05.09-.11.18-.17.28ZM511.33 86.41c3.08-.89 6.24-1.62 9.46-2.14-1.51-3.98-2.98-7.96-4.39-11.87-.05.15-.09.31-.14.46-1.02 3.32-2.15 6.61-3.39 9.85-.48 1.25-.98 2.49-1.53 3.7h-.01ZM578.24 74.45c.11-.44.23-.87.35-1.31-.31.7-.64 1.39-.97 2.08.09.21.19.4.28.61.12-.46.23-.92.35-1.38h-.01ZM520.62 53.11c-.09 0-.18-.01-.28-.02.38.34.29 1.08.93 2.53l6.65 17.15c2.2 5.68 4.69 11.36 7.41 16.87l1.06 2.17c-2.95-7.05-5.92-14.08-8.87-21.13-1.58-3.79-3.16-7.59-4.7-11.4-.78-1.92-1.73-3.89-2.25-5.91-.03-.1 0-.19.04-.26h.01ZM578.78 77.87c1.45-5.77 3.07-10.43 3.58-13.36.05-.34.16-.88.31-1.55-.67 1.79-1.37 3.56-2.08 5.33-.12.43-.23.86-.35 1.29-.65 2.43-1.29 4.86-1.9 7.3.14.33.29.65.43 1l.01-.01ZM545.3 94.66c.02-.44.03-.83.05-1.12.02-1.01.05-2.02.11-3.02.03-6.66-.46-14.33-1.46-22.8-.13-.42-.27-1.24-.56-2.89 0-.02 0-.04-.01-.06.62 6.61.95 13.25 1.32 19.87.17 3.08.33 6.16.52 9.23.02.25.03.52.04.78l-.01.01ZM580.77 102.81c.13.2.27.38.37.49.27-.11.53-.22.8-.32-.43.09-.82.05-1.17-.16v-.01ZM530.48 104.07h.33c-.36-.13-.71-.32-1.04-.56.14.24.3.47.45.7.06-.08.14-.13.26-.13v-.01ZM542.63 58.82c.06.23.11.47.15.71.14-.33.36-.62.7-.86-.28.05-.57.11-.85.15ZM583.81 57.87c.15-.7.29-1.41.42-2.11-.14.45-.28.9-.42 1.34-.46 1.44-.89 2.89-1.31 4.34.44-1.19.88-2.37 1.31-3.57ZM523.62 91.48c-4.66 1.17-9.05 2.89-14.02 5.27 4.65-1.84 9.48-3.29 14.28-4.63-.09-.22-.17-.41-.26-.64ZM460.64 78.3c-.04-2.9-.11-5.81-.28-8.71-.1-1.68-.17-3.43-.5-5.09-.07.02-.14.03-.2.05.3 6.54.45 12.17.51 17.12.17-.07.34-.14.51-.2 0-1.06-.01-2.11-.03-3.17h-.01ZM470.63 63.24c-3.38-.26-6.81.32-10.1 1.1.41 2.01.47 4.14.57 6.18.18 3.55.25 7.11.27 10.67 3.31-1.38 6.5-3.12 9.3-5.35 1.96-1.56 3.86-3.41 5.02-5.66.73-1.41 1.19-3.22.26-4.65-1.09-1.7-3.46-2.14-5.32-2.29ZM460.29 63.68c1-.24 2.01-.46 3.04-.65-1.15.16-2.37.38-3.71.69v.13c.07-.02.15-.04.22-.05.11-.13.3-.18.45-.11v-.01ZM457.24 100.96c.43-.03.86-.07 1.29-.11.14-.49.27-.99.38-1.49-.44.7-1 1.23-1.67 1.6ZM482.88 104.98c-.18.23-.36.38-.55.47.14.09.27.19.4.28a70.76 70.76 0 0 0 4.37-4.63c.76-.89 1.52-1.81 2.19-2.77-.3-.27-.61-.53-.92-.79-.07 1.94-4.62 6.32-5.49 7.45v-.01Z", transform: "translate(-144.023 -51.76)" }), m("path", { d: "M474.36 63.31c-.4-.16-.84-.27-1.29-.37 1.56.42 3.08 1.22 3.76 2.74.62 1.4.32 2.95-.28 4.32.7-1.22.94-2.34.74-3.47-.24-1.33-1.19-2.54-2.93-3.21v-.01ZM477.34 89.18c-1.2-.81-2.4-1.62-3.6-2.42-.14.1-.26.19-.4.29 1.4.67 2.73 1.39 4 2.13ZM465.88 93.85c.37.25.74.5 1.1.75.46.32.92.65 1.38.97-1.57-1.2-2.01-1.61-2.49-1.72h.01ZM574.92 90.06c-2.28-5.21-4.93-11.13-5.67-12.26-.1-.15-1.57-3.01-1.63-3.08 0 0-.01.02-.02.02.4 1.37 1.09 2.69 1.65 3.99 2.14 4.95 4.36 9.86 6.67 14.73.6 1.26 1.21 2.52 1.83 3.78-.75-2.01-1.64-4.45-2.83-7.18ZM448.73 65.29c.1.2.22.38.34.57.22-.02.43-.06.65-.08v-.08c-.14-.05-.25 0-.99-.41ZM460.16 94.81c-.02.31-.06.59-.1.89-.03 1.71-.33 3.43-.79 5.07.15-.02.3-.03.45-.05.01-.04.02-.08.03-.11.09-.34.15-.69.2-1.03.17-1.07.25-2.16.33-3.24.05-.69.08-1.39.12-2.08-.27.1-.27.26-.24.57v-.02Z", transform: "translate(-144.023 -51.76)" }), m("path", { d: "m328.67 98.12-3.22-6.58c-1.29-2.63-2.53-5.29-3.72-7.97-.25-.85-.52-1.69-.79-2.53-.81-2.57-1.67-5.12-2.55-7.67-1.92-5.53-3.9-11.08-6.32-16.41-.72-1.58-1.46-3.44-2.63-4.79-.03-.17-.16-.29-.34-.36a.282.282 0 0 0-.23-.04c-.06-.01-.12 0-.18.01-.74.06-1.5.38-2.19.61-2.22.77-4.4 1.64-6.63 2.38-.03-.08-.06-.16-.09-.25-.15-.42-.82-.24-.67.19.03.09.07.19.1.28l-.18.06c-.36.11-.28.6 0 .68.18 1.18.63 2.36.98 3.49.03.09.06.17.08.26-.08.23-.17.46-.24.64-.37.98-.79 1.94-1.21 2.9-1.27 2.89-2.62 5.75-3.98 8.6-3.18 6.67-6.44 13.31-9.64 19.97-1.08 2.25-2.2 4.5-3.15 6.81-.13.32.24.5.5.37 1.34 1.33 2.84 2.5 4.4 3.57.65.44 1.31.87 2.01 1.24.4.22.86.48 1.33.5.24.01.35-.19.33-.37.11-.1.21-.21.28-.28.41-.41.81-.84 1.2-1.26.85-.92 1.69-1.87 2.5-2.84 6.31-2.34 12.6-4.31 18.71-5.84 2.14 5.3 3.43 8.43 3.97 9.58.55 1.05 1.15 1.88 1.82 2.52 1.32.56 6.96-.03 9.23-1.96.87-1.28 1.19-2.67.93-4.15-.09-.5-.22-.95-.4-1.33l-.01-.03Zm-20.09-45.61c.43.77.83 1.56 1.21 2.35-.54-.45-1.27-.99-2.07-1.49-.42-.24-.6-.35-.94-.34.43-.15.85-.29 1.29-.41.17-.05.34-.08.51-.11Zm-25.86 45.66c.78-1.85 1.67-3.66 2.54-5.47 1.51-3.16 3.05-6.31 4.58-9.47 1.28-2.63 2.56-5.26 3.83-7.9l-1.1 2.66c-1.99 4.79-4.97 10.9-8.88 18.15-.43.76-.66 1.51-.71 2.24-.05-.05-.1-.09-.15-.14a.259.259 0 0 0-.11-.07Zm6.24 4.71c-.42-.23-.82-.48-1.22-.74 1.05.45 2 .72 2.55.72l-.21.21c-.05.05-.11.1-.16.15-.01.01-.04.03-.05.04 0-.02.03-.02.05-.03a.27.27 0 0 0-.08.07c-.05-.02-.1-.03-.14-.05-.25-.1-.49-.24-.73-.37h-.01Zm15.73-29.43c1.05 3.15 2.1 6.31 3.1 9.48.34 1.06.69 2.13 1.01 3.21-3.5.63-6.95 1.46-10.27 2.5 2.48-6.03 4.54-11.11 6.16-15.19Zm4.79 12.57c-.23-.79-.49-1.58-.73-2.36-.79-2.54-1.63-5.08-2.46-7.61l-1.2-3.6c.02-.04.04-.09.05-.13 1.6 4.45 3.28 9 5.01 13.57l-.67.12v.01Zm5.83-18.27-.15-.54c-.49-1.64-1.03-3.28-1.6-4.9.23.58.47 1.17.7 1.75 1.56 4.03 3.01 8.1 4.39 12.2-.33-.82-.67-1.64-.98-2.46l-2.35-6.05h-.01ZM390.43 79.37c-.13-10.43-.22-17.5-.24-19.97-.24-1.6.21-2.88-.65-3.65-.14-.13-.32-.23-.52-.32h.03c.45 0 .45-.69 0-.7-1.75-.03-3.5-.04-5.25-.14-1.38-.08-2.76-.21-4.15-.31-.07 0-.12.01-.17.04-.21-.07-.47.03-.45.31l.03.45c-.11.14-.19.3-.22.5-.21 1.26-.32 13.67-.36 23.59-.32 5.79-.67 11.57-.97 17.36-.09 1.73-.29 3.54-.21 5.3-.39.02-.38.64.04.69v.12c.05.44.74.45.7 0v-.06c1.1.09 2.2.21 3.3.3 1.14.19 2.44.2 3.29.17 1.73-.05 2.92-.05 3.8-.37.45-.05.9-.11 1.35-.17.44-.06.25-.73-.19-.67h-.01c.24-.32.45-.72.62-1.25.66-1.84.41-6.36.34-11.33l-.13-9.9.02.01Zm-12.26 18.17c.09-1.91.2-3.81.31-5.71.06 5.38 0 6.14-.01 6.51-.05 1.65-.21 2.81.72 3.66-.39-.04-.78-.07-1.17-.1-.06-1.44.09-2.93.16-4.35l-.01-.01ZM588.97 53.85c-2.06-.25-3.17-.51-3.76-.6a.3.3 0 0 1 .04-.08c.22-.39-.39-.75-.6-.35-.56 1.02-.9 2.19-1.26 3.29-.61 1.88-1.17 3.78-1.72 5.68-.63 2.19-1.24 4.39-1.83 6.59-.81 2.03-1.67 4.05-2.61 6.03-1.7-3.64-3.11-6.04-4.03-7.57-2.26-3.74-2.85-5.48-3.57-6.08l.31-.09c.43-.12.25-.8-.19-.67-1.06.3-2.12.6-3.17.95-.93.32-1.85.69-2.76 1.07-.13.05-.19.16-.22.27-.04.02-.08.05-.11.07-.04-.06-.07-.12-.11-.18a.354.354 0 0 0-.48-.12c-.16.09-.22.32-.13.48l.33.54c0 .09.02.18.06.28.51 1.16.78 1.38.72 1.47-2.42 3.44-5.41 7.86-6.2 9.1-1.27 1.97-2.01 3.14-2.45 3.84l-.91-6.56-.43-4.1c-.19-1.85-.37-3.23-.53-4.13-.19-1.1-.3-2.15-.45-3.16-.2-1.36-.29-2.06-.47-2.42h.04c.45.02.45-.68 0-.7-3.43-.16-6.81.94-10.17 1.48-.24-.22-.73-.04-.58.32.24.59.33 1.25.43 1.87.17 1.06.29 2.13.4 3.2.32 3.09.53 6.2.74 9.3.44 6.75.77 13.51 1.17 20.26.11 1.95.13 3.96.46 5.89.05.3.37.31.55.14.74 1.71 2.87 1.27 6.13 1.27 1.34 0 2.39.04 2.99-.11.02.32.48.53.63.18 3.61-8.26 7.41-16.46 12.05-24.2.03-.05.04-.1.05-.15.3.73.64 1.45.94 2.16.97 2.26 1.97 4.52 2.98 6.76 2.26 5.03 4.54 10.07 7.09 14.96.47.9.94 1.79 1.47 2.65.2.32.4.67.66.96-.18.25 0 .68.34.54.91-.38 1.82-.75 2.76-1.07 1.04-.35 2.11-.65 3.17-.95.39-.11.28-.66-.07-.68.62-.4.95-.96.87-1.91-.3-3.34.72-7.47.86-8.52l2.14-11.43c1.75-10.74 3.13-17.51 3.23-20.86.02-.49.08-2.84.13-3.24.17-1.25.48-1-4.96-1.65l.03-.02Zm-46.19 5.67c-.04-.24-.09-.48-.15-.71l.85-.15c-.34.24-.56.53-.7.86Zm1.95 25.12c-.36-6.63-.7-13.26-1.32-19.87 0 .02 0 .04.01.06.29 1.65.44 2.47.56 2.89 1 8.46 1.5 16.14 1.46 22.8-.06.99-.1 2-.11 3.02-.01.29-.03.68-.05 1.12-.01-.26-.03-.53-.04-.78-.19-3.08-.35-6.16-.52-9.23l.01-.01Zm36.4 18.66c-.11-.11-.24-.29-.37-.49.35.21.74.26 1.17.16-.27.11-.53.22-.8.32v.01Zm-.89-33.72c.12-.43.23-.86.35-1.29.71-1.77 1.41-3.55 2.08-5.33-.15.68-.26 1.22-.31 1.55-.5 2.94-2.13 7.59-3.58 13.36-.15-.35-.29-.66-.43-1 .61-2.44 1.25-4.87 1.9-7.3l-.01.01Zm3.56-12.48c.14-.44.28-.89.42-1.34-.13.7-.27 1.41-.42 2.11-.43 1.19-.86 2.38-1.31 3.57.42-1.45.85-2.9 1.31-4.34Zm-5.22 16.05c-.11.44-.23.87-.35 1.31-.12.46-.23.92-.35 1.38-.1-.22-.19-.4-.28-.61.34-.69.66-1.38.97-2.08h.01Zm-11.64 2.62c.06-.1.12-.19.17-.28.05.13.09.26.14.39a.398.398 0 0 0-.31-.11Zm2.3 2.98c-.56-1.3-1.25-2.63-1.65-3.99 0 0 .01-.02.02-.02.06.08 1.52 2.93 1.63 3.08.73 1.13 3.38 7.04 5.67 12.26 1.2 2.73 2.08 5.17 2.83 7.18-.62-1.25-1.23-2.51-1.83-3.78-2.31-4.87-4.53-9.78-6.67-14.73ZM275.92 87.03c-1.06-2.18-1.13-3.45-2.44-2.93-1.52.57-2.94 1.3-4.5 2.1-1.4.72-2.68 1.44-3.92 2.12.01-.25-.24-.5-.51-.34-4.8 2.93-12.41 4.7-17.28 1.31-1.98-1.77-3.32-4.15-3.97-5.78-.29-.95-.49-1.94-.63-2.93-.14-3.34 1.58-6.53 3.9-9.12.8-.79 1.68-1.51 2.66-2.12 3.7-2.3 8.22-3.07 12.51-2.51 2.71.35 5.32 1.24 7.71 2.55.39.22.75-.39.35-.6-.18-.1-.37-.18-.55-.27.56.27 1.03.33 1.51.19l-.48.39c-.15.11-.23.3-.13.48.09.15.33.24.48.13 1.3-.97 2.46-2.09 3.45-3.37.37-.29.64-.6.65-.97v-.02c.08-.33-.03-.7-.21-1.08-.31-.87-.98-2.01-2.19-3.26-2.43-2.52-3.79-3.45-5.68-4.26-1.14-.49-3.12-1.06-4.42-1.23-3.28-.42-10.64-1.21-18.18 4.11-7.74 5.46-11.94 12.3-12.23 20.61-.08 2.06.04 3.98.34 5.71.74 4.18 2.57 8 5.44 11.34 4.26 4.99 9.76 7.52 16.34 7.52 4.85 0 9.69-1.77 14.89-4.62.23-.12.45-.23.68-.35 2.19-1.1 4.37-2.23 6.46-3.5.49-.3 1.03-.61 1.5-.98 1.47-.87 1.11-1.12.49-2.95-.39-1.14-.76-2.7-2.06-5.36l.02-.01Zm-17.38-21.76c3.05-.42 6.31.79 9.36 2.35.51.39.94.68 1.33.87-5.61-2.86-12.72-3.39-18.44-.79 2.05-1.33 4.24-1.95 7.74-2.44l.01.01ZM443.67 72.67c-.4-2.2-1.15-4.33-2.37-6.22-1.49-2.32-3.58-4.19-5.91-5.64-6.17-3.81-13.75-5.11-20.83-6.01-3.23-.41-6.47-.69-9.72-.92l-1.39-.12c-.85-.07-1.52-.1-2.05-.1-1.08-.06-2.17-.12-3.25-.17-.08 0-.14.02-.19.05-.1.05-.18.14-.16.3.27 2.55-.01 5.12-.92 7.52-.15.38.4.56.62.28 1.32.59 2.68 1.05 4.08 1.37 0 2.78-.14 7.58-.33 12.91 0 0 0 .02-.01.03-.61 3.66-.79 7.42-1 11.12-.23 4.01-.43 8.03-.44 12.05 0 .64 0 1.28.03 1.93.02.31 0 .68.15.96.06.11.14.16.24.17-.2.17-.21.54.11.59 3.83.67 7.78.71 11.68.25 2.3-.19 4.87-.65 7.65-1.56 1.85-.54 3.67-1.18 5.43-1.91 7.2-3.02 14.31-8.07 17.35-15.53.76-1.86 1.17-3.8 1.31-5.75.3-1.93.28-3.82-.09-5.58l.01-.02Zm-19.32-15.42c5.74 1.41 11.94 3.68 15.65 8.55.25.32.47.65.69.99-2.3-2.82-5.68-5.69-12.88-8.23-2.16-.76-4.35-1.43-6.64-2.02 1.06.21 2.13.45 3.18.71Zm-25.82-3.04c.13 0 .27.01.4.02-.14.1-.26.23-.37.38 0-.13-.02-.26-.03-.4Zm34.82 22.17c-.75 3.09-3.55 5.66-5.88 7.58-3.35 2.76-7.21 5.03-11.28 6.54-1.33.49-2.71.9-4.12 1.15.06-1.38.08-2.76.07-4.13-.02-3.78-.16-7.56-.41-11.33-.09-1.37-.18-2.74-.37-4.1 0-.06-.03-.11-.06-.15.09-3.25.12-6.16.03-8.12 6.86 1.05 10.56 2.17 14.06 3.62 5.52 2.28 8.59 5.44 7.97 8.96l-.01-.02Zm-22 16.15c-.12 0-.23-.02-.34-.03l.34-.03v.06Zm-.69-.7c0-3.13.26-8.84.47-14.51.06 1.2.11 2.41.15 3.6.15 3.6.25 7.23.09 10.83-.24.03-.48.05-.71.07v.01Zm-12.33-30.94c.37.63 2.01 1.01 3.23 1.25v.15c-1.31-.31-2.59-.73-3.83-1.29.12-.36.23-.72.33-1.09.08.48.18.84.27.98Zm13.7 31.65v-.18c3.41-.56 6.71-2.02 9.69-3.68 2.31-1.28 4.59-2.78 6.63-4.53-4.69 4.53-11.61 8.24-16.33 8.38l.01.01Zm24.07-.75c-2.05 1.93-4.37 3.56-6.83 4.95 2.7-1.78 5.52-4.03 8.42-6.87.82-.82 1.56-1.69 2.23-2.59-1.08 1.65-2.38 3.16-3.81 4.51h-.01ZM187.16 92.14c-.79-2.47-2.1-7.12-3.1-6.87-.19-.01-2.09.77-4.08 1.54-3.06 1.18-5.91 2.13-10.09 2.82-2.74.42-5.87 1.01-10.61 1.06.04-3.34.05-6.01.05-7.99 7.97-.65 12.33-2.11 16.37-3.55 1.11-.39 2.69-1.01 2.63-1.8-.08-.35-.55-1.39-1.17-2.61-.47-1.16-.98-2.31-1.61-3.38-.42-.71-1.04-1.69-1.86-2.06-.11-.08-.22-.13-.29-.12-.02 0-.04 0-.07.01-.19-.04-.39-.05-.6-.01-.17.03-.24.15-.25.28-.04.02-.09.04-.14.05-4.33 1.48-8.85 2.33-13.24 3.61a499.1 499.1 0 0 0-.31-8.19c4.51-.99 8.88-1.38 13.11-1.82 3.68-.38 6.28.12 7.47.34.59.11.9.16 1.16.18h.1c-.1.37.44.66.62.28.02-.04.03-.08.05-.13.15.2.53.22.62-.1.17-.58.19-1.21.21-1.81v-.36c.03-.15.05-.3.07-.45.52-2.47.33-5.09-.64-7.44-.11-.27-.44-.28-.6-.14-.08-.21-.15-.42-.24-.62-.19-.41-.79-.05-.6.35.03.07.05.15.09.22-.98-.42-2.15-.54-3.17-.63-2.17-.19-4.37-.14-6.54 0-5.7.35-11.4 1.3-16.91 2.79-2.08.56-4.13 1.22-6.14 2-4.54 1.05-3.79 1.51-2.17 6.07.18.51.46 1.68.54 1.94.82 2.47 1.08 2.13 3.1 2.13s0 .05 0 .08h.52c-.48 2.66-.51 5.45-.62 8.13-.15 3.48-.22 6.96-.28 10.45 0 .41-.01.82-.02 1.23-.16.29-.33.57-.51.85-.05.38-.09.77-.14 1.18-.42 3.52-.59 6.48-.52 8.8v.34c.02.47.05.76.06.87.16 1.57-.26 3.47 1.35 3.79 1.61.32 3.5.55 4.85.55.11 0 .22-.02.33-.02 1.79.24 3.67.05 5.45-.12 2.85-.28 5.69-.7 8.51-1.19 3.03-.53 6.05-1.14 9.04-1.86 2.4-.58 4.82-1.19 7.13-2.06.51-.19 1.73-.57 2.46-1.14 1.81-.68 2.18-1 1.57-2.67-.23-.62-.48-1.49-.91-2.78l-.03-.02Zm-11.12-38.71c.89.05 1.93.08 2.89.3-.33 0-.68-.02-1.06-.03-8.28-.26-14.88.75-23.97 2.51 2.41-.64 4.85-1.16 7.28-1.59 4.87-.86 9.91-1.45 14.86-1.19Zm-26.53 22.13c.03 1.71.04 3.43 0 5.14-.04 1.27-.11 2.55-.24 3.82 0-.73.02-1.46.04-2.19.05-2.26.12-4.51.22-6.77h-.02Zm6.73 27.85c.2-.1.4-.21.58-.33 1.82-.17 3.82-.24 5.94-.34-.86.11-1.72.24-2.58.33-1.27.14-2.61.31-3.93.34h-.01ZM534.48 85.44c-3.52-8.38-7.07-16.75-10.5-25.17-.63-1.54-1.25-3.09-1.86-4.65-.31-.8-.65-1.6-.87-2.43-.04-.17-.17-.24-.31-.25.1-.2 0-.51-.29-.53-1.59-.08-3.18-.22-4.78-.25-1.96-.03-3.91.13-5.84.42-.31.05-.31.38-.13.56-.03.06-.05.14-.04.22.23 1.54.63 3.06 1.16 4.53.13.35.27.7.41 1.06l-2.68 6.18c-.11.03-.2.09-.25.22-.67 1.9-1.52 3.73-2.34 5.56a536.85 536.85 0 0 1-3.9 8.45c-2.64 5.64-5.34 11.25-7.91 16.93-.44.97-.88 1.94-1.29 2.93-.2.48-.47 1-.55 1.52v.05c-.02.12.02.26.16.34 1.19.73 2.41 1.41 3.66 2.05 1.2.62 2.45 1.25 3.76 1.61.43.12.62-.55.19-.67-1.13-.31-2.2-.83-3.24-1.36 1.09.36 2.1.69 2.75.93 2.82 1.01 2.38 1.1 4.3-3.75 2.1-1.09 4.34-1.96 6.53-2.79 4.35-1.64 8.8-3.03 13.27-4.29.82 2.01 1.77 3.97 2.72 5.92.35.83.62 1.45.79 1.82.22.42.45.8.69 1.15.17.33.33.67.5 1 .42.8.84 1.63 1.4 2.35.23.29.6 0 .55-.31 1.53-.02 3.06-.07 4.58-.27.92-.12 1.82-.32 2.71-.54 1.39-.27 3.85-1.11 3.74-1.42-.67-1.96-1.55-3.87-2.34-5.78-1.57-3.78-3.16-7.56-4.75-11.33v-.01Zm-11.65-26.16c1.54 3.81 3.12 7.6 4.7 11.4 2.94 7.05 5.91 14.09 8.87 21.13l-1.06-2.17c-2.71-5.51-5.2-11.19-7.41-16.87l-6.65-17.15c-.65-1.45-.55-2.19-.93-2.53.09 0 .18.01.28.02a.29.29 0 0 0-.04.26c.52 2.02 1.47 3.98 2.25 5.91h-.01Zm-6.58 13.58c.05-.15.09-.31.14-.46 1.41 3.92 2.88 7.9 4.39 11.87-3.22.52-6.38 1.25-9.46 2.14.55-1.22 1.05-2.46 1.53-3.7 1.24-3.24 2.37-6.53 3.39-9.85h.01Zm-.23-20c.36 0 .73.03 1.09.05-2.15.1-5.18.33-5.87.74-.24.15-.41.3-.53.45-.06-.29-.13-.58-.18-.88 1.82-.26 3.65-.39 5.49-.35v-.01Zm-.09 18.72c-.49 1.67-1.05 3.33-1.6 4.97-1.07 3.19-2.19 6.38-3.57 9.46-.09.21-.19.43-.29.65-.25.07-.5.14-.74.22 2.53-6.16 4.61-11.29 6.2-15.3Zm-6.34 25.16c4.97-2.38 9.37-4.1 14.02-5.27l.26.64c-4.8 1.35-9.63 2.8-14.28 4.63Zm20.17 6.76c.33.23.68.42 1.04.56h-.33c-.12 0-.21.06-.26.13-.15-.23-.31-.45-.45-.7v.01ZM226.57 91.75c-3.55-4.74-6.68-9.11-9.31-12.99 9.2-15.25 10.05-17.81 10.35-18.38.17-.34 1.09-2.27.64-2.53-1.13-.65-1.03-.65-2.97-1.71-1.19-.65-3.04-1.61-4.53-2.12-1.71-.59-1.24-.36-3 2.77-.06.1-.11.2-.17.3-.75 1.02-1.48 2.05-2.2 3.09-1.88 2.71-3.73 5.45-5.69 8.1-3.68-4.91-6.88-8.76-9.51-11.43-.15-.15-.3-.29-.46-.42-1.27-1.28-7.24 3.53-7.93 5.58-.09.09-.19.16-.28.25-.27.26.03.64.33.58.19.65.5 1.29.94 1.91 3.85 5.06 7.19 9.76 9.94 14-1.23 2.61-3.06 5-4.67 7.38l-2.28 3.33c-.5.66-.93 1.23-1.29 1.69-.67.93-2.09 2.61-2.3 3.87-.51.85-1.16 1.84-1.29 2.83-.06.44.61.63.67.19.01-.08.04-.15.06-.22 1.36 1.08 2.76 2.11 4.19 3.11 1.3.91 2.62 1.85 4.04 2.56.21.1.4 0 .48-.17.24.07.48.14.72.2.44.1.62-.57.19-.67-2.02-.48-3.77-1.57-5.23-3.02-.47-.46-.9-.96-1.32-1.46 1.74 1.35 4.2 2.89 5.89 4.14 1.39 1.03 2.85-2.27 4.22-4.2 1.86-2.64 3.96-5.86 5.52-8.29l10.39 14.51c.67.81 1.14 1.21 1.57 1.36-.05.24.12.51.41.4 1.53-.58 3.05-1.19 4.54-1.87 1.52-.69 3.06-1.45 4.36-2.5a.28.28 0 0 0 .12-.23c1.66-1.1.81-1.74-1.41-4.91-1.13-1.58-1.71-2.36-3.7-5.01l-.03-.02Zm2.41 6.54c.56 1.15 1.19 2.52 1.11 3.81-.06.04-.12.07-.17.1-.03-.88-.55-2.66-.94-3.91Zm-16.51-32.73c1.86-2.65 3.65-5.35 5.57-7.95.4-.55.81-1.13 1.26-1.66.19-.18.38-.33.56-.45.18.03.36.08.55.13l-8.05 10.11.12-.18h-.01ZM192.7 95.48c.79-1.37 1.66-2.69 2.54-4 1.19-1.79 2.4-3.56 3.61-5.33-.04.09-.09.17-.13.26-.1.22.03.41.2.49-2.47 3.42-4.89 6.73-6.4 9.28.21.24.4.48.63.75-.24.07-.4.36-.17.56.4.33.72.77 1.05 1.17.09.11.18.21.27.32-.84-.61-1.66-1.24-2.47-1.88.24-.57.58-1.11.87-1.61v-.01Zm7.46-10.32c.47-.81.98-1.59 1.49-2.37.31-.48.64-.95.96-1.43.26-.29.52-.56.75-.79-.99 1.48-2.09 3.03-3.2 4.59Zm10.03-16.22s-.03-.05-.05-.07c.22-.29.43-.59.64-.89-.2.32-.4.65-.58.96h-.01ZM371.54 87.96c-.01-.08-.01-.16-.03-.23-.06-.38-.58-.29-.66.03-.3-.05-.6-.08-.81-.11-1.14-.15-2.29-.19-3.44-.2 1.04-.09 2.09-.18 3.14-.23.45-.02.45-.72 0-.7-6.57.35-13.14 1.23-19.65 2.11-1.53.21-3.05.42-4.57.68-.01 0-.02.01-.04.01-.04-3.33-.13-6.66-.24-9.99-.19-5.7-.4-11.41-.88-17.1-.13-1.51-.23-3.07-.49-4.58 0-.25 0-.48-.02-.68-.06-1.19-.04-2.61-.68-2.78-.16-.07-.72-.16-1.5-.24.22-.17.16-.62-.2-.63-1.19-.04-2.39.09-3.57.23-1.2.14-2.41.32-3.59.6-.16-.1-.41-.06-.5.12-.06.02-.13.03-.19.05-.35.1-.29.55-.03.66-.26.6-.19 2.27-.21 3-.02.66-.66 33.73-.9 40.3-.03.65.06 1.12.04 1.45-.16 3.05.87 4.96 6.34 3.93 1.09-.08 2.75-.77 5.36-1.43 4.13-1.04 5.78-1.52 6.2-1.65 6.43-1.69 6.78-1.97 11.72-2.43.55-.05 4.8-.38 6.03-.3.64.04 1.19.07 1.65.1.09 0 .16-.03.24-.05.1.27.56.33.66-.02.39-1.32.61-2.71.78-4.08.2-1.61.29-3.24.15-4.86.24.03.52-.23.38-.53-.09-.2-.27-.33-.49-.43v-.02Zm-.63.56c.07.57.11 1.14.11 1.71-.21-.99-.53-1.71-.95-1.87.22.03.44.06.65.11.06.01.12.04.19.05Zm-25.41 1.73c1.54-.36 3.1-.64 4.66-.89-1.61.37-3.18.77-4.66 1.2v-.31Zm-.86-7.37c-.07-1.37-.16-2.75-.25-4.12-.21-3.13-.45-6.27-.79-9.4.02-2.25.08-4.31.13-6.11.16 2.08.29 4.16.4 6.24.23 4.46.38 8.93.5 13.39h.01Zm-.94-4c.16 2.41.29 4.83.39 7.24.06 1.6.14 3.22.09 4.83-.15.05-.32.09-.47.14V78.88h-.01ZM483.72 92.83c-3.05-2.28-6.22-4.4-9.38-6.51 8.86-6.49 13.49-12.95 13.73-19.23.04-.76 0-1.5-.13-2.2-.67-3.82-3.5-6.68-8.39-8.48.13.04.27.08.4.13 3.92 1.39 7.74 4.23 8.5 8.56.34 1.95-.05 3.96-.98 5.69-.21.4.39.75.6.35 1.86-3.46 1.46-7.55-.97-10.63-3.53-4.47-9.76-5.88-15.16-6.16-2.32-.12-4.64-.04-6.95.19-6 .32-12.71 1.68-17.63 3.21-.37.11-.67.23-.92.35-.2-.17-.62.02-.57.37v.03c-.64.68-.18 1.64.48 3.21.38.91.67 1.89 1.15 2.58.32.76.68 1.51 1.13 2.19.14.21.38.19.53.07.19-.02.38-.05.57-.08v1.57c-.06.06-.1.13-.11.23-.27 4.18-.34 8.38-.48 12.57l-.3 9.03c-.24 3.91-.44 6.77-.46 7.26-.05.88-.11 1.95.07 2.81-.01.22-.02.43-.04.65 0 .11-.02.23-.03.35 0 .05-.03.27-.01.16-.05.4.5.59.64.28.05.04.12.08.2.08 1.75.13 3.5.28 5.25.3 1.69.02 3.38-.12 5.06-.32.08.23.36.39.55.15.06-.08.11-.17.16-.26.18-.09.24-.32.18-.48.05-.2.1-.4.13-.6.16-.86.25-1.74.33-2.62.11-1.17.17-2.34.23-3.51.15-.01.32-.03.52-.04.36-.03 1.73-.15 2.06-.15.39 0 .7-.02.95-.04 1.76 1.11 3.45 2.35 5.14 3.55 2.83 2.01 5.64 4.04 8.47 6.04 1.42 1 2.85 2 4.29 2.97.1.06.19.07.27.04.08 0 .17-.02.25-.1 1.61-1.56 3.15-3.18 4.6-4.88.75-.88 1.49-1.78 2.15-2.73.01.01.03.02.04.03.34.3.83-.2.49-.49-2.16-1.9-4.34-3.76-6.64-5.48l.03-.01Zm-6.38-3.65a55.72 55.72 0 0 0-4-2.13c.14-.1.26-.19.4-.29 1.2.81 2.4 1.61 3.6 2.42Zm-20.1 11.78c.67-.37 1.23-.91 1.67-1.6-.11.5-.24 1-.38 1.49-.43.04-.86.08-1.29.11Zm2.38-37.24c1.34-.31 2.56-.52 3.71-.69-1.03.19-2.04.41-3.04.65-.14-.07-.34-.02-.45.11-.07.02-.15.04-.22.05v-.13.01Zm.04.84c.07-.02.14-.03.2-.05.34 1.66.41 3.41.5 5.09.17 2.9.24 5.81.28 8.71l.03 3.17c-.17.07-.34.14-.51.2-.06-4.96-.21-10.58-.51-17.12h.01Zm16.04 5.62c-1.16 2.25-3.06 4.1-5.02 5.66-2.8 2.23-5.99 3.97-9.3 5.35-.01-3.56-.09-7.12-.27-10.67-.1-2.04-.16-4.16-.57-6.18 3.3-.78 6.72-1.36 10.1-1.1 1.85.14 4.23.59 5.32 2.29.92 1.43.46 3.24-.26 4.65Zm.85-.18c.6-1.37.9-2.92.28-4.32-.67-1.52-2.2-2.32-3.76-2.74.46.1.89.21 1.29.37 1.74.67 2.69 1.88 2.93 3.21.2 1.13-.05 2.25-.74 3.47V70Zm-27.47-4.14c-.12-.19-.23-.38-.34-.57.74.42.85.36.99.41v.08c-.22.03-.43.06-.65.08Zm11.21 30.46c-.08 1.08-.16 2.17-.33 3.24-.05.35-.11.69-.2 1.03 0 .04-.02.07-.03.11-.15.02-.3.04-.45.05.45-1.64.76-3.36.79-5.07.03-.29.08-.57.1-.89-.03-.31-.03-.47.24-.57-.04.69-.07 1.39-.12 2.08v.02Zm5.6-2.47c.48.11.92.52 2.49 1.72-.46-.32-.92-.65-1.38-.97-.37-.25-.73-.5-1.1-.75h-.01Zm21.23 7.24a70.76 70.76 0 0 1-4.37 4.63c-.14-.09-.27-.19-.4-.28.19-.09.37-.24.55-.47.87-1.14 5.43-5.51 5.49-7.45.31.26.62.53.92.79-.67.97-1.42 1.88-2.19 2.77v.01Z", fill: "currentColor", transform: "translate(-144.023 -51.76)" })] }), Lge = ({ style: e, size: t = "small", withText: n }) => D("div", { className: `ExcalidrawLogo is-${t}`, style: e, children: [m(Nge, {}), n && m(Dge, {})] }), c9 = ({ icon: e, shortcut: t, children: n }) => {
  let r = ur();
  return D(ge, { children: [m("div", { className: "welcome-screen-menu-item__icon", children: e }), m("div", { className: "welcome-screen-menu-item__text", children: n }), t && !r.editor.isMobile && m("div", { className: "welcome-screen-menu-item__shortcut", children: t })] });
};
c9.displayName = "WelcomeScreenMenuItemContent";
var t1 = ({ onSelect: e, children: t, icon: n, shortcut: r, className: i = "", ...a }) => m("button", { ...a, type: "button", className: `welcome-screen-menu-item ${i}`, onClick: e, children: m(c9, { icon: n, shortcut: r, children: t }) });
t1.displayName = "WelcomeScreenMenuItem";
var eO = ({ children: e, href: t, icon: n, shortcut: r, className: i = "", ...a }) => m("a", { ...a, className: `welcome-screen-menu-item ${i}`, href: t, target: "_blank", rel: "noreferrer", children: m(c9, { icon: n, shortcut: r, children: e }) });
eO.displayName = "WelcomeScreenMenuItemLink";
var Ls = ({ children: e }) => {
  let { WelcomeScreenCenterTunnel: t } = Li();
  return m(t.In, { children: m("div", { className: "welcome-screen-center", children: e || D(ge, { children: [m(d9, {}), m(u9, { children: N("welcomeScreen.defaults.center_heading") }), D(h9, { children: [m(p9, {}), m(f9, {})] })] }) }) });
};
Ls.displayName = "Center";
var d9 = ({ children: e }) => m("div", { className: "welcome-screen-center__logo excalifont welcome-screen-decor", children: e || m(Lge, { withText: !0 }) });
d9.displayName = "Logo";
var u9 = ({ children: e }) => m("div", { className: "welcome-screen-center__heading welcome-screen-decor excalifont", children: e });
u9.displayName = "Heading";
var h9 = ({ children: e }) => m("div", { className: "welcome-screen-menu", children: e });
h9.displayName = "Menu";
var f9 = () => {
  let e = mi();
  return m(t1, { onSelect: () => e.executeAction(jU), shortcut: "?", icon: _8, children: N("helpDialog.title") });
};
f9.displayName = "MenuItemHelp";
var p9 = () => {
  let e = Zr(), t = mi();
  return e.viewModeEnabled ? null : m(t1, { onSelect: () => t.executeAction(Q7), shortcut: Pr("loadScene"), icon: k8, children: N("buttons.load") });
};
p9.displayName = "MenuItemLoadScene";
var tO = ({ onSelect: e }) => {
  let { t } = Fr();
  return m(t1, { shortcut: null, onSelect: e, icon: aA, children: t("labels.liveCollaboration") });
};
tO.displayName = "MenuItemLiveCollaborationTrigger";
Ls.Logo = d9;
Ls.Heading = u9;
Ls.Menu = h9;
Ls.MenuItem = t1;
Ls.MenuItemLink = eO;
Ls.MenuItemHelp = f9;
Ls.MenuItemLoadScene = p9;
Ls.MenuItemLiveCollaborationTrigger = tO;
var Rge = ({ children: e }) => {
  let { WelcomeScreenMenuHintTunnel: t } = Li();
  return m(t.In, { children: D("div", { className: "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--menu", children: [_q, m("div", { className: "welcome-screen-decor-hint__label", children: e || N("welcomeScreen.defaults.menuHint") })] }) });
};
Rge.displayName = "MenuHint";
var Pge = ({ children: e }) => {
  let { WelcomeScreenToolbarHintTunnel: t } = Li();
  return m(t.In, { children: D("div", { className: "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--toolbar", children: [m("div", { className: "welcome-screen-decor-hint__label", children: e || N("welcomeScreen.defaults.toolbarHint") }), Cq] }) });
};
Pge.displayName = "ToolbarHint";
var Oge = ({ children: e }) => {
  let { WelcomeScreenHelpHintTunnel: t } = Li();
  return m(t.In, { children: D("div", { className: "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--help", children: [m("div", { children: e || N("welcomeScreen.defaults.helpHint") }), kq] }) });
};
Oge.displayName = "HelpHint";
Of((e, t, n) => {
  if (st.DEV || st.MODE === oi.TEST || window != null && window.DEBUG_FRACTIONAL_INDICES) {
    let r = xs(e.map((i) => ({ ...i })));
    B8(r, { shouldThrow: st.DEV || st.MODE === oi.TEST, includeBoundTextValidation: !0, reconciliationContext: { localElements: t, remoteElements: n } });
  }
}, 1e3 * 60, { leading: !0, trailing: !1 });
Age();
var $ge = (e) => {
  var j, V, q, oe;
  let { onChange: t, initialData: n, excalidrawAPI: r, isCollaborating: i = !1, onPointerUpdate: a, renderTopRightUI: l, langCode: s = su.code, viewModeEnabled: c, zenModeEnabled: d, gridModeEnabled: o, libraryReturnUrl: u, theme: h, name: f, renderCustomStats: p, onPaste: g, detectScroll: b = !0, handleKeyboardGlobally: v = !1, onLibraryChange: U, autoFocus: y = !1, generateIdForFile: w, onLinkOpen: x, generateLinkForSelection: E, onPointerDown: S, onPointerUp: _, onScrollChange: k, onDuplicate: M, children: A, validateEmbeddable: L, renderEmbeddable: R, aiEnabled: z, showDeprecatedFonts: F } = e, W = (j = e.UIOptions) == null ? void 0 : j.canvasActions, B = { ...e.UIOptions, canvasActions: { ...Bw.canvasActions, ...W }, tools: { image: ((q = (V = e.UIOptions) == null ? void 0 : V.tools) == null ? void 0 : q.image) ?? !0 } };
  return W != null && W.export && (B.canvasActions.export.saveFileToDisk = ((oe = W.export) == null ? void 0 : oe.saveFileToDisk) ?? Bw.canvasActions.export.saveFileToDisk), B.canvasActions.toggleTheme === null && typeof h > "u" && (B.canvasActions.toggleTheme = !0), Y(() => {
    (async () => await import("./roundRect-DxA6ocdw.js"))();
    let Ue = (fe) => {
      typeof fe.scale == "number" && fe.scale !== 1 && fe.preventDefault();
    };
    return document.addEventListener("touchmove", Ue, { passive: !1 }), () => {
      document.removeEventListener("touchmove", Ue);
    };
  }, []), m(kue, { store: _a, children: m(Iue, { langCode: s, theme: h, children: m(Tge, { onChange: t, initialData: n, excalidrawAPI: r, isCollaborating: i, onPointerUpdate: a, renderTopRightUI: l, langCode: s, viewModeEnabled: c, zenModeEnabled: d, gridModeEnabled: o, libraryReturnUrl: u, theme: h, name: f, renderCustomStats: p, UIOptions: B, onPaste: g, detectScroll: b, handleKeyboardGlobally: v, onLibraryChange: U, autoFocus: y, generateIdForFile: w, onLinkOpen: x, generateLinkForSelection: E, onPointerDown: S, onPointerUp: _, onScrollChange: k, onDuplicate: M, validateEmbeddable: L, renderEmbeddable: R, aiEnabled: z !== !1, showDeprecatedFonts: F, children: A }) }) });
}, Fge = (e, t) => {
  if (e.children !== t.children) return !1;
  let { initialData: n, UIOptions: r = {}, ...i } = e, { initialData: a, UIOptions: l = {}, ...s } = t, c = Object.keys(r), d = Object.keys(l);
  return c.length !== d.length ? !1 : c.every((o) => o === "canvasActions" ? Object.keys(r.canvasActions).every((u) => {
    var h, f, p, g;
    return u === "export" && ((h = r == null ? void 0 : r.canvasActions) != null && h.export) && ((f = l == null ? void 0 : l.canvasActions) != null && f.export) ? r.canvasActions.export.saveFileToDisk === l.canvasActions.export.saveFileToDisk : ((p = r == null ? void 0 : r.canvasActions) == null ? void 0 : p[u]) === ((g = l == null ? void 0 : l.canvasActions) == null ? void 0 : g[u]);
  }) : r[o] === l[o]) && Tr(i, s);
}, nO = pe.memo($ge, Fge);
nO.displayName = "Excalidraw";
function zge(e) {
  return typeof e == "object" && e !== null && "nodeType" in e && typeof e.nodeType == "number";
}
function Bge({
  closeOnClickOutside: e = !1,
  onSave: t,
  initialElements: n,
  initialAppState: r,
  initialFiles: i,
  isShown: a = !1,
  onDelete: l,
  onClose: s
}) {
  const c = de(null), [d, o] = Q(null), [u, h] = Q(!1), [f, p] = Q(n), [g, b] = Q(i);
  Y(() => {
    var x;
    (x = c.current) == null || x.focus();
  }, []), Y(() => {
    var S;
    let x = null;
    const E = (_) => {
      const k = _.target;
      c.current !== null && zge(k) && !c.current.contains(k) && e && l();
    };
    return c.current !== null && (x = (S = c.current) == null ? void 0 : S.parentElement, x == null || x.addEventListener("click", E)), () => {
      x == null || x.removeEventListener("click", E);
    };
  }, [e, l]), Bn(() => {
    const x = c.current, E = (S) => {
      S.key === "Escape" && l();
    };
    return x == null || x.addEventListener("keydown", E), () => {
      x == null || x.removeEventListener("keydown", E);
    };
  }, [f, g, l]);
  const v = () => {
    if (f != null && f.some((x) => !x.isDeleted)) {
      const x = d == null ? void 0 : d.getAppState(), E = {
        exportBackground: x == null ? void 0 : x.exportBackground,
        exportScale: x == null ? void 0 : x.exportScale,
        exportWithDarkMode: (x == null ? void 0 : x.theme) === "dark",
        isBindingEnabled: x == null ? void 0 : x.isBindingEnabled,
        isLoading: x == null ? void 0 : x.isLoading,
        name: x == null ? void 0 : x.name,
        theme: x == null ? void 0 : x.theme,
        viewBackgroundColor: x == null ? void 0 : x.viewBackgroundColor,
        viewModeEnabled: x == null ? void 0 : x.viewModeEnabled,
        zenModeEnabled: x == null ? void 0 : x.zenModeEnabled,
        zoom: x == null ? void 0 : x.zoom
      };
      t(f, E, g);
    } else
      l();
  }, U = () => {
    h(!0);
  };
  function y() {
    return /* @__PURE__ */ D(
      vT,
      {
        title: "Discard",
        onClose: () => {
          h(!1);
        },
        closeOnClickOutside: !1,
        children: [
          "Are you sure you want to discard the changes?",
          /* @__PURE__ */ D("div", { className: "ExcalidrawModal__discardModal", children: [
            /* @__PURE__ */ m(
              Qi,
              {
                onClick: () => {
                  h(!1), s();
                },
                children: "Discard"
              }
            ),
            " ",
            /* @__PURE__ */ m(
              Qi,
              {
                onClick: () => {
                  h(!1);
                },
                children: "Cancel"
              }
            )
          ] })
        ]
      }
    );
  }
  return a === !1 ? null : fi(
    /* @__PURE__ */ m("div", { className: "ExcalidrawModal__overlay", role: "dialog", children: /* @__PURE__ */ m(
      "div",
      {
        className: "ExcalidrawModal__modal",
        ref: c,
        tabIndex: -1,
        children: /* @__PURE__ */ D("div", { className: "ExcalidrawModal__row", children: [
          u && /* @__PURE__ */ m(y, {}),
          /* @__PURE__ */ m(
            nO,
            {
              onChange: (x, E, S) => {
                p(x), b(S);
              },
              excalidrawAPI: o,
              initialData: {
                appState: r || { isLoading: !1 },
                elements: n,
                files: i
              }
            }
          ),
          /* @__PURE__ */ D("div", { className: "ExcalidrawModal__actions", children: [
            /* @__PURE__ */ m("button", { className: "action-button", onClick: U, type: "button", children: "Discard" }),
            /* @__PURE__ */ m("button", { className: "action-button", onClick: v, type: "button", children: "Save" })
          ] })
        ] })
      }
    ) }),
    document.body
  );
}
const m9 = xn();
function Hge() {
  const [e] = Fe(), [t, n] = Q(!1);
  return Y(() => {
    if (!e.hasNodes([Rc]))
      throw new Error(
        "ExcalidrawPlugin: ExcalidrawNode not registered on editor"
      );
    return e.registerCommand(
      m9,
      () => (n(!0), !0),
      it
    );
  }, [e]), t ? /* @__PURE__ */ m(
    Bge,
    {
      initialElements: [],
      initialAppState: {},
      initialFiles: {},
      isShown: t,
      onDelete: () => {
        n(!1);
      },
      onClose: () => {
        n(!1);
      },
      onSave: (l, s, c) => {
        e.update(() => {
          const d = lT();
          d.setData(
            JSON.stringify({
              appState: s,
              elements: l,
              files: c
            })
          ), z0([d]), er(d.getParentOrThrow()) && xf(d, He).selectEnd();
        }), n(!1);
      },
      closeOnClickOutside: !1
    }
  ) : null;
}
Ci({
  cellEditorConfig: null,
  cellEditorPlugins: null,
  set: () => {
  }
});
function rO({
  activeEditor: e,
  onClose: t
}) {
  const [n, r] = Q("5"), [i, a] = Q("5"), [l, s] = Q(!0);
  return Y(() => {
    const d = Number(n), o = Number(i);
    d && d > 0 && d <= 500 && o && o > 0 && o <= 50 ? s(!1) : s(!0);
  }, [n, i]), /* @__PURE__ */ D(ge, { children: [
    /* @__PURE__ */ m(
      xo,
      {
        placeholder: "# of rows (1-500)",
        label: "Rows",
        onChange: r,
        value: n,
        "data-test-id": "table-modal-rows",
        type: "number"
      }
    ),
    /* @__PURE__ */ m(
      xo,
      {
        placeholder: "# of columns (1-50)",
        label: "Columns",
        onChange: a,
        value: i,
        "data-test-id": "table-modal-columns",
        type: "number"
      }
    ),
    /* @__PURE__ */ m(J0, { "data-test-id": "table-model-confirm-insert", children: /* @__PURE__ */ m(Qi, { disabled: l, onClick: () => {
      e.dispatchCommand(fb, {
        columns: i,
        rows: n
      }), t();
    }, children: "Confirm" }) })
  ] });
}
const iO = xn();
function aO({
  activeEditor: e,
  onClose: t
}) {
  const [n, r] = Q(""), i = () => {
    e.dispatchCommand(iO, n), t();
  };
  return /* @__PURE__ */ D(ge, { children: [
    /* @__PURE__ */ m(xo, { label: "Question", onChange: r, value: n }),
    /* @__PURE__ */ m(J0, { children: /* @__PURE__ */ m(Qi, { disabled: n.trim() === "", onClick: i, children: "Confirm" }) })
  ] });
}
function Wge() {
  const [e] = Fe();
  return Y(() => {
    if (!e.hasNodes([Y0]))
      throw new Error("PollPlugin: PollNode not registered on editor");
    return e.registerCommand(
      iO,
      (t) => {
        const n = Yb(t, [
          wy(),
          wy()
        ]);
        return z0([n]), er(n.getParentOrThrow()) && xf(n, He).selectEnd(), !0;
      },
      it
    );
  }, [e]), null;
}
const lO = xn(), Xge = xn();
function Vge() {
  const [e] = Fe();
  return Y(() => {
    if (!e.hasNodes([Pc, Oc]))
      throw new Error(
        "LayoutPlugin: LayoutContainerNode, or LayoutItemNode not registered on editor"
      );
    const t = (n) => {
      var i, a;
      const r = se();
      if (ie(r) && r.isCollapsed() && r.anchor.offset === 0) {
        const l = Xe(
          r.anchor.getNode(),
          y1
        );
        if (y1(l)) {
          const s = l.getParent(), c = s && (n ? s.getFirstChild() : s == null ? void 0 : s.getLastChild()), d = n ? (i = l.getFirstDescendant()) == null ? void 0 : i.getKey() : (a = l.getLastDescendant()) == null ? void 0 : a.getKey();
          s !== null && c === l && r.anchor.key === d && (n ? l.insertBefore(He()) : l.insertAfter(He()));
        }
      }
      return !1;
    };
    return Pt(
      // When layout is the last child pressing down/right arrow will insert paragraph
      // below it to allow adding more content. It's similar what $insertBlockNode
      // (mainly for decorators), except it'll always be possible to continue adding
      // new content even if trailing paragraph is accidentally deleted
      e.registerCommand(
        Ao,
        () => t(!1),
        ot
      ),
      e.registerCommand(
        pf,
        () => t(!1),
        ot
      ),
      // When layout is the first child pressing up/left arrow will insert paragraph
      // above it to allow adding more content. It's similar what $insertBlockNode
      // (mainly for decorators), except it'll always be possible to continue adding
      // new content even if leading paragraph is accidentally deleted
      e.registerCommand(
        Io,
        () => t(!0),
        ot
      ),
      e.registerCommand(
        R0,
        () => t(!0),
        ot
      ),
      e.registerCommand(
        lO,
        (n) => (e.update(() => {
          const r = sT(n), i = z5(n);
          for (let a = 0; a < i; a++)
            r.append(
              R4().append(He())
            );
          Lo(r), r.selectStart();
        }), !0),
        it
      ),
      e.registerCommand(
        Xge,
        ({ template: n, nodeKey: r }) => (e.update(() => {
          const i = Rt(r);
          if (!y1(i))
            return;
          const a = z5(n), l = z5(
            i.getTemplateColumns()
          );
          if (a > l)
            for (let s = l; s < a; s++)
              i.append(
                R4().append(He())
              );
          else if (a < l)
            for (let s = l - 1; s >= a; s--) {
              const c = i.getChildAtIndex(s);
              yy(c) && c.remove();
            }
          i.setTemplateColumns(n);
        }), !0),
        it
      ),
      // Structure enforcing transformers for each node type. In case nesting structure is not
      // "Container > Item" it'll unwrap nodes and convert it back
      // to regular content.
      e.registerNodeTransform(Oc, (n) => {
        const r = n.getParent();
        if (!y1(r)) {
          const i = n.getChildren();
          for (const a of i)
            n.insertBefore(a);
          n.remove();
        }
      }),
      e.registerNodeTransform(Pc, (n) => {
        const r = n.getChildren();
        if (!r.every(yy)) {
          for (const i of r)
            n.insertBefore(i);
          n.remove();
        }
      })
    );
  }, [e]), null;
}
function z5(e) {
  return e.trim().split(/\s+/).length;
}
const B5 = [
  { label: "2 columns (equal width)", value: "1fr 1fr" },
  { label: "2 columns (25% - 75%)", value: "1fr 3fr" },
  { label: "3 columns (equal width)", value: "1fr 1fr 1fr" },
  { label: "3 columns (25% - 50% - 25%)", value: "1fr 2fr 1fr" },
  { label: "4 columns (equal width)", value: "1fr 1fr 1fr 1fr" }
];
function sO({
  activeEditor: e,
  onClose: t
}) {
  var l;
  const [n, r] = Q(B5[0].value), i = (l = B5.find((s) => s.value === n)) == null ? void 0 : l.label, a = () => {
    e.dispatchCommand(lO, n), t();
  };
  return /* @__PURE__ */ D(ge, { children: [
    /* @__PURE__ */ m(
      $c,
      {
        buttonClassName: "toolbar-item dialog-dropdown",
        buttonLabel: i,
        children: B5.map(({ label: s, value: c }) => /* @__PURE__ */ m(
          St,
          {
            className: "item",
            onClick: () => r(c),
            children: /* @__PURE__ */ m("span", { className: "text", children: s })
          },
          c
        ))
      }
    ),
    /* @__PURE__ */ m(Qi, { onClick: a, children: "Insert" })
  ] });
}
function h3(e, t) {
  return h3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, h3(e, t);
}
function Gge(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, h3(e, t);
}
var jge = function(t, n) {
  return t === void 0 && (t = []), n === void 0 && (n = []), t.length !== n.length || t.some(function(r, i) {
    return !Object.is(r, n[i]);
  });
}, I_ = {
  error: null
}, Kge = /* @__PURE__ */ function(e) {
  Gge(t, e);
  function t() {
    for (var r, i = arguments.length, a = new Array(i), l = 0; l < i; l++)
      a[l] = arguments[l];
    return r = e.call.apply(e, [this].concat(a)) || this, r.state = I_, r.resetErrorBoundary = function() {
      for (var s, c = arguments.length, d = new Array(c), o = 0; o < c; o++)
        d[o] = arguments[o];
      r.props.onReset == null || (s = r.props).onReset.apply(s, d), r.reset();
    }, r;
  }
  t.getDerivedStateFromError = function(i) {
    return {
      error: i
    };
  };
  var n = t.prototype;
  return n.reset = function() {
    this.setState(I_);
  }, n.componentDidCatch = function(i, a) {
    var l, s;
    (l = (s = this.props).onError) == null || l.call(s, i, a);
  }, n.componentDidUpdate = function(i, a) {
    var l = this.state.error, s = this.props.resetKeys;
    if (l !== null && a.error !== null && jge(i.resetKeys, s)) {
      var c, d;
      (c = (d = this.props).onResetKeysChange) == null || c.call(d, i.resetKeys, s), this.reset();
    }
  }, n.render = function() {
    var i = this.state.error, a = this.props, l = a.fallbackRender, s = a.FallbackComponent, c = a.fallback;
    if (i !== null) {
      var d = {
        error: i,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (/* @__PURE__ */ J.isValidElement(c))
        return c;
      if (typeof l == "function")
        return l(d);
      if (s)
        return /* @__PURE__ */ J.createElement(s, d);
      throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
    }
    return this.props.children;
  }, t;
}(J.Component);
function Yge({
  equation: e,
  inline: t,
  onDoubleClick: n
}) {
  const r = de(null);
  return Y(() => {
    const i = r.current;
    i !== null && jb.render(e, i, {
      displayMode: !t,
      // true === block display //
      errorColor: "#cc0000",
      output: "html",
      strict: "warn",
      throwOnError: !1,
      trust: !1
    });
  }, [e, t]), // We use an empty image tag either side to ensure Android doesn't try and compose from the
  // inner text from Katex. There didn't seem to be any other way of making this work,
  // without having a physical space.
  /* @__PURE__ */ D(ge, { children: [
    /* @__PURE__ */ m("img", { src: "#", alt: "" }),
    /* @__PURE__ */ m(
      "span",
      {
        role: "button",
        tabIndex: -1,
        onDoubleClick: n,
        ref: r
      }
    ),
    /* @__PURE__ */ m("img", { src: "#", alt: "" })
  ] });
}
function qge({
  onConfirm: e,
  initialEquation: t = ""
}) {
  const [n] = Fe(), [r, i] = Q(t), [a, l] = Q(!0), s = he(() => {
    e(r, a);
  }, [e, r, a]), c = he(() => {
    l(!a);
  }, [l, a]);
  return /* @__PURE__ */ D(ge, { children: [
    /* @__PURE__ */ D("div", { className: "KatexEquationAlterer_defaultRow", children: [
      "Inline",
      /* @__PURE__ */ m("input", { type: "checkbox", checked: a, onChange: c })
    ] }),
    /* @__PURE__ */ m("div", { className: "KatexEquationAlterer_defaultRow", children: "Equation " }),
    /* @__PURE__ */ m("div", { className: "KatexEquationAlterer_centerRow", children: a ? /* @__PURE__ */ m(
      "input",
      {
        onChange: (d) => {
          i(d.target.value);
        },
        value: r,
        className: "KatexEquationAlterer_textArea"
      }
    ) : /* @__PURE__ */ m(
      "textarea",
      {
        onChange: (d) => {
          i(d.target.value);
        },
        value: r,
        className: "KatexEquationAlterer_textArea"
      }
    ) }),
    /* @__PURE__ */ m("div", { className: "KatexEquationAlterer_defaultRow", children: "Visualization " }),
    /* @__PURE__ */ m("div", { className: "KatexEquationAlterer_centerRow", children: /* @__PURE__ */ m(Kge, { onError: (d) => n._onError(d), fallback: null, children: /* @__PURE__ */ m(
      Yge,
      {
        equation: r,
        inline: !1,
        onDoubleClick: () => null
      }
    ) }) }),
    /* @__PURE__ */ m("div", { className: "KatexEquationAlterer_dialogActions", children: /* @__PURE__ */ m(Qi, { onClick: s, children: "Confirm" }) })
  ] });
}
const oO = xn();
function cO({
  activeEditor: e,
  onClose: t
}) {
  const n = he(
    (r, i) => {
      e.dispatchCommand(oO, { equation: r, inline: i }), t();
    },
    [e, t]
  );
  return /* @__PURE__ */ m(qge, { onConfirm: n });
}
function Zge() {
  const [e] = Fe();
  return Y(() => {
    if (!e.hasNodes([K0]))
      throw new Error(
        "EquationsPlugins: EquationsNode not registered on editor"
      );
    return e.registerCommand(
      oO,
      (t) => {
        const { equation: n, inline: r } = t, i = Kb(n, r);
        return z0([i]), er(i.getParentOrThrow()) && xf(i, He).selectEnd(), !0;
      },
      it
    );
  }, [e]), null;
}
const g9 = xn();
function Jge() {
  const [e] = Fe();
  return Y(() => {
    if (!e.hasNodes([
      Nc,
      Lc,
      Dc
    ]))
      throw new Error(
        "CollapsiblePlugin: CollapsibleContainerNode, CollapsibleTitleNode, or CollapsibleContentNode not registered on editor"
      );
    const t = () => {
      var i;
      const r = se();
      if (ie(r) && r.isCollapsed() && r.anchor.offset === 0) {
        const a = Xe(
          r.anchor.getNode(),
          Wl
        );
        if (Wl(a)) {
          const l = a.getParent();
          l !== null && l.getFirstChild() === a && r.anchor.key === ((i = a.getFirstDescendant()) == null ? void 0 : i.getKey()) && a.insertBefore(He());
        }
      }
      return !1;
    }, n = () => {
      const r = se();
      if (ie(r) && r.isCollapsed()) {
        const i = Xe(
          r.anchor.getNode(),
          Wl
        );
        if (Wl(i)) {
          const a = i.getParent();
          if (a !== null && a.getLastChild() === i) {
            const l = i.getFirstDescendant(), s = i.getLastDescendant();
            (s !== null && r.anchor.key === s.getKey() && r.anchor.offset === s.getTextContentSize() || l !== null && r.anchor.key === l.getKey() && r.anchor.offset === l.getTextContentSize()) && i.insertAfter(He());
          }
        }
      }
      return !1;
    };
    return Pt(
      // Structure enforcing transformers for each node type. In case nesting structure is not
      // "Container > Title + Content" it'll unwrap nodes and convert it back
      // to regular content.
      e.registerNodeTransform(Dc, (r) => {
        const i = r.getParent();
        if (!Wl(i)) {
          const a = r.getChildren();
          for (const l of a)
            r.insertBefore(l);
          r.remove();
        }
      }),
      e.registerNodeTransform(Lc, (r) => {
        const i = r.getParent();
        if (!Wl(i)) {
          r.replace(
            He().append(...r.getChildren())
          );
          return;
        }
      }),
      e.registerNodeTransform(Nc, (r) => {
        const i = r.getChildren();
        if (i.length !== 2 || !$v(i[0]) || !aM(i[1])) {
          for (const a of i)
            r.insertBefore(a);
          r.remove();
        }
      }),
      // This handles the case when container is collapsed and we delete its previous sibling
      // into it, it would cause collapsed content deleted (since it's display: none, and selection
      // swallows it when deletes single char). Instead we expand container, which is although
      // not perfect, but avoids bigger problem
      e.registerCommand(
        ls,
        () => {
          const r = se();
          if (!ie(r) || !r.isCollapsed() || r.anchor.offset !== 0)
            return !1;
          const a = r.anchor.getNode().getTopLevelElement();
          if (a === null)
            return !1;
          const l = a.getPreviousSibling();
          return !Wl(l) || l.getOpen() ? !1 : (l.setOpen(!0), !0);
        },
        ot
      ),
      // When collapsible is the last child pressing down/right arrow will insert paragraph
      // below it to allow adding more content. It's similar what $insertBlockNode
      // (mainly for decorators), except it'll always be possible to continue adding
      // new content even if trailing paragraph is accidentally deleted
      e.registerCommand(
        Ao,
        n,
        ot
      ),
      e.registerCommand(
        pf,
        n,
        ot
      ),
      // When collapsible is the first child pressing up/left arrow will insert paragraph
      // above it to allow adding more content. It's similar what $insertBlockNode
      // (mainly for decorators), except it'll always be possible to continue adding
      // new content even if leading paragraph is accidentally deleted
      e.registerCommand(
        Io,
        t,
        ot
      ),
      e.registerCommand(
        R0,
        t,
        ot
      ),
      // Handling CMD+Enter to toggle collapsible element collapsed state
      e.registerCommand(
        kc,
        () => {
          var i;
          const r = (i = e._window) == null ? void 0 : i.event;
          if (r && (r.ctrlKey || r.metaKey) && r.key === "Enter") {
            const a = Do();
            if (ie(a) && a.isCollapsed()) {
              const l = Xe(
                a.anchor.getNode(),
                (s) => re(s) && !s.isInline()
              );
              if ($v(l)) {
                const s = l.getParent();
                if (Wl(s))
                  return s.toggleOpen(), pn(a.clone()), !0;
              }
            }
          }
          return !1;
        },
        ot
      ),
      e.registerCommand(
        g9,
        () => (e.update(() => {
          const r = kb(), i = He();
          Lo(
            Sb(!0).append(
              r.append(i),
              _b().append(He())
            )
          ), i.select();
        }), !0),
        ot
      )
    );
  }, [e]), null;
}
const A_ = "startTransition", f3 = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, Qge = f3 ? Bn : Y;
let e2e = class {
  constructor(t) {
    this.key = t, this.ref = { current: null }, this.setRefElement = this.setRefElement.bind(this);
  }
  setRefElement(t) {
    this.ref = { current: t };
  }
};
const N_ = (e) => {
  const t = document.getElementById("typeahead-menu");
  if (!t) return;
  const n = t.getBoundingClientRect();
  n.top + n.height > window.innerHeight && t.scrollIntoView({ block: "center" }), n.top < 0 && t.scrollIntoView({ block: "center" }), e.scrollIntoView({ block: "nearest" });
};
function D_(e, t) {
  const n = e.getBoundingClientRect(), r = t.getBoundingClientRect();
  return n.top > r.top && n.top < r.bottom;
}
function t2e(e, t, n, r) {
  const [i] = Fe();
  Y(() => {
    if (t != null && e != null) {
      const a = i.getRootElement(), l = a != null ? function(u, h) {
        let f = getComputedStyle(u);
        const p = f.position === "absolute", g = /(auto|scroll)/;
        if (f.position === "fixed") return document.body;
        for (let b = u; b = b.parentElement; ) if (f = getComputedStyle(b), (!p || f.position !== "static") && g.test(f.overflow + f.overflowY + f.overflowX)) return b;
        return document.body;
      }(a) : document.body;
      let s = !1, c = D_(t, l);
      const d = function() {
        s || (window.requestAnimationFrame(function() {
          n(), s = !1;
        }), s = !0);
        const u = D_(t, l);
        u !== c && (c = u, r != null && r(u));
      }, o = new ResizeObserver(n);
      return window.addEventListener("resize", n), document.addEventListener("scroll", d, { capture: !0, passive: !0 }), o.observe(t), () => {
        o.unobserve(t), window.removeEventListener("resize", n), document.removeEventListener("scroll", d, !0);
      };
    }
  }, [t, i, r, n, e]);
}
const L_ = xn();
function n2e({ close: e, editor: t, anchorElementRef: n, resolution: r, options: i, menuRenderFn: a, onSelectOption: l, shouldSplitNodeWithQuery: s = !1, commandPriority: c = ot }) {
  const [d, o] = Q(null), u = r.match && r.match.matchingString;
  Y(() => {
    o(0);
  }, [u]);
  const h = he((p) => {
    t.update(() => {
      const g = r.match != null && s ? function(b) {
        const v = se();
        if (!ie(v) || !v.isCollapsed()) return null;
        const U = v.anchor;
        if (U.type !== "text") return null;
        const y = U.getNode();
        if (!y.isSimpleText()) return null;
        const w = U.offset, x = y.getTextContent().slice(0, w), E = b.replaceableString.length, S = w - function(k, M, A) {
          let L = A;
          for (let R = L; R <= M.length; R++) k.substr(-R) === M.substr(0, R) && (L = R);
          return L;
        }(x, b.matchingString, E);
        if (S < 0) return null;
        let _;
        return S === 0 ? [_] = y.splitText(w) : [, _] = y.splitText(S, w), _;
      }(r.match) : null;
      l(p, g, e, r.match ? r.match.matchingString : "");
    });
  }, [t, s, r.match, l, e]), f = he((p) => {
    const g = t.getRootElement();
    g !== null && (g.setAttribute("aria-activedescendant", "typeahead-item-" + p), o(p));
  }, [t]);
  return Y(() => () => {
    const p = t.getRootElement();
    p !== null && p.removeAttribute("aria-activedescendant");
  }, [t]), Qge(() => {
    i === null ? o(null) : d === null && f(0);
  }, [i, d, f]), Y(() => Pt(t.registerCommand(L_, ({ option: p }) => !(!p.ref || p.ref.current == null) && (N_(p.ref.current), !0), c)), [t, f, c]), Y(() => Pt(t.registerCommand(Ao, (p) => {
    const g = p;
    if (i !== null && i.length && d !== null) {
      const b = d !== i.length - 1 ? d + 1 : 0;
      f(b);
      const v = i[b];
      v.ref != null && v.ref.current && t.dispatchCommand(L_, { index: b, option: v }), g.preventDefault(), g.stopImmediatePropagation();
    }
    return !0;
  }, c), t.registerCommand(Io, (p) => {
    const g = p;
    if (i !== null && i.length && d !== null) {
      const b = d !== 0 ? d - 1 : i.length - 1;
      f(b);
      const v = i[b];
      v.ref != null && v.ref.current && N_(v.ref.current), g.preventDefault(), g.stopImmediatePropagation();
    }
    return !0;
  }, c), t.registerCommand(rd, (p) => {
    const g = p;
    return g.preventDefault(), g.stopImmediatePropagation(), e(), !0;
  }, c), t.registerCommand(mf, (p) => {
    const g = p;
    return i !== null && d !== null && i[d] != null && (g.preventDefault(), g.stopImmediatePropagation(), h(i[d]), !0);
  }, c), t.registerCommand(a0, (p) => i !== null && d !== null && i[d] != null && (p !== null && (p.preventDefault(), p.stopImmediatePropagation()), h(i[d]), !0), c)), [h, e, t, i, d, f, c]), a(n, Ke(() => ({ options: i, selectOptionAndCleanUp: h, selectedIndex: d, setHighlightedIndex: o }), [h, d, i]), r.match ? r.match.matchingString : "");
}
function r2e({ options: e, nodeKey: t, onClose: n, onOpen: r, onSelectOption: i, menuRenderFn: a, anchorClassName: l, commandPriority: s = ot, parent: c }) {
  const [d] = Fe(), [o, u] = Q(null), h = function(b, v, U, y = f3 ? document.body : void 0, w = !0) {
    const [x] = Fe(), E = de(f3 ? document.createElement("div") : null), S = he(() => {
      if (E.current === null || y === void 0) return;
      E.current.style.top = E.current.style.bottom;
      const k = x.getRootElement(), M = E.current, A = M.firstChild;
      if (k !== null && b !== null) {
        const { left: L, top: R, width: z, height: F } = b.getRect(), W = E.current.offsetHeight;
        if (M.style.top = `${R + W + 3 + (w ? window.pageYOffset : 0)}px`, M.style.left = `${L + window.pageXOffset}px`, M.style.height = `${F}px`, M.style.width = `${z}px`, A !== null) {
          A.style.top = `${R}`;
          const B = A.getBoundingClientRect(), j = B.height, V = B.width, q = k.getBoundingClientRect();
          L + V > q.right && (M.style.left = `${q.right - V + window.pageXOffset}px`), (R + j > window.innerHeight || R + j > q.bottom) && R - q.top > j + F && (M.style.top = `${R - j - F + (w ? window.pageYOffset : 0)}px`);
        }
        M.isConnected || (U != null && (M.className = U), M.setAttribute("aria-label", "Typeahead menu"), M.setAttribute("id", "typeahead-menu"), M.setAttribute("role", "listbox"), M.style.display = "block", M.style.position = "absolute", y.append(M)), E.current = M, k.setAttribute("aria-controls", "typeahead-menu");
      }
    }, [x, b, w, U, y]);
    Y(() => {
      const k = x.getRootElement();
      if (b !== null) return S(), () => {
        k !== null && k.removeAttribute("aria-controls");
        const M = E.current;
        M !== null && M.isConnected && M.remove();
      };
    }, [x, S, b]);
    const _ = he((k) => {
      b !== null && (k || v(null));
    }, [b, v]);
    return t2e(b, E.current, S, _), E;
  }(o, u, l, c), f = he(() => {
    u(null), n != null && o !== null && n();
  }, [n, o]), p = he((b) => {
    u(b), r != null && o === null && r(b);
  }, [r, o]), g = he(() => {
    t ? d.update(() => {
      const b = Rt(t), v = d.getElementByKey(t);
      var U;
      b != null && v != null && o == null && (U = () => p({ getRect: () => v.getBoundingClientRect() }), A_ in pe ? pe[A_](U) : U());
    }) : t == null && o != null && f();
  }, [f, d, t, p, o]);
  return Y(() => {
    g();
  }, [g, t]), Y(() => {
    if (t != null) return d.registerUpdateListener(({ dirtyElements: b }) => {
      b.get(t) && g();
    });
  }, [d, g, t]), h.current === null || o === null || d === null ? null : m(n2e, { close: f, resolution: o, editor: d, anchorElementRef: h, options: e, menuRenderFn: a, onSelectOption: i, commandPriority: s });
}
const i2e = /((https?:\/\/(www\.)?)|(www\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/, b9 = xn();
let R_ = class extends e2e {
  constructor(t, n) {
    super(t), this.title = t, this.onSelect = n.onSelect.bind(this);
  }
};
function a2e({ embedConfigs: e, onOpenEmbedModalForConfig: t, getMenuOptions: n, menuRenderFn: r, menuCommandPriority: i = ot }) {
  const [a] = Fe(), [l, s] = Q(null), [c, d] = Q(null), o = he(() => {
    s(null), d(null);
  }, []), u = he(async (g) => {
    const b = a.getEditorState().read(function() {
      const v = Rt(g);
      if (qn(v)) return v.getURL();
    });
    if (b !== void 0) for (const v of e)
      await Promise.resolve(v.parseUrl(b)) != null && (d(v), s(g));
  }, [a, e]);
  Y(() => Pt(...[H0, Ef].map((g) => a.registerMutationListener(g, (...b) => ((v, { updateTags: U, dirtyLeaves: y }) => {
    for (const [w, x] of v) x === "created" && U.has("paste") && y.size <= 3 ? u(w) : w === l && o();
  })(...b), { skipInitialization: !0 }))), [u, a, e, l, o]), Y(() => a.registerCommand(b9, (g) => {
    const b = e.find(({ type: v }) => v === g);
    return !!b && (t(b), !0);
  }, it), [a, e, t]);
  const h = he(async function() {
    if (c != null && l != null) {
      const g = a.getEditorState().read(() => {
        const b = Rt(l);
        return qn(b) ? b : null;
      });
      if (qn(g)) {
        const b = await Promise.resolve(c.parseUrl(g.__url));
        b != null && a.update(() => {
          se() || g.selectEnd(), c.insertNode(a, b), g.isAttached() && g.remove();
        });
      }
    }
  }, [c, a, l]), f = Ke(() => c != null && l != null ? n(c, h, o) : [], [c, h, n, l, o]), p = he((g, b, v) => {
    a.update(() => {
      g.onSelect(b), v();
    });
  }, [a]);
  return l != null ? m(r2e, { nodeKey: l, onClose: o, onSelectOption: p, options: f, menuRenderFn: r, commandPriority: i }) : null;
}
const dO = xn();
function l2e() {
  const [e] = Fe();
  return Y(() => {
    if (!e.hasNodes([Cf]))
      throw new Error("FigmaPlugin: FigmaNode not registered on editor");
    return e.registerCommand(
      dO,
      (t) => {
        const n = iM(t);
        return Lo(n), !0;
      },
      it
    );
  }, [e]), null;
}
const uO = xn();
function s2e() {
  const [e] = Fe();
  return Y(() => {
    if (!e.hasNodes([Mf]))
      throw new Error("TwitterPlugin: TweetNode not registered on editor");
    return e.registerCommand(
      uO,
      (t) => {
        const n = xb(t);
        return Lo(n), !0;
      },
      it
    );
  }, [e]), null;
}
const hO = xn();
function o2e() {
  const [e] = Fe();
  return Y(() => {
    if (!e.hasNodes([Tf]))
      throw new Error("YouTubePlugin: YouTubeNode not registered on editor");
    return e.registerCommand(
      hO,
      (t) => {
        const n = Eb(t);
        return Lo(n), !0;
      },
      it
    );
  }, [e]), null;
}
const c2e = {
  contentName: "Youtube Video",
  exampleUrl: "https://www.youtube.com/watch?v=jNQXAC9IVRw",
  // Icon for display.
  icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon youtube" }),
  insertNode: (e, t) => {
    e.dispatchCommand(hO, t.id);
  },
  keywords: ["youtube", "video"],
  // Determine if a given URL is a match and return url data.
  parseUrl: async (e) => {
    const t = /^.*(youtu\.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/.exec(e), n = t && (t == null ? void 0 : t[2].length) === 11 ? t[2] : null;
    return n != null ? {
      id: n,
      url: e
    } : null;
  },
  type: "youtube-video"
}, d2e = {
  // e.g. Tweet or Google Map.
  contentName: "Tweet",
  exampleUrl: "https://twitter.com/jack/status/20",
  // Icon for display.
  icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon tweet" }),
  // Create the Lexical embed node from the url data.
  insertNode: (e, t) => {
    e.dispatchCommand(uO, t.id);
  },
  // For extra searching.
  keywords: ["tweet", "twitter"],
  // Determine if a given URL is a match and return url data.
  parseUrl: (e) => {
    const t = /^https:\/\/(twitter|x)\.com\/(#!\/)?(\w+)\/status(es)*\/(\d+)/.exec(
      e
    );
    return t != null ? {
      id: t[5],
      url: t[1]
    } : null;
  },
  type: "tweet"
}, u2e = {
  contentName: "Figma Document",
  exampleUrl: "https://www.figma.com/file/LKQ4FJ4bTnCSjedbRpk931/Sample-File",
  icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon figma" }),
  insertNode: (e, t) => {
    e.dispatchCommand(dO, t.id);
  },
  keywords: ["figma", "figma.com", "mock-up"],
  // Determine if a given URL is a match and return url data.
  parseUrl: (e) => {
    const t = /https:\/\/([\w.-]+\.)?figma.com\/(file|proto)\/([0-9a-zA-Z]{22,128})(?:\/.*)?$/.exec(
      e
    );
    return t != null ? {
      id: t[3],
      url: t[0]
    } : null;
  },
  type: "figma"
}, U9 = [
  d2e,
  c2e,
  u2e
];
function h2e({
  index: e,
  isSelected: t,
  onClick: n,
  onMouseEnter: r,
  option: i
}) {
  let a = "item";
  return t && (a += " selected"), /* @__PURE__ */ m(
    "li",
    {
      tabIndex: -1,
      className: a,
      ref: i.setRefElement,
      role: "option",
      "aria-selected": t,
      id: "typeahead-item-" + e,
      onMouseEnter: r,
      onClick: n,
      children: /* @__PURE__ */ m("span", { className: "text", children: i.title })
    },
    i.key
  );
}
function f2e({
  options: e,
  selectedItemIndex: t,
  onOptionClick: n,
  onOptionMouseEnter: r
}) {
  return /* @__PURE__ */ m("div", { className: "doc-editor-typeahead-popover", children: /* @__PURE__ */ m("ul", { children: e.map((i, a) => /* @__PURE__ */ m(
    h2e,
    {
      index: a,
      isSelected: t === a,
      onClick: () => n(i, a),
      onMouseEnter: () => r(a),
      option: i
    },
    i.key
  )) }) });
}
const p2e = (e, t) => {
  let n;
  return (r) => {
    window.clearTimeout(n), n = window.setTimeout(() => {
      e(r);
    }, t);
  };
};
function m2e({
  embedConfig: e,
  onClose: t
}) {
  const [n, r] = Q(""), [i] = Fe(), [a, l] = Q(null), s = Ke(
    () => p2e((d) => {
      const o = i2e.exec(d);
      e != null && d != null && o != null ? Promise.resolve(e.parseUrl(d)).then(
        (u) => {
          l(u);
        }
      ) : a != null && l(null);
    }, 200),
    [e, a]
  ), c = () => {
    a != null && (e.insertNode(i, a), t());
  };
  return /* @__PURE__ */ D("div", { style: { width: "600px" }, children: [
    /* @__PURE__ */ m("div", { className: "Input__wrapper", children: /* @__PURE__ */ m(
      "input",
      {
        type: "text",
        className: "Input__input",
        placeholder: e.exampleUrl,
        value: n,
        "data-test-id": `${e.type}-embed-modal-url`,
        onChange: (d) => {
          const { value: o } = d.target;
          r(o), s(o);
        }
      }
    ) }),
    /* @__PURE__ */ m(J0, { children: /* @__PURE__ */ m(
      Qi,
      {
        disabled: !a,
        onClick: c,
        "data-test-id": `${e.type}-embed-modal-submit-btn`,
        children: "Embed"
      }
    ) })
  ] });
}
function g2e() {
  const [e, t] = zg();
  return /* @__PURE__ */ D(ge, { children: [
    e,
    /* @__PURE__ */ m(
      a2e,
      {
        embedConfigs: U9,
        onOpenEmbedModalForConfig: (i) => {
          t(`Embed ${i.contentName}`, (a) => /* @__PURE__ */ m(m2e, { embedConfig: i, onClose: a }));
        },
        getMenuOptions: (i, a, l) => [
          new R_("Dismiss", {
            onSelect: l
          }),
          new R_(`Embed ${i.contentName}`, {
            onSelect: a
          })
        ],
        menuRenderFn: (i, { selectedIndex: a, options: l, selectOptionAndCleanUp: s, setHighlightedIndex: c }) => i.current ? _c.createPortal(
          /* @__PURE__ */ m(
            "div",
            {
              className: "doc-editor-typeahead-popover auto-embed-menu",
              style: {
                marginLeft: i.current.style.width,
                width: 200
              },
              children: /* @__PURE__ */ m(
                f2e,
                {
                  options: l,
                  selectedItemIndex: a,
                  onOptionClick: (d, o) => {
                    c(o), s(d);
                  },
                  onOptionMouseEnter: (d) => {
                    c(d);
                  }
                }
              )
            }
          ),
          i.current
        ) : null
      }
    )
  ] });
}
const p3 = {
  bullet: "Bulleted List",
  check: "Check List",
  code: "Code Block",
  h1: "Heading 1",
  h2: "Heading 2",
  h3: "Heading 3",
  h4: "Heading 4",
  h5: "Heading 5",
  h6: "Heading 6",
  number: "Numbered List",
  paragraph: "Normal",
  quote: "Quote"
}, P_ = [
  ['"Noto Sans JP", serif', "Noto Sans JP"],
  ["Arial", "Arial"],
  ["Courier New", "Courier New"],
  ["Georgia", "Georgia"],
  ["Times New Roman", "Times New Roman"],
  ["Trebuchet MS", "Trebuchet MS"],
  ["Verdana", "Verdana"]
], b2e = [
  ["10px", "10px"],
  ["11px", "11px"],
  ["12px", "12px"],
  ["13px", "13px"],
  ["14px", "14px"],
  ["15px", "15px"],
  ["16px", "16px"],
  ["17px", "17px"],
  ["18px", "18px"],
  ["19px", "19px"],
  ["20px", "20px"]
], Du = {
  center: {
    icon: "center-align",
    iconRTL: "center-align",
    name: "Center Align"
  },
  end: {
    icon: "right-align",
    iconRTL: "left-align",
    name: "End Align"
  },
  justify: {
    icon: "justify-align",
    iconRTL: "justify-align",
    name: "Justify Align"
  },
  left: {
    icon: "left-align",
    iconRTL: "left-align",
    name: "Left Align"
  },
  right: {
    icon: "right-align",
    iconRTL: "right-align",
    name: "Right Align"
  },
  start: {
    icon: "left-align",
    iconRTL: "right-align",
    name: "Start Align"
  }
};
function Fi(e) {
  return e ? "active dropdown-item-active" : "";
}
function U2e({
  editor: e,
  blockType: t,
  disabled: n = !1
}) {
  const r = () => {
    e.update(() => {
      const d = se();
      oc(d, () => He());
    });
  }, i = (d) => {
    t !== d && e.update(() => {
      const o = se();
      oc(o, () => cc(d));
    });
  }, a = () => {
    t !== "bullet" ? e.dispatchCommand(nb, void 0) : r();
  }, l = () => {
    t !== "check" ? e.dispatchCommand(ib, void 0) : r();
  }, s = () => {
    t !== "number" ? e.dispatchCommand(rb, void 0) : r();
  }, c = () => {
    t !== "quote" && e.update(() => {
      const d = se();
      oc(d, () => Mg());
    });
  };
  return /* @__PURE__ */ D(
    $c,
    {
      disabled: n,
      buttonClassName: "toolbar-item block-controls",
      buttonIconClassName: "doc-editor-icon block-type " + t,
      buttonLabel: p3[t],
      buttonAriaLabel: "Formatting options for text style",
      children: [
        /* @__PURE__ */ D(
          St,
          {
            className: "item " + Fi(t === "paragraph"),
            onClick: r,
            children: [
              /* @__PURE__ */ m("i", { className: "doc-editor-icon paragraph" }),
              /* @__PURE__ */ m("span", { className: "text", children: "Normal" })
            ]
          }
        ),
        /* @__PURE__ */ D(
          St,
          {
            className: "item " + Fi(t === "h1"),
            onClick: () => i("h1"),
            children: [
              /* @__PURE__ */ m("i", { className: "doc-editor-icon h1" }),
              /* @__PURE__ */ m("span", { className: "text", children: "Heading 1" })
            ]
          }
        ),
        /* @__PURE__ */ D(
          St,
          {
            className: "item " + Fi(t === "h2"),
            onClick: () => i("h2"),
            children: [
              /* @__PURE__ */ m("i", { className: "doc-editor-icon h2" }),
              /* @__PURE__ */ m("span", { className: "text", children: "Heading 2" })
            ]
          }
        ),
        /* @__PURE__ */ D(
          St,
          {
            className: "item " + Fi(t === "h3"),
            onClick: () => i("h3"),
            children: [
              /* @__PURE__ */ m("i", { className: "doc-editor-icon h3" }),
              /* @__PURE__ */ m("span", { className: "text", children: "Heading 3" })
            ]
          }
        ),
        /* @__PURE__ */ D(
          St,
          {
            className: "item " + Fi(t === "bullet"),
            onClick: a,
            children: [
              /* @__PURE__ */ m("i", { className: "doc-editor-icon bullet-list" }),
              /* @__PURE__ */ m("span", { className: "text", children: "Bullet List" })
            ]
          }
        ),
        /* @__PURE__ */ D(
          St,
          {
            className: "item " + Fi(t === "number"),
            onClick: s,
            children: [
              /* @__PURE__ */ m("i", { className: "doc-editor-icon numbered-list" }),
              /* @__PURE__ */ m("span", { className: "text", children: "Numbered List" })
            ]
          }
        ),
        /* @__PURE__ */ D(
          St,
          {
            className: "item " + Fi(t === "check"),
            onClick: l,
            children: [
              /* @__PURE__ */ m("i", { className: "doc-editor-icon check-list" }),
              /* @__PURE__ */ m("span", { className: "text", children: "Check List" })
            ]
          }
        ),
        /* @__PURE__ */ D(
          St,
          {
            className: "item " + Fi(t === "quote"),
            onClick: c,
            children: [
              /* @__PURE__ */ m("i", { className: "doc-editor-icon quote" }),
              /* @__PURE__ */ m("span", { className: "text", children: "Quote" })
            ]
          }
        )
      ]
    }
  );
}
function v2e({
  editor: e,
  value: t,
  style: n,
  disabled: r = !1
}) {
  var l;
  const i = he(
    (s) => {
      e.update(() => {
        const c = se();
        c !== null && (ch(c) ? c.getNodes()[0].patchStyle({ [n]: s }) : Z3(c, {
          [n]: s
        }));
      });
    },
    [e, n]
  ), a = n === "font-family" ? "Formatting options for font family" : "Formatting options for font size";
  return /* @__PURE__ */ m(
    $c,
    {
      disabled: r,
      buttonClassName: "toolbar-item " + n,
      buttonLabel: ((l = P_.find(([s]) => s === t)) == null ? void 0 : l[1]) || t,
      buttonIconClassName: n === "font-family" ? "doc-editor-icon block-type font-family" : "",
      buttonAriaLabel: a,
      children: (n === "font-family" ? P_ : b2e).map(
        ([s, c]) => /* @__PURE__ */ m(
          St,
          {
            className: `item ${Fi(t === s)} ${n === "font-size" ? "fontsize-item" : ""}`,
            onClick: () => i(s),
            children: /* @__PURE__ */ m("span", { className: "text", children: c })
          },
          s
        )
      )
    }
  );
}
function nc() {
  return /* @__PURE__ */ m("div", { className: "divider" });
}
function y2e({
  editor: e,
  value: t,
  isRTL: n,
  disabled: r = !1
}) {
  const i = Du[t || "left"];
  return /* @__PURE__ */ D(
    $c,
    {
      disabled: r,
      buttonLabel: i.name,
      buttonIconClassName: `doc-editor-icon ${n ? i.iconRTL : i.icon}`,
      buttonClassName: "toolbar-item spaced alignment",
      buttonAriaLabel: "Formatting options for text alignment",
      children: [
        /* @__PURE__ */ D(
          St,
          {
            onClick: () => {
              e.dispatchCommand(il, "left");
            },
            className: "item",
            children: [
              /* @__PURE__ */ m("i", { className: "doc-editor-icon left-align" }),
              /* @__PURE__ */ m("span", { className: "text", children: "Left Align" })
            ]
          }
        ),
        /* @__PURE__ */ D(
          St,
          {
            onClick: () => {
              e.dispatchCommand(il, "center");
            },
            className: "item",
            children: [
              /* @__PURE__ */ m("i", { className: "doc-editor-icon center-align" }),
              /* @__PURE__ */ m("span", { className: "text", children: "Center Align" })
            ]
          }
        ),
        /* @__PURE__ */ D(
          St,
          {
            onClick: () => {
              e.dispatchCommand(il, "right");
            },
            className: "item",
            children: [
              /* @__PURE__ */ m("i", { className: "doc-editor-icon right-align" }),
              /* @__PURE__ */ m("span", { className: "text", children: "Right Align" })
            ]
          }
        ),
        /* @__PURE__ */ D(
          St,
          {
            onClick: () => {
              e.dispatchCommand(il, "justify");
            },
            className: "item",
            children: [
              /* @__PURE__ */ m("i", { className: "doc-editor-icon justify-align" }),
              /* @__PURE__ */ m("span", { className: "text", children: "Justify Align" })
            ]
          }
        ),
        /* @__PURE__ */ D(
          St,
          {
            onClick: () => {
              e.dispatchCommand(il, "start");
            },
            className: "item",
            children: [
              /* @__PURE__ */ m(
                "i",
                {
                  className: `doc-editor-icon ${n ? Du.start.iconRTL : Du.start.icon}`
                }
              ),
              /* @__PURE__ */ m("span", { className: "text", children: "Start Align" })
            ]
          }
        ),
        /* @__PURE__ */ D(
          St,
          {
            onClick: () => {
              e.dispatchCommand(il, "end");
            },
            className: "item",
            children: [
              /* @__PURE__ */ m(
                "i",
                {
                  className: `doc-editor-icon ${n ? Du.end.iconRTL : Du.end.icon}`
                }
              ),
              /* @__PURE__ */ m("span", { className: "text", children: "End Align" })
            ]
          }
        ),
        /* @__PURE__ */ m(nc, {}),
        /* @__PURE__ */ D(
          St,
          {
            onClick: () => {
              e.dispatchCommand(Pp, void 0);
            },
            className: "item",
            children: [
              /* @__PURE__ */ m("i", { className: "doc-editor-icon " + (n ? "indent" : "outdent") }),
              /* @__PURE__ */ m("span", { className: "text", children: "Outdent" })
            ]
          }
        ),
        /* @__PURE__ */ D(
          St,
          {
            onClick: () => {
              e.dispatchCommand(dg, void 0);
            },
            className: "item",
            children: [
              /* @__PURE__ */ m("i", { className: "doc-editor-icon " + (n ? "outdent" : "indent") }),
              /* @__PURE__ */ m("span", { className: "text", children: "Indent" })
            ]
          }
        )
      ]
    }
  );
}
function w2e({ setIsLinkEditMode: e, imageUploadCallback: t }) {
  const [n] = Fe(), [r, i] = Q("paragraph"), [a, l] = Q(n), [s, c] = Q("15px"), [d, o] = Q("#000"), [u, h] = Q("#fff"), [f, p] = Q('"Noto Sans JP", serif'), [g, b] = Q("left"), [v, U] = Q(!1), [y, w] = Q(!1), [x, E] = Q(!1), [S, _] = Q(!1), [k, M] = Q(!1), [A, L] = Q(!1), [R, z] = Q(!1), [F, W] = Q(!1), [B, j] = Q(!1), [V, q] = Q(!1), [oe, Ue] = Q(!1), [fe, Pe] = Q(() => n.isEditable()), [ze, Oe] = zg(), Be = he(() => {
    const _e = se();
    if (_e && ch(_e)) {
      const rt = _e.getNodes()[0];
      w(rt.hasFormat("bold")), E(rt.hasFormat("italic")), _(rt.hasFormat("underline")), M(rt.hasFormat("strikethrough")), L(rt.hasFormat("subscript")), z(rt.hasFormat("superscript")), W(rt.hasFormat("code")), c(rt.getStyleValue("font-size", "15px")), o(rt.getStyleValue("color", "#000")), h(rt.getStyleValue("background-color", "#fff")), p(rt.getStyleValue("font-family", '"Noto Sans JP", serif'));
    } else if (ie(_e)) {
      const rt = _e.anchor.getNode();
      let Xt = rt.getKey() === "root" ? rt : Xe(rt, (Xa) => {
        const n1 = Xa.getParent();
        return n1 !== null && er(n1);
      });
      Xt === null && (Xt = rt.getTopLevelElementOrThrow());
      const fr = Xt.getKey(), Qt = a.getElementByKey(fr);
      w(_e.hasFormat("bold")), E(_e.hasFormat("italic")), _(_e.hasFormat("underline")), M(_e.hasFormat("strikethrough")), L(_e.hasFormat("subscript")), z(_e.hasFormat("superscript")), W(_e.hasFormat("code")), j(mC(_e));
      const rr = h0(_e), Kt = rr.getParent();
      if (qn(Kt) || qn(rr) ? U(!0) : U(!1), Qt !== null)
        if (vt(Xt)) {
          const Xa = UC(
            rt,
            _f
          ), n1 = Xa ? Xa.getListType() : Xt.getListType();
          i(n1);
        } else {
          const Xa = Kd(Xt) ? Xt.getTag() : Xt.getType();
          Xa in p3 && i(Xa);
        }
      c(
        l1(_e, "font-size", "15px")
      ), o(
        l1(_e, "color", "#000")
      ), h(
        l1(
          _e,
          "background-color",
          "#fff"
        )
      ), p(
        l1(_e, "font-family", '"Noto Sans JP", serif')
      );
      let F2;
      qn(Kt) && (F2 = Xe(
        rr,
        (Xa) => re(Xa) && !Xa.isInline()
      )), b(
        re(F2) ? F2.getFormatType() : re(rr) ? rr.getFormatType() : (Kt == null ? void 0 : Kt.getFormatType()) || "left"
      );
    }
  }, [a]);
  Y(() => n.registerCommand(
    Ei,
    (_e, rt) => (Be(), l(rt), Pe(rt.isEditable()), !1),
    mr
  ), [n, Be]), Y(() => Pt(
    n.registerEditableListener((_e) => {
      Pe(_e);
    }),
    a.registerUpdateListener(({ editorState: _e }) => {
      _e.read(() => {
        Be();
      });
    }),
    a.registerCommand(
      Pu,
      (_e) => (q(_e), !1),
      mr
    ),
    a.registerCommand(
      Ru,
      (_e) => (Ue(_e), !1),
      mr
    )
  ), [Be, a, n]), Y(() => a.registerCommand(
    uk,
    (_e) => {
      const rt = _e, { code: Xt, ctrlKey: fr, metaKey: Qt } = rt;
      if (Xt === "KeyK" && (fr || Qt)) {
        rt.preventDefault();
        let rr;
        return v ? (e(!1), rr = null) : (e(!0), rr = lm("https://")), a.dispatchCommand(Ul, rr);
      }
      return !1;
    },
    H$
  ), [a, v, e]);
  const qe = he(
    (_e, rt) => {
      a.update(
        () => {
          const Xt = se();
          Xt !== null && (ch(Xt) ? Xt.getNodes()[0].patchStyle(_e) : Z3(Xt, _e));
        },
        rt ? { tag: "historic" } : {}
      );
    },
    [a]
  ), At = he(() => {
    a.update(() => {
      const _e = se();
      if (_e && ch(_e))
        _e.getNodes()[0].clearAllFormats();
      else if (ie(_e)) {
        const rt = _e.anchor, Xt = _e.focus, fr = _e.getNodes();
        if (rt.key === Xt.key && rt.offset === Xt.offset)
          return;
        fr.forEach((Qt, rr) => {
          if (ce(Qt)) {
            let Kt = Qt;
            rr === 0 && rt.offset !== 0 && (Kt = Kt.splitText(rt.offset)[1] || Kt), rr === fr.length - 1 && (Kt = Kt.splitText(Xt.offset)[0] || Kt), Kt.__style !== "" && Kt.setStyle(""), Kt.__format !== 0 && (Kt.setFormat(0), Cg(Kt).setFormat("")), Qt = Kt;
          } else Kd(Qt) || KF(Qt) ? Qt.replace(He(), !0) : _4(Qt) && Qt.setFormat("");
        });
      }
    });
  }, [a]), Je = he(
    (_e, rt) => {
      qe({ color: _e }, rt);
    },
    [qe]
  ), mt = he(
    (_e, rt) => {
      qe({ "background-color": _e }, rt);
    },
    [qe]
  ), jt = he(() => {
    v ? (e(!1), n.dispatchCommand(Ul, null)) : (e(!0), n.dispatchCommand(Ul, lm("https://")));
  }, [n, v, e]);
  return /* @__PURE__ */ D("div", { className: "toolbar", children: [
    /* @__PURE__ */ m(
      "button",
      {
        disabled: !V || !fe,
        onClick: () => {
          a.dispatchCommand(og, void 0);
        },
        title: $s ? "Undo (⌘Z)" : "Undo (Ctrl+Z)",
        type: "button",
        className: "toolbar-item spaced",
        "aria-label": "Undo",
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon format undo" })
      }
    ),
    /* @__PURE__ */ m(
      "button",
      {
        disabled: !oe || !fe,
        onClick: () => {
          a.dispatchCommand(cg, void 0);
        },
        title: $s ? "Redo (⌘Y)" : "Redo (Ctrl+Y)",
        type: "button",
        className: "toolbar-item spaced",
        "aria-label": "Redo",
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon format redo" })
      }
    ),
    /* @__PURE__ */ m(nc, {}),
    r in p3 && /* @__PURE__ */ D(ge, { children: [
      /* @__PURE__ */ m(
        U2e,
        {
          disabled: !fe,
          blockType: r,
          editor: a
        }
      ),
      /* @__PURE__ */ m(nc, {})
    ] }),
    /* @__PURE__ */ m(
      v2e,
      {
        disabled: !fe,
        editor: a,
        value: f,
        style: "font-family"
      }
    ),
    /* @__PURE__ */ m(nc, {}),
    /* @__PURE__ */ m(vW, { selectionFontSize: s.slice(0, -2), editor: a, disabled: !fe }),
    /* @__PURE__ */ m(nc, {}),
    /* @__PURE__ */ m(
      "button",
      {
        disabled: !fe,
        onClick: () => {
          a.dispatchCommand(Mn, "bold");
        },
        className: "toolbar-item spaced " + (y ? "active" : ""),
        title: $s ? "Bold (⌘B)" : "Bold (Ctrl+B)",
        type: "button",
        "aria-label": `Format text as bold. Shortcut: ${$s ? "⌘B" : "Ctrl+B"}`,
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon format bold" })
      }
    ),
    /* @__PURE__ */ m(
      "button",
      {
        disabled: !fe,
        onClick: () => {
          a.dispatchCommand(Mn, "italic");
        },
        className: "toolbar-item spaced " + (x ? "active" : ""),
        title: $s ? "Italic (⌘I)" : "Italic (Ctrl+I)",
        type: "button",
        "aria-label": `Format text as italics. Shortcut: ${$s ? "⌘I" : "Ctrl+I"}`,
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon format italic" })
      }
    ),
    /* @__PURE__ */ m(
      "button",
      {
        disabled: !fe,
        onClick: () => {
          a.dispatchCommand(Mn, "underline");
        },
        className: "toolbar-item spaced " + (S ? "active" : ""),
        title: $s ? "Underline (⌘U)" : "Underline (Ctrl+U)",
        type: "button",
        "aria-label": `Format text to underlined. Shortcut: ${$s ? "⌘U" : "Ctrl+U"}`,
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon format underline" })
      }
    ),
    /* @__PURE__ */ m(
      "button",
      {
        disabled: !fe,
        onClick: () => {
          a.dispatchCommand(Mn, "code");
        },
        className: "toolbar-item spaced " + (F ? "active" : ""),
        title: "Insert code block",
        type: "button",
        "aria-label": "Insert code block",
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon format code" })
      }
    ),
    /* @__PURE__ */ m(
      "button",
      {
        disabled: !fe,
        onClick: jt,
        className: "toolbar-item spaced " + (v ? "active" : ""),
        "aria-label": "Insert link",
        title: "Insert link",
        type: "button",
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon format link" })
      }
    ),
    /* @__PURE__ */ m(
      Oy,
      {
        disabled: !fe,
        buttonClassName: "toolbar-item color-picker",
        buttonAriaLabel: "Formatting text color",
        buttonIconClassName: "doc-editor-icon font-color",
        color: d,
        onChange: Je,
        title: "text color"
      }
    ),
    /* @__PURE__ */ m(
      Oy,
      {
        disabled: !fe,
        buttonClassName: "toolbar-item color-picker",
        buttonAriaLabel: "Formatting background color",
        buttonIconClassName: "doc-editor-icon bg-color",
        color: u,
        onChange: mt,
        title: "bg color"
      }
    ),
    /* @__PURE__ */ D(
      $c,
      {
        disabled: !fe,
        buttonClassName: "toolbar-item spaced",
        buttonLabel: "",
        buttonAriaLabel: "Formatting options for additional text styles",
        buttonIconClassName: "doc-editor-icon dropdown-more",
        children: [
          /* @__PURE__ */ D(
            St,
            {
              onClick: () => {
                a.dispatchCommand(
                  Mn,
                  "strikethrough"
                );
              },
              className: "item " + Fi(k),
              title: "Strikethrough",
              "aria-label": "Format text with a strikethrough",
              children: [
                /* @__PURE__ */ m("i", { className: "doc-editor-icon strikethrough" }),
                /* @__PURE__ */ m("span", { className: "text", children: "Strikethrough" })
              ]
            }
          ),
          /* @__PURE__ */ D(
            St,
            {
              onClick: () => {
                a.dispatchCommand(Mn, "subscript");
              },
              className: "item " + Fi(A),
              title: "Subscript",
              "aria-label": "Format text with a subscript",
              children: [
                /* @__PURE__ */ m("i", { className: "doc-editor-icon subscript" }),
                /* @__PURE__ */ m("span", { className: "text", children: "Subscript" })
              ]
            }
          ),
          /* @__PURE__ */ D(
            St,
            {
              onClick: () => {
                a.dispatchCommand(
                  Mn,
                  "superscript"
                );
              },
              className: "item " + Fi(R),
              title: "Superscript",
              "aria-label": "Format text with a superscript",
              children: [
                /* @__PURE__ */ m("i", { className: "doc-editor-icon superscript" }),
                /* @__PURE__ */ m("span", { className: "text", children: "Superscript" })
              ]
            }
          ),
          /* @__PURE__ */ D(
            St,
            {
              onClick: At,
              className: "item",
              title: "Clear text formatting",
              "aria-label": "Clear all text formatting",
              children: [
                /* @__PURE__ */ m("i", { className: "doc-editor-icon clear" }),
                /* @__PURE__ */ m("span", { className: "text", children: "Clear Formatting" })
              ]
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ m(nc, {}),
    /* @__PURE__ */ D(
      $c,
      {
        disabled: !fe,
        buttonClassName: "toolbar-item spaced",
        buttonLabel: "Insert",
        buttonAriaLabel: "Insert specialized editor node",
        buttonIconClassName: "doc-editor-icon plus",
        children: [
          /* @__PURE__ */ D(
            St,
            {
              onClick: () => {
                a.dispatchCommand(
                  ob,
                  void 0
                );
              },
              className: "item",
              children: [
                /* @__PURE__ */ m("i", { className: "doc-editor-icon horizontal-rule" }),
                /* @__PURE__ */ m("span", { className: "text", children: "Horizontal Rule" })
              ]
            }
          ),
          /* @__PURE__ */ D(
            St,
            {
              onClick: () => {
                a.dispatchCommand(Jb, void 0);
              },
              className: "item",
              children: [
                /* @__PURE__ */ m("i", { className: "doc-editor-icon page-break" }),
                /* @__PURE__ */ m("span", { className: "text", children: "Page Break" })
              ]
            }
          ),
          /* @__PURE__ */ D(
            St,
            {
              onClick: () => {
                Oe("Insert Image", (_e) => /* @__PURE__ */ m(
                  gT,
                  {
                    activeEditor: a,
                    onClose: _e,
                    imageUploadCallback: t
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ m("i", { className: "doc-editor-icon image" }),
                /* @__PURE__ */ m("span", { className: "text", children: "Image" })
              ]
            }
          ),
          /* @__PURE__ */ D(
            St,
            {
              onClick: () => {
                Oe("Insert Inline Image", (_e) => /* @__PURE__ */ m(
                  BW,
                  {
                    activeEditor: a,
                    onClose: _e,
                    imageUploadCallback: t
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ m("i", { className: "doc-editor-icon image" }),
                /* @__PURE__ */ m("span", { className: "text", children: "Inline Image" })
              ]
            }
          ),
          /* @__PURE__ */ D(
            St,
            {
              onClick: () => {
                a.dispatchCommand(
                  m9,
                  void 0
                );
              },
              className: "item",
              children: [
                /* @__PURE__ */ m("i", { className: "doc-editor-icon diagram-2" }),
                /* @__PURE__ */ m("span", { className: "text", children: "Excalidraw" })
              ]
            }
          ),
          /* @__PURE__ */ D(
            St,
            {
              onClick: () => {
                Oe("Insert Table", (_e) => /* @__PURE__ */ m(
                  rO,
                  {
                    activeEditor: a,
                    onClose: _e
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ m("i", { className: "doc-editor-icon table" }),
                /* @__PURE__ */ m("span", { className: "text", children: "Table" })
              ]
            }
          ),
          /* @__PURE__ */ D(
            St,
            {
              onClick: () => {
                Oe("Insert Poll", (_e) => /* @__PURE__ */ m(
                  aO,
                  {
                    activeEditor: a,
                    onClose: _e
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ m("i", { className: "doc-editor-icon poll" }),
                /* @__PURE__ */ m("span", { className: "text", children: "Poll" })
              ]
            }
          ),
          /* @__PURE__ */ D(
            St,
            {
              onClick: () => {
                Oe("Insert Columns Layout", (_e) => /* @__PURE__ */ m(
                  sO,
                  {
                    activeEditor: a,
                    onClose: _e
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ m("i", { className: "doc-editor-icon columns" }),
                /* @__PURE__ */ m("span", { className: "text", children: "Columns Layout" })
              ]
            }
          ),
          /* @__PURE__ */ D(
            St,
            {
              onClick: () => {
                Oe("Insert Equation", (_e) => /* @__PURE__ */ m(
                  cO,
                  {
                    activeEditor: a,
                    onClose: _e
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ m("i", { className: "doc-editor-icon equation" }),
                /* @__PURE__ */ m("span", { className: "text", children: "Equation" })
              ]
            }
          ),
          /* @__PURE__ */ D(
            St,
            {
              onClick: () => {
                n.update(() => {
                  const _e = Bt(), rt = TH(0, 0);
                  _e.append(rt);
                });
              },
              className: "item",
              children: [
                /* @__PURE__ */ m("i", { className: "doc-editor-icon sticky" }),
                /* @__PURE__ */ m("span", { className: "text", children: "Sticky Note" })
              ]
            }
          ),
          /* @__PURE__ */ D(
            St,
            {
              onClick: () => {
                n.dispatchCommand(g9, void 0);
              },
              className: "item",
              children: [
                /* @__PURE__ */ m("i", { className: "doc-editor-icon caret-right" }),
                /* @__PURE__ */ m("span", { className: "text", children: "Collapsible container" })
              ]
            }
          ),
          U9.map((_e) => /* @__PURE__ */ D(
            St,
            {
              onClick: () => {
                a.dispatchCommand(
                  b9,
                  _e.type
                );
              },
              className: "item",
              children: [
                _e.icon,
                /* @__PURE__ */ m("span", { className: "text", children: _e.contentName })
              ]
            },
            _e.type
          ))
        ]
      }
    ),
    /* @__PURE__ */ m(nc, {}),
    /* @__PURE__ */ m(
      y2e,
      {
        disabled: !fe,
        value: g,
        editor: n,
        isRTL: B
      }
    ),
    ze
  ] });
}
function x2e() {
  const [e] = Fe();
  return Y(() => {
    if (!e.hasNodes([_f, Sf])) throw new Error("ListPlugin: ListNode and/or ListItemNode not registered on editor");
  }, [e]), function(t) {
    Y(() => SF(t), [t]);
  }(e), null;
}
function E2e() {
  const [e] = Fe();
  return Y(() => Pt(e.registerCommand(ib, () => (U4(e, "check"), !0), ot), e.registerCommand(Ao, (t) => F_(t, e, !1), ot), e.registerCommand(Io, (t) => F_(t, e, !0), ot), e.registerCommand(rd, (t) => {
    if (m3() != null) {
      const n = e.getRootElement();
      return n != null && n.focus(), !0;
    }
    return !1;
  }, ot), e.registerCommand(ck, (t) => {
    const n = m3();
    return !(n == null || !e.isEditable()) && (e.update(() => {
      const r = on(n);
      Gt(r) && (t.preventDefault(), r.toggleChecked());
    }), !0);
  }, ot), e.registerCommand(R0, (t) => e.getEditorState().read(() => {
    const n = se();
    if (ie(n) && n.isCollapsed()) {
      const { anchor: r } = n, i = r.type === "element";
      if (i || r.offset === 0) {
        const a = r.getNode(), l = Xe(a, (s) => re(s) && !s.isInline());
        if (Gt(l)) {
          const s = l.getParent();
          if (vt(s) && s.getListType() === "check" && (i || l.getFirstDescendant() === a)) {
            const c = e.getElementByKey(l.__key);
            if (c != null && document.activeElement !== c) return c.focus(), t.preventDefault(), !0;
          }
        }
      }
    }
    return !1;
  }), ot), e.registerRootListener((t, n) => {
    t !== null && (t.addEventListener("click", O_), t.addEventListener("pointerdown", $_)), n !== null && (n.removeEventListener("click", O_), n.removeEventListener("pointerdown", $_));
  }))), null;
}
function fO(e, t) {
  const n = e.target;
  if (n === null || !Ti(n)) return;
  const r = n.firstChild;
  if (r != null && Ti(r) && (r.tagName === "UL" || r.tagName === "OL")) return;
  const i = n.parentNode;
  if (!i || i.__lexicalListType !== "check") return;
  const a = n.getBoundingClientRect(), l = e.pageX / p4(n);
  (n.dir === "rtl" ? l < a.right && l > a.right - 20 : l > a.left && l < a.left + 20) && t();
}
function O_(e) {
  fO(e, () => {
    if (e.target instanceof HTMLElement) {
      const t = e.target, n = L3(t);
      n != null && n.isEditable() && n.update(() => {
        const r = on(t);
        Gt(r) && (t.focus(), r.toggleChecked());
      });
    }
  });
}
function $_(e) {
  fO(e, () => {
    e.preventDefault();
  });
}
function m3() {
  const e = document.activeElement;
  return e != null && e.tagName === "LI" && e.parentNode != null && e.parentNode.__lexicalListType === "check" ? e : null;
}
function F_(e, t, n) {
  const r = m3();
  return r != null && t.update(() => {
    const i = on(r);
    if (!Gt(i)) return;
    const a = function(l, s) {
      let c = s ? l.getPreviousSibling() : l.getNextSibling(), d = l;
      for (; c == null && Gt(d); ) d = d.getParentOrThrow().getParent(), d != null && (c = s ? d.getPreviousSibling() : d.getNextSibling());
      for (; Gt(c); ) {
        const o = s ? c.getLastChild() : c.getFirstChild();
        if (!vt(o)) return c;
        c = s ? o.getLastChild() : o.getFirstChild();
      }
      return null;
    }(i, n);
    if (a != null) {
      a.selectStart();
      const l = t.getElementByKey(a.__key);
      l != null && (e.preventDefault(), setTimeout(() => {
        l.focus();
      }, 0));
    }
  }), !1;
}
function S2e(e) {
  const t = e.getNodes();
  return t.length === 0 ? /* @__PURE__ */ new Set([
    e.anchor.getNode().getParentOrThrow(),
    e.focus.getNode().getParentOrThrow()
  ]) : new Set(
    t.map((n) => re(n) ? n : n.getParentOrThrow())
  );
}
function _2e(e) {
  const t = se();
  if (!ie(t))
    return !1;
  const n = S2e(t);
  let r = 0;
  for (const i of n)
    if (vt(i))
      r = Math.max(g4(i) + 1, r);
    else if (Gt(i)) {
      const a = i.getParent();
      if (!vt(a))
        throw new Error(
          "ListMaxIndentLevelPlugin: A ListItemNode must have a ListNode for a parent."
        );
      r = Math.max(g4(a) + 1, r);
    }
  return r <= e;
}
function k2e({ maxDepth: e }) {
  const [t] = Fe();
  return Y(() => t.registerCommand(
    dg,
    () => !_2e(e ?? 7),
    mr
  ), [t, e]), null;
}
const C2e = 1, M2e = 100;
let pO = 0, z_ = !1;
function T2e() {
  window.addEventListener(
    "keydown",
    (e) => {
      e.key === "Tab" && (pO = e.timeStamp);
    },
    !0
  );
}
function I2e() {
  const [e] = Fe();
  return Y(() => (z_ || (T2e(), z_ = !0), e.registerCommand(
    x3,
    (t) => {
      const n = se();
      return ie(n) && pO + M2e > t.timeStamp && pn(n.clone()), !1;
    },
    C2e
  )), [e]), null;
}
const A2e = 10, N2e = 5;
function B_(e, t, n, r = A2e, i = N2e) {
  const a = n.parentElement;
  if (e === null || !a) {
    t.style.opacity = "0", t.style.transform = "translate(-10000px, -10000px)";
    return;
  }
  const l = t.getBoundingClientRect(), s = n.getBoundingClientRect(), c = a.getBoundingClientRect();
  let d = e.top - r, o = e.left - i;
  d < c.top && (d += l.height + e.height + r * 2), o + l.width > c.right && (o = c.right - l.width - i), d -= s.top, o -= s.left, t.style.opacity = "1", t.style.transform = `translate(${o}px, ${d}px)`;
}
function D2e({
  editor: e,
  isLink: t,
  setIsLink: n,
  anchorElem: r,
  isLinkEditMode: i,
  setIsLinkEditMode: a
}) {
  const l = de(null), s = de(null), [c, d] = Q(""), [o, u] = Q("https://"), [h, f] = Q(
    null
  ), p = he(() => {
    var E, S;
    const v = se();
    if (ie(v)) {
      const _ = h0(v), k = Xe(_, qn);
      k ? d(k.getURL()) : qn(_) ? d(_.getURL()) : d(""), i && u(c);
    }
    const U = l.current, y = window.getSelection(), w = document.activeElement;
    if (U === null)
      return;
    const x = e.getRootElement();
    if (v !== null && y !== null && x !== null && x.contains(y.anchorNode) && e.isEditable()) {
      const _ = (S = (E = y.focusNode) == null ? void 0 : E.parentElement) == null ? void 0 : S.getBoundingClientRect();
      _ && (_.y += 40, B_(_, U, r)), f(v);
    } else (!w || w.className !== "link-input") && (x !== null && B_(null, U, r), f(null), a(!1), d(""));
    return !0;
  }, [r, e, a, i, c]);
  Y(() => {
    const v = r.parentElement, U = () => {
      e.getEditorState().read(() => {
        p();
      });
    };
    return window.addEventListener("resize", U), v && v.addEventListener("scroll", U), () => {
      window.removeEventListener("resize", U), v && v.removeEventListener("scroll", U);
    };
  }, [r.parentElement, e, p]), Y(() => Pt(
    e.registerUpdateListener(({ editorState: v }) => {
      v.read(() => {
        p();
      });
    }),
    e.registerCommand(
      Ei,
      () => (p(), !0),
      ot
    ),
    e.registerCommand(
      rd,
      () => t ? (n(!1), !0) : !1,
      vi
    )
  ), [e, p, n, t]), Y(() => {
    e.getEditorState().read(() => {
      p();
    });
  }, [e, p]), Y(() => {
    i && s.current && s.current.focus();
  }, [i, t]);
  const g = (v) => {
    v.key === "Enter" ? (v.preventDefault(), b()) : v.key === "Escape" && (v.preventDefault(), a(!1));
  }, b = () => {
    h !== null && (c !== "" && (e.dispatchCommand(Ul, lm(o)), e.update(() => {
      const v = se();
      if (ie(v)) {
        const U = h0(v).getParent();
        if (Ql(U)) {
          const y = Ah(U.getURL(), {
            rel: U.__rel,
            target: U.__target,
            title: U.__title
          });
          U.replace(y, !0);
        }
      }
    })), u("https://"), a(!1));
  };
  return /* @__PURE__ */ m("div", { ref: l, className: "link-editor", children: t ? i ? /* @__PURE__ */ D(ge, { children: [
    /* @__PURE__ */ m(
      "input",
      {
        ref: s,
        className: "link-input",
        value: o,
        onChange: (v) => {
          u(v.target.value);
        },
        onKeyDown: (v) => {
          g(v);
        }
      }
    ),
    /* @__PURE__ */ D("div", { children: [
      /* @__PURE__ */ m(
        "div",
        {
          className: "link-cancel",
          role: "button",
          tabIndex: 0,
          onMouseDown: (v) => v.preventDefault(),
          onClick: () => {
            a(!1);
          }
        }
      ),
      /* @__PURE__ */ m(
        "div",
        {
          className: "link-confirm",
          role: "button",
          tabIndex: 0,
          onMouseDown: (v) => v.preventDefault(),
          onClick: b
        }
      )
    ] })
  ] }) : /* @__PURE__ */ D("div", { className: "link-view", children: [
    /* @__PURE__ */ m(
      "a",
      {
        href: lm(c),
        target: "_blank",
        rel: "noopener noreferrer",
        children: c
      }
    ),
    /* @__PURE__ */ m(
      "div",
      {
        className: "link-edit",
        role: "button",
        tabIndex: 0,
        onMouseDown: (v) => v.preventDefault(),
        onClick: () => {
          u(c), a(!0);
        }
      }
    ),
    /* @__PURE__ */ m(
      "div",
      {
        className: "link-trash",
        role: "button",
        tabIndex: 0,
        onMouseDown: (v) => v.preventDefault(),
        onClick: () => {
          e.dispatchCommand(Ul, null);
        }
      }
    )
  ] }) : null });
}
function L2e(e, t, n, r) {
  const [i, a] = Q(e), [l, s] = Q(!1);
  return Y(() => {
    function c() {
      const d = se();
      if (ie(d)) {
        const o = h0(d), u = Xe(o, qn), h = Xe(
          o,
          Ql
        );
        if (!(u || h)) {
          s(!1);
          return;
        }
        const f = d.getNodes().find((p) => {
          const g = Xe(p, qn), b = Xe(p, Ql);
          if (!(g != null && g.is(u)) && !(b != null && b.is(h)) && !g && !b && !Ca(p))
            return p;
        });
        s(!f);
      }
    }
    return Pt(
      e.registerUpdateListener(({ editorState: d }) => {
        d.read(() => {
          c();
        });
      }),
      e.registerCommand(
        Ei,
        (d, o) => (c(), a(o), !1),
        mr
      ),
      e.registerCommand(
        L0,
        (d) => {
          const o = se();
          if (ie(o)) {
            const u = h0(o), h = Xe(u, qn);
            if (qn(h) && (d.metaKey || d.ctrlKey))
              return window.open(h.getURL(), "_blank"), !0;
          }
          return !1;
        },
        ot
      )
    );
  }, [e]), fi(
    /* @__PURE__ */ m(
      D2e,
      {
        editor: i,
        isLink: l,
        anchorElem: t,
        setIsLink: s,
        isLinkEditMode: n,
        setIsLinkEditMode: r
      }
    ),
    t
  );
}
function R2e({
  anchorElem: e = document.body,
  isLinkEditMode: t,
  setIsLinkEditMode: n
}) {
  const [r] = Fe();
  return L2e(
    r,
    e,
    t,
    n
  );
}
function P2e(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var O2e = P2e(function(e) {
  const t = new URLSearchParams();
  t.append("code", e);
  for (let n = 1; n < arguments.length; n++) t.append("v", arguments[n]);
  throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
});
function H_(e, t = (n) => n) {
  return (n) => {
    const r = e.exec(n);
    return r === null ? null : { index: r.index, length: r[0].length, text: r[0], url: t(r[0]) };
  };
}
function mO(e, t) {
  for (let n = 0; n < t.length; n++) {
    const r = t[n](e);
    if (r) return r;
  }
  return null;
}
const $2e = /[.,;\s]/;
function rg(e) {
  return $2e.test(e);
}
function gO(e) {
  return rg(e[e.length - 1]);
}
function g3(e) {
  return rg(e[0]);
}
function bO(e) {
  let t = e.getPreviousSibling();
  return re(t) && (t = t.getLastDescendant()), t === null || Ca(t) || ce(t) && gO(t.getTextContent());
}
function UO(e) {
  let t = e.getNextSibling();
  return re(t) && (t = t.getFirstDescendant()), t === null || Ca(t) || ce(t) && g3(t.getTextContent());
}
function F2e(e, t, n, r) {
  return (e > 0 ? rg(n[e - 1]) : bO(r[0])) ? t < n.length ? rg(n[t]) : UO(r[r.length - 1]) : !1;
}
function z2e(e, t, n) {
  const r = [], i = [], a = [];
  let l = 0, s = 0;
  const c = [...e];
  for (; c.length > 0; ) {
    const d = c[0], o = d.getTextContent().length, u = s;
    s + o <= t ? (r.push(d), l += o) : u >= n ? a.push(d) : i.push(d), s += o, c.shift();
  }
  return [l, r, i, a];
}
function B2e(e, t, n, r) {
  const i = m4(r.url, r.attributes);
  if (e.length === 1) {
    let a, l = e[0];
    t === 0 ? [a, l] = l.splitText(n) : [, a, l] = l.splitText(t, n);
    const s = un(r.text);
    return s.setFormat(a.getFormat()), s.setDetail(a.getDetail()), s.setStyle(a.getStyle()), i.append(s), a.replace(i), l;
  }
  if (e.length > 1) {
    const a = e[0];
    let l, s = a.getTextContent().length;
    t === 0 ? l = a : [, l] = a.splitText(t);
    const c = [];
    let d;
    for (let f = 1; f < e.length; f++) {
      const p = e[f], g = p.getTextContent().length, b = s;
      if (b < n) if (s + g <= n) c.push(p);
      else {
        const [v, U] = p.splitText(n - b);
        c.push(v), d = U;
      }
      s += g;
    }
    const o = se(), u = o ? o.getNodes().find(ce) : void 0, h = un(l.getTextContent());
    return h.setFormat(l.getFormat()), h.setDetail(l.getDetail()), h.setStyle(l.getStyle()), i.append(h, ...c), u && u === l && (ie(o) ? h.select(o.anchor.offset, o.focus.offset) : Xn(o) && h.select(0, h.getTextContent().length)), l.replace(i), d;
  }
}
function H5(e, t, n) {
  const r = e.getChildren(), i = r.length;
  for (let c = 0; c < i; c++) {
    const d = r[c];
    if (!ce(d) || !d.isSimpleText()) return Lp(e), void n(null, e.getURL());
  }
  const a = e.getTextContent(), l = mO(a, t);
  if (l === null || l.text !== a || !bO(e) || !UO(e)) return Lp(e), void n(null, e.getURL());
  const s = e.getURL();
  if (s !== l.url && (e.setURL(l.url), n(l.url, s)), l.attributes) {
    const c = e.getRel();
    c !== l.attributes.rel && (e.setRel(l.attributes.rel || null), n(l.attributes.rel || null, c));
    const d = e.getTarget();
    d !== l.attributes.target && (e.setTarget(l.attributes.target || null), n(l.attributes.target || null, d));
  }
}
function Lp(e) {
  const t = e.getChildren();
  for (let n = t.length - 1; n >= 0; n--) e.insertAfter(t[n]);
  return e.remove(), t.map((n) => n.getLatest());
}
function H2e(e, t, n) {
  Y(() => {
    e.hasNodes([Ef]) || O2e(77);
    const r = (i, a) => {
      n && n(i, a);
    };
    return Pt(e.registerNodeTransform(aa, (i) => {
      const a = i.getParentOrThrow(), l = i.getPreviousSibling();
      if (Ql(a) && !a.getIsUnlinked()) H5(a, t, r);
      else if (!qn(a)) {
        if (i.isSimpleText() && (g3(i.getTextContent()) || !Ql(l))) {
          const s = function(c) {
            const d = [c];
            let o = c.getNextSibling();
            for (; o !== null && ce(o) && o.isSimpleText() && (d.push(o), !/[\s]/.test(o.getTextContent())); ) o = o.getNextSibling();
            return d;
          }(i);
          (function(c, d, o) {
            let u = [...c];
            const h = u.map((b) => b.getTextContent()).join("");
            let f, p = h, g = 0;
            for (; (f = mO(p, d)) && f !== null; ) {
              const b = f.index, v = b + f.length;
              if (F2e(g + b, g + v, h, u)) {
                const [U, , y, w] = z2e(u, g + b, g + v), x = B2e(y, g + b - U, g + v - U, f);
                u = x ? [x, ...w] : w, o(f.url, null), g = 0;
              } else g += v;
              p = p.substring(v);
            }
          })(s, t, r);
        }
        (function(s, c, d) {
          const o = s.getPreviousSibling(), u = s.getNextSibling(), h = s.getTextContent();
          var f;
          !Ql(o) || o.getIsUnlinked() || g3(h) && (f = h, !(o.isEmailURI() ? /^\.[a-zA-Z]{2,}/.test(f) : /^\.[a-zA-Z0-9]{1,}/.test(f))) || (o.append(s), H5(o, c, d), d(null, o.getURL())), !Ql(u) || u.getIsUnlinked() || gO(h) || (Lp(u), H5(u, c, d), d(null, u.getURL()));
        })(i, t, r);
      }
    }), e.registerCommand(Ul, (i) => {
      const a = se();
      return i !== null || !ie(a) || a.extract().forEach((l) => {
        const s = l.getParent();
        if (Ql(s)) return s.setIsUnlinked(!s.getIsUnlinked()), s.markDirty(), !0;
      }), !1;
    }, ot));
  }, [e, t, n]);
}
function W2e({ matchers: e, onChange: t }) {
  const [n] = Fe();
  return H2e(n, e, t), null;
}
const X2e = /((https?:\/\/(www\.)?)|(www\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/, V2e = /(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/, G2e = [
  H_(X2e, (e) => e.startsWith("http") ? e : `https://${e}`),
  H_(V2e, (e) => `mailto:${e}`)
];
function j2e() {
  return /* @__PURE__ */ m(W2e, { matchers: G2e });
}
function K2e({ validateUrl: e, attributes: t }) {
  const [n] = Fe();
  return Y(() => {
    if (!n.hasNodes([H0])) throw new Error("LinkPlugin: LinkNode not registered on editor");
    return Pt(n.registerCommand(Ul, (r) => {
      if (r === null) return J2(r), !0;
      if (typeof r == "string") return !(e !== void 0 && !e(r)) && (J2(r, t), !0);
      {
        const { url: i, target: a, rel: l, title: s } = r;
        return J2(i, { ...t, rel: l, target: a, title: s }), !0;
      }
    }, ot), e !== void 0 ? n.registerCommand(sg, (r) => {
      const i = se();
      if (!ie(i) || i.isCollapsed() || !ns(r, ClipboardEvent)) return !1;
      const a = r;
      if (a.clipboardData === null) return !1;
      const l = a.clipboardData.getData("text");
      return !!e(l) && !i.getNodes().some((s) => re(s)) && (n.dispatchCommand(Ul, { ...t, url: l }), r.preventDefault(), !0);
    }, ot) : () => {
    });
  }, [n, e, t]), null;
}
function Y2e() {
  return /* @__PURE__ */ m(K2e, { validateUrl: xW });
}
function q2e(e, t, n) {
  const [r] = Fe();
  Y(() => Pt(...jH(r, e, t, n)), [n, r, e, t]);
}
const Z2e = /(^|$|[^A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԧԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠࢢ-ࢬऄ-हऽॐक़-ॡॱ-ॷॹ-ॿঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-ళవ-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤜᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎↃↄⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々〆〱-〵〻〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚗꚠ-ꛥꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞓꞠ-Ɦꟸ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꪀ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ])(congrats|congratulations|gratuluju|gratuluji|gratulujeme|blahopřeju|blahopřeji|blahopřejeme|Til lykke|Tillykke|Glückwunsch|Gratuliere|felicitaciones|enhorabuena|paljon onnea|onnittelut|Félicitations|gratula|gratulálok|gratulálunk|congratulazioni|complimenti|おめでとう|おめでとうございます|축하해|축하해요|gratulerer|Gefeliciteerd|gratulacje|Parabéns|parabéns|felicitações|felicitări|мои поздравления|поздравляем|поздравляю|gratulujem|blahoželám|ยินดีด้วย|ขอแสดงความยินดี|tebrikler|tebrik ederim|恭喜|祝贺你|恭喜你|恭喜|恭喜|baie geluk|veels geluk|অভিনন্দন|Čestitam|Čestitke|Čestitamo|Συγχαρητήρια|Μπράβο|અભિનંદન|badhai|बधाई|अभिनंदन|Честитам|Свака част|hongera|வாழ்த்துகள்|வாழ்த்துக்கள்|అభినందనలు|അഭിനന്ദനങ്ങൾ|Chúc mừng|מזל טוב|mazel tov|mazal tov)(^|$|[^A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԧԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠࢢ-ࢬऄ-हऽॐक़-ॡॱ-ॷॹ-ॿঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-ళవ-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤜᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎↃↄⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々〆〱-〵〻〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚗꚠ-ꛥꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞓꞠ-Ɦꟸ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꪀ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ])/i;
function J2e() {
  const [e] = Fe();
  Y(() => {
    if (!e.hasNodes([c0]))
      throw new Error("KeywordsPlugin: KeywordNode not registered on editor");
  }, [e]);
  const t = he((r) => rM(r.getTextContent()), []), n = he((r) => {
    const i = Z2e.exec(r);
    if (i === null)
      return null;
    const a = i[2].length, l = i.index + i[1].length;
    return {
      end: l + a,
      start: l
    };
  }, []);
  return q2e(
    n,
    c0,
    t
  ), null;
}
const W_ = /* @__PURE__ */ new Map([
  [":)", ["doc-editor-emoji happysmile", "🙂"]],
  [":D", ["doc-editor-emoji veryhappysmile", "😀"]],
  [":(", ["doc-editor-emoji unhappysmile", "🙁"]],
  ["<3", ["doc-editor-emoji heart", "❤"]],
  ["🙂", ["doc-editor-emoji happysmile", "🙂"]],
  ["😀", ["doc-editor-emoji veryhappysmile", "😀"]],
  ["🙁", ["doc-editor-emoji unhappysmile", "🙁"]],
  ["❤", ["doc-editor-emoji heart", "❤"]]
]);
function Q2e(e) {
  const t = e.getTextContent();
  for (let n = 0; n < t.length; n++) {
    const r = W_.get(t[n]) || W_.get(t.slice(n, n + 2));
    if (r !== void 0) {
      const [i, a] = r;
      let l;
      n === 0 ? [l] = e.splitText(n + 2) : [, l] = e.splitText(n, n + 2);
      const s = nM(i, a);
      return l.replace(s), s;
    }
  }
  return null;
}
function e6e(e) {
  let t = e;
  for (; t !== null; ) {
    if (!t.isSimpleText())
      return;
    t = Q2e(t);
  }
}
function t6e(e) {
  Y(() => {
    if (!e.hasNodes([kf]))
      throw new Error("EmojisPlugin: EmojiNode not registered on editor");
    return e.registerNodeTransform(aa, e6e);
  }, [e]);
}
function n6e() {
  const [e] = Fe();
  return t6e(e), null;
}
const X_ = "startTransition", b3 = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, r6e = b3 ? Bn : Y;
class v9 {
  constructor(t) {
    this.key = t, this.ref = { current: null }, this.setRefElement = this.setRefElement.bind(this);
  }
  setRefElement(t) {
    this.ref = { current: t };
  }
}
const V_ = (e) => {
  const t = document.getElementById("typeahead-menu");
  if (!t) return;
  const n = t.getBoundingClientRect();
  n.top + n.height > window.innerHeight && t.scrollIntoView({ block: "center" }), n.top < 0 && t.scrollIntoView({ block: "center" }), e.scrollIntoView({ block: "nearest" });
};
function G_(e, t) {
  const n = e.getBoundingClientRect(), r = t.getBoundingClientRect();
  return n.top > r.top && n.top < r.bottom;
}
function i6e(e, t, n, r) {
  const [i] = Fe();
  Y(() => {
    if (t != null && e != null) {
      const a = i.getRootElement(), l = a != null ? function(u, h) {
        let f = getComputedStyle(u);
        const p = f.position === "absolute", g = /(auto|scroll)/;
        if (f.position === "fixed") return document.body;
        for (let b = u; b = b.parentElement; ) if (f = getComputedStyle(b), (!p || f.position !== "static") && g.test(f.overflow + f.overflowY + f.overflowX)) return b;
        return document.body;
      }(a) : document.body;
      let s = !1, c = G_(t, l);
      const d = function() {
        s || (window.requestAnimationFrame(function() {
          n(), s = !1;
        }), s = !0);
        const u = G_(t, l);
        u !== c && (c = u, r != null && r(u));
      }, o = new ResizeObserver(n);
      return window.addEventListener("resize", n), document.addEventListener("scroll", d, { capture: !0, passive: !0 }), o.observe(t), () => {
        o.unobserve(t), window.removeEventListener("resize", n), document.removeEventListener("scroll", d, !0);
      };
    }
  }, [t, i, r, n, e]);
}
const j_ = xn();
function a6e({ close: e, editor: t, anchorElementRef: n, resolution: r, options: i, menuRenderFn: a, onSelectOption: l, shouldSplitNodeWithQuery: s = !1, commandPriority: c = ot }) {
  const [d, o] = Q(null), u = r.match && r.match.matchingString;
  Y(() => {
    o(0);
  }, [u]);
  const h = he((p) => {
    t.update(() => {
      const g = r.match != null && s ? function(b) {
        const v = se();
        if (!ie(v) || !v.isCollapsed()) return null;
        const U = v.anchor;
        if (U.type !== "text") return null;
        const y = U.getNode();
        if (!y.isSimpleText()) return null;
        const w = U.offset, x = y.getTextContent().slice(0, w), E = b.replaceableString.length, S = w - function(k, M, A) {
          let L = A;
          for (let R = L; R <= M.length; R++) k.substr(-R) === M.substr(0, R) && (L = R);
          return L;
        }(x, b.matchingString, E);
        if (S < 0) return null;
        let _;
        return S === 0 ? [_] = y.splitText(w) : [, _] = y.splitText(S, w), _;
      }(r.match) : null;
      l(p, g, e, r.match ? r.match.matchingString : "");
    });
  }, [t, s, r.match, l, e]), f = he((p) => {
    const g = t.getRootElement();
    g !== null && (g.setAttribute("aria-activedescendant", "typeahead-item-" + p), o(p));
  }, [t]);
  return Y(() => () => {
    const p = t.getRootElement();
    p !== null && p.removeAttribute("aria-activedescendant");
  }, [t]), r6e(() => {
    i === null ? o(null) : d === null && f(0);
  }, [i, d, f]), Y(() => Pt(t.registerCommand(j_, ({ option: p }) => !(!p.ref || p.ref.current == null) && (V_(p.ref.current), !0), c)), [t, f, c]), Y(() => Pt(t.registerCommand(Ao, (p) => {
    const g = p;
    if (i !== null && i.length && d !== null) {
      const b = d !== i.length - 1 ? d + 1 : 0;
      f(b);
      const v = i[b];
      v.ref != null && v.ref.current && t.dispatchCommand(j_, { index: b, option: v }), g.preventDefault(), g.stopImmediatePropagation();
    }
    return !0;
  }, c), t.registerCommand(Io, (p) => {
    const g = p;
    if (i !== null && i.length && d !== null) {
      const b = d !== 0 ? d - 1 : i.length - 1;
      f(b);
      const v = i[b];
      v.ref != null && v.ref.current && V_(v.ref.current), g.preventDefault(), g.stopImmediatePropagation();
    }
    return !0;
  }, c), t.registerCommand(rd, (p) => {
    const g = p;
    return g.preventDefault(), g.stopImmediatePropagation(), e(), !0;
  }, c), t.registerCommand(mf, (p) => {
    const g = p;
    return i !== null && d !== null && i[d] != null && (g.preventDefault(), g.stopImmediatePropagation(), h(i[d]), !0);
  }, c), t.registerCommand(a0, (p) => i !== null && d !== null && i[d] != null && (p !== null && (p.preventDefault(), p.stopImmediatePropagation()), h(i[d]), !0), c)), [h, e, t, i, d, f, c]), a(n, Ke(() => ({ options: i, selectOptionAndCleanUp: h, selectedIndex: d, setHighlightedIndex: o }), [h, d, i]), r.match ? r.match.matchingString : "");
}
const l6e = `\\.,\\+\\*\\?\\$\\@\\|#{}\\(\\)\\^\\-\\[\\]\\\\/!%'"~=<>_:;`;
function y9(e, { minLength: t = 1, maxLength: n = 75 }) {
  return he((r) => {
    const i = new RegExp("(^|\\s|\\()([" + e + "]((?:" + ("[^" + e + l6e + "\\s]") + "){0," + n + "}))$").exec(r);
    if (i !== null) {
      const a = i[1], l = i[3];
      if (l.length >= t) return { leadOffset: i.index + a.length, matchingString: l, replaceableString: i[2] };
    }
    return null;
  }, [n, t, e]);
}
function w9({ options: e, onQueryChange: t, onSelectOption: n, onOpen: r, onClose: i, menuRenderFn: a, triggerFn: l, anchorClassName: s, commandPriority: c = ot, parent: d }) {
  const [o] = Fe(), [u, h] = Q(null), f = function(b, v, U, y = b3 ? document.body : void 0, w = !0) {
    const [x] = Fe(), E = de(b3 ? document.createElement("div") : null), S = he(() => {
      if (E.current === null || y === void 0) return;
      E.current.style.top = E.current.style.bottom;
      const k = x.getRootElement(), M = E.current, A = M.firstChild;
      if (k !== null && b !== null) {
        const { left: L, top: R, width: z, height: F } = b.getRect(), W = E.current.offsetHeight;
        if (M.style.top = `${R + W + 3 + (w ? window.pageYOffset : 0)}px`, M.style.left = `${L + window.pageXOffset}px`, M.style.height = `${F}px`, M.style.width = `${z}px`, A !== null) {
          A.style.top = `${R}`;
          const B = A.getBoundingClientRect(), j = B.height, V = B.width, q = k.getBoundingClientRect();
          L + V > q.right && (M.style.left = `${q.right - V + window.pageXOffset}px`), (R + j > window.innerHeight || R + j > q.bottom) && R - q.top > j + F && (M.style.top = `${R - j - F + (w ? window.pageYOffset : 0)}px`);
        }
        M.isConnected || (U != null && (M.className = U), M.setAttribute("aria-label", "Typeahead menu"), M.setAttribute("id", "typeahead-menu"), M.setAttribute("role", "listbox"), M.style.display = "block", M.style.position = "absolute", y.append(M)), E.current = M, k.setAttribute("aria-controls", "typeahead-menu");
      }
    }, [x, b, w, U, y]);
    Y(() => {
      const k = x.getRootElement();
      if (b !== null) return S(), () => {
        k !== null && k.removeAttribute("aria-controls");
        const M = E.current;
        M !== null && M.isConnected && M.remove();
      };
    }, [x, S, b]);
    const _ = he((k) => {
      b !== null && (k || v(null));
    }, [b, v]);
    return i6e(b, E.current, S, _), E;
  }(u, h, s, d), p = he(() => {
    h(null), i != null && u !== null && i();
  }, [i, u]), g = he((b) => {
    h(b), r != null && u === null && r(b);
  }, [r, u]);
  return Y(() => {
    const b = o.registerUpdateListener(() => {
      o.getEditorState().read(() => {
        const v = o._window || window, U = v.document.createRange(), y = se(), w = function(S) {
          let _ = null;
          return S.getEditorState().read(() => {
            const k = se();
            ie(k) && (_ = function(M) {
              const A = M.anchor;
              if (A.type !== "text") return null;
              const L = A.getNode();
              if (!L.isSimpleText()) return null;
              const R = A.offset;
              return L.getTextContent().slice(0, R);
            }(k));
          }), _;
        }(o);
        if (!ie(y) || !y.isCollapsed() || w === null || U === null) return void p();
        const x = l(w, o);
        if (t(x ? x.matchingString : null), x !== null && !function(S, _) {
          return _ === 0 && S.getEditorState().read(() => {
            const k = se();
            if (ie(k)) {
              const M = k.anchor.getNode().getPreviousSibling();
              return ce(M) && M.isTextEntity();
            }
            return !1;
          });
        }(o, x.leadOffset) && function(_, k, M) {
          const A = M.getSelection();
          if (A === null || !A.isCollapsed) return !1;
          const L = A.anchorNode, R = _, z = A.anchorOffset;
          if (L == null || z == null) return !1;
          try {
            k.setStart(L, R), k.setEnd(L, z);
          } catch {
            return !1;
          }
          return !0;
        }(x.leadOffset, U, v) !== null)
          return E = () => g({ getRect: () => U.getBoundingClientRect(), match: x }), void (X_ in pe ? pe[X_](E) : E());
        var E;
        p();
      });
    });
    return () => {
      b();
    };
  }, [o, l, t, u, p, g]), u === null || o === null || f.current === null ? null : m(a6e, { close: p, resolution: u, editor: o, anchorElementRef: f, options: e, menuRenderFn: a, shouldSplitNodeWithQuery: !0, onSelectOption: n, commandPriority: c });
}
class Kn extends v9 {
  constructor(n, r) {
    super(n);
    // What shows up in the editor
    Ne(this, "title");
    // Icon for display
    Ne(this, "icon");
    // For extra searching.
    Ne(this, "keywords");
    // TBD
    Ne(this, "keyboardShortcut");
    // What happens when you select this option?
    Ne(this, "onSelect");
    this.title = n, this.keywords = r.keywords || [], this.icon = r.icon, this.keyboardShortcut = r.keyboardShortcut, this.onSelect = r.onSelect.bind(this);
  }
}
function s6e({
  index: e,
  isSelected: t,
  onClick: n,
  onMouseEnter: r,
  option: i
}) {
  let a = "item";
  return t && (a += " selected"), /* @__PURE__ */ D(
    "li",
    {
      tabIndex: -1,
      className: a,
      ref: i.setRefElement,
      role: "option",
      "aria-selected": t,
      id: "typeahead-item-" + e,
      onMouseEnter: r,
      onClick: n,
      children: [
        i.icon,
        /* @__PURE__ */ m("span", { className: "text", children: i.title })
      ]
    },
    i.key
  );
}
function o6e(e, t) {
  const n = [];
  if (t == null)
    return n;
  const r = t.match(/^([1-9]\d?)(?:x([1-9]\d?)?)?$/);
  if (r !== null) {
    const i = r[1], a = r[2] ? [r[2]] : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(String);
    n.push(
      ...a.map(
        (l) => new Kn(`${i}x${l} Table`, {
          icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon table" }),
          keywords: ["table"],
          onSelect: () => e.dispatchCommand(fb, { columns: l, rows: i })
        })
      )
    );
  }
  return n;
}
function c6e(e, t, n) {
  return [
    new Kn("Paragraph", {
      icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon paragraph" }),
      keywords: ["normal", "paragraph", "p", "text"],
      onSelect: () => e.update(() => {
        const r = se();
        ie(r) && oc(r, () => He());
      })
    }),
    ...[1, 2, 3].map(
      (r) => new Kn(`Heading ${r}`, {
        icon: /* @__PURE__ */ m("i", { className: `doc-editor-icon h${r}` }),
        keywords: ["heading", "header", `h${r}`],
        onSelect: () => e.update(() => {
          const i = se();
          ie(i) && oc(i, () => cc(`h${r}`));
        })
      })
    ),
    new Kn("Table", {
      icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon table" }),
      keywords: ["table", "grid", "spreadsheet", "rows", "columns"],
      onSelect: () => t("Insert Table", (r) => /* @__PURE__ */ m(rO, { activeEditor: e, onClose: r }))
    }),
    new Kn("Numbered List", {
      icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon number" }),
      keywords: ["numbered list", "ordered list", "ol"],
      onSelect: () => e.dispatchCommand(rb, void 0)
    }),
    new Kn("Bulleted List", {
      icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon bullet" }),
      keywords: ["bulleted list", "unordered list", "ul"],
      onSelect: () => e.dispatchCommand(nb, void 0)
    }),
    new Kn("Check List", {
      icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon check" }),
      keywords: ["check list", "todo list"],
      onSelect: () => e.dispatchCommand(ib, void 0)
    }),
    new Kn("Quote", {
      icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon quote" }),
      keywords: ["block quote"],
      onSelect: () => e.update(() => {
        const r = se();
        ie(r) && oc(r, () => Mg());
      })
    }),
    new Kn("Code", {
      icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon code" }),
      keywords: ["javascript", "python", "js", "codeblock"],
      onSelect: () => e.update(() => {
        const r = se();
        if (ie(r))
          if (r.isCollapsed())
            oc(r, () => Ic());
          else {
            const i = r.getTextContent(), a = Ic();
            r.insertNodes([a]), r.insertRawText(i);
          }
      })
    }),
    new Kn("Divider", {
      icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon horizontal-rule" }),
      keywords: ["horizontal rule", "divider", "hr"],
      onSelect: () => e.dispatchCommand(ob, void 0)
    }),
    new Kn("Page Break", {
      icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon page-break" }),
      keywords: ["page break", "divider"],
      onSelect: () => e.dispatchCommand(Jb, void 0)
    }),
    new Kn("Excalidraw", {
      icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon diagram-2" }),
      keywords: ["excalidraw", "diagram", "drawing"],
      onSelect: () => e.dispatchCommand(m9, void 0)
    }),
    new Kn("Poll", {
      icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon poll" }),
      keywords: ["poll", "vote"],
      onSelect: () => t("Insert Poll", (r) => /* @__PURE__ */ m(aO, { activeEditor: e, onClose: r }))
    }),
    ...U9.map(
      (r) => new Kn(`Embed ${r.contentName}`, {
        icon: r.icon,
        keywords: [...r.keywords, "embed"],
        onSelect: () => e.dispatchCommand(b9, r.type)
      })
    ),
    new Kn("Equation", {
      icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon equation" }),
      keywords: ["equation", "latex", "math"],
      onSelect: () => t("Insert Equation", (r) => /* @__PURE__ */ m(cO, { activeEditor: e, onClose: r }))
    }),
    new Kn("GIF", {
      icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon gif" }),
      keywords: ["gif", "animate", "image", "file"],
      onSelect: () => e.dispatchCommand(Lf, {
        altText: "Cat typing on a laptop",
        src: "https://media.giphy.com/media/3o7TKz5R0Lkzg7g9gI/giphy.gif"
      })
    }),
    new Kn("Image", {
      icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon image" }),
      keywords: ["image", "photo", "picture", "file"],
      onSelect: () => t("Insert Image", (r) => /* @__PURE__ */ m(gT, { activeEditor: e, onClose: r, imageUploadCallback: n }))
    }),
    new Kn("Collapsible", {
      icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon caret-right" }),
      keywords: ["collapse", "collapsible", "toggle"],
      onSelect: () => e.dispatchCommand(g9, void 0)
    }),
    new Kn("Columns Layout", {
      icon: /* @__PURE__ */ m("i", { className: "doc-editor-icon columns" }),
      keywords: ["columns", "layout", "grid"],
      onSelect: () => t("Insert Columns Layout", (r) => /* @__PURE__ */ m(sO, { activeEditor: e, onClose: r }))
    }),
    ...["left", "center", "right", "justify"].map(
      (r) => new Kn(`Align ${r}`, {
        icon: /* @__PURE__ */ m("i", { className: `doc-editor-icon ${r}-align` }),
        keywords: ["align", "justify", r],
        onSelect: () => e.dispatchCommand(il, r)
      })
    )
  ];
}
function d6e({ imageUploadCallback: e }) {
  const [t] = Fe(), [n, r] = zg(), [i, a] = Q(null), l = y9("/", {
    minLength: 0
  }), s = Ke(() => {
    const d = c6e(t, r, e);
    if (!i)
      return d;
    const o = new RegExp(i, "i");
    return [
      ...o6e(t, i),
      ...d.filter(
        (u) => o.test(u.title) || u.keywords.some((h) => o.test(h))
      )
    ];
  }, [t, i, r]), c = he(
    (d, o, u, h) => {
      t.update(() => {
        o == null || o.remove(), d.onSelect(h), u();
      });
    },
    [t]
  );
  return /* @__PURE__ */ D(ge, { children: [
    n,
    /* @__PURE__ */ m(
      w9,
      {
        onQueryChange: a,
        onSelectOption: c,
        triggerFn: l,
        options: s,
        menuRenderFn: (d, { selectedIndex: o, selectOptionAndCleanUp: u, setHighlightedIndex: h }) => d.current && s.length ? _c.createPortal(
          /* @__PURE__ */ m("div", { className: "doc-editor-typeahead-popover component-picker-menu", children: /* @__PURE__ */ m("ul", { children: s.map((f, p) => /* @__PURE__ */ m(
            s6e,
            {
              index: p,
              isSelected: o === p,
              onClick: () => {
                h(p), u(f);
              },
              onMouseEnter: () => {
                h(p);
              },
              option: f
            },
            f.key
          )) }) }),
          d.current
        ) : null
      }
    )
  ] });
}
function u6e(e, t) {
  const n = e.getRangeAt(0);
  let r;
  if (e.anchorNode === t) {
    let i = t;
    for (; i.firstElementChild != null; )
      i = i.firstElementChild;
    r = i.getBoundingClientRect();
  } else
    r = n.getBoundingClientRect();
  return r;
}
const h6e = 10, f6e = 5;
function p6e(e, t, n, r = !1, i = h6e, a = f6e) {
  const l = n.parentElement;
  if (e === null || !l) {
    t.style.opacity = "0", t.style.transform = "translate(-10000px, -10000px)";
    return;
  }
  const s = t.getBoundingClientRect(), c = n.getBoundingClientRect(), d = l.getBoundingClientRect();
  let o = e.top - s.height - i, u = e.left - a;
  o < d.top && (o += s.height + e.height + i * (r ? 9 : 2)), u + s.width > d.right && (u = d.right - s.width - a), o -= c.top, u -= c.left, t.style.opacity = "1", t.style.transform = `translate(${u}px, ${o}px)`;
}
function m6e({
  editor: e,
  anchorElem: t,
  isLink: n,
  isBold: r,
  isItalic: i,
  isUnderline: a,
  isCode: l,
  isStrikethrough: s,
  isSubscript: c,
  isSuperscript: d
}) {
  const o = de(null), u = he(() => {
    n ? e.dispatchCommand(Ul, null) : e.dispatchCommand(Ul, "https://");
  }, [e, n]);
  function h(g) {
    if (o != null && o.current && (g.buttons === 1 || g.buttons === 3) && o.current.style.pointerEvents !== "none") {
      const b = g.clientX, v = g.clientY, U = document.elementFromPoint(b, v);
      o.current.contains(U) || (o.current.style.pointerEvents = "none");
    }
  }
  function f(g) {
    o != null && o.current && o.current.style.pointerEvents !== "auto" && (o.current.style.pointerEvents = "auto");
  }
  Y(() => {
    if (o != null && o.current)
      return document.addEventListener("mousemove", h), document.addEventListener("mouseup", f), () => {
        document.removeEventListener("mousemove", h), document.removeEventListener("mouseup", f);
      };
  }, [o]);
  const p = he(() => {
    const g = se(), b = o.current, v = window.getSelection();
    if (b === null)
      return;
    const U = e.getRootElement();
    if (g !== null && v !== null && !v.isCollapsed && U !== null && U.contains(v.anchorNode)) {
      const y = u6e(v, U);
      p6e(
        y,
        b,
        t,
        n
      );
    }
  }, [e, t, n]);
  return Y(() => {
    const g = t.parentElement, b = () => {
      e.getEditorState().read(() => {
        p();
      });
    };
    return window.addEventListener("resize", b), g && g.addEventListener("scroll", b), () => {
      window.removeEventListener("resize", b), g && g.removeEventListener("scroll", b);
    };
  }, [e, p, t]), Y(() => (e.getEditorState().read(() => {
    p();
  }), Pt(
    e.registerUpdateListener(({ editorState: g }) => {
      g.read(() => {
        p();
      });
    }),
    e.registerCommand(
      Ei,
      () => (p(), !1),
      ot
    )
  )), [e, p]), /* @__PURE__ */ m("div", { ref: o, className: "floating-text-format-popup", children: e.isEditable() && /* @__PURE__ */ D(ge, { children: [
    /* @__PURE__ */ m(
      "button",
      {
        type: "button",
        onClick: () => {
          e.dispatchCommand(Mn, "bold");
        },
        className: "popup-item spaced " + (r ? "active" : ""),
        "aria-label": "Format text as bold",
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon format bold" })
      }
    ),
    /* @__PURE__ */ m(
      "button",
      {
        type: "button",
        onClick: () => {
          e.dispatchCommand(Mn, "italic");
        },
        className: "popup-item spaced " + (i ? "active" : ""),
        "aria-label": "Format text as italics",
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon format italic" })
      }
    ),
    /* @__PURE__ */ m(
      "button",
      {
        type: "button",
        onClick: () => {
          e.dispatchCommand(Mn, "underline");
        },
        className: "popup-item spaced " + (a ? "active" : ""),
        "aria-label": "Format text to underlined",
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon format underline" })
      }
    ),
    /* @__PURE__ */ m(
      "button",
      {
        type: "button",
        onClick: () => {
          e.dispatchCommand(Mn, "strikethrough");
        },
        className: "popup-item spaced " + (s ? "active" : ""),
        "aria-label": "Format text with a strikethrough",
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon format strikethrough" })
      }
    ),
    /* @__PURE__ */ m(
      "button",
      {
        type: "button",
        onClick: () => {
          e.dispatchCommand(Mn, "subscript");
        },
        className: "popup-item spaced " + (c ? "active" : ""),
        title: "Subscript",
        "aria-label": "Format Subscript",
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon format subscript" })
      }
    ),
    /* @__PURE__ */ m(
      "button",
      {
        type: "button",
        onClick: () => {
          e.dispatchCommand(Mn, "superscript");
        },
        className: "popup-item spaced " + (d ? "active" : ""),
        title: "Superscript",
        "aria-label": "Format Superscript",
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon format superscript" })
      }
    ),
    /* @__PURE__ */ m(
      "button",
      {
        type: "button",
        onClick: () => {
          e.dispatchCommand(Mn, "code");
        },
        className: "popup-item spaced " + (l ? "active" : ""),
        "aria-label": "Insert code block",
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon format code" })
      }
    ),
    /* @__PURE__ */ m(
      "button",
      {
        type: "button",
        onClick: u,
        className: "popup-item spaced " + (n ? "active" : ""),
        "aria-label": "Insert link",
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon format link" })
      }
    )
  ] }) });
}
function g6e(e, t) {
  const [n, r] = Q(!1), [i, a] = Q(!1), [l, s] = Q(!1), [c, d] = Q(!1), [o, u] = Q(!1), [h, f] = Q(!1), [p, g] = Q(!1), [b, v] = Q(!1), [U, y] = Q(!1), w = he(() => {
    e.getEditorState().read(() => {
      if (e.isComposing())
        return;
      const x = se(), E = window.getSelection(), S = e.getRootElement();
      if (E !== null && (!ie(x) || S === null || !S.contains(E.anchorNode))) {
        r(!1);
        return;
      }
      if (!ie(x))
        return;
      const _ = h0(x);
      s(x.hasFormat("bold")), d(x.hasFormat("italic")), u(x.hasFormat("underline")), f(x.hasFormat("strikethrough")), g(x.hasFormat("subscript")), v(x.hasFormat("superscript")), y(x.hasFormat("code"));
      const k = _.getParent();
      qn(k) || qn(_) ? a(!0) : a(!1), !eb(x.anchor.getNode()) && x.getTextContent() !== "" ? r(ce(_) || La(_)) : r(!1);
      const M = x.getTextContent().replace(/\n/g, "");
      if (!x.isCollapsed() && M === "") {
        r(!1);
        return;
      }
    });
  }, [e]);
  return Y(() => (document.addEventListener("selectionchange", w), () => {
    document.removeEventListener("selectionchange", w);
  }), [w]), Y(() => Pt(
    e.registerUpdateListener(() => {
      w();
    }),
    e.registerRootListener(() => {
      e.getRootElement() === null && r(!1);
    })
  ), [e, w]), n ? fi(
    /* @__PURE__ */ m(
      m6e,
      {
        editor: e,
        anchorElem: t,
        isLink: i,
        isBold: l,
        isItalic: c,
        isStrikethrough: h,
        isSubscript: p,
        isSuperscript: b,
        isUnderline: o,
        isCode: U
      }
    ),
    t
  ) : null;
}
function b6e({
  anchorElem: e = document.body
}) {
  const [t] = Fe();
  return g6e(t, e);
}
function U6e(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var J1 = U6e(function(e) {
  const t = new URLSearchParams();
  t.append("code", e);
  for (let n = 1; n < arguments.length; n++) t.append("v", arguments[n]);
  throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
});
function v6e({ hasCellMerge: e = !0, hasCellBackgroundColor: t = !0, hasTabHandler: n = !0 }) {
  const [r] = Fe();
  return Y(() => (r.hasNodes([co, oo, Ig]) || J1(10), Pt(r.registerCommand(fb, ({ columns: i, rows: a, includeHeaders: l }) => {
    const s = ez(Number(a), Number(i), l);
    Lo(s);
    const c = s.getFirstDescendant();
    return ce(c) && c.select(), !0;
  }, it), r.registerNodeTransform(co, (i) => {
    const [a] = gb(i, null, null), l = a.reduce((c, d) => Math.max(c, d.length), 0), s = i.getChildren();
    for (let c = 0; c < a.length; ++c) {
      const d = s[c];
      if (!d) continue;
      const o = a[c].reduce((u, h) => h ? 1 + u : u, 0);
      if (o !== l) for (let u = o; u < l; ++u) {
        const h = Ma(0);
        h.append(He()), d.append(h);
      }
    }
  }))), [r]), Y(() => {
    const i = /* @__PURE__ */ new Map(), a = (s, c, d) => {
      const o = d, u = sz(s, o, r, n);
      i.set(c, [u, o]);
    }, l = r.registerMutationListener(co, (s) => {
      for (const [c, d] of s) if (d === "created" || d === "updated") {
        const o = i.get(c), u = r.getElementByKey(c);
        o && u === o[1] || (o && (o[0].removeListeners(), i.delete(c)), u !== null && r.getEditorState().read(() => {
          const h = Rt(c);
          fn(h) && a(h, c, u);
        }));
      } else if (d === "destroyed") {
        const o = i.get(c);
        o !== void 0 && (o[0].removeListeners(), i.delete(c));
      }
    }, { skipInitialization: !1 });
    return () => {
      l();
      for (const [, [s]] of i) s.removeListeners();
    };
  }, [r, n]), Y(() => {
    if (!e) return r.registerNodeTransform(oo, (i) => {
      if (i.getColSpan() > 1 || i.getRowSpan() > 1) {
        const [, , a] = Cr(i), [l] = Xi(a, i, i), s = l.length, c = l[0].length;
        let d = a.getFirstChild();
        Vn(d) || J1(175);
        const o = [];
        for (let u = 0; u < s; u++) {
          u !== 0 && (d = d.getNextSibling(), Vn(d) || J1(175));
          let h = null;
          for (let f = 0; f < c; f++) {
            const p = l[u][f], g = p.cell;
            if (p.startRow === u && p.startColumn === f) h = g, o.push(g);
            else if (g.getColSpan() > 1 || g.getRowSpan() > 1) {
              De(g) || J1(176);
              const b = Ma(g.__headerState);
              h !== null ? h.insertAfter(b) : iF(d, b);
            }
          }
        }
        for (const u of o) u.setColSpan(1), u.setRowSpan(1);
      }
    });
  }, [r, e]), Y(() => {
    if (!t) return r.registerNodeTransform(oo, (i) => {
      i.getBackgroundColor() !== null && i.setBackgroundColor(null);
    });
  }, [r, t, e]), null;
}
const y6e = 33, K_ = 92;
function w6e({ editor: e }) {
  const t = de(null), n = de(null), r = de(null), i = de(null), [a, l] = Q(null), [s, c] = Q(null), [d, o] = Q(!1), [u, h] = Q(null), f = he(() => {
    c(null), t.current = null, h(null), i.current = null, r.current = null;
  }, []), p = (_) => (_.buttons & 1) === 1;
  Y(() => e.registerNodeTransform(co, (_) => {
    if (_.getColWidths())
      return _;
    const k = _.getColumnCount(), M = K_;
    return _.setColWidths(Array(k).fill(M)), _;
  }), [e]), Y(() => {
    const _ = (L) => {
      setTimeout(() => {
        const R = L.target;
        if (u) {
          l({
            x: L.clientX,
            y: L.clientY
          });
          return;
        }
        if (o(p(L)), !(n.current && n.current.contains(R)) && t.current !== R) {
          t.current = R;
          const z = S4(R);
          z && s !== z ? e.update(() => {
            const F = on(z.elem);
            if (!F)
              throw new Error("TableCellResizer: Table cell node not found.");
            const W = es(F), B = e.getElementByKey(W.getKey());
            if (!B)
              throw new Error("TableCellResizer: Table element not found.");
            t.current = R, r.current = B.getBoundingClientRect(), c(z);
          }) : z == null && f();
        }
      }, 0);
    }, k = () => {
      setTimeout(() => {
        o(!0);
      }, 0);
    }, M = () => {
      setTimeout(() => {
        o(!1);
      }, 0);
    }, A = e.registerRootListener(
      (L, R) => {
        R == null || R.removeEventListener("mousemove", _), R == null || R.removeEventListener("mousedown", k), R == null || R.removeEventListener("mouseup", M), L == null || L.addEventListener("mousemove", _), L == null || L.addEventListener("mousedown", k), L == null || L.addEventListener("mouseup", M);
      }
    );
    return () => {
      A();
    };
  }, [s, u, e, f]);
  const g = (_) => _ === "bottom", b = he(
    (_) => {
      if (!s)
        throw new Error("TableCellResizer: Expected active cell.");
      e.update(
        () => {
          const k = on(s.elem);
          if (!De(k))
            throw new Error("TableCellResizer: Table cell node not found.");
          const M = es(k), A = pb(k) + k.getRowSpan() - 1, L = M.getChildren();
          if (A >= L.length || A < 0)
            throw new Error("Expected table cell to be inside of table row.");
          const R = L[A];
          if (!Vn(R))
            throw new Error("Expected table row");
          let z = R.getHeight();
          if (z === void 0) {
            const W = R.getChildren();
            z = Math.min(
              ...W.map(
                (B) => v(B, e) ?? 1 / 0
              )
            );
          }
          const F = Math.max(z + _, y6e);
          R.setHeight(F);
        },
        { tag: "skip-scroll-into-view" }
      );
    },
    [s, e]
  ), v = (_, k) => {
    const M = k.getElementByKey(_.getKey());
    return M == null ? void 0 : M.clientHeight;
  }, U = (_, k) => {
    for (let M = 0; M < k.length; M++)
      for (let A = 0; A < k[M].length; A++)
        if (k[M][A].cell === _)
          return A;
  }, y = he(
    (_) => {
      if (!s)
        throw new Error("TableCellResizer: Expected active cell.");
      e.update(
        () => {
          const k = on(s.elem);
          if (!De(k))
            throw new Error("TableCellResizer: Table cell node not found.");
          const M = es(k), [A] = gb(
            M,
            null,
            null
          ), L = U(k, A);
          if (L === void 0)
            throw new Error("TableCellResizer: Table column not found.");
          const R = M.getColWidths();
          if (!R)
            return;
          const z = R[L];
          if (z === void 0)
            return;
          const F = [...R];
          F[L] = Math.max(z + _, K_), M.setColWidths(F);
        },
        { tag: "skip-scroll-into-view" }
      );
    },
    [s, e]
  ), w = he(
    (_) => {
      const k = (M) => {
        if (M.preventDefault(), M.stopPropagation(), !s)
          throw new Error("TableCellResizer: Expected active cell.");
        if (i.current) {
          const { x: A, y: L } = i.current, R = p4(M.target);
          if (g(_)) {
            const z = (M.clientY - L) / R;
            b(z);
          } else {
            const z = (M.clientX - A) / R;
            y(z);
          }
          f(), document.removeEventListener("mouseup", k);
        }
      };
      return k;
    },
    [s, f, y, b]
  ), x = he(
    (_) => (k) => {
      if (k.preventDefault(), k.stopPropagation(), !s)
        throw new Error("TableCellResizer: Expected active cell.");
      i.current = {
        x: k.clientX,
        y: k.clientY
      }, l(i.current), h(_), document.addEventListener("mouseup", w(_));
    },
    [s, w]
  ), S = he(() => {
    if (s) {
      const { height: _, width: k, top: M, left: A } = s.elem.getBoundingClientRect(), L = p4(s.elem), R = 10, z = {
        bottom: {
          backgroundColor: "none",
          cursor: "row-resize",
          height: `${R}px`,
          left: `${(window.scrollX || window.pageXOffset) + A}px`,
          top: `${(window.scrollY || window.pageYOffset) + M + _ - R / 2}px`,
          width: `${k}px`
        },
        right: {
          backgroundColor: "none",
          cursor: "col-resize",
          height: `${_}px`,
          left: `${(window.scrollX || window.pageXOffset) + A + k - R / 2}px`,
          top: `${(window.scrollY || window.pageYOffset) + M}px`,
          width: `${R}px`
        }
      }, F = r.current;
      return u && a && F && (g(u) ? (z[u].left = `${(window.scrollX || window.pageXOffset) + F.left}px`, z[u].top = `${(window.scrollY || window.pageYOffset) + a.y / L}px`, z[u].height = "3px", z[u].width = `${F.width}px`) : (z[u].top = `${(window.scrollY || window.pageYOffset) + F.top}px`, z[u].left = `${(window.scrollX || window.pageXOffset) + a.x / L}px`, z[u].width = "3px", z[u].height = `${F.height}px`), z[u].backgroundColor = "#adf"), z;
    }
    return {
      bottom: null,
      left: null,
      right: null,
      top: null
    };
  }, [s, u, a])();
  return /* @__PURE__ */ m("div", { ref: n, children: s != null && !d && /* @__PURE__ */ D(ge, { children: [
    /* @__PURE__ */ m(
      "div",
      {
        className: "TableCellResizer__resizer TableCellResizer__ui",
        style: S.right || void 0,
        onMouseDown: x("right")
      }
    ),
    /* @__PURE__ */ m(
      "div",
      {
        className: "TableCellResizer__resizer TableCellResizer__ui",
        style: S.bottom || void 0,
        onMouseDown: x("bottom")
      }
    )
  ] }) });
}
function x6e() {
  const [e] = Fe(), t = Df();
  return Ke(
    () => t ? fi(/* @__PURE__ */ m(w6e, { editor: e }), document.body) : null,
    [e, t]
  );
}
function W5(e) {
  const t = e.getShape();
  return {
    columns: t.toX - t.fromX + 1,
    rows: t.toY - t.fromY + 1
  };
}
function E6e() {
  const e = se();
  if (ie(e) && !e.isCollapsed() || Ct(e) && !e.anchor.is(e.focus) || !ie(e) && !Ct(e))
    return !1;
  const [t] = Cr(e.anchor);
  return t.__colSpan > 1 || t.__rowSpan > 1;
}
function Y_(e) {
  if (e.getChildrenSize() !== 1)
    return !1;
  const t = e.getFirstChildOrThrow();
  return !(!La(t) || !t.isEmpty());
}
function S6e(e) {
  const t = e.getLastDescendant();
  ce(t) ? t.select() : re(t) ? t.selectEnd() : t !== null && t.selectNext();
}
function q_(e) {
  return e.getEditorState().read(() => {
    const t = se();
    if (ie(t) || Ct(t)) {
      const [n] = Cr(t.anchor);
      if (De(n))
        return n.getBackgroundColor();
    }
    return null;
  });
}
function _6e({
  onClose: e,
  tableCellNode: t,
  setIsMenuOpen: n,
  contextRef: r,
  cellMerge: i,
  showColorPickerModal: a
}) {
  const [l] = Fe(), s = de(null), [c, d] = Q(t), [o, u] = Q({
    columns: 1,
    rows: 1
  }), [h, f] = Q(!1), [p, g] = Q(!1), [b, v] = Q(
    () => q_(l) || ""
  );
  Y(() => l.registerMutationListener(
    oo,
    (F) => {
      F.get(c.getKey()) === "updated" && (l.getEditorState().read(() => {
        d(c.getLatest());
      }), v(q_(l) || ""));
    },
    { skipInitialization: !0 }
  ), [l, c]), Y(() => {
    l.getEditorState().read(() => {
      const F = se();
      if (Ct(F)) {
        const W = W5(F);
        u(W5(F)), f(
          W.columns > 1 || W.rows > 1
        );
      }
      g(E6e());
    });
  }, [l]), Y(() => {
    const F = r.current, W = s.current, B = l.getRootElement();
    if (F != null && W != null && B != null) {
      const j = B.getBoundingClientRect(), V = F.getBoundingClientRect();
      W.style.opacity = "1";
      const q = W.getBoundingClientRect(), oe = 5;
      let Ue = V.right + oe;
      if (Ue + q.width > window.innerWidth || Ue + q.width > j.right) {
        const Pe = V.left - q.width - oe;
        Ue = (Pe < 0 ? oe : Pe) + window.pageXOffset;
      }
      W.style.left = `${Ue + window.pageXOffset}px`;
      let fe = V.top;
      if (fe + q.height > window.innerHeight) {
        const Pe = V.bottom - q.height;
        fe = (Pe < 0 ? oe : Pe) + window.pageYOffset;
      }
      W.style.top = `${fe + +window.pageYOffset}px`;
    }
  }, [r, s, l]), Y(() => {
    function F(W) {
      s.current != null && r.current != null && !s.current.contains(W.target) && !r.current.contains(W.target) && n(!1);
    }
    return window.addEventListener("click", F), () => window.removeEventListener("click", F);
  }, [n, r]);
  const U = he(() => {
    l.update(() => {
      if (c.isAttached()) {
        const W = es(c), B = l.getElementByKey(
          W.getKey()
        );
        if (!B)
          throw new Error("Expected to find tableElement in DOM");
        const j = E4(B);
        j !== null && j.clearHighlight(), W.markDirty(), d(c.getLatest());
      }
      Bt().selectStart();
    });
  }, [l, c]), y = () => {
    l.update(() => {
      const F = se();
      if (Ct(F)) {
        const { columns: W, rows: B } = W5(F), j = F.getNodes();
        let V = null;
        for (let q = 0; q < j.length; q++) {
          const oe = j[q];
          if (De(oe))
            if (V === null) {
              oe.setColSpan(W).setRowSpan(B), V = oe;
              const Ue = Y_(oe);
              let fe;
              Ue && La(fe = oe.getFirstChild()) && fe.remove();
            } else De(V) && (Y_(oe) || V.append(...oe.getChildren()), oe.remove());
        }
        V !== null && (V.getChildrenSize() === 0 && V.append(He()), S6e(V)), e();
      }
    });
  }, w = () => {
    l.update(() => {
      iz();
    });
  }, x = he(
    (F) => {
      l.update(() => {
        jC(F), e();
      });
    },
    [l, e]
  ), E = he(
    (F) => {
      l.update(() => {
        for (let W = 0; W < o.columns; W++)
          KC(F);
        e();
      });
    },
    [l, e, o.columns]
  ), S = he(() => {
    l.update(() => {
      nz(), e();
    });
  }, [l, e]), _ = he(() => {
    l.update(() => {
      es(c).remove(), U(), e();
    });
  }, [l, c, U, e]), k = he(() => {
    l.update(() => {
      rz(), e();
    });
  }, [l, e]), M = he(() => {
    l.update(() => {
      const F = es(c), W = pb(c), B = F.getChildren();
      if (W >= B.length || W < 0)
        throw new Error("Expected table cell to be inside of table row.");
      const j = B[W];
      if (!Vn(j))
        throw new Error("Expected table row");
      const V = c.getHeaderStyles() ^ an.ROW;
      j.getChildren().forEach((q) => {
        if (!De(q))
          throw new Error("Expected table cell");
        q.setHeaderStyles(V, an.ROW);
      }), U(), e();
    });
  }, [l, c, U, e]), A = he(() => {
    l.update(() => {
      const F = es(c), W = GC(c), B = F.getChildren(), j = Math.max(
        ...B.map((q) => q.getChildren().length)
      );
      if (W >= j || W < 0)
        throw new Error("Expected table cell to be inside of table row.");
      const V = c.getHeaderStyles() ^ an.COLUMN;
      for (let q = 0; q < B.length; q++) {
        const oe = B[q];
        if (!Vn(oe))
          throw new Error("Expected table row");
        const Ue = oe.getChildren();
        if (W >= Ue.length)
          continue;
        const fe = Ue[W];
        if (!De(fe))
          throw new Error("Expected table cell");
        fe.setHeaderStyles(V, an.COLUMN);
      }
      U(), e();
    });
  }, [l, c, U, e]), L = he(() => {
    l.update(() => {
      if (c.isAttached()) {
        const F = es(c);
        F && F.setRowStriping(!F.getRowStriping());
      }
      U(), e();
    });
  }, [l, c, U, e]), R = he(
    (F) => {
      l.update(() => {
        const W = se();
        if (ie(W) || Ct(W)) {
          const [B] = Cr(W.anchor);
          if (De(B) && B.setBackgroundColor(F), Ct(W)) {
            const j = W.getNodes();
            for (let V = 0; V < j.length; V++) {
              const q = j[V];
              De(q) && q.setBackgroundColor(F);
            }
          }
        }
      });
    },
    [l]
  );
  let z = null;
  return i && (h ? z = /* @__PURE__ */ m(
    "button",
    {
      type: "button",
      className: "item",
      onClick: () => y(),
      "data-test-id": "table-merge-cells",
      children: "Merge cells"
    }
  ) : p && (z = /* @__PURE__ */ m(
    "button",
    {
      type: "button",
      className: "item",
      onClick: () => w(),
      "data-test-id": "table-unmerge-cells",
      children: "Unmerge cells"
    }
  ))), fi(
    /* @__PURE__ */ D(
      "div",
      {
        className: "doc-editor-dropdown",
        ref: s,
        onClick: (F) => {
          F.stopPropagation();
        },
        children: [
          z,
          /* @__PURE__ */ m(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => a("Cell background color", () => /* @__PURE__ */ m(
                pT,
                {
                  color: b,
                  onChange: R
                }
              )),
              "data-test-id": "table-background-color",
              children: /* @__PURE__ */ m("span", { className: "text", children: "Background color" })
            }
          ),
          /* @__PURE__ */ m(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => L(),
              "data-test-id": "table-row-striping",
              children: /* @__PURE__ */ m("span", { className: "text", children: "Toggle Row Striping" })
            }
          ),
          /* @__PURE__ */ m("hr", {}),
          /* @__PURE__ */ m(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => x(!1),
              "data-test-id": "table-insert-row-above",
              children: /* @__PURE__ */ D("span", { className: "text", children: [
                "Insert",
                " ",
                o.rows === 1 ? "row" : `${o.rows} rows`,
                " ",
                "above"
              ] })
            }
          ),
          /* @__PURE__ */ m(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => x(!0),
              "data-test-id": "table-insert-row-below",
              children: /* @__PURE__ */ D("span", { className: "text", children: [
                "Insert",
                " ",
                o.rows === 1 ? "row" : `${o.rows} rows`,
                " ",
                "below"
              ] })
            }
          ),
          /* @__PURE__ */ m("hr", {}),
          /* @__PURE__ */ m(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => E(!1),
              "data-test-id": "table-insert-column-before",
              children: /* @__PURE__ */ D("span", { className: "text", children: [
                "Insert",
                " ",
                o.columns === 1 ? "column" : `${o.columns} columns`,
                " ",
                "left"
              ] })
            }
          ),
          /* @__PURE__ */ m(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => E(!0),
              "data-test-id": "table-insert-column-after",
              children: /* @__PURE__ */ D("span", { className: "text", children: [
                "Insert",
                " ",
                o.columns === 1 ? "column" : `${o.columns} columns`,
                " ",
                "right"
              ] })
            }
          ),
          /* @__PURE__ */ m("hr", {}),
          /* @__PURE__ */ m(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => k(),
              "data-test-id": "table-delete-columns",
              children: /* @__PURE__ */ m("span", { className: "text", children: "Delete column" })
            }
          ),
          /* @__PURE__ */ m(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => S(),
              "data-test-id": "table-delete-rows",
              children: /* @__PURE__ */ m("span", { className: "text", children: "Delete row" })
            }
          ),
          /* @__PURE__ */ m(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => _(),
              "data-test-id": "table-delete",
              children: /* @__PURE__ */ m("span", { className: "text", children: "Delete table" })
            }
          ),
          /* @__PURE__ */ m("hr", {}),
          /* @__PURE__ */ m(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => M(),
              children: /* @__PURE__ */ D("span", { className: "text", children: [
                (c.__headerState & an.ROW) === an.ROW ? "Remove" : "Add",
                " ",
                "row header"
              ] })
            }
          ),
          /* @__PURE__ */ m(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => A(),
              "data-test-id": "table-column-header",
              children: /* @__PURE__ */ D("span", { className: "text", children: [
                (c.__headerState & an.COLUMN) === an.COLUMN ? "Remove" : "Add",
                " ",
                "column header"
              ] })
            }
          )
        ]
      }
    ),
    document.body
  );
}
function k6e({
  anchorElem: e,
  cellMerge: t
}) {
  const [n] = Fe(), r = de(null), i = de(null), [a, l] = Q(!1), [s, c] = Q(
    null
  ), [d, o] = zg(), u = he(() => {
    const f = r.current, p = se(), g = window.getSelection(), b = document.activeElement;
    if (p == null || f == null) {
      c(null);
      return;
    }
    const v = n.getRootElement();
    if (ie(p) && v !== null && g !== null && v.contains(g.anchorNode)) {
      const U = tz(
        p.anchor.getNode()
      );
      if (U == null) {
        c(null);
        return;
      }
      if (n.getElementByKey(
        U.getKey()
      ) == null) {
        c(null);
        return;
      }
      c(U);
    } else b || c(null);
  }, [n]);
  Y(() => n.registerUpdateListener(() => {
    n.getEditorState().read(() => {
      u();
    });
  })), Y(() => {
    const f = r.current;
    if (f != null && s != null) {
      const p = n.getElementByKey(s.getKey());
      if (p != null) {
        const g = p.getBoundingClientRect(), b = f.getBoundingClientRect(), v = e.getBoundingClientRect(), U = g.top - v.top + 4, y = g.right - b.width - 10 - v.left;
        f.style.opacity = "1", f.style.transform = `translate(${y}px, ${U}px)`;
      } else
        f.style.opacity = "0", f.style.transform = "translate(-10000px, -10000px)";
    }
  }, [r, s, n, e]);
  const h = de(s);
  return Y(() => {
    h.current !== s && l(!1), h.current = s;
  }, [h, s]), /* @__PURE__ */ m("div", { className: "table-cell-action-button-container", ref: r, children: s != null && /* @__PURE__ */ D(ge, { children: [
    /* @__PURE__ */ m(
      "button",
      {
        type: "button",
        className: "table-cell-action-button chevron-down",
        onClick: (f) => {
          f.stopPropagation(), l(!a);
        },
        ref: i,
        children: /* @__PURE__ */ m("i", { className: "doc-editor-icon chevron-down" })
      }
    ),
    d,
    a && /* @__PURE__ */ m(
      _6e,
      {
        contextRef: i,
        setIsMenuOpen: l,
        onClose: () => l(!1),
        tableCellNode: s,
        cellMerge: t,
        showColorPickerModal: o
      }
    )
  ] }) });
}
function C6e({
  anchorElem: e = document.body,
  cellMerge: t = !1
}) {
  const n = Df();
  return fi(
    n ? /* @__PURE__ */ m(
      k6e,
      {
        anchorElem: e,
        cellMerge: t
      }
    ) : null,
    e
  );
}
const Z_ = [
  "image/",
  "image/heic",
  "image/heif",
  "image/gif",
  "image/webp"
];
function M6e() {
  const [e] = Fe();
  return Y(() => e.registerCommand(
    y4,
    (t) => ((async () => {
      const n = await nF(
        t,
        [Z_].flatMap((r) => r)
      );
      for (const { file: r, result: i } of n)
        bC(r, Z_) && e.dispatchCommand(Lf, {
          altText: r.name,
          src: i
        });
    })(), !0),
    ot
  ), [e]), null;
}
class T6e extends v9 {
  constructor(n, r, i) {
    super(n);
    Ne(this, "title");
    Ne(this, "emoji");
    Ne(this, "keywords");
    this.title = n, this.emoji = r, this.keywords = i.keywords || [];
  }
}
function I6e({
  index: e,
  isSelected: t,
  onClick: n,
  onMouseEnter: r,
  option: i
}) {
  let a = "item";
  return t && (a += " selected"), /* @__PURE__ */ m(
    "li",
    {
      tabIndex: -1,
      className: a,
      ref: i.setRefElement,
      role: "option",
      "aria-selected": t,
      id: "typeahead-item-" + e,
      onMouseEnter: r,
      onClick: n,
      children: /* @__PURE__ */ D("span", { className: "text", children: [
        i.emoji,
        " ",
        i.title
      ] })
    },
    i.key
  );
}
const A6e = 10;
function N6e() {
  const [e] = Fe(), [t, n] = Q(null), [r, i] = Q([]);
  Y(() => {
    import("./emoji-list-CKk-PE96.js").then((d) => i(d.default));
  }, []);
  const a = Ke(
    () => r != null ? r.map(
      ({ emoji: d, aliases: o, tags: u }) => new T6e(o[0], d, {
        keywords: [...o, ...u]
      })
    ) : [],
    [r]
  ), l = y9(":", {
    minLength: 0
  }), s = Ke(() => a.filter((d) => t != null ? new RegExp(t, "gi").exec(d.title) || d.keywords != null ? d.keywords.some(
    (o) => new RegExp(t, "gi").exec(o)
  ) : !1 : a).slice(0, A6e), [a, t]), c = he(
    (d, o, u) => {
      e.update(() => {
        const h = se();
        !ie(h) || d == null || (o && o.remove(), h.insertNodes([un(d.emoji)]), u());
      });
    },
    [e]
  );
  return /* @__PURE__ */ m(
    w9,
    {
      onQueryChange: n,
      onSelectOption: c,
      triggerFn: l,
      options: s,
      menuRenderFn: (d, { selectedIndex: o, selectOptionAndCleanUp: u, setHighlightedIndex: h }) => d.current == null || s.length === 0 ? null : d.current && s.length ? _c.createPortal(
        /* @__PURE__ */ m("div", { className: "doc-editor-typeahead-popover emoji-menu", children: /* @__PURE__ */ m("ul", { children: s.map((f, p) => /* @__PURE__ */ m("div", { children: /* @__PURE__ */ m(
          I6e,
          {
            index: p,
            isSelected: o === p,
            onClick: () => {
              h(p), u(f);
            },
            onMouseEnter: () => {
              h(p);
            },
            option: f
          }
        ) }, f.key)) }) }),
        d.current
      ) : null
    }
  );
}
function X5(e) {
  return e instanceof HTMLElement;
}
class vO {
  constructor(t, n) {
    Ne(this, "_x");
    Ne(this, "_y");
    this._x = t, this._y = n;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  equals({ x: t, y: n }) {
    return this.x === t && this.y === n;
  }
  calcDeltaXTo({ x: t }) {
    return this.x - t;
  }
  calcDeltaYTo({ y: t }) {
    return this.y - t;
  }
  calcHorizontalDistanceTo(t) {
    return Math.abs(this.calcDeltaXTo(t));
  }
  calcVerticalDistance(t) {
    return Math.abs(this.calcDeltaYTo(t));
  }
  calcDistanceTo(t) {
    return Math.sqrt(
      Math.pow(this.calcDeltaXTo(t), 2) + Math.pow(this.calcDeltaYTo(t), 2)
    );
  }
}
function D6e(e) {
  return e instanceof vO;
}
class sc {
  constructor(t, n, r, i) {
    Ne(this, "_left");
    Ne(this, "_top");
    Ne(this, "_right");
    Ne(this, "_bottom");
    const [a, l] = n <= i ? [n, i] : [i, n], [s, c] = t <= r ? [t, r] : [r, t];
    this._top = a, this._right = c, this._left = s, this._bottom = l;
  }
  get top() {
    return this._top;
  }
  get right() {
    return this._right;
  }
  get bottom() {
    return this._bottom;
  }
  get left() {
    return this._left;
  }
  get width() {
    return Math.abs(this._left - this._right);
  }
  get height() {
    return Math.abs(this._bottom - this._top);
  }
  equals({ top: t, left: n, bottom: r, right: i }) {
    return t === this._top && r === this._bottom && n === this._left && i === this._right;
  }
  contains(t) {
    if (D6e(t)) {
      const { x: n, y: r } = t, i = r < this._top, a = r > this._bottom, l = n < this._left, s = n > this._right;
      return {
        reason: {
          isOnBottomSide: a,
          isOnLeftSide: l,
          isOnRightSide: s,
          isOnTopSide: i
        },
        result: !i && !a && !l && !s
      };
    } else {
      const { top: n, left: r, bottom: i, right: a } = t;
      return n >= this._top && n <= this._bottom && i >= this._top && i <= this._bottom && r >= this._left && r <= this._right && a >= this._left && a <= this._right;
    }
  }
  intersectsWith(t) {
    const { left: n, top: r, width: i, height: a } = t, { left: l, top: s, width: c, height: d } = this, o = n + i >= l + c ? n + i : l + c, u = r + a >= s + d ? r + a : s + d, h = n <= l ? n : l, f = r <= s ? r : s;
    return o - h <= i + c && u - f <= a + d;
  }
  generateNewRect({
    left: t = this.left,
    top: n = this.top,
    right: r = this.right,
    bottom: i = this.bottom
  }) {
    return new sc(t, n, r, i);
  }
  static fromLTRB(t, n, r, i) {
    return new sc(t, n, r, i);
  }
  static fromLWTH(t, n, r, i) {
    return new sc(t, r, t + n, r + i);
  }
  static fromPoints(t, n) {
    const { y: r, x: i } = t, { y: a, x: l } = n;
    return sc.fromLTRB(i, r, l, a);
  }
  static fromDOM(t) {
    const { top: n, width: r, left: i, height: a } = t.getBoundingClientRect();
    return sc.fromLWTH(i, r, n, a);
  }
}
const U3 = 4, L6e = 2, R6e = "draggable-block-menu", J_ = "application/x-lexical-drag-block", Q_ = 28, P6e = 1, O6e = -1, ek = 0;
let Rp = 1 / 0;
function $6e(e) {
  return e === 0 ? 1 / 0 : Rp >= 0 && Rp < e ? Rp : Math.floor(e / 2);
}
function F6e(e) {
  return e.getEditorState().read(() => Bt().getChildrenKeys());
}
function yO(e) {
  const t = (c, d) => c ? parseFloat(window.getComputedStyle(c)[d]) : 0, { marginTop: n, marginBottom: r } = window.getComputedStyle(e), i = t(
    e.previousElementSibling,
    "marginBottom"
  ), a = t(
    e.nextElementSibling,
    "marginTop"
  ), l = Math.max(
    parseFloat(n),
    i
  );
  return { marginBottom: Math.max(
    parseFloat(r),
    a
  ), marginTop: l };
}
function V5(e, t, n, r = !1) {
  const i = e.getBoundingClientRect(), a = F6e(t);
  let l = null;
  return t.getEditorState().read(() => {
    if (r) {
      const [d, o] = [
        t.getElementByKey(a[0]),
        t.getElementByKey(a[a.length - 1])
      ], [u, h] = [
        d == null ? void 0 : d.getBoundingClientRect(),
        o == null ? void 0 : o.getBoundingClientRect()
      ];
      if (u && h && (n.y < u.top ? l = d : n.y > h.bottom && (l = o), l))
        return;
    }
    let s = $6e(a.length), c = ek;
    for (; s >= 0 && s < a.length; ) {
      const d = a[s], o = t.getElementByKey(d);
      if (o === null)
        break;
      const u = new vO(n.x, n.y), h = sc.fromDOM(o), { marginTop: f, marginBottom: p } = yO(o), g = h.generateNewRect({
        bottom: h.bottom + p,
        left: i.left,
        right: i.right,
        top: h.top - f
      }), {
        result: b,
        reason: { isOnTopSide: v, isOnBottomSide: U }
      } = g.contains(u);
      if (b) {
        l = o, Rp = s;
        break;
      }
      c === ek && (v ? c = O6e : U ? c = P6e : c = 1 / 0), s += c;
    }
  }), l;
}
function z6e(e) {
  return !!e.closest(`.${R6e}`);
}
function B6e(e, t, n) {
  if (!e) {
    t.style.opacity = "0", t.style.transform = "translate(-10000px, -10000px)";
    return;
  }
  const r = e.getBoundingClientRect(), i = window.getComputedStyle(e), a = t.getBoundingClientRect(), l = n.getBoundingClientRect(), s = r.top + (parseInt(i.lineHeight, 10) - a.height) / 2 - l.top, c = U3;
  t.style.opacity = "1", t.style.transform = `translate(${c}px, ${s}px)`;
}
function H6e(e, t) {
  const { transform: n } = t.style;
  t.style.transform = "translateZ(0)", e.setDragImage(t, 0, 0), setTimeout(() => {
    t.style.transform = n;
  });
}
function W6e(e, t, n, r) {
  const { top: i, height: a } = t.getBoundingClientRect(), { top: l, width: s } = r.getBoundingClientRect(), { marginTop: c, marginBottom: d } = yO(t);
  let o = i;
  n >= i ? o += a + d / 2 : o -= c / 2;
  const u = o - l - L6e, h = Q_ - U3;
  e.style.transform = `translate(${h}px, ${u}px)`, e.style.width = `${s - (Q_ - U3) * 2}px`, e.style.opacity = ".4";
}
function X6e(e) {
  e && (e.style.opacity = "0", e.style.transform = "translate(-10000px, -10000px)");
}
function V6e(e, t, n) {
  const r = t.parentElement, i = de(null), a = de(null), l = de(!1), [s, c] = Q(null);
  Y(() => {
    function u(f) {
      const p = f.target;
      if (!X5(p)) {
        c(null);
        return;
      }
      if (z6e(p))
        return;
      const g = V5(t, e, f);
      c(g);
    }
    function h() {
      c(null);
    }
    return r == null || r.addEventListener("mousemove", u), r == null || r.addEventListener("mouseleave", h), () => {
      r == null || r.removeEventListener("mousemove", u), r == null || r.removeEventListener("mouseleave", h);
    };
  }, [r, t, e]), Y(() => {
    i.current && B6e(s, i.current, t);
  }, [t, s]), Y(() => {
    function u(f) {
      if (!l.current)
        return !1;
      const [p] = Ld(f);
      if (p)
        return !1;
      const { pageY: g, target: b } = f;
      if (!X5(b))
        return !1;
      const v = V5(t, e, f, !0), U = a.current;
      return v === null || U === null ? !1 : (W6e(U, v, g, t), f.preventDefault(), !0);
    }
    function h(f) {
      if (!l.current)
        return !1;
      const [p] = Ld(f);
      if (p)
        return !1;
      const { target: g, dataTransfer: b, pageY: v } = f, U = (b == null ? void 0 : b.getData(J_)) || "", y = Rt(U);
      if (!y || !X5(g))
        return !1;
      const w = V5(t, e, f, !0);
      if (!w)
        return !1;
      const x = on(w);
      if (!x)
        return !1;
      if (x === y)
        return !0;
      const E = w.getBoundingClientRect().top;
      return v >= E ? x.insertAfter(y) : x.insertBefore(y), c(null), !0;
    }
    return Pt(
      e.registerCommand(
        bf,
        (f) => u(f),
        ot
      ),
      e.registerCommand(
        gf,
        (f) => h(f),
        vi
      )
    );
  }, [t, e]);
  function d(u) {
    const h = u.dataTransfer;
    if (!h || !s)
      return;
    H6e(h, s);
    let f = "";
    e.update(() => {
      const p = on(s);
      p && (f = p.getKey());
    }), l.current = !0, h.setData(J_, f);
  }
  function o() {
    l.current = !1, X6e(a.current);
  }
  return fi(
    /* @__PURE__ */ D(ge, { children: [
      /* @__PURE__ */ m(
        "div",
        {
          className: "doc-editor-icon draggable-block-menu",
          ref: i,
          draggable: !0,
          onDragStart: d,
          onDragEnd: o,
          children: /* @__PURE__ */ m("div", { className: n ? "doc-editor-icon" : "" })
        }
      ),
      /* @__PURE__ */ m("div", { className: "draggable-block-target-line", ref: a })
    ] }),
    t
  );
}
function G6e({
  anchorElem: e = document.body
}) {
  const [t] = Fe();
  return V6e(t, e, t._editable);
}
const j6e = xn(), K6e = `\\.,\\+\\*\\?\\$\\@\\|#{}\\(\\)\\^\\-\\[\\]\\\\/!%'"~=<>_:;`, Y6e = {
  PUNCTUATION: K6e
}, wO = Y6e.PUNCTUATION, x9 = ["=\\$a", "=\\$i", "=\\$f"].join("|"), G5 = "=$a", q6e = "=$i", Z6e = "=$f", xO = "^(" + x9 + ")\\s|[^" + wO + "\\s]", J6e = "(?:\\.[ |$]| |[" + wO + "]|)", Q6e = 75, e5e = new RegExp(
  "((" + x9 + ")((?:" + xO + J6e + "){0," + Q6e + "}))"
), t5e = 50, n5e = new RegExp(
  "((" + x9 + ")((?:" + xO + "){0," + t5e + "}))"
), r5e = [
  {
    inputField: {
      label: "入力フィールドを追加",
      value: null
    }
  }
], j5 = /* @__PURE__ */ new Map(), i5e = {
  search(e, t, n) {
    setTimeout(() => {
      const r = t.filter(
        (i) => Object.keys(i).filter((a) => i[a].label.toLowerCase().includes(e.toLowerCase())).length > 0
      );
      n(r);
    }, 300);
  }
};
function a5e(e, t, n = "") {
  const [r, i] = Q([]);
  return Y(() => {
    const a = j5.get(n + e);
    if (e == null) {
      i([]);
      return;
    }
    if (a !== null) {
      if (a !== void 0) {
        i(a);
        return;
      }
      j5.set(n + e, null), i5e.search(e, t, (l) => {
        j5.set(n + e, l), i(l);
      });
    }
  }, [e, t, n]), r;
}
function l5e(e, t) {
  let n = e5e.exec(e);
  if (n === null && (n = n5e.exec(e)), n !== null) {
    const r = n[3];
    if (r.length >= t)
      return {
        leadOffset: n.index,
        matchingString: r,
        // Use the extracted part for searching
        replaceableString: n[0]
        // The entire matched string including trigger
      };
  }
  return null;
}
function s5e(e) {
  return l5e(e, 0);
}
class o5e extends v9 {
  constructor(n, r, i, a, l = !1, s = !1) {
    super(n + i);
    Ne(this, "dataMention");
    Ne(this, "fieldName");
    Ne(this, "label");
    Ne(this, "data");
    Ne(this, "isMan");
    Ne(this, "isNumber");
    this.dataMention = n, this.fieldName = r, this.label = i, this.data = a, this.isMan = l, this.isNumber = s;
  }
}
function c5e({
  index: e,
  isSelected: t,
  onClick: n,
  onMouseEnter: r,
  option: i
}) {
  let a = "item";
  return t && (a += " selected"), /* @__PURE__ */ m(
    "li",
    {
      tabIndex: -1,
      className: a,
      ref: i.setRefElement,
      role: "option",
      "aria-selected": t,
      id: "typeahead-item-" + e,
      onMouseEnter: r,
      onClick: n,
      children: /* @__PURE__ */ m("span", { className: "text", children: i.label })
    },
    i.key
  );
}
function d5e({
  step: e,
  autoData: t,
  afterAutoData: n
}) {
  const [r] = Fe(), [i, a] = Q(null), [l, s] = Q(), [c, d] = Q(), [o, u] = Q(!1), [h, f] = Q(null), g = a5e(i, l === G5 ? t : l === Z6e ? n : r5e, l), b = y9("/", {
    minLength: 0
  }), v = Ke(
    () => g.map(
      (w) => {
        const x = Object.keys(w)[0];
        return new o5e(l === G5 ? "auto" : "after-auto", x, w[x].label, w[x].value, w[x].isMan, w[x].isNumber);
      }
    ),
    [g]
  ), U = he(
    (w, x, E) => {
      r.update(() => {
        let S = w.data;
        w.isMan && typeof S == "number" && S && (S = 1e4 * S), w.isNumber && S && (S = S.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ","));
        const _ = Zb(
          {
            dataMention: l === G5 ? "auto" : l == q6e ? "input" : "after-auto",
            fieldName: w.fieldName,
            label: w.label,
            data: S,
            format: x == null ? void 0 : x.getFormat(),
            style: x == null ? void 0 : x.getStyle()
          }
        );
        w.fieldName === "inputField" && (u(!0), f(_), E()), x && x.replace(_), E();
      });
    },
    [r, l]
  ), y = he(
    (w) => {
      if (b(w, r) !== null)
        return null;
      const E = s5e(w);
      return E !== null && s(E.replaceableString.replace(E.matchingString, "")), E;
    },
    [b, r]
  );
  return Y(() => {
    if (!r.hasNodes([wo]))
      throw new Error("DataMentionPlugin: DataMentionNode not registered on editor");
    const w = () => {
      r.update(() => {
        b$(wo).forEach((E) => {
          if (E.__dataMention === "auto" && E.__step === 2 || E.__dataMention === "after-auto" && E.__step === 3) {
            let S;
            if (E.__dataMention === "auto" ? S = t.find((_) => _[E.__fieldName] && _[E.__fieldName].label === E.__label) : S = n.find((_) => _[E.__fieldName] && _[E.__fieldName].label === E.__label), S) {
              const _ = S[E.__fieldName];
              let k = _.value;
              k && _.isMan && (k = parseInt(k.toString()) * 1e4), k && _.isNumber && (k = k.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")), E.setData(k);
            }
          }
        });
      });
    };
    return w(), Pt(
      r.registerCommand(
        j6e,
        () => e === 2 || e === 3 ? (w(), !0) : !1,
        it
      )
    );
  }, [r]), /* @__PURE__ */ D(ge, { children: [
    /* @__PURE__ */ m(
      w9,
      {
        onQueryChange: a,
        onSelectOption: U,
        triggerFn: y,
        options: v,
        menuRenderFn: (w, { selectedIndex: x, selectOptionAndCleanUp: E, setHighlightedIndex: S }) => w.current && g.length ? _c.createPortal(
          /* @__PURE__ */ m("div", { className: "doc-editor-typeahead-popover mentions-menu", children: /* @__PURE__ */ m("ul", { children: v.map((_, k) => /* @__PURE__ */ m(
            c5e,
            {
              index: k,
              isSelected: x === k,
              onClick: () => {
                S(k), E(_);
              },
              onMouseEnter: () => {
                S(k);
              },
              option: _
            },
            _.key
          )) }) }),
          w.current
        ) : null
      }
    ),
    o && h && _c.createPortal(
      /* @__PURE__ */ D("div", { className: "doc-editor-typeahead-popover data-mention-input-menu", children: [
        /* @__PURE__ */ m(
          "input",
          {
            placeholder: "Enter label of input field",
            value: c || "",
            type: "text",
            onChange: (w) => {
              d(w.target.value);
            }
          }
        ),
        /* @__PURE__ */ m(
          "button",
          {
            type: "button",
            onClick: () => {
              r.update(() => {
                h == null || h.setLabel(c || ""), u(!1), f(null), d("");
              });
            },
            children: "Save"
          }
        )
      ] }),
      document.body
    )
  ] });
}
var u5e = typeof global == "object" && global && global.Object === Object && global, h5e = typeof self == "object" && self && self.Object === Object && self, EO = u5e || h5e || Function("return this")(), ig = EO.Symbol, SO = Object.prototype, f5e = SO.hasOwnProperty, p5e = SO.toString, Lu = ig ? ig.toStringTag : void 0;
function m5e(e) {
  var t = f5e.call(e, Lu), n = e[Lu];
  try {
    e[Lu] = void 0;
    var r = !0;
  } catch {
  }
  var i = p5e.call(e);
  return r && (t ? e[Lu] = n : delete e[Lu]), i;
}
var g5e = Object.prototype, b5e = g5e.toString;
function U5e(e) {
  return b5e.call(e);
}
var v5e = "[object Null]", y5e = "[object Undefined]", tk = ig ? ig.toStringTag : void 0;
function w5e(e) {
  return e == null ? e === void 0 ? y5e : v5e : tk && tk in Object(e) ? m5e(e) : U5e(e);
}
function x5e(e) {
  return e != null && typeof e == "object";
}
var E5e = "[object Symbol]";
function S5e(e) {
  return typeof e == "symbol" || x5e(e) && w5e(e) == E5e;
}
var _5e = /\s/;
function k5e(e) {
  for (var t = e.length; t-- && _5e.test(e.charAt(t)); )
    ;
  return t;
}
var C5e = /^\s+/;
function M5e(e) {
  return e && e.slice(0, k5e(e) + 1).replace(C5e, "");
}
function v3(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var nk = NaN, T5e = /^[-+]0x[0-9a-f]+$/i, I5e = /^0b[01]+$/i, A5e = /^0o[0-7]+$/i, N5e = parseInt;
function rk(e) {
  if (typeof e == "number")
    return e;
  if (S5e(e))
    return nk;
  if (v3(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = v3(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = M5e(e);
  var n = I5e.test(e);
  return n || A5e.test(e) ? N5e(e.slice(2), n ? 2 : 8) : T5e.test(e) ? nk : +e;
}
var K5 = function() {
  return EO.Date.now();
}, D5e = "Expected a function", L5e = Math.max, R5e = Math.min;
function P5e(e, t, n) {
  var r, i, a, l, s, c, d = 0, o = !1, u = !1, h = !0;
  if (typeof e != "function")
    throw new TypeError(D5e);
  t = rk(t) || 0, v3(n) && (o = !!n.leading, u = "maxWait" in n, a = u ? L5e(rk(n.maxWait) || 0, t) : a, h = "trailing" in n ? !!n.trailing : h);
  function f(E) {
    var S = r, _ = i;
    return r = i = void 0, d = E, l = e.apply(_, S), l;
  }
  function p(E) {
    return d = E, s = setTimeout(v, t), o ? f(E) : l;
  }
  function g(E) {
    var S = E - c, _ = E - d, k = t - S;
    return u ? R5e(k, a - _) : k;
  }
  function b(E) {
    var S = E - c, _ = E - d;
    return c === void 0 || S >= t || S < 0 || u && _ >= a;
  }
  function v() {
    var E = K5();
    if (b(E))
      return U(E);
    s = setTimeout(v, g(E));
  }
  function U(E) {
    return s = void 0, h && r ? f(E) : (r = i = void 0, l);
  }
  function y() {
    s !== void 0 && clearTimeout(s), d = 0, r = c = i = s = void 0;
  }
  function w() {
    return s === void 0 ? l : U(K5());
  }
  function x() {
    var E = K5(), S = b(E);
    if (r = arguments, i = this, c = E, S) {
      if (s === void 0)
        return p(c);
      if (u)
        return clearTimeout(s), s = setTimeout(v, t), f(c);
    }
    return s === void 0 && (s = setTimeout(v, t)), l;
  }
  return x.cancel = y, x.flush = w, x;
}
function O5e(e, t, n) {
  const r = de(null);
  return r.current = e, Ke(
    () => P5e(
      (...i) => {
        r.current && r.current(...i);
      },
      t,
      { maxWait: n }
    ),
    [t, n]
  );
}
const ik = 20;
function $5e({
  anchorElem: e
}) {
  const [t] = Fe(), n = Df(), [r, i] = Q(!1), [a, l] = Q(!1), [s, c] = Q(!1), [d, o] = Q({}), u = de(/* @__PURE__ */ new Set()), h = de(null), f = O5e(
    (b) => {
      const { isOutside: v, tableDOMNode: U } = F5e(b);
      if (v) {
        i(!1), l(!1);
        return;
      }
      if (!U)
        return;
      h.current = U;
      let y = null, w = null, x = null;
      if (t.update(() => {
        var S;
        const E = on(U);
        if (De(E)) {
          const _ = Xe(
            E,
            (k) => fn(k)
          );
          if (!fn(_))
            return;
          if (x = t.getElementByKey(_ == null ? void 0 : _.getKey()), x) {
            const k = _.getChildrenSize(), M = (S = _.getChildAtIndex(0)) == null ? void 0 : S.getChildrenSize(), A = pb(E), L = GC(E);
            A === k - 1 ? y = E : L === M - 1 && (w = E);
          }
        }
      }), x) {
        const {
          width: E,
          y: S,
          right: _,
          left: k,
          bottom: M,
          height: A
        } = x.getBoundingClientRect(), { y: L, left: R } = e.getBoundingClientRect();
        y ? (l(!1), i(!0), o({
          height: ik,
          left: k - R,
          top: M - L + 5,
          width: E
        })) : w && (l(!0), i(!1), o({
          height: A,
          left: _ - R + 5,
          top: S - L,
          width: ik
        }));
      }
    },
    50,
    250
  ), p = Ke(() => new ResizeObserver(() => {
    i(!1), l(!1);
  }), []);
  Y(() => {
    if (s)
      return document.addEventListener("mousemove", f), () => {
        i(!1), l(!1), f.cancel(), document.removeEventListener("mousemove", f);
      };
  }, [s, f]), Y(() => Pt(
    t.registerMutationListener(
      co,
      (b) => {
        t.getEditorState().read(() => {
          for (const [v, U] of b) {
            const y = t.getElementByKey(v);
            switch (U) {
              case "created":
                u.current.add(v), c(u.current.size > 0), y && p.observe(y);
                break;
              case "destroyed":
                u.current.delete(v), c(u.current.size > 0), p.disconnect(), u.current.forEach((w) => {
                  const x = t.getElementByKey(w);
                  x && p.observe(x);
                });
                break;
            }
          }
        });
      },
      { skipInitialization: !1 }
    )
  ), [t, p]);
  const g = (b) => {
    t.update(() => {
      if (h.current) {
        const v = on(
          h.current
        );
        v == null || v.selectEnd(), b ? (jC(), i(!1)) : (KC(), l(!1));
      }
    });
  };
  return n ? /* @__PURE__ */ D(ge, { children: [
    r && /* @__PURE__ */ m(
      "button",
      {
        type: "button",
        className: "et_table-add-rows",
        style: { ...d },
        onClick: () => g(!0)
      }
    ),
    a && /* @__PURE__ */ m(
      "button",
      {
        type: "button",
        className: "et_table-add-columns",
        style: { ...d },
        onClick: () => g(!1)
      }
    )
  ] }) : null;
}
function F5e(e) {
  const t = e.target;
  if (t && t instanceof HTMLElement) {
    const n = t.closest(
      "td.et_table-cell, th.et_table-cell"
    );
    return { isOutside: !(n || t.closest(
      "button.et_table-add-rows"
    ) || t.closest(
      "button.et_table-add-columns"
    ) || t.closest("div.TableCellResizer__resizer")), tableDOMNode: n };
  } else
    return { isOutside: !0, tableDOMNode: null };
}
function z5e({
  anchorElem: e = document.body
}) {
  return Df() ? fi(
    /* @__PURE__ */ m($5e, { anchorElem: e }),
    e
  ) : null;
}
function E9(e) {
  return [e.getKey(), e.getTextContent(), e.getTag()];
}
function B5e(e, t, n) {
  if (t === null) return n;
  const r = E9(t);
  let i = [];
  if (e === null) {
    if (n.length > 0 && n[0][0] === t.__key) return n;
    i = [r, ...n];
  } else for (let a = 0; a < n.length; a++) {
    const l = n[a][0];
    if (i.push(n[a]), l === e.getKey() && l !== t.getKey()) {
      if (a + 1 < n.length && n[a + 1][0] === t.__key) return n;
      i.push(r);
    }
  }
  return i;
}
function H5e(e, t) {
  const n = [];
  for (const r of t) r[0] !== e && n.push(r);
  return n;
}
function W5e(e, t) {
  const n = [];
  for (const r of t) r[0] === e.getKey() ? n.push(E9(e)) : n.push(r);
  return n;
}
function ak(e, t, n) {
  const r = [], i = E9(t);
  e || r.push(i);
  for (const a of n) a[0] !== t.getKey() && (r.push(a), e && a[0] === e.getKey() && r.push(i));
  return r;
}
function Y5(e) {
  let t = cv(e);
  for (; t !== null && !Kd(t); ) t = cv(t);
  return t;
}
function X5e({ children: e }) {
  const [t, n] = Q([]), [r] = Fe();
  return Y(() => {
    let i = [];
    r.getEditorState().read(() => {
      const c = (d) => {
        for (const o of d.getChildren()) Kd(o) ? i.push([o.getKey(), o.getTextContent(), o.getTag()]) : re(o) && c(o);
      };
      c(Bt()), n(i);
    });
    const a = r.registerUpdateListener(({ editorState: c, dirtyElements: d }) => {
      c.read(() => {
        const o = (u) => {
          for (const h of u.getChildren()) if (Kd(h)) {
            const f = Y5(h);
            i = ak(f, h, i), n(i);
          } else re(h) && o(h);
        };
        Bt().getChildren().forEach((u) => {
          re(u) && d.get(u.__key) && o(u);
        });
      });
    }), l = r.registerMutationListener(Tg, (c) => {
      r.getEditorState().read(() => {
        for (const [d, o] of c) if (o === "created") {
          const u = Rt(d);
          if (u !== null) {
            const h = Y5(u);
            i = B5e(h, u, i);
          }
        } else if (o === "destroyed") i = H5e(d, i);
        else if (o === "updated") {
          const u = Rt(d);
          if (u !== null) {
            const h = Y5(u);
            i = ak(h, u, i);
          }
        }
        n(i);
      });
    }, { skipInitialization: !0 }), s = r.registerMutationListener(aa, (c) => {
      r.getEditorState().read(() => {
        for (const [d, o] of c) if (o === "updated") {
          const u = Rt(d);
          if (u !== null) {
            const h = u.getParentOrThrow();
            Kd(h) && (i = W5e(h, i), n(i));
          }
        }
      });
    }, { skipInitialization: !0 });
    return () => {
      l(), s(), a();
    };
  }, [r]), e(t, r);
}
const ag = 300, _O = 9;
function V5e(e) {
  if (e === "h2")
    return "heading2";
  if (e === "h3")
    return "heading3";
}
function G5e(e) {
  const t = e == null ? void 0 : e.getClientRects()[0].y;
  return t >= ag && t <= ag + _O;
}
function Q1(e) {
  return (e == null ? void 0 : e.getClientRects()[0].y) < ag;
}
function q5(e) {
  return (e == null ? void 0 : e.getClientRects()[0].y) >= ag + _O;
}
function j5e({
  tableOfContents: e
}) {
  const [t, n] = Q(""), r = de(null), i = de(null), a = de(0), [l] = Fe(), s = de(/* @__PURE__ */ new Map());
  function c(o, u) {
    l.getEditorState().read(() => {
      const h = l.getElementByKey(o);
      h !== null && (i.current && i.current instanceof HTMLElement ? i.current.scrollTo({
        top: h.offsetTop,
        behavior: "smooth"
      }) : h.scrollIntoView({ behavior: "smooth" }), n(o), a.current = u);
    });
  }
  function d(o) {
    if (o === null)
      return [];
    const u = [];
    let h = o.parentElement;
    for (; h; ) {
      const f = window.getComputedStyle(h).overflowY, p = window.getComputedStyle(h).overflowX, g = f === "scroll" || f === "auto", b = p === "scroll" || p === "auto";
      (g && h.scrollHeight > h.clientHeight || b && h.scrollWidth > h.clientWidth) && u.push(h), h = h.parentElement;
    }
    return u;
  }
  return Y(() => {
    const o = l.getRootElement(), u = d(o);
    function h(b) {
      if (i.current = b.target, e.length !== 0 && a.current < e.length - 1) {
        let v = l.getElementByKey(
          e[a.current][0]
        );
        if (v !== null) {
          if (q5(v)) {
            for (; v !== null && q5(v) && a.current > 0; ) {
              const y = l.getElementByKey(
                e[a.current - 1][0]
              );
              y !== null && (Q1(y) || q5(y)) && a.current--, v = y;
            }
            const U = e[a.current][0];
            n(U);
          } else if (Q1(v)) {
            for (; v !== null && Q1(v) && a.current < e.length - 1; ) {
              const y = l.getElementByKey(
                e[a.current + 1][0]
              );
              y !== null && (G5e(y) || Q1(y)) && a.current++, v = y;
            }
            const U = e[a.current][0];
            n(U);
          }
        }
      } else
        a.current = 0;
    }
    let f;
    function p(b, v) {
      return (U) => {
        clearTimeout(f), f = setTimeout(() => b(U), v);
      };
    }
    function g(b) {
      const v = b.target, U = s.current.get(v) || 0;
      v.scrollTop !== U && (s.current.set(v, v.scrollTop), p(h, 50)(b));
    }
    return u.length > 0 ? u.forEach((b) => {
      s.current.set(b, b.scrollTop), b.addEventListener("scroll", g);
    }) : document.addEventListener("scroll", g), () => {
      u.length > 0 ? u.forEach((b) => {
        b.removeEventListener("scroll", g);
      }) : document.removeEventListener("scroll", g);
    };
  }, [e, l]), Y(() => {
    if (r.current) {
      const o = r.current.querySelector(
        ".selected-heading-wrapper"
      );
      o && o.scrollIntoView({
        behavior: "instant",
        block: "center"
      });
    }
  }, [t]), /* @__PURE__ */ m("div", { className: "table-of-contents", children: /* @__PURE__ */ m("ul", { className: "headings", ref: r, children: e.map(([o, u, h], f) => f === 0 ? /* @__PURE__ */ D("div", { className: "normal-heading-wrapper", children: [
    /* @__PURE__ */ m(
      "div",
      {
        className: "first-heading",
        onClick: () => c(o, f),
        role: "button",
        tabIndex: 0,
        children: ("" + u).length > 20 ? u.substring(0, 20) + "..." : u
      }
    ),
    /* @__PURE__ */ m("br", {})
  ] }, o) : /* @__PURE__ */ m(
    "div",
    {
      className: `normal-heading-wrapper ${t === o ? "selected-heading-wrapper" : ""}`,
      children: /* @__PURE__ */ m(
        "div",
        {
          onClick: () => c(o, f),
          role: "button",
          className: V5e(h),
          tabIndex: 0,
          children: /* @__PURE__ */ m(
            "li",
            {
              className: `normal-heading ${t === o ? "selected-heading" : ""}
                    `,
              children: ("" + u).length > 27 ? u.substring(0, 27) + "..." : u
            }
          )
        }
      )
    },
    o
  )) }) });
}
function K5e() {
  return /* @__PURE__ */ m(X5e, { children: (e) => /* @__PURE__ */ m(j5e, { tableOfContents: e }) });
}
const Y5e = dn((e, t) => {
  const {
    step: n,
    autoMentionData: r,
    autoAfterMentionData: i,
    onChange: a,
    imageUploadCallback: l,
    showTableOfContents: s = !1,
    ignoreSelectionChange: c = !0
  } = e, { historyState: d } = FH(), [o] = Fe(), [u, h] = Q(o), f = /* @__PURE__ */ m(rW, { children: "Enter text..." }), [p, g] = Q(!1), [b, v] = Q(null), [U, y] = Q(!1), w = (_) => {
    _ !== null && v(_);
  };
  Y(() => {
    const _ = () => {
      const k = Z0 && window.matchMedia("(max-width: 1025px)").matches;
      k !== U && y(k);
    };
    return _(), window.addEventListener("resize", _), () => {
      window.removeEventListener("resize", _);
    };
  }, [U]);
  const x = () => {
    let _ = "", k = "", M = {};
    return o.read(() => {
      const A = Bt();
      _ = Qp(o), M = o.getEditorState().toJSON(), k = A.getTextContent();
    }), { serializedEditorState: M, htmlContent: _, plainContent: k };
  }, E = (_) => {
    if (_ !== null)
      switch (typeof _) {
        case "string": {
          const k = o.parseEditorState(_);
          o.setEditorState(k, { tag: "history-merge" });
          break;
        }
        case "object": {
          o.setEditorState(_, { tag: "history-merge" });
          break;
        }
        case "function": {
          o.update(() => {
            Bt().isEmpty() && _(o);
          }, { tag: "history-merge" });
          break;
        }
      }
  };
  y3(t, () => ({
    exportData: x,
    updateEditorState: E,
    getEditor: () => o
  }));
  const S = he((_, k) => {
    a && k.read(() => {
      const M = Bt(), A = Qp(k), L = _.toJSON(), R = M.getTextContent();
      a({ htmlContent: A, plainContent: R, serializedEditorState: L });
    });
  }, [a]);
  return Bn(() => {
    if (a)
      return u.registerUpdateListener(
        ({ dirtyElements: _, dirtyLeaves: k, prevEditorState: M }) => {
          if (_.size === 0 && k.size === 0 || M.isEmpty())
            return;
          const A = o.getEditorState();
          S(A, o);
        }
      );
  }, [u, c, S, a, o]), Y(() => o.registerCommand(
    Ei,
    (_, k) => (h(k), !1),
    mr
  ), [o]), /* @__PURE__ */ D(ge, { children: [
    /* @__PURE__ */ m(w2e, { setIsLinkEditMode: g, imageUploadCallback: l }),
    /* @__PURE__ */ D("div", { className: "editor-container", children: [
      /* @__PURE__ */ m(M6e, {}),
      /* @__PURE__ */ m(QH, {}),
      /* @__PURE__ */ m(d6e, { imageUploadCallback: l }),
      /* @__PURE__ */ m(N6e, {}),
      /* @__PURE__ */ m(g2e, {}),
      /* @__PURE__ */ m(d5e, { step: n, autoData: r, afterAutoData: i }),
      /* @__PURE__ */ m(n6e, {}),
      /* @__PURE__ */ m(J2e, {}),
      /* @__PURE__ */ m(OH, { externalHistoryState: d }),
      /* @__PURE__ */ m(j2e, {}),
      /* @__PURE__ */ m(
        YH,
        {
          contentEditable: /* @__PURE__ */ m("div", { className: "editor-scroller", children: /* @__PURE__ */ m("div", { className: "editor", ref: w, children: /* @__PURE__ */ m(cW, {}) }) }),
          placeholder: f,
          ErrorBoundary: JH
        }
      ),
      /* @__PURE__ */ m(x2e, {}),
      /* @__PURE__ */ m(E2e, {}),
      /* @__PURE__ */ m(k2e, { maxDepth: 7 }),
      /* @__PURE__ */ m(
        v6e,
        {
          hasCellMerge: !0,
          hasCellBackgroundColor: !0
        }
      ),
      /* @__PURE__ */ m(x6e, {}),
      /* @__PURE__ */ m(AW, {}),
      /* @__PURE__ */ m(HW, {}),
      /* @__PURE__ */ m(Y2e, {}),
      /* @__PURE__ */ m(Wge, {}),
      /* @__PURE__ */ m(s2e, {}),
      /* @__PURE__ */ m(o2e, {}),
      /* @__PURE__ */ m(l2e, {}),
      /* @__PURE__ */ m(nW, {}),
      /* @__PURE__ */ m(Zge, {}),
      /* @__PURE__ */ m(Hge, {}),
      /* @__PURE__ */ m(I2e, {}),
      /* @__PURE__ */ m(tW, {}),
      /* @__PURE__ */ m(Jge, {}),
      /* @__PURE__ */ m(_W, {}),
      /* @__PURE__ */ m(Vge, {}),
      b && !U && /* @__PURE__ */ D(ge, { children: [
        /* @__PURE__ */ m(
          G6e,
          {
            anchorElem: b
          }
        ),
        /* @__PURE__ */ m(
          R2e,
          {
            anchorElem: b,
            isLinkEditMode: p,
            setIsLinkEditMode: g
          }
        ),
        /* @__PURE__ */ m(z5e, { anchorElem: b }),
        /* @__PURE__ */ m(
          b6e,
          {
            anchorElem: b
          }
        ),
        /* @__PURE__ */ m(
          C6e,
          {
            anchorElem: b,
            cellMerge: !0
          }
        )
      ] }),
      s && /* @__PURE__ */ m(K5e, {})
    ] })
  ] });
});
function q5e({ editorRef: e }) {
  const [t] = Fe();
  return J.useEffect(() => {
    typeof e == "function" ? e(t) : typeof e == "object" && (e.current = t);
  }, [t]), null;
}
const I4e = dn((e, t) => {
  const {
    editorState: n,
    historyState: r,
    onChange: i,
    showTableOfContents: a,
    autoAfterMentionData: l = [],
    autoMentionData: s = [],
    step: c = 1,
    editorRef: d = { current: null },
    imageUploadCallback: o
  } = e;
  wo.prototype.defaultStep = c;
  const u = {
    editorState: n,
    namespace: "Doc App",
    editable: c === 1,
    theme: V$,
    onError: (h) => {
      console.log("Error:", h.message);
    },
    nodes: [...IH, wo]
  };
  return /* @__PURE__ */ D(X$, { initialConfig: u, children: [
    /* @__PURE__ */ m(q5e, { editorRef: d }),
    /* @__PURE__ */ m($H, { initHistoryState: r, children: /* @__PURE__ */ m("div", { className: "doc-editor-shell", children: /* @__PURE__ */ m(
      Y5e,
      {
        step: c,
        autoAfterMentionData: l,
        autoMentionData: s,
        onChange: i,
        showTableOfContents: a,
        ref: t,
        imageUploadCallback: o
      }
    ) }) })
  ] });
});
export {
  CH as $,
  _se as A,
  xD as B,
  Use as C,
  Cse as D,
  yse as E,
  Ese as F,
  w4e as G,
  Fe as H,
  Mse as I,
  SC as J,
  hF as K,
  xse as L,
  q2e as M,
  Tse as N,
  zg as O,
  Sse as P,
  sb as Q,
  Ase as R,
  bse as S,
  wse as T,
  Xn as U,
  se as V,
  Rt as W,
  qle as X,
  pn as Y,
  Pt as Z,
  kse as _,
  Qle as a,
  Yge as a$,
  rd as a0,
  ot as a1,
  a0 as a2,
  P0 as a3,
  O0 as a4,
  ug as a5,
  L0 as a6,
  Ei as a7,
  QH as a8,
  Y2e as a9,
  X3 as aA,
  n6e as aB,
  J2e as aC,
  OH as aD,
  x2e as aE,
  k2e as aF,
  v6e as aG,
  x6e as aH,
  AW as aI,
  HW as aJ,
  I2e as aK,
  z5e as aL,
  C6e as aM,
  xn as aN,
  mz as aO,
  KN as aP,
  Df as aQ,
  zge as aR,
  Bge as aS,
  p4e as aT,
  m4e as aU,
  wy as aV,
  CW as aW,
  ad as aX,
  f4e as aY,
  vi as aZ,
  Kge as a_,
  b6e as aa,
  YH as ab,
  JH as ac,
  rW as ad,
  lW as ae,
  xo as af,
  FW as ag,
  J0 as ah,
  Qi as ai,
  sk as aj,
  LO as ak,
  b4e as al,
  bI as am,
  FH as an,
  bW as ao,
  Mn as ap,
  Z5 as aq,
  Cc as ar,
  i0 as as,
  j3 as at,
  aa as au,
  _g as av,
  kf as aw,
  c0 as ax,
  _f as ay,
  Sf as az,
  dse as b,
  ya as b0,
  ie as b1,
  it as b2,
  gf as b3,
  sg as b4,
  s4e as b5,
  fg as b6,
  hg as b7,
  J5 as b8,
  g$ as b9,
  j6e as bA,
  h4e as bB,
  Gd as ba,
  ls as bb,
  pf as bc,
  lv as bd,
  sv as be,
  R0 as bf,
  kc as bg,
  gc as bh,
  ns as bi,
  PF as bj,
  KH as bk,
  dT as bl,
  Z0 as bm,
  V$ as bn,
  cW as bo,
  g4e as bp,
  rk as bq,
  S5e as br,
  v3 as bs,
  ig as bt,
  x5e as bu,
  w5e as bv,
  EO as bw,
  u5e as bx,
  I4e as by,
  wo as bz,
  ase as c,
  ise as d,
  Lse as e,
  gse as f,
  use as g,
  cse as h,
  ese as i,
  Nse as j,
  pse as k,
  nse as l,
  sse as m,
  tse as n,
  Dse as o,
  lse as p,
  x4e as q,
  Jle as r,
  rse as s,
  Zle as t,
  ose as u,
  mse as v,
  fse as w,
  vse as x,
  hse as y,
  Ise as z
};
