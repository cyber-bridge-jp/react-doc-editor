var Sh = Object.defineProperty;
var Oh = (r, e, t) => e in r ? Sh(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var Ye = (r, e, t) => Oh(r, typeof e != "symbol" ? e + "" : e, t);
import * as hr from "react";
import nt, { useCallback as ct, useEffect as We, Suspense as An, useRef as Rt, useState as Ie, createContext as _u, useContext as Mh, useMemo as Sr } from "react";
import Ve, { DecoratorNode as mn, COMMAND_PRIORITY_HIGH as cn, $isNodeSelection as cs, $getSelection as Nt, $getNodeByKey as us, CLICK_COMMAND as Cu, COMMAND_PRIORITY_LOW as qt, KEY_DELETE_COMMAND as Rh, KEY_BACKSPACE_COMMAND as Ah, TextNode as ds, $applyNodeReplacement as Oi, createEditor as To, $setSelection as Wn, ElementNode as Mi, $isElementNode as yn, $createParagraphNode as Gt, createCommand as mr, $isRangeSelection as At, COMMAND_PRIORITY_EDITOR as Or, $insertNodes as Ri, $isRootOrShadowRoot as Gn, DRAGSTART_COMMAND as bu, DRAGOVER_COMMAND as hs, DROP_COMMAND as fs, $createRangeSelection as yu, KEY_ARROW_DOWN_COMMAND as wu, KEY_ARROW_RIGHT_COMMAND as Tu, KEY_ARROW_UP_COMMAND as Eu, KEY_ARROW_LEFT_COMMAND as Su, DELETE_CHARACTER_COMMAND as Lh, INSERT_PARAGRAPH_COMMAND as kh, $getPreviousSelection as Dh, SELECTION_CHANGE_COMMAND as Vn, COMMAND_PRIORITY_CRITICAL as _i, CAN_UNDO_COMMAND as $h, CAN_REDO_COMMAND as Ih, KEY_MODIFIER_COMMAND as Ph, COMMAND_PRIORITY_NORMAL as Fh, $isTextNode as ms, UNDO_COMMAND as Bh, REDO_COMMAND as zh, FORMAT_TEXT_COMMAND as dr, $getRoot as gs, FORMAT_ELEMENT_COMMAND as _n, OUTDENT_CONTENT_COMMAND as Hh, INDENT_CONTENT_COMMAND as Ou, FOCUS_COMMAND as jh, KEY_ESCAPE_COMMAND as qh, $isLineBreakNode as Kh, $isParagraphNode as ps, $getNearestNodeFromDOMNode as Ci, $createTextNode as Uh } from "lexical";
import * as wi from "react-dom";
import Mu, { createPortal as Qr } from "react-dom";
var po = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ru(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Wa = { exports: {} }, li = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var il;
function Yh() {
  if (il) return li;
  il = 1;
  var r = nt, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, i = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var d, p = {}, m = null, c = null;
    u !== void 0 && (m = "" + u), l.key !== void 0 && (m = "" + l.key), l.ref !== void 0 && (c = l.ref);
    for (d in l) n.call(l, d) && !o.hasOwnProperty(d) && (p[d] = l[d]);
    if (a && a.defaultProps) for (d in l = a.defaultProps, l) p[d] === void 0 && (p[d] = l[d]);
    return { $$typeof: e, type: a, key: m, ref: c, props: p, _owner: i.current };
  }
  return li.Fragment = t, li.jsx = s, li.jsxs = s, li;
}
var ci = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ol;
function Wh() {
  return ol || (ol = 1, process.env.NODE_ENV !== "production" && function() {
    var r = nt, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), m = Symbol.for("react.lazy"), c = Symbol.for("react.offscreen"), h = Symbol.iterator, f = "@@iterator";
    function N(ae) {
      if (ae === null || typeof ae != "object")
        return null;
      var Oe = h && ae[h] || ae[f];
      return typeof Oe == "function" ? Oe : null;
    }
    var v = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function C(ae) {
      {
        for (var Oe = arguments.length, Fe = new Array(Oe > 1 ? Oe - 1 : 0), rt = 1; rt < Oe; rt++)
          Fe[rt - 1] = arguments[rt];
        g("error", ae, Fe);
      }
    }
    function g(ae, Oe, Fe) {
      {
        var rt = v.ReactDebugCurrentFrame, bt = rt.getStackAddendum();
        bt !== "" && (Oe += "%s", Fe = Fe.concat([bt]));
        var Et = Fe.map(function(gt) {
          return String(gt);
        });
        Et.unshift("Warning: " + Oe), Function.prototype.apply.call(console[ae], console, Et);
      }
    }
    var x = !1, b = !1, A = !1, w = !1, M = !1, y;
    y = Symbol.for("react.module.reference");
    function E(ae) {
      return !!(typeof ae == "string" || typeof ae == "function" || ae === n || ae === o || M || ae === i || ae === u || ae === d || w || ae === c || x || b || A || typeof ae == "object" && ae !== null && (ae.$$typeof === m || ae.$$typeof === p || ae.$$typeof === s || ae.$$typeof === a || ae.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      ae.$$typeof === y || ae.getModuleId !== void 0));
    }
    function S(ae, Oe, Fe) {
      var rt = ae.displayName;
      if (rt)
        return rt;
      var bt = Oe.displayName || Oe.name || "";
      return bt !== "" ? Fe + "(" + bt + ")" : Fe;
    }
    function P(ae) {
      return ae.displayName || "Context";
    }
    function U(ae) {
      if (ae == null)
        return null;
      if (typeof ae.tag == "number" && C("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof ae == "function")
        return ae.displayName || ae.name || null;
      if (typeof ae == "string")
        return ae;
      switch (ae) {
        case n:
          return "Fragment";
        case t:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case u:
          return "Suspense";
        case d:
          return "SuspenseList";
      }
      if (typeof ae == "object")
        switch (ae.$$typeof) {
          case a:
            var Oe = ae;
            return P(Oe) + ".Consumer";
          case s:
            var Fe = ae;
            return P(Fe._context) + ".Provider";
          case l:
            return S(ae, ae.render, "ForwardRef");
          case p:
            var rt = ae.displayName || null;
            return rt !== null ? rt : U(ae.type) || "Memo";
          case m: {
            var bt = ae, Et = bt._payload, gt = bt._init;
            try {
              return U(gt(Et));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var j = Object.assign, H = 0, R, T, $, G, q, I, Y;
    function D() {
    }
    D.__reactDisabledLog = !0;
    function z() {
      {
        if (H === 0) {
          R = console.log, T = console.info, $ = console.warn, G = console.error, q = console.group, I = console.groupCollapsed, Y = console.groupEnd;
          var ae = {
            configurable: !0,
            enumerable: !0,
            value: D,
            writable: !0
          };
          Object.defineProperties(console, {
            info: ae,
            log: ae,
            warn: ae,
            error: ae,
            group: ae,
            groupCollapsed: ae,
            groupEnd: ae
          });
        }
        H++;
      }
    }
    function X() {
      {
        if (H--, H === 0) {
          var ae = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: j({}, ae, {
              value: R
            }),
            info: j({}, ae, {
              value: T
            }),
            warn: j({}, ae, {
              value: $
            }),
            error: j({}, ae, {
              value: G
            }),
            group: j({}, ae, {
              value: q
            }),
            groupCollapsed: j({}, ae, {
              value: I
            }),
            groupEnd: j({}, ae, {
              value: Y
            })
          });
        }
        H < 0 && C("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Q = v.ReactCurrentDispatcher, ne;
    function fe(ae, Oe, Fe) {
      {
        if (ne === void 0)
          try {
            throw Error();
          } catch (bt) {
            var rt = bt.stack.trim().match(/\n( *(at )?)/);
            ne = rt && rt[1] || "";
          }
        return `
` + ne + ae;
      }
    }
    var _e = !1, pe;
    {
      var Ne = typeof WeakMap == "function" ? WeakMap : Map;
      pe = new Ne();
    }
    function B(ae, Oe) {
      if (!ae || _e)
        return "";
      {
        var Fe = pe.get(ae);
        if (Fe !== void 0)
          return Fe;
      }
      var rt;
      _e = !0;
      var bt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Et;
      Et = Q.current, Q.current = null, z();
      try {
        if (Oe) {
          var gt = function() {
            throw Error();
          };
          if (Object.defineProperty(gt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(gt, []);
            } catch (rr) {
              rt = rr;
            }
            Reflect.construct(ae, [], gt);
          } else {
            try {
              gt.call();
            } catch (rr) {
              rt = rr;
            }
            ae.call(gt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (rr) {
            rt = rr;
          }
          ae();
        }
      } catch (rr) {
        if (rr && rt && typeof rr.stack == "string") {
          for (var ht = rr.stack.split(`
`), tr = rt.stack.split(`
`), Dt = ht.length - 1, $t = tr.length - 1; Dt >= 1 && $t >= 0 && ht[Dt] !== tr[$t]; )
            $t--;
          for (; Dt >= 1 && $t >= 0; Dt--, $t--)
            if (ht[Dt] !== tr[$t]) {
              if (Dt !== 1 || $t !== 1)
                do
                  if (Dt--, $t--, $t < 0 || ht[Dt] !== tr[$t]) {
                    var ir = `
` + ht[Dt].replace(" at new ", " at ");
                    return ae.displayName && ir.includes("<anonymous>") && (ir = ir.replace("<anonymous>", ae.displayName)), typeof ae == "function" && pe.set(ae, ir), ir;
                  }
                while (Dt >= 1 && $t >= 0);
              break;
            }
        }
      } finally {
        _e = !1, Q.current = Et, X(), Error.prepareStackTrace = bt;
      }
      var kt = ae ? ae.displayName || ae.name : "", Mr = kt ? fe(kt) : "";
      return typeof ae == "function" && pe.set(ae, Mr), Mr;
    }
    function F(ae, Oe, Fe) {
      return B(ae, !1);
    }
    function k(ae) {
      var Oe = ae.prototype;
      return !!(Oe && Oe.isReactComponent);
    }
    function W(ae, Oe, Fe) {
      if (ae == null)
        return "";
      if (typeof ae == "function")
        return B(ae, k(ae));
      if (typeof ae == "string")
        return fe(ae);
      switch (ae) {
        case u:
          return fe("Suspense");
        case d:
          return fe("SuspenseList");
      }
      if (typeof ae == "object")
        switch (ae.$$typeof) {
          case l:
            return F(ae.render);
          case p:
            return W(ae.type, Oe, Fe);
          case m: {
            var rt = ae, bt = rt._payload, Et = rt._init;
            try {
              return W(Et(bt), Oe, Fe);
            } catch {
            }
          }
        }
      return "";
    }
    var V = Object.prototype.hasOwnProperty, te = {}, ee = v.ReactDebugCurrentFrame;
    function ue(ae) {
      if (ae) {
        var Oe = ae._owner, Fe = W(ae.type, ae._source, Oe ? Oe.type : null);
        ee.setExtraStackFrame(Fe);
      } else
        ee.setExtraStackFrame(null);
    }
    function xe(ae, Oe, Fe, rt, bt) {
      {
        var Et = Function.call.bind(V);
        for (var gt in ae)
          if (Et(ae, gt)) {
            var ht = void 0;
            try {
              if (typeof ae[gt] != "function") {
                var tr = Error((rt || "React class") + ": " + Fe + " type `" + gt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ae[gt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw tr.name = "Invariant Violation", tr;
              }
              ht = ae[gt](Oe, gt, rt, Fe, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Dt) {
              ht = Dt;
            }
            ht && !(ht instanceof Error) && (ue(bt), C("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", rt || "React class", Fe, gt, typeof ht), ue(null)), ht instanceof Error && !(ht.message in te) && (te[ht.message] = !0, ue(bt), C("Failed %s type: %s", Fe, ht.message), ue(null));
          }
      }
    }
    var ye = Array.isArray;
    function de(ae) {
      return ye(ae);
    }
    function me(ae) {
      {
        var Oe = typeof Symbol == "function" && Symbol.toStringTag, Fe = Oe && ae[Symbol.toStringTag] || ae.constructor.name || "Object";
        return Fe;
      }
    }
    function we(ae) {
      try {
        return Ee(ae), !1;
      } catch {
        return !0;
      }
    }
    function Ee(ae) {
      return "" + ae;
    }
    function Be(ae) {
      if (we(ae))
        return C("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", me(ae)), Ee(ae);
    }
    var ke = v.ReactCurrentOwner, at = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Pt, Ct, Je;
    Je = {};
    function le(ae) {
      if (V.call(ae, "ref")) {
        var Oe = Object.getOwnPropertyDescriptor(ae, "ref").get;
        if (Oe && Oe.isReactWarning)
          return !1;
      }
      return ae.ref !== void 0;
    }
    function Z(ae) {
      if (V.call(ae, "key")) {
        var Oe = Object.getOwnPropertyDescriptor(ae, "key").get;
        if (Oe && Oe.isReactWarning)
          return !1;
      }
      return ae.key !== void 0;
    }
    function re(ae, Oe) {
      if (typeof ae.ref == "string" && ke.current && Oe && ke.current.stateNode !== Oe) {
        var Fe = U(ke.current.type);
        Je[Fe] || (C('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', U(ke.current.type), ae.ref), Je[Fe] = !0);
      }
    }
    function ce(ae, Oe) {
      {
        var Fe = function() {
          Pt || (Pt = !0, C("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Oe));
        };
        Fe.isReactWarning = !0, Object.defineProperty(ae, "key", {
          get: Fe,
          configurable: !0
        });
      }
    }
    function ve(ae, Oe) {
      {
        var Fe = function() {
          Ct || (Ct = !0, C("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Oe));
        };
        Fe.isReactWarning = !0, Object.defineProperty(ae, "ref", {
          get: Fe,
          configurable: !0
        });
      }
    }
    var he = function(ae, Oe, Fe, rt, bt, Et, gt) {
      var ht = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: ae,
        key: Oe,
        ref: Fe,
        props: gt,
        // Record the component responsible for creating this element.
        _owner: Et
      };
      return ht._store = {}, Object.defineProperty(ht._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ht, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: rt
      }), Object.defineProperty(ht, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: bt
      }), Object.freeze && (Object.freeze(ht.props), Object.freeze(ht)), ht;
    };
    function Te(ae, Oe, Fe, rt, bt) {
      {
        var Et, gt = {}, ht = null, tr = null;
        Fe !== void 0 && (Be(Fe), ht = "" + Fe), Z(Oe) && (Be(Oe.key), ht = "" + Oe.key), le(Oe) && (tr = Oe.ref, re(Oe, bt));
        for (Et in Oe)
          V.call(Oe, Et) && !at.hasOwnProperty(Et) && (gt[Et] = Oe[Et]);
        if (ae && ae.defaultProps) {
          var Dt = ae.defaultProps;
          for (Et in Dt)
            gt[Et] === void 0 && (gt[Et] = Dt[Et]);
        }
        if (ht || tr) {
          var $t = typeof ae == "function" ? ae.displayName || ae.name || "Unknown" : ae;
          ht && ce(gt, $t), tr && ve(gt, $t);
        }
        return he(ae, ht, tr, bt, rt, ke.current, gt);
      }
    }
    var De = v.ReactCurrentOwner, Pe = v.ReactDebugCurrentFrame;
    function Ae(ae) {
      if (ae) {
        var Oe = ae._owner, Fe = W(ae.type, ae._source, Oe ? Oe.type : null);
        Pe.setExtraStackFrame(Fe);
      } else
        Pe.setExtraStackFrame(null);
    }
    var qe;
    qe = !1;
    function be(ae) {
      return typeof ae == "object" && ae !== null && ae.$$typeof === e;
    }
    function Ce() {
      {
        if (De.current) {
          var ae = U(De.current.type);
          if (ae)
            return `

Check the render method of \`` + ae + "`.";
        }
        return "";
      }
    }
    function Le(ae) {
      return "";
    }
    var je = {};
    function Ke(ae) {
      {
        var Oe = Ce();
        if (!Oe) {
          var Fe = typeof ae == "string" ? ae : ae.displayName || ae.name;
          Fe && (Oe = `

Check the top-level render call using <` + Fe + ">.");
        }
        return Oe;
      }
    }
    function Ue(ae, Oe) {
      {
        if (!ae._store || ae._store.validated || ae.key != null)
          return;
        ae._store.validated = !0;
        var Fe = Ke(Oe);
        if (je[Fe])
          return;
        je[Fe] = !0;
        var rt = "";
        ae && ae._owner && ae._owner !== De.current && (rt = " It was passed a child from " + U(ae._owner.type) + "."), Ae(ae), C('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Fe, rt), Ae(null);
      }
    }
    function tt(ae, Oe) {
      {
        if (typeof ae != "object")
          return;
        if (de(ae))
          for (var Fe = 0; Fe < ae.length; Fe++) {
            var rt = ae[Fe];
            be(rt) && Ue(rt, Oe);
          }
        else if (be(ae))
          ae._store && (ae._store.validated = !0);
        else if (ae) {
          var bt = N(ae);
          if (typeof bt == "function" && bt !== ae.entries)
            for (var Et = bt.call(ae), gt; !(gt = Et.next()).done; )
              be(gt.value) && Ue(gt.value, Oe);
        }
      }
    }
    function Ze(ae) {
      {
        var Oe = ae.type;
        if (Oe == null || typeof Oe == "string")
          return;
        var Fe;
        if (typeof Oe == "function")
          Fe = Oe.propTypes;
        else if (typeof Oe == "object" && (Oe.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Oe.$$typeof === p))
          Fe = Oe.propTypes;
        else
          return;
        if (Fe) {
          var rt = U(Oe);
          xe(Fe, ae.props, "prop", rt, ae);
        } else if (Oe.PropTypes !== void 0 && !qe) {
          qe = !0;
          var bt = U(Oe);
          C("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", bt || "Unknown");
        }
        typeof Oe.getDefaultProps == "function" && !Oe.getDefaultProps.isReactClassApproved && C("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function st(ae) {
      {
        for (var Oe = Object.keys(ae.props), Fe = 0; Fe < Oe.length; Fe++) {
          var rt = Oe[Fe];
          if (rt !== "children" && rt !== "key") {
            Ae(ae), C("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", rt), Ae(null);
            break;
          }
        }
        ae.ref !== null && (Ae(ae), C("Invalid attribute `ref` supplied to `React.Fragment`."), Ae(null));
      }
    }
    var Tt = {};
    function pt(ae, Oe, Fe, rt, bt, Et) {
      {
        var gt = E(ae);
        if (!gt) {
          var ht = "";
          (ae === void 0 || typeof ae == "object" && ae !== null && Object.keys(ae).length === 0) && (ht += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var tr = Le();
          tr ? ht += tr : ht += Ce();
          var Dt;
          ae === null ? Dt = "null" : de(ae) ? Dt = "array" : ae !== void 0 && ae.$$typeof === e ? (Dt = "<" + (U(ae.type) || "Unknown") + " />", ht = " Did you accidentally export a JSX literal instead of a component?") : Dt = typeof ae, C("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Dt, ht);
        }
        var $t = Te(ae, Oe, Fe, bt, Et);
        if ($t == null)
          return $t;
        if (gt) {
          var ir = Oe.children;
          if (ir !== void 0)
            if (rt)
              if (de(ir)) {
                for (var kt = 0; kt < ir.length; kt++)
                  tt(ir[kt], ae);
                Object.freeze && Object.freeze(ir);
              } else
                C("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              tt(ir, ae);
        }
        if (V.call(Oe, "key")) {
          var Mr = U(ae), rr = Object.keys(Oe).filter(function(Hi) {
            return Hi !== "key";
          }), ai = rr.length > 0 ? "{key: someKey, " + rr.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Tt[Mr + ai]) {
            var $o = rr.length > 0 ? "{" + rr.join(": ..., ") + ": ...}" : "{}";
            C(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ai, Mr, $o, Mr), Tt[Mr + ai] = !0;
          }
        }
        return ae === n ? st($t) : Ze($t), $t;
      }
    }
    function er(ae, Oe, Fe) {
      return pt(ae, Oe, Fe, !0);
    }
    function vt(ae, Oe, Fe) {
      return pt(ae, Oe, Fe, !1);
    }
    var xt = vt, wt = er;
    ci.Fragment = n, ci.jsx = xt, ci.jsxs = wt;
  }()), ci;
}
process.env.NODE_ENV === "production" ? Wa.exports = Yh() : Wa.exports = Wh();
var L = Wa.exports, Io = {}, ui = {}, al;
function Gh() {
  if (al) return ui;
  al = 1;
  var r = nt;
  const e = /* @__PURE__ */ r.createContext(null);
  function t(i, o) {
    let s = null;
    i != null && (s = i[1]);
    function a() {
      return o ?? (s != null ? s.getTheme() : null);
    }
    return {
      getTheme: a
    };
  }
  function n() {
    const i = r.useContext(e);
    if (i == null)
      throw Error("LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext");
    return i;
  }
  return ui.LexicalComposerContext = e, ui.createLexicalComposerContext = t, ui.useLexicalComposerContext = n, ui;
}
var di = {}, sl;
function Vh() {
  if (sl) return di;
  sl = 1;
  var r = nt;
  function e(n) {
    let i = new URLSearchParams();
    i.append("code", n);
    for (let o = 1; o < arguments.length; o++) i.append("v", arguments[o]);
    throw Error(`Minified Lexical error #${n}; visit https://lexical.dev/docs/error?${i} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  let t = r.createContext(null);
  return di.LexicalComposerContext = t, di.createLexicalComposerContext = function(n, i) {
    let o = null;
    return n != null && (o = n[1]), { getTheme: function() {
      return i ?? (o != null ? o.getTheme() : null);
    } };
  }, di.useLexicalComposerContext = function() {
    let n = r.useContext(t);
    return n == null && e(8), n;
  }, di;
}
var Po, ll;
function lt() {
  return ll || (ll = 1, Po = process.env.NODE_ENV === "development" ? Gh() : Vh()), Po;
}
var cl;
function Xh() {
  if (cl) return Io;
  cl = 1;
  var r = lt(), e = Ve, t = nt;
  const n = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  var o = n ? t.useLayoutEffect : t.useEffect;
  const s = {
    tag: "history-merge"
  };
  function a({
    initialConfig: u,
    children: d
  }) {
    const p = t.useMemo(
      () => {
        const {
          theme: m,
          namespace: c,
          editor__DEPRECATED: h,
          nodes: f,
          onError: N,
          editorState: v,
          html: C
        } = u, g = r.createLexicalComposerContext(null, m);
        let x = h || null;
        if (x === null) {
          const b = e.createEditor({
            editable: u.editable,
            html: C,
            namespace: c,
            nodes: f,
            onError: (A) => N(A, b),
            theme: m
          });
          l(b, v), x = b;
        }
        return [x, g];
      },
      // We only do this for init
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    );
    return o(() => {
      const m = u.editable, [c] = p;
      c.setEditable(m !== void 0 ? m : !0);
    }, []), /* @__PURE__ */ t.createElement(r.LexicalComposerContext.Provider, {
      value: p
    }, d);
  }
  function l(u, d) {
    if (d !== null) {
      if (d === void 0)
        u.update(() => {
          const p = e.$getRoot();
          if (p.isEmpty()) {
            const m = e.$createParagraphNode();
            p.append(m);
            const c = n ? document.activeElement : null;
            (e.$getSelection() !== null || c !== null && c === u.getRootElement()) && m.select();
          }
        }, s);
      else if (d !== null)
        switch (typeof d) {
          case "string": {
            const p = u.parseEditorState(d);
            u.setEditorState(p, s);
            break;
          }
          case "object": {
            u.setEditorState(d, s);
            break;
          }
          case "function": {
            u.update(() => {
              e.$getRoot().isEmpty() && d(u);
            }, s);
            break;
          }
        }
    }
  }
  return Io.LexicalComposer = a, Io;
}
var Fo = {}, ul;
function Jh() {
  if (ul) return Fo;
  ul = 1;
  var r = lt(), e = Ve, t = nt;
  let n = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  var i = n ? t.useLayoutEffect : t.useEffect;
  let o = { tag: "history-merge" };
  function s(a, l) {
    if (l !== null) {
      if (l === void 0) a.update(() => {
        var u = e.$getRoot();
        if (u.isEmpty()) {
          let d = e.$createParagraphNode();
          u.append(d), u = n ? document.activeElement : null, (e.$getSelection() !== null || u !== null && u === a.getRootElement()) && d.select();
        }
      }, o);
      else if (l !== null) switch (typeof l) {
        case "string":
          let u = a.parseEditorState(l);
          a.setEditorState(u, o);
          break;
        case "object":
          a.setEditorState(l, o);
          break;
        case "function":
          a.update(() => {
            e.$getRoot().isEmpty() && l(a);
          }, o);
      }
    }
  }
  return Fo.LexicalComposer = function({ initialConfig: a, children: l }) {
    let u = t.useMemo(() => {
      const { theme: d, namespace: p, editor__DEPRECATED: m, nodes: c, onError: h, editorState: f, html: N } = a, v = r.createLexicalComposerContext(null, d);
      let C = m || null;
      if (C === null) {
        const g = e.createEditor({ editable: a.editable, html: N, namespace: p, nodes: c, onError: (x) => h(x, g), theme: d });
        s(g, f), C = g;
      }
      return [C, v];
    }, []);
    return i(() => {
      let d = a.editable, [p] = u;
      p.setEditable(d !== void 0 ? d : !0);
    }, []), t.createElement(
      r.LexicalComposerContext.Provider,
      { value: u },
      l
    );
  }, Fo;
}
const Zh = process.env.NODE_ENV === "development" ? Xh() : Jh();
var Qh = Zh;
const ef = {
  blockCursor: "et_block-cursor",
  code: "et_code",
  characterLimit: "character-limit",
  embedBlock: {
    base: "et_embed-block",
    focus: "et_embed-block-focus"
  },
  hashtag: "et_hashtag",
  heading: {
    h1: "et_h1",
    h2: "et_h2",
    h3: "et_h3",
    h4: "et_h4",
    h5: "et_h5",
    h6: "et_h6"
  },
  image: "editor-image",
  indent: "et_indent",
  inlineImage: "inline-editor-image",
  layoutContainer: "et_layout-container",
  layoutItem: "et_layout-item",
  link: "et_link",
  list: {
    checklist: "et_checklist",
    listitem: "et_listitem",
    listitemChecked: "et_listitem-checked",
    listitemUnchecked: "et_listitem-unchecked",
    nested: {
      listitem: "et_nested-listitem"
    },
    olDepth: [
      "et_ol1",
      "et_ol2",
      "et_ol3",
      "et_ol4",
      "et_ol5"
    ],
    ul: "et_ul"
  },
  ltr: "et_ltr",
  mark: "et_mark",
  markOverlap: "et_mark-overlap",
  paragraph: "et_paragraph",
  quote: "et_quote",
  rtl: "et_rtl",
  table: "et_table",
  tableAddColumns: "et_table-add-columns",
  tableAddRows: "et_table-add-rows",
  tableCell: "et_table-cell",
  tableCellActionButton: "et_table-cell-action-button",
  tableCellActionButtonContainer: "et_table-cell-action-button-container",
  tableCellEditing: "et_table-cell-editing",
  tableCellHeader: "et_table-cell-header",
  tableCellPrimarySelected: "et_table-cell-primary-selected",
  tableCellResizer: "et_table-cell-resizer",
  tableCellSelected: "et_table-cell-selected",
  tableCellSortedIndicator: "et_table-cell-sorted-indicator",
  tableResizeRuler: "et_table-resize-ruler",
  tableSelected: "et_table-selected",
  tableSelection: "et_table-selection",
  text: {
    bold: "et_text-bold",
    code: "et_text-code",
    italic: "et_text-italic",
    strikethrough: "et_text-strikethrough",
    subscript: "et_text-subscript",
    superscript: "et_text-superscript",
    underline: "et_text-underline",
    underlineStrikethrough: "et_text-underline-strikethrough"
  },
  dataMention: "et_data-mention"
};
var Kt = {}, Bo = { exports: {} }, dl;
function Au() {
  return dl || (dl = 1, function(r) {
    var e = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
    /**
     * Prism: Lightweight, robust, elegant syntax highlighting
     *
     * @license MIT <https://opensource.org/licenses/MIT>
     * @author Lea Verou <https://lea.verou.me>
     * @namespace
     * @public
     */
    var t = function(n) {
      var i = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, o = 0, s = {}, a = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: n.Prism && n.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: n.Prism && n.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function C(g) {
            return g instanceof l ? new l(g.type, C(g.content), g.alias) : Array.isArray(g) ? g.map(C) : g.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(C) {
            return Object.prototype.toString.call(C).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(C) {
            return C.__id || Object.defineProperty(C, "__id", { value: ++o }), C.__id;
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function C(g, x) {
            x = x || {};
            var b, A;
            switch (a.util.type(g)) {
              case "Object":
                if (A = a.util.objId(g), x[A])
                  return x[A];
                b = /** @type {Record<string, any>} */
                {}, x[A] = b;
                for (var w in g)
                  g.hasOwnProperty(w) && (b[w] = C(g[w], x));
                return (
                  /** @type {any} */
                  b
                );
              case "Array":
                return A = a.util.objId(g), x[A] ? x[A] : (b = [], x[A] = b, /** @type {Array} */
                /** @type {any} */
                g.forEach(function(M, y) {
                  b[y] = C(M, x);
                }), /** @type {any} */
                b);
              default:
                return g;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(C) {
            for (; C; ) {
              var g = i.exec(C.className);
              if (g)
                return g[1].toLowerCase();
              C = C.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(C, g) {
            C.className = C.className.replace(RegExp(i, "gi"), ""), C.classList.add("language-" + g);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document > "u")
              return null;
            if ("currentScript" in document)
              return (
                /** @type {any} */
                document.currentScript
              );
            try {
              throw new Error();
            } catch (b) {
              var C = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(b.stack) || [])[1];
              if (C) {
                var g = document.getElementsByTagName("script");
                for (var x in g)
                  if (g[x].src == C)
                    return g[x];
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(C, g, x) {
            for (var b = "no-" + g; C; ) {
              var A = C.classList;
              if (A.contains(g))
                return !0;
              if (A.contains(b))
                return !1;
              C = C.parentElement;
            }
            return !!x;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: s,
          plaintext: s,
          text: s,
          txt: s,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(C, g) {
            var x = a.util.clone(a.languages[C]);
            for (var b in g)
              x[b] = g[b];
            return x;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(C, g, x, b) {
            b = b || /** @type {any} */
            a.languages;
            var A = b[C], w = {};
            for (var M in A)
              if (A.hasOwnProperty(M)) {
                if (M == g)
                  for (var y in x)
                    x.hasOwnProperty(y) && (w[y] = x[y]);
                x.hasOwnProperty(M) || (w[M] = A[M]);
              }
            var E = b[C];
            return b[C] = w, a.languages.DFS(a.languages, function(S, P) {
              P === E && S != C && (this[S] = w);
            }), w;
          },
          // Traverse a language definition with Depth First Search
          DFS: function C(g, x, b, A) {
            A = A || {};
            var w = a.util.objId;
            for (var M in g)
              if (g.hasOwnProperty(M)) {
                x.call(g, M, g[M], b || M);
                var y = g[M], E = a.util.type(y);
                E === "Object" && !A[w(y)] ? (A[w(y)] = !0, C(y, x, null, A)) : E === "Array" && !A[w(y)] && (A[w(y)] = !0, C(y, x, M, A));
              }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prismâ€™s API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(C, g) {
          a.highlightAllUnder(document, C, g);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(C, g, x) {
          var b = {
            callback: x,
            container: C,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          a.hooks.run("before-highlightall", b), b.elements = Array.prototype.slice.apply(b.container.querySelectorAll(b.selector)), a.hooks.run("before-all-elements-highlight", b);
          for (var A = 0, w; w = b.elements[A++]; )
            a.highlightElement(w, g === !0, b.callback);
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(C, g, x) {
          var b = a.util.getLanguage(C), A = a.languages[b];
          a.util.setLanguage(C, b);
          var w = C.parentElement;
          w && w.nodeName.toLowerCase() === "pre" && a.util.setLanguage(w, b);
          var M = C.textContent, y = {
            element: C,
            language: b,
            grammar: A,
            code: M
          };
          function E(P) {
            y.highlightedCode = P, a.hooks.run("before-insert", y), y.element.innerHTML = y.highlightedCode, a.hooks.run("after-highlight", y), a.hooks.run("complete", y), x && x.call(y.element);
          }
          if (a.hooks.run("before-sanity-check", y), w = y.element.parentElement, w && w.nodeName.toLowerCase() === "pre" && !w.hasAttribute("tabindex") && w.setAttribute("tabindex", "0"), !y.code) {
            a.hooks.run("complete", y), x && x.call(y.element);
            return;
          }
          if (a.hooks.run("before-highlight", y), !y.grammar) {
            E(a.util.encode(y.code));
            return;
          }
          if (g && n.Worker) {
            var S = new Worker(a.filename);
            S.onmessage = function(P) {
              E(P.data);
            }, S.postMessage(JSON.stringify({
              language: y.language,
              code: y.code,
              immediateClose: !0
            }));
          } else
            E(a.highlight(y.code, y.grammar, y.language));
        },
        /**
         * Low-level function, only use if you know what youâ€™re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(C, g, x) {
          var b = {
            code: C,
            grammar: g,
            language: x
          };
          if (a.hooks.run("before-tokenize", b), !b.grammar)
            throw new Error('The language "' + b.language + '" has no grammar.');
          return b.tokens = a.tokenize(b.code, b.grammar), a.hooks.run("after-tokenize", b), l.stringify(a.util.encode(b.tokens), b.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(C, g) {
          var x = g.rest;
          if (x) {
            for (var b in x)
              g[b] = x[b];
            delete g.rest;
          }
          var A = new p();
          return m(A, A.head, C), d(C, A, g, A.head, 0), h(A);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(C, g) {
            var x = a.hooks.all;
            x[C] = x[C] || [], x[C].push(g);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(C, g) {
            var x = a.hooks.all[C];
            if (!(!x || !x.length))
              for (var b = 0, A; A = x[b++]; )
                A(g);
          }
        },
        Token: l
      };
      n.Prism = a;
      function l(C, g, x, b) {
        this.type = C, this.content = g, this.alias = x, this.length = (b || "").length | 0;
      }
      l.stringify = function C(g, x) {
        if (typeof g == "string")
          return g;
        if (Array.isArray(g)) {
          var b = "";
          return g.forEach(function(E) {
            b += C(E, x);
          }), b;
        }
        var A = {
          type: g.type,
          content: C(g.content, x),
          tag: "span",
          classes: ["token", g.type],
          attributes: {},
          language: x
        }, w = g.alias;
        w && (Array.isArray(w) ? Array.prototype.push.apply(A.classes, w) : A.classes.push(w)), a.hooks.run("wrap", A);
        var M = "";
        for (var y in A.attributes)
          M += " " + y + '="' + (A.attributes[y] || "").replace(/"/g, "&quot;") + '"';
        return "<" + A.tag + ' class="' + A.classes.join(" ") + '"' + M + ">" + A.content + "</" + A.tag + ">";
      };
      function u(C, g, x, b) {
        C.lastIndex = g;
        var A = C.exec(x);
        if (A && b && A[1]) {
          var w = A[1].length;
          A.index += w, A[0] = A[0].slice(w);
        }
        return A;
      }
      function d(C, g, x, b, A, w) {
        for (var M in x)
          if (!(!x.hasOwnProperty(M) || !x[M])) {
            var y = x[M];
            y = Array.isArray(y) ? y : [y];
            for (var E = 0; E < y.length; ++E) {
              if (w && w.cause == M + "," + E)
                return;
              var S = y[E], P = S.inside, U = !!S.lookbehind, j = !!S.greedy, H = S.alias;
              if (j && !S.pattern.global) {
                var R = S.pattern.toString().match(/[imsuy]*$/)[0];
                S.pattern = RegExp(S.pattern.source, R + "g");
              }
              for (var T = S.pattern || S, $ = b.next, G = A; $ !== g.tail && !(w && G >= w.reach); G += $.value.length, $ = $.next) {
                var q = $.value;
                if (g.length > C.length)
                  return;
                if (!(q instanceof l)) {
                  var I = 1, Y;
                  if (j) {
                    if (Y = u(T, G, C, U), !Y || Y.index >= C.length)
                      break;
                    var Q = Y.index, D = Y.index + Y[0].length, z = G;
                    for (z += $.value.length; Q >= z; )
                      $ = $.next, z += $.value.length;
                    if (z -= $.value.length, G = z, $.value instanceof l)
                      continue;
                    for (var X = $; X !== g.tail && (z < D || typeof X.value == "string"); X = X.next)
                      I++, z += X.value.length;
                    I--, q = C.slice(G, z), Y.index -= G;
                  } else if (Y = u(T, 0, q, U), !Y)
                    continue;
                  var Q = Y.index, ne = Y[0], fe = q.slice(0, Q), _e = q.slice(Q + ne.length), pe = G + q.length;
                  w && pe > w.reach && (w.reach = pe);
                  var Ne = $.prev;
                  fe && (Ne = m(g, Ne, fe), G += fe.length), c(g, Ne, I);
                  var B = new l(M, P ? a.tokenize(ne, P) : ne, H, ne);
                  if ($ = m(g, Ne, B), _e && m(g, $, _e), I > 1) {
                    var F = {
                      cause: M + "," + E,
                      reach: pe
                    };
                    d(C, g, x, $.prev, G, F), w && F.reach > w.reach && (w.reach = F.reach);
                  }
                }
              }
            }
          }
      }
      function p() {
        var C = { value: null, prev: null, next: null }, g = { value: null, prev: C, next: null };
        C.next = g, this.head = C, this.tail = g, this.length = 0;
      }
      function m(C, g, x) {
        var b = g.next, A = { value: x, prev: g, next: b };
        return g.next = A, b.prev = A, C.length++, A;
      }
      function c(C, g, x) {
        for (var b = g.next, A = 0; A < x && b !== C.tail; A++)
          b = b.next;
        g.next = b, b.prev = g, C.length -= A;
      }
      function h(C) {
        for (var g = [], x = C.head.next; x !== C.tail; )
          g.push(x.value), x = x.next;
        return g;
      }
      if (!n.document)
        return n.addEventListener && (a.disableWorkerMessageHandler || n.addEventListener("message", function(C) {
          var g = JSON.parse(C.data), x = g.language, b = g.code, A = g.immediateClose;
          n.postMessage(a.highlight(b, a.languages[x], x)), A && n.close();
        }, !1)), a;
      var f = a.util.currentScript();
      f && (a.filename = f.src, f.hasAttribute("data-manual") && (a.manual = !0));
      function N() {
        a.manual || a.highlightAll();
      }
      if (!a.manual) {
        var v = document.readyState;
        v === "loading" || v === "interactive" && f && f.defer ? document.addEventListener("DOMContentLoaded", N) : window.requestAnimationFrame ? window.requestAnimationFrame(N) : window.setTimeout(N, 16);
      }
      return a;
    }(e);
    r.exports && (r.exports = t), typeof po < "u" && (po.Prism = t), t.languages.markup = {
      comment: {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: !0
      },
      prolog: {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: !0
      },
      doctype: {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: !0,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: !0,
            greedy: !0,
            inside: null
            // see below
          },
          string: {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: !0
          },
          punctuation: /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          name: /[^\s<>'"]+/
        }
      },
      cdata: {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: !0
      },
      tag: {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: !0,
        inside: {
          tag: {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              punctuation: /^<\/?/,
              namespace: /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: !0
                }
              ]
            }
          },
          punctuation: /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              namespace: /^[^\s>\/:]+:/
            }
          }
        }
      },
      entity: [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    }, t.languages.markup.tag.inside["attr-value"].inside.entity = t.languages.markup.entity, t.languages.markup.doctype.inside["internal-subset"].inside = t.languages.markup, t.hooks.add("wrap", function(n) {
      n.type === "entity" && (n.attributes.title = n.content.replace(/&amp;/, "&"));
    }), Object.defineProperty(t.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function(i, o) {
        var s = {};
        s["language-" + o] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: !0,
          inside: t.languages[o]
        }, s.cdata = /^<!\[CDATA\[|\]\]>$/i;
        var a = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: s
          }
        };
        a["language-" + o] = {
          pattern: /[\s\S]+/,
          inside: t.languages[o]
        };
        var l = {};
        l[i] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return i;
          }), "i"),
          lookbehind: !0,
          greedy: !0,
          inside: a
        }, t.languages.insertBefore("markup", "cdata", l);
      }
    }), Object.defineProperty(t.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(n, i) {
        t.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + n + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: !0,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                value: {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: !0,
                  alias: [i, "language-" + i],
                  inside: t.languages[i]
                },
                punctuation: [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    }), t.languages.html = t.languages.markup, t.languages.mathml = t.languages.markup, t.languages.svg = t.languages.markup, t.languages.xml = t.languages.extend("markup", {}), t.languages.ssml = t.languages.xml, t.languages.atom = t.languages.xml, t.languages.rss = t.languages.xml, function(n) {
      var i = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      n.languages.css = {
        comment: /\/\*[\s\S]*?\*\//,
        atrule: {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + i.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            rule: /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: !0,
              alias: "selector"
            },
            keyword: {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: !0
            }
            // See rest below
          }
        },
        url: {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + i.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: !0,
          inside: {
            function: /^url/i,
            punctuation: /^\(|\)$/,
            string: {
              pattern: RegExp("^" + i.source + "$"),
              alias: "url"
            }
          }
        },
        selector: {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + i.source + ")*(?=\\s*\\{)"),
          lookbehind: !0
        },
        string: {
          pattern: i,
          greedy: !0
        },
        property: {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: !0
        },
        important: /!important\b/i,
        function: {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: !0
        },
        punctuation: /[(){};:,]/
      }, n.languages.css.atrule.inside.rest = n.languages.css;
      var o = n.languages.markup;
      o && (o.tag.addInlined("style", "css"), o.tag.addAttribute("style", "css"));
    }(t), t.languages.clike = {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: {
          punctuation: /[.\\]/
        }
      },
      keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b\w+(?=\()/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      punctuation: /[{}[\];(),.:]/
    }, t.languages.javascript = t.languages.extend("clike", {
      "class-name": [
        t.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: !0
        }
      ],
      keyword: [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: !0
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: !0
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      number: {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: !0
      },
      operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    }), t.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, t.languages.insertBefore("javascript", "keyword", {
      regex: {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: !0,
            alias: "language-regex",
            inside: t.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      parameter: [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: !0,
          inside: t.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: !0,
          inside: t.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: !0,
          inside: t.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: !0,
          inside: t.languages.javascript
        }
      ],
      constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    }), t.languages.insertBefore("javascript", "string", {
      hashbang: {
        pattern: /^#!.*/,
        greedy: !0,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: !0,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: !0,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: t.languages.javascript
            }
          },
          string: /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      }
    }), t.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: !0,
        alias: "property"
      }
    }), t.languages.markup && (t.languages.markup.tag.addInlined("script", "javascript"), t.languages.markup.tag.addAttribute(
      /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
      "javascript"
    )), t.languages.js = t.languages.javascript, function() {
      if (typeof t > "u" || typeof document > "u")
        return;
      Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
      var n = "Loadingâ€¦", i = function(f, N) {
        return "âœ– Error " + f + " while fetching file: " + N;
      }, o = "âœ– Error: File does not exist or is empty", s = {
        js: "javascript",
        py: "python",
        rb: "ruby",
        ps1: "powershell",
        psm1: "powershell",
        sh: "bash",
        bat: "batch",
        h: "c",
        tex: "latex"
      }, a = "data-src-status", l = "loading", u = "loaded", d = "failed", p = "pre[data-src]:not([" + a + '="' + u + '"]):not([' + a + '="' + l + '"])';
      function m(f, N, v) {
        var C = new XMLHttpRequest();
        C.open("GET", f, !0), C.onreadystatechange = function() {
          C.readyState == 4 && (C.status < 400 && C.responseText ? N(C.responseText) : C.status >= 400 ? v(i(C.status, C.statusText)) : v(o));
        }, C.send(null);
      }
      function c(f) {
        var N = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(f || "");
        if (N) {
          var v = Number(N[1]), C = N[2], g = N[3];
          return C ? g ? [v, Number(g)] : [v, void 0] : [v, v];
        }
      }
      t.hooks.add("before-highlightall", function(f) {
        f.selector += ", " + p;
      }), t.hooks.add("before-sanity-check", function(f) {
        var N = (
          /** @type {HTMLPreElement} */
          f.element
        );
        if (N.matches(p)) {
          f.code = "", N.setAttribute(a, l);
          var v = N.appendChild(document.createElement("CODE"));
          v.textContent = n;
          var C = N.getAttribute("data-src"), g = f.language;
          if (g === "none") {
            var x = (/\.(\w+)$/.exec(C) || [, "none"])[1];
            g = s[x] || x;
          }
          t.util.setLanguage(v, g), t.util.setLanguage(N, g);
          var b = t.plugins.autoloader;
          b && b.loadLanguages(g), m(
            C,
            function(A) {
              N.setAttribute(a, u);
              var w = c(N.getAttribute("data-range"));
              if (w) {
                var M = A.split(/\r\n?|\n/g), y = w[0], E = w[1] == null ? M.length : w[1];
                y < 0 && (y += M.length), y = Math.max(0, Math.min(y - 1, M.length)), E < 0 && (E += M.length), E = Math.max(0, Math.min(E, M.length)), A = M.slice(y, E).join(`
`), N.hasAttribute("data-start") || N.setAttribute("data-start", String(y + 1));
              }
              v.textContent = A, t.highlightElement(v);
            },
            function(A) {
              N.setAttribute(a, d), v.textContent = A;
            }
          );
        }
      }), t.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function(N) {
          for (var v = (N || document).querySelectorAll(p), C = 0, g; g = v[C++]; )
            t.highlightElement(g);
        }
      };
      var h = !1;
      t.fileHighlight = function() {
        h || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), h = !0), t.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    }();
  }(Bo)), Bo.exports;
}
var hl = {}, fl;
function Lu() {
  return fl || (fl = 1, Prism.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: !0,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  }), hl;
}
var ml = {}, gl;
function ku() {
  return gl || (gl = 1, Prism.languages.javascript = Prism.languages.extend("clike", {
    "class-name": [
      Prism.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: !0
      }
    ],
    keyword: [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: !0
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: !0
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  }), Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, Prism.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: !0,
          alias: "language-regex",
          inside: Prism.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    parameter: [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: !0,
        inside: Prism.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: !0,
        inside: Prism.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: !0,
        inside: Prism.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: !0,
        inside: Prism.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  }), Prism.languages.insertBefore("javascript", "string", {
    hashbang: {
      pattern: /^#!.*/,
      greedy: !0,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: !0,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: Prism.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    }
  }), Prism.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: !0,
      alias: "property"
    }
  }), Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), Prism.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  )), Prism.languages.js = Prism.languages.javascript), ml;
}
var pl = {}, vl;
function Du() {
  return vl || (vl = 1, Prism.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: !0
              }
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function(r) {
    r.type === "entity" && (r.attributes.title = r.content.replace(/&amp;/, "&"));
  }), Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function(e, t) {
      var n = {};
      n["language-" + t] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: Prism.languages[t]
      }, n.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var i = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: n
        }
      };
      i["language-" + t] = {
        pattern: /[\s\S]+/,
        inside: Prism.languages[t]
      };
      var o = {};
      o[e] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return e;
        }), "i"),
        lookbehind: !0,
        greedy: !0,
        inside: i
      }, Prism.languages.insertBefore("markup", "cdata", o);
    }
  }), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(r, e) {
      Prism.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + r + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [e, "language-" + e],
                inside: Prism.languages[e]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml), pl;
}
var xl = {}, Nl;
function $u() {
  return Nl || (Nl = 1, function(r) {
    var e = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
    function t(d) {
      return d = d.replace(/<inner>/g, function() {
        return e;
      }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + d + ")");
    }
    var n = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, i = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
      return n;
    }), o = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
    r.languages.markdown = r.languages.extend("markup", {}), r.languages.insertBefore("markdown", "prolog", {
      "front-matter-block": {
        pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          punctuation: /^---|---$/,
          "front-matter": {
            pattern: /\S+(?:\s+\S+)*/,
            alias: ["yaml", "language-yaml"],
            inside: r.languages.yaml
          }
        }
      },
      blockquote: {
        // > ...
        pattern: /^>(?:[\t ]*>)*/m,
        alias: "punctuation"
      },
      table: {
        pattern: RegExp("^" + i + o + "(?:" + i + ")*", "m"),
        inside: {
          "table-data-rows": {
            pattern: RegExp("^(" + i + o + ")(?:" + i + ")*$"),
            lookbehind: !0,
            inside: {
              "table-data": {
                pattern: RegExp(n),
                inside: r.languages.markdown
              },
              punctuation: /\|/
            }
          },
          "table-line": {
            pattern: RegExp("^(" + i + ")" + o + "$"),
            lookbehind: !0,
            inside: {
              punctuation: /\||:?-{3,}:?/
            }
          },
          "table-header-row": {
            pattern: RegExp("^" + i + "$"),
            inside: {
              "table-header": {
                pattern: RegExp(n),
                alias: "important",
                inside: r.languages.markdown
              },
              punctuation: /\|/
            }
          }
        }
      },
      code: [
        {
          // Prefixed by 4 spaces or 1 tab and preceded by an empty line
          pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
          lookbehind: !0,
          alias: "keyword"
        },
        {
          // ```optional language
          // code block
          // ```
          pattern: /^```[\s\S]*?^```$/m,
          greedy: !0,
          inside: {
            "code-block": {
              pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
              lookbehind: !0
            },
            "code-language": {
              pattern: /^(```).+/,
              lookbehind: !0
            },
            punctuation: /```/
          }
        }
      ],
      title: [
        {
          // title 1
          // =======
          // title 2
          // -------
          pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
          alias: "important",
          inside: {
            punctuation: /==+$|--+$/
          }
        },
        {
          // # title 1
          // ###### title 6
          pattern: /(^\s*)#.+/m,
          lookbehind: !0,
          alias: "important",
          inside: {
            punctuation: /^#+|#+$/
          }
        }
      ],
      hr: {
        // ***
        // ---
        // * * *
        // -----------
        pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
        lookbehind: !0,
        alias: "punctuation"
      },
      list: {
        // * item
        // + item
        // - item
        // 1. item
        pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
        lookbehind: !0,
        alias: "punctuation"
      },
      "url-reference": {
        // [id]: http://example.com "Optional title"
        // [id]: http://example.com 'Optional title'
        // [id]: http://example.com (Optional title)
        // [id]: <http://example.com> "Optional title"
        pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
        inside: {
          variable: {
            pattern: /^(!?\[)[^\]]+/,
            lookbehind: !0
          },
          string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
          punctuation: /^[\[\]!:]|[<>]/
        },
        alias: "url"
      },
      bold: {
        // **strong**
        // __strong__
        // allow one nested instance of italic text using the same delimiter
        pattern: t(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: {
            pattern: /(^..)[\s\S]+(?=..$)/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          punctuation: /\*\*|__/
        }
      },
      italic: {
        // *em*
        // _em_
        // allow one nested instance of bold text using the same delimiter
        pattern: t(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: {
            pattern: /(^.)[\s\S]+(?=.$)/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          punctuation: /[*_]/
        }
      },
      strike: {
        // ~~strike through~~
        // ~strike~
        // eslint-disable-next-line regexp/strict
        pattern: t(/(~~?)(?:(?!~)<inner>)+\2/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: {
            pattern: /(^~~?)[\s\S]+(?=\1$)/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          punctuation: /~~?/
        }
      },
      "code-snippet": {
        // `code`
        // ``code``
        pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
        lookbehind: !0,
        greedy: !0,
        alias: ["code", "keyword"]
      },
      url: {
        // [example](http://example.com "Optional title")
        // [example][id]
        // [example] [id]
        pattern: t(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          operator: /^!/,
          content: {
            pattern: /(^\[)[^\]]+(?=\])/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          variable: {
            pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
            lookbehind: !0
          },
          url: {
            pattern: /(^\]\()[^\s)]+/,
            lookbehind: !0
          },
          string: {
            pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
            lookbehind: !0
          }
        }
      }
    }), ["url", "bold", "italic", "strike"].forEach(function(d) {
      ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(p) {
        d !== p && (r.languages.markdown[d].inside.content.inside[p] = r.languages.markdown[p]);
      });
    }), r.hooks.add("after-tokenize", function(d) {
      if (d.language !== "markdown" && d.language !== "md")
        return;
      function p(m) {
        if (!(!m || typeof m == "string"))
          for (var c = 0, h = m.length; c < h; c++) {
            var f = m[c];
            if (f.type !== "code") {
              p(f.content);
              continue;
            }
            var N = f.content[1], v = f.content[3];
            if (N && v && N.type === "code-language" && v.type === "code-block" && typeof N.content == "string") {
              var C = N.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
              C = (/[a-z][\w-]*/i.exec(C) || [""])[0].toLowerCase();
              var g = "language-" + C;
              v.alias ? typeof v.alias == "string" ? v.alias = [v.alias, g] : v.alias.push(g) : v.alias = [g];
            }
          }
      }
      p(d.tokens);
    }), r.hooks.add("wrap", function(d) {
      if (d.type === "code-block") {
        for (var p = "", m = 0, c = d.classes.length; m < c; m++) {
          var h = d.classes[m], f = /language-(.+)/.exec(h);
          if (f) {
            p = f[1];
            break;
          }
        }
        var N = r.languages[p];
        if (N)
          d.content = r.highlight(u(d.content), N, p);
        else if (p && p !== "none" && r.plugins.autoloader) {
          var v = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
          d.attributes.id = v, r.plugins.autoloader.loadLanguages(p, function() {
            var C = document.getElementById(v);
            C && (C.innerHTML = r.highlight(C.textContent, r.languages[p], p));
          });
        }
      }
    });
    var s = RegExp(r.languages.markup.tag.pattern.source, "gi"), a = {
      amp: "&",
      lt: "<",
      gt: ">",
      quot: '"'
    }, l = String.fromCodePoint || String.fromCharCode;
    function u(d) {
      var p = d.replace(s, "");
      return p = p.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m, c) {
        if (c = c.toLowerCase(), c[0] === "#") {
          var h;
          return c[1] === "x" ? h = parseInt(c.slice(2), 16) : h = Number(c.slice(1)), l(h);
        } else {
          var f = a[c];
          return f || m;
        }
      }), p;
    }
    r.languages.md = r.languages.markdown;
  }(Prism)), xl;
}
var _l = {}, Cl;
function Iu() {
  return Cl || (Cl = 1, Prism.languages.c = Prism.languages.extend("clike", {
    comment: {
      pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: !0
    },
    string: {
      // https://en.cppreference.com/w/c/language/string_literal
      pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
      lookbehind: !0
    },
    keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
  }), Prism.languages.insertBefore("c", "string", {
    char: {
      // https://en.cppreference.com/w/c/language/character_constant
      pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
      greedy: !0
    }
  }), Prism.languages.insertBefore("c", "string", {
    macro: {
      // allow for multiline macro definitions
      // spaces after the # character compile fine with gcc
      pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
      lookbehind: !0,
      greedy: !0,
      alias: "property",
      inside: {
        string: [
          {
            // highlight the path of the include statement as a string
            pattern: /^(#\s*include\s*)<[^>]+>/,
            lookbehind: !0
          },
          Prism.languages.c.string
        ],
        char: Prism.languages.c.char,
        comment: Prism.languages.c.comment,
        "macro-name": [
          {
            pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
            lookbehind: !0
          },
          {
            pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
            lookbehind: !0,
            alias: "function"
          }
        ],
        // highlight macro directives as keywords
        directive: {
          pattern: /^(#\s*)[a-z]+/,
          lookbehind: !0,
          alias: "keyword"
        },
        "directive-hash": /^#/,
        punctuation: /##|\\(?=[\r\n])/,
        expression: {
          pattern: /\S[\s\S]*/,
          inside: Prism.languages.c
        }
      }
    }
  }), Prism.languages.insertBefore("c", "function", {
    // highlight predefined macros as constants
    constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
  }), delete Prism.languages.c.boolean), _l;
}
var bl = {}, yl;
function Pu() {
  return yl || (yl = 1, function(r) {
    var e = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    r.languages.css = {
      comment: /\/\*[\s\S]*?\*\//,
      atrule: {
        pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + e.source + ")*?" + /(?:;|(?=\s*\{))/.source),
        inside: {
          rule: /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: !0,
            alias: "selector"
          },
          keyword: {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: !0
          }
          // See rest below
        }
      },
      url: {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp("\\burl\\((?:" + e.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: !0,
        inside: {
          function: /^url/i,
          punctuation: /^\(|\)$/,
          string: {
            pattern: RegExp("^" + e.source + "$"),
            alias: "url"
          }
        }
      },
      selector: {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + e.source + ")*(?=\\s*\\{)"),
        lookbehind: !0
      },
      string: {
        pattern: e,
        greedy: !0
      },
      property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: !0
      },
      important: /!important\b/i,
      function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: !0
      },
      punctuation: /[(){};:,]/
    }, r.languages.css.atrule.inside.rest = r.languages.css;
    var t = r.languages.markup;
    t && (t.tag.addInlined("style", "css"), t.tag.addAttribute("style", "css"));
  }(Prism)), bl;
}
var wl = {}, Tl;
function Fu() {
  return Tl || (Tl = 1, Prism.languages.objectivec = Prism.languages.extend("c", {
    string: {
      pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: !0
    },
    keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
    operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
  }), delete Prism.languages.objectivec["class-name"], Prism.languages.objc = Prism.languages.objectivec), wl;
}
var El = {}, Sl;
function Bu() {
  return Sl || (Sl = 1, Prism.languages.sql = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
      lookbehind: !0
    },
    variable: [
      {
        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
        greedy: !0
      },
      /@[\w.$]+/
    ],
    string: {
      pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
      greedy: !0,
      lookbehind: !0
    },
    identifier: {
      pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
      greedy: !0,
      lookbehind: !0,
      inside: {
        punctuation: /^`|`$/
      }
    },
    function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    // Should we highlight user defined functions too?
    keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
    number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    punctuation: /[;[\]()`,.]/
  }), El;
}
var Ol = {}, Ml;
function zu() {
  return Ml || (Ml = 1, Prism.languages.python = {
    comment: {
      pattern: /(^|[^\\])#.*/,
      lookbehind: !0,
      greedy: !0
    },
    "string-interpolation": {
      pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
      greedy: !0,
      inside: {
        interpolation: {
          // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
          pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
          lookbehind: !0,
          inside: {
            "format-spec": {
              pattern: /(:)[^:(){}]+(?=\}$)/,
              lookbehind: !0
            },
            "conversion-option": {
              pattern: /![sra](?=[:}]$)/,
              alias: "punctuation"
            },
            rest: null
          }
        },
        string: /[\s\S]+/
      }
    },
    "triple-quoted-string": {
      pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
      greedy: !0,
      alias: "string"
    },
    string: {
      pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
      greedy: !0
    },
    function: {
      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
      lookbehind: !0
    },
    "class-name": {
      pattern: /(\bclass\s+)\w+/i,
      lookbehind: !0
    },
    decorator: {
      pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
      lookbehind: !0,
      alias: ["annotation", "punctuation"],
      inside: {
        punctuation: /\./
      }
    },
    keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    boolean: /\b(?:False|None|True)\b/,
    number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
    operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    punctuation: /[{}[\];(),.:]/
  }, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python), Ol;
}
var Rl = {}, Al;
function Hu() {
  return Al || (Al = 1, function(r) {
    for (var e = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, t = 0; t < 2; t++)
      e = e.replace(/<self>/g, function() {
        return e;
      });
    e = e.replace(/<self>/g, function() {
      return /[^\s\S]/.source;
    }), r.languages.rust = {
      comment: [
        {
          pattern: RegExp(/(^|[^\\])/.source + e),
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
        greedy: !0
      },
      char: {
        pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
        greedy: !0
      },
      attribute: {
        pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
        greedy: !0,
        alias: "attr-name",
        inside: {
          string: null
          // see below
        }
      },
      // Closure params should not be confused with bitwise OR |
      "closure-params": {
        pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          "closure-punctuation": {
            pattern: /^\||\|$/,
            alias: "punctuation"
          },
          rest: null
          // see below
        }
      },
      "lifetime-annotation": {
        pattern: /'\w+/,
        alias: "symbol"
      },
      "fragment-specifier": {
        pattern: /(\$\w+:)[a-z]+/,
        lookbehind: !0,
        alias: "punctuation"
      },
      variable: /\$\w+/,
      "function-definition": {
        pattern: /(\bfn\s+)\w+/,
        lookbehind: !0,
        alias: "function"
      },
      "type-definition": {
        pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
        lookbehind: !0,
        alias: "class-name"
      },
      "module-declaration": [
        {
          pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
          lookbehind: !0,
          alias: "namespace"
        },
        {
          pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
          lookbehind: !0,
          alias: "namespace",
          inside: {
            punctuation: /::/
          }
        }
      ],
      keyword: [
        // https://github.com/rust-lang/reference/blob/master/src/keywords.md
        /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
        // primitives and str
        // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
        /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
      ],
      // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
      // and Rust's naming conventions recommend snake_case anyway.
      // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
      function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
      macro: {
        pattern: /\b\w+!/,
        alias: "property"
      },
      constant: /\b[A-Z_][A-Z_\d]+\b/,
      "class-name": /\b[A-Z]\w*\b/,
      namespace: {
        pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
        inside: {
          punctuation: /::/
        }
      },
      // Hex, oct, bin, dec numbers with visual separators and type suffix
      number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
      boolean: /\b(?:false|true)\b/,
      punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
      operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
    }, r.languages.rust["closure-params"].inside.rest = r.languages.rust, r.languages.rust.attribute.inside.string = r.languages.rust.string;
  }(Prism)), Rl;
}
var Ll = {}, kl;
function ju() {
  return kl || (kl = 1, Prism.languages.swift = {
    comment: {
      // Nested comments are supported up to 2 levels
      pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
      lookbehind: !0,
      greedy: !0
    },
    "string-literal": [
      // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
      {
        pattern: RegExp(
          /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\\($/,
            alias: "punctuation"
          },
          punctuation: /\\(?=[\r\n])/,
          string: /[\s\S]+/
        }
      },
      {
        pattern: RegExp(
          /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\#+\($/,
            alias: "punctuation"
          },
          string: /[\s\S]+/
        }
      }
    ],
    directive: {
      // directives with conditions
      pattern: RegExp(
        /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
      ),
      alias: "property",
      inside: {
        "directive-name": /^#\w+/,
        boolean: /\b(?:false|true)\b/,
        number: /\b\d+(?:\.\d+)*\b/,
        operator: /!|&&|\|\||[<>]=?/,
        punctuation: /[(),]/
      }
    },
    literal: {
      pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
      alias: "constant"
    },
    "other-directive": {
      pattern: /#\w+\b/,
      alias: "property"
    },
    attribute: {
      pattern: /@\w+/,
      alias: "atrule"
    },
    "function-definition": {
      pattern: /(\bfunc\s+)\w+/,
      lookbehind: !0,
      alias: "function"
    },
    label: {
      // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
      pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
      lookbehind: !0,
      alias: "important"
    },
    keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
    boolean: /\b(?:false|true)\b/,
    nil: {
      pattern: /\bnil\b/,
      alias: "constant"
    },
    "short-argument": /\$\d+\b/,
    omit: {
      pattern: /\b_\b/,
      alias: "keyword"
    },
    number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
    // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
    "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
    // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
    // This regex only supports ASCII operators.
    operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
    punctuation: /[{}[\]();,.:\\]/
  }, Prism.languages.swift["string-literal"].forEach(function(r) {
    r.inside.interpolation.inside = Prism.languages.swift;
  })), Ll;
}
var Dl = {}, $l;
function qu() {
  return $l || ($l = 1, function(r) {
    r.languages.typescript = r.languages.extend("javascript", {
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
        lookbehind: !0,
        greedy: !0,
        inside: null
        // see below
      },
      builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
    }), r.languages.typescript.keyword.push(
      /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
      // keywords that have to be followed by an identifier
      /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
      // This is for `import type *, {}`
      /\btype\b(?=\s*(?:[\{*]|$))/
    ), delete r.languages.typescript.parameter, delete r.languages.typescript["literal-property"];
    var e = r.languages.extend("typescript", {});
    delete e["class-name"], r.languages.typescript["class-name"].inside = e, r.languages.insertBefore("typescript", "function", {
      decorator: {
        pattern: /@[$\w\xA0-\uFFFF]+/,
        inside: {
          at: {
            pattern: /^@/,
            alias: "operator"
          },
          function: /^[\s\S]+/
        }
      },
      "generic-function": {
        // e.g. foo<T extends "bar" | "baz">( ...
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
        greedy: !0,
        inside: {
          function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
          generic: {
            pattern: /<[\s\S]+/,
            // everything after the first <
            alias: "class-name",
            inside: e
          }
        }
      }
    }), r.languages.ts = r.languages.typescript;
  }(Prism)), Dl;
}
var Il = {}, Pl;
function Ku() {
  return Pl || (Pl = 1, function(r) {
    var e = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/, t = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, n = {
      pattern: RegExp(/(^|[^\w.])/.source + t + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
      lookbehind: !0,
      inside: {
        namespace: {
          pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
          inside: {
            punctuation: /\./
          }
        },
        punctuation: /\./
      }
    };
    r.languages.java = r.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
        lookbehind: !0,
        greedy: !0
      },
      "class-name": [
        n,
        {
          // variables, parameters, and constructor references
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(^|[^\w.])/.source + t + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
          lookbehind: !0,
          inside: n.inside
        },
        {
          // class names based on keyword
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + t + /[A-Z]\w*\b/.source),
          lookbehind: !0,
          inside: n.inside
        }
      ],
      keyword: e,
      function: [
        r.languages.clike.function,
        {
          pattern: /(::\s*)[a-z_]\w*/,
          lookbehind: !0
        }
      ],
      number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
      operator: {
        pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
        lookbehind: !0
      },
      constant: /\b[A-Z][A-Z_\d]+\b/
    }), r.languages.insertBefore("java", "string", {
      "triple-quoted-string": {
        // http://openjdk.java.net/jeps/355#Description
        pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
        greedy: !0,
        alias: "string"
      },
      char: {
        pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
        greedy: !0
      }
    }), r.languages.insertBefore("java", "class-name", {
      annotation: {
        pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
        lookbehind: !0,
        alias: "punctuation"
      },
      generics: {
        pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
        inside: {
          "class-name": n,
          keyword: e,
          punctuation: /[<>(),.:]/,
          operator: /[?&|]/
        }
      },
      import: [
        {
          pattern: RegExp(/(\bimport\s+)/.source + t + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
          lookbehind: !0,
          inside: {
            namespace: n.inside.namespace,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        },
        {
          pattern: RegExp(/(\bimport\s+static\s+)/.source + t + /(?:\w+|\*)(?=\s*;)/.source),
          lookbehind: !0,
          alias: "static",
          inside: {
            namespace: n.inside.namespace,
            static: /\b\w+$/,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        }
      ],
      namespace: {
        pattern: RegExp(
          /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
            return e.source;
          })
        ),
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      }
    });
  }(Prism)), Il;
}
var Fl = {}, Bl;
function Uu() {
  return Bl || (Bl = 1, function(r) {
    var e = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, t = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
      return e.source;
    });
    r.languages.cpp = r.languages.extend("c", {
      "class-name": [
        {
          pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
            return e.source;
          })),
          lookbehind: !0
        },
        // This is intended to capture the class name of method implementations like:
        //   void foo::bar() const {}
        // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
        // it starts with an uppercase letter. This approximation should give decent results.
        /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
        // This will capture the class name before destructors like:
        //   Foo::~Foo() {}
        /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
        // This also intends to capture the class name of method implementations but here the class has template
        // parameters, so it can't be a namespace (until C++ adds generic namespaces).
        /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
      ],
      keyword: e,
      number: {
        pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
        greedy: !0
      },
      operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
      boolean: /\b(?:false|true)\b/
    }), r.languages.insertBefore("cpp", "string", {
      module: {
        // https://en.cppreference.com/w/cpp/language/modules
        pattern: RegExp(
          /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
          /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
          /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
            return t;
          }) + ")"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          string: /^[<"][\s\S]+/,
          operator: /:/,
          punctuation: /\./
        }
      },
      "raw-string": {
        pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
        alias: "string",
        greedy: !0
      }
    }), r.languages.insertBefore("cpp", "keyword", {
      "generic-function": {
        pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
        inside: {
          function: /^\w+/,
          generic: {
            pattern: /<[\s\S]+/,
            alias: "class-name",
            inside: r.languages.cpp
          }
        }
      }
    }), r.languages.insertBefore("cpp", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    }), r.languages.insertBefore("cpp", "class-name", {
      // the base clause is an optional list of parent classes
      // https://en.cppreference.com/w/cpp/language/class
      "base-clause": {
        pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
        lookbehind: !0,
        greedy: !0,
        inside: r.languages.extend("cpp", {})
      }
    }), r.languages.insertBefore("inside", "double-colon", {
      // All untokenized words that are not namespaces should be class names
      "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
    }, r.languages.cpp["base-clause"]);
  }(Prism)), Fl;
}
var Ft = {}, Xt = {}, zl;
function tf() {
  if (zl) return Xt;
  zl = 1;
  var r = Ve;
  const e = /* @__PURE__ */ new Map();
  function t(R) {
    let T = R;
    for (; T != null; ) {
      if (T.nodeType === Node.TEXT_NODE)
        return T;
      T = T.firstChild;
    }
    return null;
  }
  function n(R) {
    const T = R.parentNode;
    if (T == null)
      throw new Error("Should never happen");
    return [T, Array.from(T.childNodes).indexOf(R)];
  }
  function i(R, T, $, G, q) {
    const I = T.getKey(), Y = G.getKey(), D = document.createRange();
    let z = R.getElementByKey(I), X = R.getElementByKey(Y), Q = $, ne = q;
    if (r.$isTextNode(T) && (z = t(z)), r.$isTextNode(G) && (X = t(X)), T === void 0 || G === void 0 || z === null || X === null)
      return null;
    z.nodeName === "BR" && ([z, Q] = n(z)), X.nodeName === "BR" && ([X, ne] = n(X));
    const fe = z.firstChild;
    z === X && fe != null && fe.nodeName === "BR" && Q === 0 && ne === 0 && (ne = 1);
    try {
      D.setStart(z, Q), D.setEnd(X, ne);
    } catch {
      return null;
    }
    return D.collapsed && (Q !== ne || I !== Y) && (D.setStart(X, ne), D.setEnd(z, Q)), D;
  }
  function o(R, T) {
    const $ = R.getRootElement();
    if ($ === null)
      return [];
    const G = $.getBoundingClientRect(), q = getComputedStyle($), I = parseFloat(q.paddingLeft) + parseFloat(q.paddingRight), Y = Array.from(T.getClientRects());
    let D = Y.length;
    Y.sort((X, Q) => {
      const ne = X.top - Q.top;
      return Math.abs(ne) <= 3 ? X.left - Q.left : ne;
    });
    let z;
    for (let X = 0; X < D; X++) {
      const Q = Y[X], ne = z && z.top <= Q.top && z.top + z.height > Q.top && z.left + z.width > Q.left, fe = Q.width + I === G.width;
      if (ne || fe) {
        Y.splice(X--, 1), D--;
        continue;
      }
      z = Q;
    }
    return Y;
  }
  function s(R) {
    const T = {}, $ = R.split(";");
    for (const G of $)
      if (G !== "") {
        const [q, I] = G.split(/:([^]+)/);
        q && I && (T[q.trim()] = I.trim());
      }
    return T;
  }
  function a(R) {
    let T = e.get(R);
    return T === void 0 && (T = s(R), e.set(R, T)), Object.freeze(T), T;
  }
  function l(R) {
    let T = "";
    for (const $ in R)
      $ && (T += `${$}: ${R[$]};`);
    return T;
  }
  function u(R, T) {
    return R.__first = T.__first, R.__last = T.__last, R.__size = T.__size, R.__format = T.__format, R.__indent = T.__indent, R.__dir = T.__dir, R;
  }
  function d(R, T) {
    return R.__format = T.__format, R.__style = T.__style, R.__mode = T.__mode, R.__detail = T.__detail, R;
  }
  function p(R) {
    const $ = R.constructor.clone(R);
    return $.__parent = R.__parent, $.__next = R.__next, $.__prev = R.__prev, r.$isElementNode(R) && r.$isElementNode($) ? u($, R) : r.$isTextNode(R) && r.$isTextNode($) ? d($, R) : $;
  }
  function m(R, T) {
    const $ = R.getStartEndPoints();
    if (T.isSelected(R) && !T.isSegmented() && !T.isToken() && $ !== null) {
      const [G, q] = $, I = R.isBackward(), Y = G.getNode(), D = q.getNode(), z = T.is(Y), X = T.is(D);
      if (z || X) {
        const [Q, ne] = r.$getCharacterOffsets(R), fe = Y.is(D), _e = T.is(I ? D : Y), pe = T.is(I ? Y : D);
        let Ne = 0, B;
        if (fe)
          Ne = Q > ne ? ne : Q, B = Q > ne ? Q : ne;
        else if (_e)
          Ne = I ? ne : Q, B = void 0;
        else if (pe) {
          const F = I ? Q : ne;
          Ne = 0, B = F;
        }
        return T.__text = T.__text.slice(Ne, B), T;
      }
    }
    return T;
  }
  function c(R) {
    if (R.type === "text")
      return R.offset === R.getNode().getTextContentSize();
    const T = R.getNode();
    if (!r.$isElementNode(T))
      throw Error("isAtNodeEnd: node must be a TextNode or ElementNode");
    return R.offset === T.getChildrenSize();
  }
  function h(R, T, $) {
    let G = T.getNode(), q = $;
    if (r.$isElementNode(G)) {
      const I = G.getDescendantByIndex(T.offset);
      I !== null && (G = I);
    }
    for (; q > 0 && G !== null; ) {
      if (r.$isElementNode(G)) {
        const X = G.getLastDescendant();
        X !== null && (G = X);
      }
      let I = G.getPreviousSibling(), Y = 0;
      if (I === null) {
        let X = G.getParentOrThrow(), Q = X.getPreviousSibling();
        for (; Q === null; ) {
          if (X = X.getParent(), X === null) {
            I = null;
            break;
          }
          Q = X.getPreviousSibling();
        }
        X !== null && (Y = X.isInline() ? 0 : 2, I = Q);
      }
      let D = G.getTextContent();
      D === "" && r.$isElementNode(G) && !G.isInline() && (D = `

`);
      const z = D.length;
      if (!r.$isTextNode(G) || q >= z) {
        const X = G.getParent();
        G.remove(), X != null && X.getChildrenSize() === 0 && !r.$isRootNode(X) && X.remove(), q -= z + Y, G = I;
      } else {
        const X = G.getKey(), Q = R.getEditorState().read(() => {
          const _e = r.$getNodeByKey(X);
          return r.$isTextNode(_e) && _e.isSimpleText() ? _e.getTextContent() : null;
        }), ne = z - q, fe = D.slice(0, ne);
        if (Q !== null && Q !== D) {
          const _e = r.$getPreviousSelection();
          let pe = G;
          if (G.isSimpleText())
            G.setTextContent(Q);
          else {
            const Ne = r.$createTextNode(Q);
            G.replace(Ne), pe = Ne;
          }
          if (r.$isRangeSelection(_e) && _e.isCollapsed()) {
            const Ne = _e.anchor.offset;
            pe.select(Ne, Ne);
          }
        } else if (G.isSimpleText()) {
          const _e = T.key === X;
          let pe = T.offset;
          pe < q && (pe = z);
          const Ne = _e ? pe - q : 0, B = _e ? pe : ne;
          if (_e && Ne === 0) {
            const [F] = G.splitText(Ne, B);
            F.remove();
          } else {
            const [, F] = G.splitText(Ne, B);
            F.remove();
          }
        } else {
          const _e = r.$createTextNode(fe);
          G.replace(_e);
        }
        q = 0;
      }
    }
  }
  function f(R) {
    const T = R.getStyle(), $ = s(T);
    e.set(T, $);
  }
  function N(R, T) {
    const $ = a("getStyle" in R ? R.getStyle() : R.style), G = Object.entries(T).reduce((I, [Y, D]) => (D instanceof Function ? I[Y] = D($[Y]) : D === null ? delete I[Y] : I[Y] = D, I), {
      ...$
    }), q = l(G);
    R.setStyle(q), e.set(q, G);
  }
  function v(R, T) {
    const $ = R.getNodes(), G = $.length, q = R.getStartEndPoints();
    if (q === null)
      return;
    const [I, Y] = q, D = G - 1;
    let z = $[0], X = $[D];
    if (R.isCollapsed() && r.$isRangeSelection(R)) {
      N(R, T);
      return;
    }
    const ne = z.getTextContent().length, fe = Y.offset;
    let _e = I.offset;
    const pe = I.isBefore(Y);
    let Ne = pe ? _e : fe, B = pe ? fe : _e;
    const F = pe ? I.type : Y.type, k = pe ? Y.type : I.type, W = pe ? Y.key : I.key;
    if (r.$isTextNode(z) && Ne === ne) {
      const V = z.getNextSibling();
      r.$isTextNode(V) && (_e = 0, Ne = 0, z = V);
    }
    if ($.length === 1) {
      if (r.$isTextNode(z) && z.canHaveFormat()) {
        if (Ne = F === "element" ? 0 : _e > fe ? fe : _e, B = k === "element" ? ne : _e > fe ? _e : fe, Ne === B)
          return;
        if (Ne === 0 && B === ne)
          N(z, T), z.select(Ne, B);
        else {
          const V = z.splitText(Ne, B), te = Ne === 0 ? V[0] : V[1];
          N(te, T), te.select(0, B - Ne);
        }
      }
    } else {
      if (r.$isTextNode(z) && Ne < z.getTextContentSize() && z.canHaveFormat() && (Ne !== 0 && (z = z.splitText(Ne)[1], Ne = 0, I.set(z.getKey(), Ne, "text")), N(z, T)), r.$isTextNode(X) && X.canHaveFormat()) {
        const te = X.getTextContent().length;
        X.__key !== W && B !== 0 && (B = te), B !== te && ([X] = X.splitText(B)), (B !== 0 || k === "element") && N(X, T);
      }
      for (let V = 1; V < D; V++) {
        const te = $[V], ee = te.getKey();
        r.$isTextNode(te) && te.canHaveFormat() && ee !== z.getKey() && ee !== X.getKey() && !te.isToken() && N(te, T);
      }
    }
  }
  function C(R, T) {
    if (R === null)
      return;
    const $ = R.getStartEndPoints(), G = $ ? $[0] : null;
    if (G !== null && G.key === "root") {
      const Y = T(), D = r.$getRoot(), z = D.getFirstChild();
      z ? z.replace(Y, !0) : D.append(Y);
      return;
    }
    const q = R.getNodes(), I = G !== null ? H(G.getNode(), j) : !1;
    I && q.indexOf(I) === -1 && q.push(I);
    for (let Y = 0; Y < q.length; Y++) {
      const D = q[Y];
      if (!j(D))
        continue;
      if (!r.$isElementNode(D))
        throw Error("Expected block node to be an ElementNode");
      const z = T();
      z.setFormat(D.getFormatType()), z.setIndent(D.getIndent()), D.replace(z, !0);
    }
  }
  function g(R) {
    return R.getNode().isAttached();
  }
  function x(R) {
    let T = R;
    for (; T !== null && !r.$isRootOrShadowRoot(T); ) {
      const $ = T.getLatest(), G = T.getParent();
      $.getChildrenSize() === 0 && T.remove(!0), T = G;
    }
  }
  function b(R, T, $ = null) {
    const G = R.getStartEndPoints(), q = G ? G[0] : null, I = R.getNodes(), Y = I.length;
    if (q !== null && (Y === 0 || Y === 1 && q.type === "element" && q.getNode().getChildrenSize() === 0)) {
      const X = q.type === "text" ? q.getNode().getParentOrThrow() : q.getNode(), Q = X.getChildren();
      let ne = T();
      ne.setFormat(X.getFormatType()), ne.setIndent(X.getIndent()), Q.forEach((fe) => ne.append(fe)), $ && (ne = $.append(ne)), X.replace(ne);
      return;
    }
    let D = null, z = [];
    for (let X = 0; X < Y; X++) {
      const Q = I[X];
      r.$isRootOrShadowRoot(Q) ? (A(R, z, z.length, T, $), z = [], D = Q) : D === null || D !== null && r.$hasAncestor(Q, D) ? z.push(Q) : (A(R, z, z.length, T, $), z = [Q]);
    }
    A(R, z, z.length, T, $);
  }
  function A(R, T, $, G, q = null) {
    if (T.length === 0)
      return;
    const I = T[0], Y = /* @__PURE__ */ new Map(), D = [];
    let z = r.$isElementNode(I) ? I : I.getParentOrThrow();
    z.isInline() && (z = z.getParentOrThrow());
    let X = !1;
    for (; z !== null; ) {
      const pe = z.getPreviousSibling();
      if (pe !== null) {
        z = pe, X = !0;
        break;
      }
      if (z = z.getParentOrThrow(), r.$isRootOrShadowRoot(z))
        break;
    }
    const Q = /* @__PURE__ */ new Set();
    for (let pe = 0; pe < $; pe++) {
      const Ne = T[pe];
      r.$isElementNode(Ne) && Ne.getChildrenSize() === 0 && Q.add(Ne.getKey());
    }
    const ne = /* @__PURE__ */ new Set();
    for (let pe = 0; pe < $; pe++) {
      const Ne = T[pe];
      let B = Ne.getParent();
      if (B !== null && B.isInline() && (B = B.getParent()), B !== null && r.$isLeafNode(Ne) && !ne.has(Ne.getKey())) {
        const F = B.getKey();
        if (Y.get(F) === void 0) {
          const k = G();
          k.setFormat(B.getFormatType()), k.setIndent(B.getIndent()), D.push(k), Y.set(F, k), B.getChildren().forEach((W) => {
            k.append(W), ne.add(W.getKey()), r.$isElementNode(W) && W.getChildrenKeys().forEach((V) => ne.add(V));
          }), x(B);
        }
      } else if (Q.has(Ne.getKey())) {
        if (!r.$isElementNode(Ne))
          throw Error("Expected node in emptyElements to be an ElementNode");
        const F = G();
        F.setFormat(Ne.getFormatType()), F.setIndent(Ne.getIndent()), D.push(F), Ne.remove(!0);
      }
    }
    if (q !== null)
      for (let pe = 0; pe < D.length; pe++) {
        const Ne = D[pe];
        q.append(Ne);
      }
    let fe = null;
    if (r.$isRootOrShadowRoot(z))
      if (X)
        if (q !== null)
          z.insertAfter(q);
        else
          for (let pe = D.length - 1; pe >= 0; pe--) {
            const Ne = D[pe];
            z.insertAfter(Ne);
          }
      else {
        const pe = z.getFirstChild();
        if (r.$isElementNode(pe) && (z = pe), pe === null)
          if (q)
            z.append(q);
          else
            for (let Ne = 0; Ne < D.length; Ne++) {
              const B = D[Ne];
              z.append(B), fe = B;
            }
        else if (q !== null)
          pe.insertBefore(q);
        else
          for (let Ne = 0; Ne < D.length; Ne++) {
            const B = D[Ne];
            pe.insertBefore(B), fe = B;
          }
      }
    else if (q)
      z.insertAfter(q);
    else
      for (let pe = D.length - 1; pe >= 0; pe--) {
        const Ne = D[pe];
        z.insertAfter(Ne), fe = Ne;
      }
    const _e = r.$getPreviousSelection();
    r.$isRangeSelection(_e) && g(_e.anchor) && g(_e.focus) ? r.$setSelection(_e.clone()) : fe !== null ? fe.selectEnd() : R.dirty = !0;
  }
  function w(R, T) {
    const $ = r.$getAdjacentNode(R.focus, T);
    return r.$isDecoratorNode($) && !$.isIsolated() || r.$isElementNode($) && !$.isInline() && !$.canBeEmpty();
  }
  function M(R, T, $, G) {
    R.modify(T ? "extend" : "move", $, G);
  }
  function y(R) {
    const T = R.anchor.getNode();
    return (r.$isRootNode(T) ? T : T.getParentOrThrow()).getDirection() === "rtl";
  }
  function E(R, T, $) {
    const G = y(R);
    M(R, T, $ ? !G : G, "character");
  }
  function S(R) {
    const T = R.anchor, $ = R.focus, I = T.getNode().getTopLevelElementOrThrow().getParentOrThrow();
    let Y = I.getFirstDescendant(), D = I.getLastDescendant(), z = "element", X = "element", Q = 0;
    r.$isTextNode(Y) ? z = "text" : !r.$isElementNode(Y) && Y !== null && (Y = Y.getParentOrThrow()), r.$isTextNode(D) ? (X = "text", Q = D.getTextContentSize()) : !r.$isElementNode(D) && D !== null && (D = D.getParentOrThrow()), Y && D && (T.set(Y.getKey(), 0, z), $.set(D.getKey(), Q, X));
  }
  function P(R, T, $) {
    const G = R.getStyle(), q = a(G);
    return q !== null && q[T] || $;
  }
  function U(R, T, $ = "") {
    let G = null;
    const q = R.getNodes(), I = R.anchor, Y = R.focus, D = R.isBackward(), z = D ? Y.offset : I.offset, X = D ? Y.getNode() : I.getNode();
    if (R.isCollapsed() && R.style !== "") {
      const Q = R.style, ne = a(Q);
      if (ne !== null && T in ne)
        return ne[T];
    }
    for (let Q = 0; Q < q.length; Q++) {
      const ne = q[Q];
      if (!(Q !== 0 && z === 0 && ne.is(X)) && r.$isTextNode(ne)) {
        const fe = P(ne, T, $);
        if (G === null)
          G = fe;
        else if (G !== fe) {
          G = "";
          break;
        }
      }
    }
    return G === null ? $ : G;
  }
  function j(R) {
    if (r.$isDecoratorNode(R) || !r.$isElementNode(R) || r.$isRootOrShadowRoot(R))
      return !1;
    const T = R.getFirstChild(), $ = T === null || r.$isLineBreakNode(T) || r.$isTextNode(T) || T.isInline();
    return !R.isInline() && R.canBeEmpty() !== !1 && $;
  }
  function H(R, T) {
    let $ = R;
    for (; $ !== null && $.getParent() !== null && !T($); )
      $ = $.getParentOrThrow();
    return T($) ? $ : null;
  }
  return Xt.$addNodeStyle = f, Xt.$cloneWithProperties = p, Xt.$getSelectionStyleValueForProperty = U, Xt.$isAtNodeEnd = c, Xt.$isParentElementRTL = y, Xt.$moveCaretSelection = M, Xt.$moveCharacter = E, Xt.$patchStyleText = v, Xt.$selectAll = S, Xt.$setBlocksType = C, Xt.$shouldOverrideDefaultCharacterSelection = w, Xt.$sliceSelectedTextNodeContent = m, Xt.$wrapNodes = b, Xt.createDOMRange = i, Xt.createRectsFromDOMRange = o, Xt.getStyleObjectFromCSS = a, Xt.trimTextContentFromAnchor = h, Xt;
}
var Jt = {}, Hl;
function rf() {
  if (Hl) return Jt;
  Hl = 1;
  var r = Ve;
  let e = /* @__PURE__ */ new Map();
  function t(c) {
    for (; c != null; ) {
      if (c.nodeType === Node.TEXT_NODE) return c;
      c = c.firstChild;
    }
    return null;
  }
  function n(c) {
    let h = c.parentNode;
    if (h == null) throw Error("Should never happen");
    return [h, Array.from(h.childNodes).indexOf(c)];
  }
  function i(c) {
    let h = {};
    c = c.split(";");
    for (let f of c) if (f !== "") {
      let [N, v] = f.split(/:([^]+)/);
      N && v && (h[N.trim()] = v.trim());
    }
    return h;
  }
  function o(c) {
    let h = e.get(c);
    return h === void 0 && (h = i(c), e.set(c, h)), h;
  }
  function s(c) {
    let h = "";
    for (let f in c) f && (h += `${f}: ${c[f]};`);
    return h;
  }
  function a(c, h) {
    let f = o("getStyle" in c ? c.getStyle() : c.style);
    h = Object.entries(h).reduce((v, [C, g]) => (g instanceof Function ? v[C] = g(f[C]) : g === null ? delete v[C] : v[C] = g, v), { ...f });
    let N = s(h);
    c.setStyle(N), e.set(N, h);
  }
  function l(c) {
    for (; c !== null && !r.$isRootOrShadowRoot(c); ) {
      let h = c.getLatest(), f = c.getParent();
      h.getChildrenSize() === 0 && c.remove(!0), c = f;
    }
  }
  function u(c, h, f, N, v = null) {
    if (h.length !== 0) {
      var C = h[0], g = /* @__PURE__ */ new Map(), x = [];
      C = r.$isElementNode(C) ? C : C.getParentOrThrow(), C.isInline() && (C = C.getParentOrThrow());
      for (var b = !1; C !== null; ) {
        var A = C.getPreviousSibling();
        if (A !== null) {
          C = A, b = !0;
          break;
        }
        if (C = C.getParentOrThrow(), r.$isRootOrShadowRoot(C)) break;
      }
      A = /* @__PURE__ */ new Set();
      for (var w = 0; w < f; w++) {
        var M = h[w];
        r.$isElementNode(M) && M.getChildrenSize() === 0 && A.add(M.getKey());
      }
      var y = /* @__PURE__ */ new Set();
      for (w = 0; w < f; w++) {
        M = h[w];
        var E = M.getParent();
        if (E !== null && E.isInline() && (E = E.getParent()), E !== null && r.$isLeafNode(M) && !y.has(M.getKey())) {
          if (M = E.getKey(), g.get(M) === void 0) {
            let S = N();
            S.setFormat(E.getFormatType()), S.setIndent(E.getIndent()), x.push(S), g.set(M, S), E.getChildren().forEach((P) => {
              S.append(P), y.add(P.getKey()), r.$isElementNode(P) && P.getChildrenKeys().forEach((U) => y.add(U));
            }), l(E);
          }
        } else if (A.has(M.getKey())) {
          if (!r.$isElementNode(M)) throw Error("Expected node in emptyElements to be an ElementNode");
          E = N(), E.setFormat(M.getFormatType()), E.setIndent(M.getIndent()), x.push(E), M.remove(!0);
        }
      }
      if (v !== null) for (h = 0; h < x.length; h++) v.append(x[h]);
      if (h = null, r.$isRootOrShadowRoot(C)) if (b) if (v !== null) C.insertAfter(v);
      else for (v = x.length - 1; 0 <= v; v--) C.insertAfter(x[v]);
      else if (b = C.getFirstChild(), r.$isElementNode(b) && (C = b), b === null) if (v) C.append(v);
      else for (v = 0; v < x.length; v++) b = x[v], C.append(b), h = b;
      else if (v !== null) b.insertBefore(v);
      else for (C = 0; C < x.length; C++) v = x[C], b.insertBefore(v), h = v;
      else if (v) C.insertAfter(v);
      else for (v = x.length - 1; 0 <= v; v--) b = x[v], C.insertAfter(b), h = b;
      x = r.$getPreviousSelection(), r.$isRangeSelection(x) && x.anchor.getNode().isAttached() && x.focus.getNode().isAttached() ? r.$setSelection(x.clone()) : h !== null ? h.selectEnd() : c.dirty = !0;
    }
  }
  function d(c, h, f, N) {
    c.modify(h ? "extend" : "move", f, N);
  }
  function p(c) {
    return c = c.anchor.getNode(), (r.$isRootNode(c) ? c : c.getParentOrThrow()).getDirection() === "rtl";
  }
  function m(c) {
    if (r.$isDecoratorNode(c) || !r.$isElementNode(c) || r.$isRootOrShadowRoot(c)) return !1;
    var h = c.getFirstChild();
    return h = h === null || r.$isLineBreakNode(h) || r.$isTextNode(h) || h.isInline(), !c.isInline() && c.canBeEmpty() !== !1 && h;
  }
  return Jt.$addNodeStyle = function(c) {
    c = c.getStyle();
    let h = i(c);
    e.set(c, h);
  }, Jt.$cloneWithProperties = function(c) {
    let h = c.constructor.clone(c);
    return h.__parent = c.__parent, h.__next = c.__next, h.__prev = c.__prev, r.$isElementNode(c) && r.$isElementNode(h) ? (h.__first = c.__first, h.__last = c.__last, h.__size = c.__size, h.__format = c.__format, h.__indent = c.__indent, h.__dir = c.__dir, h) : (r.$isTextNode(c) && r.$isTextNode(h) && (h.__format = c.__format, h.__style = c.__style, h.__mode = c.__mode, h.__detail = c.__detail), h);
  }, Jt.$getSelectionStyleValueForProperty = function(c, h, f = "") {
    let N = null, v = c.getNodes();
    var C = c.anchor, g = c.focus, x = c.isBackward();
    let b = x ? g.offset : C.offset;
    if (C = x ? g.getNode() : C.getNode(), c.isCollapsed() && c.style !== "" && (c = o(c.style), c !== null && h in c)) return c[h];
    for (c = 0; c < v.length; c++) {
      var A = v[c];
      if ((c === 0 || b !== 0 || !A.is(C)) && r.$isTextNode(A)) {
        if (g = h, x = f, A = A.getStyle(), A = o(A), g = A !== null && A[g] || x, N === null) N = g;
        else if (N !== g) {
          N = "";
          break;
        }
      }
    }
    return N === null ? f : N;
  }, Jt.$isAtNodeEnd = function(c) {
    if (c.type === "text") return c.offset === c.getNode().getTextContentSize();
    let h = c.getNode();
    if (!r.$isElementNode(h)) throw Error("isAtNodeEnd: node must be a TextNode or ElementNode");
    return c.offset === h.getChildrenSize();
  }, Jt.$isParentElementRTL = p, Jt.$moveCaretSelection = d, Jt.$moveCharacter = function(c, h, f) {
    let N = p(c);
    d(c, h, f ? !N : N, "character");
  }, Jt.$patchStyleText = function(c, h) {
    var f = c.getNodes(), N = f.length, v = c.getStartEndPoints();
    if (v !== null) {
      var [C, g] = v;
      --N, v = f[0];
      var x = f[N];
      if (c.isCollapsed() && r.$isRangeSelection(c)) a(c, h);
      else {
        var b = v.getTextContent().length, A = g.offset, w = C.offset, M = C.isBefore(g), y = M ? w : A;
        c = M ? A : w;
        var E = M ? C.type : g.type, S = M ? g.type : C.type;
        if (M = M ? g.key : C.key, r.$isTextNode(v) && y === b) {
          let P = v.getNextSibling();
          r.$isTextNode(P) && (y = w = 0, v = P);
        }
        if (f.length === 1) r.$isTextNode(v) && v.canHaveFormat() && (y = E === "element" ? 0 : w > A ? A : w, c = S === "element" ? b : w > A ? w : A, y !== c && (y === 0 && c === b ? (a(v, h), v.select(y, c)) : (f = v.splitText(y, c), f = y === 0 ? f[0] : f[1], a(f, h), f.select(0, c - y))));
        else for (r.$isTextNode(v) && y < v.getTextContentSize() && v.canHaveFormat() && (y !== 0 && (v = v.splitText(y)[1], y = 0, C.set(v.getKey(), y, "text")), a(v, h)), r.$isTextNode(x) && x.canHaveFormat() && (y = x.getTextContent().length, x.__key !== M && c !== 0 && (c = y), c !== y && ([x] = x.splitText(c)), c === 0 && S !== "element" || a(x, h)), c = 1; c < N; c++) y = f[c], S = y.getKey(), r.$isTextNode(y) && y.canHaveFormat() && S !== v.getKey() && S !== x.getKey() && !y.isToken() && a(y, h);
      }
    }
  }, Jt.$selectAll = function(c) {
    let h = c.anchor;
    c = c.focus;
    var f = h.getNode().getTopLevelElementOrThrow().getParentOrThrow();
    let N = f.getFirstDescendant();
    f = f.getLastDescendant();
    let v = "element", C = "element", g = 0;
    r.$isTextNode(N) ? v = "text" : r.$isElementNode(N) || N === null || (N = N.getParentOrThrow()), r.$isTextNode(f) ? (C = "text", g = f.getTextContentSize()) : r.$isElementNode(f) || f === null || (f = f.getParentOrThrow()), N && f && (h.set(N.getKey(), 0, v), c.set(f.getKey(), g, C));
  }, Jt.$setBlocksType = function(c, h) {
    if (c !== null) {
      var f = c.getStartEndPoints();
      if (f = f ? f[0] : null, f !== null && f.key === "root") h = h(), c = r.$getRoot(), (f = c.getFirstChild()) ? f.replace(h, !0) : c.append(h);
      else {
        if (c = c.getNodes(), f !== null) {
          for (f = f.getNode(); f !== null && f.getParent() !== null && !m(f); ) f = f.getParentOrThrow();
          f = m(f) ? f : null;
        } else f = !1;
        for (f && c.indexOf(f) === -1 && c.push(f), f = 0; f < c.length; f++) {
          let N = c[f];
          if (!m(N)) continue;
          if (!r.$isElementNode(N)) throw Error("Expected block node to be an ElementNode");
          let v = h();
          v.setFormat(N.getFormatType()), v.setIndent(N.getIndent()), N.replace(v, !0);
        }
      }
    }
  }, Jt.$shouldOverrideDefaultCharacterSelection = function(c, h) {
    return c = r.$getAdjacentNode(c.focus, h), r.$isDecoratorNode(c) && !c.isIsolated() || r.$isElementNode(c) && !c.isInline() && !c.canBeEmpty();
  }, Jt.$sliceSelectedTextNodeContent = function(c, h) {
    var f = c.getStartEndPoints();
    if (h.isSelected(c) && !h.isSegmented() && !h.isToken() && f !== null) {
      let [x, b] = f;
      f = c.isBackward();
      var N = x.getNode(), v = b.getNode(), C = h.is(N), g = h.is(v);
      if (C || g) {
        let [A, w] = r.$getCharacterOffsets(c);
        c = N.is(v), C = h.is(f ? v : N), v = h.is(f ? N : v), N = 0, g = void 0, c ? (N = A > w ? w : A, g = A > w ? A : w) : C ? (N = f ? w : A, g = void 0) : v && (f = f ? A : w, N = 0, g = f), h.__text = h.__text.slice(N, g);
      }
    }
    return h;
  }, Jt.$wrapNodes = function(c, h, f = null) {
    var N = c.getStartEndPoints(), v = N ? N[0] : null;
    N = c.getNodes();
    let C = N.length;
    if (v !== null && (C === 0 || C === 1 && v.type === "element" && v.getNode().getChildrenSize() === 0)) {
      c = v.type === "text" ? v.getNode().getParentOrThrow() : v.getNode(), N = c.getChildren();
      let x = h();
      x.setFormat(c.getFormatType()), x.setIndent(c.getIndent()), N.forEach((b) => x.append(b)), f && (x = f.append(x)), c.replace(x);
    } else {
      v = null;
      var g = [];
      for (let x = 0; x < C; x++) {
        let b = N[x];
        r.$isRootOrShadowRoot(b) ? (u(c, g, g.length, h, f), g = [], v = b) : v === null || v !== null && r.$hasAncestor(b, v) ? g.push(b) : (u(c, g, g.length, h, f), g = [b]);
      }
      u(c, g, g.length, h, f);
    }
  }, Jt.createDOMRange = function(c, h, f, N, v) {
    let C = h.getKey(), g = N.getKey(), x = document.createRange(), b = c.getElementByKey(C);
    if (c = c.getElementByKey(g), r.$isTextNode(h) && (b = t(b)), r.$isTextNode(N) && (c = t(c)), h === void 0 || N === void 0 || b === null || c === null) return null;
    b.nodeName === "BR" && ([b, f] = n(b)), c.nodeName === "BR" && ([c, v] = n(c)), h = b.firstChild, b === c && h != null && h.nodeName === "BR" && f === 0 && v === 0 && (v = 1);
    try {
      x.setStart(b, f), x.setEnd(c, v);
    } catch {
      return null;
    }
    return !x.collapsed || f === v && C === g || (x.setStart(c, v), x.setEnd(
      b,
      f
    )), x;
  }, Jt.createRectsFromDOMRange = function(c, h) {
    var f = c.getRootElement();
    if (f === null) return [];
    c = f.getBoundingClientRect(), f = getComputedStyle(f), f = parseFloat(f.paddingLeft) + parseFloat(f.paddingRight), h = Array.from(h.getClientRects());
    let N = h.length;
    h.sort((C, g) => {
      let x = C.top - g.top;
      return 3 >= Math.abs(x) ? C.left - g.left : x;
    });
    let v;
    for (let C = 0; C < N; C++) {
      let g = h[C], x = g.width + f === c.width;
      v && v.top <= g.top && v.top + v.height > g.top && v.left + v.width > g.left || x ? (h.splice(C--, 1), N--) : v = g;
    }
    return h;
  }, Jt.getStyleObjectFromCSS = o, Jt.trimTextContentFromAnchor = function(c, h, f) {
    let N = h.getNode();
    if (r.$isElementNode(N)) {
      var v = N.getDescendantByIndex(h.offset);
      v !== null && (N = v);
    }
    for (; 0 < f && N !== null; ) {
      r.$isElementNode(N) && (v = N.getLastDescendant(), v !== null && (N = v));
      var C = N.getPreviousSibling(), g = 0;
      if (C === null) {
        v = N.getParentOrThrow();
        for (var x = v.getPreviousSibling(); x === null; ) {
          if (v = v.getParent(), v === null) {
            C = null;
            break;
          }
          x = v.getPreviousSibling();
        }
        v !== null && (g = v.isInline() ? 0 : 2, C = x);
      }
      if (x = N.getTextContent(), x === "" && r.$isElementNode(N) && !N.isInline() && (x = `

`), v = x.length, !r.$isTextNode(N) || f >= v) x = N.getParent(), N.remove(), x == null || x.getChildrenSize() !== 0 || r.$isRootNode(x) || x.remove(), f -= v + g, N = C;
      else {
        let b = N.getKey();
        g = c.getEditorState().read(() => {
          const w = r.$getNodeByKey(b);
          return r.$isTextNode(w) && w.isSimpleText() ? w.getTextContent() : null;
        }), C = v - f;
        let A = x.slice(0, C);
        g !== null && g !== x ? (f = r.$getPreviousSelection(), v = N, N.isSimpleText() ? N.setTextContent(g) : (v = r.$createTextNode(g), N.replace(v)), r.$isRangeSelection(f) && f.isCollapsed() && (f = f.anchor.offset, v.select(f, f))) : N.isSimpleText() ? (g = h.key === b, x = h.offset, x < f && (x = v), f = g ? x - f : 0, v = g ? x : C, g && f === 0 ? ([f] = N.splitText(f, v), f.remove()) : ([, f] = N.splitText(f, v), f.remove())) : (f = r.$createTextNode(A), N.replace(f)), f = 0;
      }
    }
  }, Jt;
}
var zo, jl;
function en() {
  return jl || (jl = 1, zo = process.env.NODE_ENV === "development" ? tf() : rf()), zo;
}
var ql;
function nf() {
  if (ql) return Ft;
  ql = 1;
  var r = en(), e = Ve;
  function t(...w) {
    return () => {
      w.forEach((M) => M());
    };
  }
  function n(w) {
    return `${w}px`;
  }
  const i = {
    attributes: !0,
    characterData: !0,
    childList: !0,
    subtree: !0
  };
  function o(w, M, y) {
    let E = null, S = null, P = null, U = [];
    const j = document.createElement("div");
    function H() {
      if (E === null)
        throw Error("Unexpected null rootDOMNode");
      if (S === null)
        throw Error("Unexpected null parentDOMNode");
      const {
        left: G,
        top: q
      } = E.getBoundingClientRect(), I = S, Y = r.createRectsFromDOMRange(w, M);
      j.isConnected || I.append(j);
      let D = !1;
      for (let z = 0; z < Y.length; z++) {
        const X = Y[z], Q = U[z] || document.createElement("div"), ne = Q.style;
        ne.position !== "absolute" && (ne.position = "absolute", D = !0);
        const fe = n(X.left - G);
        ne.left !== fe && (ne.left = fe, D = !0);
        const _e = n(X.top - q);
        ne.top !== _e && (Q.style.top = _e, D = !0);
        const pe = n(X.width);
        ne.width !== pe && (Q.style.width = pe, D = !0);
        const Ne = n(X.height);
        ne.height !== Ne && (Q.style.height = Ne, D = !0), Q.parentNode !== j && (j.append(Q), D = !0), U[z] = Q;
      }
      for (; U.length > Y.length; )
        U.pop();
      D && y(U);
    }
    function R() {
      S = null, E = null, P !== null && P.disconnect(), P = null, j.remove();
      for (const G of U)
        G.remove();
      U = [];
    }
    function T() {
      const G = w.getRootElement();
      if (G === null)
        return R();
      const q = G.parentElement;
      if (!(q instanceof HTMLElement))
        return R();
      R(), E = G, S = q, P = new MutationObserver((I) => {
        const Y = w.getRootElement(), D = Y && Y.parentElement;
        if (Y !== E || D !== S)
          return T();
        for (const z of I)
          if (!j.contains(z.target))
            return H();
      }), P.observe(q, i), H();
    }
    const $ = w.registerRootListener(T);
    return () => {
      $(), R();
    };
  }
  function s(w, M) {
    let y = null, E = null, S = null, P = null, U = () => {
    };
    function j(H) {
      H.read(() => {
        const R = e.$getSelection();
        if (!e.$isRangeSelection(R)) {
          y = null, E = null, S = null, P = null, U(), U = () => {
          };
          return;
        }
        const {
          anchor: T,
          focus: $
        } = R, G = T.getNode(), q = G.getKey(), I = T.offset, Y = $.getNode(), D = Y.getKey(), z = $.offset, X = w.getElementByKey(q), Q = w.getElementByKey(D), ne = y === null || X === null || I !== E || q !== y.getKey() || G !== y && (!(y instanceof e.TextNode) || G.updateDOM(y, X, w._config)), fe = S === null || Q === null || z !== P || D !== S.getKey() || Y !== S && (!(S instanceof e.TextNode) || Y.updateDOM(S, Q, w._config));
        if (ne || fe) {
          const _e = w.getElementByKey(T.getNode().getKey()), pe = w.getElementByKey($.getNode().getKey());
          if (_e !== null && pe !== null && _e.tagName === "SPAN" && pe.tagName === "SPAN") {
            const Ne = document.createRange();
            let B, F, k, W;
            $.isBefore(T) ? (B = pe, F = $.offset, k = _e, W = T.offset) : (B = _e, F = T.offset, k = pe, W = $.offset);
            const V = B.firstChild;
            if (V === null)
              throw Error("Expected text node to be first child of span");
            const te = k.firstChild;
            if (te === null)
              throw Error("Expected text node to be first child of span");
            Ne.setStart(V, F), Ne.setEnd(te, W), U(), U = o(w, Ne, (ee) => {
              for (const ue of ee) {
                const xe = ue.style;
                xe.background !== "Highlight" && (xe.background = "Highlight"), xe.color !== "HighlightText" && (xe.color = "HighlightText"), xe.zIndex !== "-1" && (xe.zIndex = "-1"), xe.pointerEvents !== "none" && (xe.pointerEvents = "none"), xe.marginTop !== n(-1.5) && (xe.marginTop = n(-1.5)), xe.paddingTop !== n(4) && (xe.paddingTop = n(4)), xe.paddingBottom !== n(0) && (xe.paddingBottom = n(0));
              }
              M !== void 0 && M(ee);
            });
          }
        }
        y = G, E = I, S = Y, P = z;
      });
    }
    return j(w.getEditorState()), t(w.registerUpdateListener(({
      editorState: H
    }) => j(H)), U, () => {
      U();
    });
  }
  function a(w, ...M) {
    M.forEach((y) => {
      if (typeof y == "string") {
        const E = y.split(" ").filter((S) => S !== "");
        w.classList.add(...E);
      }
    });
  }
  function l(w, ...M) {
    M.forEach((y) => {
      typeof y == "string" && w.classList.remove(...y.split(" "));
    });
  }
  function u(w, M) {
    for (const y of M)
      if (w.type.startsWith(y))
        return !0;
    return !1;
  }
  function d(w, M) {
    const y = w[Symbol.iterator]();
    return new Promise((E, S) => {
      const P = [], U = () => {
        const {
          done: j,
          value: H
        } = y.next();
        if (j)
          return E(P);
        const R = new FileReader();
        R.addEventListener("error", S), R.addEventListener("load", () => {
          const T = R.result;
          typeof T == "string" && P.push({
            file: H,
            result: T
          }), U();
        }), u(H, M) ? R.readAsDataURL(H) : U();
      };
      U();
    });
  }
  function p(w, M) {
    const y = [], E = (w || e.$getRoot()).getLatest(), S = M || (e.$isElementNode(E) ? E.getLastDescendant() : E);
    let P = E, U = m(P);
    for (; P !== null && !P.is(S); )
      if (y.push({
        depth: U,
        node: P
      }), e.$isElementNode(P) && P.getChildrenSize() > 0)
        P = P.getFirstChild(), U++;
      else {
        let j = null;
        for (; j === null && P !== null; )
          j = P.getNextSibling(), j === null ? (P = P.getParent(), U--) : P = j;
      }
    return P !== null && P.is(S) && y.push({
      depth: U,
      node: P
    }), y;
  }
  function m(w) {
    let M = w, y = 0;
    for (; (M = M.getParent()) !== null; )
      y++;
    return y;
  }
  function c(w, M) {
    let y = w;
    for (; y != null; ) {
      if (y instanceof M)
        return y;
      y = y.getParent();
    }
    return null;
  }
  function h(w) {
    const M = f(w, (y) => e.$isElementNode(y) && !y.isInline());
    if (!e.$isElementNode(M))
      throw Error(`Expected node ${w.__key} to have closest block element node.`);
    return M;
  }
  const f = (w, M) => {
    let y = w;
    for (; y !== e.$getRoot() && y != null; ) {
      if (M(y))
        return y;
      y = y.getParent();
    }
    return null;
  };
  function N(w, M, y, E) {
    const S = (j) => j instanceof M, P = (j) => {
      const H = j.getChildren();
      for (let $ = 0; $ < H.length; $++) {
        const G = H[$];
        if (S(G))
          return null;
      }
      let R = j, T = j;
      for (; R !== null; )
        if (T = R, R = R.getParent(), S(R))
          return {
            child: T,
            parent: R
          };
      return null;
    }, U = (j) => {
      const H = P(j);
      if (H !== null) {
        const {
          child: R,
          parent: T
        } = H;
        if (R.is(j)) {
          E(T, j);
          const $ = R.getNextSiblings(), G = $.length;
          if (T.insertAfter(R), G !== 0) {
            const q = y(T);
            R.insertAfter(q);
            for (let I = 0; I < G; I++)
              q.append($[I]);
          }
          !T.canBeEmpty() && T.getChildrenSize() === 0 && T.remove();
        }
      }
    };
    return w.registerNodeTransform(M, U);
  }
  function v(w, M) {
    const E = /* @__PURE__ */ new Map(), S = w._pendingEditorState;
    for (const [U, j] of M._nodeMap) {
      const H = r.$cloneWithProperties(j);
      if (e.$isTextNode(H)) {
        if (!e.$isTextNode(j))
          throw Error("Expected node be a TextNode");
        H.__text = j.__text;
      }
      E.set(U, H);
    }
    S && (S._nodeMap = E), w._dirtyType = 2;
    const P = M._selection;
    e.$setSelection(P === null ? null : P.clone());
  }
  function C(w) {
    const M = e.$getSelection() || e.$getPreviousSelection();
    if (e.$isRangeSelection(M)) {
      const {
        focus: y
      } = M, E = y.getNode(), S = y.offset;
      if (e.$isRootOrShadowRoot(E)) {
        const P = E.getChildAtIndex(S);
        P == null ? E.append(w) : P.insertBefore(w), w.selectNext();
      } else {
        let P, U;
        e.$isTextNode(E) ? (P = E.getParentOrThrow(), U = E.getIndexWithinParent(), S > 0 && (U += 1, E.splitText(S))) : (P = E, U = S);
        const [, j] = e.$splitNode(P, U);
        j.insertBefore(w), j.selectStart();
      }
    } else {
      if (M != null) {
        const E = M.getNodes();
        E[E.length - 1].getTopLevelElementOrThrow().insertAfter(w);
      } else
        e.$getRoot().append(w);
      const y = e.$createParagraphNode();
      w.insertAfter(y), y.select();
    }
    return w.getLatest();
  }
  function g(w, M) {
    const y = M();
    return w.replace(y), y.append(w), y;
  }
  function x(w, M) {
    return w !== null ? Object.getPrototypeOf(w).constructor.name === M.name : !1;
  }
  function b(w, M) {
    const y = [];
    for (let E = 0; E < w.length; E++) {
      const S = M(w[E]);
      S !== null && y.push(S);
    }
    return y;
  }
  function A(w, M) {
    const y = w.getFirstChild();
    y !== null ? y.insertBefore(M) : w.append(M);
  }
  return Ft.$splitNode = e.$splitNode, Ft.isHTMLAnchorElement = e.isHTMLAnchorElement, Ft.isHTMLElement = e.isHTMLElement, Ft.$dfs = p, Ft.$filter = b, Ft.$findMatchingParent = f, Ft.$getNearestBlockElementAncestorOrThrow = h, Ft.$getNearestNodeOfType = c, Ft.$insertFirst = A, Ft.$insertNodeToNearestRoot = C, Ft.$restoreEditorState = v, Ft.$wrapNodeInElement = g, Ft.addClassNamesToElement = a, Ft.isMimeType = u, Ft.markSelection = s, Ft.mediaFileReader = d, Ft.mergeRegister = t, Ft.objectKlassEquals = x, Ft.positionNodeOnRange = o, Ft.registerNestedElementResolver = N, Ft.removeClassNamesFromElement = l, Ft;
}
var Bt = {}, Kl;
function of() {
  if (Kl) return Bt;
  Kl = 1;
  var r = en(), e = Ve;
  function t(l) {
    let u = new URLSearchParams();
    u.append("code", l);
    for (let d = 1; d < arguments.length; d++) u.append("v", arguments[d]);
    throw Error(`Minified Lexical error #${l}; visit https://lexical.dev/docs/error?${u} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  function n(...l) {
    return () => {
      l.forEach((u) => u());
    };
  }
  let i = { attributes: !0, characterData: !0, childList: !0, subtree: !0 };
  function o(l, u, d) {
    function p() {
      if (h === null) throw Error("Unexpected null rootDOMNode");
      if (f === null) throw Error("Unexpected null parentDOMNode");
      let { left: x, top: b } = h.getBoundingClientRect();
      var A = f;
      let w = r.createRectsFromDOMRange(l, u);
      C.isConnected || A.append(C), A = !1;
      for (let E = 0; E < w.length; E++) {
        var M = w[E];
        let S = v[E] || document.createElement("div"), P = S.style;
        P.position !== "absolute" && (P.position = "absolute", A = !0);
        var y = `${M.left - x}px`;
        P.left !== y && (P.left = y, A = !0), y = `${M.top - b}px`, P.top !== y && (S.style.top = y, A = !0), y = `${M.width}px`, P.width !== y && (S.style.width = y, A = !0), M = `${M.height}px`, P.height !== M && (S.style.height = M, A = !0), S.parentNode !== C && (C.append(S), A = !0), v[E] = S;
      }
      for (; v.length > w.length; ) v.pop();
      A && d(v);
    }
    function m() {
      h = f = null, N !== null && N.disconnect(), N = null, C.remove();
      for (let x of v) x.remove();
      v = [];
    }
    function c() {
      let x = l.getRootElement();
      if (x === null) return m();
      let b = x.parentElement;
      if (!(b instanceof HTMLElement)) return m();
      m(), h = x, f = b, N = new MutationObserver((A) => {
        let w = l.getRootElement(), M = w && w.parentElement;
        if (w !== h || M !== f) return c();
        for (let y of A) if (!C.contains(y.target)) return p();
      }), N.observe(b, i), p();
    }
    let h = null, f = null, N = null, v = [], C = document.createElement("div"), g = l.registerRootListener(c);
    return () => {
      g(), m();
    };
  }
  function s(l, u) {
    for (let d of u) if (l.type.startsWith(d)) return !0;
    return !1;
  }
  let a = (l, u) => {
    for (; l !== e.$getRoot() && l != null; ) {
      if (u(l)) return l;
      l = l.getParent();
    }
    return null;
  };
  return Bt.$splitNode = e.$splitNode, Bt.isHTMLAnchorElement = e.isHTMLAnchorElement, Bt.isHTMLElement = e.isHTMLElement, Bt.$dfs = function(l, u) {
    let d = [];
    l = (l || e.$getRoot()).getLatest(), u = u || (e.$isElementNode(l) ? l.getLastDescendant() : l);
    for (var p = l, m = 0; (p = p.getParent()) !== null; ) m++;
    for (p = m; l !== null && !l.is(u); ) if (d.push({ depth: p, node: l }), e.$isElementNode(l) && 0 < l.getChildrenSize()) l = l.getFirstChild(), p++;
    else for (m = null; m === null && l !== null; ) m = l.getNextSibling(), m === null ? (l = l.getParent(), p--) : l = m;
    return l !== null && l.is(u) && d.push({ depth: p, node: l }), d;
  }, Bt.$filter = function(l, u) {
    let d = [];
    for (let p = 0; p < l.length; p++) {
      let m = u(l[p]);
      m !== null && d.push(m);
    }
    return d;
  }, Bt.$findMatchingParent = a, Bt.$getNearestBlockElementAncestorOrThrow = function(l) {
    let u = a(l, (d) => e.$isElementNode(d) && !d.isInline());
    return e.$isElementNode(u) || t(4, l.__key), u;
  }, Bt.$getNearestNodeOfType = function(l, u) {
    for (; l != null; ) {
      if (l instanceof u) return l;
      l = l.getParent();
    }
    return null;
  }, Bt.$insertFirst = function(l, u) {
    let d = l.getFirstChild();
    d !== null ? d.insertBefore(u) : l.append(u);
  }, Bt.$insertNodeToNearestRoot = function(l) {
    var u = e.$getSelection() || e.$getPreviousSelection();
    if (e.$isRangeSelection(u)) {
      var { focus: d } = u;
      if (u = d.getNode(), d = d.offset, e.$isRootOrShadowRoot(u)) d = u.getChildAtIndex(d), d == null ? u.append(l) : d.insertBefore(l), l.selectNext();
      else {
        let p, m;
        e.$isTextNode(u) ? (p = u.getParentOrThrow(), m = u.getIndexWithinParent(), 0 < d && (m += 1, u.splitText(d))) : (p = u, m = d), [, u] = e.$splitNode(p, m), u.insertBefore(l), u.selectStart();
      }
    } else u != null ? (u = u.getNodes(), u[u.length - 1].getTopLevelElementOrThrow().insertAfter(l)) : e.$getRoot().append(l), u = e.$createParagraphNode(), l.insertAfter(u), u.select();
    return l.getLatest();
  }, Bt.$restoreEditorState = function(l, u) {
    let d = /* @__PURE__ */ new Map(), p = l._pendingEditorState;
    for (let [m, c] of u._nodeMap) {
      let h = r.$cloneWithProperties(c);
      if (e.$isTextNode(h)) {
        if (!e.$isTextNode(c)) throw Error("Expected node be a TextNode");
        h.__text = c.__text;
      }
      d.set(m, h);
    }
    p && (p._nodeMap = d), l._dirtyType = 2, l = u._selection, e.$setSelection(l === null ? null : l.clone());
  }, Bt.$wrapNodeInElement = function(l, u) {
    return u = u(), l.replace(u), u.append(l), u;
  }, Bt.addClassNamesToElement = function(l, ...u) {
    u.forEach((d) => {
      typeof d == "string" && (d = d.split(" ").filter((p) => p !== ""), l.classList.add(...d));
    });
  }, Bt.isMimeType = s, Bt.markSelection = function(l, u) {
    function d(N) {
      N.read(() => {
        var v = e.$getSelection();
        if (e.$isRangeSelection(v)) {
          var { anchor: C, focus: g } = v;
          v = C.getNode();
          var x = v.getKey(), b = C.offset, A = g.getNode(), w = A.getKey(), M = g.offset, y = l.getElementByKey(x), E = l.getElementByKey(w);
          if (x = p === null || y === null || b !== m || x !== p.getKey() || v !== p && (!(p instanceof e.TextNode) || v.updateDOM(p, y, l._config)), w = c === null || E === null || M !== h || w !== c.getKey() || A !== c && (!(c instanceof e.TextNode) || A.updateDOM(c, E, l._config)), x || w) {
            y = l.getElementByKey(C.getNode().getKey());
            var S = l.getElementByKey(g.getNode().getKey());
            if (y !== null && S !== null && y.tagName === "SPAN" && S.tagName === "SPAN") {
              if (w = document.createRange(), g.isBefore(C) ? (x = S, E = g.offset, S = y, y = C.offset) : (x = y, E = C.offset, y = g.offset), x = x.firstChild, x === null || (S = S.firstChild, S === null)) throw Error("Expected text node to be first child of span");
              w.setStart(x, E), w.setEnd(S, y), f(), f = o(l, w, (P) => {
                for (let U of P) {
                  let j = U.style;
                  j.background !== "Highlight" && (j.background = "Highlight"), j.color !== "HighlightText" && (j.color = "HighlightText"), j.zIndex !== "-1" && (j.zIndex = "-1"), j.pointerEvents !== "none" && (j.pointerEvents = "none"), j.marginTop !== "-1.5px" && (j.marginTop = "-1.5px"), j.paddingTop !== "4px" && (j.paddingTop = "4px"), j.paddingBottom !== "0px" && (j.paddingBottom = "0px");
                }
                u !== void 0 && u(P);
              });
            }
          }
          p = v, m = b, c = A, h = M;
        } else h = c = m = p = null, f(), f = () => {
        };
      });
    }
    let p = null, m = null, c = null, h = null, f = () => {
    };
    return d(l.getEditorState()), n(l.registerUpdateListener(({ editorState: N }) => d(N)), f, () => {
      f();
    });
  }, Bt.mediaFileReader = function(l, u) {
    let d = l[Symbol.iterator]();
    return new Promise((p, m) => {
      let c = [], h = () => {
        const { done: f, value: N } = d.next();
        if (f) return p(c);
        const v = new FileReader();
        v.addEventListener("error", m), v.addEventListener("load", () => {
          const C = v.result;
          typeof C == "string" && c.push({ file: N, result: C }), h();
        }), s(N, u) ? v.readAsDataURL(N) : h();
      };
      h();
    });
  }, Bt.mergeRegister = n, Bt.objectKlassEquals = function(l, u) {
    return l !== null ? Object.getPrototypeOf(l).constructor.name === u.name : !1;
  }, Bt.positionNodeOnRange = o, Bt.registerNestedElementResolver = function(l, u, d, p) {
    return l.registerNodeTransform(u, (m) => {
      e: {
        for (var c = m.getChildren(), h = 0; h < c.length; h++) if (c[h] instanceof u) {
          c = null;
          break e;
        }
        for (c = m; c !== null; ) if (h = c, c = c.getParent(), c instanceof u) {
          c = { child: h, parent: c };
          break e;
        }
        c = null;
      }
      if (c !== null) {
        const { child: f, parent: N } = c;
        if (f.is(m)) {
          if (p(N, m), m = f.getNextSiblings(), c = m.length, N.insertAfter(f), c !== 0) {
            h = d(N), f.insertAfter(h);
            for (let v = 0; v < c; v++) h.append(m[v]);
          }
          N.canBeEmpty() || N.getChildrenSize() !== 0 || N.remove();
        }
      }
    });
  }, Bt.removeClassNamesFromElement = function(l, ...u) {
    u.forEach((d) => {
      typeof d == "string" && l.classList.remove(...d.split(" "));
    });
  }, Bt;
}
var Ho, Ul;
function it() {
  return Ul || (Ul = 1, Ho = process.env.NODE_ENV === "development" ? nf() : of()), Ho;
}
var Yl;
function af() {
  if (Yl) return Kt;
  Yl = 1;
  var r = Au();
  Lu(), ku(), Du(), $u(), Iu(), Pu(), Fu(), Bu(), zu(), Hu(), ju(), qu(), Ku(), Uu();
  var e = it(), t = Ve;
  const n = (k) => k != null && r.languages.hasOwnProperty(k) ? k : void 0;
  function i(k, W) {
    for (const V of k.childNodes) {
      if (e.isHTMLElement(V) && V.tagName === W)
        return !0;
      i(V, W);
    }
    return !1;
  }
  const o = "data-highlight-language";
  class s extends t.ElementNode {
    /** @internal */
    static getType() {
      return "code";
    }
    static clone(W) {
      return new s(W.__language, W.__key);
    }
    constructor(W, V) {
      super(V), this.__language = n(W);
    }
    // View
    createDOM(W) {
      const V = document.createElement("code");
      e.addClassNamesToElement(V, W.theme.code), V.setAttribute("spellcheck", "false");
      const te = this.getLanguage();
      return te && V.setAttribute(o, te), V;
    }
    updateDOM(W, V, te) {
      const ee = this.__language, ue = W.__language;
      return ee ? ee !== ue && V.setAttribute(o, ee) : ue && V.removeAttribute(o), !1;
    }
    exportDOM() {
      const W = document.createElement("pre");
      W.setAttribute("spellcheck", "false");
      const V = this.getLanguage();
      return V && W.setAttribute(o, V), {
        element: W
      };
    }
    static importDOM() {
      return {
        // Typically <pre> is used for code blocks, and <code> for inline code styles
        // but if it's a multi line <code> we'll create a block. Pass through to
        // inline format handled by TextNode otherwise.
        code: (W) => W.textContent != null && (/\r?\n/.test(W.textContent) || i(W, "BR")) ? {
          conversion: u,
          priority: 1
        } : null,
        div: (W) => ({
          conversion: d,
          priority: 1
        }),
        pre: (W) => ({
          conversion: u,
          priority: 0
        }),
        table: (W) => v(W) ? {
          conversion: p,
          priority: 3
        } : null,
        td: (W) => {
          const V = W, te = V.closest("table");
          return N(V) ? {
            conversion: c,
            priority: 3
          } : te && v(te) ? {
            conversion: m,
            priority: 3
          } : null;
        },
        tr: (W) => {
          const te = W.closest("table");
          return te && v(te) ? {
            conversion: m,
            priority: 3
          } : null;
        }
      };
    }
    static importJSON(W) {
      const V = a(W.language);
      return V.setFormat(W.format), V.setIndent(W.indent), V.setDirection(W.direction), V;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        language: this.getLanguage(),
        type: "code",
        version: 1
      };
    }
    // Mutation
    insertNewAfter(W, V = !0) {
      const te = this.getChildren(), ee = te.length;
      if (ee >= 2 && te[ee - 1].getTextContent() === `
` && te[ee - 2].getTextContent() === `
` && W.isCollapsed() && W.anchor.key === this.__key && W.anchor.offset === ee) {
        te[ee - 1].remove(), te[ee - 2].remove();
        const me = t.$createParagraphNode();
        return this.insertAfter(me, V), me;
      }
      const {
        anchor: ue,
        focus: xe
      } = W, de = (ue.isBefore(xe) ? ue : xe).getNode();
      if (t.$isTextNode(de)) {
        let me = U(de);
        const we = [];
        for (; ; )
          if (t.$isTabNode(me))
            we.push(t.$createTabNode()), me = me.getNextSibling();
          else if (P(me)) {
            let Je = 0;
            const le = me.getTextContent(), Z = me.getTextContentSize();
            for (; Je < Z && le[Je] === " "; Je++) ;
            if (Je !== 0 && we.push(S(" ".repeat(Je))), Je !== Z)
              break;
            me = me.getNextSibling();
          } else
            break;
        const Ee = de.splitText(ue.offset)[0], Be = ue.offset === 0 ? 0 : 1, ke = Ee.getIndexWithinParent() + Be, at = de.getParentOrThrow(), Pt = [t.$createLineBreakNode(), ...we];
        at.splice(ke, 0, Pt);
        const Ct = we[we.length - 1];
        Ct ? Ct.select() : ue.offset === 0 ? Ee.selectPrevious() : Ee.getNextSibling().selectNext(0, 0);
      }
      if (l(de)) {
        const {
          offset: me
        } = W.anchor;
        de.splice(me, 0, [t.$createLineBreakNode()]), de.select(me + 1, me + 1);
      }
      return null;
    }
    canIndent() {
      return !1;
    }
    collapseAtStart() {
      const W = t.$createParagraphNode();
      return this.getChildren().forEach((te) => W.append(te)), this.replace(W), !0;
    }
    setLanguage(W) {
      const V = this.getWritable();
      V.__language = n(W);
    }
    getLanguage() {
      return this.getLatest().__language;
    }
  }
  function a(k) {
    return t.$applyNodeReplacement(new s(k));
  }
  function l(k) {
    return k instanceof s;
  }
  function u(k) {
    let W;
    return e.isHTMLElement(k) && (W = k.getAttribute(o)), {
      node: a(W)
    };
  }
  function d(k) {
    const W = k, V = h(W);
    return !V && !f(W) ? {
      node: null
    } : {
      after: (te) => {
        const ee = k.parentNode;
        return ee != null && k !== ee.lastChild && te.push(t.$createLineBreakNode()), te;
      },
      node: V ? a() : null
    };
  }
  function p() {
    return {
      node: a()
    };
  }
  function m() {
    return {
      node: null
    };
  }
  function c(k) {
    const W = k;
    return {
      after: (V) => (W.parentNode && W.parentNode.nextSibling && V.push(t.$createLineBreakNode()), V),
      node: null
    };
  }
  function h(k) {
    return k.style.fontFamily.match("monospace") !== null;
  }
  function f(k) {
    let W = k.parentElement;
    for (; W !== null; ) {
      if (h(W))
        return !0;
      W = W.parentElement;
    }
    return !1;
  }
  function N(k) {
    return k.classList.contains("js-file-line");
  }
  function v(k) {
    return k.classList.contains("js-file-line-container");
  }
  const C = "javascript", g = {
    c: "C",
    clike: "C-like",
    cpp: "C++",
    css: "CSS",
    html: "HTML",
    java: "Java",
    js: "JavaScript",
    markdown: "Markdown",
    objc: "Objective-C",
    plain: "Plain Text",
    py: "Python",
    rust: "Rust",
    sql: "SQL",
    swift: "Swift",
    typescript: "TypeScript",
    xml: "XML"
  }, x = {
    cpp: "cpp",
    java: "java",
    javascript: "js",
    md: "markdown",
    plaintext: "plain",
    python: "py",
    text: "plain",
    ts: "typescript"
  };
  function b(k) {
    return x[k] || k;
  }
  function A(k) {
    const W = b(k);
    return g[W] || W;
  }
  const w = () => C, M = () => Object.keys(r.languages).filter(
    // Prism has several language helpers mixed into languages object
    // so filtering them out here to get langs list
    (k) => typeof r.languages[k] != "function"
  ).sort();
  class y extends t.TextNode {
    /** @internal */
    constructor(W, V, te) {
      super(W, te), this.__highlightType = V;
    }
    static getType() {
      return "code-highlight";
    }
    static clone(W) {
      return new y(W.__text, W.__highlightType || void 0, W.__key);
    }
    getHighlightType() {
      return this.getLatest().__highlightType;
    }
    canHaveFormat() {
      return !1;
    }
    createDOM(W) {
      const V = super.createDOM(W), te = E(W.theme, this.__highlightType);
      return e.addClassNamesToElement(V, te), V;
    }
    updateDOM(W, V, te) {
      const ee = super.updateDOM(W, V, te), ue = E(te.theme, W.__highlightType), xe = E(te.theme, this.__highlightType);
      return ue !== xe && (ue && e.removeClassNamesFromElement(V, ue), xe && e.addClassNamesToElement(V, xe)), ee;
    }
    static importJSON(W) {
      const V = S(W.text, W.highlightType);
      return V.setFormat(W.format), V.setDetail(W.detail), V.setMode(W.mode), V.setStyle(W.style), V;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        highlightType: this.getHighlightType(),
        type: "code-highlight",
        version: 1
      };
    }
    // Prevent formatting (bold, underline, etc)
    setFormat(W) {
      return this;
    }
    isParentRequired() {
      return !0;
    }
    createParentElementNode() {
      return a();
    }
  }
  function E(k, W) {
    return W && k && k.codeHighlight && k.codeHighlight[W];
  }
  function S(k, W) {
    return t.$applyNodeReplacement(new y(k, W));
  }
  function P(k) {
    return k instanceof y;
  }
  function U(k) {
    let W = k, V = k;
    for (; P(V) || t.$isTabNode(V); )
      W = V, V = V.getPreviousSibling();
    return W;
  }
  function j(k) {
    let W = k, V = k;
    for (; P(V) || t.$isTabNode(V); )
      W = V, V = V.getNextSibling();
    return W;
  }
  const H = {
    defaultLanguage: C,
    tokenize(k, W) {
      return r.tokenize(k, r.languages[W || ""] || r.languages[this.defaultLanguage]);
    }
  };
  function R(k, W) {
    let V = null, te = null, ee = k, ue = W, xe = k.getTextContent();
    for (; ; ) {
      if (ue === 0) {
        if (ee = ee.getPreviousSibling(), ee === null)
          break;
        if (!(P(ee) || t.$isTabNode(ee) || t.$isLineBreakNode(ee)))
          throw Error("Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode");
        if (t.$isLineBreakNode(ee)) {
          V = {
            node: ee,
            offset: 1
          };
          break;
        }
        ue = Math.max(0, ee.getTextContentSize() - 1), xe = ee.getTextContent();
      } else
        ue--;
      const de = xe[ue];
      P(ee) && de !== " " && (te = {
        node: ee,
        offset: ue
      });
    }
    if (te !== null)
      return te;
    let ye = null;
    if (W < k.getTextContentSize())
      P(k) && (ye = k.getTextContent()[W]);
    else {
      const de = k.getNextSibling();
      P(de) && (ye = de.getTextContent()[0]);
    }
    if (ye !== null && ye !== " ")
      return V;
    {
      const de = T(k, W);
      return de !== null ? de : V;
    }
  }
  function T(k, W) {
    let V = k, te = W, ee = k.getTextContent(), ue = k.getTextContentSize();
    for (; ; ) {
      if (!P(V) || te === ue) {
        if (V = V.getNextSibling(), V === null || t.$isLineBreakNode(V))
          return null;
        P(V) && (te = 0, ee = V.getTextContent(), ue = V.getTextContentSize());
      }
      if (P(V)) {
        if (ee[te] !== " ")
          return {
            node: V,
            offset: te
          };
        te++;
      }
    }
  }
  function $(k) {
    const W = j(k);
    if (t.$isLineBreakNode(W))
      throw Error("Unexpected lineBreakNode in getEndOfCodeInLine");
    return W;
  }
  function G(k, W, V) {
    const te = k.getParent();
    l(te) ? Y(te, W, V) : P(k) && k.replace(t.$createTextNode(k.__text));
  }
  function q(k, W) {
    const V = W.getElementByKey(k.getKey());
    if (V === null)
      return;
    const te = k.getChildren(), ee = te.length;
    if (ee === V.__cachedChildrenLength)
      return;
    V.__cachedChildrenLength = ee;
    let ue = "1", xe = 1;
    for (let ye = 0; ye < ee; ye++)
      t.$isLineBreakNode(te[ye]) && (ue += `
` + ++xe);
    V.setAttribute("data-gutter", ue);
  }
  const I = /* @__PURE__ */ new Set();
  function Y(k, W, V) {
    const te = k.getKey();
    I.has(te) || (I.add(te), k.getLanguage() === void 0 && k.setLanguage(V.defaultLanguage), W.update(() => {
      z(te, () => {
        const ee = t.$getNodeByKey(te);
        if (!l(ee) || !ee.isAttached())
          return !1;
        const ue = ee.getTextContent(), xe = V.tokenize(ue, ee.getLanguage() || V.defaultLanguage), ye = D(xe), de = X(ee.getChildren(), ye), {
          from: me,
          to: we,
          nodesForReplacement: Ee
        } = de;
        return me !== we || Ee.length ? (k.splice(me, we - me, Ee), !0) : !1;
      });
    }, {
      onUpdate: () => {
        I.delete(te);
      },
      skipTransforms: !0
    }));
  }
  function D(k, W) {
    const V = [];
    for (const te of k)
      if (typeof te == "string") {
        const ee = te.split(/(\n|\t)/), ue = ee.length;
        for (let xe = 0; xe < ue; xe++) {
          const ye = ee[xe];
          ye === `
` || ye === `\r
` ? V.push(t.$createLineBreakNode()) : ye === "	" ? V.push(t.$createTabNode()) : ye.length > 0 && V.push(S(ye, W));
        }
      } else {
        const {
          content: ee
        } = te;
        typeof ee == "string" ? V.push(...D([ee], te.type)) : Array.isArray(ee) && V.push(...D(ee, te.type));
      }
    return V;
  }
  function z(k, W) {
    const V = t.$getNodeByKey(k);
    if (!l(V) || !V.isAttached())
      return;
    const te = t.$getSelection();
    if (!t.$isRangeSelection(te)) {
      W();
      return;
    }
    const ee = te.anchor, ue = ee.offset, xe = ee.type === "element" && t.$isLineBreakNode(V.getChildAtIndex(ee.offset - 1));
    let ye = 0;
    if (!xe) {
      const me = ee.getNode();
      ye = ue + me.getPreviousSiblings().reduce((we, Ee) => we + Ee.getTextContentSize(), 0);
    }
    if (W()) {
      if (xe) {
        ee.getNode().select(ue, ue);
        return;
      }
      V.getChildren().some((me) => {
        const we = t.$isTextNode(me);
        if (we || t.$isLineBreakNode(me)) {
          const Ee = me.getTextContentSize();
          if (we && Ee >= ye)
            return me.select(ye, ye), !0;
          ye -= Ee;
        }
        return !1;
      });
    }
  }
  function X(k, W) {
    let V = 0;
    for (; V < k.length && Q(k[V], W[V]); )
      V++;
    const te = k.length, ee = W.length, ue = Math.min(te, ee) - V;
    let xe = 0;
    for (; xe < ue; )
      if (xe++, !Q(k[te - xe], W[ee - xe])) {
        xe--;
        break;
      }
    const ye = V, de = te - xe, me = W.slice(V, ee - xe);
    return {
      from: ye,
      nodesForReplacement: me,
      to: de
    };
  }
  function Q(k, W) {
    return P(k) && P(W) && k.__text === W.__text && k.__highlightType === W.__highlightType || t.$isTabNode(k) && t.$isTabNode(W) || t.$isLineBreakNode(k) && t.$isLineBreakNode(W);
  }
  function ne(k) {
    if (!t.$isRangeSelection(k))
      return !1;
    const W = k.anchor.getNode(), V = k.focus.getNode();
    if (W.is(V) && l(W))
      return !0;
    const te = W.getParent();
    return l(te) && te.is(V.getParent());
  }
  function fe(k) {
    const W = k.getNodes(), V = [[]];
    if (W.length === 1 && l(W[0]))
      return V;
    let te = V[0];
    for (let ee = 0; ee < W.length; ee++) {
      const ue = W[ee];
      if (!(P(ue) || t.$isTabNode(ue) || t.$isLineBreakNode(ue)))
        throw Error("Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode");
      t.$isLineBreakNode(ue) ? ee !== 0 && te.length > 0 && (te = [], V.push(te)) : te.push(ue);
    }
    return V;
  }
  function _e(k) {
    const W = t.$getSelection();
    if (!t.$isRangeSelection(W) || !ne(W))
      return null;
    const V = k ? t.OUTDENT_CONTENT_COMMAND : t.INDENT_CONTENT_COMMAND, te = k ? t.OUTDENT_CONTENT_COMMAND : t.INSERT_TAB_COMMAND;
    if (fe(W).length > 1)
      return V;
    const xe = W.getNodes()[0];
    if (!(l(xe) || P(xe) || t.$isTabNode(xe) || t.$isLineBreakNode(xe)))
      throw Error("Expected selection firstNode to be CodeHighlightNode or TabNode");
    if (l(xe))
      return V;
    const ye = U(xe), de = j(xe), me = W.anchor, we = W.focus;
    let Ee, Be;
    return we.isBefore(me) ? (Ee = we, Be = me) : (Ee = me, Be = we), ye !== null && de !== null && Ee.key === ye.getKey() && Ee.offset === 0 && Be.key === de.getKey() && Be.offset === de.getTextContentSize() ? V : te;
  }
  function pe(k) {
    const W = t.$getSelection();
    if (!t.$isRangeSelection(W) || !ne(W))
      return !1;
    const V = fe(W), te = V.length;
    if (V.length > 1) {
      for (let ye = 0; ye < te; ye++) {
        const de = V[ye];
        if (de.length > 0) {
          let me = de[0];
          ye === 0 && (me = U(me)), me !== null && (k === t.INDENT_CONTENT_COMMAND ? me.insertBefore(t.$createTabNode()) : t.$isTabNode(me) && me.remove());
        }
      }
      return !0;
    }
    const ue = W.getNodes()[0];
    if (!(l(ue) || P(ue) || t.$isTabNode(ue) || t.$isLineBreakNode(ue)))
      throw Error("Expected selection firstNode to be CodeHighlightNode or CodeTabNode");
    if (l(ue))
      return k === t.INDENT_CONTENT_COMMAND && W.insertNodes([t.$createTabNode()]), !0;
    const xe = U(ue);
    if (xe === null)
      throw Error("Expected getFirstCodeNodeOfLine to return a valid Code Node");
    return k === t.INDENT_CONTENT_COMMAND ? t.$isLineBreakNode(xe) ? xe.insertAfter(t.$createTabNode()) : xe.insertBefore(t.$createTabNode()) : t.$isTabNode(xe) && xe.remove(), !0;
  }
  function Ne(k, W) {
    const V = t.$getSelection();
    if (!t.$isRangeSelection(V))
      return !1;
    const {
      anchor: te,
      focus: ee
    } = V, ue = te.offset, xe = ee.offset, ye = te.getNode(), de = ee.getNode(), me = k === t.KEY_ARROW_UP_COMMAND;
    if (!ne(V) || !(P(ye) || t.$isTabNode(ye)) || !(P(de) || t.$isTabNode(de)))
      return !1;
    if (!W.altKey) {
      if (V.isCollapsed()) {
        const Je = ye.getParentOrThrow();
        if (me && ue === 0 && ye.getPreviousSibling() === null) {
          if (Je.getPreviousSibling() === null)
            return Je.selectPrevious(), W.preventDefault(), !0;
        } else if (!me && ue === ye.getTextContentSize() && ye.getNextSibling() === null && Je.getNextSibling() === null)
          return Je.selectNext(), W.preventDefault(), !0;
      }
      return !1;
    }
    let we, Ee;
    if (ye.isBefore(de) ? (we = U(ye), Ee = j(de)) : (we = U(de), Ee = j(ye)), we == null || Ee == null)
      return !1;
    const Be = we.getNodesBetween(Ee);
    for (let Je = 0; Je < Be.length; Je++) {
      const le = Be[Je];
      if (!P(le) && !t.$isTabNode(le) && !t.$isLineBreakNode(le))
        return !1;
    }
    W.preventDefault(), W.stopPropagation();
    const ke = me ? we.getPreviousSibling() : Ee.getNextSibling();
    if (!t.$isLineBreakNode(ke))
      return !0;
    const at = me ? ke.getPreviousSibling() : ke.getNextSibling();
    if (at == null)
      return !0;
    const Pt = P(at) || t.$isTabNode(at) || t.$isLineBreakNode(at) ? me ? U(at) : j(at) : null;
    let Ct = Pt ?? at;
    return ke.remove(), Be.forEach((Je) => Je.remove()), k === t.KEY_ARROW_UP_COMMAND ? (Be.forEach((Je) => Ct.insertBefore(Je)), Ct.insertBefore(ke)) : (Ct.insertAfter(ke), Ct = ke, Be.forEach((Je) => {
      Ct.insertAfter(Je), Ct = Je;
    })), V.setTextNodeRange(ye, ue, de, xe), !0;
  }
  function B(k, W) {
    const V = t.$getSelection();
    if (!t.$isRangeSelection(V))
      return !1;
    const {
      anchor: te,
      focus: ee
    } = V, ue = te.getNode(), xe = ee.getNode(), ye = k === t.MOVE_TO_START;
    if (!(P(ue) || t.$isTabNode(ue)) || !(P(xe) || t.$isTabNode(xe)))
      return !1;
    if (ye) {
      const de = R(xe, ee.offset);
      if (de !== null) {
        const {
          node: me,
          offset: we
        } = de;
        t.$isLineBreakNode(me) ? me.selectNext(0, 0) : V.setTextNodeRange(me, we, me, we);
      } else
        xe.getParentOrThrow().selectStart();
    } else
      $(xe).select();
    return W.preventDefault(), W.stopPropagation(), !0;
  }
  function F(k, W) {
    if (!k.hasNodes([s, y]))
      throw new Error("CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor");
    return W == null && (W = H), e.mergeRegister(k.registerMutationListener(s, (V) => {
      k.update(() => {
        for (const [te, ee] of V)
          if (ee !== "destroyed") {
            const ue = t.$getNodeByKey(te);
            ue !== null && q(ue, k);
          }
      });
    }), k.registerNodeTransform(s, (V) => Y(V, k, W)), k.registerNodeTransform(t.TextNode, (V) => G(V, k, W)), k.registerNodeTransform(y, (V) => G(V, k, W)), k.registerCommand(t.KEY_TAB_COMMAND, (V) => {
      const te = _e(V.shiftKey);
      return te === null ? !1 : (V.preventDefault(), k.dispatchCommand(te, void 0), !0);
    }, t.COMMAND_PRIORITY_LOW), k.registerCommand(t.INSERT_TAB_COMMAND, () => {
      const V = t.$getSelection();
      return ne(V) ? (t.$insertNodes([t.$createTabNode()]), !0) : !1;
    }, t.COMMAND_PRIORITY_LOW), k.registerCommand(t.INDENT_CONTENT_COMMAND, (V) => pe(t.INDENT_CONTENT_COMMAND), t.COMMAND_PRIORITY_LOW), k.registerCommand(t.OUTDENT_CONTENT_COMMAND, (V) => pe(t.OUTDENT_CONTENT_COMMAND), t.COMMAND_PRIORITY_LOW), k.registerCommand(t.KEY_ARROW_UP_COMMAND, (V) => Ne(t.KEY_ARROW_UP_COMMAND, V), t.COMMAND_PRIORITY_LOW), k.registerCommand(t.KEY_ARROW_DOWN_COMMAND, (V) => Ne(t.KEY_ARROW_DOWN_COMMAND, V), t.COMMAND_PRIORITY_LOW), k.registerCommand(t.MOVE_TO_END, (V) => B(t.MOVE_TO_END, V), t.COMMAND_PRIORITY_LOW), k.registerCommand(t.MOVE_TO_START, (V) => B(t.MOVE_TO_START, V), t.COMMAND_PRIORITY_LOW));
  }
  return Kt.$createCodeHighlightNode = S, Kt.$createCodeNode = a, Kt.$isCodeHighlightNode = P, Kt.$isCodeNode = l, Kt.CODE_LANGUAGE_FRIENDLY_NAME_MAP = g, Kt.CODE_LANGUAGE_MAP = x, Kt.CodeHighlightNode = y, Kt.CodeNode = s, Kt.DEFAULT_CODE_LANGUAGE = C, Kt.PrismTokenizer = H, Kt.getCodeLanguages = M, Kt.getDefaultCodeLanguage = w, Kt.getEndOfCodeInLine = $, Kt.getFirstCodeNodeOfLine = U, Kt.getLanguageFriendlyName = A, Kt.getLastCodeNodeOfLine = j, Kt.getStartOfCodeInLine = R, Kt.normalizeCodeLang = b, Kt.registerCodeHighlighting = F, Kt;
}
var Ut = {}, Wl;
function sf() {
  if (Wl) return Ut;
  Wl = 1;
  var r = Au();
  Lu(), ku(), Du(), $u(), Iu(), Pu(), Fu(), Bu(), zu(), Hu(), ju(), qu(), Ku(), Uu();
  var e = it(), t = Ve;
  let n = (D) => D != null && r.languages.hasOwnProperty(D) ? D : void 0;
  function i(D, z) {
    for (let X of D.childNodes) {
      if (e.isHTMLElement(X) && X.tagName === z) return !0;
      i(X, z);
    }
    return !1;
  }
  class o extends t.ElementNode {
    static getType() {
      return "code";
    }
    static clone(z) {
      return new o(z.__language, z.__key);
    }
    constructor(z, X) {
      super(X), this.__language = n(z);
    }
    createDOM(z) {
      let X = document.createElement("code");
      return e.addClassNamesToElement(X, z.theme.code), X.setAttribute("spellcheck", "false"), (z = this.getLanguage()) && X.setAttribute("data-highlight-language", z), X;
    }
    updateDOM(z, X) {
      let Q = this.__language;
      return z = z.__language, Q ? Q !== z && X.setAttribute("data-highlight-language", Q) : z && X.removeAttribute("data-highlight-language"), !1;
    }
    exportDOM() {
      let z = document.createElement("pre");
      z.setAttribute("spellcheck", "false");
      let X = this.getLanguage();
      return X && z.setAttribute("data-highlight-language", X), { element: z };
    }
    static importDOM() {
      return { code: (z) => z.textContent != null && (/\r?\n/.test(z.textContent) || i(z, "BR")) ? { conversion: l, priority: 1 } : null, div: () => ({ conversion: u, priority: 1 }), pre: () => ({ conversion: l, priority: 0 }), table: (z) => h(z) ? { conversion: d, priority: 3 } : null, td: (z) => {
        let X = z.closest("table");
        return z.classList.contains("js-file-line") ? { conversion: m, priority: 3 } : X && h(X) ? { conversion: p, priority: 3 } : null;
      }, tr: (z) => (z = z.closest("table")) && h(z) ? { conversion: p, priority: 3 } : null };
    }
    static importJSON(z) {
      let X = s(z.language);
      return X.setFormat(z.format), X.setIndent(z.indent), X.setDirection(z.direction), X;
    }
    exportJSON() {
      return { ...super.exportJSON(), language: this.getLanguage(), type: "code", version: 1 };
    }
    insertNewAfter(z, X = !0) {
      var Q = this.getChildren(), ne = Q.length;
      if (2 <= ne && Q[ne - 1].getTextContent() === `
` && Q[ne - 2].getTextContent() === `
` && z.isCollapsed() && z.anchor.key === this.__key && z.anchor.offset === ne) return Q[ne - 1].remove(), Q[ne - 2].remove(), z = t.$createParagraphNode(), this.insertAfter(z, X), z;
      let { anchor: fe, focus: _e } = z;
      if (X = (fe.isBefore(_e) ? fe : _e).getNode(), t.$isTextNode(X)) {
        for (ne = A(X), Q = []; ; ) if (t.$isTabNode(ne)) Q.push(t.$createTabNode()), ne = ne.getNextSibling();
        else if (b(ne)) {
          for (var pe = 0, Ne = ne.getTextContent(), B = ne.getTextContentSize(); pe < B && Ne[pe] === " "; pe++) ;
          if (pe !== 0 && Q.push(x(" ".repeat(pe))), pe !== B) break;
          ne = ne.getNextSibling();
        } else break;
        ne = X.splitText(fe.offset)[0], pe = fe.offset === 0 ? 0 : 1, pe = ne.getIndexWithinParent() + pe, Ne = X.getParentOrThrow(), B = [t.$createLineBreakNode(), ...Q], Ne.splice(pe, 0, B), (Q = Q[Q.length - 1]) ? Q.select() : fe.offset === 0 ? ne.selectPrevious() : ne.getNextSibling().selectNext(0, 0);
      }
      return a(X) && ({ offset: z } = z.anchor, X.splice(z, 0, [t.$createLineBreakNode()]), X.select(z + 1, z + 1)), null;
    }
    canIndent() {
      return !1;
    }
    collapseAtStart() {
      let z = t.$createParagraphNode();
      return this.getChildren().forEach((X) => z.append(X)), this.replace(z), !0;
    }
    setLanguage(z) {
      this.getWritable().__language = n(z);
    }
    getLanguage() {
      return this.getLatest().__language;
    }
  }
  function s(D) {
    return t.$applyNodeReplacement(new o(D));
  }
  function a(D) {
    return D instanceof o;
  }
  function l(D) {
    let z;
    return e.isHTMLElement(D) && (z = D.getAttribute("data-highlight-language")), { node: s(z) };
  }
  function u(D) {
    let z = D.style.fontFamily.match("monospace") !== null;
    return z || c(D) ? { after: (X) => {
      let Q = D.parentNode;
      return Q != null && D !== Q.lastChild && X.push(t.$createLineBreakNode()), X;
    }, node: z ? s() : null } : { node: null };
  }
  function d() {
    return { node: s() };
  }
  function p() {
    return { node: null };
  }
  function m(D) {
    return { after: (z) => (D.parentNode && D.parentNode.nextSibling && z.push(t.$createLineBreakNode()), z), node: null };
  }
  function c(D) {
    for (D = D.parentElement; D !== null; ) {
      if (D.style.fontFamily.match("monospace") !== null) return !0;
      D = D.parentElement;
    }
    return !1;
  }
  function h(D) {
    return D.classList.contains("js-file-line-container");
  }
  let f = { c: "C", clike: "C-like", cpp: "C++", css: "CSS", html: "HTML", java: "Java", js: "JavaScript", markdown: "Markdown", objc: "Objective-C", plain: "Plain Text", py: "Python", rust: "Rust", sql: "SQL", swift: "Swift", typescript: "TypeScript", xml: "XML" }, N = { cpp: "cpp", java: "java", javascript: "js", md: "markdown", plaintext: "plain", python: "py", text: "plain", ts: "typescript" };
  function v(D) {
    return N[D] || D;
  }
  class C extends t.TextNode {
    constructor(z, X, Q) {
      super(z, Q), this.__highlightType = X;
    }
    static getType() {
      return "code-highlight";
    }
    static clone(z) {
      return new C(z.__text, z.__highlightType || void 0, z.__key);
    }
    getHighlightType() {
      return this.getLatest().__highlightType;
    }
    canHaveFormat() {
      return !1;
    }
    createDOM(z) {
      let X = super.createDOM(z);
      return z = g(z.theme, this.__highlightType), e.addClassNamesToElement(X, z), X;
    }
    updateDOM(z, X, Q) {
      let ne = super.updateDOM(z, X, Q);
      return z = g(Q.theme, z.__highlightType), Q = g(Q.theme, this.__highlightType), z !== Q && (z && e.removeClassNamesFromElement(X, z), Q && e.addClassNamesToElement(X, Q)), ne;
    }
    static importJSON(z) {
      let X = x(z.text, z.highlightType);
      return X.setFormat(z.format), X.setDetail(z.detail), X.setMode(z.mode), X.setStyle(z.style), X;
    }
    exportJSON() {
      return { ...super.exportJSON(), highlightType: this.getHighlightType(), type: "code-highlight", version: 1 };
    }
    setFormat() {
      return this;
    }
    isParentRequired() {
      return !0;
    }
    createParentElementNode() {
      return s();
    }
  }
  function g(D, z) {
    return z && D && D.codeHighlight && D.codeHighlight[z];
  }
  function x(D, z) {
    return t.$applyNodeReplacement(new C(D, z));
  }
  function b(D) {
    return D instanceof C;
  }
  function A(D) {
    let z = D;
    for (; b(D) || t.$isTabNode(D); ) z = D, D = D.getPreviousSibling();
    return z;
  }
  function w(D) {
    let z = D;
    for (; b(D) || t.$isTabNode(D); ) z = D, D = D.getNextSibling();
    return z;
  }
  let M = { defaultLanguage: "javascript", tokenize(D, z) {
    return r.tokenize(D, r.languages[z || ""] || r.languages[this.defaultLanguage]);
  } };
  function y(D, z) {
    let X = null;
    var Q = null, ne = D;
    let fe = z, _e = D.getTextContent();
    for (; ; ) {
      if (fe === 0) {
        if (ne = ne.getPreviousSibling(), ne === null) break;
        if (!(b(ne) || t.$isTabNode(ne) || t.$isLineBreakNode(ne))) throw Error("Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode");
        if (t.$isLineBreakNode(ne)) {
          X = { node: ne, offset: 1 };
          break;
        }
        fe = Math.max(0, ne.getTextContentSize() - 1), _e = ne.getTextContent();
      } else fe--;
      let pe = _e[fe];
      b(ne) && pe !== " " && (Q = { node: ne, offset: fe });
    }
    if (Q !== null) return Q;
    if (Q = null, z < D.getTextContentSize() ? b(D) && (Q = D.getTextContent()[z]) : (ne = D.getNextSibling(), b(ne) && (Q = ne.getTextContent()[0])), Q !== null && Q !== " ") return X;
    e: for (Q = D, ne = D.getTextContent(), D = D.getTextContentSize(); ; ) {
      if (!b(Q) || z === D) {
        if (Q = Q.getNextSibling(), Q === null || t.$isLineBreakNode(Q)) {
          D = null;
          break e;
        }
        b(Q) && (z = 0, ne = Q.getTextContent(), D = Q.getTextContentSize());
      }
      if (b(Q)) {
        if (ne[z] !== " ") {
          D = { node: Q, offset: z };
          break e;
        }
        z++;
      }
    }
    return D !== null ? D : X;
  }
  function E(D) {
    if (D = w(D), t.$isLineBreakNode(D)) throw Error("Unexpected lineBreakNode in getEndOfCodeInLine");
    return D;
  }
  function S(D, z, X) {
    let Q = D.getParent();
    a(Q) ? U(Q, z, X) : b(D) && D.replace(t.$createTextNode(D.__text));
  }
  let P = /* @__PURE__ */ new Set();
  function U(D, z, X) {
    let Q = D.getKey();
    P.has(Q) || (P.add(Q), D.getLanguage() === void 0 && D.setLanguage(X.defaultLanguage), z.update(() => {
      H(Q, () => {
        var ne = t.$getNodeByKey(Q);
        if (!a(ne) || !ne.isAttached()) return !1;
        var fe = ne.getTextContent();
        fe = X.tokenize(fe, ne.getLanguage() || X.defaultLanguage), fe = j(fe);
        var _e = ne.getChildren();
        for (ne = 0; ne < _e.length && R(_e[ne], fe[ne]); ) ne++;
        var pe = _e.length;
        let Ne = fe.length, B = Math.min(pe, Ne) - ne, F = 0;
        for (; F < B; ) if (F++, !R(_e[pe - F], fe[Ne - F])) {
          F--;
          break;
        }
        _e = ne, pe -= F, fe = fe.slice(ne, Ne - F);
        let { from: k, to: W, nodesForReplacement: V } = { from: _e, nodesForReplacement: fe, to: pe };
        return k !== W || V.length ? (D.splice(k, W - k, V), !0) : !1;
      });
    }, { onUpdate: () => {
      P.delete(Q);
    }, skipTransforms: !0 }));
  }
  function j(D, z) {
    let X = [];
    for (let Q of D) if (typeof Q == "string") {
      D = Q.split(/(\n|\t)/);
      let ne = D.length;
      for (let fe = 0; fe < ne; fe++) {
        let _e = D[fe];
        _e === `
` || _e === `\r
` ? X.push(t.$createLineBreakNode()) : _e === "	" ? X.push(t.$createTabNode()) : 0 < _e.length && X.push(x(_e, z));
      }
    } else ({ content: D } = Q), typeof D == "string" ? X.push(...j([D], Q.type)) : Array.isArray(D) && X.push(...j(D, Q.type));
    return X;
  }
  function H(D, z) {
    if (D = t.$getNodeByKey(D), a(D) && D.isAttached()) {
      var X = t.$getSelection();
      if (t.$isRangeSelection(X)) {
        X = X.anchor;
        var Q = X.offset, ne = X.type === "element" && t.$isLineBreakNode(D.getChildAtIndex(X.offset - 1)), fe = 0;
        if (!ne) {
          let _e = X.getNode();
          fe = Q + _e.getPreviousSiblings().reduce((pe, Ne) => pe + Ne.getTextContentSize(), 0);
        }
        z() && (ne ? X.getNode().select(Q, Q) : D.getChildren().some((_e) => {
          let pe = t.$isTextNode(_e);
          if (pe || t.$isLineBreakNode(_e)) {
            let Ne = _e.getTextContentSize();
            if (pe && Ne >= fe) return _e.select(fe, fe), !0;
            fe -= Ne;
          }
          return !1;
        }));
      } else z();
    }
  }
  function R(D, z) {
    return b(D) && b(z) && D.__text === z.__text && D.__highlightType === z.__highlightType || t.$isTabNode(D) && t.$isTabNode(z) || t.$isLineBreakNode(D) && t.$isLineBreakNode(z);
  }
  function T(D) {
    if (!t.$isRangeSelection(D)) return !1;
    var z = D.anchor.getNode();
    return D = D.focus.getNode(), z.is(D) && a(z) ? !0 : (z = z.getParent(), a(z) && z.is(D.getParent()));
  }
  function $(D) {
    D = D.getNodes();
    let z = [[]];
    if (D.length === 1 && a(D[0])) return z;
    let X = z[0];
    for (let Q = 0; Q < D.length; Q++) {
      let ne = D[Q];
      if (!(b(ne) || t.$isTabNode(ne) || t.$isLineBreakNode(ne))) throw Error("Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode");
      t.$isLineBreakNode(ne) ? Q !== 0 && 0 < X.length && (X = [], z.push(X)) : X.push(ne);
    }
    return z;
  }
  function G(D) {
    var z = t.$getSelection();
    if (!t.$isRangeSelection(z) || !T(z)) return null;
    let X = D ? t.OUTDENT_CONTENT_COMMAND : t.INDENT_CONTENT_COMMAND;
    if (D = D ? t.OUTDENT_CONTENT_COMMAND : t.INSERT_TAB_COMMAND, 1 < $(z).length) return X;
    var Q = z.getNodes()[0];
    if (!(a(Q) || b(Q) || t.$isTabNode(Q) || t.$isLineBreakNode(Q))) throw Error("Expected selection firstNode to be CodeHighlightNode or TabNode");
    if (a(Q)) return X;
    let ne = A(Q);
    Q = w(Q);
    var fe = z.anchor;
    let _e = z.focus;
    return _e.isBefore(fe) ? z = _e : (z = fe, fe = _e), ne !== null && Q !== null && z.key === ne.getKey() && z.offset === 0 && fe.key === Q.getKey() && fe.offset === Q.getTextContentSize() ? X : D;
  }
  function q(D) {
    var z = t.$getSelection();
    if (!t.$isRangeSelection(z) || !T(z)) return !1;
    var X = $(z);
    let Q = X.length;
    if (1 < X.length) {
      for (z = 0; z < Q; z++) {
        var ne = X[z];
        0 < ne.length && (ne = ne[0], z === 0 && (ne = A(ne)), ne !== null && (D === t.INDENT_CONTENT_COMMAND ? ne.insertBefore(t.$createTabNode()) : t.$isTabNode(ne) && ne.remove()));
      }
      return !0;
    }
    if (X = z.getNodes()[0], !(a(X) || b(X) || t.$isTabNode(X) || t.$isLineBreakNode(X))) throw Error("Expected selection firstNode to be CodeHighlightNode or CodeTabNode");
    if (a(X)) return D === t.INDENT_CONTENT_COMMAND && z.insertNodes([t.$createTabNode()]), !0;
    if (X = A(X), X === null) throw Error("Expected getFirstCodeNodeOfLine to return a valid Code Node");
    return D === t.INDENT_CONTENT_COMMAND ? t.$isLineBreakNode(X) ? X.insertAfter(t.$createTabNode()) : X.insertBefore(t.$createTabNode()) : t.$isTabNode(X) && X.remove(), !0;
  }
  function I(D, z) {
    let X = t.$getSelection();
    if (!t.$isRangeSelection(X)) return !1;
    let { anchor: Q, focus: ne } = X, fe = Q.offset, _e = ne.offset, pe = Q.getNode(), Ne = ne.getNode();
    var B = D === t.KEY_ARROW_UP_COMMAND;
    if (!T(X) || !b(pe) && !t.$isTabNode(pe) || !b(Ne) && !t.$isTabNode(Ne)) return !1;
    if (!z.altKey) {
      if (X.isCollapsed()) {
        if (D = pe.getParentOrThrow(), B && fe === 0 && pe.getPreviousSibling() === null) {
          if (D.getPreviousSibling() === null) return D.selectPrevious(), z.preventDefault(), !0;
        } else if (!B && fe === pe.getTextContentSize() && pe.getNextSibling() === null && D.getNextSibling() === null) return D.selectNext(), z.preventDefault(), !0;
      }
      return !1;
    }
    let F;
    if (pe.isBefore(Ne)) {
      var k = A(pe);
      F = w(Ne);
    } else k = A(Ne), F = w(pe);
    if (k == null || F == null) return !1;
    let W = k.getNodesBetween(F);
    for (let te = 0; te < W.length; te++) {
      let ee = W[te];
      if (!b(ee) && !t.$isTabNode(ee) && !t.$isLineBreakNode(ee)) return !1;
    }
    if (z.preventDefault(), z.stopPropagation(), z = B ? k.getPreviousSibling() : F.getNextSibling(), !t.$isLineBreakNode(z) || (k = B ? z.getPreviousSibling() : z.getNextSibling(), k == null)) return !0;
    B = b(k) || t.$isTabNode(k) || t.$isLineBreakNode(k) ? B ? A(k) : w(k) : null;
    let V = B ?? k;
    return z.remove(), W.forEach((te) => te.remove()), D === t.KEY_ARROW_UP_COMMAND ? (W.forEach((te) => V.insertBefore(te)), V.insertBefore(z)) : (V.insertAfter(z), V = z, W.forEach((te) => {
      V.insertAfter(te), V = te;
    })), X.setTextNodeRange(pe, fe, Ne, _e), !0;
  }
  function Y(D, z) {
    let X = t.$getSelection();
    if (!t.$isRangeSelection(X)) return !1;
    let { anchor: Q, focus: ne } = X;
    var fe = Q.getNode();
    let _e = ne.getNode();
    if (D = D === t.MOVE_TO_START, !b(fe) && !t.$isTabNode(fe) || !b(_e) && !t.$isTabNode(_e)) return !1;
    if (D) if (fe = y(_e, ne.offset), fe !== null) {
      let { node: pe, offset: Ne } = fe;
      t.$isLineBreakNode(pe) ? pe.selectNext(0, 0) : X.setTextNodeRange(pe, Ne, pe, Ne);
    } else _e.getParentOrThrow().selectStart();
    else E(_e).select();
    return z.preventDefault(), z.stopPropagation(), !0;
  }
  return Ut.$createCodeHighlightNode = x, Ut.$createCodeNode = s, Ut.$isCodeHighlightNode = b, Ut.$isCodeNode = a, Ut.CODE_LANGUAGE_FRIENDLY_NAME_MAP = f, Ut.CODE_LANGUAGE_MAP = N, Ut.CodeHighlightNode = C, Ut.CodeNode = o, Ut.DEFAULT_CODE_LANGUAGE = "javascript", Ut.PrismTokenizer = M, Ut.getCodeLanguages = () => Object.keys(r.languages).filter((D) => typeof r.languages[D] != "function").sort(), Ut.getDefaultCodeLanguage = () => "javascript", Ut.getEndOfCodeInLine = E, Ut.getFirstCodeNodeOfLine = A, Ut.getLanguageFriendlyName = function(D) {
    return D = v(D), f[D] || D;
  }, Ut.getLastCodeNodeOfLine = w, Ut.getStartOfCodeInLine = y, Ut.normalizeCodeLang = v, Ut.registerCodeHighlighting = function(D, z) {
    if (!D.hasNodes([o, C])) throw Error("CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor");
    return z == null && (z = M), e.mergeRegister(
      D.registerMutationListener(o, (X) => {
        D.update(() => {
          for (let [fe, _e] of X) if (_e !== "destroyed") {
            var Q = t.$getNodeByKey(fe);
            if (Q !== null) e: {
              var ne = Q;
              if (Q = D.getElementByKey(ne.getKey()), Q === null) break e;
              ne = ne.getChildren();
              let pe = ne.length;
              if (pe === Q.__cachedChildrenLength) break e;
              Q.__cachedChildrenLength = pe;
              let Ne = "1", B = 1;
              for (let F = 0; F < pe; F++) t.$isLineBreakNode(ne[F]) && (Ne += `
` + ++B);
              Q.setAttribute("data-gutter", Ne);
            }
          }
        });
      }),
      D.registerNodeTransform(o, (X) => U(X, D, z)),
      D.registerNodeTransform(t.TextNode, (X) => S(X, D, z)),
      D.registerNodeTransform(C, (X) => S(X, D, z)),
      D.registerCommand(t.KEY_TAB_COMMAND, (X) => {
        let Q = G(X.shiftKey);
        return Q === null ? !1 : (X.preventDefault(), D.dispatchCommand(Q, void 0), !0);
      }, t.COMMAND_PRIORITY_LOW),
      D.registerCommand(t.INSERT_TAB_COMMAND, () => {
        let X = t.$getSelection();
        return T(X) ? (t.$insertNodes([t.$createTabNode()]), !0) : !1;
      }, t.COMMAND_PRIORITY_LOW),
      D.registerCommand(t.INDENT_CONTENT_COMMAND, () => q(t.INDENT_CONTENT_COMMAND), t.COMMAND_PRIORITY_LOW),
      D.registerCommand(t.OUTDENT_CONTENT_COMMAND, () => q(t.OUTDENT_CONTENT_COMMAND), t.COMMAND_PRIORITY_LOW),
      D.registerCommand(t.KEY_ARROW_UP_COMMAND, (X) => I(t.KEY_ARROW_UP_COMMAND, X), t.COMMAND_PRIORITY_LOW),
      D.registerCommand(t.KEY_ARROW_DOWN_COMMAND, (X) => I(t.KEY_ARROW_DOWN_COMMAND, X), t.COMMAND_PRIORITY_LOW),
      D.registerCommand(t.MOVE_TO_END, (X) => Y(t.MOVE_TO_END, X), t.COMMAND_PRIORITY_LOW),
      D.registerCommand(t.MOVE_TO_START, (X) => Y(t.MOVE_TO_START, X), t.COMMAND_PRIORITY_LOW)
    );
  }, Ut;
}
const lf = process.env.NODE_ENV === "development" ? af() : sf();
var vo = lf, hi = {}, Gl;
function cf() {
  if (Gl) return hi;
  Gl = 1;
  var r = it(), e = Ve;
  class t extends e.TextNode {
    static getType() {
      return "hashtag";
    }
    static clone(s) {
      return new t(s.__text, s.__key);
    }
    constructor(s, a) {
      super(s, a);
    }
    createDOM(s) {
      const a = super.createDOM(s);
      return r.addClassNamesToElement(a, s.theme.hashtag), a;
    }
    static importJSON(s) {
      const a = n(s.text);
      return a.setFormat(s.format), a.setDetail(s.detail), a.setMode(s.mode), a.setStyle(s.style), a;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "hashtag"
      };
    }
    canInsertTextBefore() {
      return !1;
    }
    isTextEntity() {
      return !0;
    }
  }
  function n(o = "") {
    return e.$applyNodeReplacement(new t(o));
  }
  function i(o) {
    return o instanceof t;
  }
  return hi.$createHashtagNode = n, hi.$isHashtagNode = i, hi.HashtagNode = t, hi;
}
var fi = {}, Vl;
function uf() {
  if (Vl) return fi;
  Vl = 1;
  var r = it(), e = Ve;
  class t extends e.TextNode {
    static getType() {
      return "hashtag";
    }
    static clone(o) {
      return new t(o.__text, o.__key);
    }
    constructor(o, s) {
      super(o, s);
    }
    createDOM(o) {
      let s = super.createDOM(o);
      return r.addClassNamesToElement(s, o.theme.hashtag), s;
    }
    static importJSON(o) {
      let s = n(o.text);
      return s.setFormat(o.format), s.setDetail(o.detail), s.setMode(o.mode), s.setStyle(o.style), s;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "hashtag" };
    }
    canInsertTextBefore() {
      return !1;
    }
    isTextEntity() {
      return !0;
    }
  }
  function n(i = "") {
    return e.$applyNodeReplacement(new t(i));
  }
  return fi.$createHashtagNode = n, fi.$isHashtagNode = function(i) {
    return i instanceof t;
  }, fi.HashtagNode = t, fi;
}
const df = process.env.NODE_ENV === "development" ? cf() : uf();
var hf = df, Rr = {}, Xl;
function ff() {
  if (Xl) return Rr;
  Xl = 1;
  var r = it(), e = Ve;
  const t = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
  class n extends e.ElementNode {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "link";
    }
    static clone(h) {
      return new n(h.__url, {
        rel: h.__rel,
        target: h.__target,
        title: h.__title
      }, h.__key);
    }
    constructor(h, f = {}, N) {
      super(N);
      const {
        target: v = null,
        rel: C = null,
        title: g = null
      } = f;
      this.__url = h, this.__target = v, this.__rel = C, this.__title = g;
    }
    createDOM(h) {
      const f = document.createElement("a");
      return f.href = this.sanitizeUrl(this.__url), this.__target !== null && (f.target = this.__target), this.__rel !== null && (f.rel = this.__rel), this.__title !== null && (f.title = this.__title), r.addClassNamesToElement(f, h.theme.link), f;
    }
    updateDOM(h, f, N) {
      const v = this.__url, C = this.__target, g = this.__rel, x = this.__title;
      return v !== h.__url && (f.href = v), C !== h.__target && (C ? f.target = C : f.removeAttribute("target")), g !== h.__rel && (g ? f.rel = g : f.removeAttribute("rel")), x !== h.__title && (x ? f.title = x : f.removeAttribute("title")), !1;
    }
    static importDOM() {
      return {
        a: (h) => ({
          conversion: i,
          priority: 1
        })
      };
    }
    static importJSON(h) {
      const f = o(h.url, {
        rel: h.rel,
        target: h.target,
        title: h.title
      });
      return f.setFormat(h.format), f.setIndent(h.indent), f.setDirection(h.direction), f;
    }
    sanitizeUrl(h) {
      try {
        const f = new URL(h);
        if (!t.has(f.protocol))
          return "about:blank";
      } catch {
        return h;
      }
      return h;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        rel: this.getRel(),
        target: this.getTarget(),
        title: this.getTitle(),
        type: "link",
        url: this.getURL(),
        version: 1
      };
    }
    getURL() {
      return this.getLatest().__url;
    }
    setURL(h) {
      const f = this.getWritable();
      f.__url = h;
    }
    getTarget() {
      return this.getLatest().__target;
    }
    setTarget(h) {
      const f = this.getWritable();
      f.__target = h;
    }
    getRel() {
      return this.getLatest().__rel;
    }
    setRel(h) {
      const f = this.getWritable();
      f.__rel = h;
    }
    getTitle() {
      return this.getLatest().__title;
    }
    setTitle(h) {
      const f = this.getWritable();
      f.__title = h;
    }
    insertNewAfter(h, f = !0) {
      const N = o(this.__url, {
        rel: this.__rel,
        target: this.__target,
        title: this.__title
      });
      return this.insertAfter(N, f), N;
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isInline() {
      return !0;
    }
    extractWithChild(h, f, N) {
      if (!e.$isRangeSelection(f))
        return !1;
      const v = f.anchor.getNode(), C = f.focus.getNode();
      return this.isParentOf(v) && this.isParentOf(C) && f.getTextContent().length > 0;
    }
  }
  function i(c) {
    let h = null;
    if (r.isHTMLAnchorElement(c)) {
      const f = c.textContent;
      (f !== null && f !== "" || c.children.length > 0) && (h = o(c.getAttribute("href") || "", {
        rel: c.getAttribute("rel"),
        target: c.getAttribute("target"),
        title: c.getAttribute("title")
      }));
    }
    return {
      node: h
    };
  }
  function o(c, h) {
    return e.$applyNodeReplacement(new n(c, h));
  }
  function s(c) {
    return c instanceof n;
  }
  class a extends n {
    static getType() {
      return "autolink";
    }
    static clone(h) {
      return new a(h.__url, {
        rel: h.__rel,
        target: h.__target,
        title: h.__title
      }, h.__key);
    }
    static importJSON(h) {
      const f = l(h.url, {
        rel: h.rel,
        target: h.target,
        title: h.title
      });
      return f.setFormat(h.format), f.setIndent(h.indent), f.setDirection(h.direction), f;
    }
    static importDOM() {
      return null;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "autolink",
        version: 1
      };
    }
    insertNewAfter(h, f = !0) {
      const N = this.getParentOrThrow().insertNewAfter(h, f);
      if (e.$isElementNode(N)) {
        const v = l(this.__url, {
          rel: this.__rel,
          target: this.__target,
          title: this.__title
        });
        return N.append(v), v;
      }
      return null;
    }
  }
  function l(c, h) {
    return e.$applyNodeReplacement(new a(c, h));
  }
  function u(c) {
    return c instanceof a;
  }
  const d = e.createCommand("TOGGLE_LINK_COMMAND");
  function p(c, h = {}) {
    const {
      target: f,
      title: N
    } = h, v = h.rel === void 0 ? "noreferrer" : h.rel, C = e.$getSelection();
    if (!e.$isRangeSelection(C))
      return;
    const g = C.extract();
    if (c === null)
      g.forEach((x) => {
        const b = x.getParent();
        if (s(b)) {
          const A = b.getChildren();
          for (let w = 0; w < A.length; w++)
            b.insertBefore(A[w]);
          b.remove();
        }
      });
    else {
      if (g.length === 1) {
        const A = g[0], w = m(A, s);
        if (w !== null) {
          w.setURL(c), f !== void 0 && w.setTarget(f), v !== null && w.setRel(v), N !== void 0 && w.setTitle(N);
          return;
        }
      }
      let x = null, b = null;
      g.forEach((A) => {
        const w = A.getParent();
        if (!(w === b || w === null || e.$isElementNode(A) && !A.isInline())) {
          if (s(w)) {
            b = w, w.setURL(c), f !== void 0 && w.setTarget(f), v !== null && b.setRel(v), N !== void 0 && b.setTitle(N);
            return;
          }
          if (w.is(x) || (x = w, b = o(c, {
            rel: v,
            target: f,
            title: N
          }), s(w) ? A.getPreviousSibling() === null ? w.insertBefore(b) : w.insertAfter(b) : A.insertBefore(b)), s(A)) {
            if (A.is(b))
              return;
            if (b !== null) {
              const M = A.getChildren();
              for (let y = 0; y < M.length; y++)
                b.append(M[y]);
            }
            A.remove();
            return;
          }
          b !== null && b.append(A);
        }
      });
    }
  }
  function m(c, h) {
    let f = c;
    for (; f !== null && f.getParent() !== null && !h(f); )
      f = f.getParentOrThrow();
    return h(f) ? f : null;
  }
  return Rr.$createAutoLinkNode = l, Rr.$createLinkNode = o, Rr.$isAutoLinkNode = u, Rr.$isLinkNode = s, Rr.AutoLinkNode = a, Rr.LinkNode = n, Rr.TOGGLE_LINK_COMMAND = d, Rr.toggleLink = p, Rr;
}
var Ar = {}, Jl;
function mf() {
  if (Jl) return Ar;
  Jl = 1;
  var r = it(), e = Ve;
  let t = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
  class n extends e.ElementNode {
    static getType() {
      return "link";
    }
    static clone(m) {
      return new n(m.__url, { rel: m.__rel, target: m.__target, title: m.__title }, m.__key);
    }
    constructor(m, c = {}, h) {
      super(h);
      let { target: f = null, rel: N = null, title: v = null } = c;
      this.__url = m, this.__target = f, this.__rel = N, this.__title = v;
    }
    createDOM(m) {
      let c = document.createElement("a");
      return c.href = this.sanitizeUrl(this.__url), this.__target !== null && (c.target = this.__target), this.__rel !== null && (c.rel = this.__rel), this.__title !== null && (c.title = this.__title), r.addClassNamesToElement(
        c,
        m.theme.link
      ), c;
    }
    updateDOM(m, c) {
      let h = this.__url, f = this.__target, N = this.__rel, v = this.__title;
      return h !== m.__url && (c.href = h), f !== m.__target && (f ? c.target = f : c.removeAttribute("target")), N !== m.__rel && (N ? c.rel = N : c.removeAttribute("rel")), v !== m.__title && (v ? c.title = v : c.removeAttribute("title")), !1;
    }
    static importDOM() {
      return { a: () => ({ conversion: i, priority: 1 }) };
    }
    static importJSON(m) {
      let c = o(m.url, { rel: m.rel, target: m.target, title: m.title });
      return c.setFormat(m.format), c.setIndent(m.indent), c.setDirection(m.direction), c;
    }
    sanitizeUrl(m) {
      try {
        let c = new URL(m);
        if (!t.has(c.protocol)) return "about:blank";
      } catch {
      }
      return m;
    }
    exportJSON() {
      return { ...super.exportJSON(), rel: this.getRel(), target: this.getTarget(), title: this.getTitle(), type: "link", url: this.getURL(), version: 1 };
    }
    getURL() {
      return this.getLatest().__url;
    }
    setURL(m) {
      this.getWritable().__url = m;
    }
    getTarget() {
      return this.getLatest().__target;
    }
    setTarget(m) {
      this.getWritable().__target = m;
    }
    getRel() {
      return this.getLatest().__rel;
    }
    setRel(m) {
      this.getWritable().__rel = m;
    }
    getTitle() {
      return this.getLatest().__title;
    }
    setTitle(m) {
      this.getWritable().__title = m;
    }
    insertNewAfter(m, c = !0) {
      return m = o(this.__url, { rel: this.__rel, target: this.__target, title: this.__title }), this.insertAfter(m, c), m;
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isInline() {
      return !0;
    }
    extractWithChild(m, c) {
      if (!e.$isRangeSelection(c)) return !1;
      m = c.anchor.getNode();
      let h = c.focus.getNode();
      return this.isParentOf(m) && this.isParentOf(h) && 0 < c.getTextContent().length;
    }
  }
  function i(p) {
    let m = null;
    if (r.isHTMLAnchorElement(p)) {
      let c = p.textContent;
      (c !== null && c !== "" || 0 < p.children.length) && (m = o(p.getAttribute("href") || "", { rel: p.getAttribute("rel"), target: p.getAttribute("target"), title: p.getAttribute("title") }));
    }
    return { node: m };
  }
  function o(p, m) {
    return e.$applyNodeReplacement(new n(p, m));
  }
  function s(p) {
    return p instanceof n;
  }
  class a extends n {
    static getType() {
      return "autolink";
    }
    static clone(m) {
      return new a(m.__url, { rel: m.__rel, target: m.__target, title: m.__title }, m.__key);
    }
    static importJSON(m) {
      let c = l(m.url, { rel: m.rel, target: m.target, title: m.title });
      return c.setFormat(m.format), c.setIndent(m.indent), c.setDirection(m.direction), c;
    }
    static importDOM() {
      return null;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "autolink", version: 1 };
    }
    insertNewAfter(m, c = !0) {
      return m = this.getParentOrThrow().insertNewAfter(m, c), e.$isElementNode(m) ? (c = l(this.__url, { rel: this.__rel, target: this.__target, title: this.__title }), m.append(c), c) : null;
    }
  }
  function l(p, m) {
    return e.$applyNodeReplacement(new a(p, m));
  }
  let u = e.createCommand("TOGGLE_LINK_COMMAND");
  function d(p, m) {
    for (; p !== null && p.getParent() !== null && !m(p); ) p = p.getParentOrThrow();
    return m(p) ? p : null;
  }
  return Ar.$createAutoLinkNode = l, Ar.$createLinkNode = o, Ar.$isAutoLinkNode = function(p) {
    return p instanceof a;
  }, Ar.$isLinkNode = s, Ar.AutoLinkNode = a, Ar.LinkNode = n, Ar.TOGGLE_LINK_COMMAND = u, Ar.toggleLink = function(p, m = {}) {
    let { target: c, title: h } = m, f = m.rel === void 0 ? "noreferrer" : m.rel;
    if (m = e.$getSelection(), e.$isRangeSelection(m)) if (m = m.extract(), p === null) m.forEach((N) => {
      if (N = N.getParent(), s(N)) {
        let v = N.getChildren();
        for (let C = 0; C < v.length; C++) N.insertBefore(v[C]);
        N.remove();
      }
    });
    else {
      if (m.length === 1) {
        let C = d(m[0], s);
        if (C !== null) {
          C.setURL(p), c !== void 0 && C.setTarget(c), f !== null && C.setRel(f), h !== void 0 && C.setTitle(h);
          return;
        }
      }
      let N = null, v = null;
      m.forEach((C) => {
        var g = C.getParent();
        if (g !== v && g !== null && (!e.$isElementNode(C) || C.isInline())) if (s(g)) v = g, g.setURL(p), c !== void 0 && g.setTarget(c), f !== null && v.setRel(f), h !== void 0 && v.setTitle(h);
        else if (g.is(N) || (N = g, v = o(p, { rel: f, target: c, title: h }), s(g) ? C.getPreviousSibling() === null ? g.insertBefore(v) : g.insertAfter(v) : C.insertBefore(v)), s(C)) {
          if (!C.is(v)) {
            if (v !== null) {
              g = C.getChildren();
              for (let x = 0; x < g.length; x++) v.append(g[x]);
            }
            C.remove();
          }
        } else v !== null && v.append(C);
      });
    }
  }, Ar;
}
const gf = process.env.NODE_ENV === "development" ? ff() : mf();
var St = gf, or = {}, Zl;
function pf() {
  if (Zl) return or;
  Zl = 1;
  var r = Ve, e = it();
  function t(q) {
    let I = 1, Y = q.getParent();
    for (; Y != null; ) {
      if (M(Y)) {
        const D = Y.getParent();
        if (H(D)) {
          I++, Y = D.getParent();
          continue;
        }
        throw Error("A ListItemNode must have a ListNode for a parent.");
      }
      return I;
    }
    return I;
  }
  function n(q) {
    let I = q.getParent();
    if (!H(I))
      throw Error("A ListItemNode must have a ListNode for a parent.");
    let Y = I;
    for (; Y !== null; )
      Y = Y.getParent(), H(Y) && (I = Y);
    return I;
  }
  function i(q) {
    let I = [];
    const Y = q.getChildren().filter(M);
    for (let D = 0; D < Y.length; D++) {
      const z = Y[D], X = z.getFirstChild();
      H(X) ? I = I.concat(i(X)) : I.push(z);
    }
    return I;
  }
  function o(q) {
    return M(q) && H(q.getFirstChild());
  }
  function s(q) {
    let I = q;
    for (; I.getNextSibling() == null && I.getPreviousSibling() == null; ) {
      const Y = I.getParent();
      if (Y == null || !(M(I) || H(I)))
        break;
      I = Y;
    }
    I.remove();
  }
  function a(q) {
    return w().append(q);
  }
  function l(q, I) {
    return M(q) && (I.length === 0 || I.length === 1 && q.is(I[0]) && q.getChildrenSize() === 0);
  }
  function u(q) {
    const I = q.getParent();
    let Y = 1;
    if (I != null)
      if (H(I))
        Y = I.getStart();
      else
        throw Error("$getListItemValue: list node is not parent of list item node");
    const D = q.getPreviousSiblings();
    for (let z = 0; z < D.length; z++) {
      const X = D[z];
      M(X) && !H(X.getFirstChild()) && Y++;
    }
    return Y;
  }
  function d(q, I) {
    q.update(() => {
      const Y = r.$getSelection();
      if (Y !== null) {
        const D = Y.getNodes(), z = Y.getStartEndPoints();
        if (z === null)
          throw Error("insertList: anchor should be defined");
        const [X] = z, Q = X.getNode(), ne = Q.getParent();
        if (l(Q, D)) {
          const fe = j(I);
          if (r.$isRootOrShadowRoot(ne)) {
            Q.replace(fe);
            const _e = w();
            r.$isElementNode(Q) && (_e.setFormat(Q.getFormatType()), _e.setIndent(Q.getIndent())), fe.append(_e);
          } else if (M(Q)) {
            const _e = Q.getParentOrThrow();
            p(fe, _e.getChildren()), _e.replace(fe);
          }
          return;
        } else {
          const fe = /* @__PURE__ */ new Set();
          for (let _e = 0; _e < D.length; _e++) {
            const pe = D[_e];
            if (r.$isElementNode(pe) && pe.isEmpty() && !M(pe) && !fe.has(pe.getKey())) {
              m(pe, I);
              continue;
            }
            if (r.$isLeafNode(pe)) {
              let Ne = pe.getParent();
              for (; Ne != null; ) {
                const B = Ne.getKey();
                if (H(Ne)) {
                  if (!fe.has(B)) {
                    const F = j(I);
                    p(F, Ne.getChildren()), Ne.replace(F), f(F), fe.add(B);
                  }
                  break;
                } else {
                  const F = Ne.getParent();
                  if (r.$isRootOrShadowRoot(F) && !fe.has(B)) {
                    fe.add(B), m(Ne, I);
                    break;
                  }
                  Ne = F;
                }
              }
            }
          }
        }
      }
    });
  }
  function p(q, I) {
    q.splice(q.getChildrenSize(), 0, I);
  }
  function m(q, I) {
    if (H(q))
      return q;
    const Y = q.getPreviousSibling(), D = q.getNextSibling(), z = w();
    if (z.setFormat(q.getFormatType()), z.setIndent(q.getIndent()), p(z, q.getChildren()), H(Y) && I === Y.getListType())
      return Y.append(z), q.remove(), H(D) && I === D.getListType() && (p(Y, D.getChildren()), D.remove()), Y;
    if (H(D) && I === D.getListType())
      return D.getFirstChildOrThrow().insertBefore(z), q.remove(), D;
    {
      const X = j(I);
      return X.append(z), q.replace(X), f(X), X;
    }
  }
  function c(q, I) {
    const Y = q.getLastChild(), D = I.getFirstChild();
    Y && D && o(Y) && o(D) && (c(Y.getFirstChild(), D.getFirstChild()), D.remove());
    const z = I.getChildren();
    z.length > 0 && (q.append(...z), f(q)), I.remove();
  }
  function h(q) {
    q.update(() => {
      const I = r.$getSelection();
      if (r.$isRangeSelection(I)) {
        const Y = /* @__PURE__ */ new Set(), D = I.getNodes(), z = I.anchor.getNode();
        if (l(z, D))
          Y.add(n(z));
        else
          for (let X = 0; X < D.length; X++) {
            const Q = D[X];
            if (r.$isLeafNode(Q)) {
              const ne = e.$getNearestNodeOfType(Q, g);
              ne != null && Y.add(n(ne));
            }
          }
        for (const X of Y) {
          let Q = X;
          const ne = i(X);
          for (const fe of ne) {
            const _e = r.$createParagraphNode();
            p(_e, fe.getChildren()), Q.insertAfter(_e), Q = _e, fe.__key === I.anchor.key && I.anchor.set(_e.getKey(), 0, "element"), fe.__key === I.focus.key && I.focus.set(_e.getKey(), 0, "element"), fe.remove();
          }
          X.remove();
        }
      }
    });
  }
  function f(q, I) {
    const Y = I || q.getChildren();
    if (Y !== void 0)
      for (let D = 0; D < Y.length; D++) {
        const z = Y[D];
        if (M(z)) {
          const X = z.getValue(), Q = u(z);
          X !== Q && z.setValue(Q);
        }
      }
  }
  function N(q) {
    const I = /* @__PURE__ */ new Set();
    if (o(q) || I.has(q.getKey()))
      return;
    const Y = q.getParent(), D = q.getNextSibling(), z = q.getPreviousSibling();
    if (o(D) && o(z)) {
      const X = z.getFirstChild();
      if (H(X)) {
        X.append(q);
        const Q = D.getFirstChild();
        if (H(Q)) {
          const ne = Q.getChildren();
          p(X, ne), D.remove(), I.add(D.getKey());
        }
        f(X);
      }
    } else if (o(D)) {
      const X = D.getFirstChild();
      if (H(X)) {
        const Q = X.getFirstChild();
        Q !== null && Q.insertBefore(q), f(X);
      }
    } else if (o(z)) {
      const X = z.getFirstChild();
      H(X) && (X.append(q), f(X));
    } else if (H(Y)) {
      const X = w(), Q = j(Y.getListType());
      X.append(Q), Q.append(q), z ? z.insertAfter(X) : D ? D.insertBefore(X) : Y.append(X), f(Q);
    }
    H(Y) && f(Y);
  }
  function v(q) {
    if (o(q))
      return;
    const I = q.getParent(), Y = I ? I.getParent() : void 0, D = Y ? Y.getParent() : void 0;
    if (H(D) && M(Y) && H(I)) {
      const z = I ? I.getFirstChild() : void 0, X = I ? I.getLastChild() : void 0;
      if (q.is(z))
        Y.insertBefore(q), I.isEmpty() && Y.remove();
      else if (q.is(X))
        Y.insertAfter(q), I.isEmpty() && Y.remove();
      else {
        const Q = I.getListType(), ne = w(), fe = j(Q);
        ne.append(fe), q.getPreviousSiblings().forEach((Ne) => fe.append(Ne));
        const _e = w(), pe = j(Q);
        _e.append(pe), p(pe, q.getNextSiblings()), Y.insertBefore(ne), Y.insertAfter(_e), Y.replace(q);
      }
      f(I), f(D);
    }
  }
  function C() {
    const q = r.$getSelection();
    if (!r.$isRangeSelection(q) || !q.isCollapsed())
      return !1;
    const I = q.anchor.getNode();
    if (!M(I) || I.getChildrenSize() !== 0)
      return !1;
    const Y = n(I), D = I.getParent();
    if (!H(D))
      throw Error("A ListItemNode must have a ListNode for a parent.");
    const z = D.getParent();
    let X;
    if (r.$isRootOrShadowRoot(z))
      X = r.$createParagraphNode(), Y.insertAfter(X);
    else if (M(z))
      X = w(), z.insertAfter(X);
    else
      return !1;
    X.select();
    const Q = I.getNextSiblings();
    if (Q.length > 0) {
      const ne = j(D.getListType());
      if (r.$isParagraphNode(X))
        X.insertAfter(ne);
      else {
        const fe = w();
        fe.append(ne), X.insertAfter(fe);
      }
      Q.forEach((fe) => {
        fe.remove(), ne.append(fe);
      });
    }
    return s(I), !0;
  }
  class g extends r.ElementNode {
    /** @internal */
    /** @internal */
    static getType() {
      return "listitem";
    }
    static clone(I) {
      return new g(I.__value, I.__checked, I.__key);
    }
    constructor(I, Y, D) {
      super(D), this.__value = I === void 0 ? 1 : I, this.__checked = Y;
    }
    createDOM(I) {
      const Y = document.createElement("li"), D = this.getParent();
      return H(D) && D.getListType() === "check" && b(Y, this, null), Y.value = this.__value, x(Y, I.theme, this), Y;
    }
    updateDOM(I, Y, D) {
      const z = this.getParent();
      return H(z) && z.getListType() === "check" && b(Y, this, I), Y.value = this.__value, x(Y, D.theme, this), !1;
    }
    static transform() {
      return (I) => {
        const Y = I.getParent();
        if (H(Y)) {
          if (f(Y), !M(I))
            throw Error("node is not a ListItemNode");
          Y.getListType() !== "check" && I.getChecked() != null && I.setChecked(void 0);
        }
      };
    }
    static importDOM() {
      return {
        li: (I) => ({
          conversion: A,
          priority: 0
        })
      };
    }
    static importJSON(I) {
      const Y = w();
      return Y.setChecked(I.checked), Y.setValue(I.value), Y.setFormat(I.format), Y.setDirection(I.direction), Y;
    }
    exportDOM(I) {
      const Y = this.createDOM(I._config);
      return Y.style.textAlign = this.getFormatType(), {
        element: Y
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        checked: this.getChecked(),
        type: "listitem",
        value: this.getValue(),
        version: 1
      };
    }
    append(...I) {
      for (let Y = 0; Y < I.length; Y++) {
        const D = I[Y];
        if (r.$isElementNode(D) && this.canMergeWith(D)) {
          const z = D.getChildren();
          this.append(...z), D.remove();
        } else
          super.append(D);
      }
      return this;
    }
    replace(I, Y) {
      if (M(I))
        return super.replace(I);
      this.setIndent(0);
      const D = this.getParentOrThrow();
      if (!H(D)) return I;
      if (D.__first === this.getKey())
        D.insertBefore(I);
      else if (D.__last === this.getKey())
        D.insertAfter(I);
      else {
        const z = j(D.getListType());
        let X = this.getNextSibling();
        for (; X; ) {
          const Q = X;
          X = X.getNextSibling(), z.append(Q);
        }
        D.insertAfter(I), I.insertAfter(z);
      }
      if (Y) {
        if (!r.$isElementNode(I))
          throw Error("includeChildren should only be true for ElementNodes");
        this.getChildren().forEach((z) => {
          I.append(z);
        });
      }
      return this.remove(), D.getChildrenSize() === 0 && D.remove(), I;
    }
    insertAfter(I, Y = !0) {
      const D = this.getParentOrThrow();
      if (!H(D))
        throw Error("insertAfter: list node is not parent of list item node");
      const z = this.getNextSiblings();
      if (M(I)) {
        const X = super.insertAfter(I, Y), Q = I.getParentOrThrow();
        return H(Q) && f(Q), X;
      }
      if (H(I)) {
        let X = I;
        const Q = I.getChildren();
        for (let ne = Q.length - 1; ne >= 0; ne--)
          X = Q[ne], this.insertAfter(X, Y);
        return X;
      }
      if (D.insertAfter(I, Y), z.length !== 0) {
        const X = j(D.getListType());
        z.forEach((Q) => X.append(Q)), I.insertAfter(X, Y);
      }
      return I;
    }
    remove(I) {
      const Y = this.getPreviousSibling(), D = this.getNextSibling();
      if (super.remove(I), Y && D && o(Y) && o(D))
        c(Y.getFirstChild(), D.getFirstChild()), D.remove();
      else if (D) {
        const z = D.getParent();
        H(z) && f(z);
      }
    }
    insertNewAfter(I, Y = !0) {
      const D = w(this.__checked == null ? void 0 : !1);
      return this.insertAfter(D, Y), D;
    }
    collapseAtStart(I) {
      const Y = r.$createParagraphNode();
      this.getChildren().forEach((ne) => Y.append(ne));
      const z = this.getParentOrThrow(), X = z.getParentOrThrow(), Q = M(X);
      if (z.getChildrenSize() === 1)
        if (Q)
          z.remove(), X.select();
        else {
          z.insertBefore(Y), z.remove();
          const ne = I.anchor, fe = I.focus, _e = Y.getKey();
          ne.type === "element" && ne.getNode().is(this) && ne.set(_e, ne.offset, "element"), fe.type === "element" && fe.getNode().is(this) && fe.set(_e, fe.offset, "element");
        }
      else
        z.insertBefore(Y), this.remove();
      return !0;
    }
    getValue() {
      return this.getLatest().__value;
    }
    setValue(I) {
      const Y = this.getWritable();
      Y.__value = I;
    }
    getChecked() {
      return this.getLatest().__checked;
    }
    setChecked(I) {
      const Y = this.getWritable();
      Y.__checked = I;
    }
    toggleChecked() {
      this.setChecked(!this.__checked);
    }
    getIndent() {
      const I = this.getParent();
      if (I === null)
        return this.getLatest().__indent;
      let Y = I.getParentOrThrow(), D = 0;
      for (; M(Y); )
        Y = Y.getParentOrThrow().getParentOrThrow(), D++;
      return D;
    }
    setIndent(I) {
      if (!(typeof I == "number" && I > -1))
        throw Error("Invalid indent value.");
      let Y = this.getIndent();
      for (; Y !== I; )
        Y < I ? (N(this), Y++) : (v(this), Y--);
      return this;
    }
    insertBefore(I) {
      if (M(I)) {
        const Y = this.getParentOrThrow();
        if (H(Y)) {
          const D = this.getNextSiblings();
          f(Y, D);
        }
      }
      return super.insertBefore(I);
    }
    canInsertAfter(I) {
      return M(I);
    }
    canReplaceWith(I) {
      return M(I);
    }
    canMergeWith(I) {
      return r.$isParagraphNode(I) || M(I);
    }
    extractWithChild(I, Y) {
      if (!r.$isRangeSelection(Y))
        return !1;
      const D = Y.anchor.getNode(), z = Y.focus.getNode();
      return this.isParentOf(D) && this.isParentOf(z) && this.getTextContent().length === Y.getTextContent().length;
    }
    isParentRequired() {
      return !0;
    }
    createParentElementNode() {
      return j("bullet");
    }
  }
  function x(q, I, Y) {
    const D = [], z = [], X = I.list, Q = X ? X.listitem : void 0;
    let ne;
    if (X && X.nested && (ne = X.nested.listitem), Q !== void 0) {
      const fe = Q.split(" ");
      D.push(...fe);
    }
    if (X) {
      const fe = Y.getParent(), _e = H(fe) && fe.getListType() === "check", pe = Y.getChecked();
      (!_e || pe) && z.push(X.listitemUnchecked), (!_e || !pe) && z.push(X.listitemChecked), _e && D.push(pe ? X.listitemChecked : X.listitemUnchecked);
    }
    if (ne !== void 0) {
      const fe = ne.split(" ");
      Y.getChildren().some((_e) => H(_e)) ? D.push(...fe) : z.push(...fe);
    }
    z.length > 0 && e.removeClassNamesFromElement(q, ...z), D.length > 0 && e.addClassNamesToElement(q, ...D);
  }
  function b(q, I, Y, D) {
    H(I.getFirstChild()) ? (q.removeAttribute("role"), q.removeAttribute("tabIndex"), q.removeAttribute("aria-checked")) : (q.setAttribute("role", "checkbox"), q.setAttribute("tabIndex", "-1"), (!Y || I.__checked !== Y.__checked) && q.setAttribute("aria-checked", I.getChecked() ? "true" : "false"));
  }
  function A(q) {
    const I = e.isHTMLElement(q) && q.getAttribute("aria-checked") === "true";
    return {
      node: w(I)
    };
  }
  function w(q) {
    return r.$applyNodeReplacement(new g(void 0, q));
  }
  function M(q) {
    return q instanceof g;
  }
  class y extends r.ElementNode {
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "list";
    }
    static clone(I) {
      const Y = I.__listType || U[I.__tag];
      return new y(Y, I.__start, I.__key);
    }
    constructor(I, Y, D) {
      super(D);
      const z = U[I] || I;
      this.__listType = z, this.__tag = z === "number" ? "ol" : "ul", this.__start = Y;
    }
    getTag() {
      return this.__tag;
    }
    setListType(I) {
      const Y = this.getWritable();
      Y.__listType = I, Y.__tag = I === "number" ? "ol" : "ul";
    }
    getListType() {
      return this.__listType;
    }
    getStart() {
      return this.__start;
    }
    // View
    createDOM(I, Y) {
      const D = this.__tag, z = document.createElement(D);
      return this.__start !== 1 && z.setAttribute("start", String(this.__start)), z.__lexicalListType = this.__listType, E(z, I.theme, this), z;
    }
    updateDOM(I, Y, D) {
      return I.__tag !== this.__tag ? !0 : (E(Y, D.theme, this), !1);
    }
    static importDOM() {
      return {
        ol: (I) => ({
          conversion: P,
          priority: 0
        }),
        ul: (I) => ({
          conversion: P,
          priority: 0
        })
      };
    }
    static importJSON(I) {
      const Y = j(I.listType, I.start);
      return Y.setFormat(I.format), Y.setIndent(I.indent), Y.setDirection(I.direction), Y;
    }
    exportDOM(I) {
      const {
        element: Y
      } = super.exportDOM(I);
      return Y && e.isHTMLElement(Y) && (this.__start !== 1 && Y.setAttribute("start", String(this.__start)), this.__listType === "check" && Y.setAttribute("__lexicalListType", "check")), {
        element: Y
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        listType: this.getListType(),
        start: this.getStart(),
        tag: this.getTag(),
        type: "list",
        version: 1
      };
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
    append(...I) {
      for (let Y = 0; Y < I.length; Y++) {
        const D = I[Y];
        if (M(D))
          super.append(D);
        else {
          const z = w();
          if (H(D))
            z.append(D);
          else if (r.$isElementNode(D)) {
            const X = r.$createTextNode(D.getTextContent());
            z.append(X);
          } else
            z.append(D);
          super.append(z);
        }
      }
      return f(this), this;
    }
    extractWithChild(I) {
      return M(I);
    }
  }
  function E(q, I, Y) {
    const D = [], z = [], X = I.list;
    if (X !== void 0) {
      const Q = X[`${Y.__tag}Depth`] || [], ne = t(Y) - 1, fe = ne % Q.length, _e = Q[fe], pe = X[Y.__tag];
      let Ne;
      const B = X.nested, F = X.checklist;
      if (B !== void 0 && B.list && (Ne = B.list), pe !== void 0 && D.push(pe), F !== void 0 && Y.__listType === "check" && D.push(F), _e !== void 0) {
        const k = _e.split(" ");
        D.push(...k);
        for (let W = 0; W < Q.length; W++)
          W !== fe && z.push(Y.__tag + W);
      }
      if (Ne !== void 0) {
        const k = Ne.split(" ");
        ne > 1 ? D.push(...k) : z.push(...k);
      }
    }
    z.length > 0 && e.removeClassNamesFromElement(q, ...z), D.length > 0 && e.addClassNamesToElement(q, ...D);
  }
  function S(q) {
    const I = [];
    for (let Y = 0; Y < q.length; Y++) {
      const D = q[Y];
      if (M(D)) {
        I.push(D);
        const z = D.getChildren();
        z.length > 1 && z.forEach((X) => {
          H(X) && I.push(a(X));
        });
      } else
        I.push(a(D));
    }
    return I;
  }
  function P(q) {
    const I = q.nodeName.toLowerCase();
    let Y = null;
    if (I === "ol") {
      const D = q.start;
      Y = j("number", D);
    } else I === "ul" && (e.isHTMLElement(q) && q.getAttribute("__lexicallisttype") === "check" ? Y = j("check") : Y = j("bullet"));
    return {
      after: S,
      node: Y
    };
  }
  const U = {
    ol: "number",
    ul: "bullet"
  };
  function j(q, I = 1) {
    return r.$applyNodeReplacement(new y(q, I));
  }
  function H(q) {
    return q instanceof y;
  }
  const R = r.createCommand("INSERT_UNORDERED_LIST_COMMAND"), T = r.createCommand("INSERT_ORDERED_LIST_COMMAND"), $ = r.createCommand("INSERT_CHECK_LIST_COMMAND"), G = r.createCommand("REMOVE_LIST_COMMAND");
  return or.$createListItemNode = w, or.$createListNode = j, or.$getListDepth = t, or.$handleListInsertParagraph = C, or.$isListItemNode = M, or.$isListNode = H, or.INSERT_CHECK_LIST_COMMAND = $, or.INSERT_ORDERED_LIST_COMMAND = T, or.INSERT_UNORDERED_LIST_COMMAND = R, or.ListItemNode = g, or.ListNode = y, or.REMOVE_LIST_COMMAND = G, or.insertList = d, or.removeList = h, or;
}
var ar = {}, Ql;
function vf() {
  if (Ql) return ar;
  Ql = 1;
  var r = Ve, e = it();
  function t(R) {
    let T = new URLSearchParams();
    T.append("code", R);
    for (let $ = 1; $ < arguments.length; $++) T.append("v", arguments[$]);
    throw Error(`Minified Lexical error #${R}; visit https://lexical.dev/docs/error?${T} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  function n(R) {
    let T = 1;
    for (R = R.getParent(); R != null; ) {
      if (x(R)) {
        if (R = R.getParent(), S(R)) {
          T++, R = R.getParent();
          continue;
        }
        t(40);
      }
      break;
    }
    return T;
  }
  function i(R) {
    R = R.getParent(), S(R) || t(40);
    let T = R;
    for (; T !== null; ) T = T.getParent(), S(T) && (R = T);
    return R;
  }
  function o(R) {
    let T = [];
    R = R.getChildren().filter(x);
    for (let $ = 0; $ < R.length; $++) {
      let G = R[$], q = G.getFirstChild();
      S(q) ? T = T.concat(o(q)) : T.push(G);
    }
    return T;
  }
  function s(R) {
    return x(R) && S(R.getFirstChild());
  }
  function a(R) {
    for (; R.getNextSibling() == null && R.getPreviousSibling() == null; ) {
      let T = R.getParent();
      if (T == null || !x(R) && !S(R)) break;
      R = T;
    }
    R.remove();
  }
  function l(R) {
    return g().append(R);
  }
  function u(R, T) {
    return x(R) && (T.length === 0 || T.length === 1 && R.is(T[0]) && R.getChildrenSize() === 0);
  }
  function d(R, T) {
    R.splice(R.getChildrenSize(), 0, T);
  }
  function p(R, T) {
    if (S(R)) return R;
    let $ = R.getPreviousSibling(), G = R.getNextSibling(), q = g();
    return q.setFormat(R.getFormatType()), q.setIndent(R.getIndent()), d(q, R.getChildren()), S($) && T === $.getListType() ? ($.append(q), R.remove(), S(G) && T === G.getListType() && (d($, G.getChildren()), G.remove()), $) : S(G) && T === G.getListType() ? (G.getFirstChildOrThrow().insertBefore(q), R.remove(), G) : (T = E(T), T.append(q), R.replace(T), c(T), T);
  }
  function m(R, T) {
    var $ = R.getLastChild();
    let G = T.getFirstChild();
    $ && G && s($) && s(G) && (m($.getFirstChild(), G.getFirstChild()), G.remove()), $ = T.getChildren(), 0 < $.length && (R.append(...$), c(R)), T.remove();
  }
  function c(R, T) {
    if (R = T || R.getChildren(), R !== void 0) for (T = 0; T < R.length; T++) {
      let I = R[T];
      if (x(I)) {
        let Y = I.getValue();
        var $ = I, G = $.getParent(), q = 1;
        for (G != null && (S(G) ? q = G.getStart() : t(44)), $ = $.getPreviousSiblings(), G = 0; G < $.length; G++) {
          let D = $[G];
          x(D) && !S(D.getFirstChild()) && q++;
        }
        Y !== q && I.setValue(q);
      }
    }
  }
  function h(R) {
    if (!s(R)) {
      var T = R.getParent(), $ = T ? T.getParent() : void 0, G = $ ? $.getParent() : void 0;
      if (S(G) && x($) && S(T)) {
        var q = T ? T.getFirstChild() : void 0, I = T ? T.getLastChild() : void 0;
        if (R.is(q)) $.insertBefore(R), T.isEmpty() && $.remove();
        else if (R.is(I)) $.insertAfter(R), T.isEmpty() && $.remove();
        else {
          var Y = T.getListType();
          q = g();
          let D = E(Y);
          q.append(D), R.getPreviousSiblings().forEach((z) => D.append(z)), I = g(), Y = E(Y), I.append(Y), d(Y, R.getNextSiblings()), $.insertBefore(q), $.insertAfter(I), $.replace(R);
        }
        c(T), c(G);
      }
    }
  }
  class f extends r.ElementNode {
    static getType() {
      return "listitem";
    }
    static clone(T) {
      return new f(T.__value, T.__checked, T.__key);
    }
    constructor(T, $, G) {
      super(G), this.__value = T === void 0 ? 1 : T, this.__checked = $;
    }
    createDOM(T) {
      let $ = document.createElement("li"), G = this.getParent();
      return S(G) && G.getListType() === "check" && v($, this, null), $.value = this.__value, N($, T.theme, this), $;
    }
    updateDOM(T, $, G) {
      let q = this.getParent();
      return S(q) && q.getListType() === "check" && v($, this, T), $.value = this.__value, N($, G.theme, this), !1;
    }
    static transform() {
      return (T) => {
        let $ = T.getParent();
        S($) && (c($), x(T) || t(144), $.getListType() !== "check" && T.getChecked() != null && T.setChecked(void 0));
      };
    }
    static importDOM() {
      return { li: () => ({ conversion: C, priority: 0 }) };
    }
    static importJSON(T) {
      let $ = g();
      return $.setChecked(T.checked), $.setValue(T.value), $.setFormat(T.format), $.setDirection(T.direction), $;
    }
    exportDOM(T) {
      return T = this.createDOM(T._config), T.style.textAlign = this.getFormatType(), { element: T };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        checked: this.getChecked(),
        type: "listitem",
        value: this.getValue(),
        version: 1
      };
    }
    append(...T) {
      for (let $ = 0; $ < T.length; $++) {
        let G = T[$];
        if (r.$isElementNode(G) && this.canMergeWith(G)) {
          let q = G.getChildren();
          this.append(...q), G.remove();
        } else super.append(G);
      }
      return this;
    }
    replace(T, $) {
      if (x(T)) return super.replace(T);
      this.setIndent(0);
      let G = this.getParentOrThrow();
      if (!S(G)) return T;
      if (G.__first === this.getKey()) G.insertBefore(T);
      else if (G.__last === this.getKey()) G.insertAfter(T);
      else {
        let q = E(G.getListType()), I = this.getNextSibling();
        for (; I; ) {
          let Y = I;
          I = I.getNextSibling(), q.append(Y);
        }
        G.insertAfter(T), T.insertAfter(q);
      }
      return $ && (r.$isElementNode(T) || t(139), this.getChildren().forEach((q) => {
        T.append(q);
      })), this.remove(), G.getChildrenSize() === 0 && G.remove(), T;
    }
    insertAfter(T, $ = !0) {
      var G = this.getParentOrThrow();
      S(G) || t(39);
      var q = this.getNextSiblings();
      if (x(T)) return $ = super.insertAfter(T, $), T = T.getParentOrThrow(), S(T) && c(T), $;
      if (S(T)) {
        for (G = T, T = T.getChildren(), q = T.length - 1; 0 <= q; q--) G = T[q], this.insertAfter(G, $);
        return G;
      }
      if (G.insertAfter(T, $), q.length !== 0) {
        let I = E(G.getListType());
        q.forEach((Y) => I.append(Y)), T.insertAfter(I, $);
      }
      return T;
    }
    remove(T) {
      let $ = this.getPreviousSibling(), G = this.getNextSibling();
      super.remove(T), $ && G && s($) && s(G) ? (m($.getFirstChild(), G.getFirstChild()), G.remove()) : G && (T = G.getParent(), S(T) && c(T));
    }
    insertNewAfter(T, $ = !0) {
      return T = g(this.__checked == null ? void 0 : !1), this.insertAfter(T, $), T;
    }
    collapseAtStart(T) {
      let $ = r.$createParagraphNode();
      this.getChildren().forEach((Y) => $.append(Y));
      var G = this.getParentOrThrow(), q = G.getParentOrThrow();
      let I = x(q);
      return G.getChildrenSize() === 1 ? I ? (G.remove(), q.select()) : (G.insertBefore($), G.remove(), G = T.anchor, T = T.focus, q = $.getKey(), G.type === "element" && G.getNode().is(this) && G.set(q, G.offset, "element"), T.type === "element" && T.getNode().is(this) && T.set(q, T.offset, "element")) : (G.insertBefore($), this.remove()), !0;
    }
    getValue() {
      return this.getLatest().__value;
    }
    setValue(T) {
      this.getWritable().__value = T;
    }
    getChecked() {
      return this.getLatest().__checked;
    }
    setChecked(T) {
      this.getWritable().__checked = T;
    }
    toggleChecked() {
      this.setChecked(!this.__checked);
    }
    getIndent() {
      var T = this.getParent();
      if (T === null) return this.getLatest().__indent;
      T = T.getParentOrThrow();
      let $ = 0;
      for (; x(T); ) T = T.getParentOrThrow().getParentOrThrow(), $++;
      return $;
    }
    setIndent(T) {
      typeof T == "number" && -1 < T || t(117);
      let $ = this.getIndent();
      for (; $ !== T; ) if ($ < T) {
        e: {
          var G = /* @__PURE__ */ new Set();
          if (s(this) || G.has(this.getKey())) break e;
          let D = this.getParent();
          var q = this.getNextSibling(), I = this.getPreviousSibling();
          if (s(q) && s(I)) {
            if (I = I.getFirstChild(), S(I)) {
              I.append(this);
              var Y = q.getFirstChild();
              S(Y) && (Y = Y.getChildren(), d(I, Y), q.remove(), G.add(q.getKey())), c(I);
            }
          } else s(q) ? (q = q.getFirstChild(), S(q) && (G = q.getFirstChild(), G !== null && G.insertBefore(this), c(q))) : s(I) ? (q = I.getFirstChild(), S(q) && (q.append(this), c(q))) : S(D) && (G = g(), Y = E(D.getListType()), G.append(Y), Y.append(this), I ? I.insertAfter(G) : q ? q.insertBefore(G) : D.append(G), c(Y));
          S(D) && c(D);
        }
        $++;
      } else h(this), $--;
      return this;
    }
    insertBefore(T) {
      if (x(T)) {
        let $ = this.getParentOrThrow();
        if (S($)) {
          let G = this.getNextSiblings();
          c($, G);
        }
      }
      return super.insertBefore(T);
    }
    canInsertAfter(T) {
      return x(T);
    }
    canReplaceWith(T) {
      return x(T);
    }
    canMergeWith(T) {
      return r.$isParagraphNode(T) || x(T);
    }
    extractWithChild(T, $) {
      if (!r.$isRangeSelection($)) return !1;
      T = $.anchor.getNode();
      let G = $.focus.getNode();
      return this.isParentOf(T) && this.isParentOf(G) && this.getTextContent().length === $.getTextContent().length;
    }
    isParentRequired() {
      return !0;
    }
    createParentElementNode() {
      return E("bullet");
    }
  }
  function N(R, T, $) {
    let G = [], q = [];
    var I = (T = T.list) ? T.listitem : void 0;
    if (T && T.nested) var Y = T.nested.listitem;
    if (I !== void 0 && (I = I.split(" "), G.push(...I)), T) {
      I = $.getParent(), I = S(I) && I.getListType() === "check";
      let D = $.getChecked();
      I && !D || q.push(T.listitemUnchecked), I && D || q.push(T.listitemChecked), I && G.push(D ? T.listitemChecked : T.listitemUnchecked);
    }
    Y !== void 0 && (Y = Y.split(" "), $.getChildren().some((D) => S(D)) ? G.push(...Y) : q.push(...Y)), 0 < q.length && e.removeClassNamesFromElement(R, ...q), 0 < G.length && e.addClassNamesToElement(
      R,
      ...G
    );
  }
  function v(R, T, $) {
    S(T.getFirstChild()) ? (R.removeAttribute("role"), R.removeAttribute("tabIndex"), R.removeAttribute("aria-checked")) : (R.setAttribute("role", "checkbox"), R.setAttribute("tabIndex", "-1"), $ && T.__checked === $.__checked || R.setAttribute("aria-checked", T.getChecked() ? "true" : "false"));
  }
  function C(R) {
    return R = e.isHTMLElement(R) && R.getAttribute("aria-checked") === "true", { node: g(R) };
  }
  function g(R) {
    return r.$applyNodeReplacement(new f(void 0, R));
  }
  function x(R) {
    return R instanceof f;
  }
  class b extends r.ElementNode {
    static getType() {
      return "list";
    }
    static clone(T) {
      return new b(T.__listType || y[T.__tag], T.__start, T.__key);
    }
    constructor(T, $, G) {
      super(G), this.__listType = T = y[T] || T, this.__tag = T === "number" ? "ol" : "ul", this.__start = $;
    }
    getTag() {
      return this.__tag;
    }
    setListType(T) {
      let $ = this.getWritable();
      $.__listType = T, $.__tag = T === "number" ? "ol" : "ul";
    }
    getListType() {
      return this.__listType;
    }
    getStart() {
      return this.__start;
    }
    createDOM(T) {
      let $ = document.createElement(this.__tag);
      return this.__start !== 1 && $.setAttribute(
        "start",
        String(this.__start)
      ), $.__lexicalListType = this.__listType, A($, T.theme, this), $;
    }
    updateDOM(T, $, G) {
      return T.__tag !== this.__tag ? !0 : (A($, G.theme, this), !1);
    }
    static importDOM() {
      return { ol: () => ({ conversion: M, priority: 0 }), ul: () => ({ conversion: M, priority: 0 }) };
    }
    static importJSON(T) {
      let $ = E(T.listType, T.start);
      return $.setFormat(T.format), $.setIndent(T.indent), $.setDirection(T.direction), $;
    }
    exportDOM(T) {
      return { element: T } = super.exportDOM(T), T && e.isHTMLElement(T) && (this.__start !== 1 && T.setAttribute("start", String(this.__start)), this.__listType === "check" && T.setAttribute("__lexicalListType", "check")), { element: T };
    }
    exportJSON() {
      return { ...super.exportJSON(), listType: this.getListType(), start: this.getStart(), tag: this.getTag(), type: "list", version: 1 };
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
    append(...T) {
      for (let G = 0; G < T.length; G++) {
        var $ = T[G];
        if (x($)) super.append($);
        else {
          let q = g();
          S($) || r.$isElementNode($) && ($ = r.$createTextNode($.getTextContent())), q.append($), super.append(q);
        }
      }
      return c(this), this;
    }
    extractWithChild(T) {
      return x(T);
    }
  }
  function A(R, T, $) {
    let G = [], q = [];
    var I = T.list;
    if (I !== void 0) {
      let D = I[`${$.__tag}Depth`] || [];
      T = n($) - 1;
      let z = T % D.length;
      var Y = D[z];
      let X = I[$.__tag], Q, ne = I.nested;
      if (I = I.checklist, ne !== void 0 && ne.list && (Q = ne.list), X !== void 0 && G.push(X), I !== void 0 && $.__listType === "check" && G.push(I), Y !== void 0) for (Y = Y.split(" "), G.push(...Y), Y = 0; Y < D.length; Y++) Y !== z && q.push($.__tag + Y);
      Q !== void 0 && ($ = Q.split(" "), 1 < T ? G.push(...$) : q.push(...$));
    }
    0 < q.length && e.removeClassNamesFromElement(R, ...q), 0 < G.length && e.addClassNamesToElement(
      R,
      ...G
    );
  }
  function w(R) {
    let T = [];
    for (let G = 0; G < R.length; G++) {
      var $ = R[G];
      x($) ? (T.push($), $ = $.getChildren(), 1 < $.length && $.forEach((q) => {
        S(q) && T.push(l(q));
      })) : T.push(l($));
    }
    return T;
  }
  function M(R) {
    let T = R.nodeName.toLowerCase(), $ = null;
    return T === "ol" ? $ = E("number", R.start) : T === "ul" && ($ = e.isHTMLElement(R) && R.getAttribute("__lexicallisttype") === "check" ? E("check") : E("bullet")), { after: w, node: $ };
  }
  let y = { ol: "number", ul: "bullet" };
  function E(R, T = 1) {
    return r.$applyNodeReplacement(new b(R, T));
  }
  function S(R) {
    return R instanceof b;
  }
  let P = r.createCommand("INSERT_UNORDERED_LIST_COMMAND"), U = r.createCommand("INSERT_ORDERED_LIST_COMMAND"), j = r.createCommand("INSERT_CHECK_LIST_COMMAND"), H = r.createCommand("REMOVE_LIST_COMMAND");
  return ar.$createListItemNode = g, ar.$createListNode = E, ar.$getListDepth = n, ar.$handleListInsertParagraph = function() {
    var R = r.$getSelection();
    if (!r.$isRangeSelection(R) || !R.isCollapsed() || (R = R.anchor.getNode(), !x(R) || R.getChildrenSize() !== 0)) return !1;
    var T = i(R), $ = R.getParent();
    S($) || t(40);
    let G = $.getParent(), q;
    if (r.$isRootOrShadowRoot(G)) q = r.$createParagraphNode(), T.insertAfter(q);
    else if (x(G)) q = g(), G.insertAfter(q);
    else return !1;
    if (q.select(), T = R.getNextSiblings(), 0 < T.length) {
      let I = E($.getListType());
      r.$isParagraphNode(q) ? q.insertAfter(I) : ($ = g(), $.append(I), q.insertAfter($)), T.forEach((Y) => {
        Y.remove(), I.append(Y);
      });
    }
    return a(R), !0;
  }, ar.$isListItemNode = x, ar.$isListNode = S, ar.INSERT_CHECK_LIST_COMMAND = j, ar.INSERT_ORDERED_LIST_COMMAND = U, ar.INSERT_UNORDERED_LIST_COMMAND = P, ar.ListItemNode = f, ar.ListNode = b, ar.REMOVE_LIST_COMMAND = H, ar.insertList = function(R, T) {
    R.update(() => {
      var $ = r.$getSelection();
      if ($ !== null) {
        var G = $.getNodes();
        $ = $.getStartEndPoints(), $ === null && t(143), [$] = $, $ = $.getNode();
        var q = $.getParent();
        if (u($, G)) G = E(T), r.$isRootOrShadowRoot(q) ? ($.replace(G), q = g(), r.$isElementNode($) && (q.setFormat($.getFormatType()), q.setIndent($.getIndent())), G.append(q)) : x($) && ($ = $.getParentOrThrow(), d(G, $.getChildren()), $.replace(G));
        else for ($ = /* @__PURE__ */ new Set(), q = 0; q < G.length; q++) {
          var I = G[q];
          if (r.$isElementNode(I) && I.isEmpty() && !x(I) && !$.has(I.getKey())) p(
            I,
            T
          );
          else if (r.$isLeafNode(I)) for (I = I.getParent(); I != null; ) {
            let D = I.getKey();
            if (S(I)) {
              if (!$.has(D)) {
                var Y = E(T);
                d(Y, I.getChildren()), I.replace(Y), c(Y), $.add(D);
              }
              break;
            } else {
              if (Y = I.getParent(), r.$isRootOrShadowRoot(Y) && !$.has(D)) {
                $.add(D), p(I, T);
                break;
              }
              I = Y;
            }
          }
        }
      }
    });
  }, ar.removeList = function(R) {
    R.update(() => {
      let T = r.$getSelection();
      if (r.$isRangeSelection(T)) {
        var $ = /* @__PURE__ */ new Set(), G = T.getNodes(), q = T.anchor.getNode();
        if (u(q, G)) $.add(i(q));
        else for (q = 0; q < G.length; q++) {
          var I = G[q];
          r.$isLeafNode(I) && (I = e.$getNearestNodeOfType(I, f), I != null && $.add(i(I)));
        }
        for (let Y of $) {
          $ = Y, G = o(Y);
          for (let D of G) G = r.$createParagraphNode(), d(G, D.getChildren()), $.insertAfter(G), $ = G, D.__key === T.anchor.key && T.anchor.set(G.getKey(), 0, "element"), D.__key === T.focus.key && T.focus.set(G.getKey(), 0, "element"), D.remove();
          Y.remove();
        }
      }
    });
  }, ar;
}
const xf = process.env.NODE_ENV === "development" ? pf() : vf();
var Zt = xf, rn = {}, e0;
function Nf() {
  if (e0) return rn;
  e0 = 1;
  var r = Ve, e = it();
  class t extends r.ElementNode {
    /** @internal */
    static getType() {
      return "mark";
    }
    static clone(u) {
      return new t(Array.from(u.__ids), u.__key);
    }
    static importDOM() {
      return null;
    }
    static importJSON(u) {
      const d = n(u.ids);
      return d.setFormat(u.format), d.setIndent(u.indent), d.setDirection(u.direction), d;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        ids: this.getIDs(),
        type: "mark",
        version: 1
      };
    }
    constructor(u, d) {
      super(d), this.__ids = u || [];
    }
    createDOM(u) {
      const d = document.createElement("mark");
      return e.addClassNamesToElement(d, u.theme.mark), this.__ids.length > 1 && e.addClassNamesToElement(d, u.theme.markOverlap), d;
    }
    updateDOM(u, d, p) {
      const m = u.__ids, c = this.__ids, h = m.length, f = c.length, N = p.theme.markOverlap;
      return h !== f && (h === 1 ? f === 2 && e.addClassNamesToElement(d, N) : f === 1 && e.removeClassNamesFromElement(d, N)), !1;
    }
    hasID(u) {
      const d = this.getIDs();
      for (let p = 0; p < d.length; p++)
        if (u === d[p])
          return !0;
      return !1;
    }
    getIDs() {
      const u = this.getLatest();
      return i(u) ? u.__ids : [];
    }
    addID(u) {
      const d = this.getWritable();
      if (i(d)) {
        const p = d.__ids;
        d.__ids = p;
        for (let m = 0; m < p.length; m++)
          if (u === p[m]) return;
        p.push(u);
      }
    }
    deleteID(u) {
      const d = this.getWritable();
      if (i(d)) {
        const p = d.__ids;
        d.__ids = p;
        for (let m = 0; m < p.length; m++)
          if (u === p[m]) {
            p.splice(m, 1);
            return;
          }
      }
    }
    insertNewAfter(u, d = !0) {
      const p = n(this.__ids);
      return this.insertAfter(p, d), p;
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isInline() {
      return !0;
    }
    extractWithChild(u, d, p) {
      if (!r.$isRangeSelection(d) || p === "html")
        return !1;
      const m = d.anchor, c = d.focus, h = m.getNode(), f = c.getNode(), v = d.isBackward() ? m.offset - c.offset : c.offset - m.offset;
      return this.isParentOf(h) && this.isParentOf(f) && this.getTextContent().length === v;
    }
    excludeFromCopy(u) {
      return u !== "clone";
    }
  }
  function n(l) {
    return r.$applyNodeReplacement(new t(l));
  }
  function i(l) {
    return l instanceof t;
  }
  function o(l) {
    const u = l.getChildren();
    let d = null;
    for (let p = 0; p < u.length; p++) {
      const m = u[p];
      d === null ? l.insertBefore(m) : d.insertAfter(m), d = m;
    }
    l.remove();
  }
  function s(l, u, d, p) {
    const m = l.getNodes(), c = l.anchor.offset, h = l.focus.offset, f = m.length, N = u ? h : c, v = u ? c : h;
    let C, g;
    for (let x = 0; x < f; x++) {
      const b = m[x];
      if (r.$isElementNode(g) && g.isParentOf(b))
        continue;
      const A = x === 0, w = x === f - 1;
      let M = null;
      if (r.$isTextNode(b)) {
        const y = b.getTextContentSize(), E = A ? N : 0, S = w ? v : y;
        if (E === 0 && S === 0)
          continue;
        const P = b.splitText(E, S);
        M = P.length > 1 && (P.length === 3 || A && !w || S === y) ? P[1] : P[0];
      } else {
        if (i(b))
          continue;
        r.$isElementNode(b) && b.isInline() && (M = b);
      }
      if (M !== null) {
        if (M && M.is(C))
          continue;
        const y = M.getParent();
        (y == null || !y.is(C)) && (g = void 0), C = y, g === void 0 && (g = (p || n)([d]), M.insertBefore(g)), g.append(M);
      } else
        C = void 0, g = void 0;
    }
    r.$isElementNode(g) && (u ? g.selectStart() : g.selectEnd());
  }
  function a(l, u) {
    let d = l;
    for (; d !== null; ) {
      if (i(d))
        return d.getIDs();
      if (r.$isTextNode(d) && u === d.getTextContentSize()) {
        const p = d.getNextSibling();
        if (i(p))
          return p.getIDs();
      }
      d = d.getParent();
    }
    return null;
  }
  return rn.$createMarkNode = n, rn.$getMarkIDs = a, rn.$isMarkNode = i, rn.$unwrapMarkNode = o, rn.$wrapSelectionInMarkNode = s, rn.MarkNode = t, rn;
}
var nn = {}, t0;
function _f() {
  if (t0) return nn;
  t0 = 1;
  var r = Ve, e = it();
  class t extends r.ElementNode {
    static getType() {
      return "mark";
    }
    static clone(s) {
      return new t(Array.from(s.__ids), s.__key);
    }
    static importDOM() {
      return null;
    }
    static importJSON(s) {
      let a = n(s.ids);
      return a.setFormat(s.format), a.setIndent(s.indent), a.setDirection(s.direction), a;
    }
    exportJSON() {
      return { ...super.exportJSON(), ids: this.getIDs(), type: "mark", version: 1 };
    }
    constructor(s, a) {
      super(a), this.__ids = s || [];
    }
    createDOM(s) {
      let a = document.createElement("mark");
      return e.addClassNamesToElement(a, s.theme.mark), 1 < this.__ids.length && e.addClassNamesToElement(a, s.theme.markOverlap), a;
    }
    updateDOM(s, a, l) {
      s = s.__ids.length;
      let u = this.__ids.length;
      return l = l.theme.markOverlap, s !== u && (s === 1 ? u === 2 && e.addClassNamesToElement(a, l) : u === 1 && e.removeClassNamesFromElement(a, l)), !1;
    }
    hasID(s) {
      let a = this.getIDs();
      for (let l = 0; l < a.length; l++) if (s === a[l]) return !0;
      return !1;
    }
    getIDs() {
      let s = this.getLatest();
      return i(s) ? s.__ids : [];
    }
    addID(s) {
      var a = this.getWritable();
      if (i(a)) {
        let l = a.__ids;
        for (a.__ids = l, a = 0; a < l.length; a++) if (s === l[a]) return;
        l.push(s);
      }
    }
    deleteID(s) {
      var a = this.getWritable();
      if (i(a)) {
        let l = a.__ids;
        for (a.__ids = l, a = 0; a < l.length; a++) if (s === l[a]) {
          l.splice(a, 1);
          break;
        }
      }
    }
    insertNewAfter(s, a = !0) {
      return s = n(this.__ids), this.insertAfter(s, a), s;
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isInline() {
      return !0;
    }
    extractWithChild(s, a, l) {
      if (!r.$isRangeSelection(a) || l === "html") return !1;
      let u = a.anchor, d = a.focus;
      return s = u.getNode(), l = d.getNode(), a = a.isBackward() ? u.offset - d.offset : d.offset - u.offset, this.isParentOf(s) && this.isParentOf(l) && this.getTextContent().length === a;
    }
    excludeFromCopy(s) {
      return s !== "clone";
    }
  }
  function n(o) {
    return r.$applyNodeReplacement(new t(o));
  }
  function i(o) {
    return o instanceof t;
  }
  return nn.$createMarkNode = n, nn.$getMarkIDs = function(o, s) {
    for (; o !== null; ) {
      if (i(o)) return o.getIDs();
      if (r.$isTextNode(o) && s === o.getTextContentSize()) {
        let a = o.getNextSibling();
        if (i(a)) return a.getIDs();
      }
      o = o.getParent();
    }
    return null;
  }, nn.$isMarkNode = i, nn.$unwrapMarkNode = function(o) {
    let s = o.getChildren(), a = null;
    for (let l = 0; l < s.length; l++) {
      let u = s[l];
      a === null ? o.insertBefore(u) : a.insertAfter(u), a = u;
    }
    o.remove();
  }, nn.$wrapSelectionInMarkNode = function(o, s, a, l) {
    let u = o.getNodes();
    var d = o.anchor.offset, p = o.focus.offset;
    o = u.length;
    let m = s ? p : d;
    d = s ? d : p;
    let c, h;
    for (p = 0; p < o; p++) {
      var f = u[p];
      if (r.$isElementNode(h) && h.isParentOf(f)) continue;
      var N = p === 0;
      let C = p === o - 1;
      var v = null;
      if (r.$isTextNode(f)) {
        v = f.getTextContentSize();
        let g = N ? m : 0, x = C ? d : v;
        if (g === 0 && x === 0) continue;
        f = f.splitText(g, x), v = 1 < f.length && (f.length === 3 || N && !C || x === v) ? f[1] : f[0];
      } else {
        if (i(f)) continue;
        r.$isElementNode(f) && f.isInline() && (v = f);
      }
      v !== null ? v && v.is(c) || (N = v.getParent(), N != null && N.is(c) || (h = void 0), c = N, h === void 0 && (h = (l || n)([a]), v.insertBefore(h)), h.append(v)) : h = c = void 0;
    }
    r.$isElementNode(h) && (s ? h.selectStart() : h.selectEnd());
  }, nn.MarkNode = t, nn;
}
const Cf = process.env.NODE_ENV === "development" ? Nf() : _f();
var bf = Cf, mi = {}, r0;
function yf() {
  if (r0) return mi;
  r0 = 1;
  var r = Ve;
  class e extends r.ElementNode {
    static getType() {
      return "overflow";
    }
    static clone(o) {
      return new e(o.__key);
    }
    static importJSON(o) {
      return t();
    }
    static importDOM() {
      return null;
    }
    constructor(o) {
      super(o), this.__type = "overflow";
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "overflow"
      };
    }
    createDOM(o) {
      const s = document.createElement("span"), a = o.theme.characterLimit;
      return typeof a == "string" && (s.className = a), s;
    }
    updateDOM(o, s) {
      return !1;
    }
    insertNewAfter(o, s = !0) {
      return this.getParentOrThrow().insertNewAfter(o, s);
    }
    excludeFromCopy() {
      return !0;
    }
  }
  function t() {
    return r.$applyNodeReplacement(new e());
  }
  function n(i) {
    return i instanceof e;
  }
  return mi.$createOverflowNode = t, mi.$isOverflowNode = n, mi.OverflowNode = e, mi;
}
var gi = {}, n0;
function wf() {
  if (n0) return gi;
  n0 = 1;
  var r = Ve;
  class e extends r.ElementNode {
    static getType() {
      return "overflow";
    }
    static clone(i) {
      return new e(i.__key);
    }
    static importJSON() {
      return t();
    }
    static importDOM() {
      return null;
    }
    constructor(i) {
      super(i), this.__type = "overflow";
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "overflow" };
    }
    createDOM(i) {
      let o = document.createElement("span");
      return i = i.theme.characterLimit, typeof i == "string" && (o.className = i), o;
    }
    updateDOM() {
      return !1;
    }
    insertNewAfter(i, o = !0) {
      return this.getParentOrThrow().insertNewAfter(i, o);
    }
    excludeFromCopy() {
      return !0;
    }
  }
  function t() {
    return r.$applyNodeReplacement(new e());
  }
  return gi.$createOverflowNode = t, gi.$isOverflowNode = function(n) {
    return n instanceof e;
  }, gi.OverflowNode = e, gi;
}
const Tf = process.env.NODE_ENV === "development" ? yf() : wf();
var Ef = Tf, $n = {}, jo = {}, i0;
function Sf() {
  if (i0) return jo;
  i0 = 1;
  var r = lt(), e = Ve, t = nt;
  function n(o, s) {
    return o.getEditorState().read(() => {
      const a = e.$getNodeByKey(s);
      return a === null ? !1 : a.isSelected();
    });
  }
  function i(o) {
    const [s] = r.useLexicalComposerContext(), [a, l] = t.useState(() => n(s, o));
    t.useEffect(() => {
      let p = !0;
      const m = s.registerUpdateListener(() => {
        p && l(n(s, o));
      });
      return () => {
        p = !1, m();
      };
    }, [s, o]);
    const u = t.useCallback((p) => {
      s.update(() => {
        let m = e.$getSelection();
        e.$isNodeSelection(m) || (m = e.$createNodeSelection(), e.$setSelection(m)), e.$isNodeSelection(m) && (p ? m.add(o) : m.delete(o));
      });
    }, [s, o]), d = t.useCallback(() => {
      s.update(() => {
        const p = e.$getSelection();
        e.$isNodeSelection(p) && p.clear();
      });
    }, [s]);
    return [a, u, d];
  }
  return jo.useLexicalNodeSelection = i, jo;
}
var qo = {}, o0;
function Of() {
  if (o0) return qo;
  o0 = 1;
  var r = lt(), e = Ve, t = nt;
  function n(i, o) {
    return i.getEditorState().read(() => {
      let s = e.$getNodeByKey(o);
      return s === null ? !1 : s.isSelected();
    });
  }
  return qo.useLexicalNodeSelection = function(i) {
    let [o] = r.useLexicalComposerContext(), [s, a] = t.useState(() => n(o, i));
    t.useEffect(() => {
      let d = !0, p = o.registerUpdateListener(() => {
        d && a(n(o, i));
      });
      return () => {
        d = !1, p();
      };
    }, [o, i]);
    let l = t.useCallback((d) => {
      o.update(() => {
        let p = e.$getSelection();
        e.$isNodeSelection(p) || (p = e.$createNodeSelection(), e.$setSelection(p)), e.$isNodeSelection(p) && (d ? p.add(i) : p.delete(i));
      });
    }, [o, i]), u = t.useCallback(
      () => {
        o.update(() => {
          const d = e.$getSelection();
          e.$isNodeSelection(d) && d.clear();
        });
      },
      [o]
    );
    return [s, l, u];
  }, qo;
}
var Ko, a0;
function Ai() {
  return a0 || (a0 = 1, Ko = process.env.NODE_ENV === "development" ? Sf() : Of()), Ko;
}
var s0;
function Mf() {
  if (s0) return $n;
  s0 = 1;
  var r = lt(), e = Ai(), t = it(), n = Ve, i = nt;
  const o = n.createCommand("INSERT_HORIZONTAL_RULE_COMMAND");
  function s({
    nodeKey: p
  }) {
    const [m] = r.useLexicalComposerContext(), [c, h, f] = e.useLexicalNodeSelection(p), N = i.useCallback((v) => {
      if (c && n.$isNodeSelection(n.$getSelection())) {
        v.preventDefault();
        const C = n.$getNodeByKey(p);
        d(C) && C.remove();
      }
      return !1;
    }, [c, p]);
    return i.useEffect(() => t.mergeRegister(m.registerCommand(n.CLICK_COMMAND, (v) => {
      const C = m.getElementByKey(p);
      return v.target === C ? (v.shiftKey || f(), h(!c), !0) : !1;
    }, n.COMMAND_PRIORITY_LOW), m.registerCommand(n.KEY_DELETE_COMMAND, N, n.COMMAND_PRIORITY_LOW), m.registerCommand(n.KEY_BACKSPACE_COMMAND, N, n.COMMAND_PRIORITY_LOW)), [f, m, c, p, N, h]), i.useEffect(() => {
      const v = m.getElementByKey(p);
      v !== null && (v.className = c ? "selected" : "");
    }, [m, c, p]), null;
  }
  class a extends n.DecoratorNode {
    static getType() {
      return "horizontalrule";
    }
    static clone(m) {
      return new a(m.__key);
    }
    static importJSON(m) {
      return u();
    }
    static importDOM() {
      return {
        hr: () => ({
          conversion: l,
          priority: 0
        })
      };
    }
    exportJSON() {
      return {
        type: "horizontalrule",
        version: 1
      };
    }
    exportDOM() {
      return {
        element: document.createElement("hr")
      };
    }
    createDOM() {
      return document.createElement("hr");
    }
    getTextContent() {
      return `
`;
    }
    isInline() {
      return !1;
    }
    updateDOM() {
      return !1;
    }
    decorate() {
      return /* @__PURE__ */ i.createElement(s, {
        nodeKey: this.__key
      });
    }
  }
  function l() {
    return {
      node: u()
    };
  }
  function u() {
    return n.$applyNodeReplacement(new a());
  }
  function d(p) {
    return p instanceof a;
  }
  return $n.$createHorizontalRuleNode = u, $n.$isHorizontalRuleNode = d, $n.HorizontalRuleNode = a, $n.INSERT_HORIZONTAL_RULE_COMMAND = o, $n;
}
var In = {}, l0;
function Rf() {
  if (l0) return In;
  l0 = 1;
  var r = lt(), e = Ai(), t = it(), n = Ve, i = nt;
  let o = n.createCommand("INSERT_HORIZONTAL_RULE_COMMAND");
  function s({ nodeKey: p }) {
    let [m] = r.useLexicalComposerContext(), [c, h, f] = e.useLexicalNodeSelection(p), N = i.useCallback((v) => (c && n.$isNodeSelection(n.$getSelection()) && (v.preventDefault(), v = n.$getNodeByKey(p), d(v) && v.remove()), !1), [c, p]);
    return i.useEffect(() => t.mergeRegister(m.registerCommand(n.CLICK_COMMAND, (v) => {
      let C = m.getElementByKey(p);
      return v.target === C ? (v.shiftKey || f(), h(!c), !0) : !1;
    }, n.COMMAND_PRIORITY_LOW), m.registerCommand(n.KEY_DELETE_COMMAND, N, n.COMMAND_PRIORITY_LOW), m.registerCommand(
      n.KEY_BACKSPACE_COMMAND,
      N,
      n.COMMAND_PRIORITY_LOW
    )), [f, m, c, p, N, h]), i.useEffect(() => {
      let v = m.getElementByKey(p);
      v !== null && (v.className = c ? "selected" : "");
    }, [m, c, p]), null;
  }
  class a extends n.DecoratorNode {
    static getType() {
      return "horizontalrule";
    }
    static clone(m) {
      return new a(m.__key);
    }
    static importJSON() {
      return u();
    }
    static importDOM() {
      return { hr: () => ({ conversion: l, priority: 0 }) };
    }
    exportJSON() {
      return { type: "horizontalrule", version: 1 };
    }
    exportDOM() {
      return { element: document.createElement("hr") };
    }
    createDOM() {
      return document.createElement("hr");
    }
    getTextContent() {
      return `
`;
    }
    isInline() {
      return !1;
    }
    updateDOM() {
      return !1;
    }
    decorate() {
      return i.createElement(s, { nodeKey: this.__key });
    }
  }
  function l() {
    return { node: u() };
  }
  function u() {
    return n.$applyNodeReplacement(new a());
  }
  function d(p) {
    return p instanceof a;
  }
  return In.$createHorizontalRuleNode = u, In.$isHorizontalRuleNode = d, In.HorizontalRuleNode = a, In.INSERT_HORIZONTAL_RULE_COMMAND = o, In;
}
const Af = process.env.NODE_ENV === "development" ? Mf() : Rf();
var Li = Af, wr = {}, Lr = {}, ji = {}, c0;
function Lf() {
  if (c0) return ji;
  c0 = 1;
  var r = en(), e = it(), t = Ve;
  function n(u, d) {
    const p = d.body ? d.body.childNodes : [];
    let m = [];
    for (let c = 0; c < p.length; c++) {
      const h = p[c];
      if (!a.has(h.nodeName)) {
        const f = l(h, u);
        f !== null && (m = m.concat(f));
      }
    }
    return m;
  }
  function i(u, d) {
    if (typeof document > "u" || typeof window > "u" && typeof po.window > "u")
      throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
    const p = document.createElement("div"), c = t.$getRoot().getChildren();
    for (let h = 0; h < c.length; h++) {
      const f = c[h];
      o(u, f, p, d);
    }
    return p.innerHTML;
  }
  function o(u, d, p, m = null) {
    let c = m !== null ? d.isSelected(m) : !0;
    const h = t.$isElementNode(d) && d.excludeFromCopy("html");
    let f = d;
    if (m !== null) {
      let A = r.$cloneWithProperties(d);
      A = t.$isTextNode(A) && m !== null ? r.$sliceSelectedTextNodeContent(m, A) : A, f = A;
    }
    const N = t.$isElementNode(f) ? f.getChildren() : [], v = u._nodes.get(f.getType());
    let C;
    v && v.exportDOM !== void 0 ? C = v.exportDOM(u, f) : C = f.exportDOM(u);
    const {
      element: g,
      after: x
    } = C;
    if (!g)
      return !1;
    const b = document.createDocumentFragment();
    for (let A = 0; A < N.length; A++) {
      const w = N[A], M = o(u, w, b, m);
      !c && t.$isElementNode(d) && M && d.extractWithChild(w, m, "html") && (c = !0);
    }
    if (c && !h) {
      if (e.isHTMLElement(g) && g.append(b), p.append(g), x) {
        const A = x.call(f, g);
        A && g.replaceWith(A);
      }
    } else
      p.append(b);
    return c;
  }
  function s(u, d) {
    const {
      nodeName: p
    } = u, m = d._htmlConversions.get(p.toLowerCase());
    let c = null;
    if (m !== void 0)
      for (const h of m) {
        const f = h(u);
        f !== null && (c === null || (c.priority || 0) < (f.priority || 0)) && (c = f);
      }
    return c !== null ? c.conversion : null;
  }
  const a = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
  function l(u, d, p = /* @__PURE__ */ new Map(), m) {
    let c = [];
    if (a.has(u.nodeName))
      return c;
    let h = null;
    const f = s(u, d), N = f ? f(u) : null;
    let v = null;
    if (N !== null) {
      v = N.after;
      const x = N.node;
      if (h = Array.isArray(x) ? x[x.length - 1] : x, h !== null) {
        for (const [, b] of p)
          if (h = b(h, m), !h)
            break;
        h && c.push(...Array.isArray(x) ? x : [h]);
      }
      N.forChild != null && p.set(u.nodeName, N.forChild);
    }
    const C = u.childNodes;
    let g = [];
    for (let x = 0; x < C.length; x++)
      g.push(...l(C[x], d, new Map(p), h));
    return v != null && (g = v(g)), h == null ? c = c.concat(g) : t.$isElementNode(h) && h.append(...g), c;
  }
  return ji.$generateHtmlFromNodes = i, ji.$generateNodesFromDOM = n, ji;
}
var qi = {}, u0;
function kf() {
  if (u0) return qi;
  u0 = 1;
  var r = en(), e = it(), t = Ve;
  function n(s, a, l, u = null) {
    let d = u !== null ? a.isSelected(u) : !0, p = t.$isElementNode(a) && a.excludeFromCopy("html");
    var m = a;
    u !== null && (m = r.$cloneWithProperties(a), m = t.$isTextNode(m) && u !== null ? r.$sliceSelectedTextNodeContent(u, m) : m);
    let c = t.$isElementNode(m) ? m.getChildren() : [];
    var h = s._nodes.get(m.getType());
    h = h && h.exportDOM !== void 0 ? h.exportDOM(s, m) : m.exportDOM(s);
    let { element: f, after: N } = h;
    if (!f) return !1;
    h = document.createDocumentFragment();
    for (let v = 0; v < c.length; v++) {
      let C = c[v], g = n(s, C, h, u);
      !d && t.$isElementNode(a) && g && a.extractWithChild(C, u, "html") && (d = !0);
    }
    return d && !p ? (e.isHTMLElement(f) && f.append(h), l.append(f), N && (s = N.call(m, f)) && f.replaceWith(s)) : l.append(h), d;
  }
  let i = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
  function o(s, a, l = /* @__PURE__ */ new Map(), u) {
    let d = [];
    if (i.has(s.nodeName)) return d;
    let p = null;
    var m, { nodeName: c } = s, h = a._htmlConversions.get(c.toLowerCase());
    if (c = null, h !== void 0) for (m of h) h = m(s), h !== null && (c === null || (c.priority || 0) < (h.priority || 0)) && (c = h);
    if (c = (m = c !== null ? c.conversion : null) ? m(s) : null, m = null, c !== null) {
      if (m = c.after, h = c.node, p = Array.isArray(h) ? h[h.length - 1] : h, p !== null) {
        for (var [, f] of l) if (p = f(p, u), !p) break;
        p && d.push(...Array.isArray(h) ? h : [p]);
      }
      c.forChild != null && l.set(s.nodeName, c.forChild);
    }
    for (s = s.childNodes, u = [], f = 0; f < s.length; f++) u.push(...o(s[f], a, new Map(l), p));
    return m != null && (u = m(u)), p == null ? d = d.concat(u) : t.$isElementNode(p) && p.append(...u), d;
  }
  return qi.$generateHtmlFromNodes = function(s, a) {
    if (typeof document > "u" || typeof window > "u" && typeof po.window > "u") throw Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
    let l = document.createElement("div"), u = t.$getRoot().getChildren();
    for (let d = 0; d < u.length; d++) n(s, u[d], l, a);
    return l.innerHTML;
  }, qi.$generateNodesFromDOM = function(s, a) {
    a = a.body ? a.body.childNodes : [];
    let l = [];
    for (let d = 0; d < a.length; d++) {
      var u = a[d];
      i.has(u.nodeName) || (u = o(u, s), u !== null && (l = l.concat(u)));
    }
    return l;
  }, qi;
}
var Uo, d0;
function Yu() {
  return d0 || (d0 = 1, Uo = process.env.NODE_ENV === "development" ? Lf() : kf()), Uo;
}
var h0;
function Df() {
  if (h0) return Lr;
  h0 = 1;
  var r = Yu(), e = en(), t = it(), n = Ve;
  const i = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", o = (g) => i ? (g || window).getSelection() : null;
  function s(g) {
    const x = n.$getSelection();
    if (x == null)
      throw Error("Expected valid LexicalSelection");
    return n.$isRangeSelection(x) && x.isCollapsed() || x.getNodes().length === 0 ? "" : r.$generateHtmlFromNodes(g, x);
  }
  function a(g) {
    const x = n.$getSelection();
    if (x == null)
      throw Error("Expected valid LexicalSelection");
    return n.$isRangeSelection(x) && x.isCollapsed() || x.getNodes().length === 0 ? null : JSON.stringify(c(g, x));
  }
  function l(g, x) {
    const b = g.getData("text/plain") || g.getData("text/uri-list");
    b != null && x.insertRawText(b);
  }
  function u(g, x, b) {
    const A = g.getData("application/x-lexical-editor");
    if (A)
      try {
        const y = JSON.parse(A);
        if (y.namespace === b._config.namespace && Array.isArray(y.nodes)) {
          const E = h(y.nodes);
          return d(b, E, x);
        }
      } catch {
      }
    const w = g.getData("text/html");
    if (w)
      try {
        const E = new DOMParser().parseFromString(w, "text/html"), S = r.$generateNodesFromDOM(b, E);
        return d(b, S, x);
      } catch {
      }
    const M = g.getData("text/plain") || g.getData("text/uri-list");
    if (M != null)
      if (n.$isRangeSelection(x)) {
        const y = M.split(/(\r?\n|\t)/);
        y[y.length - 1] === "" && y.pop();
        for (let E = 0; E < y.length; E++) {
          const S = y[E];
          S === `
` || S === `\r
` ? x.insertParagraph() : S === "	" ? x.insertNodes([n.$createTabNode()]) : x.insertText(S);
        }
      } else
        x.insertRawText(M);
  }
  function d(g, x, b) {
    g.dispatchCommand(n.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {
      nodes: x,
      selection: b
    }) || b.insertNodes(x);
  }
  function p(g) {
    const x = g.exportJSON(), b = g.constructor;
    if (x.type !== b.getType())
      throw Error(`LexicalNode: Node ${b.name} does not implement .exportJSON().`);
    if (n.$isElementNode(g)) {
      const A = x.children;
      if (!Array.isArray(A))
        throw Error(`LexicalNode: Node ${b.name} is an element but .exportJSON() does not have a children array.`);
    }
    return x;
  }
  function m(g, x, b, A = []) {
    let w = x !== null ? b.isSelected(x) : !0;
    const M = n.$isElementNode(b) && b.excludeFromCopy("html");
    let y = b;
    if (x !== null) {
      let P = e.$cloneWithProperties(b);
      P = n.$isTextNode(P) && x !== null ? e.$sliceSelectedTextNodeContent(x, P) : P, y = P;
    }
    const E = n.$isElementNode(y) ? y.getChildren() : [], S = p(y);
    if (n.$isTextNode(y)) {
      const P = y.__text;
      P.length > 0 ? S.text = P : w = !1;
    }
    for (let P = 0; P < E.length; P++) {
      const U = E[P], j = m(g, x, U, S.children);
      !w && n.$isElementNode(b) && j && b.extractWithChild(U, x, "clone") && (w = !0);
    }
    if (w && !M)
      A.push(S);
    else if (Array.isArray(S.children))
      for (let P = 0; P < S.children.length; P++) {
        const U = S.children[P];
        A.push(U);
      }
    return w;
  }
  function c(g, x) {
    const b = [], w = n.$getRoot().getChildren();
    for (let M = 0; M < w.length; M++) {
      const y = w[M];
      m(g, x, y, b);
    }
    return {
      namespace: g._config.namespace,
      nodes: b
    };
  }
  function h(g) {
    const x = [];
    for (let b = 0; b < g.length; b++) {
      const A = g[b], w = n.$parseSerializedNode(A);
      n.$isTextNode(w) && e.$addNodeStyle(w), x.push(w);
    }
    return x;
  }
  const f = 50;
  let N = null;
  async function v(g, x) {
    if (N !== null)
      return !1;
    if (x !== null)
      return new Promise((E, S) => {
        g.update(() => {
          E(C(g, x));
        });
      });
    const b = g.getRootElement(), A = g._window == null ? window.document : g._window.document, w = o(g._window);
    if (b === null || w === null)
      return !1;
    const M = A.createElement("span");
    M.style.cssText = "position: fixed; top: -1000px;", M.append(A.createTextNode("#")), b.append(M);
    const y = new Range();
    return y.setStart(M, 0), y.setEnd(M, 1), w.removeAllRanges(), w.addRange(y), new Promise((E, S) => {
      const P = g.registerCommand(n.COPY_COMMAND, (U) => (t.objectKlassEquals(U, ClipboardEvent) && (P(), N !== null && (window.clearTimeout(N), N = null), E(C(g, U))), !0), n.COMMAND_PRIORITY_CRITICAL);
      N = window.setTimeout(() => {
        P(), N = null, E(!1);
      }, f), A.execCommand("copy"), M.remove();
    });
  }
  function C(g, x) {
    const b = o(g._window);
    if (!b)
      return !1;
    const A = b.anchorNode, w = b.focusNode;
    if (A !== null && w !== null && !n.isSelectionWithinEditor(g, A, w))
      return !1;
    x.preventDefault();
    const M = x.clipboardData, y = n.$getSelection();
    if (M === null || y === null)
      return !1;
    const E = s(g), S = a(g);
    let P = "";
    return y !== null && (P = y.getTextContent()), E !== null && M.setData("text/html", E), S !== null && M.setData("application/x-lexical-editor", S), M.setData("text/plain", P), !0;
  }
  return Lr.$generateJSONFromSelectedNodes = c, Lr.$generateNodesFromSerializedNodes = h, Lr.$getHtmlContent = s, Lr.$getLexicalContent = a, Lr.$insertDataTransferForPlainText = l, Lr.$insertDataTransferForRichText = u, Lr.$insertGeneratedNodes = d, Lr.copyToClipboard = v, Lr;
}
var kr = {}, f0;
function $f() {
  if (f0) return kr;
  f0 = 1;
  var r = Yu(), e = en(), t = it(), n = Ve;
  function i(h) {
    let f = new URLSearchParams();
    f.append("code", h);
    for (let N = 1; N < arguments.length; N++) f.append("v", arguments[N]);
    throw Error(`Minified Lexical error #${h}; visit https://lexical.dev/docs/error?${f} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  let o = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  function s(h) {
    let f = n.$getSelection();
    if (f == null) throw Error("Expected valid LexicalSelection");
    return n.$isRangeSelection(f) && f.isCollapsed() || f.getNodes().length === 0 ? "" : r.$generateHtmlFromNodes(h, f);
  }
  function a(h) {
    let f = n.$getSelection();
    if (f == null) throw Error("Expected valid LexicalSelection");
    return n.$isRangeSelection(f) && f.isCollapsed() || f.getNodes().length === 0 ? null : JSON.stringify(d(h, f));
  }
  function l(h, f, N) {
    h.dispatchCommand(n.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, { nodes: f, selection: N }) || N.insertNodes(f);
  }
  function u(h, f, N, v = []) {
    let C = f !== null ? N.isSelected(f) : !0, g = n.$isElementNode(N) && N.excludeFromCopy("html");
    var x = N;
    if (f !== null) {
      var b = e.$cloneWithProperties(N);
      x = b = n.$isTextNode(b) && f !== null ? e.$sliceSelectedTextNodeContent(f, b) : b;
    }
    let A = n.$isElementNode(x) ? x.getChildren() : [];
    var w = x;
    b = w.exportJSON();
    var M = w.constructor;
    for (b.type !== M.getType() && i(58, M.name), n.$isElementNode(w) && (Array.isArray(b.children) || i(59, M.name)), n.$isTextNode(x) && (x = x.__text, 0 < x.length ? b.text = x : C = !1), x = 0; x < A.length; x++) w = A[x], M = u(h, f, w, b.children), !C && n.$isElementNode(N) && M && N.extractWithChild(w, f, "clone") && (C = !0);
    if (C && !g) v.push(b);
    else if (Array.isArray(b.children)) for (h = 0; h < b.children.length; h++) v.push(b.children[h]);
    return C;
  }
  function d(h, f) {
    let N = [], v = n.$getRoot().getChildren();
    for (let C = 0; C < v.length; C++) u(h, f, v[C], N);
    return { namespace: h._config.namespace, nodes: N };
  }
  function p(h) {
    let f = [];
    for (let N = 0; N < h.length; N++) {
      let v = n.$parseSerializedNode(h[N]);
      n.$isTextNode(v) && e.$addNodeStyle(v), f.push(v);
    }
    return f;
  }
  let m = null;
  function c(h, f) {
    var N = o ? (h._window || window).getSelection() : null;
    if (!N) return !1;
    var v = N.anchorNode;
    if (N = N.focusNode, v !== null && N !== null && !n.isSelectionWithinEditor(h, v, N) || (f.preventDefault(), f = f.clipboardData, v = n.$getSelection(), f === null || v === null)) return !1;
    N = s(h), h = a(h);
    let C = "";
    return v !== null && (C = v.getTextContent()), N !== null && f.setData("text/html", N), h !== null && f.setData("application/x-lexical-editor", h), f.setData("text/plain", C), !0;
  }
  return kr.$generateJSONFromSelectedNodes = d, kr.$generateNodesFromSerializedNodes = p, kr.$getHtmlContent = s, kr.$getLexicalContent = a, kr.$insertDataTransferForPlainText = function(h, f) {
    h = h.getData("text/plain") || h.getData("text/uri-list"), h != null && f.insertRawText(h);
  }, kr.$insertDataTransferForRichText = function(h, f, N) {
    var v = h.getData("application/x-lexical-editor");
    if (v) try {
      let g = JSON.parse(v);
      if (g.namespace === N._config.namespace && Array.isArray(g.nodes)) {
        let x = p(g.nodes);
        return l(N, x, f);
      }
    } catch {
    }
    if (v = h.getData("text/html")) try {
      var C = new DOMParser().parseFromString(v, "text/html");
      let g = r.$generateNodesFromDOM(N, C);
      return l(N, g, f);
    } catch {
    }
    if (h = h.getData("text/plain") || h.getData("text/uri-list"), h != null) if (n.$isRangeSelection(f)) for (h = h.split(/(\r?\n|\t)/), h[h.length - 1] === "" && h.pop(), N = 0; N < h.length; N++) C = h[N], C === `
` || C === `\r
` ? f.insertParagraph() : C === "	" ? f.insertNodes([n.$createTabNode()]) : f.insertText(C);
    else f.insertRawText(h);
  }, kr.$insertGeneratedNodes = l, kr.copyToClipboard = async function(h, f) {
    if (m !== null) return !1;
    if (f !== null) return new Promise((x) => {
      h.update(() => {
        x(c(h, f));
      });
    });
    var N = h.getRootElement();
    let v = h._window == null ? window.document : h._window.document, C = o ? (h._window || window).getSelection() : null;
    if (N === null || C === null) return !1;
    let g = v.createElement("span");
    return g.style.cssText = "position: fixed; top: -1000px;", g.append(v.createTextNode("#")), N.append(g), N = new Range(), N.setStart(g, 0), N.setEnd(g, 1), C.removeAllRanges(), C.addRange(N), new Promise((x) => {
      let b = h.registerCommand(n.COPY_COMMAND, (A) => (t.objectKlassEquals(A, ClipboardEvent) && (b(), m !== null && (window.clearTimeout(m), m = null), x(c(h, A))), !0), n.COMMAND_PRIORITY_CRITICAL);
      m = window.setTimeout(() => {
        b(), m = null, x(!1);
      }, 50), v.execCommand("copy"), g.remove();
    });
  }, kr;
}
var Yo, m0;
function Wu() {
  return m0 || (m0 = 1, Yo = process.env.NODE_ENV === "development" ? Df() : $f()), Yo;
}
var g0;
function If() {
  if (g0) return wr;
  g0 = 1;
  var r = Wu(), e = en(), t = it(), n = Ve;
  function i(U, j) {
    if (typeof document.caretRangeFromPoint < "u") {
      const H = document.caretRangeFromPoint(U, j);
      return H === null ? null : {
        node: H.startContainer,
        offset: H.startOffset
      };
    } else if (document.caretPositionFromPoint !== "undefined") {
      const H = document.caretPositionFromPoint(U, j);
      return H === null ? null : {
        node: H.offsetNode,
        offset: H.offset
      };
    } else
      return null;
  }
  const o = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", s = o && "documentMode" in document ? document.documentMode : null, a = o && "InputEvent" in window && !s ? "getTargetRanges" in new window.InputEvent("input") : !1, l = o && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), u = o && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, d = o && /^(?=.*Chrome).*/i.test(navigator.userAgent), p = o && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !d, m = n.createCommand("DRAG_DROP_PASTE_FILE");
  class c extends n.ElementNode {
    static getType() {
      return "quote";
    }
    static clone(j) {
      return new c(j.__key);
    }
    constructor(j) {
      super(j);
    }
    // View
    createDOM(j) {
      const H = document.createElement("blockquote");
      return t.addClassNamesToElement(H, j.theme.quote), H;
    }
    updateDOM(j, H) {
      return !1;
    }
    static importDOM() {
      return {
        blockquote: (j) => ({
          conversion: g,
          priority: 0
        })
      };
    }
    exportDOM(j) {
      const {
        element: H
      } = super.exportDOM(j);
      if (H && t.isHTMLElement(H)) {
        this.isEmpty() && H.append(document.createElement("br"));
        const R = this.getFormatType();
        H.style.textAlign = R;
        const T = this.getDirection();
        T && (H.dir = T);
      }
      return {
        element: H
      };
    }
    static importJSON(j) {
      const H = h();
      return H.setFormat(j.format), H.setIndent(j.indent), H.setDirection(j.direction), H;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "quote"
      };
    }
    // Mutation
    insertNewAfter(j, H) {
      const R = n.$createParagraphNode(), T = this.getDirection();
      return R.setDirection(T), this.insertAfter(R, H), R;
    }
    collapseAtStart() {
      const j = n.$createParagraphNode();
      return this.getChildren().forEach((R) => j.append(R)), this.replace(j), !0;
    }
  }
  function h() {
    return n.$applyNodeReplacement(new c());
  }
  function f(U) {
    return U instanceof c;
  }
  class N extends n.ElementNode {
    /** @internal */
    static getType() {
      return "heading";
    }
    static clone(j) {
      return new N(j.__tag, j.__key);
    }
    constructor(j, H) {
      super(H), this.__tag = j;
    }
    getTag() {
      return this.__tag;
    }
    // View
    createDOM(j) {
      const H = this.__tag, R = document.createElement(H), $ = j.theme.heading;
      if ($ !== void 0) {
        const G = $[H];
        t.addClassNamesToElement(R, G);
      }
      return R;
    }
    updateDOM(j, H) {
      return !1;
    }
    static importDOM() {
      return {
        h1: (j) => ({
          conversion: C,
          priority: 0
        }),
        h2: (j) => ({
          conversion: C,
          priority: 0
        }),
        h3: (j) => ({
          conversion: C,
          priority: 0
        }),
        h4: (j) => ({
          conversion: C,
          priority: 0
        }),
        h5: (j) => ({
          conversion: C,
          priority: 0
        }),
        h6: (j) => ({
          conversion: C,
          priority: 0
        }),
        p: (j) => {
          const R = j.firstChild;
          return R !== null && v(R) ? {
            conversion: () => ({
              node: null
            }),
            priority: 3
          } : null;
        },
        span: (j) => v(j) ? {
          conversion: (H) => ({
            node: x("h1")
          }),
          priority: 3
        } : null
      };
    }
    exportDOM(j) {
      const {
        element: H
      } = super.exportDOM(j);
      if (H && t.isHTMLElement(H)) {
        this.isEmpty() && H.append(document.createElement("br"));
        const R = this.getFormatType();
        H.style.textAlign = R;
        const T = this.getDirection();
        T && (H.dir = T);
      }
      return {
        element: H
      };
    }
    static importJSON(j) {
      const H = x(j.tag);
      return H.setFormat(j.format), H.setIndent(j.indent), H.setDirection(j.direction), H;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        tag: this.getTag(),
        type: "heading",
        version: 1
      };
    }
    // Mutation
    insertNewAfter(j, H = !0) {
      const R = j ? j.anchor.offset : 0, T = R === this.getTextContentSize() || !j ? n.$createParagraphNode() : x(this.getTag()), $ = this.getDirection();
      if (T.setDirection($), this.insertAfter(T, H), R === 0 && !this.isEmpty() && j) {
        const G = n.$createParagraphNode();
        G.select(), this.replace(G, !0);
      }
      return T;
    }
    collapseAtStart() {
      const j = this.isEmpty() ? n.$createParagraphNode() : x(this.getTag());
      return this.getChildren().forEach((R) => j.append(R)), this.replace(j), !0;
    }
    extractWithChild() {
      return !0;
    }
  }
  function v(U) {
    return U.nodeName.toLowerCase() === "span" ? U.style.fontSize === "26pt" : !1;
  }
  function C(U) {
    const j = U.nodeName.toLowerCase();
    let H = null;
    return (j === "h1" || j === "h2" || j === "h3" || j === "h4" || j === "h5" || j === "h6") && (H = x(j), U.style !== null && H.setFormat(U.style.textAlign)), {
      node: H
    };
  }
  function g(U) {
    const j = h();
    return U.style !== null && j.setFormat(U.style.textAlign), {
      node: j
    };
  }
  function x(U) {
    return n.$applyNodeReplacement(new N(U));
  }
  function b(U) {
    return U instanceof N;
  }
  function A(U, j) {
    U.preventDefault(), j.update(() => {
      const H = n.$getSelection(), R = U instanceof InputEvent || U instanceof KeyboardEvent ? null : U.clipboardData;
      R != null && H !== null && r.$insertDataTransferForRichText(R, H, j);
    }, {
      tag: "paste"
    });
  }
  async function w(U, j) {
    await r.copyToClipboard(j, t.objectKlassEquals(U, ClipboardEvent) ? U : null), j.update(() => {
      const H = n.$getSelection();
      n.$isRangeSelection(H) ? H.removeText() : n.$isNodeSelection(H) && H.getNodes().forEach((R) => R.remove());
    });
  }
  function M(U) {
    let j = null;
    if (U instanceof DragEvent ? j = U.dataTransfer : U instanceof ClipboardEvent && (j = U.clipboardData), j === null)
      return [!1, [], !1];
    const H = j.types, R = H.includes("Files"), T = H.includes("text/html") || H.includes("text/plain");
    return [R, Array.from(j.files), T];
  }
  function y(U) {
    const j = n.$getSelection();
    if (!n.$isRangeSelection(j))
      return !1;
    const H = /* @__PURE__ */ new Set(), R = j.getNodes();
    for (let T = 0; T < R.length; T++) {
      const $ = R[T], G = $.getKey();
      if (H.has(G))
        continue;
      const q = t.$getNearestBlockElementAncestorOrThrow($), I = q.getKey();
      q.canIndent() && !H.has(I) && (H.add(I), U(q));
    }
    return H.size > 0;
  }
  function E(U) {
    const j = n.$getNearestNodeFromDOMNode(U);
    return n.$isDecoratorNode(j);
  }
  function S(U) {
    const j = U.focus;
    return j.key === "root" && j.offset === n.$getRoot().getChildrenSize();
  }
  function P(U) {
    return t.mergeRegister(U.registerCommand(n.CLICK_COMMAND, (H) => {
      const R = n.$getSelection();
      return n.$isNodeSelection(R) ? (R.clear(), !0) : !1;
    }, 0), U.registerCommand(n.DELETE_CHARACTER_COMMAND, (H) => {
      const R = n.$getSelection();
      return n.$isRangeSelection(R) ? (R.deleteCharacter(H), !0) : !1;
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.DELETE_WORD_COMMAND, (H) => {
      const R = n.$getSelection();
      return n.$isRangeSelection(R) ? (R.deleteWord(H), !0) : !1;
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.DELETE_LINE_COMMAND, (H) => {
      const R = n.$getSelection();
      return n.$isRangeSelection(R) ? (R.deleteLine(H), !0) : !1;
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.CONTROLLED_TEXT_INSERTION_COMMAND, (H) => {
      const R = n.$getSelection();
      if (typeof H == "string")
        R !== null && R.insertText(H);
      else {
        if (R === null)
          return !1;
        const T = H.dataTransfer;
        if (T != null)
          r.$insertDataTransferForRichText(T, R, U);
        else if (n.$isRangeSelection(R)) {
          const $ = H.data;
          return $ && R.insertText($), !0;
        }
      }
      return !0;
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.REMOVE_TEXT_COMMAND, () => {
      const H = n.$getSelection();
      return n.$isRangeSelection(H) ? (H.removeText(), !0) : !1;
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.FORMAT_TEXT_COMMAND, (H) => {
      const R = n.$getSelection();
      return n.$isRangeSelection(R) ? (R.formatText(H), !0) : !1;
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.FORMAT_ELEMENT_COMMAND, (H) => {
      const R = n.$getSelection();
      if (!n.$isRangeSelection(R) && !n.$isNodeSelection(R))
        return !1;
      const T = R.getNodes();
      for (const $ of T) {
        const G = t.$findMatchingParent($, (q) => n.$isElementNode(q) && !q.isInline());
        G !== null && G.setFormat(H);
      }
      return !0;
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.INSERT_LINE_BREAK_COMMAND, (H) => {
      const R = n.$getSelection();
      return n.$isRangeSelection(R) ? (R.insertLineBreak(H), !0) : !1;
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.INSERT_PARAGRAPH_COMMAND, () => {
      const H = n.$getSelection();
      return n.$isRangeSelection(H) ? (H.insertParagraph(), !0) : !1;
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.INSERT_TAB_COMMAND, () => (n.$insertNodes([n.$createTabNode()]), !0), n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.INDENT_CONTENT_COMMAND, () => y((H) => {
      const R = H.getIndent();
      H.setIndent(R + 1);
    }), n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.OUTDENT_CONTENT_COMMAND, () => y((H) => {
      const R = H.getIndent();
      R > 0 && H.setIndent(R - 1);
    }), n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.KEY_ARROW_UP_COMMAND, (H) => {
      const R = n.$getSelection();
      if (n.$isNodeSelection(R) && !E(H.target)) {
        const T = R.getNodes();
        if (T.length > 0)
          return T[0].selectPrevious(), !0;
      } else if (n.$isRangeSelection(R)) {
        const T = n.$getAdjacentNode(R.focus, !0);
        if (!H.shiftKey && n.$isDecoratorNode(T) && !T.isIsolated() && !T.isInline())
          return T.selectPrevious(), H.preventDefault(), !0;
      }
      return !1;
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.KEY_ARROW_DOWN_COMMAND, (H) => {
      const R = n.$getSelection();
      if (n.$isNodeSelection(R)) {
        const T = R.getNodes();
        if (T.length > 0)
          return T[0].selectNext(0, 0), !0;
      } else if (n.$isRangeSelection(R)) {
        if (S(R))
          return H.preventDefault(), !0;
        const T = n.$getAdjacentNode(R.focus, !1);
        if (!H.shiftKey && n.$isDecoratorNode(T) && !T.isIsolated() && !T.isInline())
          return T.selectNext(), H.preventDefault(), !0;
      }
      return !1;
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.KEY_ARROW_LEFT_COMMAND, (H) => {
      const R = n.$getSelection();
      if (n.$isNodeSelection(R)) {
        const T = R.getNodes();
        if (T.length > 0)
          return H.preventDefault(), T[0].selectPrevious(), !0;
      }
      if (!n.$isRangeSelection(R))
        return !1;
      if (e.$shouldOverrideDefaultCharacterSelection(R, !0)) {
        const T = H.shiftKey;
        return H.preventDefault(), e.$moveCharacter(R, T, !0), !0;
      }
      return !1;
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.KEY_ARROW_RIGHT_COMMAND, (H) => {
      const R = n.$getSelection();
      if (n.$isNodeSelection(R) && !E(H.target)) {
        const $ = R.getNodes();
        if ($.length > 0)
          return H.preventDefault(), $[0].selectNext(0, 0), !0;
      }
      if (!n.$isRangeSelection(R))
        return !1;
      const T = H.shiftKey;
      return e.$shouldOverrideDefaultCharacterSelection(R, !1) ? (H.preventDefault(), e.$moveCharacter(R, T, !1), !0) : !1;
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.KEY_BACKSPACE_COMMAND, (H) => {
      if (E(H.target))
        return !1;
      const R = n.$getSelection();
      if (!n.$isRangeSelection(R))
        return !1;
      H.preventDefault();
      const {
        anchor: T
      } = R, $ = T.getNode();
      return R.isCollapsed() && T.offset === 0 && !n.$isRootNode($) && t.$getNearestBlockElementAncestorOrThrow($).getIndent() > 0 ? U.dispatchCommand(n.OUTDENT_CONTENT_COMMAND, void 0) : U.dispatchCommand(n.DELETE_CHARACTER_COMMAND, !0);
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.KEY_DELETE_COMMAND, (H) => {
      if (E(H.target))
        return !1;
      const R = n.$getSelection();
      return n.$isRangeSelection(R) ? (H.preventDefault(), U.dispatchCommand(n.DELETE_CHARACTER_COMMAND, !1)) : !1;
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.KEY_ENTER_COMMAND, (H) => {
      const R = n.$getSelection();
      if (!n.$isRangeSelection(R))
        return !1;
      if (H !== null) {
        if ((u || l || p) && a)
          return !1;
        if (H.preventDefault(), H.shiftKey)
          return U.dispatchCommand(n.INSERT_LINE_BREAK_COMMAND, !1);
      }
      return U.dispatchCommand(n.INSERT_PARAGRAPH_COMMAND, void 0);
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.KEY_ESCAPE_COMMAND, () => {
      const H = n.$getSelection();
      return n.$isRangeSelection(H) ? (U.blur(), !0) : !1;
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.DROP_COMMAND, (H) => {
      const [, R] = M(H);
      if (R.length > 0) {
        const $ = H.clientX, G = H.clientY, q = i($, G);
        if (q !== null) {
          const {
            offset: I,
            node: Y
          } = q, D = n.$getNearestNodeFromDOMNode(Y);
          if (D !== null) {
            const z = n.$createRangeSelection();
            if (n.$isTextNode(D))
              z.anchor.set(D.getKey(), I, "text"), z.focus.set(D.getKey(), I, "text");
            else {
              const Q = D.getParentOrThrow().getKey(), ne = D.getIndexWithinParent() + 1;
              z.anchor.set(Q, ne, "element"), z.focus.set(Q, ne, "element");
            }
            const X = n.$normalizeSelection__EXPERIMENTAL(z);
            n.$setSelection(X);
          }
          U.dispatchCommand(m, R);
        }
        return H.preventDefault(), !0;
      }
      const T = n.$getSelection();
      return !!n.$isRangeSelection(T);
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.DRAGSTART_COMMAND, (H) => {
      const [R] = M(H), T = n.$getSelection();
      return !(R && !n.$isRangeSelection(T));
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.DRAGOVER_COMMAND, (H) => {
      const [R] = M(H), T = n.$getSelection();
      if (R && !n.$isRangeSelection(T))
        return !1;
      const $ = H.clientX, G = H.clientY, q = i($, G);
      if (q !== null) {
        const I = n.$getNearestNodeFromDOMNode(q.node);
        n.$isDecoratorNode(I) && H.preventDefault();
      }
      return !0;
    }, n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.SELECT_ALL_COMMAND, () => (n.$selectAll(), !0), n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.COPY_COMMAND, (H) => (r.copyToClipboard(U, t.objectKlassEquals(H, ClipboardEvent) ? H : null), !0), n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.CUT_COMMAND, (H) => (w(H, U), !0), n.COMMAND_PRIORITY_EDITOR), U.registerCommand(n.PASTE_COMMAND, (H) => {
      const [, R, T] = M(H);
      return R.length > 0 && !T ? (U.dispatchCommand(m, R), !0) : n.isSelectionCapturedInDecoratorInput(H.target) ? !1 : n.$getSelection() !== null ? (A(H, U), !0) : !1;
    }, n.COMMAND_PRIORITY_EDITOR));
  }
  return wr.$createHeadingNode = x, wr.$createQuoteNode = h, wr.$isHeadingNode = b, wr.$isQuoteNode = f, wr.DRAG_DROP_PASTE = m, wr.HeadingNode = N, wr.QuoteNode = c, wr.eventFiles = M, wr.registerRichText = P, wr;
}
var Tr = {}, p0;
function Pf() {
  if (p0) return Tr;
  p0 = 1;
  var r = Wu(), e = en(), t = it(), n = Ve;
  function i(y, E) {
    return typeof document.caretRangeFromPoint < "u" ? (y = document.caretRangeFromPoint(y, E), y === null ? null : { node: y.startContainer, offset: y.startOffset }) : document.caretPositionFromPoint !== "undefined" ? (y = document.caretPositionFromPoint(y, E), y === null ? null : { node: y.offsetNode, offset: y.offset }) : null;
  }
  let o = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", s = o && "documentMode" in document ? document.documentMode : null, a = o && "InputEvent" in window && !s ? "getTargetRanges" in new window.InputEvent("input") : !1, l = o && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), u = o && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, d = o && /^(?=.*Chrome).*/i.test(navigator.userAgent), p = o && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !d, m = n.createCommand("DRAG_DROP_PASTE_FILE");
  class c extends n.ElementNode {
    static getType() {
      return "quote";
    }
    static clone(E) {
      return new c(E.__key);
    }
    constructor(E) {
      super(E);
    }
    createDOM(E) {
      let S = document.createElement("blockquote");
      return t.addClassNamesToElement(S, E.theme.quote), S;
    }
    updateDOM() {
      return !1;
    }
    static importDOM() {
      return { blockquote: () => ({ conversion: C, priority: 0 }) };
    }
    exportDOM(E) {
      if ({ element: E } = super.exportDOM(E), E && t.isHTMLElement(E)) {
        this.isEmpty() && E.append(document.createElement("br"));
        var S = this.getFormatType();
        E.style.textAlign = S, (S = this.getDirection()) && (E.dir = S);
      }
      return { element: E };
    }
    static importJSON(E) {
      let S = h();
      return S.setFormat(E.format), S.setIndent(E.indent), S.setDirection(E.direction), S;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "quote" };
    }
    insertNewAfter(E, S) {
      E = n.$createParagraphNode();
      let P = this.getDirection();
      return E.setDirection(P), this.insertAfter(E, S), E;
    }
    collapseAtStart() {
      let E = n.$createParagraphNode();
      return this.getChildren().forEach((S) => E.append(S)), this.replace(E), !0;
    }
  }
  function h() {
    return n.$applyNodeReplacement(new c());
  }
  class f extends n.ElementNode {
    static getType() {
      return "heading";
    }
    static clone(E) {
      return new f(E.__tag, E.__key);
    }
    constructor(E, S) {
      super(S), this.__tag = E;
    }
    getTag() {
      return this.__tag;
    }
    createDOM(E) {
      let S = this.__tag, P = document.createElement(S);
      return E = E.theme.heading, E !== void 0 && t.addClassNamesToElement(P, E[S]), P;
    }
    updateDOM() {
      return !1;
    }
    static importDOM() {
      return { h1: () => ({ conversion: v, priority: 0 }), h2: () => ({ conversion: v, priority: 0 }), h3: () => ({ conversion: v, priority: 0 }), h4: () => ({ conversion: v, priority: 0 }), h5: () => ({
        conversion: v,
        priority: 0
      }), h6: () => ({ conversion: v, priority: 0 }), p: (E) => (E = E.firstChild, E !== null && N(E) ? { conversion: () => ({ node: null }), priority: 3 } : null), span: (E) => N(E) ? { conversion: () => ({ node: g("h1") }), priority: 3 } : null };
    }
    exportDOM(E) {
      if ({ element: E } = super.exportDOM(E), E && t.isHTMLElement(E)) {
        this.isEmpty() && E.append(document.createElement("br"));
        var S = this.getFormatType();
        E.style.textAlign = S, (S = this.getDirection()) && (E.dir = S);
      }
      return { element: E };
    }
    static importJSON(E) {
      let S = g(E.tag);
      return S.setFormat(E.format), S.setIndent(E.indent), S.setDirection(E.direction), S;
    }
    exportJSON() {
      return { ...super.exportJSON(), tag: this.getTag(), type: "heading", version: 1 };
    }
    insertNewAfter(E, S = !0) {
      let P = E ? E.anchor.offset : 0, U = P !== this.getTextContentSize() && E ? g(this.getTag()) : n.$createParagraphNode(), j = this.getDirection();
      return U.setDirection(j), this.insertAfter(U, S), P === 0 && !this.isEmpty() && E && (E = n.$createParagraphNode(), E.select(), this.replace(E, !0)), U;
    }
    collapseAtStart() {
      let E = this.isEmpty() ? n.$createParagraphNode() : g(this.getTag());
      return this.getChildren().forEach((S) => E.append(S)), this.replace(E), !0;
    }
    extractWithChild() {
      return !0;
    }
  }
  function N(y) {
    return y.nodeName.toLowerCase() === "span" ? y.style.fontSize === "26pt" : !1;
  }
  function v(y) {
    let E = y.nodeName.toLowerCase(), S = null;
    return (E === "h1" || E === "h2" || E === "h3" || E === "h4" || E === "h5" || E === "h6") && (S = g(E), y.style !== null && S.setFormat(y.style.textAlign)), { node: S };
  }
  function C(y) {
    let E = h();
    return y.style !== null && E.setFormat(y.style.textAlign), { node: E };
  }
  function g(y) {
    return n.$applyNodeReplacement(new f(y));
  }
  function x(y, E) {
    y.preventDefault(), E.update(() => {
      let S = n.$getSelection(), P = y instanceof InputEvent || y instanceof KeyboardEvent ? null : y.clipboardData;
      P != null && S !== null && r.$insertDataTransferForRichText(P, S, E);
    }, { tag: "paste" });
  }
  async function b(y, E) {
    await r.copyToClipboard(E, t.objectKlassEquals(y, ClipboardEvent) ? y : null), E.update(() => {
      let S = n.$getSelection();
      n.$isRangeSelection(S) ? S.removeText() : n.$isNodeSelection(S) && S.getNodes().forEach((P) => P.remove());
    });
  }
  function A(y) {
    let E = null;
    if (y instanceof DragEvent ? E = y.dataTransfer : y instanceof ClipboardEvent && (E = y.clipboardData), E === null) return [!1, [], !1];
    var S = E.types;
    return y = S.includes("Files"), S = S.includes("text/html") || S.includes("text/plain"), [y, Array.from(E.files), S];
  }
  function w(y) {
    var E = n.$getSelection();
    if (!n.$isRangeSelection(E)) return !1;
    let S = /* @__PURE__ */ new Set();
    E = E.getNodes();
    for (let j = 0; j < E.length; j++) {
      var P = E[j], U = P.getKey();
      S.has(U) || (P = t.$getNearestBlockElementAncestorOrThrow(P), U = P.getKey(), P.canIndent() && !S.has(U) && (S.add(U), y(P)));
    }
    return 0 < S.size;
  }
  function M(y) {
    return y = n.$getNearestNodeFromDOMNode(y), n.$isDecoratorNode(y);
  }
  return Tr.$createHeadingNode = g, Tr.$createQuoteNode = h, Tr.$isHeadingNode = function(y) {
    return y instanceof f;
  }, Tr.$isQuoteNode = function(y) {
    return y instanceof c;
  }, Tr.DRAG_DROP_PASTE = m, Tr.HeadingNode = f, Tr.QuoteNode = c, Tr.eventFiles = A, Tr.registerRichText = function(y) {
    return t.mergeRegister(
      y.registerCommand(n.CLICK_COMMAND, () => {
        const E = n.$getSelection();
        return n.$isNodeSelection(E) ? (E.clear(), !0) : !1;
      }, 0),
      y.registerCommand(n.DELETE_CHARACTER_COMMAND, (E) => {
        const S = n.$getSelection();
        return n.$isRangeSelection(S) ? (S.deleteCharacter(E), !0) : !1;
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.DELETE_WORD_COMMAND, (E) => {
        const S = n.$getSelection();
        return n.$isRangeSelection(S) ? (S.deleteWord(E), !0) : !1;
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.DELETE_LINE_COMMAND, (E) => {
        const S = n.$getSelection();
        return n.$isRangeSelection(S) ? (S.deleteLine(E), !0) : !1;
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.CONTROLLED_TEXT_INSERTION_COMMAND, (E) => {
        const S = n.$getSelection();
        if (typeof E == "string") S !== null && S.insertText(E);
        else {
          if (S === null) return !1;
          const P = E.dataTransfer;
          P != null ? r.$insertDataTransferForRichText(P, S, y) : n.$isRangeSelection(S) && (E = E.data) && S.insertText(E);
        }
        return !0;
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(
        n.REMOVE_TEXT_COMMAND,
        () => {
          const E = n.$getSelection();
          return n.$isRangeSelection(E) ? (E.removeText(), !0) : !1;
        },
        n.COMMAND_PRIORITY_EDITOR
      ),
      y.registerCommand(n.FORMAT_TEXT_COMMAND, (E) => {
        const S = n.$getSelection();
        return n.$isRangeSelection(S) ? (S.formatText(E), !0) : !1;
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.FORMAT_ELEMENT_COMMAND, (E) => {
        var S = n.$getSelection();
        if (!n.$isRangeSelection(S) && !n.$isNodeSelection(S)) return !1;
        S = S.getNodes();
        for (const P of S) S = t.$findMatchingParent(P, (U) => n.$isElementNode(U) && !U.isInline()), S !== null && S.setFormat(E);
        return !0;
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.INSERT_LINE_BREAK_COMMAND, (E) => {
        const S = n.$getSelection();
        return n.$isRangeSelection(S) ? (S.insertLineBreak(E), !0) : !1;
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.INSERT_PARAGRAPH_COMMAND, () => {
        const E = n.$getSelection();
        return n.$isRangeSelection(E) ? (E.insertParagraph(), !0) : !1;
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.INSERT_TAB_COMMAND, () => (n.$insertNodes([n.$createTabNode()]), !0), n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.INDENT_CONTENT_COMMAND, () => w((E) => {
        const S = E.getIndent();
        E.setIndent(S + 1);
      }), n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.OUTDENT_CONTENT_COMMAND, () => w((E) => {
        const S = E.getIndent();
        0 < S && E.setIndent(S - 1);
      }), n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.KEY_ARROW_UP_COMMAND, (E) => {
        var S = n.$getSelection();
        if (n.$isNodeSelection(S) && !M(E.target)) {
          if (E = S.getNodes(), 0 < E.length) return E[0].selectPrevious(), !0;
        } else if (n.$isRangeSelection(S) && (S = n.$getAdjacentNode(S.focus, !0), !E.shiftKey && n.$isDecoratorNode(S) && !S.isIsolated() && !S.isInline())) return S.selectPrevious(), E.preventDefault(), !0;
        return !1;
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.KEY_ARROW_DOWN_COMMAND, (E) => {
        var S = n.$getSelection();
        if (n.$isNodeSelection(S)) {
          if (E = S.getNodes(), 0 < E.length) return E[0].selectNext(0, 0), !0;
        } else if (n.$isRangeSelection(S)) {
          let P = S.focus;
          if (P.key === "root" && P.offset === n.$getRoot().getChildrenSize()) return E.preventDefault(), !0;
          if (S = n.$getAdjacentNode(S.focus, !1), !E.shiftKey && n.$isDecoratorNode(S) && !S.isIsolated() && !S.isInline()) return S.selectNext(), E.preventDefault(), !0;
        }
        return !1;
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.KEY_ARROW_LEFT_COMMAND, (E) => {
        const S = n.$getSelection();
        if (n.$isNodeSelection(S)) {
          var P = S.getNodes();
          if (0 < P.length) return E.preventDefault(), P[0].selectPrevious(), !0;
        }
        return n.$isRangeSelection(S) && e.$shouldOverrideDefaultCharacterSelection(S, !0) ? (P = E.shiftKey, E.preventDefault(), e.$moveCharacter(S, P, !0), !0) : !1;
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.KEY_ARROW_RIGHT_COMMAND, (E) => {
        const S = n.$getSelection();
        if (n.$isNodeSelection(S) && !M(E.target)) {
          var P = S.getNodes();
          if (0 < P.length) return E.preventDefault(), P[0].selectNext(0, 0), !0;
        }
        return n.$isRangeSelection(S) ? (P = E.shiftKey, e.$shouldOverrideDefaultCharacterSelection(S, !1) ? (E.preventDefault(), e.$moveCharacter(S, P, !1), !0) : !1) : !1;
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.KEY_BACKSPACE_COMMAND, (E) => {
        if (M(E.target)) return !1;
        const S = n.$getSelection();
        if (!n.$isRangeSelection(S)) return !1;
        E.preventDefault(), { anchor: E } = S;
        const P = E.getNode();
        return S.isCollapsed() && E.offset === 0 && !n.$isRootNode(P) && 0 < t.$getNearestBlockElementAncestorOrThrow(P).getIndent() ? y.dispatchCommand(n.OUTDENT_CONTENT_COMMAND, void 0) : y.dispatchCommand(n.DELETE_CHARACTER_COMMAND, !0);
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.KEY_DELETE_COMMAND, (E) => {
        if (M(E.target)) return !1;
        const S = n.$getSelection();
        return n.$isRangeSelection(S) ? (E.preventDefault(), y.dispatchCommand(n.DELETE_CHARACTER_COMMAND, !1)) : !1;
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.KEY_ENTER_COMMAND, (E) => {
        const S = n.$getSelection();
        if (!n.$isRangeSelection(S)) return !1;
        if (E !== null) {
          if ((u || l || p) && a) return !1;
          if (E.preventDefault(), E.shiftKey) return y.dispatchCommand(n.INSERT_LINE_BREAK_COMMAND, !1);
        }
        return y.dispatchCommand(n.INSERT_PARAGRAPH_COMMAND, void 0);
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.KEY_ESCAPE_COMMAND, () => {
        const E = n.$getSelection();
        return n.$isRangeSelection(E) ? (y.blur(), !0) : !1;
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.DROP_COMMAND, (E) => {
        const [, S] = A(E);
        if (0 < S.length) {
          var P = i(E.clientX, E.clientY);
          if (P !== null) {
            const { offset: j, node: H } = P;
            var U = n.$getNearestNodeFromDOMNode(H);
            if (U !== null) {
              if (P = n.$createRangeSelection(), n.$isTextNode(U)) P.anchor.set(U.getKey(), j, "text"), P.focus.set(U.getKey(), j, "text");
              else {
                const R = U.getParentOrThrow().getKey();
                U = U.getIndexWithinParent() + 1, P.anchor.set(R, U, "element"), P.focus.set(R, U, "element");
              }
              P = n.$normalizeSelection__EXPERIMENTAL(P), n.$setSelection(P);
            }
            y.dispatchCommand(m, S);
          }
          return E.preventDefault(), !0;
        }
        return E = n.$getSelection(), !!n.$isRangeSelection(E);
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.DRAGSTART_COMMAND, (E) => {
        [E] = A(E);
        const S = n.$getSelection();
        return !(E && !n.$isRangeSelection(S));
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.DRAGOVER_COMMAND, (E) => {
        var [S] = A(E);
        const P = n.$getSelection();
        return S && !n.$isRangeSelection(P) ? !1 : (S = i(E.clientX, E.clientY), S !== null && (S = n.$getNearestNodeFromDOMNode(S.node), n.$isDecoratorNode(S) && E.preventDefault()), !0);
      }, n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.SELECT_ALL_COMMAND, () => (n.$selectAll(), !0), n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.COPY_COMMAND, (E) => (r.copyToClipboard(y, t.objectKlassEquals(E, ClipboardEvent) ? E : null), !0), n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.CUT_COMMAND, (E) => (b(E, y), !0), n.COMMAND_PRIORITY_EDITOR),
      y.registerCommand(n.PASTE_COMMAND, (E) => {
        const [, S, P] = A(E);
        return 0 < S.length && !P ? (y.dispatchCommand(m, S), !0) : n.isSelectionCapturedInDecoratorInput(E.target) ? !1 : n.$getSelection() !== null ? (x(E, y), !0) : !1;
      }, n.COMMAND_PRIORITY_EDITOR)
    );
  }, Tr;
}
const Ff = process.env.NODE_ENV === "development" ? If() : Pf();
var fr = Ff, ft = {}, v0;
function Bf() {
  if (v0) return ft;
  v0 = 1;
  var r = it(), e = Ve;
  const t = /^(\d+(?:\.\d+)?)px$/, n = {
    BOTH: 3,
    COLUMN: 2,
    NO_STATUS: 0,
    ROW: 1
  };
  class i extends e.ElementNode {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "tablecell";
    }
    static clone(Z) {
      const re = new i(Z.__headerState, Z.__colSpan, Z.__width, Z.__key);
      return re.__rowSpan = Z.__rowSpan, re.__backgroundColor = Z.__backgroundColor, re;
    }
    static importDOM() {
      return {
        td: (Z) => ({
          conversion: o,
          priority: 0
        }),
        th: (Z) => ({
          conversion: o,
          priority: 0
        })
      };
    }
    static importJSON(Z) {
      const re = Z.colSpan || 1, ce = Z.rowSpan || 1, ve = s(Z.headerState, re, Z.width || void 0);
      return ve.__rowSpan = ce, ve.__backgroundColor = Z.backgroundColor || null, ve;
    }
    constructor(Z = n.NO_STATUS, re = 1, ce, ve) {
      super(ve), this.__colSpan = re, this.__rowSpan = 1, this.__headerState = Z, this.__width = ce, this.__backgroundColor = null;
    }
    createDOM(Z) {
      const re = document.createElement(this.getTag());
      return this.__width && (re.style.width = `${this.__width}px`), this.__colSpan > 1 && (re.colSpan = this.__colSpan), this.__rowSpan > 1 && (re.rowSpan = this.__rowSpan), this.__backgroundColor !== null && (re.style.backgroundColor = this.__backgroundColor), r.addClassNamesToElement(re, Z.theme.tableCell, this.hasHeader() && Z.theme.tableCellHeader), re;
    }
    exportDOM(Z) {
      const {
        element: re
      } = super.exportDOM(Z);
      if (re) {
        const ce = re, ve = 700, he = this.getParentOrThrow().getChildrenSize();
        ce.style.border = "1px solid black", this.__colSpan > 1 && (ce.colSpan = this.__colSpan), this.__rowSpan > 1 && (ce.rowSpan = this.__rowSpan), ce.style.width = `${this.getWidth() || Math.max(90, ve / he)}px`, ce.style.verticalAlign = "top", ce.style.textAlign = "start";
        const Te = this.getBackgroundColor();
        Te !== null ? ce.style.backgroundColor = Te : this.hasHeader() && (ce.style.backgroundColor = "#f2f3f5");
      }
      return {
        element: re
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        backgroundColor: this.getBackgroundColor(),
        colSpan: this.__colSpan,
        headerState: this.__headerState,
        rowSpan: this.__rowSpan,
        type: "tablecell",
        width: this.getWidth()
      };
    }
    getColSpan() {
      return this.__colSpan;
    }
    setColSpan(Z) {
      return this.getWritable().__colSpan = Z, this;
    }
    getRowSpan() {
      return this.__rowSpan;
    }
    setRowSpan(Z) {
      return this.getWritable().__rowSpan = Z, this;
    }
    getTag() {
      return this.hasHeader() ? "th" : "td";
    }
    setHeaderStyles(Z) {
      const re = this.getWritable();
      return re.__headerState = Z, this.__headerState;
    }
    getHeaderStyles() {
      return this.getLatest().__headerState;
    }
    setWidth(Z) {
      const re = this.getWritable();
      return re.__width = Z, this.__width;
    }
    getWidth() {
      return this.getLatest().__width;
    }
    getBackgroundColor() {
      return this.getLatest().__backgroundColor;
    }
    setBackgroundColor(Z) {
      this.getWritable().__backgroundColor = Z;
    }
    toggleHeaderStyle(Z) {
      const re = this.getWritable();
      return (re.__headerState & Z) === Z ? re.__headerState -= Z : re.__headerState += Z, re;
    }
    hasHeaderState(Z) {
      return (this.getHeaderStyles() & Z) === Z;
    }
    hasHeader() {
      return this.getLatest().__headerState !== n.NO_STATUS;
    }
    updateDOM(Z) {
      return Z.__headerState !== this.__headerState || Z.__width !== this.__width || Z.__colSpan !== this.__colSpan || Z.__rowSpan !== this.__rowSpan || Z.__backgroundColor !== this.__backgroundColor;
    }
    isShadowRoot() {
      return !0;
    }
    collapseAtStart() {
      return !0;
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
  }
  function o(le) {
    const Z = le, re = le.nodeName.toLowerCase();
    let ce;
    t.test(Z.style.width) && (ce = parseFloat(Z.style.width));
    const ve = s(re === "th" ? n.ROW : n.NO_STATUS, Z.colSpan, ce);
    ve.__rowSpan = Z.rowSpan;
    const he = Z.style.backgroundColor;
    return he !== "" && (ve.__backgroundColor = he), {
      forChild: (Te, De) => {
        if (a(De) && !e.$isElementNode(Te)) {
          const Pe = e.$createParagraphNode();
          return e.$isLineBreakNode(Te) && Te.getTextContent() === `
` ? null : (Pe.append(Te), Pe);
        }
        return Te;
      },
      node: ve
    };
  }
  function s(le, Z = 1, re) {
    return e.$applyNodeReplacement(new i(le, Z, re));
  }
  function a(le) {
    return le instanceof i;
  }
  const l = e.createCommand("INSERT_TABLE_COMMAND");
  class u extends e.ElementNode {
    /** @internal */
    static getType() {
      return "tablerow";
    }
    static clone(Z) {
      return new u(Z.__height, Z.__key);
    }
    static importDOM() {
      return {
        tr: (Z) => ({
          conversion: d,
          priority: 0
        })
      };
    }
    static importJSON(Z) {
      return p(Z.height);
    }
    constructor(Z, re) {
      super(re), this.__height = Z;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "tablerow",
        version: 1
      };
    }
    createDOM(Z) {
      const re = document.createElement("tr");
      return this.__height && (re.style.height = `${this.__height}px`), r.addClassNamesToElement(re, Z.theme.tableRow), re;
    }
    isShadowRoot() {
      return !0;
    }
    setHeight(Z) {
      const re = this.getWritable();
      return re.__height = Z, this.__height;
    }
    getHeight() {
      return this.getLatest().__height;
    }
    updateDOM(Z) {
      return Z.__height !== this.__height;
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
  }
  function d(le) {
    const Z = le;
    let re;
    return t.test(Z.style.height) && (re = parseFloat(Z.style.height)), {
      node: p(re)
    };
  }
  function p(le) {
    return e.$applyNodeReplacement(new u(le));
  }
  function m(le) {
    return le instanceof u;
  }
  const c = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  function h(le, Z, re = !0) {
    const ce = Ct();
    for (let ve = 0; ve < le; ve++) {
      const he = p();
      for (let Te = 0; Te < Z; Te++) {
        let De = n.NO_STATUS;
        typeof re == "object" ? (ve === 0 && re.rows && (De |= n.ROW), Te === 0 && re.columns && (De |= n.COLUMN)) : re && (ve === 0 && (De |= n.ROW), Te === 0 && (De |= n.COLUMN));
        const Pe = s(De), Ae = e.$createParagraphNode();
        Ae.append(e.$createTextNode()), Pe.append(Ae), he.append(Pe);
      }
      ce.append(he);
    }
    return ce;
  }
  function f(le) {
    const Z = r.$findMatchingParent(le, (re) => a(re));
    return a(Z) ? Z : null;
  }
  function N(le) {
    const Z = r.$findMatchingParent(le, (re) => m(re));
    if (m(Z))
      return Z;
    throw new Error("Expected table cell to be inside of table row.");
  }
  function v(le) {
    const Z = r.$findMatchingParent(le, (re) => Je(re));
    if (Je(Z))
      return Z;
    throw new Error("Expected table cell to be inside of table.");
  }
  function C(le) {
    const Z = N(le);
    return v(Z).getChildren().findIndex((ce) => ce.is(Z));
  }
  function g(le) {
    return N(le).getChildren().findIndex((re) => re.is(le));
  }
  function x(le, Z) {
    const re = v(le), {
      x: ce,
      y: ve
    } = re.getCordsFromCellNode(le, Z);
    return {
      above: re.getCellNodeFromCords(ce, ve - 1, Z),
      below: re.getCellNodeFromCords(ce, ve + 1, Z),
      left: re.getCellNodeFromCords(ce - 1, ve, Z),
      right: re.getCellNodeFromCords(ce + 1, ve, Z)
    };
  }
  function b(le, Z) {
    const re = le.getChildren();
    if (Z >= re.length || Z < 0)
      throw new Error("Expected table cell to be inside of table row.");
    return re[Z].remove(), le;
  }
  function A(le, Z, re = !0, ce, ve) {
    const he = le.getChildren();
    if (Z >= he.length || Z < 0)
      throw new Error("Table row target index out of range");
    const Te = he[Z];
    if (m(Te))
      for (let De = 0; De < ce; De++) {
        const Pe = Te.getChildren(), Ae = Pe.length, qe = p();
        for (let be = 0; be < Ae; be++) {
          const Ce = Pe[be];
          if (!a(Ce))
            throw Error("Expected table cell");
          const {
            above: Le,
            below: je
          } = x(Ce, ve);
          let Ke = n.NO_STATUS;
          const Ue = Le && Le.getWidth() || je && je.getWidth() || void 0;
          (Le && Le.hasHeaderState(n.COLUMN) || je && je.hasHeaderState(n.COLUMN)) && (Ke |= n.COLUMN);
          const tt = s(Ke, 1, Ue);
          tt.append(e.$createParagraphNode()), qe.append(tt);
        }
        re ? Te.insertAfter(qe) : Te.insertBefore(qe);
      }
    else
      throw new Error("Row before insertion index does not exist.");
    return le;
  }
  const w = (le, Z) => le === n.BOTH || le === Z ? Z : n.NO_STATUS;
  function M(le = !0) {
    const Z = e.$getSelection();
    if (!(e.$isRangeSelection(Z) || I(Z)))
      throw Error("Expected a RangeSelection or GridSelection");
    const re = Z.focus.getNode(), [ce, , ve] = $(re), [he, Te] = T(ve, ce, ce), De = he[0].length, {
      startRow: Pe
    } = Te;
    if (le) {
      const Ae = Pe + ce.__rowSpan - 1, qe = he[Ae], be = p();
      for (let Le = 0; Le < De; Le++) {
        const {
          cell: je,
          startRow: Ke
        } = qe[Le];
        if (Ke + je.__rowSpan - 1 <= Ae) {
          const tt = qe[Le].cell.__headerState, Ze = w(tt, n.COLUMN);
          be.append(s(Ze).append(e.$createParagraphNode()));
        } else
          je.setRowSpan(je.__rowSpan + 1);
      }
      const Ce = ve.getChildAtIndex(Ae);
      if (!m(Ce))
        throw Error("focusEndRow is not a TableRowNode");
      Ce.insertAfter(be);
    } else {
      const Ae = he[Pe], qe = p();
      for (let Ce = 0; Ce < De; Ce++) {
        const {
          cell: Le,
          startRow: je
        } = Ae[Ce];
        if (je === Pe) {
          const Ue = Ae[Ce].cell.__headerState, tt = w(Ue, n.COLUMN);
          qe.append(s(tt).append(e.$createParagraphNode()));
        } else
          Le.setRowSpan(Le.__rowSpan + 1);
      }
      const be = ve.getChildAtIndex(Pe);
      if (!m(be))
        throw Error("focusEndRow is not a TableRowNode");
      be.insertBefore(qe);
    }
  }
  function y(le, Z, re = !0, ce, ve) {
    const he = le.getChildren(), Te = [];
    for (let De = 0; De < he.length; De++) {
      const Pe = he[De];
      if (m(Pe))
        for (let Ae = 0; Ae < ce; Ae++) {
          const qe = Pe.getChildren();
          if (Z >= qe.length || Z < 0)
            throw new Error("Table column target index out of range");
          const be = qe[Z];
          if (!a(be))
            throw Error("Expected table cell");
          const {
            left: Ce,
            right: Le
          } = x(be, ve);
          let je = n.NO_STATUS;
          (Ce && Ce.hasHeaderState(n.ROW) || Le && Le.hasHeaderState(n.ROW)) && (je |= n.ROW);
          const Ke = s(je);
          Ke.append(e.$createParagraphNode()), Te.push({
            newTableCell: Ke,
            targetCell: be
          });
        }
    }
    return Te.forEach(({
      newTableCell: De,
      targetCell: Pe
    }) => {
      re ? Pe.insertAfter(De) : Pe.insertBefore(De);
    }), le;
  }
  function E(le = !0) {
    const Z = e.$getSelection();
    if (!(e.$isRangeSelection(Z) || I(Z)))
      throw Error("Expected a RangeSelection or GridSelection");
    const re = Z.anchor.getNode(), ce = Z.focus.getNode(), [ve] = $(re), [he, , Te] = $(ce), [De, Pe, Ae] = T(Te, he, ve), qe = De.length, be = le ? Math.max(Pe.startColumn, Ae.startColumn) : Math.min(Pe.startColumn, Ae.startColumn), Ce = le ? be + he.__colSpan - 1 : be - 1, Le = Te.getFirstChild();
    if (!m(Le))
      throw Error("Expected firstTable child to be a row");
    let je = null;
    function Ke(tt = n.NO_STATUS) {
      const Ze = s(tt).append(e.$createParagraphNode());
      return je === null && (je = Ze), Ze;
    }
    let Ue = Le;
    e: for (let tt = 0; tt < qe; tt++) {
      if (tt !== 0) {
        const xt = Ue.getNextSibling();
        if (!m(xt))
          throw Error("Expected row nextSibling to be a row");
        Ue = xt;
      }
      const Ze = De[tt], st = Ze[Ce < 0 ? 0 : Ce].cell.__headerState, Tt = w(st, n.ROW);
      if (Ce < 0) {
        H(Ue, Ke(Tt));
        continue;
      }
      const {
        cell: pt,
        startColumn: er,
        startRow: vt
      } = Ze[Ce];
      if (er + pt.__colSpan - 1 <= Ce) {
        let xt = pt, wt = vt, ae = Ce;
        for (; wt !== tt && xt.__rowSpan > 1; )
          if (ae -= pt.__colSpan, ae >= 0) {
            const {
              cell: Oe,
              startRow: Fe
            } = Ze[ae];
            xt = Oe, wt = Fe;
          } else {
            Ue.append(Ke(Tt));
            continue e;
          }
        xt.insertAfter(Ke(Tt));
      } else
        pt.setColSpan(pt.__colSpan + 1);
    }
    je !== null && j(je);
  }
  function S(le, Z) {
    const re = le.getChildren();
    for (let ce = 0; ce < re.length; ce++) {
      const ve = re[ce];
      if (m(ve)) {
        const he = ve.getChildren();
        if (Z >= he.length || Z < 0)
          throw new Error("Table column target index out of range");
        he[Z].remove();
      }
    }
    return le;
  }
  function P() {
    const le = e.$getSelection();
    if (!(e.$isRangeSelection(le) || I(le)))
      throw Error("Expected a RangeSelection or GridSelection");
    const Z = le.anchor.getNode(), re = le.focus.getNode(), [ce, , ve] = $(Z), [he] = $(re), [Te, De, Pe] = T(ve, ce, he), {
      startRow: Ae
    } = De, {
      startRow: qe
    } = Pe, be = qe + he.__rowSpan - 1;
    if (Te.length === be - Ae + 1) {
      ve.remove();
      return;
    }
    const Ce = Te[0].length, Le = Te[be + 1], je = ve.getChildAtIndex(be + 1);
    for (let Ke = be; Ke >= Ae; Ke--) {
      for (let tt = Ce - 1; tt >= 0; tt--) {
        const {
          cell: Ze,
          startRow: st,
          startColumn: Tt
        } = Te[Ke][tt];
        if (Tt === tt && (Ke === Ae && st < Ae && Ze.setRowSpan(Ze.__rowSpan - (st - Ae)), st >= Ae && st + Ze.__rowSpan - 1 > be)) {
          if (Ze.setRowSpan(Ze.__rowSpan - (be - st + 1)), je === null)
            throw Error("Expected nextRowNode not to be null");
          if (tt === 0)
            H(je, Ze);
          else {
            const {
              cell: pt
            } = Le[tt - 1];
            pt.insertAfter(Ze);
          }
        }
      }
      const Ue = ve.getChildAtIndex(Ke);
      if (!m(Ue))
        throw Error(`Expected GridNode childAtIndex(${String(Ke)}) to be RowNode`);
      Ue.remove();
    }
    if (Le !== void 0) {
      const {
        cell: Ke
      } = Le[0];
      j(Ke);
    } else {
      const Ke = Te[Ae - 1], {
        cell: Ue
      } = Ke[0];
      j(Ue);
    }
  }
  function U() {
    const le = e.$getSelection();
    if (!(e.$isRangeSelection(le) || I(le)))
      throw Error("Expected a RangeSelection or GridSelection");
    const Z = le.anchor.getNode(), re = le.focus.getNode(), [ce, , ve] = $(Z), [he] = $(re), [Te, De, Pe] = T(ve, ce, he), {
      startColumn: Ae
    } = De, {
      startRow: qe,
      startColumn: be
    } = Pe, Ce = Math.min(Ae, be), Le = Math.max(Ae + ce.__colSpan - 1, be + he.__colSpan - 1), je = Le - Ce + 1;
    if (Te[0].length === Le - Ce + 1) {
      ve.selectPrevious(), ve.remove();
      return;
    }
    const Ue = Te.length;
    for (let st = 0; st < Ue; st++)
      for (let Tt = Ce; Tt <= Le; Tt++) {
        const {
          cell: pt,
          startColumn: er
        } = Te[st][Tt];
        if (er < Ce) {
          if (Tt === Ce) {
            const vt = Ce - er;
            pt.setColSpan(pt.__colSpan - // Possible overflow right too
            Math.min(je, pt.__colSpan - vt));
          }
        } else if (er + pt.__colSpan - 1 > Le) {
          if (Tt === Le) {
            const vt = Le - er + 1;
            pt.setColSpan(pt.__colSpan - vt);
          }
        } else
          pt.remove();
      }
    const tt = Te[qe], Ze = tt[be + he.__colSpan];
    if (Ze !== void 0) {
      const {
        cell: st
      } = Ze;
      j(st);
    } else {
      const st = tt[be - 1], {
        cell: Tt
      } = st;
      j(Tt);
    }
  }
  function j(le) {
    const Z = le.getFirstDescendant();
    Z == null ? le.selectStart() : Z.getParentOrThrow().selectStart();
  }
  function H(le, Z) {
    const re = le.getFirstChild();
    re !== null ? re.insertBefore(Z) : le.append(Z);
  }
  function R() {
    const le = e.$getSelection();
    if (!(e.$isRangeSelection(le) || I(le)))
      throw Error("Expected a RangeSelection or GridSelection");
    const Z = le.anchor.getNode(), [re, ce, ve] = $(Z), he = re.__colSpan, Te = re.__rowSpan;
    if (he > 1) {
      for (let De = 1; De < he; De++)
        re.insertAfter(s(n.NO_STATUS));
      re.setColSpan(1);
    }
    if (Te > 1) {
      const [De, Pe] = T(ve, re, re), {
        startColumn: Ae,
        startRow: qe
      } = Pe;
      let be;
      for (let Ce = 1; Ce < Te; Ce++) {
        const Le = qe + Ce, je = De[Le];
        if (be = (be || ce).getNextSibling(), !m(be))
          throw Error("Expected row next sibling to be a row");
        let Ke = null;
        for (let Ue = 0; Ue < Ae; Ue++) {
          const tt = je[Ue], Ze = tt.cell;
          tt.startRow === Le && (Ke = Ze), Ze.__colSpan > 1 && (Ue += Ze.__colSpan - 1);
        }
        if (Ke === null)
          for (let Ue = 0; Ue < he; Ue++)
            H(be, s(n.NO_STATUS));
        else
          for (let Ue = 0; Ue < he; Ue++)
            Ke.insertAfter(s(n.NO_STATUS));
      }
      re.setRowSpan(1);
    }
  }
  function T(le, Z, re) {
    const ce = [];
    let ve = null, he = null;
    function Te(Ae, qe, be) {
      const Ce = {
        cell: be,
        startColumn: qe,
        startRow: Ae
      }, Le = be.__rowSpan, je = be.__colSpan;
      for (let Ke = 0; Ke < Le; Ke++) {
        ce[Ae + Ke] === void 0 && (ce[Ae + Ke] = []);
        for (let Ue = 0; Ue < je; Ue++)
          ce[Ae + Ke][qe + Ue] = Ce;
      }
      Z.is(be) && (ve = Ce), re.is(be) && (he = Ce);
    }
    function De(Ae, qe) {
      return ce[Ae] === void 0 || ce[Ae][qe] === void 0;
    }
    const Pe = le.getChildren();
    for (let Ae = 0; Ae < Pe.length; Ae++) {
      const qe = Pe[Ae];
      if (!m(qe))
        throw Error("Expected GridNode children to be TableRowNode");
      const be = qe.getChildren();
      let Ce = 0;
      for (const Le of be) {
        if (!a(Le))
          throw Error("Expected TableRowNode children to be TableCellNode");
        for (; !De(Ae, Ce); )
          Ce++;
        Te(Ae, Ce, Le), Ce += Le.__colSpan;
      }
    }
    if (ve === null)
      throw Error("Anchor not found in Grid");
    if (he === null)
      throw Error("Focus not found in Grid");
    return [ce, ve, he];
  }
  function $(le) {
    let Z;
    if (le instanceof i)
      Z = le;
    else if ("__type" in le) {
      const ve = r.$findMatchingParent(le, a);
      if (!a(ve))
        throw Error("Expected to find a parent TableCellNode");
      Z = ve;
    } else {
      const ve = r.$findMatchingParent(le.getNode(), a);
      if (!a(ve))
        throw Error("Expected to find a parent TableCellNode");
      Z = ve;
    }
    const re = Z.getParent();
    if (!m(re))
      throw Error("Expected TableCellNode to have a parent TableRowNode");
    const ce = re.getParent();
    if (!Je(ce))
      throw Error("Expected TableRowNode to have a parent GridNode");
    return [Z, re, ce];
  }
  function G(le) {
    const [Z, , re] = $(le), ce = re.getChildren(), ve = ce.length, he = ce[0].getChildren().length, Te = new Array(ve);
    for (let De = 0; De < ve; De++)
      Te[De] = new Array(he);
    for (let De = 0; De < ve; De++) {
      const Ae = ce[De].getChildren();
      let qe = 0;
      for (let be = 0; be < Ae.length; be++) {
        for (; Te[De][qe]; )
          qe++;
        const Ce = Ae[be], Le = Ce.__rowSpan || 1, je = Ce.__colSpan || 1;
        for (let Ke = 0; Ke < Le; Ke++)
          for (let Ue = 0; Ue < je; Ue++)
            Te[De + Ke][qe + Ue] = Ce;
        if (Z === Ce)
          return {
            colSpan: je,
            columnIndex: qe,
            rowIndex: De,
            rowSpan: Le
          };
        qe += je;
      }
    }
    return null;
  }
  class q {
    constructor(Z, re, ce) {
      this.anchor = re, this.focus = ce, re._selection = this, ce._selection = this, this._cachedNodes = null, this.dirty = !1, this.tableKey = Z;
    }
    getStartEndPoints() {
      return [this.anchor, this.focus];
    }
    /**
     * Returns whether the Selection is "backwards", meaning the focus
     * logically precedes the anchor in the EditorState.
     * @returns true if the Selection is backwards, false otherwise.
     */
    isBackward() {
      return this.focus.isBefore(this.anchor);
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(Z) {
      this._cachedNodes = Z;
    }
    is(Z) {
      return I(Z) ? this.tableKey === Z.tableKey && this.anchor.is(Z.anchor) && this.focus.is(Z.focus) : !1;
    }
    set(Z, re, ce) {
      this.dirty = !0, this.tableKey = Z, this.anchor.key = re, this.focus.key = ce, this._cachedNodes = null;
    }
    clone() {
      return new q(this.tableKey, this.anchor, this.focus);
    }
    isCollapsed() {
      return !1;
    }
    extract() {
      return this.getNodes();
    }
    insertRawText(Z) {
    }
    insertText() {
    }
    insertNodes(Z) {
      const re = this.focus.getNode();
      if (!e.$isElementNode(re))
        throw Error("Expected TableSelection focus to be an ElementNode");
      e.$normalizeSelection__EXPERIMENTAL(re.select(0, re.getChildrenSize())).insertNodes(Z);
    }
    // TODO Deprecate this method. It's confusing when used with colspan|rowspan
    getShape() {
      const Z = e.$getNodeByKey(this.anchor.key);
      if (!a(Z))
        throw Error("Expected TableSelection anchor to be (or a child of) TableCellNode");
      const re = G(Z);
      if (re === null)
        throw Error("getCellRect: expected to find AnchorNode");
      const ce = e.$getNodeByKey(this.focus.key);
      if (!a(ce))
        throw Error("Expected TableSelection focus to be (or a child of) TableCellNode");
      const ve = G(ce);
      if (ve === null)
        throw Error("getCellRect: expected to find focusCellNode");
      const he = Math.min(re.columnIndex, ve.columnIndex), Te = Math.max(re.columnIndex, ve.columnIndex), De = Math.min(re.rowIndex, ve.rowIndex), Pe = Math.max(re.rowIndex, ve.rowIndex);
      return {
        fromX: Math.min(he, Te),
        fromY: Math.min(De, Pe),
        toX: Math.max(he, Te),
        toY: Math.max(De, Pe)
      };
    }
    getNodes() {
      const Z = this._cachedNodes;
      if (Z !== null)
        return Z;
      const re = this.anchor.getNode(), ce = this.focus.getNode(), ve = r.$findMatchingParent(re, a), he = r.$findMatchingParent(ce, a);
      if (!a(ve))
        throw Error("Expected TableSelection anchor to be (or a child of) TableCellNode");
      if (!a(he))
        throw Error("Expected TableSelection focus to be (or a child of) TableCellNode");
      const Te = ve.getParent();
      if (!m(Te))
        throw Error("Expected anchorCell to have a parent TableRowNode");
      const De = Te.getParent();
      if (!Je(De))
        throw Error("Expected tableNode to have a parent TableNode");
      const Pe = he.getParents()[1];
      if (Pe !== De) {
        if (De.isParentOf(he)) {
          const vt = Pe.getParent();
          if (vt == null)
            throw Error("Expected focusCellParent to have a parent");
          this.set(this.tableKey, he.getKey(), vt.getKey());
        } else {
          const vt = De.getParent();
          if (vt == null)
            throw Error("Expected gridParent to have a parent");
          this.set(this.tableKey, vt.getKey(), he.getKey());
        }
        return this.getNodes();
      }
      const [Ae, qe, be] = T(De, ve, he);
      let Ce = Math.min(qe.startColumn, be.startColumn), Le = Math.min(qe.startRow, be.startRow), je = Math.max(qe.startColumn + qe.cell.__colSpan - 1, be.startColumn + be.cell.__colSpan - 1), Ke = Math.max(qe.startRow + qe.cell.__rowSpan - 1, be.startRow + be.cell.__rowSpan - 1), Ue = Ce, tt = Le, Ze = Ce, st = Le;
      function Tt(vt) {
        const {
          cell: xt,
          startColumn: wt,
          startRow: ae
        } = vt;
        Ce = Math.min(Ce, wt), Le = Math.min(Le, ae), je = Math.max(je, wt + xt.__colSpan - 1), Ke = Math.max(Ke, ae + xt.__rowSpan - 1);
      }
      for (; Ce < Ue || Le < tt || je > Ze || Ke > st; ) {
        if (Ce < Ue) {
          const vt = st - tt, xt = Ue - 1;
          for (let wt = 0; wt <= vt; wt++)
            Tt(Ae[tt + wt][xt]);
          Ue = xt;
        }
        if (Le < tt) {
          const vt = Ze - Ue, xt = tt - 1;
          for (let wt = 0; wt <= vt; wt++)
            Tt(Ae[xt][Ue + wt]);
          tt = xt;
        }
        if (je > Ze) {
          const vt = st - tt, xt = Ze + 1;
          for (let wt = 0; wt <= vt; wt++)
            Tt(Ae[tt + wt][xt]);
          Ze = xt;
        }
        if (Ke > st) {
          const vt = Ze - Ue, xt = st + 1;
          for (let wt = 0; wt <= vt; wt++)
            Tt(Ae[xt][Ue + wt]);
          st = xt;
        }
      }
      const pt = [De];
      let er = null;
      for (let vt = Le; vt <= Ke; vt++)
        for (let xt = Ce; xt <= je; xt++) {
          const {
            cell: wt
          } = Ae[vt][xt], ae = wt.getParent();
          if (!m(ae))
            throw Error("Expected TableCellNode parent to be a TableRowNode");
          ae !== er && pt.push(ae), pt.push(wt, ...D(wt)), er = ae;
        }
      return e.isCurrentlyReadOnlyMode() || (this._cachedNodes = pt), pt;
    }
    getTextContent() {
      const Z = this.getNodes();
      let re = "";
      for (let ce = 0; ce < Z.length; ce++)
        re += Z[ce].getTextContent();
      return re;
    }
  }
  function I(le) {
    return le instanceof q;
  }
  function Y() {
    const le = e.$createPoint("root", 0, "element"), Z = e.$createPoint("root", 0, "element");
    return new q("root", le, Z);
  }
  function D(le) {
    const Z = [], re = [le];
    for (; re.length > 0; ) {
      const ce = re.pop();
      if (ce === void 0)
        throw Error("Stack.length > 0; can't be undefined");
      e.$isElementNode(ce) && re.unshift(...ce.getChildren()), ce !== le && Z.push(ce);
    }
    return Z;
  }
  const z = (le) => c ? (le || window).getSelection() : null;
  class X {
    constructor(Z, re) {
      this.isHighlightingCells = !1, this.anchorX = -1, this.anchorY = -1, this.focusX = -1, this.focusY = -1, this.listenersToRemove = /* @__PURE__ */ new Set(), this.tableNodeKey = re, this.editor = Z, this.table = {
        columns: 0,
        domRows: [],
        rows: 0
      }, this.tableSelection = null, this.anchorCellNodeKey = null, this.focusCellNodeKey = null, this.anchorCell = null, this.focusCell = null, this.hasHijackedSelectionStyles = !1, this.trackTable();
    }
    getTable() {
      return this.table;
    }
    removeListeners() {
      Array.from(this.listenersToRemove).forEach((Z) => Z());
    }
    trackTable() {
      const Z = new MutationObserver((re) => {
        this.editor.update(() => {
          let ce = !1;
          for (let he = 0; he < re.length; he++) {
            const Pe = re[he].target.nodeName;
            if (Pe === "TABLE" || Pe === "TR") {
              ce = !0;
              break;
            }
          }
          if (!ce)
            return;
          const ve = this.editor.getElementByKey(this.tableNodeKey);
          if (!ve)
            throw new Error("Expected to find TableElement in DOM");
          this.table = Ne(ve);
        });
      });
      this.editor.update(() => {
        const re = this.editor.getElementByKey(this.tableNodeKey);
        if (!re)
          throw new Error("Expected to find TableElement in DOM");
        this.table = Ne(re), Z.observe(re, {
          childList: !0,
          subtree: !0
        });
      });
    }
    clearHighlight() {
      const Z = this.editor;
      this.isHighlightingCells = !1, this.anchorX = -1, this.anchorY = -1, this.focusX = -1, this.focusY = -1, this.tableSelection = null, this.anchorCellNodeKey = null, this.focusCellNodeKey = null, this.anchorCell = null, this.focusCell = null, this.hasHijackedSelectionStyles = !1, this.enableHighlightStyle(), Z.update(() => {
        const re = e.$getNodeByKey(this.tableNodeKey);
        if (!Je(re))
          throw new Error("Expected TableNode.");
        const ce = Z.getElementByKey(this.tableNodeKey);
        if (!ce)
          throw new Error("Expected to find TableElement in DOM");
        const ve = Ne(ce);
        B(Z, ve, null), e.$setSelection(null), Z.dispatchCommand(e.SELECTION_CHANGE_COMMAND, void 0);
      });
    }
    enableHighlightStyle() {
      const Z = this.editor;
      Z.update(() => {
        const re = Z.getElementByKey(this.tableNodeKey);
        if (!re)
          throw new Error("Expected to find TableElement in DOM");
        r.removeClassNamesFromElement(re, Z._config.theme.tableSelection), re.classList.remove("disable-selection"), this.hasHijackedSelectionStyles = !1;
      });
    }
    disableHighlightStyle() {
      const Z = this.editor;
      Z.update(() => {
        const re = Z.getElementByKey(this.tableNodeKey);
        if (!re)
          throw new Error("Expected to find TableElement in DOM");
        r.addClassNamesToElement(re, Z._config.theme.tableSelection), this.hasHijackedSelectionStyles = !0;
      });
    }
    updateTableTableSelection(Z) {
      if (Z !== null && Z.tableKey === this.tableNodeKey) {
        const re = this.editor;
        this.tableSelection = Z, this.isHighlightingCells = !0, this.disableHighlightStyle(), B(re, this.table, this.tableSelection);
      } else Z == null ? this.clearHighlight() : (this.tableNodeKey = Z.tableKey, this.updateTableTableSelection(Z));
    }
    setFocusCellForSelection(Z, re = !1) {
      const ce = this.editor;
      ce.update(() => {
        const ve = e.$getNodeByKey(this.tableNodeKey);
        if (!Je(ve))
          throw new Error("Expected TableNode.");
        if (!ce.getElementByKey(this.tableNodeKey))
          throw new Error("Expected to find TableElement in DOM");
        const Te = Z.x, De = Z.y;
        if (this.focusCell = Z, this.anchorCell !== null) {
          const Pe = z(ce._window);
          Pe && Pe.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);
        }
        if (!this.isHighlightingCells && (this.anchorX !== Te || this.anchorY !== De || re))
          this.isHighlightingCells = !0, this.disableHighlightStyle();
        else if (Te === this.focusX && De === this.focusY)
          return;
        if (this.focusX = Te, this.focusY = De, this.isHighlightingCells) {
          const Pe = e.$getNearestNodeFromDOMNode(Z.elem);
          if (this.tableSelection != null && this.anchorCellNodeKey != null && a(Pe)) {
            const Ae = Pe.getKey();
            this.tableSelection = this.tableSelection.clone() || Y(), this.focusCellNodeKey = Ae, this.tableSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey), e.$setSelection(this.tableSelection), ce.dispatchCommand(e.SELECTION_CHANGE_COMMAND, void 0), B(ce, this.table, this.tableSelection);
          }
        }
      });
    }
    setAnchorCellForSelection(Z) {
      this.isHighlightingCells = !1, this.anchorCell = Z, this.anchorX = Z.x, this.anchorY = Z.y, this.editor.update(() => {
        const re = e.$getNearestNodeFromDOMNode(Z.elem);
        if (a(re)) {
          const ce = re.getKey();
          this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : Y(), this.anchorCellNodeKey = ce;
        }
      });
    }
    formatCells(Z) {
      this.editor.update(() => {
        const re = e.$getSelection();
        if (!I(re))
          throw Error("Expected grid selection");
        const ce = e.$createRangeSelection(), ve = ce.anchor, he = ce.focus;
        re.getNodes().forEach((Te) => {
          a(Te) && Te.getTextContentSize() !== 0 && (ve.set(Te.getKey(), 0, "element"), he.set(Te.getKey(), Te.getChildrenSize(), "element"), ce.formatText(Z));
        }), e.$setSelection(re), this.editor.dispatchCommand(e.SELECTION_CHANGE_COMMAND, void 0);
      });
    }
    clearText() {
      const Z = this.editor;
      Z.update(() => {
        const re = e.$getNodeByKey(this.tableNodeKey);
        if (!Je(re))
          throw new Error("Expected TableNode.");
        const ce = e.$getSelection();
        if (!I(ce))
          throw Error("Expected grid selection");
        const ve = ce.getNodes().filter(a);
        if (ve.length === this.table.columns * this.table.rows) {
          re.selectPrevious(), re.remove(), e.$getRoot().selectStart();
          return;
        }
        ve.forEach((he) => {
          if (e.$isElementNode(he)) {
            const Te = e.$createParagraphNode(), De = e.$createTextNode();
            Te.append(De), he.append(Te), he.getChildren().forEach((Pe) => {
              Pe !== Te && Pe.remove();
            });
          }
        }), B(Z, this.table, null), e.$setSelection(null), Z.dispatchCommand(e.SELECTION_CHANGE_COMMAND, void 0);
      });
    }
  }
  const Q = "__lexicalTableSelection";
  function ne(le, Z, re, ce) {
    const ve = re.getRootElement();
    if (ve === null)
      throw new Error("No root element.");
    const he = new X(re, le.getKey()), Te = re._window || window;
    fe(Z, he), Z.addEventListener("mousedown", (be) => {
      setTimeout(() => {
        if (be.button !== 0 || !Te)
          return;
        const Ce = pe(be.target);
        Ce !== null && (Be(be), he.setAnchorCellForSelection(Ce));
        const Le = () => {
          Te.removeEventListener("mouseup", Le), Te.removeEventListener("mousemove", je);
        }, je = (Ke) => {
          const Ue = pe(Ke.target);
          Ue !== null && (he.anchorX !== Ue.x || he.anchorY !== Ue.y) && (Ke.preventDefault(), he.setFocusCellForSelection(Ue));
        };
        Te.addEventListener("mouseup", Le), Te.addEventListener("mousemove", je);
      }, 0);
    });
    const De = (be) => {
      be.button === 0 && re.update(() => {
        const Ce = e.$getSelection(), Le = be.target;
        I(Ce) && Ce.tableKey === he.tableNodeKey && ve.contains(Le) && he.clearHighlight();
      });
    };
    Te.addEventListener("mousedown", De), he.listenersToRemove.add(() => Te.removeEventListener("mousedown", De)), he.listenersToRemove.add(re.registerCommand(e.KEY_ARROW_DOWN_COMMAND, (be) => Ee(re, be, "down", le, he), e.COMMAND_PRIORITY_HIGH)), he.listenersToRemove.add(re.registerCommand(e.KEY_ARROW_UP_COMMAND, (be) => Ee(re, be, "up", le, he), e.COMMAND_PRIORITY_HIGH)), he.listenersToRemove.add(re.registerCommand(e.KEY_ARROW_LEFT_COMMAND, (be) => Ee(re, be, "backward", le, he), e.COMMAND_PRIORITY_HIGH)), he.listenersToRemove.add(re.registerCommand(e.KEY_ARROW_RIGHT_COMMAND, (be) => Ee(re, be, "forward", le, he), e.COMMAND_PRIORITY_HIGH)), he.listenersToRemove.add(re.registerCommand(e.KEY_ESCAPE_COMMAND, (be) => {
      const Ce = e.$getSelection();
      if (I(Ce)) {
        const Le = r.$findMatchingParent(Ce.focus.getNode(), a);
        if (a(Le))
          return Be(be), Le.selectEnd(), !0;
      }
      return !1;
    }, e.COMMAND_PRIORITY_HIGH));
    const Pe = (be) => () => {
      const Ce = e.$getSelection();
      if (!ee(Ce, le))
        return !1;
      if (I(Ce))
        return he.clearText(), !0;
      if (e.$isRangeSelection(Ce)) {
        const Le = r.$findMatchingParent(Ce.anchor.getNode(), (pt) => a(pt));
        if (!a(Le))
          return !1;
        const je = Ce.anchor.getNode(), Ke = Ce.focus.getNode(), Ue = le.isParentOf(je), tt = le.isParentOf(Ke);
        if (Ue && !tt || tt && !Ue)
          return he.clearText(), !0;
        const st = r.$findMatchingParent(Ce.anchor.getNode(), (pt) => e.$isElementNode(pt)), Tt = st && r.$findMatchingParent(st, (pt) => e.$isElementNode(pt) && a(pt.getParent()));
        if (!e.$isElementNode(Tt) || !e.$isElementNode(st))
          return !1;
        if (be === e.DELETE_LINE_COMMAND && Tt.getPreviousSibling() === null)
          return !0;
        if ((be === e.DELETE_CHARACTER_COMMAND || be === e.DELETE_WORD_COMMAND) && Ce.isCollapsed() && Ce.anchor.offset === 0 && st !== Tt) {
          const pt = st.getChildren(), er = e.$createParagraphNode();
          return pt.forEach((vt) => er.append(vt)), st.replace(er), st.getWritable().__parent = Le.getKey(), !0;
        }
      }
      return !1;
    };
    [e.DELETE_WORD_COMMAND, e.DELETE_LINE_COMMAND, e.DELETE_CHARACTER_COMMAND].forEach((be) => {
      he.listenersToRemove.add(re.registerCommand(be, Pe(be), e.COMMAND_PRIORITY_CRITICAL));
    });
    const Ae = (be) => {
      const Ce = e.$getSelection();
      if (!ee(Ce, le))
        return !1;
      if (I(Ce))
        return be.preventDefault(), be.stopPropagation(), he.clearText(), !0;
      if (e.$isRangeSelection(Ce)) {
        const Le = r.$findMatchingParent(Ce.anchor.getNode(), (je) => a(je));
        if (!a(Le))
          return !1;
      }
      return !1;
    };
    he.listenersToRemove.add(re.registerCommand(e.KEY_BACKSPACE_COMMAND, Ae, e.COMMAND_PRIORITY_CRITICAL)), he.listenersToRemove.add(re.registerCommand(e.KEY_DELETE_COMMAND, Ae, e.COMMAND_PRIORITY_CRITICAL)), he.listenersToRemove.add(re.registerCommand(e.FORMAT_TEXT_COMMAND, (be) => {
      const Ce = e.$getSelection();
      if (!ee(Ce, le))
        return !1;
      if (I(Ce))
        return he.formatCells(be), !0;
      if (e.$isRangeSelection(Ce)) {
        const Le = r.$findMatchingParent(Ce.anchor.getNode(), (je) => a(je));
        if (!a(Le))
          return !1;
      }
      return !1;
    }, e.COMMAND_PRIORITY_CRITICAL)), he.listenersToRemove.add(re.registerCommand(e.CONTROLLED_TEXT_INSERTION_COMMAND, (be) => {
      const Ce = e.$getSelection();
      if (!ee(Ce, le))
        return !1;
      if (I(Ce))
        return he.clearHighlight(), !1;
      if (e.$isRangeSelection(Ce)) {
        const Le = r.$findMatchingParent(Ce.anchor.getNode(), (je) => a(je));
        if (!a(Le))
          return !1;
      }
      return !1;
    }, e.COMMAND_PRIORITY_CRITICAL)), ce && he.listenersToRemove.add(re.registerCommand(e.KEY_TAB_COMMAND, (be) => {
      const Ce = e.$getSelection();
      if (!e.$isRangeSelection(Ce) || !Ce.isCollapsed() || !ee(Ce, le))
        return !1;
      const Le = me(Ce.anchor.getNode());
      if (Le === null)
        return !1;
      Be(be);
      const je = le.getCordsFromCellNode(Le, he.table);
      return V(he, le, je.x, je.y, be.shiftKey ? "backward" : "forward"), !0;
    }, e.COMMAND_PRIORITY_CRITICAL)), he.listenersToRemove.add(re.registerCommand(e.FOCUS_COMMAND, (be) => le.isSelected(), e.COMMAND_PRIORITY_HIGH));
    function qe(be) {
      const Ce = le.getCordsFromCellNode(be, he.table);
      return le.getDOMCellFromCordsOrThrow(Ce.x, Ce.y, he.table);
    }
    return he.listenersToRemove.add(re.registerCommand(e.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, (be) => {
      const {
        nodes: Ce,
        selection: Le
      } = be, je = Le.getStartEndPoints(), Ke = I(Le), tt = e.$isRangeSelection(Le) && r.$findMatchingParent(Le.anchor.getNode(), (kt) => a(kt)) !== null && r.$findMatchingParent(Le.focus.getNode(), (kt) => a(kt)) !== null || Ke;
      if (Ce.length !== 1 || !Je(Ce[0]) || !tt || je === null)
        return !1;
      const [Ze] = je, st = Ce[0], Tt = st.getChildren(), pt = st.getFirstChildOrThrow().getChildrenSize(), er = st.getChildrenSize(), vt = r.$findMatchingParent(Ze.getNode(), (kt) => a(kt)), xt = vt && r.$findMatchingParent(vt, (kt) => m(kt)), wt = xt && r.$findMatchingParent(xt, (kt) => Je(kt));
      if (!a(vt) || !m(xt) || !Je(wt))
        return !1;
      const ae = xt.getIndexWithinParent(), Oe = Math.min(wt.getChildrenSize() - 1, ae + er - 1), Fe = vt.getIndexWithinParent(), rt = Math.min(xt.getChildrenSize() - 1, Fe + pt - 1), bt = Math.min(Fe, rt), Et = Math.min(ae, Oe), gt = Math.max(Fe, rt), ht = Math.max(ae, Oe), tr = wt.getChildren();
      let Dt = 0, $t, ir;
      for (let kt = Et; kt <= ht; kt++) {
        const Mr = tr[kt];
        if (!m(Mr))
          return !1;
        const rr = Tt[Dt];
        if (!m(rr))
          return !1;
        const ai = Mr.getChildren(), $o = rr.getChildren();
        let Hi = 0;
        for (let si = bt; si <= gt; si++) {
          const kn = ai[si];
          if (!a(kn))
            return !1;
          const nl = $o[Hi];
          if (!a(nl))
            return !1;
          kt === Et && si === bt ? $t = kn.getKey() : kt === ht && si === gt && (ir = kn.getKey());
          const Eh = kn.getChildren();
          nl.getChildren().forEach((Dn) => {
            e.$isTextNode(Dn) && e.$createParagraphNode().append(Dn), kn.append(Dn);
          }), Eh.forEach((Dn) => Dn.remove()), Hi++;
        }
        Dt++;
      }
      if ($t && ir) {
        const kt = Y();
        kt.set(Ce[0].getKey(), $t, ir), e.$setSelection(kt);
      }
      return !0;
    }, e.COMMAND_PRIORITY_CRITICAL)), he.listenersToRemove.add(re.registerCommand(e.SELECTION_CHANGE_COMMAND, () => {
      const be = e.$getSelection(), Ce = e.$getPreviousSelection();
      if (e.$isRangeSelection(be)) {
        const {
          anchor: Le,
          focus: je
        } = be, Ke = Le.getNode(), Ue = je.getNode(), tt = me(Ke), Ze = me(Ue), st = tt && le.is(we(tt)), Tt = Ze && le.is(we(Ze)), pt = st !== Tt, er = st && Tt, vt = be.isBackward();
        if (pt) {
          const xt = be.clone();
          xt.focus.set(le.getKey(), vt ? 0 : le.getChildrenSize(), "element"), e.$setSelection(xt), k(re, he);
        } else er && (tt.is(Ze) || (he.setAnchorCellForSelection(qe(tt)), he.setFocusCellForSelection(qe(Ze), !0)));
      }
      return be && !be.is(Ce) && (I(be) || I(Ce)) && he.tableSelection && !he.tableSelection.is(Ce) ? (I(be) && be.tableKey === he.tableNodeKey ? he.updateTableTableSelection(be) : !I(be) && I(Ce) && Ce.tableKey === he.tableNodeKey && he.updateTableTableSelection(null), !1) : (he.hasHijackedSelectionStyles && !le.isSelected() ? W(re, he) : !he.hasHijackedSelectionStyles && le.isSelected() && k(re, he), !1);
    }, e.COMMAND_PRIORITY_CRITICAL)), he;
  }
  function fe(le, Z) {
    le[Q] = Z;
  }
  function _e(le) {
    return le[Q];
  }
  function pe(le) {
    let Z = le;
    for (; Z != null; ) {
      const re = Z.nodeName;
      if (re === "TD" || re === "TH") {
        const ce = Z._cell;
        return ce === void 0 ? null : ce;
      }
      Z = Z.parentNode;
    }
    return null;
  }
  function Ne(le) {
    const Z = [], re = {
      columns: 0,
      domRows: Z,
      rows: 0
    };
    let ce = le.firstChild, ve = 0, he = 0;
    for (Z.length = 0; ce != null; ) {
      const Te = ce.nodeName;
      if (Te === "TD" || Te === "TH") {
        const Ae = ce, qe = {
          elem: Ae,
          hasBackgroundColor: Ae.style.backgroundColor !== "",
          highlighted: !1,
          x: ve,
          y: he
        };
        ce._cell = qe;
        let be = Z[he];
        be === void 0 && (be = Z[he] = []), be[ve] = qe;
      } else {
        const Ae = ce.firstChild;
        if (Ae != null) {
          ce = Ae;
          continue;
        }
      }
      const De = ce.nextSibling;
      if (De != null) {
        ve++, ce = De;
        continue;
      }
      const Pe = ce.parentNode;
      if (Pe != null) {
        const Ae = Pe.nextSibling;
        if (Ae == null)
          break;
        he++, ve = 0, ce = Ae;
      }
    }
    return re.columns = ve + 1, re.rows = he + 1, re;
  }
  function B(le, Z, re) {
    const ce = new Set(re ? re.getNodes() : []);
    F(Z, (ve, he) => {
      const Te = ve.elem;
      ce.has(he) ? (ve.highlighted = !0, ye(le, ve)) : (ve.highlighted = !1, de(le, ve), Te.getAttribute("style") || Te.removeAttribute("style"));
    });
  }
  function F(le, Z) {
    const {
      domRows: re
    } = le;
    for (let ce = 0; ce < re.length; ce++) {
      const ve = re[ce];
      if (ve)
        for (let he = 0; he < ve.length; he++) {
          const Te = ve[he];
          if (!Te)
            continue;
          const De = e.$getNearestNodeFromDOMNode(Te.elem);
          De !== null && Z(Te, De, {
            x: he,
            y: ce
          });
        }
    }
  }
  function k(le, Z) {
    Z.disableHighlightStyle(), F(Z.table, (re) => {
      re.highlighted = !0, ye(le, re);
    });
  }
  function W(le, Z) {
    Z.enableHighlightStyle(), F(Z.table, (re) => {
      const ce = re.elem;
      re.highlighted = !1, de(le, re), ce.getAttribute("style") || ce.removeAttribute("style");
    });
  }
  const V = (le, Z, re, ce, ve) => {
    const he = ve === "forward";
    switch (ve) {
      case "backward":
      case "forward":
        return re !== (he ? le.table.columns - 1 : 0) ? ue(Z.getCellNodeFromCordsOrThrow(re + (he ? 1 : -1), ce, le.table), he) : ce !== (he ? le.table.rows - 1 : 0) ? ue(Z.getCellNodeFromCordsOrThrow(he ? 0 : le.table.columns - 1, ce + (he ? 1 : -1), le.table), he) : he ? Z.selectNext() : Z.selectPrevious(), !0;
      case "up":
        return ce !== 0 ? ue(Z.getCellNodeFromCordsOrThrow(re, ce - 1, le.table), !1) : Z.selectPrevious(), !0;
      case "down":
        return ce !== le.table.rows - 1 ? ue(Z.getCellNodeFromCordsOrThrow(re, ce + 1, le.table), !0) : Z.selectNext(), !0;
      default:
        return !1;
    }
  }, te = (le, Z, re, ce, ve) => {
    const he = ve === "forward";
    switch (ve) {
      case "backward":
      case "forward":
        return re !== (he ? le.table.columns - 1 : 0) && le.setFocusCellForSelection(Z.getDOMCellFromCordsOrThrow(re + (he ? 1 : -1), ce, le.table)), !0;
      case "up":
        return ce !== 0 ? (le.setFocusCellForSelection(Z.getDOMCellFromCordsOrThrow(re, ce - 1, le.table)), !0) : !1;
      case "down":
        return ce !== le.table.rows - 1 ? (le.setFocusCellForSelection(Z.getDOMCellFromCordsOrThrow(re, ce + 1, le.table)), !0) : !1;
      default:
        return !1;
    }
  };
  function ee(le, Z) {
    if (e.$isRangeSelection(le) || I(le)) {
      const re = Z.isParentOf(le.anchor.getNode()), ce = Z.isParentOf(le.focus.getNode());
      return re && ce;
    }
    return !1;
  }
  function ue(le, Z) {
    Z ? le.selectStart() : le.selectEnd();
  }
  const xe = "172,206,247";
  function ye(le, Z) {
    const re = Z.elem, ce = e.$getNearestNodeFromDOMNode(re);
    if (!a(ce))
      throw Error("Expected to find LexicalNode from Table Cell DOMNode");
    ce.getBackgroundColor() === null ? re.style.setProperty("background-color", `rgb(${xe})`) : re.style.setProperty("background-image", `linear-gradient(to right, rgba(${xe},0.85), rgba(${xe},0.85))`), re.style.setProperty("caret-color", "transparent");
  }
  function de(le, Z) {
    const re = Z.elem, ce = e.$getNearestNodeFromDOMNode(re);
    if (!a(ce))
      throw Error("Expected to find LexicalNode from Table Cell DOMNode");
    ce.getBackgroundColor() === null && re.style.removeProperty("background-color"), re.style.removeProperty("background-image"), re.style.removeProperty("caret-color");
  }
  function me(le) {
    const Z = r.$findMatchingParent(le, a);
    return a(Z) ? Z : null;
  }
  function we(le) {
    const Z = r.$findMatchingParent(le, Je);
    return Je(Z) ? Z : null;
  }
  function Ee(le, Z, re, ce, ve) {
    const he = e.$getSelection();
    if (!ee(he, ce))
      return !1;
    if (e.$isRangeSelection(he) && he.isCollapsed()) {
      if (re === "backward" || re === "forward")
        return !1;
      const {
        anchor: Te,
        focus: De
      } = he, Pe = r.$findMatchingParent(Te.getNode(), a), Ae = r.$findMatchingParent(De.getNode(), a);
      if (!a(Pe) || !Pe.is(Ae))
        return !1;
      const qe = we(Pe);
      if (qe !== ce && qe != null) {
        const Ze = le.getElementByKey(qe.getKey());
        if (Ze != null)
          return ve.table = Ne(Ze), Ee(le, Z, re, qe, ve);
      }
      const be = le.getElementByKey(Pe.__key), Ce = le.getElementByKey(Te.key);
      if (Ce == null || be == null)
        return !1;
      let Le;
      if (Te.type === "element")
        Le = Ce.getBoundingClientRect();
      else {
        const Ze = window.getSelection();
        if (Ze === null || Ze.rangeCount === 0)
          return !1;
        Le = Ze.getRangeAt(0).getBoundingClientRect();
      }
      const je = re === "up" ? Pe.getFirstChild() : Pe.getLastChild();
      if (je == null)
        return !1;
      const Ke = le.getElementByKey(je.__key);
      if (Ke == null)
        return !1;
      const Ue = Ke.getBoundingClientRect();
      if (re === "up" ? Ue.top > Le.top - Le.height : Le.bottom + Le.height > Ue.bottom) {
        Be(Z);
        const Ze = ce.getCordsFromCellNode(Pe, ve.table);
        if (Z.shiftKey) {
          const st = ce.getDOMCellFromCordsOrThrow(Ze.x, Ze.y, ve.table);
          ve.setAnchorCellForSelection(st), ve.setFocusCellForSelection(st, !0);
        } else
          return V(ve, ce, Ze.x, Ze.y, re);
        return !0;
      }
    } else if (I(he)) {
      const {
        anchor: Te,
        focus: De
      } = he, Pe = r.$findMatchingParent(Te.getNode(), a), Ae = r.$findMatchingParent(De.getNode(), a), [qe] = he.getNodes(), be = le.getElementByKey(qe.getKey());
      if (!a(Pe) || !a(Ae) || !Je(qe) || be == null)
        return !1;
      ve.updateTableTableSelection(he);
      const Ce = Ne(be), Le = ce.getCordsFromCellNode(Pe, Ce), je = ce.getDOMCellFromCordsOrThrow(Le.x, Le.y, Ce);
      if (ve.setAnchorCellForSelection(je), Be(Z), Z.shiftKey) {
        const Ke = ce.getCordsFromCellNode(Ae, Ce);
        return te(ve, qe, Ke.x, Ke.y, re);
      } else
        Ae.selectEnd();
      return !0;
    }
    return !1;
  }
  function Be(le) {
    le.preventDefault(), le.stopImmediatePropagation(), le.stopPropagation();
  }
  class ke extends e.ElementNode {
    static getType() {
      return "table";
    }
    static clone(Z) {
      return new ke(Z.__key);
    }
    static importDOM() {
      return {
        table: (Z) => ({
          conversion: Pt,
          priority: 1
        })
      };
    }
    static importJSON(Z) {
      return Ct();
    }
    constructor(Z) {
      super(Z);
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "table",
        version: 1
      };
    }
    createDOM(Z, re) {
      const ce = document.createElement("table");
      return r.addClassNamesToElement(ce, Z.theme.table), ce;
    }
    updateDOM() {
      return !1;
    }
    exportDOM(Z) {
      return {
        ...super.exportDOM(Z),
        after: (re) => {
          if (re) {
            const ce = re.cloneNode(), ve = document.createElement("colgroup"), he = document.createElement("tbody");
            r.isHTMLElement(re) && he.append(...re.children);
            const Te = this.getFirstChildOrThrow();
            if (!m(Te))
              throw new Error("Expected to find row node.");
            const De = Te.getChildrenSize();
            for (let Pe = 0; Pe < De; Pe++) {
              const Ae = document.createElement("col");
              ve.append(Ae);
            }
            return ce.replaceChildren(ve, he), ce;
          }
        }
      };
    }
    // TODO 0.10 deprecate
    canExtractContents() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isShadowRoot() {
      return !0;
    }
    getCordsFromCellNode(Z, re) {
      const {
        rows: ce,
        domRows: ve
      } = re;
      for (let he = 0; he < ce; he++) {
        const Te = ve[he];
        if (Te == null)
          continue;
        const De = Te.findIndex((Pe) => {
          if (!Pe) return;
          const {
            elem: Ae
          } = Pe;
          return e.$getNearestNodeFromDOMNode(Ae) === Z;
        });
        if (De !== -1)
          return {
            x: De,
            y: he
          };
      }
      throw new Error("Cell not found in table.");
    }
    getDOMCellFromCords(Z, re, ce) {
      const {
        domRows: ve
      } = ce, he = ve[re];
      if (he == null)
        return null;
      const Te = he[Z];
      return Te ?? null;
    }
    getDOMCellFromCordsOrThrow(Z, re, ce) {
      const ve = this.getDOMCellFromCords(Z, re, ce);
      if (!ve)
        throw new Error("Cell not found at cords.");
      return ve;
    }
    getCellNodeFromCords(Z, re, ce) {
      const ve = this.getDOMCellFromCords(Z, re, ce);
      if (ve == null)
        return null;
      const he = e.$getNearestNodeFromDOMNode(ve.elem);
      return a(he) ? he : null;
    }
    getCellNodeFromCordsOrThrow(Z, re, ce) {
      const ve = this.getCellNodeFromCords(Z, re, ce);
      if (!ve)
        throw new Error("Node at cords not TableCellNode.");
      return ve;
    }
    canSelectBefore() {
      return !0;
    }
    canIndent() {
      return !1;
    }
  }
  function at(le, Z) {
    const re = le.getElementByKey(Z.getKey());
    if (re == null)
      throw new Error("Table Element Not Found");
    return Ne(re);
  }
  function Pt(le) {
    return {
      node: Ct()
    };
  }
  function Ct() {
    return e.$applyNodeReplacement(new ke());
  }
  function Je(le) {
    return le instanceof ke;
  }
  return ft.$computeTableMap = T, ft.$createTableCellNode = s, ft.$createTableNode = Ct, ft.$createTableNodeWithDimensions = h, ft.$createTableRowNode = p, ft.$createTableSelection = Y, ft.$deleteTableColumn = S, ft.$deleteTableColumn__EXPERIMENTAL = U, ft.$deleteTableRow__EXPERIMENTAL = P, ft.$getElementForTableNode = at, ft.$getNodeTriplet = $, ft.$getTableCellNodeFromLexicalNode = f, ft.$getTableCellNodeRect = G, ft.$getTableColumnIndexFromTableCellNode = g, ft.$getTableNodeFromLexicalNodeOrThrow = v, ft.$getTableRowIndexFromTableCellNode = C, ft.$getTableRowNodeFromTableCellNodeOrThrow = N, ft.$insertTableColumn = y, ft.$insertTableColumn__EXPERIMENTAL = E, ft.$insertTableRow = A, ft.$insertTableRow__EXPERIMENTAL = M, ft.$isTableCellNode = a, ft.$isTableNode = Je, ft.$isTableRowNode = m, ft.$isTableSelection = I, ft.$removeTableRowAtIndex = b, ft.$unmergeCell = R, ft.INSERT_TABLE_COMMAND = l, ft.TableCellHeaderStates = n, ft.TableCellNode = i, ft.TableNode = ke, ft.TableObserver = X, ft.TableRowNode = u, ft.applyTableHandlers = ne, ft.getDOMCellFromTarget = pe, ft.getTableObserverFromTableElement = _e, ft;
}
var mt = {}, x0;
function zf() {
  if (x0) return mt;
  x0 = 1;
  var r = it(), e = Ve;
  let t = /^(\d+(?:\.\d+)?)px$/, n = { BOTH: 3, COLUMN: 2, NO_STATUS: 0, ROW: 1 };
  class i extends e.ElementNode {
    static getType() {
      return "tablecell";
    }
    static clone(F) {
      let k = new i(F.__headerState, F.__colSpan, F.__width, F.__key);
      return k.__rowSpan = F.__rowSpan, k.__backgroundColor = F.__backgroundColor, k;
    }
    static importDOM() {
      return { td: () => ({ conversion: o, priority: 0 }), th: () => ({ conversion: o, priority: 0 }) };
    }
    static importJSON(F) {
      let k = F.rowSpan || 1, W = s(F.headerState, F.colSpan || 1, F.width || void 0);
      return W.__rowSpan = k, W.__backgroundColor = F.backgroundColor || null, W;
    }
    constructor(F = n.NO_STATUS, k = 1, W, V) {
      super(V), this.__colSpan = k, this.__rowSpan = 1, this.__headerState = F, this.__width = W, this.__backgroundColor = null;
    }
    createDOM(F) {
      let k = document.createElement(this.getTag());
      return this.__width && (k.style.width = `${this.__width}px`), 1 < this.__colSpan && (k.colSpan = this.__colSpan), 1 < this.__rowSpan && (k.rowSpan = this.__rowSpan), this.__backgroundColor !== null && (k.style.backgroundColor = this.__backgroundColor), r.addClassNamesToElement(k, F.theme.tableCell, this.hasHeader() && F.theme.tableCellHeader), k;
    }
    exportDOM(F) {
      if ({ element: F } = super.exportDOM(F), F) {
        var k = this.getParentOrThrow().getChildrenSize();
        F.style.border = "1px solid black", 1 < this.__colSpan && (F.colSpan = this.__colSpan), 1 < this.__rowSpan && (F.rowSpan = this.__rowSpan), F.style.width = `${this.getWidth() || Math.max(90, 700 / k)}px`, F.style.verticalAlign = "top", F.style.textAlign = "start", k = this.getBackgroundColor(), k !== null ? F.style.backgroundColor = k : this.hasHeader() && (F.style.backgroundColor = "#f2f3f5");
      }
      return { element: F };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        backgroundColor: this.getBackgroundColor(),
        colSpan: this.__colSpan,
        headerState: this.__headerState,
        rowSpan: this.__rowSpan,
        type: "tablecell",
        width: this.getWidth()
      };
    }
    getColSpan() {
      return this.__colSpan;
    }
    setColSpan(F) {
      return this.getWritable().__colSpan = F, this;
    }
    getRowSpan() {
      return this.__rowSpan;
    }
    setRowSpan(F) {
      return this.getWritable().__rowSpan = F, this;
    }
    getTag() {
      return this.hasHeader() ? "th" : "td";
    }
    setHeaderStyles(F) {
      return this.getWritable().__headerState = F, this.__headerState;
    }
    getHeaderStyles() {
      return this.getLatest().__headerState;
    }
    setWidth(F) {
      return this.getWritable().__width = F, this.__width;
    }
    getWidth() {
      return this.getLatest().__width;
    }
    getBackgroundColor() {
      return this.getLatest().__backgroundColor;
    }
    setBackgroundColor(F) {
      this.getWritable().__backgroundColor = F;
    }
    toggleHeaderStyle(F) {
      let k = this.getWritable();
      return k.__headerState = (k.__headerState & F) === F ? k.__headerState - F : k.__headerState + F, k;
    }
    hasHeaderState(F) {
      return (this.getHeaderStyles() & F) === F;
    }
    hasHeader() {
      return this.getLatest().__headerState !== n.NO_STATUS;
    }
    updateDOM(F) {
      return F.__headerState !== this.__headerState || F.__width !== this.__width || F.__colSpan !== this.__colSpan || F.__rowSpan !== this.__rowSpan || F.__backgroundColor !== this.__backgroundColor;
    }
    isShadowRoot() {
      return !0;
    }
    collapseAtStart() {
      return !0;
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
  }
  function o(B) {
    var F = B.nodeName.toLowerCase();
    let k;
    return t.test(B.style.width) && (k = parseFloat(B.style.width)), F = s(F === "th" ? n.ROW : n.NO_STATUS, B.colSpan, k), F.__rowSpan = B.rowSpan, B = B.style.backgroundColor, B !== "" && (F.__backgroundColor = B), { forChild: (W, V) => a(V) && !e.$isElementNode(W) ? (V = e.$createParagraphNode(), e.$isLineBreakNode(W) && W.getTextContent() === `
` ? null : (V.append(W), V)) : W, node: F };
  }
  function s(B, F = 1, k) {
    return e.$applyNodeReplacement(new i(B, F, k));
  }
  function a(B) {
    return B instanceof i;
  }
  let l = e.createCommand("INSERT_TABLE_COMMAND");
  class u extends e.ElementNode {
    static getType() {
      return "tablerow";
    }
    static clone(F) {
      return new u(F.__height, F.__key);
    }
    static importDOM() {
      return { tr: () => ({ conversion: d, priority: 0 }) };
    }
    static importJSON(F) {
      return p(F.height);
    }
    constructor(F, k) {
      super(k), this.__height = F;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "tablerow", version: 1 };
    }
    createDOM(F) {
      let k = document.createElement("tr");
      return this.__height && (k.style.height = `${this.__height}px`), r.addClassNamesToElement(k, F.theme.tableRow), k;
    }
    isShadowRoot() {
      return !0;
    }
    setHeight(F) {
      return this.getWritable().__height = F, this.__height;
    }
    getHeight() {
      return this.getLatest().__height;
    }
    updateDOM(F) {
      return F.__height !== this.__height;
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
  }
  function d(B) {
    let F;
    return t.test(B.style.height) && (F = parseFloat(B.style.height)), { node: p(F) };
  }
  function p(B) {
    return e.$applyNodeReplacement(new u(B));
  }
  function m(B) {
    return B instanceof u;
  }
  function c(B) {
    let F = new URLSearchParams();
    F.append("code", B);
    for (let k = 1; k < arguments.length; k++) F.append("v", arguments[k]);
    throw Error(`Minified Lexical error #${B}; visit https://lexical.dev/docs/error?${F} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  let h = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  function f(B) {
    if (B = r.$findMatchingParent(B, (F) => m(F)), m(B)) return B;
    throw Error("Expected table cell to be inside of table row.");
  }
  function N(B) {
    if (B = r.$findMatchingParent(B, (F) => Ne(F)), Ne(B)) return B;
    throw Error("Expected table cell to be inside of table.");
  }
  function v(B, F) {
    let k = N(B), { x: W, y: V } = k.getCordsFromCellNode(B, F);
    return { above: k.getCellNodeFromCords(W, V - 1, F), below: k.getCellNodeFromCords(W, V + 1, F), left: k.getCellNodeFromCords(W - 1, V, F), right: k.getCellNodeFromCords(W + 1, V, F) };
  }
  let C = (B, F) => B === n.BOTH || B === F ? F : n.NO_STATUS;
  function g(B) {
    let F = B.getFirstDescendant();
    F == null ? B.selectStart() : F.getParentOrThrow().selectStart();
  }
  function x(B, F) {
    let k = B.getFirstChild();
    k !== null ? k.insertBefore(F) : B.append(F);
  }
  function b(B, F, k) {
    let W = [], V = null, te = null;
    B = B.getChildren();
    for (let de = 0; de < B.length; de++) {
      var ee = B[de];
      m(ee) || c(146);
      var ue = ee.getChildren();
      ee = 0;
      for (let me of ue) {
        for (a(me) || c(147); W[de] !== void 0 && W[de][ee] !== void 0; ) ee++;
        ue = de;
        var xe = ee, ye = me;
        let we = { cell: ye, startColumn: xe, startRow: ue }, Ee = ye.__rowSpan, Be = ye.__colSpan;
        for (let ke = 0; ke < Ee; ke++) {
          W[ue + ke] === void 0 && (W[ue + ke] = []);
          for (let at = 0; at < Be; at++) W[ue + ke][xe + at] = we;
        }
        F.is(ye) && (V = we), k.is(ye) && (te = we), ee += me.__colSpan;
      }
    }
    return V === null && c(110), te === null && c(111), [W, V, te];
  }
  function A(B) {
    B instanceof i || ("__type" in B ? (B = r.$findMatchingParent(B, a), a(B) || c(148)) : (B = r.$findMatchingParent(B.getNode(), a), a(B) || c(148)));
    let F = B.getParent();
    m(F) || c(149);
    let k = F.getParent();
    return Ne(k) || c(150), [B, F, k];
  }
  function w(B) {
    let [F, , k] = A(B);
    B = k.getChildren();
    let W = B.length;
    var V = B[0].getChildren().length;
    let te = Array(W);
    for (var ee = 0; ee < W; ee++) te[ee] = Array(V);
    for (V = 0; V < W; V++) {
      ee = B[V].getChildren();
      let ue = 0;
      for (let xe = 0; xe < ee.length; xe++) {
        for (; te[V][ue]; ) ue++;
        let ye = ee[xe], de = ye.__rowSpan || 1, me = ye.__colSpan || 1;
        for (let we = 0; we < de; we++) for (let Ee = 0; Ee < me; Ee++) te[V + we][ue + Ee] = ye;
        if (F === ye) return { colSpan: me, columnIndex: ue, rowIndex: V, rowSpan: de };
        ue += me;
      }
    }
    return null;
  }
  class M {
    constructor(F, k, W) {
      this.anchor = k, this.focus = W, k._selection = this, W._selection = this, this._cachedNodes = null, this.dirty = !1, this.tableKey = F;
    }
    getStartEndPoints() {
      return [this.anchor, this.focus];
    }
    isBackward() {
      return this.focus.isBefore(this.anchor);
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(F) {
      this._cachedNodes = F;
    }
    is(F) {
      return y(F) ? this.tableKey === F.tableKey && this.anchor.is(F.anchor) && this.focus.is(F.focus) : !1;
    }
    set(F, k, W) {
      this.dirty = !0, this.tableKey = F, this.anchor.key = k, this.focus.key = W, this._cachedNodes = null;
    }
    clone() {
      return new M(this.tableKey, this.anchor, this.focus);
    }
    isCollapsed() {
      return !1;
    }
    extract() {
      return this.getNodes();
    }
    insertRawText() {
    }
    insertText() {
    }
    insertNodes(F) {
      let k = this.focus.getNode();
      e.$isElementNode(k) || c(151), e.$normalizeSelection__EXPERIMENTAL(k.select(0, k.getChildrenSize())).insertNodes(F);
    }
    getShape() {
      var F = e.$getNodeByKey(this.anchor.key);
      a(F) || c(152), F = w(F), F === null && c(153);
      var k = e.$getNodeByKey(this.focus.key);
      a(k) || c(154);
      let W = w(k);
      W === null && c(155), k = Math.min(
        F.columnIndex,
        W.columnIndex
      );
      let V = Math.max(F.columnIndex, W.columnIndex), te = Math.min(F.rowIndex, W.rowIndex);
      return F = Math.max(F.rowIndex, W.rowIndex), { fromX: Math.min(k, V), fromY: Math.min(te, F), toX: Math.max(k, V), toY: Math.max(te, F) };
    }
    getNodes() {
      function F(at) {
        let { cell: Pt, startColumn: Ct, startRow: Je } = at;
        ye = Math.min(ye, Ct), de = Math.min(de, Je), me = Math.max(me, Ct + Pt.__colSpan - 1), we = Math.max(we, Je + Pt.__rowSpan - 1);
      }
      var k = this._cachedNodes;
      if (k !== null) return k;
      var W = this.anchor.getNode();
      k = this.focus.getNode();
      var V = r.$findMatchingParent(W, a);
      W = r.$findMatchingParent(
        k,
        a
      ), a(V) || c(152), a(W) || c(154), k = V.getParent(), m(k) || c(156), k = k.getParent(), Ne(k) || c(157);
      var te = W.getParents()[1];
      if (te !== k) return k.isParentOf(W) ? (k = te.getParent(), k == null && c(159), this.set(this.tableKey, W.getKey(), k.getKey())) : (k = k.getParent(), k == null && c(158), this.set(this.tableKey, k.getKey(), W.getKey())), this.getNodes();
      let [ee, ue, xe] = b(k, V, W), ye = Math.min(ue.startColumn, xe.startColumn), de = Math.min(ue.startRow, xe.startRow), me = Math.max(ue.startColumn + ue.cell.__colSpan - 1, xe.startColumn + xe.cell.__colSpan - 1), we = Math.max(ue.startRow + ue.cell.__rowSpan - 1, xe.startRow + xe.cell.__rowSpan - 1);
      W = ye, V = de, te = ye;
      for (var Ee = de; ye < W || de < V || me > te || we > Ee; ) {
        if (ye < W) {
          var Be = Ee - V;
          --W;
          for (var ke = 0; ke <= Be; ke++) F(ee[V + ke][W]);
        }
        if (de < V) for (Be = te - W, --V, ke = 0; ke <= Be; ke++) F(ee[V][W + ke]);
        if (me > te) for (Be = Ee - V, te += 1, ke = 0; ke <= Be; ke++) F(ee[V + ke][te]);
        if (we > Ee) for (Be = te - W, Ee += 1, ke = 0; ke <= Be; ke++) F(ee[Ee][W + ke]);
      }
      for (k = [k], W = null, V = de; V <= we; V++) for (te = ye; te <= me; te++) ({ cell: Ee } = ee[V][te]), Be = Ee.getParent(), m(Be) || c(160), Be !== W && k.push(Be), k.push(Ee, ...S(Ee)), W = Be;
      return e.isCurrentlyReadOnlyMode() || (this._cachedNodes = k), k;
    }
    getTextContent() {
      let F = this.getNodes(), k = "";
      for (let W = 0; W < F.length; W++) k += F[W].getTextContent();
      return k;
    }
  }
  function y(B) {
    return B instanceof M;
  }
  function E() {
    let B = e.$createPoint("root", 0, "element"), F = e.$createPoint("root", 0, "element");
    return new M("root", B, F);
  }
  function S(B) {
    let F = [], k = [B];
    for (; 0 < k.length; ) {
      let W = k.pop();
      W === void 0 && c(112), e.$isElementNode(W) && k.unshift(...W.getChildren()), W !== B && F.push(W);
    }
    return F;
  }
  class P {
    constructor(F, k) {
      this.isHighlightingCells = !1, this.focusY = this.focusX = this.anchorY = this.anchorX = -1, this.listenersToRemove = /* @__PURE__ */ new Set(), this.tableNodeKey = k, this.editor = F, this.table = { columns: 0, domRows: [], rows: 0 }, this.focusCell = this.anchorCell = this.focusCellNodeKey = this.anchorCellNodeKey = this.tableSelection = null, this.hasHijackedSelectionStyles = !1, this.trackTable();
    }
    getTable() {
      return this.table;
    }
    removeListeners() {
      Array.from(this.listenersToRemove).forEach((F) => F());
    }
    trackTable() {
      let F = new MutationObserver((k) => {
        this.editor.update(() => {
          var W = !1;
          for (let V = 0; V < k.length; V++) {
            const te = k[V].target.nodeName;
            if (te === "TABLE" || te === "TR") {
              W = !0;
              break;
            }
          }
          if (W) {
            if (W = this.editor.getElementByKey(this.tableNodeKey), !W) throw Error("Expected to find TableElement in DOM");
            this.table = j(W);
          }
        });
      });
      this.editor.update(() => {
        let k = this.editor.getElementByKey(this.tableNodeKey);
        if (!k) throw Error("Expected to find TableElement in DOM");
        this.table = j(k), F.observe(k, { childList: !0, subtree: !0 });
      });
    }
    clearHighlight() {
      let F = this.editor;
      this.isHighlightingCells = !1, this.focusY = this.focusX = this.anchorY = this.anchorX = -1, this.focusCell = this.anchorCell = this.focusCellNodeKey = this.anchorCellNodeKey = this.tableSelection = null, this.hasHijackedSelectionStyles = !1, this.enableHighlightStyle(), F.update(() => {
        var k = e.$getNodeByKey(this.tableNodeKey);
        if (!Ne(k)) throw Error("Expected TableNode.");
        if (k = F.getElementByKey(this.tableNodeKey), !k) throw Error("Expected to find TableElement in DOM");
        k = j(k), H(F, k, null), e.$setSelection(null), F.dispatchCommand(
          e.SELECTION_CHANGE_COMMAND,
          void 0
        );
      });
    }
    enableHighlightStyle() {
      let F = this.editor;
      F.update(() => {
        let k = F.getElementByKey(this.tableNodeKey);
        if (!k) throw Error("Expected to find TableElement in DOM");
        r.removeClassNamesFromElement(k, F._config.theme.tableSelection), k.classList.remove("disable-selection"), this.hasHijackedSelectionStyles = !1;
      });
    }
    disableHighlightStyle() {
      let F = this.editor;
      F.update(() => {
        let k = F.getElementByKey(this.tableNodeKey);
        if (!k) throw Error("Expected to find TableElement in DOM");
        r.addClassNamesToElement(k, F._config.theme.tableSelection), this.hasHijackedSelectionStyles = !0;
      });
    }
    updateTableTableSelection(F) {
      if (F !== null && F.tableKey === this.tableNodeKey) {
        let k = this.editor;
        this.tableSelection = F, this.isHighlightingCells = !0, this.disableHighlightStyle(), H(k, this.table, this.tableSelection);
      } else F == null ? this.clearHighlight() : (this.tableNodeKey = F.tableKey, this.updateTableTableSelection(F));
    }
    setFocusCellForSelection(F, k = !1) {
      let W = this.editor;
      W.update(() => {
        var V = e.$getNodeByKey(this.tableNodeKey);
        if (!Ne(V)) throw Error("Expected TableNode.");
        if (!W.getElementByKey(this.tableNodeKey)) throw Error("Expected to find TableElement in DOM");
        V = F.x;
        let te = F.y;
        if (this.focusCell = F, this.anchorCell !== null) {
          let ee = h ? (W._window || window).getSelection() : null;
          ee && ee.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);
        }
        if (!this.isHighlightingCells && (this.anchorX !== V || this.anchorY !== te || k)) this.isHighlightingCells = !0, this.disableHighlightStyle();
        else if (V === this.focusX && te === this.focusY) return;
        this.focusX = V, this.focusY = te, this.isHighlightingCells && (V = e.$getNearestNodeFromDOMNode(F.elem), this.tableSelection != null && this.anchorCellNodeKey != null && a(V) && (V = V.getKey(), this.tableSelection = this.tableSelection.clone() || E(), this.focusCellNodeKey = V, this.tableSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey), e.$setSelection(this.tableSelection), W.dispatchCommand(e.SELECTION_CHANGE_COMMAND, void 0), H(W, this.table, this.tableSelection)));
      });
    }
    setAnchorCellForSelection(F) {
      this.isHighlightingCells = !1, this.anchorCell = F, this.anchorX = F.x, this.anchorY = F.y, this.editor.update(() => {
        var k = e.$getNearestNodeFromDOMNode(F.elem);
        a(k) && (k = k.getKey(), this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : E(), this.anchorCellNodeKey = k);
      });
    }
    formatCells(F) {
      this.editor.update(() => {
        let k = e.$getSelection();
        y(k) || c(11);
        let W = e.$createRangeSelection(), V = W.anchor, te = W.focus;
        k.getNodes().forEach((ee) => {
          a(ee) && ee.getTextContentSize() !== 0 && (V.set(ee.getKey(), 0, "element"), te.set(ee.getKey(), ee.getChildrenSize(), "element"), W.formatText(F));
        }), e.$setSelection(k), this.editor.dispatchCommand(e.SELECTION_CHANGE_COMMAND, void 0);
      });
    }
    clearText() {
      let F = this.editor;
      F.update(() => {
        let k = e.$getNodeByKey(this.tableNodeKey);
        if (!Ne(k)) throw Error("Expected TableNode.");
        var W = e.$getSelection();
        y(W) || c(11), W = W.getNodes().filter(a), W.length === this.table.columns * this.table.rows ? (k.selectPrevious(), k.remove(), e.$getRoot().selectStart()) : (W.forEach((V) => {
          if (e.$isElementNode(V)) {
            let te = e.$createParagraphNode(), ee = e.$createTextNode();
            te.append(ee), V.append(te), V.getChildren().forEach((ue) => {
              ue !== te && ue.remove();
            });
          }
        }), H(F, this.table, null), e.$setSelection(null), F.dispatchCommand(
          e.SELECTION_CHANGE_COMMAND,
          void 0
        ));
      });
    }
  }
  function U(B) {
    for (; B != null; ) {
      let F = B.nodeName;
      if (F === "TD" || F === "TH") {
        if (B = B._cell, B === void 0) break;
        return B;
      }
      B = B.parentNode;
    }
    return null;
  }
  function j(B) {
    let F = [], k = { columns: 0, domRows: F, rows: 0 };
    var W = B.firstChild;
    let V = B = 0;
    for (F.length = 0; W != null; ) {
      var te = W.nodeName;
      if (te === "TD" || te === "TH") {
        te = W, te = { elem: te, hasBackgroundColor: te.style.backgroundColor !== "", highlighted: !1, x: B, y: V }, W._cell = te;
        let ee = F[V];
        ee === void 0 && (ee = F[V] = []), ee[B] = te;
      } else if (te = W.firstChild, te != null) {
        W = te;
        continue;
      }
      if (te = W.nextSibling, te != null) B++, W = te;
      else if (te = W.parentNode, te != null) {
        if (W = te.nextSibling, W == null) break;
        V++, B = 0;
      }
    }
    return k.columns = B + 1, k.rows = V + 1, k;
  }
  function H(B, F, k) {
    let W = new Set(k ? k.getNodes() : []);
    R(F, (V, te) => {
      let ee = V.elem;
      W.has(te) ? (V.highlighted = !0, Y(B, V)) : (V.highlighted = !1, D(B, V), ee.getAttribute("style") || ee.removeAttribute("style"));
    });
  }
  function R(B, F) {
    ({ domRows: B } = B);
    for (let k = 0; k < B.length; k++) {
      let W = B[k];
      if (W) for (let V = 0; V < W.length; V++) {
        let te = W[V];
        if (!te) continue;
        let ee = e.$getNearestNodeFromDOMNode(te.elem);
        ee !== null && F(te, ee, { x: V, y: k });
      }
    }
  }
  function T(B, F) {
    F.disableHighlightStyle(), R(F.table, (k) => {
      k.highlighted = !0, Y(B, k);
    });
  }
  function $(B, F) {
    F.enableHighlightStyle(), R(F.table, (k) => {
      let W = k.elem;
      k.highlighted = !1, D(B, k), W.getAttribute("style") || W.removeAttribute("style");
    });
  }
  let G = (B, F, k, W, V) => {
    const te = V === "forward";
    switch (V) {
      case "backward":
      case "forward":
        return k !== (te ? B.table.columns - 1 : 0) ? (B = F.getCellNodeFromCordsOrThrow(k + (te ? 1 : -1), W, B.table), te ? B.selectStart() : B.selectEnd()) : W !== (te ? B.table.rows - 1 : 0) ? (B = F.getCellNodeFromCordsOrThrow(te ? 0 : B.table.columns - 1, W + (te ? 1 : -1), B.table), te ? B.selectStart() : B.selectEnd()) : te ? F.selectNext() : F.selectPrevious(), !0;
      case "up":
        return W !== 0 ? F.getCellNodeFromCordsOrThrow(k, W - 1, B.table).selectEnd() : F.selectPrevious(), !0;
      case "down":
        return W !== B.table.rows - 1 ? F.getCellNodeFromCordsOrThrow(k, W + 1, B.table).selectStart() : F.selectNext(), !0;
      default:
        return !1;
    }
  }, q = (B, F, k, W, V) => {
    const te = V === "forward";
    switch (V) {
      case "backward":
      case "forward":
        return k !== (te ? B.table.columns - 1 : 0) && B.setFocusCellForSelection(F.getDOMCellFromCordsOrThrow(k + (te ? 1 : -1), W, B.table)), !0;
      case "up":
        return W !== 0 ? (B.setFocusCellForSelection(F.getDOMCellFromCordsOrThrow(k, W - 1, B.table)), !0) : !1;
      case "down":
        return W !== B.table.rows - 1 ? (B.setFocusCellForSelection(F.getDOMCellFromCordsOrThrow(
          k,
          W + 1,
          B.table
        )), !0) : !1;
      default:
        return !1;
    }
  };
  function I(B, F) {
    if (e.$isRangeSelection(B) || y(B)) {
      let k = F.isParentOf(B.anchor.getNode());
      return B = F.isParentOf(B.focus.getNode()), k && B;
    }
    return !1;
  }
  function Y(B, F) {
    B = F.elem, F = e.$getNearestNodeFromDOMNode(B), a(F) || c(131), F.getBackgroundColor() === null ? B.style.setProperty("background-color", "rgb(172,206,247)") : B.style.setProperty("background-image", "linear-gradient(to right, rgba(172,206,247,0.85), rgba(172,206,247,0.85))"), B.style.setProperty("caret-color", "transparent");
  }
  function D(B, F) {
    B = F.elem, F = e.$getNearestNodeFromDOMNode(B), a(F) || c(131), F.getBackgroundColor() === null && B.style.removeProperty("background-color"), B.style.removeProperty("background-image"), B.style.removeProperty("caret-color");
  }
  function z(B) {
    return B = r.$findMatchingParent(B, a), a(B) ? B : null;
  }
  function X(B) {
    return B = r.$findMatchingParent(B, Ne), Ne(B) ? B : null;
  }
  function Q(B, F, k, W, V) {
    let te = e.$getSelection();
    if (!I(te, W)) return !1;
    if (e.$isRangeSelection(te) && te.isCollapsed()) {
      if (k === "backward" || k === "forward") return !1;
      let { anchor: ye, focus: de } = te;
      var ee = r.$findMatchingParent(ye.getNode(), a), ue = r.$findMatchingParent(de.getNode(), a);
      if (!a(ee) || !ee.is(ue)) return !1;
      if (ue = X(ee), ue !== W && ue != null) {
        var xe = B.getElementByKey(ue.getKey());
        if (xe != null) return V.table = j(xe), Q(B, F, k, ue, V);
      }
      if (ue = B.getElementByKey(ee.__key), xe = B.getElementByKey(ye.key), xe == null || ue == null) return !1;
      if (ye.type === "element") ue = xe.getBoundingClientRect();
      else {
        if (ue = window.getSelection(), ue === null || ue.rangeCount === 0) return !1;
        ue = ue.getRangeAt(0).getBoundingClientRect();
      }
      if (xe = k === "up" ? ee.getFirstChild() : ee.getLastChild(), xe == null || (B = B.getElementByKey(xe.__key), B == null)) return !1;
      if (B = B.getBoundingClientRect(), k === "up" ? B.top > ue.top - ue.height : ue.bottom + ue.height > B.bottom) {
        if (ne(F), B = W.getCordsFromCellNode(ee, V.table), F.shiftKey) k = W.getDOMCellFromCordsOrThrow(B.x, B.y, V.table), V.setAnchorCellForSelection(k), V.setFocusCellForSelection(
          k,
          !0
        );
        else return G(V, W, B.x, B.y, k);
        return !0;
      }
    } else if (y(te)) {
      let { anchor: ye, focus: de } = te;
      return xe = r.$findMatchingParent(ye.getNode(), a), ue = r.$findMatchingParent(de.getNode(), a), [ee] = te.getNodes(), B = B.getElementByKey(ee.getKey()), !a(xe) || !a(ue) || !Ne(ee) || B == null ? !1 : (V.updateTableTableSelection(te), B = j(B), xe = W.getCordsFromCellNode(xe, B), xe = W.getDOMCellFromCordsOrThrow(xe.x, xe.y, B), V.setAnchorCellForSelection(xe), ne(F), F.shiftKey ? (F = W.getCordsFromCellNode(ue, B), q(V, ee, F.x, F.y, k)) : (ue.selectEnd(), !0));
    }
    return !1;
  }
  function ne(B) {
    B.preventDefault(), B.stopImmediatePropagation(), B.stopPropagation();
  }
  class fe extends e.ElementNode {
    static getType() {
      return "table";
    }
    static clone(F) {
      return new fe(F.__key);
    }
    static importDOM() {
      return { table: () => ({ conversion: _e, priority: 1 }) };
    }
    static importJSON() {
      return pe();
    }
    constructor(F) {
      super(F);
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "table", version: 1 };
    }
    createDOM(F) {
      let k = document.createElement("table");
      return r.addClassNamesToElement(k, F.theme.table), k;
    }
    updateDOM() {
      return !1;
    }
    exportDOM(F) {
      return { ...super.exportDOM(F), after: (k) => {
        if (k) {
          let W = k.cloneNode(), V = document.createElement("colgroup"), te = document.createElement("tbody");
          if (r.isHTMLElement(k) && te.append(...k.children), k = this.getFirstChildOrThrow(), !m(k)) throw Error("Expected to find row node.");
          k = k.getChildrenSize();
          for (let ee = 0; ee < k; ee++) {
            let ue = document.createElement("col");
            V.append(ue);
          }
          return W.replaceChildren(V, te), W;
        }
      } };
    }
    canExtractContents() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isShadowRoot() {
      return !0;
    }
    getCordsFromCellNode(F, k) {
      let { rows: W, domRows: V } = k;
      for (k = 0; k < W; k++) {
        var te = V[k];
        if (te != null && (te = te.findIndex((ee) => {
          if (ee) return { elem: ee } = ee, e.$getNearestNodeFromDOMNode(ee) === F;
        }), te !== -1)) return { x: te, y: k };
      }
      throw Error("Cell not found in table.");
    }
    getDOMCellFromCords(F, k, W) {
      return { domRows: W } = W, k = W[k], k == null ? null : (F = k[F], F ?? null);
    }
    getDOMCellFromCordsOrThrow(F, k, W) {
      if (F = this.getDOMCellFromCords(F, k, W), !F) throw Error("Cell not found at cords.");
      return F;
    }
    getCellNodeFromCords(F, k, W) {
      return F = this.getDOMCellFromCords(F, k, W), F == null ? null : (F = e.$getNearestNodeFromDOMNode(F.elem), a(F) ? F : null);
    }
    getCellNodeFromCordsOrThrow(F, k, W) {
      if (F = this.getCellNodeFromCords(
        F,
        k,
        W
      ), !F) throw Error("Node at cords not TableCellNode.");
      return F;
    }
    canSelectBefore() {
      return !0;
    }
    canIndent() {
      return !1;
    }
  }
  function _e() {
    return { node: pe() };
  }
  function pe() {
    return e.$applyNodeReplacement(new fe());
  }
  function Ne(B) {
    return B instanceof fe;
  }
  return mt.$computeTableMap = b, mt.$createTableCellNode = s, mt.$createTableNode = pe, mt.$createTableNodeWithDimensions = function(B, F, k = !0) {
    let W = pe();
    for (let te = 0; te < B; te++) {
      let ee = p();
      for (let ue = 0; ue < F; ue++) {
        var V = n.NO_STATUS;
        typeof k == "object" ? (te === 0 && k.rows && (V |= n.ROW), ue === 0 && k.columns && (V |= n.COLUMN)) : k && (te === 0 && (V |= n.ROW), ue === 0 && (V |= n.COLUMN)), V = s(V);
        let xe = e.$createParagraphNode();
        xe.append(e.$createTextNode()), V.append(xe), ee.append(V);
      }
      W.append(ee);
    }
    return W;
  }, mt.$createTableRowNode = p, mt.$createTableSelection = E, mt.$deleteTableColumn = function(B, F) {
    let k = B.getChildren();
    for (let V = 0; V < k.length; V++) {
      var W = k[V];
      if (m(W)) {
        if (W = W.getChildren(), F >= W.length || 0 > F) throw Error("Table column target index out of range");
        W[F].remove();
      }
    }
    return B;
  }, mt.$deleteTableColumn__EXPERIMENTAL = function() {
    var B = e.$getSelection();
    e.$isRangeSelection(B) || y(B) || c(118);
    var F = B.anchor.getNode();
    B = B.focus.getNode();
    let [k, , W] = A(F);
    [F] = A(B);
    let [V, te, ee] = b(W, k, F);
    var { startColumn: ue } = te;
    let { startRow: xe, startColumn: ye } = ee;
    B = Math.min(ue, ye), ue = Math.max(ue + k.__colSpan - 1, ye + F.__colSpan - 1);
    let de = ue - B + 1;
    if (V[0].length === ue - B + 1) W.selectPrevious(), W.remove();
    else {
      var me = V.length;
      for (let we = 0; we < me; we++) for (let Ee = B; Ee <= ue; Ee++) {
        let { cell: Be, startColumn: ke } = V[we][Ee];
        ke < B ? Ee === B && Be.setColSpan(Be.__colSpan - Math.min(de, Be.__colSpan - (B - ke))) : ke + Be.__colSpan - 1 > ue ? Ee === ue && Be.setColSpan(Be.__colSpan - (ue - ke + 1)) : Be.remove();
      }
      B = V[xe], F = B[ye + F.__colSpan], F !== void 0 ? ({ cell: F } = F, g(F)) : ({ cell: F } = B[ye - 1], g(F));
    }
  }, mt.$deleteTableRow__EXPERIMENTAL = function() {
    var B = e.$getSelection();
    e.$isRangeSelection(B) || y(B) || c(118);
    var F = B.anchor.getNode();
    B = B.focus.getNode();
    let [k, , W] = A(F);
    [B] = A(B);
    let [V, te, ee] = b(W, k, B);
    ({ startRow: F } = te);
    var { startRow: ue } = ee;
    if (B = ue + B.__rowSpan - 1, V.length === B - F + 1) W.remove();
    else {
      ue = V[0].length;
      var xe = V[B + 1], ye = W.getChildAtIndex(B + 1);
      for (let me = B; me >= F; me--) {
        for (var de = ue - 1; 0 <= de; de--) {
          let { cell: we, startRow: Ee, startColumn: Be } = V[me][de];
          if (Be === de && (me === F && Ee < F && we.setRowSpan(we.__rowSpan - (Ee - F)), Ee >= F && Ee + we.__rowSpan - 1 > B)) if (we.setRowSpan(we.__rowSpan - (B - Ee + 1)), ye === null && c(122), de === 0) x(ye, we);
          else {
            let { cell: ke } = xe[de - 1];
            ke.insertAfter(we);
          }
        }
        de = W.getChildAtIndex(me), m(de) || c(123, String(me)), de.remove();
      }
      xe !== void 0 ? ({ cell: F } = xe[0], g(F)) : ({ cell: F } = V[F - 1][0], g(F));
    }
  }, mt.$getElementForTableNode = function(B, F) {
    if (B = B.getElementByKey(F.getKey()), B == null) throw Error("Table Element Not Found");
    return j(B);
  }, mt.$getNodeTriplet = A, mt.$getTableCellNodeFromLexicalNode = function(B) {
    return B = r.$findMatchingParent(B, (F) => a(F)), a(B) ? B : null;
  }, mt.$getTableCellNodeRect = w, mt.$getTableColumnIndexFromTableCellNode = function(B) {
    return f(B).getChildren().findIndex((F) => F.is(B));
  }, mt.$getTableNodeFromLexicalNodeOrThrow = N, mt.$getTableRowIndexFromTableCellNode = function(B) {
    let F = f(B);
    return N(F).getChildren().findIndex((k) => k.is(F));
  }, mt.$getTableRowNodeFromTableCellNodeOrThrow = f, mt.$insertTableColumn = function(B, F, k = !0, W, V) {
    let te = B.getChildren(), ee = [];
    for (let ye = 0; ye < te.length; ye++) {
      let de = te[ye];
      if (m(de)) for (let me = 0; me < W; me++) {
        var ue = de.getChildren();
        if (F >= ue.length || 0 > F) throw Error("Table column target index out of range");
        ue = ue[F], a(ue) || c(12);
        let { left: we, right: Ee } = v(ue, V);
        var xe = n.NO_STATUS;
        (we && we.hasHeaderState(n.ROW) || Ee && Ee.hasHeaderState(n.ROW)) && (xe |= n.ROW), xe = s(xe), xe.append(e.$createParagraphNode()), ee.push({ newTableCell: xe, targetCell: ue });
      }
    }
    return ee.forEach(({ newTableCell: ye, targetCell: de }) => {
      k ? de.insertAfter(ye) : de.insertBefore(ye);
    }), B;
  }, mt.$insertTableColumn__EXPERIMENTAL = function(B = !0) {
    function F(me = n.NO_STATUS) {
      return me = s(me).append(e.$createParagraphNode()), ye === null && (ye = me), me;
    }
    var k = e.$getSelection();
    e.$isRangeSelection(k) || y(k) || c(118);
    var W = k.anchor.getNode();
    k = k.focus.getNode(), [W] = A(W);
    let [V, , te] = A(k), [ee, ue, xe] = b(te, V, W);
    W = ee.length, k = B ? Math.max(ue.startColumn, xe.startColumn) : Math.min(ue.startColumn, xe.startColumn), B = B ? k + V.__colSpan - 1 : k - 1, k = te.getFirstChild(), m(k) || c(120);
    let ye = null;
    var de = k;
    e: for (k = 0; k < W; k++) {
      k !== 0 && (de = de.getNextSibling(), m(de) || c(121));
      let me = ee[k], we = C(me[0 > B ? 0 : B].cell.__headerState, n.ROW);
      if (0 > B) {
        x(de, F(we));
        continue;
      }
      let { cell: Ee, startColumn: Be, startRow: ke } = me[B];
      if (Be + Ee.__colSpan - 1 <= B) {
        let at = Ee, Pt = ke, Ct = B;
        for (; Pt !== k && 1 < at.__rowSpan; ) if (Ct -= Ee.__colSpan, 0 <= Ct) {
          let { cell: Je, startRow: le } = me[Ct];
          at = Je, Pt = le;
        } else {
          de.append(F(we));
          continue e;
        }
        at.insertAfter(F(we));
      } else Ee.setColSpan(Ee.__colSpan + 1);
    }
    ye !== null && g(ye);
  }, mt.$insertTableRow = function(B, F, k = !0, W, V) {
    var te = B.getChildren();
    if (F >= te.length || 0 > F) throw Error("Table row target index out of range");
    if (F = te[F], m(F)) for (te = 0; te < W; te++) {
      let ue = F.getChildren(), xe = ue.length, ye = p();
      for (let de = 0; de < xe; de++) {
        var ee = ue[de];
        a(ee) || c(12);
        let { above: me, below: we } = v(ee, V);
        ee = n.NO_STATUS;
        let Ee = me && me.getWidth() || we && we.getWidth() || void 0;
        (me && me.hasHeaderState(n.COLUMN) || we && we.hasHeaderState(n.COLUMN)) && (ee |= n.COLUMN), ee = s(ee, 1, Ee), ee.append(e.$createParagraphNode()), ye.append(ee);
      }
      k ? F.insertAfter(ye) : F.insertBefore(ye);
    }
    else throw Error("Row before insertion index does not exist.");
    return B;
  }, mt.$insertTableRow__EXPERIMENTAL = function(B = !0) {
    var F = e.$getSelection();
    e.$isRangeSelection(F) || y(F) || c(118), F = F.focus.getNode();
    let [k, , W] = A(F), [V, te] = b(W, k, k);
    F = V[0].length;
    var { startRow: ee } = te;
    if (B) {
      B = ee + k.__rowSpan - 1;
      var ue = V[B];
      ee = p();
      for (var xe = 0; xe < F; xe++) {
        let { cell: de, startRow: me } = ue[xe];
        if (me + de.__rowSpan - 1 <= B) {
          var ye = C(ue[xe].cell.__headerState, n.COLUMN);
          ee.append(s(ye).append(e.$createParagraphNode()));
        } else de.setRowSpan(de.__rowSpan + 1);
      }
      F = W.getChildAtIndex(B), m(F) || c(145), F.insertAfter(ee);
    } else {
      for (ue = V[ee], B = p(), xe = 0; xe < F; xe++) {
        let { cell: de, startRow: me } = ue[xe];
        me === ee ? (ye = C(ue[xe].cell.__headerState, n.COLUMN), B.append(s(ye).append(e.$createParagraphNode()))) : de.setRowSpan(de.__rowSpan + 1);
      }
      F = W.getChildAtIndex(ee), m(F) || c(145), F.insertBefore(B);
    }
  }, mt.$isTableCellNode = a, mt.$isTableNode = Ne, mt.$isTableRowNode = m, mt.$isTableSelection = y, mt.$removeTableRowAtIndex = function(B, F) {
    let k = B.getChildren();
    if (F >= k.length || 0 > F) throw Error("Expected table cell to be inside of table row.");
    return k[F].remove(), B;
  }, mt.$unmergeCell = function() {
    var B = e.$getSelection();
    e.$isRangeSelection(B) || y(B) || c(118), B = B.anchor.getNode();
    let [F, k, W] = A(B);
    B = F.__colSpan;
    let V = F.__rowSpan;
    if (1 < B) {
      for (var te = 1; te < B; te++) F.insertAfter(s(n.NO_STATUS));
      F.setColSpan(1);
    }
    if (1 < V) {
      let [xe, ye] = b(W, F, F), { startColumn: de, startRow: me } = ye, we;
      for (te = 1; te < V; te++) {
        var ee = me + te;
        let Ee = xe[ee];
        we = (we || k).getNextSibling(), m(we) || c(125);
        var ue = null;
        for (let Be = 0; Be < de; Be++) {
          let ke = Ee[Be], at = ke.cell;
          ke.startRow === ee && (ue = at), 1 < at.__colSpan && (Be += at.__colSpan - 1);
        }
        if (ue === null) for (ue = 0; ue < B; ue++) x(we, s(n.NO_STATUS));
        else for (ee = 0; ee < B; ee++) ue.insertAfter(s(n.NO_STATUS));
      }
      F.setRowSpan(1);
    }
  }, mt.INSERT_TABLE_COMMAND = l, mt.TableCellHeaderStates = n, mt.TableCellNode = i, mt.TableNode = fe, mt.TableObserver = P, mt.TableRowNode = u, mt.applyTableHandlers = function(B, F, k, W) {
    function V(de) {
      return de = B.getCordsFromCellNode(de, ee.table), B.getDOMCellFromCordsOrThrow(de.x, de.y, ee.table);
    }
    let te = k.getRootElement();
    if (te === null) throw Error("No root element.");
    let ee = new P(k, B.getKey()), ue = k._window || window;
    F.__lexicalTableSelection = ee, F.addEventListener("mousedown", (de) => {
      setTimeout(() => {
        if (de.button === 0 && ue) {
          var me = U(de.target);
          me !== null && (ne(de), ee.setAnchorCellForSelection(me));
          var we = () => {
            ue.removeEventListener("mouseup", we), ue.removeEventListener(
              "mousemove",
              Ee
            );
          }, Ee = (Be) => {
            const ke = U(Be.target);
            ke === null || ee.anchorX === ke.x && ee.anchorY === ke.y || (Be.preventDefault(), ee.setFocusCellForSelection(ke));
          };
          ue.addEventListener("mouseup", we), ue.addEventListener("mousemove", Ee);
        }
      }, 0);
    });
    let xe = (de) => {
      de.button === 0 && k.update(() => {
        const me = e.$getSelection(), we = de.target;
        y(me) && me.tableKey === ee.tableNodeKey && te.contains(we) && ee.clearHighlight();
      });
    };
    ue.addEventListener("mousedown", xe), ee.listenersToRemove.add(() => ue.removeEventListener("mousedown", xe)), ee.listenersToRemove.add(k.registerCommand(
      e.KEY_ARROW_DOWN_COMMAND,
      (de) => Q(k, de, "down", B, ee),
      e.COMMAND_PRIORITY_HIGH
    )), ee.listenersToRemove.add(k.registerCommand(e.KEY_ARROW_UP_COMMAND, (de) => Q(k, de, "up", B, ee), e.COMMAND_PRIORITY_HIGH)), ee.listenersToRemove.add(k.registerCommand(e.KEY_ARROW_LEFT_COMMAND, (de) => Q(k, de, "backward", B, ee), e.COMMAND_PRIORITY_HIGH)), ee.listenersToRemove.add(k.registerCommand(e.KEY_ARROW_RIGHT_COMMAND, (de) => Q(k, de, "forward", B, ee), e.COMMAND_PRIORITY_HIGH)), ee.listenersToRemove.add(k.registerCommand(e.KEY_ESCAPE_COMMAND, (de) => {
      var me = e.$getSelection();
      return y(me) && (me = r.$findMatchingParent(
        me.focus.getNode(),
        a
      ), a(me)) ? (ne(de), me.selectEnd(), !0) : !1;
    }, e.COMMAND_PRIORITY_HIGH));
    let ye = (de) => () => {
      var me = e.$getSelection();
      if (!I(me, B)) return !1;
      if (y(me)) return ee.clearText(), !0;
      if (e.$isRangeSelection(me)) {
        const Be = r.$findMatchingParent(me.anchor.getNode(), (ke) => a(ke));
        if (!a(Be)) return !1;
        var we = me.anchor.getNode(), Ee = me.focus.getNode();
        if (we = B.isParentOf(we), Ee = B.isParentOf(Ee), we && !Ee || Ee && !we) return ee.clearText(), !0;
        if (we = (Ee = r.$findMatchingParent(me.anchor.getNode(), (ke) => e.$isElementNode(ke))) && r.$findMatchingParent(Ee, (ke) => e.$isElementNode(ke) && a(ke.getParent())), !e.$isElementNode(we) || !e.$isElementNode(Ee)) return !1;
        if (de === e.DELETE_LINE_COMMAND && we.getPreviousSibling() === null) return !0;
        if ((de === e.DELETE_CHARACTER_COMMAND || de === e.DELETE_WORD_COMMAND) && me.isCollapsed() && me.anchor.offset === 0 && Ee !== we) {
          me = Ee.getChildren();
          const ke = e.$createParagraphNode();
          return me.forEach((at) => ke.append(at)), Ee.replace(ke), Ee.getWritable().__parent = Be.getKey(), !0;
        }
      }
      return !1;
    };
    return [e.DELETE_WORD_COMMAND, e.DELETE_LINE_COMMAND, e.DELETE_CHARACTER_COMMAND].forEach((de) => {
      ee.listenersToRemove.add(k.registerCommand(
        de,
        ye(de),
        e.COMMAND_PRIORITY_CRITICAL
      ));
    }), F = (de) => {
      const me = e.$getSelection();
      return I(me, B) ? y(me) ? (de.preventDefault(), de.stopPropagation(), ee.clearText(), !0) : (e.$isRangeSelection(me) && (de = r.$findMatchingParent(me.anchor.getNode(), (we) => a(we)), a(de)), !1) : !1;
    }, ee.listenersToRemove.add(k.registerCommand(e.KEY_BACKSPACE_COMMAND, F, e.COMMAND_PRIORITY_CRITICAL)), ee.listenersToRemove.add(k.registerCommand(e.KEY_DELETE_COMMAND, F, e.COMMAND_PRIORITY_CRITICAL)), ee.listenersToRemove.add(k.registerCommand(
      e.FORMAT_TEXT_COMMAND,
      (de) => {
        let me = e.$getSelection();
        return I(me, B) ? y(me) ? (ee.formatCells(de), !0) : (e.$isRangeSelection(me) && (de = r.$findMatchingParent(me.anchor.getNode(), (we) => a(we)), a(de)), !1) : !1;
      },
      e.COMMAND_PRIORITY_CRITICAL
    )), ee.listenersToRemove.add(k.registerCommand(e.CONTROLLED_TEXT_INSERTION_COMMAND, () => {
      var de = e.$getSelection();
      return I(de, B) && (y(de) ? ee.clearHighlight() : e.$isRangeSelection(de) && (de = r.$findMatchingParent(de.anchor.getNode(), (me) => a(me)), a(de))), !1;
    }, e.COMMAND_PRIORITY_CRITICAL)), W && ee.listenersToRemove.add(k.registerCommand(
      e.KEY_TAB_COMMAND,
      (de) => {
        var me = e.$getSelection();
        return !e.$isRangeSelection(me) || !me.isCollapsed() || !I(me, B) || (me = z(me.anchor.getNode()), me === null) ? !1 : (ne(de), me = B.getCordsFromCellNode(me, ee.table), G(ee, B, me.x, me.y, de.shiftKey ? "backward" : "forward"), !0);
      },
      e.COMMAND_PRIORITY_CRITICAL
    )), ee.listenersToRemove.add(k.registerCommand(e.FOCUS_COMMAND, () => B.isSelected(), e.COMMAND_PRIORITY_HIGH)), ee.listenersToRemove.add(k.registerCommand(e.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, (de) => {
      let { nodes: me, selection: we } = de;
      de = we.getStartEndPoints();
      var Ee = y(we);
      if (Ee = e.$isRangeSelection(we) && r.$findMatchingParent(we.anchor.getNode(), (ve) => a(ve)) !== null && r.$findMatchingParent(we.focus.getNode(), (ve) => a(ve)) !== null || Ee, me.length !== 1 || !Ne(me[0]) || !Ee || de === null) return !1;
      var [Be] = de, ke = me[0];
      de = ke.getChildren(), Ee = ke.getFirstChildOrThrow().getChildrenSize(), ke = ke.getChildrenSize();
      var at = r.$findMatchingParent(Be.getNode(), (ve) => a(ve)), Pt = (Be = at && r.$findMatchingParent(at, (ve) => m(ve))) && r.$findMatchingParent(Be, (ve) => Ne(ve));
      if (!a(at) || !m(Be) || !Ne(Pt)) return !1;
      var Ct = Be.getIndexWithinParent(), Je = Math.min(Pt.getChildrenSize() - 1, Ct + ke - 1);
      ke = at.getIndexWithinParent(), at = Math.min(Be.getChildrenSize() - 1, ke + Ee - 1), Ee = Math.min(ke, at), Be = Math.min(Ct, Je), ke = Math.max(ke, at), Ct = Math.max(Ct, Je), Pt = Pt.getChildren(), Je = 0;
      let le, Z;
      for (at = Be; at <= Ct; at++) {
        var re = Pt[at];
        if (!m(re)) return !1;
        var ce = de[Je];
        if (!m(ce)) return !1;
        re = re.getChildren(), ce = ce.getChildren();
        let ve = 0;
        for (let he = Ee; he <= ke; he++) {
          let Te = re[he];
          if (!a(Te)) return !1;
          let De = ce[ve];
          if (!a(De)) return !1;
          at === Be && he === Ee ? le = Te.getKey() : at === Ct && he === ke && (Z = Te.getKey());
          let Pe = Te.getChildren();
          De.getChildren().forEach((Ae) => {
            e.$isTextNode(Ae) && e.$createParagraphNode().append(Ae), Te.append(Ae);
          }), Pe.forEach((Ae) => Ae.remove()), ve++;
        }
        Je++;
      }
      return le && Z && (de = E(), de.set(me[0].getKey(), le, Z), e.$setSelection(de)), !0;
    }, e.COMMAND_PRIORITY_CRITICAL)), ee.listenersToRemove.add(k.registerCommand(e.SELECTION_CHANGE_COMMAND, () => {
      let de = e.$getSelection(), me = e.$getPreviousSelection();
      if (e.$isRangeSelection(de)) {
        let { anchor: at, focus: Pt } = de;
        var we = at.getNode(), Ee = Pt.getNode();
        we = z(we), Ee = z(Ee);
        var Be = we && B.is(X(we)), ke = Ee && B.is(X(Ee));
        let Ct = Be !== ke;
        ke = Be && ke, Be = de.isBackward(), Ct ? (we = de.clone(), we.focus.set(
          B.getKey(),
          Be ? 0 : B.getChildrenSize(),
          "element"
        ), e.$setSelection(we), T(k, ee)) : ke && !we.is(Ee) && (ee.setAnchorCellForSelection(V(we)), ee.setFocusCellForSelection(V(Ee), !0));
      }
      return de && !de.is(me) && (y(de) || y(me)) && ee.tableSelection && !ee.tableSelection.is(me) ? (y(de) && de.tableKey === ee.tableNodeKey ? ee.updateTableTableSelection(de) : !y(de) && y(me) && me.tableKey === ee.tableNodeKey && ee.updateTableTableSelection(null), !1) : (ee.hasHijackedSelectionStyles && !B.isSelected() ? $(k, ee) : !ee.hasHijackedSelectionStyles && B.isSelected() && T(k, ee), !1);
    }, e.COMMAND_PRIORITY_CRITICAL)), ee;
  }, mt.getDOMCellFromTarget = U, mt.getTableObserverFromTableElement = function(B) {
    return B.__lexicalTableSelection;
  }, mt;
}
const Hf = process.env.NODE_ENV === "development" ? Bf() : zf();
var Ge = Hf, Ot = lt(), jf = Ai(), ut = it();
function qf({ nodeKey: r }) {
  const [e] = Ot.useLexicalComposerContext(), [t, n, i] = jf.useLexicalNodeSelection(r), o = ct(
    (s) => {
      if (s.preventDefault(), t && cs(Nt())) {
        const a = us(r);
        if (Uf(a))
          return a.remove(), !0;
      }
      return !1;
    },
    [t, r]
  );
  return We(() => ut.mergeRegister(
    e.registerCommand(
      Cu,
      (s) => {
        const a = e.getElementByKey(r);
        return s.target === a ? (s.shiftKey || i(), n(!t), !0) : !1;
      },
      qt
    ),
    e.registerCommand(
      Rh,
      o,
      qt
    ),
    e.registerCommand(
      Ah,
      o,
      qt
    )
  ), [i, e, t, r, o, n]), We(() => {
    const s = e.getElementByKey(r);
    s !== null && (s.className = t ? "selected" : "");
  }, [e, t, r]), null;
}
class Xn extends mn {
  static getType() {
    return "page-break";
  }
  static clone(e) {
    return new Xn(e.__key);
  }
  static importJSON() {
    return vs();
  }
  static importDOM() {
    return {
      figure: (e) => e.getAttribute("type") !== this.getType() ? null : {
        conversion: Kf,
        priority: cn
      }
    };
  }
  exportJSON() {
    return {
      type: this.getType(),
      version: 1
    };
  }
  createDOM() {
    const e = document.createElement("figure");
    return e.style.pageBreakAfter = "always", e.setAttribute("type", this.getType()), e;
  }
  getTextContent() {
    return `
`;
  }
  isInline() {
    return !1;
  }
  updateDOM() {
    return !1;
  }
  decorate() {
    return /* @__PURE__ */ L.jsx(qf, { nodeKey: this.__key });
  }
}
function Kf() {
  return { node: vs() };
}
function vs() {
  return new Xn();
}
function Uf(r) {
  return r instanceof Xn;
}
class ki extends ds {
  constructor(t, n, i) {
    super(n, i);
    Ye(this, "__className");
    this.__className = t;
  }
  static getType() {
    return "emoji";
  }
  static clone(t) {
    return new ki(t.__className, t.__text, t.__key);
  }
  createDOM(t) {
    const n = document.createElement("span"), i = super.createDOM(t);
    return n.className = this.__className, i.className = "emoji-inner", n.appendChild(i), n;
  }
  updateDOM(t, n, i) {
    const o = n.firstChild;
    return o === null ? !0 : (super.updateDOM(t, o, i), !1);
  }
  static importJSON(t) {
    const n = Gu(
      t.className,
      t.text
    );
    return n.setFormat(t.format), n.setDetail(t.detail), n.setMode(t.mode), n.setStyle(t.style), n;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      className: this.getClassName(),
      type: "emoji"
    };
  }
  getClassName() {
    return this.getLatest().__className;
  }
}
function Gu(r, e) {
  const t = new ki(r, e).setMode("token");
  return Oi(t);
}
const Yf = hr.lazy(() => import("./ImageComponent-DEco1xBo.js"));
function Wf(r) {
  const e = r;
  if (e.src.startsWith("file:///"))
    return null;
  const { alt: t, src: n, width: i, height: o } = e;
  return { node: xs({ altText: t, height: o, src: n, width: i }) };
}
class Jn extends mn {
  constructor(t, n, i, o, s, a, l, u, d, p, m, c) {
    super(d);
    Ye(this, "__src");
    Ye(this, "__altText");
    Ye(this, "__width");
    Ye(this, "__height");
    Ye(this, "__maxWidth");
    Ye(this, "__showCaption");
    Ye(this, "__caption");
    // Captions cannot yet be used within editor cells
    Ye(this, "__captionsEnabled");
    Ye(this, "__isAbsolute");
    Ye(this, "__x");
    Ye(this, "__y");
    this.__src = t, this.__altText = n, this.__maxWidth = i, this.__width = o || "inherit", this.__height = s || "inherit", this.__showCaption = a || !1, this.__caption = l || To(), this.__captionsEnabled = u || u === void 0, this.__isAbsolute = p || !1, this.__x = m || 0, this.__y = c || 0;
  }
  static getType() {
    return "image";
  }
  static clone(t) {
    return new Jn(
      t.__src,
      t.__altText,
      t.__maxWidth,
      t.__width,
      t.__height,
      t.__showCaption,
      t.__caption,
      t.__captionsEnabled,
      t.__key,
      t.__isAbsolute,
      t.__x,
      t.__y
    );
  }
  static importJSON(t) {
    const {
      altText: n,
      height: i,
      width: o,
      maxWidth: s,
      caption: a,
      src: l,
      showCaption: u,
      isAbsolute: d,
      xOffset: p,
      yOffset: m
    } = t, c = xs({
      altText: n,
      height: i,
      maxWidth: s,
      showCaption: u,
      src: l,
      width: o,
      isAbsolute: d,
      xOffset: p,
      yOffset: m
    }), h = c.__caption, f = h.parseEditorState(a.editorState);
    return f.isEmpty() || h.setEditorState(f), c;
  }
  exportDOM() {
    const t = document.createElement("img");
    return t.setAttribute("src", this.__src), t.setAttribute("alt", this.__altText), t.setAttribute("width", this.__width.toString()), t.setAttribute("height", this.__height.toString()), { element: t };
  }
  static importDOM() {
    return {
      img: () => ({
        conversion: Wf,
        priority: 0
      })
    };
  }
  exportJSON() {
    return {
      altText: this.getAltText(),
      caption: this.__caption.toJSON(),
      height: this.__height === "inherit" ? 0 : this.__height,
      maxWidth: this.__maxWidth,
      showCaption: this.__showCaption,
      src: this.getSrc(),
      type: "image",
      version: 1,
      width: this.__width === "inherit" ? 0 : this.__width,
      isAbsolute: this.__isAbsolute,
      xOffset: this.__x,
      yOffset: this.__y
    };
  }
  setWidthAndHeight(t, n) {
    const i = this.getWritable();
    i.__width = t, i.__height = n;
  }
  setShowCaption(t) {
    const n = this.getWritable();
    n.__showCaption = t;
  }
  setAbsolute(t) {
    const n = this.getWritable();
    n.__isAbsolute = t;
  }
  setPosition(t, n) {
    const i = this.getWritable();
    i.__x = t, i.__y = n, Wn(null);
  }
  // View
  createDOM(t) {
    const n = document.createElement("span"), o = t.theme.image;
    return o !== void 0 && (n.className = o), n;
  }
  updateDOM() {
    return !1;
  }
  getSrc() {
    return this.__src;
  }
  getAltText() {
    return this.__altText;
  }
  decorate() {
    return /* @__PURE__ */ L.jsx(An, { fallback: null, children: /* @__PURE__ */ L.jsx(
      Yf,
      {
        src: this.__src,
        altText: this.__altText,
        width: this.__width,
        height: this.__height,
        maxWidth: this.__maxWidth,
        nodeKey: this.getKey(),
        showCaption: this.__showCaption,
        caption: this.__caption,
        captionsEnabled: this.__captionsEnabled,
        resizable: !0,
        isAbsolute: this.__isAbsolute,
        xOffset: this.__x,
        yOffset: this.__y
      }
    ) });
  }
}
function xs({
  altText: r,
  height: e,
  maxWidth: t = 500,
  captionsEnabled: n,
  src: i,
  width: o,
  showCaption: s,
  caption: a,
  key: l,
  xOffset: u,
  yOffset: d,
  isAbsolute: p
}) {
  return Oi(
    new Jn(
      i,
      r,
      t,
      o,
      e,
      s,
      a,
      n,
      l,
      p,
      u,
      d
    )
  );
}
function Gf(r) {
  return r instanceof Jn;
}
class qn extends ds {
  static getType() {
    return "keyword";
  }
  static clone(e) {
    return new qn(e.__text, e.__key);
  }
  static importJSON(e) {
    const t = Vu(e.text);
    return t.setFormat(e.format), t.setDetail(e.detail), t.setMode(e.mode), t.setStyle(e.style), t;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "keyword",
      version: 1
    };
  }
  createDOM(e) {
    const t = super.createDOM(e);
    return t.style.cursor = "default", t.className = "keyword", t;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
  isTextEntity() {
    return !0;
  }
}
function Vu(r) {
  return new qn(r);
}
var Wo = {}, Ki = {}, N0;
function Vf() {
  if (N0) return Ki;
  N0 = 1;
  var r = Ve;
  class e extends r.DecoratorNode {
    constructor(i, o) {
      super(o), this.__format = i || "";
    }
    exportJSON() {
      return {
        format: this.__format || "",
        type: "decorator-block",
        version: 1
      };
    }
    createDOM() {
      return document.createElement("div");
    }
    updateDOM() {
      return !1;
    }
    setFormat(i) {
      const o = this.getWritable();
      o.__format = i;
    }
    isInline() {
      return !1;
    }
  }
  function t(n) {
    return n instanceof e;
  }
  return Ki.$isDecoratorBlockNode = t, Ki.DecoratorBlockNode = e, Ki;
}
var Ui = {}, _0;
function Xf() {
  if (_0) return Ui;
  _0 = 1;
  var r = Ve;
  class e extends r.DecoratorNode {
    constructor(n, i) {
      super(i), this.__format = n || "";
    }
    exportJSON() {
      return { format: this.__format || "", type: "decorator-block", version: 1 };
    }
    createDOM() {
      return document.createElement("div");
    }
    updateDOM() {
      return !1;
    }
    setFormat(n) {
      this.getWritable().__format = n;
    }
    isInline() {
      return !1;
    }
  }
  return Ui.$isDecoratorBlockNode = function(t) {
    return t instanceof e;
  }, Ui.DecoratorBlockNode = e, Ui;
}
const Jf = process.env.NODE_ENV === "development" ? Vf() : Xf();
var Zn = Jf, C0;
function Zf() {
  if (C0) return Wo;
  C0 = 1;
  var r = lt(), e = Zn, t = Ai(), n = it(), i = Ve, o = nt;
  function s({
    children: a,
    format: l,
    nodeKey: u,
    className: d
  }) {
    const [p] = r.useLexicalComposerContext(), [m, c, h] = t.useLexicalNodeSelection(u), f = o.useRef(null), N = o.useCallback((v) => {
      if (m && i.$isNodeSelection(i.$getSelection())) {
        v.preventDefault();
        const C = i.$getNodeByKey(u);
        i.$isDecoratorNode(C) && C.remove();
      }
      return !1;
    }, [m, u]);
    return o.useEffect(() => n.mergeRegister(p.registerCommand(i.FORMAT_ELEMENT_COMMAND, (v) => {
      if (m) {
        const C = i.$getSelection();
        if (i.$isNodeSelection(C)) {
          const g = i.$getNodeByKey(u);
          e.$isDecoratorBlockNode(g) && g.setFormat(v);
        } else if (i.$isRangeSelection(C)) {
          const g = C.getNodes();
          for (const x of g)
            e.$isDecoratorBlockNode(x) ? x.setFormat(v) : n.$getNearestBlockElementAncestorOrThrow(x).setFormat(v);
        }
        return !0;
      }
      return !1;
    }, i.COMMAND_PRIORITY_LOW), p.registerCommand(i.CLICK_COMMAND, (v) => v.target === f.current ? (v.preventDefault(), v.shiftKey || h(), c(!m), !0) : !1, i.COMMAND_PRIORITY_LOW), p.registerCommand(i.KEY_DELETE_COMMAND, N, i.COMMAND_PRIORITY_LOW), p.registerCommand(i.KEY_BACKSPACE_COMMAND, N, i.COMMAND_PRIORITY_LOW)), [h, p, m, u, N, c]), /* @__PURE__ */ o.createElement("div", {
      className: [d.base, m ? d.focus : null].filter(Boolean).join(" "),
      ref: f,
      style: {
        textAlign: l || void 0
      }
    }, a);
  }
  return Wo.BlockWithAlignableContents = s, Wo;
}
var Go = {}, b0;
function Qf() {
  if (b0) return Go;
  b0 = 1;
  var r = lt(), e = Zn, t = Ai(), n = it(), i = Ve, o = nt;
  return Go.BlockWithAlignableContents = function({ children: s, format: a, nodeKey: l, className: u }) {
    let [d] = r.useLexicalComposerContext(), [p, m, c] = t.useLexicalNodeSelection(l), h = o.useRef(null), f = o.useCallback((N) => (p && i.$isNodeSelection(i.$getSelection()) && (N.preventDefault(), N = i.$getNodeByKey(l), i.$isDecoratorNode(N) && N.remove()), !1), [p, l]);
    return o.useEffect(() => n.mergeRegister(d.registerCommand(i.FORMAT_ELEMENT_COMMAND, (N) => {
      if (p) {
        var v = i.$getSelection();
        if (i.$isNodeSelection(v)) {
          var C = i.$getNodeByKey(l);
          e.$isDecoratorBlockNode(C) && C.setFormat(N);
        } else if (i.$isRangeSelection(v)) {
          v = v.getNodes();
          for (C of v) e.$isDecoratorBlockNode(C) ? C.setFormat(N) : n.$getNearestBlockElementAncestorOrThrow(C).setFormat(N);
        }
        return !0;
      }
      return !1;
    }, i.COMMAND_PRIORITY_LOW), d.registerCommand(i.CLICK_COMMAND, (N) => N.target === h.current ? (N.preventDefault(), N.shiftKey || c(), m(!p), !0) : !1, i.COMMAND_PRIORITY_LOW), d.registerCommand(i.KEY_DELETE_COMMAND, f, i.COMMAND_PRIORITY_LOW), d.registerCommand(i.KEY_BACKSPACE_COMMAND, f, i.COMMAND_PRIORITY_LOW)), [c, d, p, l, f, m]), o.createElement(
      "div",
      { className: [u.base, p ? u.focus : null].filter(Boolean).join(" "), ref: h, style: { textAlign: a || void 0 } },
      s
    );
  }, Go;
}
const em = process.env.NODE_ENV === "development" ? Zf() : Qf();
var Ns = em;
function tm({
  className: r,
  format: e,
  nodeKey: t,
  documentID: n
}) {
  return /* @__PURE__ */ L.jsx(
    Ns.BlockWithAlignableContents,
    {
      className: r,
      format: e,
      nodeKey: t,
      children: /* @__PURE__ */ L.jsx(
        "iframe",
        {
          width: "560",
          height: "315",
          src: `https://www.figma.com/embed?embed_host=lexical&url=        https://www.figma.com/file/${n}`,
          allowFullScreen: !0
        }
      )
    }
  );
}
class Di extends Zn.DecoratorBlockNode {
  constructor(t, n, i) {
    super(n, i);
    Ye(this, "__id");
    this.__id = t;
  }
  static getType() {
    return "figma";
  }
  static clone(t) {
    return new Di(t.__id, t.__format, t.__key);
  }
  static importJSON(t) {
    const n = Xu(t.documentID);
    return n.setFormat(t.format), n;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      documentID: this.__id,
      type: "figma",
      version: 1
    };
  }
  updateDOM() {
    return !1;
  }
  getId() {
    return this.__id;
  }
  getTextContent() {
    return `https://www.figma.com/file/${this.__id}`;
  }
  decorate(t, n) {
    const i = n.theme.embedBlock || {}, o = {
      base: i.base || "",
      focus: i.focus || ""
    };
    return /* @__PURE__ */ L.jsx(
      tm,
      {
        className: o,
        format: this.__format,
        nodeKey: this.getKey(),
        documentID: this.__id
      }
    );
  }
}
function Xu(r) {
  return new Di(r);
}
const rm = "https://platform.twitter.com/widgets.js";
function nm(r) {
  const e = r.getAttribute("data-lexical-tweet-id");
  return e ? { node: _s(e) } : null;
}
let y0 = !0;
function im({
  className: r,
  format: e,
  loadingComponent: t,
  nodeKey: n,
  onError: i,
  onLoad: o,
  tweetID: s
}) {
  const a = Rt(null), l = Rt(""), [u, d] = Ie(!1), p = ct(async () => {
    try {
      await window.twttr.widgets.createTweet(s, a.current), d(!1), y0 = !1, o && o();
    } catch (m) {
      i && i(String(m));
    }
  }, [i, o, s]);
  return We(() => {
    var m;
    if (s !== l.current) {
      if (d(!0), y0) {
        const c = document.createElement("script");
        c.src = rm, c.async = !0, (m = document.body) == null || m.appendChild(c), c.onload = p, i && (c.onerror = i);
      } else
        p();
      l && (l.current = s);
    }
  }, [p, i, s]), /* @__PURE__ */ L.jsxs(
    Ns.BlockWithAlignableContents,
    {
      className: r,
      format: e,
      nodeKey: n,
      children: [
        u ? t : null,
        /* @__PURE__ */ L.jsx(
          "div",
          {
            style: { display: "inline-block", width: "550px" },
            ref: a
          }
        )
      ]
    }
  );
}
class $i extends Zn.DecoratorBlockNode {
  constructor(t, n, i) {
    super(n, i);
    Ye(this, "__id");
    this.__id = t;
  }
  static getType() {
    return "tweet";
  }
  static clone(t) {
    return new $i(t.__id, t.__format, t.__key);
  }
  static importJSON(t) {
    const n = _s(t.id);
    return n.setFormat(t.format), n;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      id: this.getId(),
      type: "tweet",
      version: 1
    };
  }
  static importDOM() {
    return {
      div: (t) => t.hasAttribute("data-lexical-tweet-id") ? {
        conversion: nm,
        priority: 2
      } : null
    };
  }
  exportDOM() {
    const t = document.createElement("div");
    t.setAttribute("data-lexical-tweet-id", this.__id);
    const n = document.createTextNode(this.getTextContent());
    return t.append(n), { element: t };
  }
  getId() {
    return this.__id;
  }
  getTextContent(t, n) {
    return `https://x.com/i/web/status/${this.__id}`;
  }
  decorate(t, n) {
    const i = n.theme.embedBlock || {}, o = {
      base: i.base || "",
      focus: i.focus || ""
    };
    return /* @__PURE__ */ L.jsx(
      im,
      {
        className: o,
        format: this.__format,
        loadingComponent: "Loading...",
        nodeKey: this.getKey(),
        tweetID: this.__id
      }
    );
  }
}
function _s(r) {
  return new $i(r);
}
function om({
  className: r,
  format: e,
  nodeKey: t,
  videoID: n
}) {
  return /* @__PURE__ */ L.jsx(
    Ns.BlockWithAlignableContents,
    {
      className: r,
      format: e,
      nodeKey: t,
      children: /* @__PURE__ */ L.jsx(
        "iframe",
        {
          width: "560",
          height: "315",
          src: `https://www.youtube-nocookie.com/embed/${n}`,
          frameBorder: "0",
          allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",
          allowFullScreen: !0,
          title: "YouTube video"
        }
      )
    }
  );
}
function am(r) {
  const e = r.getAttribute("data-lexical-youtube");
  return e ? { node: Cs(e) } : null;
}
class Ii extends Zn.DecoratorBlockNode {
  constructor(t, n, i) {
    super(n, i);
    Ye(this, "__id");
    this.__id = t;
  }
  static getType() {
    return "youtube";
  }
  static clone(t) {
    return new Ii(t.__id, t.__format, t.__key);
  }
  static importJSON(t) {
    const n = Cs(t.videoID);
    return n.setFormat(t.format), n;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "youtube",
      version: 1,
      videoID: this.__id
    };
  }
  exportDOM() {
    const t = document.createElement("iframe");
    return t.setAttribute("data-lexical-youtube", this.__id), t.setAttribute("width", "560"), t.setAttribute("height", "315"), t.setAttribute(
      "src",
      `https://www.youtube-nocookie.com/embed/${this.__id}`
    ), t.setAttribute("frameborder", "0"), t.setAttribute(
      "allow",
      "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    ), t.setAttribute("allowfullscreen", "true"), t.setAttribute("title", "YouTube video"), { element: t };
  }
  static importDOM() {
    return {
      iframe: (t) => t.hasAttribute("data-lexical-youtube") ? {
        conversion: am,
        priority: 1
      } : null
    };
  }
  updateDOM() {
    return !1;
  }
  getId() {
    return this.__id;
  }
  getTextContent(t, n) {
    return `https://www.youtube.com/watch?v=${this.__id}`;
  }
  decorate(t, n) {
    const i = n.theme.embedBlock || {}, o = {
      base: i.base || "",
      focus: i.focus || ""
    };
    return /* @__PURE__ */ L.jsx(
      om,
      {
        className: o,
        format: this.__format,
        nodeKey: this.getKey(),
        videoID: this.__id
      }
    );
  }
}
function Cs(r) {
  return new Ii(r);
}
function sm(r) {
  const e = r.open !== void 0 ? r.open : !0;
  return {
    node: bs(e)
  };
}
class wn extends Mi {
  constructor(t, n) {
    super(n);
    Ye(this, "__open");
    this.__open = t;
  }
  static getType() {
    return "collapsible-container";
  }
  static clone(t) {
    return new wn(t.__open, t.__key);
  }
  createDOM(t, n) {
    const i = document.createElement("details");
    return i.classList.add("Collapsible__container"), i.open = this.__open, i.addEventListener("toggle", () => {
      n.getEditorState().read(() => this.getOpen()) !== i.open && n.update(() => this.toggleOpen());
    }), i;
  }
  updateDOM(t, n) {
    return t.__open !== this.__open && (n.open = this.__open), !1;
  }
  static importDOM() {
    return {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      details: (t) => ({
        conversion: sm,
        priority: 1
      })
    };
  }
  static importJSON(t) {
    return bs(t.open);
  }
  exportDOM() {
    const t = document.createElement("details");
    return t.setAttribute("open", this.__open.toString()), { element: t };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      open: this.__open,
      type: "collapsible-container",
      version: 1
    };
  }
  setOpen(t) {
    const n = this.getWritable();
    n.__open = t;
  }
  getOpen() {
    return this.getLatest().__open;
  }
  toggleOpen() {
    this.setOpen(!this.getOpen());
  }
}
function bs(r) {
  return new wn(r);
}
function Ur(r) {
  return r instanceof wn;
}
function lm(r) {
  return {
    node: ys()
  };
}
class Tn extends Mi {
  static getType() {
    return "collapsible-content";
  }
  static clone(e) {
    return new Tn(e.__key);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createDOM(e) {
    const t = document.createElement("div");
    return t.classList.add("Collapsible__content"), t;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  updateDOM(e, t) {
    return !1;
  }
  static importDOM() {
    return {
      div: (e) => e.hasAttribute("data-lexical-collapsible-content") ? {
        conversion: lm,
        priority: 2
      } : null
    };
  }
  exportDOM() {
    const e = document.createElement("div");
    return e.setAttribute("data-lexical-collapsible-content", "true"), { element: e };
  }
  static importJSON(e) {
    return ys();
  }
  isShadowRoot() {
    return !0;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "collapsible-content",
      version: 1
    };
  }
}
function ys() {
  return new Tn();
}
function Ju(r) {
  return r instanceof Tn;
}
function cm(r) {
  return {
    node: ws()
  };
}
class En extends Mi {
  static getType() {
    return "collapsible-title";
  }
  static clone(e) {
    return new En(e.__key);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createDOM(e, t) {
    const n = document.createElement("summary");
    return n.classList.add("Collapsible__title"), n;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  updateDOM(e, t) {
    return !1;
  }
  static importDOM() {
    return {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      summary: (e) => ({
        conversion: cm,
        priority: 1
      })
    };
  }
  static importJSON(e) {
    return ws();
  }
  exportDOM() {
    return { element: document.createElement("summary") };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "collapsible-title",
      version: 1
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  collapseAtStart(e) {
    return this.getParentOrThrow().insertBefore(this), !0;
  }
  insertNewAfter(e, t = !0) {
    const n = this.getParentOrThrow();
    if (!Ur(n))
      throw new Error(
        "CollapsibleTitleNode expects to be child of CollapsibleContainerNode"
      );
    if (n.getOpen()) {
      const i = this.getNextSibling();
      if (!Ju(i))
        throw new Error(
          "CollapsibleTitleNode expects to have CollapsibleContentNode sibling"
        );
      const o = i.getFirstChild();
      if (yn(o))
        return o;
      {
        const s = Gt();
        return i.append(s), s;
      }
    } else {
      const i = Gt();
      return n.insertAfter(i, t), i;
    }
  }
}
function ws() {
  return new En();
}
function w0(r) {
  return r instanceof En;
}
class pr {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(e, t, n) {
    this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = e, this.start = t, this.end = n;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(e, t) {
    return t ? !e || !e.loc || !t.loc || e.loc.lexer !== t.loc.lexer ? null : new pr(e.loc.lexer, e.loc.start, t.loc.end) : e && e.loc;
  }
}
class Cr {
  // don't expand the token
  // used in \noexpand
  constructor(e, t) {
    this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = e, this.loc = t;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(e, t) {
    return new Cr(t, pr.range(this, e));
  }
}
class Re {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(e, t) {
    this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
    var n = "KaTeX parse error: " + e, i, o, s = t && t.loc;
    if (s && s.start <= s.end) {
      var a = s.lexer.input;
      i = s.start, o = s.end, i === a.length ? n += " at end of input: " : n += " at position " + (i + 1) + ": ";
      var l = a.slice(i, o).replace(/[^]/g, "$&Ì²"), u;
      i > 15 ? u = "â€¦" + a.slice(i - 15, i) : u = a.slice(0, i);
      var d;
      o + 15 < a.length ? d = a.slice(o, o + 15) + "â€¦" : d = a.slice(o), n += u + l + d;
    }
    var p = new Error(n);
    return p.name = "ParseError", p.__proto__ = Re.prototype, p.position = i, i != null && o != null && (p.length = o - i), p.rawMessage = e, p;
  }
}
Re.prototype.__proto__ = Error.prototype;
var um = function(e, t) {
  return e.indexOf(t) !== -1;
}, dm = function(e, t) {
  return e === void 0 ? t : e;
}, hm = /([A-Z])/g, fm = function(e) {
  return e.replace(hm, "-$1").toLowerCase();
}, mm = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
}, gm = /[&><"']/g;
function pm(r) {
  return String(r).replace(gm, (e) => mm[e]);
}
var Zu = function r(e) {
  return e.type === "ordgroup" || e.type === "color" ? e.body.length === 1 ? r(e.body[0]) : e : e.type === "font" ? r(e.body) : e;
}, vm = function(e) {
  var t = Zu(e);
  return t.type === "mathord" || t.type === "textord" || t.type === "atom";
}, xm = function(e) {
  if (!e)
    throw new Error("Expected non-null, but got " + String(e));
  return e;
}, Nm = function(e) {
  var t = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(e);
  return t ? t[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(t[1]) ? null : t[1].toLowerCase() : "_relative";
}, Xe = {
  contains: um,
  deflt: dm,
  escape: pm,
  hyphenate: fm,
  getBaseElem: Zu,
  isCharacterBox: vm,
  protocolFromUrl: Nm
}, fo = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: !0,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (r) => "#" + r
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (r, e) => (e.push(r), e)
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (r) => Math.max(0, r),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: !1
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: 1 / 0,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (r) => Math.max(0, r),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (r) => Math.max(0, r),
    cli: "-e, --max-expand <n>",
    cliProcessor: (r) => r === "Infinity" ? 1 / 0 : parseInt(r)
  },
  globalGroup: {
    type: "boolean",
    cli: !1
  }
};
function _m(r) {
  if (r.default)
    return r.default;
  var e = r.type, t = Array.isArray(e) ? e[0] : e;
  if (typeof t != "string")
    return t.enum[0];
  switch (t) {
    case "boolean":
      return !1;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
class Ts {
  constructor(e) {
    this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, e = e || {};
    for (var t in fo)
      if (fo.hasOwnProperty(t)) {
        var n = fo[t];
        this[t] = e[t] !== void 0 ? n.processor ? n.processor(e[t]) : e[t] : _m(n);
      }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(e, t, n) {
    var i = this.strict;
    if (typeof i == "function" && (i = i(e, t, n)), !(!i || i === "ignore")) {
      if (i === !0 || i === "error")
        throw new Re("LaTeX-incompatible input and strict mode is set to 'error': " + (t + " [" + e + "]"), n);
      i === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (t + " [" + e + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + t + " [" + e + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(e, t, n) {
    var i = this.strict;
    if (typeof i == "function")
      try {
        i = i(e, t, n);
      } catch {
        i = "error";
      }
    return !i || i === "ignore" ? !1 : i === !0 || i === "error" ? !0 : i === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (t + " [" + e + "]")), !1) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + t + " [" + e + "]")), !1);
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(e) {
    if (e.url && !e.protocol) {
      var t = Xe.protocolFromUrl(e.url);
      if (t == null)
        return !1;
      e.protocol = t;
    }
    var n = typeof this.trust == "function" ? this.trust(e) : this.trust;
    return !!n;
  }
}
class on {
  constructor(e, t, n) {
    this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = e, this.size = t, this.cramped = n;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return Dr[Cm[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return Dr[bm[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return Dr[ym[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return Dr[wm[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return Dr[Tm[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return Dr[Em[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
}
var Es = 0, xo = 1, Hn = 2, Wr = 3, Ti = 4, _r = 5, Kn = 6, lr = 7, Dr = [new on(Es, 0, !1), new on(xo, 0, !0), new on(Hn, 1, !1), new on(Wr, 1, !0), new on(Ti, 2, !1), new on(_r, 2, !0), new on(Kn, 3, !1), new on(lr, 3, !0)], Cm = [Ti, _r, Ti, _r, Kn, lr, Kn, lr], bm = [_r, _r, _r, _r, lr, lr, lr, lr], ym = [Hn, Wr, Ti, _r, Kn, lr, Kn, lr], wm = [Wr, Wr, _r, _r, lr, lr, lr, lr], Tm = [xo, xo, Wr, Wr, _r, _r, lr, lr], Em = [Es, xo, Hn, Wr, Hn, Wr, Hn, Wr], et = {
  DISPLAY: Dr[Es],
  TEXT: Dr[Hn],
  SCRIPT: Dr[Ti],
  SCRIPTSCRIPT: Dr[Kn]
}, Ga = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900â€“097F)
  // Bengali (0980â€“09FF)
  // Gurmukhi (0A00â€“0A7F)
  // Gujarati (0A80â€“0AFF)
  // Oriya (0B00â€“0B7F)
  // Tamil (0B80â€“0BFF)
  // Telugu (0C00â€“0C7F)
  // Kannada (0C80â€“0CFF)
  // Malayalam (0D00â€“0D7F)
  // Sinhala (0D80â€“0DFF)
  // Thai (0E00â€“0E7F)
  // Lao (0E80â€“0EFF)
  // Tibetan (0F00â€“0FFF)
  // Myanmar (1000â€“109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function Sm(r) {
  for (var e = 0; e < Ga.length; e++)
    for (var t = Ga[e], n = 0; n < t.blocks.length; n++) {
      var i = t.blocks[n];
      if (r >= i[0] && r <= i[1])
        return t.name;
    }
  return null;
}
var mo = [];
Ga.forEach((r) => r.blocks.forEach((e) => mo.push(...e)));
function Qu(r) {
  for (var e = 0; e < mo.length; e += 2)
    if (r >= mo[e] && r <= mo[e + 1])
      return !0;
  return !1;
}
var Pn = 80, Om = function(e, t) {
  return "M95," + (622 + e + t) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + e / 2.075 + " -" + e + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + e) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, Mm = function(e, t) {
  return "M263," + (601 + e + t) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + e / 2.084 + " -" + e + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + e) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, Rm = function(e, t) {
  return "M983 " + (10 + e + t) + `
l` + e / 3.13 + " -" + e + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + e) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, Am = function(e, t) {
  return "M424," + (2398 + e + t) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + e / 4.223 + " -" + e + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + e) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + e) + " " + t + `
h400000v` + (40 + e) + "h-400000z";
}, Lm = function(e, t) {
  return "M473," + (2713 + e + t) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + e / 5.298 + " -" + e + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + e) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "H1017.7z";
}, km = function(e) {
  var t = e / 2;
  return "M400000 " + e + " H0 L" + t + " 0 l65 45 L145 " + (e - 80) + " H400000z";
}, Dm = function(e, t, n) {
  var i = n - 54 - t - e;
  return "M702 " + (e + t) + "H400000" + (40 + e) + `
H742v` + i + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + t + "H400000v" + (40 + e) + "H742z";
}, $m = function(e, t, n) {
  t = 1e3 * t;
  var i = "";
  switch (e) {
    case "sqrtMain":
      i = Om(t, Pn);
      break;
    case "sqrtSize1":
      i = Mm(t, Pn);
      break;
    case "sqrtSize2":
      i = Rm(t, Pn);
      break;
    case "sqrtSize3":
      i = Am(t, Pn);
      break;
    case "sqrtSize4":
      i = Lm(t, Pn);
      break;
    case "sqrtTall":
      i = Dm(t, Pn, n);
  }
  return i;
}, Im = function(e, t) {
  switch (e) {
    case "âŽœ":
      return "M291 0 H417 V" + t + " H291z M291 0 H417 V" + t + " H291z";
    case "âˆ£":
      return "M145 0 H188 V" + t + " H145z M145 0 H188 V" + t + " H145z";
    case "âˆ¥":
      return "M145 0 H188 V" + t + " H145z M145 0 H188 V" + t + " H145z" + ("M367 0 H410 V" + t + " H367z M367 0 H410 V" + t + " H367z");
    case "âŽŸ":
      return "M457 0 H583 V" + t + " H457z M457 0 H583 V" + t + " H457z";
    case "âŽ¢":
      return "M319 0 H403 V" + t + " H319z M319 0 H403 V" + t + " H319z";
    case "âŽ¥":
      return "M263 0 H347 V" + t + " H263z M263 0 H347 V" + t + " H263z";
    case "âŽª":
      return "M384 0 H504 V" + t + " H384z M384 0 H504 V" + t + " H384z";
    case "â":
      return "M312 0 H355 V" + t + " H312z M312 0 H355 V" + t + " H312z";
    case "â€–":
      return "M257 0 H300 V" + t + " H257z M257 0 H300 V" + t + " H257z" + ("M478 0 H521 V" + t + " H478z M478 0 H521 V" + t + " H478z");
    default:
      return "";
  }
}, T0 = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
  leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
  leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
  leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
  leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
  leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
  leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
  leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
  longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
  midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
  midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
  oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
  oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
  oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
  oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
  rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
  rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
  rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
  rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
  rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
  rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
  rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
  rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
  rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
  righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
  rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
  rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
  twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
  // ditto tilde2, tilde3, & tilde4
  tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
  tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
  tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
  // ditto widehat2, widehat3, & widehat4
  widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  // widecheck paths are all inverted versions of widehat
  widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
  widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
  rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
  shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
  shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
}, Pm = function(e, t) {
  switch (e) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + t + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + t + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + t + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + t + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + t + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + t + ` v585 h43z
M367 15 v585 v` + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + t + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + t + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + t + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + t + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + t + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + t + ` v602 h84z
M403 1759 V0 H319 V1759 v` + t + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + t + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + t + " v602 h84z";
    case "lparen":
      return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (t + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (t + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
    case "rparen":
      return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (t + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (t + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
class Pi {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(e) {
    this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = e, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
  }
  hasClass(e) {
    return Xe.contains(this.classes, e);
  }
  /** Convert the fragment into a node. */
  toNode() {
    for (var e = document.createDocumentFragment(), t = 0; t < this.children.length; t++)
      e.appendChild(this.children[t].toNode());
    return e;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    for (var e = "", t = 0; t < this.children.length; t++)
      e += this.children[t].toMarkup();
    return e;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var e = (t) => t.toText();
    return this.children.map(e).join("");
  }
}
var $r = {
  "AMS-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68889, 0, 0, 0.72222],
    66: [0, 0.68889, 0, 0, 0.66667],
    67: [0, 0.68889, 0, 0, 0.72222],
    68: [0, 0.68889, 0, 0, 0.72222],
    69: [0, 0.68889, 0, 0, 0.66667],
    70: [0, 0.68889, 0, 0, 0.61111],
    71: [0, 0.68889, 0, 0, 0.77778],
    72: [0, 0.68889, 0, 0, 0.77778],
    73: [0, 0.68889, 0, 0, 0.38889],
    74: [0.16667, 0.68889, 0, 0, 0.5],
    75: [0, 0.68889, 0, 0, 0.77778],
    76: [0, 0.68889, 0, 0, 0.66667],
    77: [0, 0.68889, 0, 0, 0.94445],
    78: [0, 0.68889, 0, 0, 0.72222],
    79: [0.16667, 0.68889, 0, 0, 0.77778],
    80: [0, 0.68889, 0, 0, 0.61111],
    81: [0.16667, 0.68889, 0, 0, 0.77778],
    82: [0, 0.68889, 0, 0, 0.72222],
    83: [0, 0.68889, 0, 0, 0.55556],
    84: [0, 0.68889, 0, 0, 0.66667],
    85: [0, 0.68889, 0, 0, 0.72222],
    86: [0, 0.68889, 0, 0, 0.72222],
    87: [0, 0.68889, 0, 0, 1],
    88: [0, 0.68889, 0, 0, 0.72222],
    89: [0, 0.68889, 0, 0, 0.72222],
    90: [0, 0.68889, 0, 0, 0.66667],
    107: [0, 0.68889, 0, 0, 0.55556],
    160: [0, 0, 0, 0, 0.25],
    165: [0, 0.675, 0.025, 0, 0.75],
    174: [0.15559, 0.69224, 0, 0, 0.94666],
    240: [0, 0.68889, 0, 0, 0.55556],
    295: [0, 0.68889, 0, 0, 0.54028],
    710: [0, 0.825, 0, 0, 2.33334],
    732: [0, 0.9, 0, 0, 2.33334],
    770: [0, 0.825, 0, 0, 2.33334],
    771: [0, 0.9, 0, 0, 2.33334],
    989: [0.08167, 0.58167, 0, 0, 0.77778],
    1008: [0, 0.43056, 0.04028, 0, 0.66667],
    8245: [0, 0.54986, 0, 0, 0.275],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8487: [0, 0.68889, 0, 0, 0.72222],
    8498: [0, 0.68889, 0, 0, 0.55556],
    8502: [0, 0.68889, 0, 0, 0.66667],
    8503: [0, 0.68889, 0, 0, 0.44445],
    8504: [0, 0.68889, 0, 0, 0.66667],
    8513: [0, 0.68889, 0, 0, 0.63889],
    8592: [-0.03598, 0.46402, 0, 0, 0.5],
    8594: [-0.03598, 0.46402, 0, 0, 0.5],
    8602: [-0.13313, 0.36687, 0, 0, 1],
    8603: [-0.13313, 0.36687, 0, 0, 1],
    8606: [0.01354, 0.52239, 0, 0, 1],
    8608: [0.01354, 0.52239, 0, 0, 1],
    8610: [0.01354, 0.52239, 0, 0, 1.11111],
    8611: [0.01354, 0.52239, 0, 0, 1.11111],
    8619: [0, 0.54986, 0, 0, 1],
    8620: [0, 0.54986, 0, 0, 1],
    8621: [-0.13313, 0.37788, 0, 0, 1.38889],
    8622: [-0.13313, 0.36687, 0, 0, 1],
    8624: [0, 0.69224, 0, 0, 0.5],
    8625: [0, 0.69224, 0, 0, 0.5],
    8630: [0, 0.43056, 0, 0, 1],
    8631: [0, 0.43056, 0, 0, 1],
    8634: [0.08198, 0.58198, 0, 0, 0.77778],
    8635: [0.08198, 0.58198, 0, 0, 0.77778],
    8638: [0.19444, 0.69224, 0, 0, 0.41667],
    8639: [0.19444, 0.69224, 0, 0, 0.41667],
    8642: [0.19444, 0.69224, 0, 0, 0.41667],
    8643: [0.19444, 0.69224, 0, 0, 0.41667],
    8644: [0.1808, 0.675, 0, 0, 1],
    8646: [0.1808, 0.675, 0, 0, 1],
    8647: [0.1808, 0.675, 0, 0, 1],
    8648: [0.19444, 0.69224, 0, 0, 0.83334],
    8649: [0.1808, 0.675, 0, 0, 1],
    8650: [0.19444, 0.69224, 0, 0, 0.83334],
    8651: [0.01354, 0.52239, 0, 0, 1],
    8652: [0.01354, 0.52239, 0, 0, 1],
    8653: [-0.13313, 0.36687, 0, 0, 1],
    8654: [-0.13313, 0.36687, 0, 0, 1],
    8655: [-0.13313, 0.36687, 0, 0, 1],
    8666: [0.13667, 0.63667, 0, 0, 1],
    8667: [0.13667, 0.63667, 0, 0, 1],
    8669: [-0.13313, 0.37788, 0, 0, 1],
    8672: [-0.064, 0.437, 0, 0, 1.334],
    8674: [-0.064, 0.437, 0, 0, 1.334],
    8705: [0, 0.825, 0, 0, 0.5],
    8708: [0, 0.68889, 0, 0, 0.55556],
    8709: [0.08167, 0.58167, 0, 0, 0.77778],
    8717: [0, 0.43056, 0, 0, 0.42917],
    8722: [-0.03598, 0.46402, 0, 0, 0.5],
    8724: [0.08198, 0.69224, 0, 0, 0.77778],
    8726: [0.08167, 0.58167, 0, 0, 0.77778],
    8733: [0, 0.69224, 0, 0, 0.77778],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8737: [0, 0.69224, 0, 0, 0.72222],
    8738: [0.03517, 0.52239, 0, 0, 0.72222],
    8739: [0.08167, 0.58167, 0, 0, 0.22222],
    8740: [0.25142, 0.74111, 0, 0, 0.27778],
    8741: [0.08167, 0.58167, 0, 0, 0.38889],
    8742: [0.25142, 0.74111, 0, 0, 0.5],
    8756: [0, 0.69224, 0, 0, 0.66667],
    8757: [0, 0.69224, 0, 0, 0.66667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8765: [-0.13313, 0.37788, 0, 0, 0.77778],
    8769: [-0.13313, 0.36687, 0, 0, 0.77778],
    8770: [-0.03625, 0.46375, 0, 0, 0.77778],
    8774: [0.30274, 0.79383, 0, 0, 0.77778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8778: [0.08167, 0.58167, 0, 0, 0.77778],
    8782: [0.06062, 0.54986, 0, 0, 0.77778],
    8783: [0.06062, 0.54986, 0, 0, 0.77778],
    8785: [0.08198, 0.58198, 0, 0, 0.77778],
    8786: [0.08198, 0.58198, 0, 0, 0.77778],
    8787: [0.08198, 0.58198, 0, 0, 0.77778],
    8790: [0, 0.69224, 0, 0, 0.77778],
    8791: [0.22958, 0.72958, 0, 0, 0.77778],
    8796: [0.08198, 0.91667, 0, 0, 0.77778],
    8806: [0.25583, 0.75583, 0, 0, 0.77778],
    8807: [0.25583, 0.75583, 0, 0, 0.77778],
    8808: [0.25142, 0.75726, 0, 0, 0.77778],
    8809: [0.25142, 0.75726, 0, 0, 0.77778],
    8812: [0.25583, 0.75583, 0, 0, 0.5],
    8814: [0.20576, 0.70576, 0, 0, 0.77778],
    8815: [0.20576, 0.70576, 0, 0, 0.77778],
    8816: [0.30274, 0.79383, 0, 0, 0.77778],
    8817: [0.30274, 0.79383, 0, 0, 0.77778],
    8818: [0.22958, 0.72958, 0, 0, 0.77778],
    8819: [0.22958, 0.72958, 0, 0, 0.77778],
    8822: [0.1808, 0.675, 0, 0, 0.77778],
    8823: [0.1808, 0.675, 0, 0, 0.77778],
    8828: [0.13667, 0.63667, 0, 0, 0.77778],
    8829: [0.13667, 0.63667, 0, 0, 0.77778],
    8830: [0.22958, 0.72958, 0, 0, 0.77778],
    8831: [0.22958, 0.72958, 0, 0, 0.77778],
    8832: [0.20576, 0.70576, 0, 0, 0.77778],
    8833: [0.20576, 0.70576, 0, 0, 0.77778],
    8840: [0.30274, 0.79383, 0, 0, 0.77778],
    8841: [0.30274, 0.79383, 0, 0, 0.77778],
    8842: [0.13597, 0.63597, 0, 0, 0.77778],
    8843: [0.13597, 0.63597, 0, 0, 0.77778],
    8847: [0.03517, 0.54986, 0, 0, 0.77778],
    8848: [0.03517, 0.54986, 0, 0, 0.77778],
    8858: [0.08198, 0.58198, 0, 0, 0.77778],
    8859: [0.08198, 0.58198, 0, 0, 0.77778],
    8861: [0.08198, 0.58198, 0, 0, 0.77778],
    8862: [0, 0.675, 0, 0, 0.77778],
    8863: [0, 0.675, 0, 0, 0.77778],
    8864: [0, 0.675, 0, 0, 0.77778],
    8865: [0, 0.675, 0, 0, 0.77778],
    8872: [0, 0.69224, 0, 0, 0.61111],
    8873: [0, 0.69224, 0, 0, 0.72222],
    8874: [0, 0.69224, 0, 0, 0.88889],
    8876: [0, 0.68889, 0, 0, 0.61111],
    8877: [0, 0.68889, 0, 0, 0.61111],
    8878: [0, 0.68889, 0, 0, 0.72222],
    8879: [0, 0.68889, 0, 0, 0.72222],
    8882: [0.03517, 0.54986, 0, 0, 0.77778],
    8883: [0.03517, 0.54986, 0, 0, 0.77778],
    8884: [0.13667, 0.63667, 0, 0, 0.77778],
    8885: [0.13667, 0.63667, 0, 0, 0.77778],
    8888: [0, 0.54986, 0, 0, 1.11111],
    8890: [0.19444, 0.43056, 0, 0, 0.55556],
    8891: [0.19444, 0.69224, 0, 0, 0.61111],
    8892: [0.19444, 0.69224, 0, 0, 0.61111],
    8901: [0, 0.54986, 0, 0, 0.27778],
    8903: [0.08167, 0.58167, 0, 0, 0.77778],
    8905: [0.08167, 0.58167, 0, 0, 0.77778],
    8906: [0.08167, 0.58167, 0, 0, 0.77778],
    8907: [0, 0.69224, 0, 0, 0.77778],
    8908: [0, 0.69224, 0, 0, 0.77778],
    8909: [-0.03598, 0.46402, 0, 0, 0.77778],
    8910: [0, 0.54986, 0, 0, 0.76042],
    8911: [0, 0.54986, 0, 0, 0.76042],
    8912: [0.03517, 0.54986, 0, 0, 0.77778],
    8913: [0.03517, 0.54986, 0, 0, 0.77778],
    8914: [0, 0.54986, 0, 0, 0.66667],
    8915: [0, 0.54986, 0, 0, 0.66667],
    8916: [0, 0.69224, 0, 0, 0.66667],
    8918: [0.0391, 0.5391, 0, 0, 0.77778],
    8919: [0.0391, 0.5391, 0, 0, 0.77778],
    8920: [0.03517, 0.54986, 0, 0, 1.33334],
    8921: [0.03517, 0.54986, 0, 0, 1.33334],
    8922: [0.38569, 0.88569, 0, 0, 0.77778],
    8923: [0.38569, 0.88569, 0, 0, 0.77778],
    8926: [0.13667, 0.63667, 0, 0, 0.77778],
    8927: [0.13667, 0.63667, 0, 0, 0.77778],
    8928: [0.30274, 0.79383, 0, 0, 0.77778],
    8929: [0.30274, 0.79383, 0, 0, 0.77778],
    8934: [0.23222, 0.74111, 0, 0, 0.77778],
    8935: [0.23222, 0.74111, 0, 0, 0.77778],
    8936: [0.23222, 0.74111, 0, 0, 0.77778],
    8937: [0.23222, 0.74111, 0, 0, 0.77778],
    8938: [0.20576, 0.70576, 0, 0, 0.77778],
    8939: [0.20576, 0.70576, 0, 0, 0.77778],
    8940: [0.30274, 0.79383, 0, 0, 0.77778],
    8941: [0.30274, 0.79383, 0, 0, 0.77778],
    8994: [0.19444, 0.69224, 0, 0, 0.77778],
    8995: [0.19444, 0.69224, 0, 0, 0.77778],
    9416: [0.15559, 0.69224, 0, 0, 0.90222],
    9484: [0, 0.69224, 0, 0, 0.5],
    9488: [0, 0.69224, 0, 0, 0.5],
    9492: [0, 0.37788, 0, 0, 0.5],
    9496: [0, 0.37788, 0, 0, 0.5],
    9585: [0.19444, 0.68889, 0, 0, 0.88889],
    9586: [0.19444, 0.74111, 0, 0, 0.88889],
    9632: [0, 0.675, 0, 0, 0.77778],
    9633: [0, 0.675, 0, 0, 0.77778],
    9650: [0, 0.54986, 0, 0, 0.72222],
    9651: [0, 0.54986, 0, 0, 0.72222],
    9654: [0.03517, 0.54986, 0, 0, 0.77778],
    9660: [0, 0.54986, 0, 0, 0.72222],
    9661: [0, 0.54986, 0, 0, 0.72222],
    9664: [0.03517, 0.54986, 0, 0, 0.77778],
    9674: [0.11111, 0.69224, 0, 0, 0.66667],
    9733: [0.19444, 0.69224, 0, 0, 0.94445],
    10003: [0, 0.69224, 0, 0, 0.83334],
    10016: [0, 0.69224, 0, 0, 0.83334],
    10731: [0.11111, 0.69224, 0, 0, 0.66667],
    10846: [0.19444, 0.75583, 0, 0, 0.61111],
    10877: [0.13667, 0.63667, 0, 0, 0.77778],
    10878: [0.13667, 0.63667, 0, 0, 0.77778],
    10885: [0.25583, 0.75583, 0, 0, 0.77778],
    10886: [0.25583, 0.75583, 0, 0, 0.77778],
    10887: [0.13597, 0.63597, 0, 0, 0.77778],
    10888: [0.13597, 0.63597, 0, 0, 0.77778],
    10889: [0.26167, 0.75726, 0, 0, 0.77778],
    10890: [0.26167, 0.75726, 0, 0, 0.77778],
    10891: [0.48256, 0.98256, 0, 0, 0.77778],
    10892: [0.48256, 0.98256, 0, 0, 0.77778],
    10901: [0.13667, 0.63667, 0, 0, 0.77778],
    10902: [0.13667, 0.63667, 0, 0, 0.77778],
    10933: [0.25142, 0.75726, 0, 0, 0.77778],
    10934: [0.25142, 0.75726, 0, 0, 0.77778],
    10935: [0.26167, 0.75726, 0, 0, 0.77778],
    10936: [0.26167, 0.75726, 0, 0, 0.77778],
    10937: [0.26167, 0.75726, 0, 0, 0.77778],
    10938: [0.26167, 0.75726, 0, 0, 0.77778],
    10949: [0.25583, 0.75583, 0, 0, 0.77778],
    10950: [0.25583, 0.75583, 0, 0, 0.77778],
    10955: [0.28481, 0.79383, 0, 0, 0.77778],
    10956: [0.28481, 0.79383, 0, 0, 0.77778],
    57350: [0.08167, 0.58167, 0, 0, 0.22222],
    57351: [0.08167, 0.58167, 0, 0, 0.38889],
    57352: [0.08167, 0.58167, 0, 0, 0.77778],
    57353: [0, 0.43056, 0.04028, 0, 0.66667],
    57356: [0.25142, 0.75726, 0, 0, 0.77778],
    57357: [0.25142, 0.75726, 0, 0, 0.77778],
    57358: [0.41951, 0.91951, 0, 0, 0.77778],
    57359: [0.30274, 0.79383, 0, 0, 0.77778],
    57360: [0.30274, 0.79383, 0, 0, 0.77778],
    57361: [0.41951, 0.91951, 0, 0, 0.77778],
    57366: [0.25142, 0.75726, 0, 0, 0.77778],
    57367: [0.25142, 0.75726, 0, 0, 0.77778],
    57368: [0.25142, 0.75726, 0, 0, 0.77778],
    57369: [0.25142, 0.75726, 0, 0, 0.77778],
    57370: [0.13597, 0.63597, 0, 0, 0.77778],
    57371: [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68333, 0, 0.19445, 0.79847],
    66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
    67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
    68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
    69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
    70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
    71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    72: [0, 0.68333, 965e-5, 0.11111, 0.84452],
    73: [0, 0.68333, 0.07382, 0, 0.54452],
    74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
    76: [0, 0.68333, 0, 0.13889, 0.68972],
    77: [0, 0.68333, 0, 0.13889, 1.2009],
    78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
    79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
    80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
    81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
    82: [0, 0.68333, 0, 0.08334, 0.8475],
    83: [0, 0.68333, 0.075, 0.13889, 0.60556],
    84: [0, 0.68333, 0.25417, 0, 0.54464],
    85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
    86: [0, 0.68333, 0.08222, 0, 0.61278],
    87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
    88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
    89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
    160: [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69141, 0, 0, 0.29574],
    34: [0, 0.69141, 0, 0, 0.21471],
    38: [0, 0.69141, 0, 0, 0.73786],
    39: [0, 0.69141, 0, 0, 0.21201],
    40: [0.24982, 0.74947, 0, 0, 0.38865],
    41: [0.24982, 0.74947, 0, 0, 0.38865],
    42: [0, 0.62119, 0, 0, 0.27764],
    43: [0.08319, 0.58283, 0, 0, 0.75623],
    44: [0, 0.10803, 0, 0, 0.27764],
    45: [0.08319, 0.58283, 0, 0, 0.75623],
    46: [0, 0.10803, 0, 0, 0.27764],
    47: [0.24982, 0.74947, 0, 0, 0.50181],
    48: [0, 0.47534, 0, 0, 0.50181],
    49: [0, 0.47534, 0, 0, 0.50181],
    50: [0, 0.47534, 0, 0, 0.50181],
    51: [0.18906, 0.47534, 0, 0, 0.50181],
    52: [0.18906, 0.47534, 0, 0, 0.50181],
    53: [0.18906, 0.47534, 0, 0, 0.50181],
    54: [0, 0.69141, 0, 0, 0.50181],
    55: [0.18906, 0.47534, 0, 0, 0.50181],
    56: [0, 0.69141, 0, 0, 0.50181],
    57: [0.18906, 0.47534, 0, 0, 0.50181],
    58: [0, 0.47534, 0, 0, 0.21606],
    59: [0.12604, 0.47534, 0, 0, 0.21606],
    61: [-0.13099, 0.36866, 0, 0, 0.75623],
    63: [0, 0.69141, 0, 0, 0.36245],
    65: [0, 0.69141, 0, 0, 0.7176],
    66: [0, 0.69141, 0, 0, 0.88397],
    67: [0, 0.69141, 0, 0, 0.61254],
    68: [0, 0.69141, 0, 0, 0.83158],
    69: [0, 0.69141, 0, 0, 0.66278],
    70: [0.12604, 0.69141, 0, 0, 0.61119],
    71: [0, 0.69141, 0, 0, 0.78539],
    72: [0.06302, 0.69141, 0, 0, 0.7203],
    73: [0, 0.69141, 0, 0, 0.55448],
    74: [0.12604, 0.69141, 0, 0, 0.55231],
    75: [0, 0.69141, 0, 0, 0.66845],
    76: [0, 0.69141, 0, 0, 0.66602],
    77: [0, 0.69141, 0, 0, 1.04953],
    78: [0, 0.69141, 0, 0, 0.83212],
    79: [0, 0.69141, 0, 0, 0.82699],
    80: [0.18906, 0.69141, 0, 0, 0.82753],
    81: [0.03781, 0.69141, 0, 0, 0.82699],
    82: [0, 0.69141, 0, 0, 0.82807],
    83: [0, 0.69141, 0, 0, 0.82861],
    84: [0, 0.69141, 0, 0, 0.66899],
    85: [0, 0.69141, 0, 0, 0.64576],
    86: [0, 0.69141, 0, 0, 0.83131],
    87: [0, 0.69141, 0, 0, 1.04602],
    88: [0, 0.69141, 0, 0, 0.71922],
    89: [0.18906, 0.69141, 0, 0, 0.83293],
    90: [0.12604, 0.69141, 0, 0, 0.60201],
    91: [0.24982, 0.74947, 0, 0, 0.27764],
    93: [0.24982, 0.74947, 0, 0, 0.27764],
    94: [0, 0.69141, 0, 0, 0.49965],
    97: [0, 0.47534, 0, 0, 0.50046],
    98: [0, 0.69141, 0, 0, 0.51315],
    99: [0, 0.47534, 0, 0, 0.38946],
    100: [0, 0.62119, 0, 0, 0.49857],
    101: [0, 0.47534, 0, 0, 0.40053],
    102: [0.18906, 0.69141, 0, 0, 0.32626],
    103: [0.18906, 0.47534, 0, 0, 0.5037],
    104: [0.18906, 0.69141, 0, 0, 0.52126],
    105: [0, 0.69141, 0, 0, 0.27899],
    106: [0, 0.69141, 0, 0, 0.28088],
    107: [0, 0.69141, 0, 0, 0.38946],
    108: [0, 0.69141, 0, 0, 0.27953],
    109: [0, 0.47534, 0, 0, 0.76676],
    110: [0, 0.47534, 0, 0, 0.52666],
    111: [0, 0.47534, 0, 0, 0.48885],
    112: [0.18906, 0.52396, 0, 0, 0.50046],
    113: [0.18906, 0.47534, 0, 0, 0.48912],
    114: [0, 0.47534, 0, 0, 0.38919],
    115: [0, 0.47534, 0, 0, 0.44266],
    116: [0, 0.62119, 0, 0, 0.33301],
    117: [0, 0.47534, 0, 0, 0.5172],
    118: [0, 0.52396, 0, 0, 0.5118],
    119: [0, 0.52396, 0, 0, 0.77351],
    120: [0.18906, 0.47534, 0, 0, 0.38865],
    121: [0.18906, 0.47534, 0, 0, 0.49884],
    122: [0.18906, 0.47534, 0, 0, 0.39054],
    160: [0, 0, 0, 0, 0.25],
    8216: [0, 0.69141, 0, 0, 0.21471],
    8217: [0, 0.69141, 0, 0, 0.21471],
    58112: [0, 0.62119, 0, 0, 0.49749],
    58113: [0, 0.62119, 0, 0, 0.4983],
    58114: [0.18906, 0.69141, 0, 0, 0.33328],
    58115: [0.18906, 0.69141, 0, 0, 0.32923],
    58116: [0.18906, 0.47534, 0, 0, 0.50343],
    58117: [0, 0.69141, 0, 0, 0.33301],
    58118: [0, 0.62119, 0, 0, 0.33409],
    58119: [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.35],
    34: [0, 0.69444, 0, 0, 0.60278],
    35: [0.19444, 0.69444, 0, 0, 0.95833],
    36: [0.05556, 0.75, 0, 0, 0.575],
    37: [0.05556, 0.75, 0, 0, 0.95833],
    38: [0, 0.69444, 0, 0, 0.89444],
    39: [0, 0.69444, 0, 0, 0.31944],
    40: [0.25, 0.75, 0, 0, 0.44722],
    41: [0.25, 0.75, 0, 0, 0.44722],
    42: [0, 0.75, 0, 0, 0.575],
    43: [0.13333, 0.63333, 0, 0, 0.89444],
    44: [0.19444, 0.15556, 0, 0, 0.31944],
    45: [0, 0.44444, 0, 0, 0.38333],
    46: [0, 0.15556, 0, 0, 0.31944],
    47: [0.25, 0.75, 0, 0, 0.575],
    48: [0, 0.64444, 0, 0, 0.575],
    49: [0, 0.64444, 0, 0, 0.575],
    50: [0, 0.64444, 0, 0, 0.575],
    51: [0, 0.64444, 0, 0, 0.575],
    52: [0, 0.64444, 0, 0, 0.575],
    53: [0, 0.64444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0, 0.64444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0, 0.64444, 0, 0, 0.575],
    58: [0, 0.44444, 0, 0, 0.31944],
    59: [0.19444, 0.44444, 0, 0, 0.31944],
    60: [0.08556, 0.58556, 0, 0, 0.89444],
    61: [-0.10889, 0.39111, 0, 0, 0.89444],
    62: [0.08556, 0.58556, 0, 0, 0.89444],
    63: [0, 0.69444, 0, 0, 0.54305],
    64: [0, 0.69444, 0, 0, 0.89444],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0, 0, 0.81805],
    67: [0, 0.68611, 0, 0, 0.83055],
    68: [0, 0.68611, 0, 0, 0.88194],
    69: [0, 0.68611, 0, 0, 0.75555],
    70: [0, 0.68611, 0, 0, 0.72361],
    71: [0, 0.68611, 0, 0, 0.90416],
    72: [0, 0.68611, 0, 0, 0.9],
    73: [0, 0.68611, 0, 0, 0.43611],
    74: [0, 0.68611, 0, 0, 0.59444],
    75: [0, 0.68611, 0, 0, 0.90138],
    76: [0, 0.68611, 0, 0, 0.69166],
    77: [0, 0.68611, 0, 0, 1.09166],
    78: [0, 0.68611, 0, 0, 0.9],
    79: [0, 0.68611, 0, 0, 0.86388],
    80: [0, 0.68611, 0, 0, 0.78611],
    81: [0.19444, 0.68611, 0, 0, 0.86388],
    82: [0, 0.68611, 0, 0, 0.8625],
    83: [0, 0.68611, 0, 0, 0.63889],
    84: [0, 0.68611, 0, 0, 0.8],
    85: [0, 0.68611, 0, 0, 0.88472],
    86: [0, 0.68611, 0.01597, 0, 0.86944],
    87: [0, 0.68611, 0.01597, 0, 1.18888],
    88: [0, 0.68611, 0, 0, 0.86944],
    89: [0, 0.68611, 0.02875, 0, 0.86944],
    90: [0, 0.68611, 0, 0, 0.70277],
    91: [0.25, 0.75, 0, 0, 0.31944],
    92: [0.25, 0.75, 0, 0, 0.575],
    93: [0.25, 0.75, 0, 0, 0.31944],
    94: [0, 0.69444, 0, 0, 0.575],
    95: [0.31, 0.13444, 0.03194, 0, 0.575],
    97: [0, 0.44444, 0, 0, 0.55902],
    98: [0, 0.69444, 0, 0, 0.63889],
    99: [0, 0.44444, 0, 0, 0.51111],
    100: [0, 0.69444, 0, 0, 0.63889],
    101: [0, 0.44444, 0, 0, 0.52708],
    102: [0, 0.69444, 0.10903, 0, 0.35139],
    103: [0.19444, 0.44444, 0.01597, 0, 0.575],
    104: [0, 0.69444, 0, 0, 0.63889],
    105: [0, 0.69444, 0, 0, 0.31944],
    106: [0.19444, 0.69444, 0, 0, 0.35139],
    107: [0, 0.69444, 0, 0, 0.60694],
    108: [0, 0.69444, 0, 0, 0.31944],
    109: [0, 0.44444, 0, 0, 0.95833],
    110: [0, 0.44444, 0, 0, 0.63889],
    111: [0, 0.44444, 0, 0, 0.575],
    112: [0.19444, 0.44444, 0, 0, 0.63889],
    113: [0.19444, 0.44444, 0, 0, 0.60694],
    114: [0, 0.44444, 0, 0, 0.47361],
    115: [0, 0.44444, 0, 0, 0.45361],
    116: [0, 0.63492, 0, 0, 0.44722],
    117: [0, 0.44444, 0, 0, 0.63889],
    118: [0, 0.44444, 0.01597, 0, 0.60694],
    119: [0, 0.44444, 0.01597, 0, 0.83055],
    120: [0, 0.44444, 0, 0, 0.60694],
    121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
    122: [0, 0.44444, 0, 0, 0.51111],
    123: [0.25, 0.75, 0, 0, 0.575],
    124: [0.25, 0.75, 0, 0, 0.31944],
    125: [0.25, 0.75, 0, 0, 0.575],
    126: [0.35, 0.34444, 0, 0, 0.575],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.86853],
    168: [0, 0.69444, 0, 0, 0.575],
    172: [0, 0.44444, 0, 0, 0.76666],
    176: [0, 0.69444, 0, 0, 0.86944],
    177: [0.13333, 0.63333, 0, 0, 0.89444],
    184: [0.17014, 0, 0, 0, 0.51111],
    198: [0, 0.68611, 0, 0, 1.04166],
    215: [0.13333, 0.63333, 0, 0, 0.89444],
    216: [0.04861, 0.73472, 0, 0, 0.89444],
    223: [0, 0.69444, 0, 0, 0.59722],
    230: [0, 0.44444, 0, 0, 0.83055],
    247: [0.13333, 0.63333, 0, 0, 0.89444],
    248: [0.09722, 0.54167, 0, 0, 0.575],
    305: [0, 0.44444, 0, 0, 0.31944],
    338: [0, 0.68611, 0, 0, 1.16944],
    339: [0, 0.44444, 0, 0, 0.89444],
    567: [0.19444, 0.44444, 0, 0, 0.35139],
    710: [0, 0.69444, 0, 0, 0.575],
    711: [0, 0.63194, 0, 0, 0.575],
    713: [0, 0.59611, 0, 0, 0.575],
    714: [0, 0.69444, 0, 0, 0.575],
    715: [0, 0.69444, 0, 0, 0.575],
    728: [0, 0.69444, 0, 0, 0.575],
    729: [0, 0.69444, 0, 0, 0.31944],
    730: [0, 0.69444, 0, 0, 0.86944],
    732: [0, 0.69444, 0, 0, 0.575],
    733: [0, 0.69444, 0, 0, 0.575],
    915: [0, 0.68611, 0, 0, 0.69166],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0, 0, 0.89444],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0, 0, 0.76666],
    928: [0, 0.68611, 0, 0, 0.9],
    931: [0, 0.68611, 0, 0, 0.83055],
    933: [0, 0.68611, 0, 0, 0.89444],
    934: [0, 0.68611, 0, 0, 0.83055],
    936: [0, 0.68611, 0, 0, 0.89444],
    937: [0, 0.68611, 0, 0, 0.83055],
    8211: [0, 0.44444, 0.03194, 0, 0.575],
    8212: [0, 0.44444, 0.03194, 0, 1.14999],
    8216: [0, 0.69444, 0, 0, 0.31944],
    8217: [0, 0.69444, 0, 0, 0.31944],
    8220: [0, 0.69444, 0, 0, 0.60278],
    8221: [0, 0.69444, 0, 0, 0.60278],
    8224: [0.19444, 0.69444, 0, 0, 0.51111],
    8225: [0.19444, 0.69444, 0, 0, 0.51111],
    8242: [0, 0.55556, 0, 0, 0.34444],
    8407: [0, 0.72444, 0.15486, 0, 0.575],
    8463: [0, 0.69444, 0, 0, 0.66759],
    8465: [0, 0.69444, 0, 0, 0.83055],
    8467: [0, 0.69444, 0, 0, 0.47361],
    8472: [0.19444, 0.44444, 0, 0, 0.74027],
    8476: [0, 0.69444, 0, 0, 0.83055],
    8501: [0, 0.69444, 0, 0, 0.70277],
    8592: [-0.10889, 0.39111, 0, 0, 1.14999],
    8593: [0.19444, 0.69444, 0, 0, 0.575],
    8594: [-0.10889, 0.39111, 0, 0, 1.14999],
    8595: [0.19444, 0.69444, 0, 0, 0.575],
    8596: [-0.10889, 0.39111, 0, 0, 1.14999],
    8597: [0.25, 0.75, 0, 0, 0.575],
    8598: [0.19444, 0.69444, 0, 0, 1.14999],
    8599: [0.19444, 0.69444, 0, 0, 1.14999],
    8600: [0.19444, 0.69444, 0, 0, 1.14999],
    8601: [0.19444, 0.69444, 0, 0, 1.14999],
    8636: [-0.10889, 0.39111, 0, 0, 1.14999],
    8637: [-0.10889, 0.39111, 0, 0, 1.14999],
    8640: [-0.10889, 0.39111, 0, 0, 1.14999],
    8641: [-0.10889, 0.39111, 0, 0, 1.14999],
    8656: [-0.10889, 0.39111, 0, 0, 1.14999],
    8657: [0.19444, 0.69444, 0, 0, 0.70277],
    8658: [-0.10889, 0.39111, 0, 0, 1.14999],
    8659: [0.19444, 0.69444, 0, 0, 0.70277],
    8660: [-0.10889, 0.39111, 0, 0, 1.14999],
    8661: [0.25, 0.75, 0, 0, 0.70277],
    8704: [0, 0.69444, 0, 0, 0.63889],
    8706: [0, 0.69444, 0.06389, 0, 0.62847],
    8707: [0, 0.69444, 0, 0, 0.63889],
    8709: [0.05556, 0.75, 0, 0, 0.575],
    8711: [0, 0.68611, 0, 0, 0.95833],
    8712: [0.08556, 0.58556, 0, 0, 0.76666],
    8715: [0.08556, 0.58556, 0, 0, 0.76666],
    8722: [0.13333, 0.63333, 0, 0, 0.89444],
    8723: [0.13333, 0.63333, 0, 0, 0.89444],
    8725: [0.25, 0.75, 0, 0, 0.575],
    8726: [0.25, 0.75, 0, 0, 0.575],
    8727: [-0.02778, 0.47222, 0, 0, 0.575],
    8728: [-0.02639, 0.47361, 0, 0, 0.575],
    8729: [-0.02639, 0.47361, 0, 0, 0.575],
    8730: [0.18, 0.82, 0, 0, 0.95833],
    8733: [0, 0.44444, 0, 0, 0.89444],
    8734: [0, 0.44444, 0, 0, 1.14999],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.31944],
    8741: [0.25, 0.75, 0, 0, 0.575],
    8743: [0, 0.55556, 0, 0, 0.76666],
    8744: [0, 0.55556, 0, 0, 0.76666],
    8745: [0, 0.55556, 0, 0, 0.76666],
    8746: [0, 0.55556, 0, 0, 0.76666],
    8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
    8764: [-0.10889, 0.39111, 0, 0, 0.89444],
    8768: [0.19444, 0.69444, 0, 0, 0.31944],
    8771: [222e-5, 0.50222, 0, 0, 0.89444],
    8773: [0.027, 0.638, 0, 0, 0.894],
    8776: [0.02444, 0.52444, 0, 0, 0.89444],
    8781: [222e-5, 0.50222, 0, 0, 0.89444],
    8801: [222e-5, 0.50222, 0, 0, 0.89444],
    8804: [0.19667, 0.69667, 0, 0, 0.89444],
    8805: [0.19667, 0.69667, 0, 0, 0.89444],
    8810: [0.08556, 0.58556, 0, 0, 1.14999],
    8811: [0.08556, 0.58556, 0, 0, 1.14999],
    8826: [0.08556, 0.58556, 0, 0, 0.89444],
    8827: [0.08556, 0.58556, 0, 0, 0.89444],
    8834: [0.08556, 0.58556, 0, 0, 0.89444],
    8835: [0.08556, 0.58556, 0, 0, 0.89444],
    8838: [0.19667, 0.69667, 0, 0, 0.89444],
    8839: [0.19667, 0.69667, 0, 0, 0.89444],
    8846: [0, 0.55556, 0, 0, 0.76666],
    8849: [0.19667, 0.69667, 0, 0, 0.89444],
    8850: [0.19667, 0.69667, 0, 0, 0.89444],
    8851: [0, 0.55556, 0, 0, 0.76666],
    8852: [0, 0.55556, 0, 0, 0.76666],
    8853: [0.13333, 0.63333, 0, 0, 0.89444],
    8854: [0.13333, 0.63333, 0, 0, 0.89444],
    8855: [0.13333, 0.63333, 0, 0, 0.89444],
    8856: [0.13333, 0.63333, 0, 0, 0.89444],
    8857: [0.13333, 0.63333, 0, 0, 0.89444],
    8866: [0, 0.69444, 0, 0, 0.70277],
    8867: [0, 0.69444, 0, 0, 0.70277],
    8868: [0, 0.69444, 0, 0, 0.89444],
    8869: [0, 0.69444, 0, 0, 0.89444],
    8900: [-0.02639, 0.47361, 0, 0, 0.575],
    8901: [-0.02639, 0.47361, 0, 0, 0.31944],
    8902: [-0.02778, 0.47222, 0, 0, 0.575],
    8968: [0.25, 0.75, 0, 0, 0.51111],
    8969: [0.25, 0.75, 0, 0, 0.51111],
    8970: [0.25, 0.75, 0, 0, 0.51111],
    8971: [0.25, 0.75, 0, 0, 0.51111],
    8994: [-0.13889, 0.36111, 0, 0, 1.14999],
    8995: [-0.13889, 0.36111, 0, 0, 1.14999],
    9651: [0.19444, 0.69444, 0, 0, 1.02222],
    9657: [-0.02778, 0.47222, 0, 0, 0.575],
    9661: [0.19444, 0.69444, 0, 0, 1.02222],
    9667: [-0.02778, 0.47222, 0, 0, 0.575],
    9711: [0.19444, 0.69444, 0, 0, 1.14999],
    9824: [0.12963, 0.69444, 0, 0, 0.89444],
    9825: [0.12963, 0.69444, 0, 0, 0.89444],
    9826: [0.12963, 0.69444, 0, 0, 0.89444],
    9827: [0.12963, 0.69444, 0, 0, 0.89444],
    9837: [0, 0.75, 0, 0, 0.44722],
    9838: [0.19444, 0.69444, 0, 0, 0.44722],
    9839: [0.19444, 0.69444, 0, 0, 0.44722],
    10216: [0.25, 0.75, 0, 0, 0.44722],
    10217: [0.25, 0.75, 0, 0, 0.44722],
    10815: [0, 0.68611, 0, 0, 0.9],
    10927: [0.19667, 0.69667, 0, 0, 0.89444],
    10928: [0.19667, 0.69667, 0, 0, 0.89444],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.11417, 0, 0.38611],
    34: [0, 0.69444, 0.07939, 0, 0.62055],
    35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
    37: [0.05556, 0.75, 0.12861, 0, 0.94444],
    38: [0, 0.69444, 0.08528, 0, 0.88555],
    39: [0, 0.69444, 0.12945, 0, 0.35555],
    40: [0.25, 0.75, 0.15806, 0, 0.47333],
    41: [0.25, 0.75, 0.03306, 0, 0.47333],
    42: [0, 0.75, 0.14333, 0, 0.59111],
    43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
    44: [0.19444, 0.14722, 0, 0, 0.35555],
    45: [0, 0.44444, 0.02611, 0, 0.41444],
    46: [0, 0.14722, 0, 0, 0.35555],
    47: [0.25, 0.75, 0.15806, 0, 0.59111],
    48: [0, 0.64444, 0.13167, 0, 0.59111],
    49: [0, 0.64444, 0.13167, 0, 0.59111],
    50: [0, 0.64444, 0.13167, 0, 0.59111],
    51: [0, 0.64444, 0.13167, 0, 0.59111],
    52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    53: [0, 0.64444, 0.13167, 0, 0.59111],
    54: [0, 0.64444, 0.13167, 0, 0.59111],
    55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    56: [0, 0.64444, 0.13167, 0, 0.59111],
    57: [0, 0.64444, 0.13167, 0, 0.59111],
    58: [0, 0.44444, 0.06695, 0, 0.35555],
    59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
    61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    63: [0, 0.69444, 0.11472, 0, 0.59111],
    64: [0, 0.69444, 0.09208, 0, 0.88555],
    65: [0, 0.68611, 0, 0, 0.86555],
    66: [0, 0.68611, 0.0992, 0, 0.81666],
    67: [0, 0.68611, 0.14208, 0, 0.82666],
    68: [0, 0.68611, 0.09062, 0, 0.87555],
    69: [0, 0.68611, 0.11431, 0, 0.75666],
    70: [0, 0.68611, 0.12903, 0, 0.72722],
    71: [0, 0.68611, 0.07347, 0, 0.89527],
    72: [0, 0.68611, 0.17208, 0, 0.8961],
    73: [0, 0.68611, 0.15681, 0, 0.47166],
    74: [0, 0.68611, 0.145, 0, 0.61055],
    75: [0, 0.68611, 0.14208, 0, 0.89499],
    76: [0, 0.68611, 0, 0, 0.69777],
    77: [0, 0.68611, 0.17208, 0, 1.07277],
    78: [0, 0.68611, 0.17208, 0, 0.8961],
    79: [0, 0.68611, 0.09062, 0, 0.85499],
    80: [0, 0.68611, 0.0992, 0, 0.78721],
    81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
    82: [0, 0.68611, 0.02559, 0, 0.85944],
    83: [0, 0.68611, 0.11264, 0, 0.64999],
    84: [0, 0.68611, 0.12903, 0, 0.7961],
    85: [0, 0.68611, 0.17208, 0, 0.88083],
    86: [0, 0.68611, 0.18625, 0, 0.86555],
    87: [0, 0.68611, 0.18625, 0, 1.15999],
    88: [0, 0.68611, 0.15681, 0, 0.86555],
    89: [0, 0.68611, 0.19803, 0, 0.86555],
    90: [0, 0.68611, 0.14208, 0, 0.70888],
    91: [0.25, 0.75, 0.1875, 0, 0.35611],
    93: [0.25, 0.75, 0.09972, 0, 0.35611],
    94: [0, 0.69444, 0.06709, 0, 0.59111],
    95: [0.31, 0.13444, 0.09811, 0, 0.59111],
    97: [0, 0.44444, 0.09426, 0, 0.59111],
    98: [0, 0.69444, 0.07861, 0, 0.53222],
    99: [0, 0.44444, 0.05222, 0, 0.53222],
    100: [0, 0.69444, 0.10861, 0, 0.59111],
    101: [0, 0.44444, 0.085, 0, 0.53222],
    102: [0.19444, 0.69444, 0.21778, 0, 0.4],
    103: [0.19444, 0.44444, 0.105, 0, 0.53222],
    104: [0, 0.69444, 0.09426, 0, 0.59111],
    105: [0, 0.69326, 0.11387, 0, 0.35555],
    106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
    107: [0, 0.69444, 0.11111, 0, 0.53222],
    108: [0, 0.69444, 0.10861, 0, 0.29666],
    109: [0, 0.44444, 0.09426, 0, 0.94444],
    110: [0, 0.44444, 0.09426, 0, 0.64999],
    111: [0, 0.44444, 0.07861, 0, 0.59111],
    112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
    113: [0.19444, 0.44444, 0.105, 0, 0.53222],
    114: [0, 0.44444, 0.11111, 0, 0.50167],
    115: [0, 0.44444, 0.08167, 0, 0.48694],
    116: [0, 0.63492, 0.09639, 0, 0.385],
    117: [0, 0.44444, 0.09426, 0, 0.62055],
    118: [0, 0.44444, 0.11111, 0, 0.53222],
    119: [0, 0.44444, 0.11111, 0, 0.76777],
    120: [0, 0.44444, 0.12583, 0, 0.56055],
    121: [0.19444, 0.44444, 0.105, 0, 0.56166],
    122: [0, 0.44444, 0.13889, 0, 0.49055],
    126: [0.35, 0.34444, 0.11472, 0, 0.59111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0.11473, 0, 0.59111],
    176: [0, 0.69444, 0, 0, 0.94888],
    184: [0.17014, 0, 0, 0, 0.53222],
    198: [0, 0.68611, 0.11431, 0, 1.02277],
    216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
    223: [0.19444, 0.69444, 0.09736, 0, 0.665],
    230: [0, 0.44444, 0.085, 0, 0.82666],
    248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
    305: [0, 0.44444, 0.09426, 0, 0.35555],
    338: [0, 0.68611, 0.11431, 0, 1.14054],
    339: [0, 0.44444, 0.085, 0, 0.82666],
    567: [0.19444, 0.44444, 0.04611, 0, 0.385],
    710: [0, 0.69444, 0.06709, 0, 0.59111],
    711: [0, 0.63194, 0.08271, 0, 0.59111],
    713: [0, 0.59444, 0.10444, 0, 0.59111],
    714: [0, 0.69444, 0.08528, 0, 0.59111],
    715: [0, 0.69444, 0, 0, 0.59111],
    728: [0, 0.69444, 0.10333, 0, 0.59111],
    729: [0, 0.69444, 0.12945, 0, 0.35555],
    730: [0, 0.69444, 0, 0, 0.94888],
    732: [0, 0.69444, 0.11472, 0, 0.59111],
    733: [0, 0.69444, 0.11472, 0, 0.59111],
    915: [0, 0.68611, 0.12903, 0, 0.69777],
    916: [0, 0.68611, 0, 0, 0.94444],
    920: [0, 0.68611, 0.09062, 0, 0.88555],
    923: [0, 0.68611, 0, 0, 0.80666],
    926: [0, 0.68611, 0.15092, 0, 0.76777],
    928: [0, 0.68611, 0.17208, 0, 0.8961],
    931: [0, 0.68611, 0.11431, 0, 0.82666],
    933: [0, 0.68611, 0.10778, 0, 0.88555],
    934: [0, 0.68611, 0.05632, 0, 0.82666],
    936: [0, 0.68611, 0.10778, 0, 0.88555],
    937: [0, 0.68611, 0.0992, 0, 0.82666],
    8211: [0, 0.44444, 0.09811, 0, 0.59111],
    8212: [0, 0.44444, 0.09811, 0, 1.18221],
    8216: [0, 0.69444, 0.12945, 0, 0.35555],
    8217: [0, 0.69444, 0.12945, 0, 0.35555],
    8220: [0, 0.69444, 0.16772, 0, 0.62055],
    8221: [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.12417, 0, 0.30667],
    34: [0, 0.69444, 0.06961, 0, 0.51444],
    35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
    37: [0.05556, 0.75, 0.13639, 0, 0.81777],
    38: [0, 0.69444, 0.09694, 0, 0.76666],
    39: [0, 0.69444, 0.12417, 0, 0.30667],
    40: [0.25, 0.75, 0.16194, 0, 0.40889],
    41: [0.25, 0.75, 0.03694, 0, 0.40889],
    42: [0, 0.75, 0.14917, 0, 0.51111],
    43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
    44: [0.19444, 0.10556, 0, 0, 0.30667],
    45: [0, 0.43056, 0.02826, 0, 0.35778],
    46: [0, 0.10556, 0, 0, 0.30667],
    47: [0.25, 0.75, 0.16194, 0, 0.51111],
    48: [0, 0.64444, 0.13556, 0, 0.51111],
    49: [0, 0.64444, 0.13556, 0, 0.51111],
    50: [0, 0.64444, 0.13556, 0, 0.51111],
    51: [0, 0.64444, 0.13556, 0, 0.51111],
    52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    53: [0, 0.64444, 0.13556, 0, 0.51111],
    54: [0, 0.64444, 0.13556, 0, 0.51111],
    55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    56: [0, 0.64444, 0.13556, 0, 0.51111],
    57: [0, 0.64444, 0.13556, 0, 0.51111],
    58: [0, 0.43056, 0.0582, 0, 0.30667],
    59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
    61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    63: [0, 0.69444, 0.1225, 0, 0.51111],
    64: [0, 0.69444, 0.09597, 0, 0.76666],
    65: [0, 0.68333, 0, 0, 0.74333],
    66: [0, 0.68333, 0.10257, 0, 0.70389],
    67: [0, 0.68333, 0.14528, 0, 0.71555],
    68: [0, 0.68333, 0.09403, 0, 0.755],
    69: [0, 0.68333, 0.12028, 0, 0.67833],
    70: [0, 0.68333, 0.13305, 0, 0.65277],
    71: [0, 0.68333, 0.08722, 0, 0.77361],
    72: [0, 0.68333, 0.16389, 0, 0.74333],
    73: [0, 0.68333, 0.15806, 0, 0.38555],
    74: [0, 0.68333, 0.14028, 0, 0.525],
    75: [0, 0.68333, 0.14528, 0, 0.76888],
    76: [0, 0.68333, 0, 0, 0.62722],
    77: [0, 0.68333, 0.16389, 0, 0.89666],
    78: [0, 0.68333, 0.16389, 0, 0.74333],
    79: [0, 0.68333, 0.09403, 0, 0.76666],
    80: [0, 0.68333, 0.10257, 0, 0.67833],
    81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
    82: [0, 0.68333, 0.03868, 0, 0.72944],
    83: [0, 0.68333, 0.11972, 0, 0.56222],
    84: [0, 0.68333, 0.13305, 0, 0.71555],
    85: [0, 0.68333, 0.16389, 0, 0.74333],
    86: [0, 0.68333, 0.18361, 0, 0.74333],
    87: [0, 0.68333, 0.18361, 0, 0.99888],
    88: [0, 0.68333, 0.15806, 0, 0.74333],
    89: [0, 0.68333, 0.19383, 0, 0.74333],
    90: [0, 0.68333, 0.14528, 0, 0.61333],
    91: [0.25, 0.75, 0.1875, 0, 0.30667],
    93: [0.25, 0.75, 0.10528, 0, 0.30667],
    94: [0, 0.69444, 0.06646, 0, 0.51111],
    95: [0.31, 0.12056, 0.09208, 0, 0.51111],
    97: [0, 0.43056, 0.07671, 0, 0.51111],
    98: [0, 0.69444, 0.06312, 0, 0.46],
    99: [0, 0.43056, 0.05653, 0, 0.46],
    100: [0, 0.69444, 0.10333, 0, 0.51111],
    101: [0, 0.43056, 0.07514, 0, 0.46],
    102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
    103: [0.19444, 0.43056, 0.08847, 0, 0.46],
    104: [0, 0.69444, 0.07671, 0, 0.51111],
    105: [0, 0.65536, 0.1019, 0, 0.30667],
    106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
    107: [0, 0.69444, 0.10764, 0, 0.46],
    108: [0, 0.69444, 0.10333, 0, 0.25555],
    109: [0, 0.43056, 0.07671, 0, 0.81777],
    110: [0, 0.43056, 0.07671, 0, 0.56222],
    111: [0, 0.43056, 0.06312, 0, 0.51111],
    112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
    113: [0.19444, 0.43056, 0.08847, 0, 0.46],
    114: [0, 0.43056, 0.10764, 0, 0.42166],
    115: [0, 0.43056, 0.08208, 0, 0.40889],
    116: [0, 0.61508, 0.09486, 0, 0.33222],
    117: [0, 0.43056, 0.07671, 0, 0.53666],
    118: [0, 0.43056, 0.10764, 0, 0.46],
    119: [0, 0.43056, 0.10764, 0, 0.66444],
    120: [0, 0.43056, 0.12042, 0, 0.46389],
    121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
    122: [0, 0.43056, 0.12292, 0, 0.40889],
    126: [0.35, 0.31786, 0.11585, 0, 0.51111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.66786, 0.10474, 0, 0.51111],
    176: [0, 0.69444, 0, 0, 0.83129],
    184: [0.17014, 0, 0, 0, 0.46],
    198: [0, 0.68333, 0.12028, 0, 0.88277],
    216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
    223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
    230: [0, 0.43056, 0.07514, 0, 0.71555],
    248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
    338: [0, 0.68333, 0.12028, 0, 0.98499],
    339: [0, 0.43056, 0.07514, 0, 0.71555],
    710: [0, 0.69444, 0.06646, 0, 0.51111],
    711: [0, 0.62847, 0.08295, 0, 0.51111],
    713: [0, 0.56167, 0.10333, 0, 0.51111],
    714: [0, 0.69444, 0.09694, 0, 0.51111],
    715: [0, 0.69444, 0, 0, 0.51111],
    728: [0, 0.69444, 0.10806, 0, 0.51111],
    729: [0, 0.66786, 0.11752, 0, 0.30667],
    730: [0, 0.69444, 0, 0, 0.83129],
    732: [0, 0.66786, 0.11585, 0, 0.51111],
    733: [0, 0.69444, 0.1225, 0, 0.51111],
    915: [0, 0.68333, 0.13305, 0, 0.62722],
    916: [0, 0.68333, 0, 0, 0.81777],
    920: [0, 0.68333, 0.09403, 0, 0.76666],
    923: [0, 0.68333, 0, 0, 0.69222],
    926: [0, 0.68333, 0.15294, 0, 0.66444],
    928: [0, 0.68333, 0.16389, 0, 0.74333],
    931: [0, 0.68333, 0.12028, 0, 0.71555],
    933: [0, 0.68333, 0.11111, 0, 0.76666],
    934: [0, 0.68333, 0.05986, 0, 0.71555],
    936: [0, 0.68333, 0.11111, 0, 0.76666],
    937: [0, 0.68333, 0.10257, 0, 0.71555],
    8211: [0, 0.43056, 0.09208, 0, 0.51111],
    8212: [0, 0.43056, 0.09208, 0, 1.02222],
    8216: [0, 0.69444, 0.12417, 0, 0.30667],
    8217: [0, 0.69444, 0.12417, 0, 0.30667],
    8220: [0, 0.69444, 0.1685, 0, 0.51444],
    8221: [0, 0.69444, 0.06961, 0, 0.51444],
    8463: [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.27778],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.77778],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.19444, 0.10556, 0, 0, 0.27778],
    45: [0, 0.43056, 0, 0, 0.33333],
    46: [0, 0.10556, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.64444, 0, 0, 0.5],
    49: [0, 0.64444, 0, 0, 0.5],
    50: [0, 0.64444, 0, 0, 0.5],
    51: [0, 0.64444, 0, 0, 0.5],
    52: [0, 0.64444, 0, 0, 0.5],
    53: [0, 0.64444, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0, 0.64444, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0, 0.64444, 0, 0, 0.5],
    58: [0, 0.43056, 0, 0, 0.27778],
    59: [0.19444, 0.43056, 0, 0, 0.27778],
    60: [0.0391, 0.5391, 0, 0, 0.77778],
    61: [-0.13313, 0.36687, 0, 0, 0.77778],
    62: [0.0391, 0.5391, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.77778],
    65: [0, 0.68333, 0, 0, 0.75],
    66: [0, 0.68333, 0, 0, 0.70834],
    67: [0, 0.68333, 0, 0, 0.72222],
    68: [0, 0.68333, 0, 0, 0.76389],
    69: [0, 0.68333, 0, 0, 0.68056],
    70: [0, 0.68333, 0, 0, 0.65278],
    71: [0, 0.68333, 0, 0, 0.78472],
    72: [0, 0.68333, 0, 0, 0.75],
    73: [0, 0.68333, 0, 0, 0.36111],
    74: [0, 0.68333, 0, 0, 0.51389],
    75: [0, 0.68333, 0, 0, 0.77778],
    76: [0, 0.68333, 0, 0, 0.625],
    77: [0, 0.68333, 0, 0, 0.91667],
    78: [0, 0.68333, 0, 0, 0.75],
    79: [0, 0.68333, 0, 0, 0.77778],
    80: [0, 0.68333, 0, 0, 0.68056],
    81: [0.19444, 0.68333, 0, 0, 0.77778],
    82: [0, 0.68333, 0, 0, 0.73611],
    83: [0, 0.68333, 0, 0, 0.55556],
    84: [0, 0.68333, 0, 0, 0.72222],
    85: [0, 0.68333, 0, 0, 0.75],
    86: [0, 0.68333, 0.01389, 0, 0.75],
    87: [0, 0.68333, 0.01389, 0, 1.02778],
    88: [0, 0.68333, 0, 0, 0.75],
    89: [0, 0.68333, 0.025, 0, 0.75],
    90: [0, 0.68333, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.27778],
    92: [0.25, 0.75, 0, 0, 0.5],
    93: [0.25, 0.75, 0, 0, 0.27778],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.31, 0.12056, 0.02778, 0, 0.5],
    97: [0, 0.43056, 0, 0, 0.5],
    98: [0, 0.69444, 0, 0, 0.55556],
    99: [0, 0.43056, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.55556],
    101: [0, 0.43056, 0, 0, 0.44445],
    102: [0, 0.69444, 0.07778, 0, 0.30556],
    103: [0.19444, 0.43056, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.55556],
    105: [0, 0.66786, 0, 0, 0.27778],
    106: [0.19444, 0.66786, 0, 0, 0.30556],
    107: [0, 0.69444, 0, 0, 0.52778],
    108: [0, 0.69444, 0, 0, 0.27778],
    109: [0, 0.43056, 0, 0, 0.83334],
    110: [0, 0.43056, 0, 0, 0.55556],
    111: [0, 0.43056, 0, 0, 0.5],
    112: [0.19444, 0.43056, 0, 0, 0.55556],
    113: [0.19444, 0.43056, 0, 0, 0.52778],
    114: [0, 0.43056, 0, 0, 0.39167],
    115: [0, 0.43056, 0, 0, 0.39445],
    116: [0, 0.61508, 0, 0, 0.38889],
    117: [0, 0.43056, 0, 0, 0.55556],
    118: [0, 0.43056, 0.01389, 0, 0.52778],
    119: [0, 0.43056, 0.01389, 0, 0.72222],
    120: [0, 0.43056, 0, 0, 0.52778],
    121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
    122: [0, 0.43056, 0, 0, 0.44445],
    123: [0.25, 0.75, 0, 0, 0.5],
    124: [0.25, 0.75, 0, 0, 0.27778],
    125: [0.25, 0.75, 0, 0, 0.5],
    126: [0.35, 0.31786, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.76909],
    167: [0.19444, 0.69444, 0, 0, 0.44445],
    168: [0, 0.66786, 0, 0, 0.5],
    172: [0, 0.43056, 0, 0, 0.66667],
    176: [0, 0.69444, 0, 0, 0.75],
    177: [0.08333, 0.58333, 0, 0, 0.77778],
    182: [0.19444, 0.69444, 0, 0, 0.61111],
    184: [0.17014, 0, 0, 0, 0.44445],
    198: [0, 0.68333, 0, 0, 0.90278],
    215: [0.08333, 0.58333, 0, 0, 0.77778],
    216: [0.04861, 0.73194, 0, 0, 0.77778],
    223: [0, 0.69444, 0, 0, 0.5],
    230: [0, 0.43056, 0, 0, 0.72222],
    247: [0.08333, 0.58333, 0, 0, 0.77778],
    248: [0.09722, 0.52778, 0, 0, 0.5],
    305: [0, 0.43056, 0, 0, 0.27778],
    338: [0, 0.68333, 0, 0, 1.01389],
    339: [0, 0.43056, 0, 0, 0.77778],
    567: [0.19444, 0.43056, 0, 0, 0.30556],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.62847, 0, 0, 0.5],
    713: [0, 0.56778, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.66786, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.75],
    732: [0, 0.66786, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.68333, 0, 0, 0.625],
    916: [0, 0.68333, 0, 0, 0.83334],
    920: [0, 0.68333, 0, 0, 0.77778],
    923: [0, 0.68333, 0, 0, 0.69445],
    926: [0, 0.68333, 0, 0, 0.66667],
    928: [0, 0.68333, 0, 0, 0.75],
    931: [0, 0.68333, 0, 0, 0.72222],
    933: [0, 0.68333, 0, 0, 0.77778],
    934: [0, 0.68333, 0, 0, 0.72222],
    936: [0, 0.68333, 0, 0, 0.77778],
    937: [0, 0.68333, 0, 0, 0.72222],
    8211: [0, 0.43056, 0.02778, 0, 0.5],
    8212: [0, 0.43056, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5],
    8224: [0.19444, 0.69444, 0, 0, 0.44445],
    8225: [0.19444, 0.69444, 0, 0, 0.44445],
    8230: [0, 0.123, 0, 0, 1.172],
    8242: [0, 0.55556, 0, 0, 0.275],
    8407: [0, 0.71444, 0.15382, 0, 0.5],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8465: [0, 0.69444, 0, 0, 0.72222],
    8467: [0, 0.69444, 0, 0.11111, 0.41667],
    8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
    8476: [0, 0.69444, 0, 0, 0.72222],
    8501: [0, 0.69444, 0, 0, 0.61111],
    8592: [-0.13313, 0.36687, 0, 0, 1],
    8593: [0.19444, 0.69444, 0, 0, 0.5],
    8594: [-0.13313, 0.36687, 0, 0, 1],
    8595: [0.19444, 0.69444, 0, 0, 0.5],
    8596: [-0.13313, 0.36687, 0, 0, 1],
    8597: [0.25, 0.75, 0, 0, 0.5],
    8598: [0.19444, 0.69444, 0, 0, 1],
    8599: [0.19444, 0.69444, 0, 0, 1],
    8600: [0.19444, 0.69444, 0, 0, 1],
    8601: [0.19444, 0.69444, 0, 0, 1],
    8614: [0.011, 0.511, 0, 0, 1],
    8617: [0.011, 0.511, 0, 0, 1.126],
    8618: [0.011, 0.511, 0, 0, 1.126],
    8636: [-0.13313, 0.36687, 0, 0, 1],
    8637: [-0.13313, 0.36687, 0, 0, 1],
    8640: [-0.13313, 0.36687, 0, 0, 1],
    8641: [-0.13313, 0.36687, 0, 0, 1],
    8652: [0.011, 0.671, 0, 0, 1],
    8656: [-0.13313, 0.36687, 0, 0, 1],
    8657: [0.19444, 0.69444, 0, 0, 0.61111],
    8658: [-0.13313, 0.36687, 0, 0, 1],
    8659: [0.19444, 0.69444, 0, 0, 0.61111],
    8660: [-0.13313, 0.36687, 0, 0, 1],
    8661: [0.25, 0.75, 0, 0, 0.61111],
    8704: [0, 0.69444, 0, 0, 0.55556],
    8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
    8707: [0, 0.69444, 0, 0, 0.55556],
    8709: [0.05556, 0.75, 0, 0, 0.5],
    8711: [0, 0.68333, 0, 0, 0.83334],
    8712: [0.0391, 0.5391, 0, 0, 0.66667],
    8715: [0.0391, 0.5391, 0, 0, 0.66667],
    8722: [0.08333, 0.58333, 0, 0, 0.77778],
    8723: [0.08333, 0.58333, 0, 0, 0.77778],
    8725: [0.25, 0.75, 0, 0, 0.5],
    8726: [0.25, 0.75, 0, 0, 0.5],
    8727: [-0.03472, 0.46528, 0, 0, 0.5],
    8728: [-0.05555, 0.44445, 0, 0, 0.5],
    8729: [-0.05555, 0.44445, 0, 0, 0.5],
    8730: [0.2, 0.8, 0, 0, 0.83334],
    8733: [0, 0.43056, 0, 0, 0.77778],
    8734: [0, 0.43056, 0, 0, 1],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.27778],
    8741: [0.25, 0.75, 0, 0, 0.5],
    8743: [0, 0.55556, 0, 0, 0.66667],
    8744: [0, 0.55556, 0, 0, 0.66667],
    8745: [0, 0.55556, 0, 0, 0.66667],
    8746: [0, 0.55556, 0, 0, 0.66667],
    8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8768: [0.19444, 0.69444, 0, 0, 0.27778],
    8771: [-0.03625, 0.46375, 0, 0, 0.77778],
    8773: [-0.022, 0.589, 0, 0, 0.778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8781: [-0.03625, 0.46375, 0, 0, 0.77778],
    8784: [-0.133, 0.673, 0, 0, 0.778],
    8801: [-0.03625, 0.46375, 0, 0, 0.77778],
    8804: [0.13597, 0.63597, 0, 0, 0.77778],
    8805: [0.13597, 0.63597, 0, 0, 0.77778],
    8810: [0.0391, 0.5391, 0, 0, 1],
    8811: [0.0391, 0.5391, 0, 0, 1],
    8826: [0.0391, 0.5391, 0, 0, 0.77778],
    8827: [0.0391, 0.5391, 0, 0, 0.77778],
    8834: [0.0391, 0.5391, 0, 0, 0.77778],
    8835: [0.0391, 0.5391, 0, 0, 0.77778],
    8838: [0.13597, 0.63597, 0, 0, 0.77778],
    8839: [0.13597, 0.63597, 0, 0, 0.77778],
    8846: [0, 0.55556, 0, 0, 0.66667],
    8849: [0.13597, 0.63597, 0, 0, 0.77778],
    8850: [0.13597, 0.63597, 0, 0, 0.77778],
    8851: [0, 0.55556, 0, 0, 0.66667],
    8852: [0, 0.55556, 0, 0, 0.66667],
    8853: [0.08333, 0.58333, 0, 0, 0.77778],
    8854: [0.08333, 0.58333, 0, 0, 0.77778],
    8855: [0.08333, 0.58333, 0, 0, 0.77778],
    8856: [0.08333, 0.58333, 0, 0, 0.77778],
    8857: [0.08333, 0.58333, 0, 0, 0.77778],
    8866: [0, 0.69444, 0, 0, 0.61111],
    8867: [0, 0.69444, 0, 0, 0.61111],
    8868: [0, 0.69444, 0, 0, 0.77778],
    8869: [0, 0.69444, 0, 0, 0.77778],
    8872: [0.249, 0.75, 0, 0, 0.867],
    8900: [-0.05555, 0.44445, 0, 0, 0.5],
    8901: [-0.05555, 0.44445, 0, 0, 0.27778],
    8902: [-0.03472, 0.46528, 0, 0, 0.5],
    8904: [5e-3, 0.505, 0, 0, 0.9],
    8942: [0.03, 0.903, 0, 0, 0.278],
    8943: [-0.19, 0.313, 0, 0, 1.172],
    8945: [-0.1, 0.823, 0, 0, 1.282],
    8968: [0.25, 0.75, 0, 0, 0.44445],
    8969: [0.25, 0.75, 0, 0, 0.44445],
    8970: [0.25, 0.75, 0, 0, 0.44445],
    8971: [0.25, 0.75, 0, 0, 0.44445],
    8994: [-0.14236, 0.35764, 0, 0, 1],
    8995: [-0.14236, 0.35764, 0, 0, 1],
    9136: [0.244, 0.744, 0, 0, 0.412],
    9137: [0.244, 0.745, 0, 0, 0.412],
    9651: [0.19444, 0.69444, 0, 0, 0.88889],
    9657: [-0.03472, 0.46528, 0, 0, 0.5],
    9661: [0.19444, 0.69444, 0, 0, 0.88889],
    9667: [-0.03472, 0.46528, 0, 0, 0.5],
    9711: [0.19444, 0.69444, 0, 0, 1],
    9824: [0.12963, 0.69444, 0, 0, 0.77778],
    9825: [0.12963, 0.69444, 0, 0, 0.77778],
    9826: [0.12963, 0.69444, 0, 0, 0.77778],
    9827: [0.12963, 0.69444, 0, 0, 0.77778],
    9837: [0, 0.75, 0, 0, 0.38889],
    9838: [0.19444, 0.69444, 0, 0, 0.38889],
    9839: [0.19444, 0.69444, 0, 0, 0.38889],
    10216: [0.25, 0.75, 0, 0, 0.38889],
    10217: [0.25, 0.75, 0, 0, 0.38889],
    10222: [0.244, 0.744, 0, 0, 0.412],
    10223: [0.244, 0.745, 0, 0, 0.412],
    10229: [0.011, 0.511, 0, 0, 1.609],
    10230: [0.011, 0.511, 0, 0, 1.638],
    10231: [0.011, 0.511, 0, 0, 1.859],
    10232: [0.024, 0.525, 0, 0, 1.609],
    10233: [0.024, 0.525, 0, 0, 1.638],
    10234: [0.024, 0.525, 0, 0, 1.858],
    10236: [0.011, 0.511, 0, 0, 1.638],
    10815: [0, 0.68333, 0, 0, 0.75],
    10927: [0.13597, 0.63597, 0, 0, 0.77778],
    10928: [0.13597, 0.63597, 0, 0, 0.77778],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.44444, 0, 0, 0.575],
    49: [0, 0.44444, 0, 0, 0.575],
    50: [0, 0.44444, 0, 0, 0.575],
    51: [0.19444, 0.44444, 0, 0, 0.575],
    52: [0.19444, 0.44444, 0, 0, 0.575],
    53: [0.19444, 0.44444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0.19444, 0.44444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0.19444, 0.44444, 0, 0, 0.575],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0.04835, 0, 0.8664],
    67: [0, 0.68611, 0.06979, 0, 0.81694],
    68: [0, 0.68611, 0.03194, 0, 0.93812],
    69: [0, 0.68611, 0.05451, 0, 0.81007],
    70: [0, 0.68611, 0.15972, 0, 0.68889],
    71: [0, 0.68611, 0, 0, 0.88673],
    72: [0, 0.68611, 0.08229, 0, 0.98229],
    73: [0, 0.68611, 0.07778, 0, 0.51111],
    74: [0, 0.68611, 0.10069, 0, 0.63125],
    75: [0, 0.68611, 0.06979, 0, 0.97118],
    76: [0, 0.68611, 0, 0, 0.75555],
    77: [0, 0.68611, 0.11424, 0, 1.14201],
    78: [0, 0.68611, 0.11424, 0, 0.95034],
    79: [0, 0.68611, 0.03194, 0, 0.83666],
    80: [0, 0.68611, 0.15972, 0, 0.72309],
    81: [0.19444, 0.68611, 0, 0, 0.86861],
    82: [0, 0.68611, 421e-5, 0, 0.87235],
    83: [0, 0.68611, 0.05382, 0, 0.69271],
    84: [0, 0.68611, 0.15972, 0, 0.63663],
    85: [0, 0.68611, 0.11424, 0, 0.80027],
    86: [0, 0.68611, 0.25555, 0, 0.67778],
    87: [0, 0.68611, 0.15972, 0, 1.09305],
    88: [0, 0.68611, 0.07778, 0, 0.94722],
    89: [0, 0.68611, 0.25555, 0, 0.67458],
    90: [0, 0.68611, 0.06979, 0, 0.77257],
    97: [0, 0.44444, 0, 0, 0.63287],
    98: [0, 0.69444, 0, 0, 0.52083],
    99: [0, 0.44444, 0, 0, 0.51342],
    100: [0, 0.69444, 0, 0, 0.60972],
    101: [0, 0.44444, 0, 0, 0.55361],
    102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
    103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
    104: [0, 0.69444, 0, 0, 0.66759],
    105: [0, 0.69326, 0, 0, 0.4048],
    106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
    107: [0, 0.69444, 0.01852, 0, 0.6037],
    108: [0, 0.69444, 88e-4, 0, 0.34815],
    109: [0, 0.44444, 0, 0, 1.0324],
    110: [0, 0.44444, 0, 0, 0.71296],
    111: [0, 0.44444, 0, 0, 0.58472],
    112: [0.19444, 0.44444, 0, 0, 0.60092],
    113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
    114: [0, 0.44444, 0.03194, 0, 0.5287],
    115: [0, 0.44444, 0, 0, 0.53125],
    116: [0, 0.63492, 0, 0, 0.41528],
    117: [0, 0.44444, 0, 0, 0.68102],
    118: [0, 0.44444, 0.03704, 0, 0.56666],
    119: [0, 0.44444, 0.02778, 0, 0.83148],
    120: [0, 0.44444, 0, 0, 0.65903],
    121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
    122: [0, 0.44444, 0.04213, 0, 0.55509],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68611, 0.15972, 0, 0.65694],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0.03194, 0, 0.86722],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0.07458, 0, 0.84125],
    928: [0, 0.68611, 0.08229, 0, 0.98229],
    931: [0, 0.68611, 0.05451, 0, 0.88507],
    933: [0, 0.68611, 0.15972, 0, 0.67083],
    934: [0, 0.68611, 0, 0, 0.76666],
    936: [0, 0.68611, 0.11653, 0, 0.71402],
    937: [0, 0.68611, 0.04835, 0, 0.8789],
    945: [0, 0.44444, 0, 0, 0.76064],
    946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
    947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
    948: [0, 0.69444, 0.03819, 0, 0.52222],
    949: [0, 0.44444, 0, 0, 0.52882],
    950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
    951: [0.19444, 0.44444, 0.03704, 0, 0.6],
    952: [0, 0.69444, 0.03194, 0, 0.5618],
    953: [0, 0.44444, 0, 0, 0.41204],
    954: [0, 0.44444, 0, 0, 0.66759],
    955: [0, 0.69444, 0, 0, 0.67083],
    956: [0.19444, 0.44444, 0, 0, 0.70787],
    957: [0, 0.44444, 0.06898, 0, 0.57685],
    958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
    959: [0, 0.44444, 0, 0, 0.58472],
    960: [0, 0.44444, 0.03704, 0, 0.68241],
    961: [0.19444, 0.44444, 0, 0, 0.6118],
    962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
    963: [0, 0.44444, 0.03704, 0, 0.68588],
    964: [0, 0.44444, 0.13472, 0, 0.52083],
    965: [0, 0.44444, 0.03704, 0, 0.63055],
    966: [0.19444, 0.44444, 0, 0, 0.74722],
    967: [0.19444, 0.44444, 0, 0, 0.71805],
    968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
    969: [0, 0.44444, 0.03704, 0, 0.71782],
    977: [0, 0.69444, 0, 0, 0.69155],
    981: [0.19444, 0.69444, 0, 0, 0.7125],
    982: [0, 0.44444, 0.03194, 0, 0.975],
    1009: [0.19444, 0.44444, 0, 0, 0.6118],
    1013: [0, 0.44444, 0, 0, 0.48333],
    57649: [0, 0.44444, 0, 0, 0.39352],
    57911: [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.43056, 0, 0, 0.5],
    49: [0, 0.43056, 0, 0, 0.5],
    50: [0, 0.43056, 0, 0, 0.5],
    51: [0.19444, 0.43056, 0, 0, 0.5],
    52: [0.19444, 0.43056, 0, 0, 0.5],
    53: [0.19444, 0.43056, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0.19444, 0.43056, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0.19444, 0.43056, 0, 0, 0.5],
    65: [0, 0.68333, 0, 0.13889, 0.75],
    66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
    67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
    68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
    69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
    70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
    71: [0, 0.68333, 0, 0.08334, 0.78625],
    72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
    74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
    75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
    76: [0, 0.68333, 0, 0.02778, 0.68056],
    77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
    78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
    79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
    81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
    82: [0, 0.68333, 773e-5, 0.08334, 0.75929],
    83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
    84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
    85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
    86: [0, 0.68333, 0.22222, 0, 0.58333],
    87: [0, 0.68333, 0.13889, 0, 0.94445],
    88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
    89: [0, 0.68333, 0.22222, 0, 0.58056],
    90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
    97: [0, 0.43056, 0, 0, 0.52859],
    98: [0, 0.69444, 0, 0, 0.42917],
    99: [0, 0.43056, 0, 0.05556, 0.43276],
    100: [0, 0.69444, 0, 0.16667, 0.52049],
    101: [0, 0.43056, 0, 0.05556, 0.46563],
    102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    104: [0, 0.69444, 0, 0, 0.57616],
    105: [0, 0.65952, 0, 0, 0.34451],
    106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
    107: [0, 0.69444, 0.03148, 0, 0.5206],
    108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
    109: [0, 0.43056, 0, 0, 0.87801],
    110: [0, 0.43056, 0, 0, 0.60023],
    111: [0, 0.43056, 0, 0.05556, 0.48472],
    112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
    113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
    115: [0, 0.43056, 0, 0.05556, 0.46875],
    116: [0, 0.61508, 0, 0.08334, 0.36111],
    117: [0, 0.43056, 0, 0.02778, 0.57246],
    118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
    119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
    120: [0, 0.43056, 0, 0.02778, 0.57153],
    121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
    916: [0, 0.68333, 0, 0.16667, 0.83334],
    920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    923: [0, 0.68333, 0, 0.16667, 0.69445],
    926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
    928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
    933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
    934: [0, 0.68333, 0, 0.08334, 0.66667],
    936: [0, 0.68333, 0.11, 0.05556, 0.61222],
    937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
    945: [0, 0.43056, 37e-4, 0.02778, 0.6397],
    946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
    948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
    949: [0, 0.43056, 0, 0.08334, 0.46632],
    950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
    953: [0, 0.43056, 0, 0.05556, 0.35394],
    954: [0, 0.43056, 0, 0, 0.57616],
    955: [0, 0.69444, 0, 0, 0.58334],
    956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
    957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
    958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    959: [0, 0.43056, 0, 0.05556, 0.48472],
    960: [0, 0.43056, 0.03588, 0, 0.57003],
    961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    963: [0, 0.43056, 0.03588, 0, 0.57141],
    964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
    965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
    966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
    967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
    968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    969: [0, 0.43056, 0.03588, 0, 0.62245],
    977: [0, 0.69444, 0, 0.08334, 0.59144],
    981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
    982: [0, 0.43056, 0.02778, 0, 0.82813],
    1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    1013: [0, 0.43056, 0, 0.05556, 0.4059],
    57649: [0, 0.43056, 0, 0.02778, 0.32246],
    57911: [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.36667],
    34: [0, 0.69444, 0, 0, 0.55834],
    35: [0.19444, 0.69444, 0, 0, 0.91667],
    36: [0.05556, 0.75, 0, 0, 0.55],
    37: [0.05556, 0.75, 0, 0, 1.02912],
    38: [0, 0.69444, 0, 0, 0.83056],
    39: [0, 0.69444, 0, 0, 0.30556],
    40: [0.25, 0.75, 0, 0, 0.42778],
    41: [0.25, 0.75, 0, 0, 0.42778],
    42: [0, 0.75, 0, 0, 0.55],
    43: [0.11667, 0.61667, 0, 0, 0.85556],
    44: [0.10556, 0.13056, 0, 0, 0.30556],
    45: [0, 0.45833, 0, 0, 0.36667],
    46: [0, 0.13056, 0, 0, 0.30556],
    47: [0.25, 0.75, 0, 0, 0.55],
    48: [0, 0.69444, 0, 0, 0.55],
    49: [0, 0.69444, 0, 0, 0.55],
    50: [0, 0.69444, 0, 0, 0.55],
    51: [0, 0.69444, 0, 0, 0.55],
    52: [0, 0.69444, 0, 0, 0.55],
    53: [0, 0.69444, 0, 0, 0.55],
    54: [0, 0.69444, 0, 0, 0.55],
    55: [0, 0.69444, 0, 0, 0.55],
    56: [0, 0.69444, 0, 0, 0.55],
    57: [0, 0.69444, 0, 0, 0.55],
    58: [0, 0.45833, 0, 0, 0.30556],
    59: [0.10556, 0.45833, 0, 0, 0.30556],
    61: [-0.09375, 0.40625, 0, 0, 0.85556],
    63: [0, 0.69444, 0, 0, 0.51945],
    64: [0, 0.69444, 0, 0, 0.73334],
    65: [0, 0.69444, 0, 0, 0.73334],
    66: [0, 0.69444, 0, 0, 0.73334],
    67: [0, 0.69444, 0, 0, 0.70278],
    68: [0, 0.69444, 0, 0, 0.79445],
    69: [0, 0.69444, 0, 0, 0.64167],
    70: [0, 0.69444, 0, 0, 0.61111],
    71: [0, 0.69444, 0, 0, 0.73334],
    72: [0, 0.69444, 0, 0, 0.79445],
    73: [0, 0.69444, 0, 0, 0.33056],
    74: [0, 0.69444, 0, 0, 0.51945],
    75: [0, 0.69444, 0, 0, 0.76389],
    76: [0, 0.69444, 0, 0, 0.58056],
    77: [0, 0.69444, 0, 0, 0.97778],
    78: [0, 0.69444, 0, 0, 0.79445],
    79: [0, 0.69444, 0, 0, 0.79445],
    80: [0, 0.69444, 0, 0, 0.70278],
    81: [0.10556, 0.69444, 0, 0, 0.79445],
    82: [0, 0.69444, 0, 0, 0.70278],
    83: [0, 0.69444, 0, 0, 0.61111],
    84: [0, 0.69444, 0, 0, 0.73334],
    85: [0, 0.69444, 0, 0, 0.76389],
    86: [0, 0.69444, 0.01528, 0, 0.73334],
    87: [0, 0.69444, 0.01528, 0, 1.03889],
    88: [0, 0.69444, 0, 0, 0.73334],
    89: [0, 0.69444, 0.0275, 0, 0.73334],
    90: [0, 0.69444, 0, 0, 0.67223],
    91: [0.25, 0.75, 0, 0, 0.34306],
    93: [0.25, 0.75, 0, 0, 0.34306],
    94: [0, 0.69444, 0, 0, 0.55],
    95: [0.35, 0.10833, 0.03056, 0, 0.55],
    97: [0, 0.45833, 0, 0, 0.525],
    98: [0, 0.69444, 0, 0, 0.56111],
    99: [0, 0.45833, 0, 0, 0.48889],
    100: [0, 0.69444, 0, 0, 0.56111],
    101: [0, 0.45833, 0, 0, 0.51111],
    102: [0, 0.69444, 0.07639, 0, 0.33611],
    103: [0.19444, 0.45833, 0.01528, 0, 0.55],
    104: [0, 0.69444, 0, 0, 0.56111],
    105: [0, 0.69444, 0, 0, 0.25556],
    106: [0.19444, 0.69444, 0, 0, 0.28611],
    107: [0, 0.69444, 0, 0, 0.53056],
    108: [0, 0.69444, 0, 0, 0.25556],
    109: [0, 0.45833, 0, 0, 0.86667],
    110: [0, 0.45833, 0, 0, 0.56111],
    111: [0, 0.45833, 0, 0, 0.55],
    112: [0.19444, 0.45833, 0, 0, 0.56111],
    113: [0.19444, 0.45833, 0, 0, 0.56111],
    114: [0, 0.45833, 0.01528, 0, 0.37222],
    115: [0, 0.45833, 0, 0, 0.42167],
    116: [0, 0.58929, 0, 0, 0.40417],
    117: [0, 0.45833, 0, 0, 0.56111],
    118: [0, 0.45833, 0.01528, 0, 0.5],
    119: [0, 0.45833, 0.01528, 0, 0.74445],
    120: [0, 0.45833, 0, 0, 0.5],
    121: [0.19444, 0.45833, 0.01528, 0, 0.5],
    122: [0, 0.45833, 0, 0, 0.47639],
    126: [0.35, 0.34444, 0, 0, 0.55],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0, 0, 0.55],
    176: [0, 0.69444, 0, 0, 0.73334],
    180: [0, 0.69444, 0, 0, 0.55],
    184: [0.17014, 0, 0, 0, 0.48889],
    305: [0, 0.45833, 0, 0, 0.25556],
    567: [0.19444, 0.45833, 0, 0, 0.28611],
    710: [0, 0.69444, 0, 0, 0.55],
    711: [0, 0.63542, 0, 0, 0.55],
    713: [0, 0.63778, 0, 0, 0.55],
    728: [0, 0.69444, 0, 0, 0.55],
    729: [0, 0.69444, 0, 0, 0.30556],
    730: [0, 0.69444, 0, 0, 0.73334],
    732: [0, 0.69444, 0, 0, 0.55],
    733: [0, 0.69444, 0, 0, 0.55],
    915: [0, 0.69444, 0, 0, 0.58056],
    916: [0, 0.69444, 0, 0, 0.91667],
    920: [0, 0.69444, 0, 0, 0.85556],
    923: [0, 0.69444, 0, 0, 0.67223],
    926: [0, 0.69444, 0, 0, 0.73334],
    928: [0, 0.69444, 0, 0, 0.79445],
    931: [0, 0.69444, 0, 0, 0.79445],
    933: [0, 0.69444, 0, 0, 0.85556],
    934: [0, 0.69444, 0, 0, 0.79445],
    936: [0, 0.69444, 0, 0, 0.85556],
    937: [0, 0.69444, 0, 0, 0.79445],
    8211: [0, 0.45833, 0.03056, 0, 0.55],
    8212: [0, 0.45833, 0.03056, 0, 1.10001],
    8216: [0, 0.69444, 0, 0, 0.30556],
    8217: [0, 0.69444, 0, 0, 0.30556],
    8220: [0, 0.69444, 0, 0, 0.55834],
    8221: [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.05733, 0, 0.31945],
    34: [0, 0.69444, 316e-5, 0, 0.5],
    35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
    36: [0.05556, 0.75, 0.11156, 0, 0.5],
    37: [0.05556, 0.75, 0.03126, 0, 0.83334],
    38: [0, 0.69444, 0.03058, 0, 0.75834],
    39: [0, 0.69444, 0.07816, 0, 0.27778],
    40: [0.25, 0.75, 0.13164, 0, 0.38889],
    41: [0.25, 0.75, 0.02536, 0, 0.38889],
    42: [0, 0.75, 0.11775, 0, 0.5],
    43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0.01946, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0.13164, 0, 0.5],
    48: [0, 0.65556, 0.11156, 0, 0.5],
    49: [0, 0.65556, 0.11156, 0, 0.5],
    50: [0, 0.65556, 0.11156, 0, 0.5],
    51: [0, 0.65556, 0.11156, 0, 0.5],
    52: [0, 0.65556, 0.11156, 0, 0.5],
    53: [0, 0.65556, 0.11156, 0, 0.5],
    54: [0, 0.65556, 0.11156, 0, 0.5],
    55: [0, 0.65556, 0.11156, 0, 0.5],
    56: [0, 0.65556, 0.11156, 0, 0.5],
    57: [0, 0.65556, 0.11156, 0, 0.5],
    58: [0, 0.44444, 0.02502, 0, 0.27778],
    59: [0.125, 0.44444, 0.02502, 0, 0.27778],
    61: [-0.13, 0.37, 0.05087, 0, 0.77778],
    63: [0, 0.69444, 0.11809, 0, 0.47222],
    64: [0, 0.69444, 0.07555, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0.08293, 0, 0.66667],
    67: [0, 0.69444, 0.11983, 0, 0.63889],
    68: [0, 0.69444, 0.07555, 0, 0.72223],
    69: [0, 0.69444, 0.11983, 0, 0.59722],
    70: [0, 0.69444, 0.13372, 0, 0.56945],
    71: [0, 0.69444, 0.11983, 0, 0.66667],
    72: [0, 0.69444, 0.08094, 0, 0.70834],
    73: [0, 0.69444, 0.13372, 0, 0.27778],
    74: [0, 0.69444, 0.08094, 0, 0.47222],
    75: [0, 0.69444, 0.11983, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0.08094, 0, 0.875],
    78: [0, 0.69444, 0.08094, 0, 0.70834],
    79: [0, 0.69444, 0.07555, 0, 0.73611],
    80: [0, 0.69444, 0.08293, 0, 0.63889],
    81: [0.125, 0.69444, 0.07555, 0, 0.73611],
    82: [0, 0.69444, 0.08293, 0, 0.64584],
    83: [0, 0.69444, 0.09205, 0, 0.55556],
    84: [0, 0.69444, 0.13372, 0, 0.68056],
    85: [0, 0.69444, 0.08094, 0, 0.6875],
    86: [0, 0.69444, 0.1615, 0, 0.66667],
    87: [0, 0.69444, 0.1615, 0, 0.94445],
    88: [0, 0.69444, 0.13372, 0, 0.66667],
    89: [0, 0.69444, 0.17261, 0, 0.66667],
    90: [0, 0.69444, 0.11983, 0, 0.61111],
    91: [0.25, 0.75, 0.15942, 0, 0.28889],
    93: [0.25, 0.75, 0.08719, 0, 0.28889],
    94: [0, 0.69444, 0.0799, 0, 0.5],
    95: [0.35, 0.09444, 0.08616, 0, 0.5],
    97: [0, 0.44444, 981e-5, 0, 0.48056],
    98: [0, 0.69444, 0.03057, 0, 0.51667],
    99: [0, 0.44444, 0.08336, 0, 0.44445],
    100: [0, 0.69444, 0.09483, 0, 0.51667],
    101: [0, 0.44444, 0.06778, 0, 0.44445],
    102: [0, 0.69444, 0.21705, 0, 0.30556],
    103: [0.19444, 0.44444, 0.10836, 0, 0.5],
    104: [0, 0.69444, 0.01778, 0, 0.51667],
    105: [0, 0.67937, 0.09718, 0, 0.23889],
    106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
    107: [0, 0.69444, 0.08336, 0, 0.48889],
    108: [0, 0.69444, 0.09483, 0, 0.23889],
    109: [0, 0.44444, 0.01778, 0, 0.79445],
    110: [0, 0.44444, 0.01778, 0, 0.51667],
    111: [0, 0.44444, 0.06613, 0, 0.5],
    112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
    113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
    114: [0, 0.44444, 0.10836, 0, 0.34167],
    115: [0, 0.44444, 0.0778, 0, 0.38333],
    116: [0, 0.57143, 0.07225, 0, 0.36111],
    117: [0, 0.44444, 0.04169, 0, 0.51667],
    118: [0, 0.44444, 0.10836, 0, 0.46111],
    119: [0, 0.44444, 0.10836, 0, 0.68334],
    120: [0, 0.44444, 0.09169, 0, 0.46111],
    121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
    122: [0, 0.44444, 0.08752, 0, 0.43472],
    126: [0.35, 0.32659, 0.08826, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0.06385, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.73752],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0.04169, 0, 0.23889],
    567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
    710: [0, 0.69444, 0.0799, 0, 0.5],
    711: [0, 0.63194, 0.08432, 0, 0.5],
    713: [0, 0.60889, 0.08776, 0, 0.5],
    714: [0, 0.69444, 0.09205, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0.09483, 0, 0.5],
    729: [0, 0.67937, 0.07774, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.73752],
    732: [0, 0.67659, 0.08826, 0, 0.5],
    733: [0, 0.69444, 0.09205, 0, 0.5],
    915: [0, 0.69444, 0.13372, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0.07555, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0.12816, 0, 0.66667],
    928: [0, 0.69444, 0.08094, 0, 0.70834],
    931: [0, 0.69444, 0.11983, 0, 0.72222],
    933: [0, 0.69444, 0.09031, 0, 0.77778],
    934: [0, 0.69444, 0.04603, 0, 0.72222],
    936: [0, 0.69444, 0.09031, 0, 0.77778],
    937: [0, 0.69444, 0.08293, 0, 0.72222],
    8211: [0, 0.44444, 0.08616, 0, 0.5],
    8212: [0, 0.44444, 0.08616, 0, 1],
    8216: [0, 0.69444, 0.07816, 0, 0.27778],
    8217: [0, 0.69444, 0.07816, 0, 0.27778],
    8220: [0, 0.69444, 0.14205, 0, 0.5],
    8221: [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.31945],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.75834],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.65556, 0, 0, 0.5],
    49: [0, 0.65556, 0, 0, 0.5],
    50: [0, 0.65556, 0, 0, 0.5],
    51: [0, 0.65556, 0, 0, 0.5],
    52: [0, 0.65556, 0, 0, 0.5],
    53: [0, 0.65556, 0, 0, 0.5],
    54: [0, 0.65556, 0, 0, 0.5],
    55: [0, 0.65556, 0, 0, 0.5],
    56: [0, 0.65556, 0, 0, 0.5],
    57: [0, 0.65556, 0, 0, 0.5],
    58: [0, 0.44444, 0, 0, 0.27778],
    59: [0.125, 0.44444, 0, 0, 0.27778],
    61: [-0.13, 0.37, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0, 0, 0.66667],
    67: [0, 0.69444, 0, 0, 0.63889],
    68: [0, 0.69444, 0, 0, 0.72223],
    69: [0, 0.69444, 0, 0, 0.59722],
    70: [0, 0.69444, 0, 0, 0.56945],
    71: [0, 0.69444, 0, 0, 0.66667],
    72: [0, 0.69444, 0, 0, 0.70834],
    73: [0, 0.69444, 0, 0, 0.27778],
    74: [0, 0.69444, 0, 0, 0.47222],
    75: [0, 0.69444, 0, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0, 0, 0.875],
    78: [0, 0.69444, 0, 0, 0.70834],
    79: [0, 0.69444, 0, 0, 0.73611],
    80: [0, 0.69444, 0, 0, 0.63889],
    81: [0.125, 0.69444, 0, 0, 0.73611],
    82: [0, 0.69444, 0, 0, 0.64584],
    83: [0, 0.69444, 0, 0, 0.55556],
    84: [0, 0.69444, 0, 0, 0.68056],
    85: [0, 0.69444, 0, 0, 0.6875],
    86: [0, 0.69444, 0.01389, 0, 0.66667],
    87: [0, 0.69444, 0.01389, 0, 0.94445],
    88: [0, 0.69444, 0, 0, 0.66667],
    89: [0, 0.69444, 0.025, 0, 0.66667],
    90: [0, 0.69444, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.28889],
    93: [0.25, 0.75, 0, 0, 0.28889],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.35, 0.09444, 0.02778, 0, 0.5],
    97: [0, 0.44444, 0, 0, 0.48056],
    98: [0, 0.69444, 0, 0, 0.51667],
    99: [0, 0.44444, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.51667],
    101: [0, 0.44444, 0, 0, 0.44445],
    102: [0, 0.69444, 0.06944, 0, 0.30556],
    103: [0.19444, 0.44444, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.51667],
    105: [0, 0.67937, 0, 0, 0.23889],
    106: [0.19444, 0.67937, 0, 0, 0.26667],
    107: [0, 0.69444, 0, 0, 0.48889],
    108: [0, 0.69444, 0, 0, 0.23889],
    109: [0, 0.44444, 0, 0, 0.79445],
    110: [0, 0.44444, 0, 0, 0.51667],
    111: [0, 0.44444, 0, 0, 0.5],
    112: [0.19444, 0.44444, 0, 0, 0.51667],
    113: [0.19444, 0.44444, 0, 0, 0.51667],
    114: [0, 0.44444, 0.01389, 0, 0.34167],
    115: [0, 0.44444, 0, 0, 0.38333],
    116: [0, 0.57143, 0, 0, 0.36111],
    117: [0, 0.44444, 0, 0, 0.51667],
    118: [0, 0.44444, 0.01389, 0, 0.46111],
    119: [0, 0.44444, 0.01389, 0, 0.68334],
    120: [0, 0.44444, 0, 0, 0.46111],
    121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
    122: [0, 0.44444, 0, 0, 0.43472],
    126: [0.35, 0.32659, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.66667],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0, 0, 0.23889],
    567: [0.19444, 0.44444, 0, 0, 0.26667],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.63194, 0, 0, 0.5],
    713: [0, 0.60889, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.67937, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.66667],
    732: [0, 0.67659, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.69444, 0, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0, 0, 0.66667],
    928: [0, 0.69444, 0, 0, 0.70834],
    931: [0, 0.69444, 0, 0, 0.72222],
    933: [0, 0.69444, 0, 0, 0.77778],
    934: [0, 0.69444, 0, 0, 0.72222],
    936: [0, 0.69444, 0, 0, 0.77778],
    937: [0, 0.69444, 0, 0, 0.72222],
    8211: [0, 0.44444, 0.02778, 0, 0.5],
    8212: [0, 0.44444, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.7, 0.22925, 0, 0.80253],
    66: [0, 0.7, 0.04087, 0, 0.90757],
    67: [0, 0.7, 0.1689, 0, 0.66619],
    68: [0, 0.7, 0.09371, 0, 0.77443],
    69: [0, 0.7, 0.18583, 0, 0.56162],
    70: [0, 0.7, 0.13634, 0, 0.89544],
    71: [0, 0.7, 0.17322, 0, 0.60961],
    72: [0, 0.7, 0.29694, 0, 0.96919],
    73: [0, 0.7, 0.19189, 0, 0.80907],
    74: [0.27778, 0.7, 0.19189, 0, 1.05159],
    75: [0, 0.7, 0.31259, 0, 0.91364],
    76: [0, 0.7, 0.19189, 0, 0.87373],
    77: [0, 0.7, 0.15981, 0, 1.08031],
    78: [0, 0.7, 0.3525, 0, 0.9015],
    79: [0, 0.7, 0.08078, 0, 0.73787],
    80: [0, 0.7, 0.08078, 0, 1.01262],
    81: [0, 0.7, 0.03305, 0, 0.88282],
    82: [0, 0.7, 0.06259, 0, 0.85],
    83: [0, 0.7, 0.19189, 0, 0.86767],
    84: [0, 0.7, 0.29087, 0, 0.74697],
    85: [0, 0.7, 0.25815, 0, 0.79996],
    86: [0, 0.7, 0.27523, 0, 0.62204],
    87: [0, 0.7, 0.27523, 0, 0.80532],
    88: [0, 0.7, 0.26006, 0, 0.94445],
    89: [0, 0.7, 0.2939, 0, 0.70961],
    90: [0, 0.7, 0.24037, 0, 0.8212],
    160: [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.35001, 0.85, 0, 0, 0.45834],
    41: [0.35001, 0.85, 0, 0, 0.45834],
    47: [0.35001, 0.85, 0, 0, 0.57778],
    91: [0.35001, 0.85, 0, 0, 0.41667],
    92: [0.35001, 0.85, 0, 0, 0.57778],
    93: [0.35001, 0.85, 0, 0, 0.41667],
    123: [0.35001, 0.85, 0, 0, 0.58334],
    125: [0.35001, 0.85, 0, 0, 0.58334],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.72222, 0, 0, 0.55556],
    732: [0, 0.72222, 0, 0, 0.55556],
    770: [0, 0.72222, 0, 0, 0.55556],
    771: [0, 0.72222, 0, 0, 0.55556],
    8214: [-99e-5, 0.601, 0, 0, 0.77778],
    8593: [1e-5, 0.6, 0, 0, 0.66667],
    8595: [1e-5, 0.6, 0, 0, 0.66667],
    8657: [1e-5, 0.6, 0, 0, 0.77778],
    8659: [1e-5, 0.6, 0, 0, 0.77778],
    8719: [0.25001, 0.75, 0, 0, 0.94445],
    8720: [0.25001, 0.75, 0, 0, 0.94445],
    8721: [0.25001, 0.75, 0, 0, 1.05556],
    8730: [0.35001, 0.85, 0, 0, 1],
    8739: [-599e-5, 0.606, 0, 0, 0.33333],
    8741: [-599e-5, 0.606, 0, 0, 0.55556],
    8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8748: [0.306, 0.805, 0.19445, 0, 0.47222],
    8749: [0.306, 0.805, 0.19445, 0, 0.47222],
    8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8896: [0.25001, 0.75, 0, 0, 0.83334],
    8897: [0.25001, 0.75, 0, 0, 0.83334],
    8898: [0.25001, 0.75, 0, 0, 0.83334],
    8899: [0.25001, 0.75, 0, 0, 0.83334],
    8968: [0.35001, 0.85, 0, 0, 0.47222],
    8969: [0.35001, 0.85, 0, 0, 0.47222],
    8970: [0.35001, 0.85, 0, 0, 0.47222],
    8971: [0.35001, 0.85, 0, 0, 0.47222],
    9168: [-99e-5, 0.601, 0, 0, 0.66667],
    10216: [0.35001, 0.85, 0, 0, 0.47222],
    10217: [0.35001, 0.85, 0, 0, 0.47222],
    10752: [0.25001, 0.75, 0, 0, 1.11111],
    10753: [0.25001, 0.75, 0, 0, 1.11111],
    10754: [0.25001, 0.75, 0, 0, 1.11111],
    10756: [0.25001, 0.75, 0, 0, 0.83334],
    10758: [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.65002, 1.15, 0, 0, 0.59722],
    41: [0.65002, 1.15, 0, 0, 0.59722],
    47: [0.65002, 1.15, 0, 0, 0.81111],
    91: [0.65002, 1.15, 0, 0, 0.47222],
    92: [0.65002, 1.15, 0, 0, 0.81111],
    93: [0.65002, 1.15, 0, 0, 0.47222],
    123: [0.65002, 1.15, 0, 0, 0.66667],
    125: [0.65002, 1.15, 0, 0, 0.66667],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1],
    732: [0, 0.75, 0, 0, 1],
    770: [0, 0.75, 0, 0, 1],
    771: [0, 0.75, 0, 0, 1],
    8719: [0.55001, 1.05, 0, 0, 1.27778],
    8720: [0.55001, 1.05, 0, 0, 1.27778],
    8721: [0.55001, 1.05, 0, 0, 1.44445],
    8730: [0.65002, 1.15, 0, 0, 1],
    8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8748: [0.862, 1.36, 0.44445, 0, 0.55556],
    8749: [0.862, 1.36, 0.44445, 0, 0.55556],
    8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8896: [0.55001, 1.05, 0, 0, 1.11111],
    8897: [0.55001, 1.05, 0, 0, 1.11111],
    8898: [0.55001, 1.05, 0, 0, 1.11111],
    8899: [0.55001, 1.05, 0, 0, 1.11111],
    8968: [0.65002, 1.15, 0, 0, 0.52778],
    8969: [0.65002, 1.15, 0, 0, 0.52778],
    8970: [0.65002, 1.15, 0, 0, 0.52778],
    8971: [0.65002, 1.15, 0, 0, 0.52778],
    10216: [0.65002, 1.15, 0, 0, 0.61111],
    10217: [0.65002, 1.15, 0, 0, 0.61111],
    10752: [0.55001, 1.05, 0, 0, 1.51112],
    10753: [0.55001, 1.05, 0, 0, 1.51112],
    10754: [0.55001, 1.05, 0, 0, 1.51112],
    10756: [0.55001, 1.05, 0, 0, 1.11111],
    10758: [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.95003, 1.45, 0, 0, 0.73611],
    41: [0.95003, 1.45, 0, 0, 0.73611],
    47: [0.95003, 1.45, 0, 0, 1.04445],
    91: [0.95003, 1.45, 0, 0, 0.52778],
    92: [0.95003, 1.45, 0, 0, 1.04445],
    93: [0.95003, 1.45, 0, 0, 0.52778],
    123: [0.95003, 1.45, 0, 0, 0.75],
    125: [0.95003, 1.45, 0, 0, 0.75],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1.44445],
    732: [0, 0.75, 0, 0, 1.44445],
    770: [0, 0.75, 0, 0, 1.44445],
    771: [0, 0.75, 0, 0, 1.44445],
    8730: [0.95003, 1.45, 0, 0, 1],
    8968: [0.95003, 1.45, 0, 0, 0.58334],
    8969: [0.95003, 1.45, 0, 0, 0.58334],
    8970: [0.95003, 1.45, 0, 0, 0.58334],
    8971: [0.95003, 1.45, 0, 0, 0.58334],
    10216: [0.95003, 1.45, 0, 0, 0.75],
    10217: [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [1.25003, 1.75, 0, 0, 0.79167],
    41: [1.25003, 1.75, 0, 0, 0.79167],
    47: [1.25003, 1.75, 0, 0, 1.27778],
    91: [1.25003, 1.75, 0, 0, 0.58334],
    92: [1.25003, 1.75, 0, 0, 1.27778],
    93: [1.25003, 1.75, 0, 0, 0.58334],
    123: [1.25003, 1.75, 0, 0, 0.80556],
    125: [1.25003, 1.75, 0, 0, 0.80556],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.825, 0, 0, 1.8889],
    732: [0, 0.825, 0, 0, 1.8889],
    770: [0, 0.825, 0, 0, 1.8889],
    771: [0, 0.825, 0, 0, 1.8889],
    8730: [1.25003, 1.75, 0, 0, 1],
    8968: [1.25003, 1.75, 0, 0, 0.63889],
    8969: [1.25003, 1.75, 0, 0, 0.63889],
    8970: [1.25003, 1.75, 0, 0, 0.63889],
    8971: [1.25003, 1.75, 0, 0, 0.63889],
    9115: [0.64502, 1.155, 0, 0, 0.875],
    9116: [1e-5, 0.6, 0, 0, 0.875],
    9117: [0.64502, 1.155, 0, 0, 0.875],
    9118: [0.64502, 1.155, 0, 0, 0.875],
    9119: [1e-5, 0.6, 0, 0, 0.875],
    9120: [0.64502, 1.155, 0, 0, 0.875],
    9121: [0.64502, 1.155, 0, 0, 0.66667],
    9122: [-99e-5, 0.601, 0, 0, 0.66667],
    9123: [0.64502, 1.155, 0, 0, 0.66667],
    9124: [0.64502, 1.155, 0, 0, 0.66667],
    9125: [-99e-5, 0.601, 0, 0, 0.66667],
    9126: [0.64502, 1.155, 0, 0, 0.66667],
    9127: [1e-5, 0.9, 0, 0, 0.88889],
    9128: [0.65002, 1.15, 0, 0, 0.88889],
    9129: [0.90001, 0, 0, 0, 0.88889],
    9130: [0, 0.3, 0, 0, 0.88889],
    9131: [1e-5, 0.9, 0, 0, 0.88889],
    9132: [0.65002, 1.15, 0, 0, 0.88889],
    9133: [0.90001, 0, 0, 0, 0.88889],
    9143: [0.88502, 0.915, 0, 0, 1.05556],
    10216: [1.25003, 1.75, 0, 0, 0.80556],
    10217: [1.25003, 1.75, 0, 0, 0.80556],
    57344: [-499e-5, 0.605, 0, 0, 1.05556],
    57345: [-499e-5, 0.605, 0, 0, 1.05556],
    57680: [0, 0.12, 0, 0, 0.45],
    57681: [0, 0.12, 0, 0, 0.45],
    57682: [0, 0.12, 0, 0, 0.45],
    57683: [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    32: [0, 0, 0, 0, 0.525],
    33: [0, 0.61111, 0, 0, 0.525],
    34: [0, 0.61111, 0, 0, 0.525],
    35: [0, 0.61111, 0, 0, 0.525],
    36: [0.08333, 0.69444, 0, 0, 0.525],
    37: [0.08333, 0.69444, 0, 0, 0.525],
    38: [0, 0.61111, 0, 0, 0.525],
    39: [0, 0.61111, 0, 0, 0.525],
    40: [0.08333, 0.69444, 0, 0, 0.525],
    41: [0.08333, 0.69444, 0, 0, 0.525],
    42: [0, 0.52083, 0, 0, 0.525],
    43: [-0.08056, 0.53055, 0, 0, 0.525],
    44: [0.13889, 0.125, 0, 0, 0.525],
    45: [-0.08056, 0.53055, 0, 0, 0.525],
    46: [0, 0.125, 0, 0, 0.525],
    47: [0.08333, 0.69444, 0, 0, 0.525],
    48: [0, 0.61111, 0, 0, 0.525],
    49: [0, 0.61111, 0, 0, 0.525],
    50: [0, 0.61111, 0, 0, 0.525],
    51: [0, 0.61111, 0, 0, 0.525],
    52: [0, 0.61111, 0, 0, 0.525],
    53: [0, 0.61111, 0, 0, 0.525],
    54: [0, 0.61111, 0, 0, 0.525],
    55: [0, 0.61111, 0, 0, 0.525],
    56: [0, 0.61111, 0, 0, 0.525],
    57: [0, 0.61111, 0, 0, 0.525],
    58: [0, 0.43056, 0, 0, 0.525],
    59: [0.13889, 0.43056, 0, 0, 0.525],
    60: [-0.05556, 0.55556, 0, 0, 0.525],
    61: [-0.19549, 0.41562, 0, 0, 0.525],
    62: [-0.05556, 0.55556, 0, 0, 0.525],
    63: [0, 0.61111, 0, 0, 0.525],
    64: [0, 0.61111, 0, 0, 0.525],
    65: [0, 0.61111, 0, 0, 0.525],
    66: [0, 0.61111, 0, 0, 0.525],
    67: [0, 0.61111, 0, 0, 0.525],
    68: [0, 0.61111, 0, 0, 0.525],
    69: [0, 0.61111, 0, 0, 0.525],
    70: [0, 0.61111, 0, 0, 0.525],
    71: [0, 0.61111, 0, 0, 0.525],
    72: [0, 0.61111, 0, 0, 0.525],
    73: [0, 0.61111, 0, 0, 0.525],
    74: [0, 0.61111, 0, 0, 0.525],
    75: [0, 0.61111, 0, 0, 0.525],
    76: [0, 0.61111, 0, 0, 0.525],
    77: [0, 0.61111, 0, 0, 0.525],
    78: [0, 0.61111, 0, 0, 0.525],
    79: [0, 0.61111, 0, 0, 0.525],
    80: [0, 0.61111, 0, 0, 0.525],
    81: [0.13889, 0.61111, 0, 0, 0.525],
    82: [0, 0.61111, 0, 0, 0.525],
    83: [0, 0.61111, 0, 0, 0.525],
    84: [0, 0.61111, 0, 0, 0.525],
    85: [0, 0.61111, 0, 0, 0.525],
    86: [0, 0.61111, 0, 0, 0.525],
    87: [0, 0.61111, 0, 0, 0.525],
    88: [0, 0.61111, 0, 0, 0.525],
    89: [0, 0.61111, 0, 0, 0.525],
    90: [0, 0.61111, 0, 0, 0.525],
    91: [0.08333, 0.69444, 0, 0, 0.525],
    92: [0.08333, 0.69444, 0, 0, 0.525],
    93: [0.08333, 0.69444, 0, 0, 0.525],
    94: [0, 0.61111, 0, 0, 0.525],
    95: [0.09514, 0, 0, 0, 0.525],
    96: [0, 0.61111, 0, 0, 0.525],
    97: [0, 0.43056, 0, 0, 0.525],
    98: [0, 0.61111, 0, 0, 0.525],
    99: [0, 0.43056, 0, 0, 0.525],
    100: [0, 0.61111, 0, 0, 0.525],
    101: [0, 0.43056, 0, 0, 0.525],
    102: [0, 0.61111, 0, 0, 0.525],
    103: [0.22222, 0.43056, 0, 0, 0.525],
    104: [0, 0.61111, 0, 0, 0.525],
    105: [0, 0.61111, 0, 0, 0.525],
    106: [0.22222, 0.61111, 0, 0, 0.525],
    107: [0, 0.61111, 0, 0, 0.525],
    108: [0, 0.61111, 0, 0, 0.525],
    109: [0, 0.43056, 0, 0, 0.525],
    110: [0, 0.43056, 0, 0, 0.525],
    111: [0, 0.43056, 0, 0, 0.525],
    112: [0.22222, 0.43056, 0, 0, 0.525],
    113: [0.22222, 0.43056, 0, 0, 0.525],
    114: [0, 0.43056, 0, 0, 0.525],
    115: [0, 0.43056, 0, 0, 0.525],
    116: [0, 0.55358, 0, 0, 0.525],
    117: [0, 0.43056, 0, 0, 0.525],
    118: [0, 0.43056, 0, 0, 0.525],
    119: [0, 0.43056, 0, 0, 0.525],
    120: [0, 0.43056, 0, 0, 0.525],
    121: [0.22222, 0.43056, 0, 0, 0.525],
    122: [0, 0.43056, 0, 0, 0.525],
    123: [0.08333, 0.69444, 0, 0, 0.525],
    124: [0.08333, 0.69444, 0, 0, 0.525],
    125: [0.08333, 0.69444, 0, 0, 0.525],
    126: [0, 0.61111, 0, 0, 0.525],
    127: [0, 0.61111, 0, 0, 0.525],
    160: [0, 0, 0, 0, 0.525],
    176: [0, 0.61111, 0, 0, 0.525],
    184: [0.19445, 0, 0, 0, 0.525],
    305: [0, 0.43056, 0, 0, 0.525],
    567: [0.22222, 0.43056, 0, 0, 0.525],
    711: [0, 0.56597, 0, 0, 0.525],
    713: [0, 0.56555, 0, 0, 0.525],
    714: [0, 0.61111, 0, 0, 0.525],
    715: [0, 0.61111, 0, 0, 0.525],
    728: [0, 0.61111, 0, 0, 0.525],
    730: [0, 0.61111, 0, 0, 0.525],
    770: [0, 0.61111, 0, 0, 0.525],
    771: [0, 0.61111, 0, 0, 0.525],
    776: [0, 0.61111, 0, 0, 0.525],
    915: [0, 0.61111, 0, 0, 0.525],
    916: [0, 0.61111, 0, 0, 0.525],
    920: [0, 0.61111, 0, 0, 0.525],
    923: [0, 0.61111, 0, 0, 0.525],
    926: [0, 0.61111, 0, 0, 0.525],
    928: [0, 0.61111, 0, 0, 0.525],
    931: [0, 0.61111, 0, 0, 0.525],
    933: [0, 0.61111, 0, 0, 0.525],
    934: [0, 0.61111, 0, 0, 0.525],
    936: [0, 0.61111, 0, 0, 0.525],
    937: [0, 0.61111, 0, 0, 0.525],
    8216: [0, 0.61111, 0, 0, 0.525],
    8217: [0, 0.61111, 0, 0, 0.525],
    8242: [0, 0.61111, 0, 0, 0.525],
    9251: [0.11111, 0.21944, 0, 0, 0.525]
  }
}, Yi = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.scss; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
}, E0 = {
  // Latin-1
  Ã…: "A",
  Ã: "D",
  Ãž: "o",
  Ã¥: "a",
  Ã°: "d",
  Ã¾: "o",
  // Cyrillic
  Ð: "A",
  Ð‘: "B",
  Ð’: "B",
  Ð“: "F",
  Ð”: "A",
  Ð•: "E",
  Ð–: "K",
  Ð—: "3",
  Ð˜: "N",
  Ð™: "N",
  Ðš: "K",
  Ð›: "N",
  Ðœ: "M",
  Ð: "H",
  Ðž: "O",
  ÐŸ: "N",
  Ð : "P",
  Ð¡: "C",
  Ð¢: "T",
  Ð£: "y",
  Ð¤: "O",
  Ð¥: "X",
  Ð¦: "U",
  Ð§: "h",
  Ð¨: "W",
  Ð©: "W",
  Ðª: "B",
  Ð«: "X",
  Ð¬: "B",
  Ð­: "3",
  Ð®: "X",
  Ð¯: "R",
  Ð°: "a",
  Ð±: "b",
  Ð²: "a",
  Ð³: "r",
  Ð´: "y",
  Ðµ: "e",
  Ð¶: "m",
  Ð·: "e",
  Ð¸: "n",
  Ð¹: "n",
  Ðº: "n",
  Ð»: "n",
  Ð¼: "m",
  Ð½: "n",
  Ð¾: "o",
  Ð¿: "n",
  Ñ€: "p",
  Ñ: "c",
  Ñ‚: "o",
  Ñƒ: "y",
  Ñ„: "b",
  Ñ…: "x",
  Ñ†: "n",
  Ñ‡: "n",
  Ñˆ: "w",
  Ñ‰: "w",
  ÑŠ: "a",
  Ñ‹: "m",
  ÑŒ: "a",
  Ñ: "e",
  ÑŽ: "m",
  Ñ: "r"
};
function Fm(r, e) {
  $r[r] = e;
}
function Ss(r, e, t) {
  if (!$r[e])
    throw new Error("Font metrics not found for font: " + e + ".");
  var n = r.charCodeAt(0), i = $r[e][n];
  if (!i && r[0] in E0 && (n = E0[r[0]].charCodeAt(0), i = $r[e][n]), !i && t === "text" && Qu(n) && (i = $r[e][77]), i)
    return {
      depth: i[0],
      height: i[1],
      italic: i[2],
      skew: i[3],
      width: i[4]
    };
}
var Vo = {};
function Bm(r) {
  var e;
  if (r >= 5 ? e = 0 : r >= 3 ? e = 1 : e = 2, !Vo[e]) {
    var t = Vo[e] = {
      cssEmPerMu: Yi.quad[e] / 18
    };
    for (var n in Yi)
      Yi.hasOwnProperty(n) && (t[n] = Yi[n][e]);
  }
  return Vo[e];
}
var zm = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
], S0 = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
], O0 = function(e, t) {
  return t.size < 2 ? e : zm[e - 1][t.size - 1];
};
class Yr {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(e) {
    this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = e.style, this.color = e.color, this.size = e.size || Yr.BASESIZE, this.textSize = e.textSize || this.size, this.phantom = !!e.phantom, this.font = e.font || "", this.fontFamily = e.fontFamily || "", this.fontWeight = e.fontWeight || "", this.fontShape = e.fontShape || "", this.sizeMultiplier = S0[this.size - 1], this.maxSize = e.maxSize, this.minRuleThickness = e.minRuleThickness, this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(e) {
    var t = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var n in e)
      e.hasOwnProperty(n) && (t[n] = e[n]);
    return new Yr(t);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(e) {
    return this.style === e ? this : this.extend({
      style: e,
      size: O0(this.textSize, e)
    });
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(e) {
    return this.size === e && this.textSize === e ? this : this.extend({
      style: this.style.text(),
      size: e,
      textSize: e,
      sizeMultiplier: S0[e - 1]
    });
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(e) {
    e = e || this.style.text();
    var t = O0(Yr.BASESIZE, e);
    return this.size === t && this.textSize === Yr.BASESIZE && this.style === e ? this : this.extend({
      style: e,
      size: t
    });
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var e;
    switch (this.style.id) {
      case 4:
      case 5:
        e = 3;
        break;
      case 6:
      case 7:
        e = 1;
        break;
      default:
        e = 6;
    }
    return this.extend({
      style: this.style.text(),
      size: e
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(e) {
    return this.extend({
      color: e
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: !0
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(e) {
    return this.extend({
      font: e
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(e) {
    return this.extend({
      fontFamily: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(e) {
    return this.extend({
      fontWeight: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(e) {
    return this.extend({
      fontShape: e,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(e) {
    return e.size !== this.size ? ["sizing", "reset-size" + e.size, "size" + this.size] : [];
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    return this.size !== Yr.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + Yr.BASESIZE] : [];
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    return this._fontMetrics || (this._fontMetrics = Bm(this.size)), this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    return this.phantom ? "transparent" : this.color;
  }
}
Yr.BASESIZE = 6;
var Va = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 1,
  // TeX point
  mm: 7227 / 2540,
  // millimeter
  cm: 7227 / 254,
  // centimeter
  in: 72.27,
  // inch
  bp: 803 / 800,
  // big (PostScript) points
  pc: 12,
  // pica
  dd: 1238 / 1157,
  // didot
  cc: 14856 / 1157,
  // cicero (12 didot)
  nd: 685 / 642,
  // new didot
  nc: 1370 / 107,
  // new cicero (12 new didot)
  sp: 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  px: 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
}, Hm = {
  ex: !0,
  em: !0,
  mu: !0
}, ed = function(e) {
  return typeof e != "string" && (e = e.unit), e in Va || e in Hm || e === "ex";
}, Ht = function(e, t) {
  var n;
  if (e.unit in Va)
    n = Va[e.unit] / t.fontMetrics().ptPerEm / t.sizeMultiplier;
  else if (e.unit === "mu")
    n = t.fontMetrics().cssEmPerMu;
  else {
    var i;
    if (t.style.isTight() ? i = t.havingStyle(t.style.text()) : i = t, e.unit === "ex")
      n = i.fontMetrics().xHeight;
    else if (e.unit === "em")
      n = i.fontMetrics().quad;
    else
      throw new Re("Invalid unit: '" + e.unit + "'");
    i !== t && (n *= i.sizeMultiplier / t.sizeMultiplier);
  }
  return Math.min(e.number * n, t.maxSize);
}, $e = function(e) {
  return +e.toFixed(4) + "em";
}, un = function(e) {
  return e.filter((t) => t).join(" ");
}, td = function(e, t, n) {
  if (this.classes = e || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = n || {}, t) {
    t.style.isTight() && this.classes.push("mtight");
    var i = t.getColor();
    i && (this.style.color = i);
  }
}, rd = function(e) {
  var t = document.createElement(e);
  t.className = un(this.classes);
  for (var n in this.style)
    this.style.hasOwnProperty(n) && (t.style[n] = this.style[n]);
  for (var i in this.attributes)
    this.attributes.hasOwnProperty(i) && t.setAttribute(i, this.attributes[i]);
  for (var o = 0; o < this.children.length; o++)
    t.appendChild(this.children[o].toNode());
  return t;
}, nd = function(e) {
  var t = "<" + e;
  this.classes.length && (t += ' class="' + Xe.escape(un(this.classes)) + '"');
  var n = "";
  for (var i in this.style)
    this.style.hasOwnProperty(i) && (n += Xe.hyphenate(i) + ":" + this.style[i] + ";");
  n && (t += ' style="' + Xe.escape(n) + '"');
  for (var o in this.attributes)
    this.attributes.hasOwnProperty(o) && (t += " " + o + '="' + Xe.escape(this.attributes[o]) + '"');
  t += ">";
  for (var s = 0; s < this.children.length; s++)
    t += this.children[s].toMarkup();
  return t += "</" + e + ">", t;
};
class Fi {
  constructor(e, t, n, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, td.call(this, e, n, i), this.children = t || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  hasClass(e) {
    return Xe.contains(this.classes, e);
  }
  toNode() {
    return rd.call(this, "span");
  }
  toMarkup() {
    return nd.call(this, "span");
  }
}
class Os {
  constructor(e, t, n, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, td.call(this, t, i), this.children = n || [], this.setAttribute("href", e);
  }
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  hasClass(e) {
    return Xe.contains(this.classes, e);
  }
  toNode() {
    return rd.call(this, "a");
  }
  toMarkup() {
    return nd.call(this, "a");
  }
}
class jm {
  constructor(e, t, n) {
    this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = t, this.src = e, this.classes = ["mord"], this.style = n;
  }
  hasClass(e) {
    return Xe.contains(this.classes, e);
  }
  toNode() {
    var e = document.createElement("img");
    e.src = this.src, e.alt = this.alt, e.className = "mord";
    for (var t in this.style)
      this.style.hasOwnProperty(t) && (e.style[t] = this.style[t]);
    return e;
  }
  toMarkup() {
    var e = '<img src="' + Xe.escape(this.src) + '"' + (' alt="' + Xe.escape(this.alt) + '"'), t = "";
    for (var n in this.style)
      this.style.hasOwnProperty(n) && (t += Xe.hyphenate(n) + ":" + this.style[n] + ";");
    return t && (e += ' style="' + Xe.escape(t) + '"'), e += "'/>", e;
  }
}
var qm = {
  Ã®: "Ä±Ì‚",
  Ã¯: "Ä±Ìˆ",
  Ã­: "Ä±Ì",
  // 'Ä«': '\u0131\u0304', // enable when we add Extended Latin
  Ã¬: "Ä±Ì€"
};
class br {
  constructor(e, t, n, i, o, s, a, l) {
    this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = e, this.height = t || 0, this.depth = n || 0, this.italic = i || 0, this.skew = o || 0, this.width = s || 0, this.classes = a || [], this.style = l || {}, this.maxFontSize = 0;
    var u = Sm(this.text.charCodeAt(0));
    u && this.classes.push(u + "_fallback"), /[Ã®Ã¯Ã­Ã¬]/.test(this.text) && (this.text = qm[this.text]);
  }
  hasClass(e) {
    return Xe.contains(this.classes, e);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var e = document.createTextNode(this.text), t = null;
    this.italic > 0 && (t = document.createElement("span"), t.style.marginRight = $e(this.italic)), this.classes.length > 0 && (t = t || document.createElement("span"), t.className = un(this.classes));
    for (var n in this.style)
      this.style.hasOwnProperty(n) && (t = t || document.createElement("span"), t.style[n] = this.style[n]);
    return t ? (t.appendChild(e), t) : e;
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var e = !1, t = "<span";
    this.classes.length && (e = !0, t += ' class="', t += Xe.escape(un(this.classes)), t += '"');
    var n = "";
    this.italic > 0 && (n += "margin-right:" + this.italic + "em;");
    for (var i in this.style)
      this.style.hasOwnProperty(i) && (n += Xe.hyphenate(i) + ":" + this.style[i] + ";");
    n && (e = !0, t += ' style="' + Xe.escape(n) + '"');
    var o = Xe.escape(this.text);
    return e ? (t += ">", t += o, t += "</span>", t) : o;
  }
}
class Vr {
  constructor(e, t) {
    this.children = void 0, this.attributes = void 0, this.children = e || [], this.attributes = t || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "svg");
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && t.setAttribute(n, this.attributes[n]);
    for (var i = 0; i < this.children.length; i++)
      t.appendChild(this.children[i].toNode());
    return t;
  }
  toMarkup() {
    var e = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="' + Xe.escape(this.attributes[t]) + '"');
    e += ">";
    for (var n = 0; n < this.children.length; n++)
      e += this.children[n].toMarkup();
    return e += "</svg>", e;
  }
}
class dn {
  constructor(e, t) {
    this.pathName = void 0, this.alternate = void 0, this.pathName = e, this.alternate = t;
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "path");
    return this.alternate ? t.setAttribute("d", this.alternate) : t.setAttribute("d", T0[this.pathName]), t;
  }
  toMarkup() {
    return this.alternate ? '<path d="' + Xe.escape(this.alternate) + '"/>' : '<path d="' + Xe.escape(T0[this.pathName]) + '"/>';
  }
}
class Xa {
  constructor(e) {
    this.attributes = void 0, this.attributes = e || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "line");
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && t.setAttribute(n, this.attributes[n]);
    return t;
  }
  toMarkup() {
    var e = "<line";
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="' + Xe.escape(this.attributes[t]) + '"');
    return e += "/>", e;
  }
}
function M0(r) {
  if (r instanceof br)
    return r;
  throw new Error("Expected symbolNode but got " + String(r) + ".");
}
function Km(r) {
  if (r instanceof Fi)
    return r;
  throw new Error("Expected span<HtmlDomNode> but got " + String(r) + ".");
}
var Um = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
}, Ym = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
}, Lt = {
  math: {},
  text: {}
};
function _(r, e, t, n, i, o) {
  Lt[r][i] = {
    font: e,
    group: t,
    replace: n
  }, o && n && (Lt[r][n] = Lt[r][i]);
}
var O = "math", Se = "text", K = "main", ie = "ams", It = "accent-token", He = "bin", cr = "close", Qn = "inner", Qe = "mathord", Vt = "op-token", vr = "open", Eo = "punct", oe = "rel", tn = "spacing", se = "textord";
_(O, K, oe, "â‰¡", "\\equiv", !0);
_(O, K, oe, "â‰º", "\\prec", !0);
_(O, K, oe, "â‰»", "\\succ", !0);
_(O, K, oe, "âˆ¼", "\\sim", !0);
_(O, K, oe, "âŠ¥", "\\perp");
_(O, K, oe, "âª¯", "\\preceq", !0);
_(O, K, oe, "âª°", "\\succeq", !0);
_(O, K, oe, "â‰ƒ", "\\simeq", !0);
_(O, K, oe, "âˆ£", "\\mid", !0);
_(O, K, oe, "â‰ª", "\\ll", !0);
_(O, K, oe, "â‰«", "\\gg", !0);
_(O, K, oe, "â‰", "\\asymp", !0);
_(O, K, oe, "âˆ¥", "\\parallel");
_(O, K, oe, "â‹ˆ", "\\bowtie", !0);
_(O, K, oe, "âŒ£", "\\smile", !0);
_(O, K, oe, "âŠ‘", "\\sqsubseteq", !0);
_(O, K, oe, "âŠ’", "\\sqsupseteq", !0);
_(O, K, oe, "â‰", "\\doteq", !0);
_(O, K, oe, "âŒ¢", "\\frown", !0);
_(O, K, oe, "âˆ‹", "\\ni", !0);
_(O, K, oe, "âˆ", "\\propto", !0);
_(O, K, oe, "âŠ¢", "\\vdash", !0);
_(O, K, oe, "âŠ£", "\\dashv", !0);
_(O, K, oe, "âˆ‹", "\\owns");
_(O, K, Eo, ".", "\\ldotp");
_(O, K, Eo, "â‹…", "\\cdotp");
_(O, K, se, "#", "\\#");
_(Se, K, se, "#", "\\#");
_(O, K, se, "&", "\\&");
_(Se, K, se, "&", "\\&");
_(O, K, se, "â„µ", "\\aleph", !0);
_(O, K, se, "âˆ€", "\\forall", !0);
_(O, K, se, "â„", "\\hbar", !0);
_(O, K, se, "âˆƒ", "\\exists", !0);
_(O, K, se, "âˆ‡", "\\nabla", !0);
_(O, K, se, "â™­", "\\flat", !0);
_(O, K, se, "â„“", "\\ell", !0);
_(O, K, se, "â™®", "\\natural", !0);
_(O, K, se, "â™£", "\\clubsuit", !0);
_(O, K, se, "â„˜", "\\wp", !0);
_(O, K, se, "â™¯", "\\sharp", !0);
_(O, K, se, "â™¢", "\\diamondsuit", !0);
_(O, K, se, "â„œ", "\\Re", !0);
_(O, K, se, "â™¡", "\\heartsuit", !0);
_(O, K, se, "â„‘", "\\Im", !0);
_(O, K, se, "â™ ", "\\spadesuit", !0);
_(O, K, se, "Â§", "\\S", !0);
_(Se, K, se, "Â§", "\\S");
_(O, K, se, "Â¶", "\\P", !0);
_(Se, K, se, "Â¶", "\\P");
_(O, K, se, "â€ ", "\\dag");
_(Se, K, se, "â€ ", "\\dag");
_(Se, K, se, "â€ ", "\\textdagger");
_(O, K, se, "â€¡", "\\ddag");
_(Se, K, se, "â€¡", "\\ddag");
_(Se, K, se, "â€¡", "\\textdaggerdbl");
_(O, K, cr, "âŽ±", "\\rmoustache", !0);
_(O, K, vr, "âŽ°", "\\lmoustache", !0);
_(O, K, cr, "âŸ¯", "\\rgroup", !0);
_(O, K, vr, "âŸ®", "\\lgroup", !0);
_(O, K, He, "âˆ“", "\\mp", !0);
_(O, K, He, "âŠ–", "\\ominus", !0);
_(O, K, He, "âŠŽ", "\\uplus", !0);
_(O, K, He, "âŠ“", "\\sqcap", !0);
_(O, K, He, "âˆ—", "\\ast");
_(O, K, He, "âŠ”", "\\sqcup", !0);
_(O, K, He, "â—¯", "\\bigcirc", !0);
_(O, K, He, "âˆ™", "\\bullet", !0);
_(O, K, He, "â€¡", "\\ddagger");
_(O, K, He, "â‰€", "\\wr", !0);
_(O, K, He, "â¨¿", "\\amalg");
_(O, K, He, "&", "\\And");
_(O, K, oe, "âŸµ", "\\longleftarrow", !0);
_(O, K, oe, "â‡", "\\Leftarrow", !0);
_(O, K, oe, "âŸ¸", "\\Longleftarrow", !0);
_(O, K, oe, "âŸ¶", "\\longrightarrow", !0);
_(O, K, oe, "â‡’", "\\Rightarrow", !0);
_(O, K, oe, "âŸ¹", "\\Longrightarrow", !0);
_(O, K, oe, "â†”", "\\leftrightarrow", !0);
_(O, K, oe, "âŸ·", "\\longleftrightarrow", !0);
_(O, K, oe, "â‡”", "\\Leftrightarrow", !0);
_(O, K, oe, "âŸº", "\\Longleftrightarrow", !0);
_(O, K, oe, "â†¦", "\\mapsto", !0);
_(O, K, oe, "âŸ¼", "\\longmapsto", !0);
_(O, K, oe, "â†—", "\\nearrow", !0);
_(O, K, oe, "â†©", "\\hookleftarrow", !0);
_(O, K, oe, "â†ª", "\\hookrightarrow", !0);
_(O, K, oe, "â†˜", "\\searrow", !0);
_(O, K, oe, "â†¼", "\\leftharpoonup", !0);
_(O, K, oe, "â‡€", "\\rightharpoonup", !0);
_(O, K, oe, "â†™", "\\swarrow", !0);
_(O, K, oe, "â†½", "\\leftharpoondown", !0);
_(O, K, oe, "â‡", "\\rightharpoondown", !0);
_(O, K, oe, "â†–", "\\nwarrow", !0);
_(O, K, oe, "â‡Œ", "\\rightleftharpoons", !0);
_(O, ie, oe, "â‰®", "\\nless", !0);
_(O, ie, oe, "î€", "\\@nleqslant");
_(O, ie, oe, "î€‘", "\\@nleqq");
_(O, ie, oe, "âª‡", "\\lneq", !0);
_(O, ie, oe, "â‰¨", "\\lneqq", !0);
_(O, ie, oe, "î€Œ", "\\@lvertneqq");
_(O, ie, oe, "â‹¦", "\\lnsim", !0);
_(O, ie, oe, "âª‰", "\\lnapprox", !0);
_(O, ie, oe, "âŠ€", "\\nprec", !0);
_(O, ie, oe, "â‹ ", "\\npreceq", !0);
_(O, ie, oe, "â‹¨", "\\precnsim", !0);
_(O, ie, oe, "âª¹", "\\precnapprox", !0);
_(O, ie, oe, "â‰", "\\nsim", !0);
_(O, ie, oe, "î€†", "\\@nshortmid");
_(O, ie, oe, "âˆ¤", "\\nmid", !0);
_(O, ie, oe, "âŠ¬", "\\nvdash", !0);
_(O, ie, oe, "âŠ­", "\\nvDash", !0);
_(O, ie, oe, "â‹ª", "\\ntriangleleft");
_(O, ie, oe, "â‹¬", "\\ntrianglelefteq", !0);
_(O, ie, oe, "âŠŠ", "\\subsetneq", !0);
_(O, ie, oe, "î€š", "\\@varsubsetneq");
_(O, ie, oe, "â«‹", "\\subsetneqq", !0);
_(O, ie, oe, "î€—", "\\@varsubsetneqq");
_(O, ie, oe, "â‰¯", "\\ngtr", !0);
_(O, ie, oe, "î€", "\\@ngeqslant");
_(O, ie, oe, "î€Ž", "\\@ngeqq");
_(O, ie, oe, "âªˆ", "\\gneq", !0);
_(O, ie, oe, "â‰©", "\\gneqq", !0);
_(O, ie, oe, "î€", "\\@gvertneqq");
_(O, ie, oe, "â‹§", "\\gnsim", !0);
_(O, ie, oe, "âªŠ", "\\gnapprox", !0);
_(O, ie, oe, "âŠ", "\\nsucc", !0);
_(O, ie, oe, "â‹¡", "\\nsucceq", !0);
_(O, ie, oe, "â‹©", "\\succnsim", !0);
_(O, ie, oe, "âªº", "\\succnapprox", !0);
_(O, ie, oe, "â‰†", "\\ncong", !0);
_(O, ie, oe, "î€‡", "\\@nshortparallel");
_(O, ie, oe, "âˆ¦", "\\nparallel", !0);
_(O, ie, oe, "âŠ¯", "\\nVDash", !0);
_(O, ie, oe, "â‹«", "\\ntriangleright");
_(O, ie, oe, "â‹­", "\\ntrianglerighteq", !0);
_(O, ie, oe, "î€˜", "\\@nsupseteqq");
_(O, ie, oe, "âŠ‹", "\\supsetneq", !0);
_(O, ie, oe, "î€›", "\\@varsupsetneq");
_(O, ie, oe, "â«Œ", "\\supsetneqq", !0);
_(O, ie, oe, "î€™", "\\@varsupsetneqq");
_(O, ie, oe, "âŠ®", "\\nVdash", !0);
_(O, ie, oe, "âªµ", "\\precneqq", !0);
_(O, ie, oe, "âª¶", "\\succneqq", !0);
_(O, ie, oe, "î€–", "\\@nsubseteqq");
_(O, ie, He, "âŠ´", "\\unlhd");
_(O, ie, He, "âŠµ", "\\unrhd");
_(O, ie, oe, "â†š", "\\nleftarrow", !0);
_(O, ie, oe, "â†›", "\\nrightarrow", !0);
_(O, ie, oe, "â‡", "\\nLeftarrow", !0);
_(O, ie, oe, "â‡", "\\nRightarrow", !0);
_(O, ie, oe, "â†®", "\\nleftrightarrow", !0);
_(O, ie, oe, "â‡Ž", "\\nLeftrightarrow", !0);
_(O, ie, oe, "â–³", "\\vartriangle");
_(O, ie, se, "â„", "\\hslash");
_(O, ie, se, "â–½", "\\triangledown");
_(O, ie, se, "â—Š", "\\lozenge");
_(O, ie, se, "â“ˆ", "\\circledS");
_(O, ie, se, "Â®", "\\circledR");
_(Se, ie, se, "Â®", "\\circledR");
_(O, ie, se, "âˆ¡", "\\measuredangle", !0);
_(O, ie, se, "âˆ„", "\\nexists");
_(O, ie, se, "â„§", "\\mho");
_(O, ie, se, "â„²", "\\Finv", !0);
_(O, ie, se, "â…", "\\Game", !0);
_(O, ie, se, "â€µ", "\\backprime");
_(O, ie, se, "â–²", "\\blacktriangle");
_(O, ie, se, "â–¼", "\\blacktriangledown");
_(O, ie, se, "â– ", "\\blacksquare");
_(O, ie, se, "â§«", "\\blacklozenge");
_(O, ie, se, "â˜…", "\\bigstar");
_(O, ie, se, "âˆ¢", "\\sphericalangle", !0);
_(O, ie, se, "âˆ", "\\complement", !0);
_(O, ie, se, "Ã°", "\\eth", !0);
_(Se, K, se, "Ã°", "Ã°");
_(O, ie, se, "â•±", "\\diagup");
_(O, ie, se, "â•²", "\\diagdown");
_(O, ie, se, "â–¡", "\\square");
_(O, ie, se, "â–¡", "\\Box");
_(O, ie, se, "â—Š", "\\Diamond");
_(O, ie, se, "Â¥", "\\yen", !0);
_(Se, ie, se, "Â¥", "\\yen", !0);
_(O, ie, se, "âœ“", "\\checkmark", !0);
_(Se, ie, se, "âœ“", "\\checkmark");
_(O, ie, se, "â„¶", "\\beth", !0);
_(O, ie, se, "â„¸", "\\daleth", !0);
_(O, ie, se, "â„·", "\\gimel", !0);
_(O, ie, se, "Ï", "\\digamma", !0);
_(O, ie, se, "Ï°", "\\varkappa");
_(O, ie, vr, "â”Œ", "\\@ulcorner", !0);
_(O, ie, cr, "â”", "\\@urcorner", !0);
_(O, ie, vr, "â””", "\\@llcorner", !0);
_(O, ie, cr, "â”˜", "\\@lrcorner", !0);
_(O, ie, oe, "â‰¦", "\\leqq", !0);
_(O, ie, oe, "â©½", "\\leqslant", !0);
_(O, ie, oe, "âª•", "\\eqslantless", !0);
_(O, ie, oe, "â‰²", "\\lesssim", !0);
_(O, ie, oe, "âª…", "\\lessapprox", !0);
_(O, ie, oe, "â‰Š", "\\approxeq", !0);
_(O, ie, He, "â‹–", "\\lessdot");
_(O, ie, oe, "â‹˜", "\\lll", !0);
_(O, ie, oe, "â‰¶", "\\lessgtr", !0);
_(O, ie, oe, "â‹š", "\\lesseqgtr", !0);
_(O, ie, oe, "âª‹", "\\lesseqqgtr", !0);
_(O, ie, oe, "â‰‘", "\\doteqdot");
_(O, ie, oe, "â‰“", "\\risingdotseq", !0);
_(O, ie, oe, "â‰’", "\\fallingdotseq", !0);
_(O, ie, oe, "âˆ½", "\\backsim", !0);
_(O, ie, oe, "â‹", "\\backsimeq", !0);
_(O, ie, oe, "â«…", "\\subseteqq", !0);
_(O, ie, oe, "â‹", "\\Subset", !0);
_(O, ie, oe, "âŠ", "\\sqsubset", !0);
_(O, ie, oe, "â‰¼", "\\preccurlyeq", !0);
_(O, ie, oe, "â‹ž", "\\curlyeqprec", !0);
_(O, ie, oe, "â‰¾", "\\precsim", !0);
_(O, ie, oe, "âª·", "\\precapprox", !0);
_(O, ie, oe, "âŠ²", "\\vartriangleleft");
_(O, ie, oe, "âŠ´", "\\trianglelefteq");
_(O, ie, oe, "âŠ¨", "\\vDash", !0);
_(O, ie, oe, "âŠª", "\\Vvdash", !0);
_(O, ie, oe, "âŒ£", "\\smallsmile");
_(O, ie, oe, "âŒ¢", "\\smallfrown");
_(O, ie, oe, "â‰", "\\bumpeq", !0);
_(O, ie, oe, "â‰Ž", "\\Bumpeq", !0);
_(O, ie, oe, "â‰§", "\\geqq", !0);
_(O, ie, oe, "â©¾", "\\geqslant", !0);
_(O, ie, oe, "âª–", "\\eqslantgtr", !0);
_(O, ie, oe, "â‰³", "\\gtrsim", !0);
_(O, ie, oe, "âª†", "\\gtrapprox", !0);
_(O, ie, He, "â‹—", "\\gtrdot");
_(O, ie, oe, "â‹™", "\\ggg", !0);
_(O, ie, oe, "â‰·", "\\gtrless", !0);
_(O, ie, oe, "â‹›", "\\gtreqless", !0);
_(O, ie, oe, "âªŒ", "\\gtreqqless", !0);
_(O, ie, oe, "â‰–", "\\eqcirc", !0);
_(O, ie, oe, "â‰—", "\\circeq", !0);
_(O, ie, oe, "â‰œ", "\\triangleq", !0);
_(O, ie, oe, "âˆ¼", "\\thicksim");
_(O, ie, oe, "â‰ˆ", "\\thickapprox");
_(O, ie, oe, "â«†", "\\supseteqq", !0);
_(O, ie, oe, "â‹‘", "\\Supset", !0);
_(O, ie, oe, "âŠ", "\\sqsupset", !0);
_(O, ie, oe, "â‰½", "\\succcurlyeq", !0);
_(O, ie, oe, "â‹Ÿ", "\\curlyeqsucc", !0);
_(O, ie, oe, "â‰¿", "\\succsim", !0);
_(O, ie, oe, "âª¸", "\\succapprox", !0);
_(O, ie, oe, "âŠ³", "\\vartriangleright");
_(O, ie, oe, "âŠµ", "\\trianglerighteq");
_(O, ie, oe, "âŠ©", "\\Vdash", !0);
_(O, ie, oe, "âˆ£", "\\shortmid");
_(O, ie, oe, "âˆ¥", "\\shortparallel");
_(O, ie, oe, "â‰¬", "\\between", !0);
_(O, ie, oe, "â‹”", "\\pitchfork", !0);
_(O, ie, oe, "âˆ", "\\varpropto");
_(O, ie, oe, "â—€", "\\blacktriangleleft");
_(O, ie, oe, "âˆ´", "\\therefore", !0);
_(O, ie, oe, "âˆ", "\\backepsilon");
_(O, ie, oe, "â–¶", "\\blacktriangleright");
_(O, ie, oe, "âˆµ", "\\because", !0);
_(O, ie, oe, "â‹˜", "\\llless");
_(O, ie, oe, "â‹™", "\\gggtr");
_(O, ie, He, "âŠ²", "\\lhd");
_(O, ie, He, "âŠ³", "\\rhd");
_(O, ie, oe, "â‰‚", "\\eqsim", !0);
_(O, K, oe, "â‹ˆ", "\\Join");
_(O, ie, oe, "â‰‘", "\\Doteq", !0);
_(O, ie, He, "âˆ”", "\\dotplus", !0);
_(O, ie, He, "âˆ–", "\\smallsetminus");
_(O, ie, He, "â‹’", "\\Cap", !0);
_(O, ie, He, "â‹“", "\\Cup", !0);
_(O, ie, He, "â©ž", "\\doublebarwedge", !0);
_(O, ie, He, "âŠŸ", "\\boxminus", !0);
_(O, ie, He, "âŠž", "\\boxplus", !0);
_(O, ie, He, "â‹‡", "\\divideontimes", !0);
_(O, ie, He, "â‹‰", "\\ltimes", !0);
_(O, ie, He, "â‹Š", "\\rtimes", !0);
_(O, ie, He, "â‹‹", "\\leftthreetimes", !0);
_(O, ie, He, "â‹Œ", "\\rightthreetimes", !0);
_(O, ie, He, "â‹", "\\curlywedge", !0);
_(O, ie, He, "â‹Ž", "\\curlyvee", !0);
_(O, ie, He, "âŠ", "\\circleddash", !0);
_(O, ie, He, "âŠ›", "\\circledast", !0);
_(O, ie, He, "â‹…", "\\centerdot");
_(O, ie, He, "âŠº", "\\intercal", !0);
_(O, ie, He, "â‹’", "\\doublecap");
_(O, ie, He, "â‹“", "\\doublecup");
_(O, ie, He, "âŠ ", "\\boxtimes", !0);
_(O, ie, oe, "â‡¢", "\\dashrightarrow", !0);
_(O, ie, oe, "â‡ ", "\\dashleftarrow", !0);
_(O, ie, oe, "â‡‡", "\\leftleftarrows", !0);
_(O, ie, oe, "â‡†", "\\leftrightarrows", !0);
_(O, ie, oe, "â‡š", "\\Lleftarrow", !0);
_(O, ie, oe, "â†ž", "\\twoheadleftarrow", !0);
_(O, ie, oe, "â†¢", "\\leftarrowtail", !0);
_(O, ie, oe, "â†«", "\\looparrowleft", !0);
_(O, ie, oe, "â‡‹", "\\leftrightharpoons", !0);
_(O, ie, oe, "â†¶", "\\curvearrowleft", !0);
_(O, ie, oe, "â†º", "\\circlearrowleft", !0);
_(O, ie, oe, "â†°", "\\Lsh", !0);
_(O, ie, oe, "â‡ˆ", "\\upuparrows", !0);
_(O, ie, oe, "â†¿", "\\upharpoonleft", !0);
_(O, ie, oe, "â‡ƒ", "\\downharpoonleft", !0);
_(O, K, oe, "âŠ¶", "\\origof", !0);
_(O, K, oe, "âŠ·", "\\imageof", !0);
_(O, ie, oe, "âŠ¸", "\\multimap", !0);
_(O, ie, oe, "â†­", "\\leftrightsquigarrow", !0);
_(O, ie, oe, "â‡‰", "\\rightrightarrows", !0);
_(O, ie, oe, "â‡„", "\\rightleftarrows", !0);
_(O, ie, oe, "â† ", "\\twoheadrightarrow", !0);
_(O, ie, oe, "â†£", "\\rightarrowtail", !0);
_(O, ie, oe, "â†¬", "\\looparrowright", !0);
_(O, ie, oe, "â†·", "\\curvearrowright", !0);
_(O, ie, oe, "â†»", "\\circlearrowright", !0);
_(O, ie, oe, "â†±", "\\Rsh", !0);
_(O, ie, oe, "â‡Š", "\\downdownarrows", !0);
_(O, ie, oe, "â†¾", "\\upharpoonright", !0);
_(O, ie, oe, "â‡‚", "\\downharpoonright", !0);
_(O, ie, oe, "â‡", "\\rightsquigarrow", !0);
_(O, ie, oe, "â‡", "\\leadsto");
_(O, ie, oe, "â‡›", "\\Rrightarrow", !0);
_(O, ie, oe, "â†¾", "\\restriction");
_(O, K, se, "â€˜", "`");
_(O, K, se, "$", "\\$");
_(Se, K, se, "$", "\\$");
_(Se, K, se, "$", "\\textdollar");
_(O, K, se, "%", "\\%");
_(Se, K, se, "%", "\\%");
_(O, K, se, "_", "\\_");
_(Se, K, se, "_", "\\_");
_(Se, K, se, "_", "\\textunderscore");
_(O, K, se, "âˆ ", "\\angle", !0);
_(O, K, se, "âˆž", "\\infty", !0);
_(O, K, se, "â€²", "\\prime");
_(O, K, se, "â–³", "\\triangle");
_(O, K, se, "Î“", "\\Gamma", !0);
_(O, K, se, "Î”", "\\Delta", !0);
_(O, K, se, "Î˜", "\\Theta", !0);
_(O, K, se, "Î›", "\\Lambda", !0);
_(O, K, se, "Îž", "\\Xi", !0);
_(O, K, se, "Î ", "\\Pi", !0);
_(O, K, se, "Î£", "\\Sigma", !0);
_(O, K, se, "Î¥", "\\Upsilon", !0);
_(O, K, se, "Î¦", "\\Phi", !0);
_(O, K, se, "Î¨", "\\Psi", !0);
_(O, K, se, "Î©", "\\Omega", !0);
_(O, K, se, "A", "Î‘");
_(O, K, se, "B", "Î’");
_(O, K, se, "E", "Î•");
_(O, K, se, "Z", "Î–");
_(O, K, se, "H", "Î—");
_(O, K, se, "I", "Î™");
_(O, K, se, "K", "Îš");
_(O, K, se, "M", "Îœ");
_(O, K, se, "N", "Î");
_(O, K, se, "O", "ÎŸ");
_(O, K, se, "P", "Î¡");
_(O, K, se, "T", "Î¤");
_(O, K, se, "X", "Î§");
_(O, K, se, "Â¬", "\\neg", !0);
_(O, K, se, "Â¬", "\\lnot");
_(O, K, se, "âŠ¤", "\\top");
_(O, K, se, "âŠ¥", "\\bot");
_(O, K, se, "âˆ…", "\\emptyset");
_(O, ie, se, "âˆ…", "\\varnothing");
_(O, K, Qe, "Î±", "\\alpha", !0);
_(O, K, Qe, "Î²", "\\beta", !0);
_(O, K, Qe, "Î³", "\\gamma", !0);
_(O, K, Qe, "Î´", "\\delta", !0);
_(O, K, Qe, "Ïµ", "\\epsilon", !0);
_(O, K, Qe, "Î¶", "\\zeta", !0);
_(O, K, Qe, "Î·", "\\eta", !0);
_(O, K, Qe, "Î¸", "\\theta", !0);
_(O, K, Qe, "Î¹", "\\iota", !0);
_(O, K, Qe, "Îº", "\\kappa", !0);
_(O, K, Qe, "Î»", "\\lambda", !0);
_(O, K, Qe, "Î¼", "\\mu", !0);
_(O, K, Qe, "Î½", "\\nu", !0);
_(O, K, Qe, "Î¾", "\\xi", !0);
_(O, K, Qe, "Î¿", "\\omicron", !0);
_(O, K, Qe, "Ï€", "\\pi", !0);
_(O, K, Qe, "Ï", "\\rho", !0);
_(O, K, Qe, "Ïƒ", "\\sigma", !0);
_(O, K, Qe, "Ï„", "\\tau", !0);
_(O, K, Qe, "Ï…", "\\upsilon", !0);
_(O, K, Qe, "Ï•", "\\phi", !0);
_(O, K, Qe, "Ï‡", "\\chi", !0);
_(O, K, Qe, "Ïˆ", "\\psi", !0);
_(O, K, Qe, "Ï‰", "\\omega", !0);
_(O, K, Qe, "Îµ", "\\varepsilon", !0);
_(O, K, Qe, "Ï‘", "\\vartheta", !0);
_(O, K, Qe, "Ï–", "\\varpi", !0);
_(O, K, Qe, "Ï±", "\\varrho", !0);
_(O, K, Qe, "Ï‚", "\\varsigma", !0);
_(O, K, Qe, "Ï†", "\\varphi", !0);
_(O, K, He, "âˆ—", "*", !0);
_(O, K, He, "+", "+");
_(O, K, He, "âˆ’", "-", !0);
_(O, K, He, "â‹…", "\\cdot", !0);
_(O, K, He, "âˆ˜", "\\circ", !0);
_(O, K, He, "Ã·", "\\div", !0);
_(O, K, He, "Â±", "\\pm", !0);
_(O, K, He, "Ã—", "\\times", !0);
_(O, K, He, "âˆ©", "\\cap", !0);
_(O, K, He, "âˆª", "\\cup", !0);
_(O, K, He, "âˆ–", "\\setminus", !0);
_(O, K, He, "âˆ§", "\\land");
_(O, K, He, "âˆ¨", "\\lor");
_(O, K, He, "âˆ§", "\\wedge", !0);
_(O, K, He, "âˆ¨", "\\vee", !0);
_(O, K, se, "âˆš", "\\surd");
_(O, K, vr, "âŸ¨", "\\langle", !0);
_(O, K, vr, "âˆ£", "\\lvert");
_(O, K, vr, "âˆ¥", "\\lVert");
_(O, K, cr, "?", "?");
_(O, K, cr, "!", "!");
_(O, K, cr, "âŸ©", "\\rangle", !0);
_(O, K, cr, "âˆ£", "\\rvert");
_(O, K, cr, "âˆ¥", "\\rVert");
_(O, K, oe, "=", "=");
_(O, K, oe, ":", ":");
_(O, K, oe, "â‰ˆ", "\\approx", !0);
_(O, K, oe, "â‰…", "\\cong", !0);
_(O, K, oe, "â‰¥", "\\ge");
_(O, K, oe, "â‰¥", "\\geq", !0);
_(O, K, oe, "â†", "\\gets");
_(O, K, oe, ">", "\\gt", !0);
_(O, K, oe, "âˆˆ", "\\in", !0);
_(O, K, oe, "î€ ", "\\@not");
_(O, K, oe, "âŠ‚", "\\subset", !0);
_(O, K, oe, "âŠƒ", "\\supset", !0);
_(O, K, oe, "âŠ†", "\\subseteq", !0);
_(O, K, oe, "âŠ‡", "\\supseteq", !0);
_(O, ie, oe, "âŠˆ", "\\nsubseteq", !0);
_(O, ie, oe, "âŠ‰", "\\nsupseteq", !0);
_(O, K, oe, "âŠ¨", "\\models");
_(O, K, oe, "â†", "\\leftarrow", !0);
_(O, K, oe, "â‰¤", "\\le");
_(O, K, oe, "â‰¤", "\\leq", !0);
_(O, K, oe, "<", "\\lt", !0);
_(O, K, oe, "â†’", "\\rightarrow", !0);
_(O, K, oe, "â†’", "\\to");
_(O, ie, oe, "â‰±", "\\ngeq", !0);
_(O, ie, oe, "â‰°", "\\nleq", !0);
_(O, K, tn, "Â ", "\\ ");
_(O, K, tn, "Â ", "\\space");
_(O, K, tn, "Â ", "\\nobreakspace");
_(Se, K, tn, "Â ", "\\ ");
_(Se, K, tn, "Â ", " ");
_(Se, K, tn, "Â ", "\\space");
_(Se, K, tn, "Â ", "\\nobreakspace");
_(O, K, tn, null, "\\nobreak");
_(O, K, tn, null, "\\allowbreak");
_(O, K, Eo, ",", ",");
_(O, K, Eo, ";", ";");
_(O, ie, He, "âŠ¼", "\\barwedge", !0);
_(O, ie, He, "âŠ»", "\\veebar", !0);
_(O, K, He, "âŠ™", "\\odot", !0);
_(O, K, He, "âŠ•", "\\oplus", !0);
_(O, K, He, "âŠ—", "\\otimes", !0);
_(O, K, se, "âˆ‚", "\\partial", !0);
_(O, K, He, "âŠ˜", "\\oslash", !0);
_(O, ie, He, "âŠš", "\\circledcirc", !0);
_(O, ie, He, "âŠ¡", "\\boxdot", !0);
_(O, K, He, "â–³", "\\bigtriangleup");
_(O, K, He, "â–½", "\\bigtriangledown");
_(O, K, He, "â€ ", "\\dagger");
_(O, K, He, "â‹„", "\\diamond");
_(O, K, He, "â‹†", "\\star");
_(O, K, He, "â—ƒ", "\\triangleleft");
_(O, K, He, "â–¹", "\\triangleright");
_(O, K, vr, "{", "\\{");
_(Se, K, se, "{", "\\{");
_(Se, K, se, "{", "\\textbraceleft");
_(O, K, cr, "}", "\\}");
_(Se, K, se, "}", "\\}");
_(Se, K, se, "}", "\\textbraceright");
_(O, K, vr, "{", "\\lbrace");
_(O, K, cr, "}", "\\rbrace");
_(O, K, vr, "[", "\\lbrack", !0);
_(Se, K, se, "[", "\\lbrack", !0);
_(O, K, cr, "]", "\\rbrack", !0);
_(Se, K, se, "]", "\\rbrack", !0);
_(O, K, vr, "(", "\\lparen", !0);
_(O, K, cr, ")", "\\rparen", !0);
_(Se, K, se, "<", "\\textless", !0);
_(Se, K, se, ">", "\\textgreater", !0);
_(O, K, vr, "âŒŠ", "\\lfloor", !0);
_(O, K, cr, "âŒ‹", "\\rfloor", !0);
_(O, K, vr, "âŒˆ", "\\lceil", !0);
_(O, K, cr, "âŒ‰", "\\rceil", !0);
_(O, K, se, "\\", "\\backslash");
_(O, K, se, "âˆ£", "|");
_(O, K, se, "âˆ£", "\\vert");
_(Se, K, se, "|", "\\textbar", !0);
_(O, K, se, "âˆ¥", "\\|");
_(O, K, se, "âˆ¥", "\\Vert");
_(Se, K, se, "âˆ¥", "\\textbardbl");
_(Se, K, se, "~", "\\textasciitilde");
_(Se, K, se, "\\", "\\textbackslash");
_(Se, K, se, "^", "\\textasciicircum");
_(O, K, oe, "â†‘", "\\uparrow", !0);
_(O, K, oe, "â‡‘", "\\Uparrow", !0);
_(O, K, oe, "â†“", "\\downarrow", !0);
_(O, K, oe, "â‡“", "\\Downarrow", !0);
_(O, K, oe, "â†•", "\\updownarrow", !0);
_(O, K, oe, "â‡•", "\\Updownarrow", !0);
_(O, K, Vt, "âˆ", "\\coprod");
_(O, K, Vt, "â‹", "\\bigvee");
_(O, K, Vt, "â‹€", "\\bigwedge");
_(O, K, Vt, "â¨„", "\\biguplus");
_(O, K, Vt, "â‹‚", "\\bigcap");
_(O, K, Vt, "â‹ƒ", "\\bigcup");
_(O, K, Vt, "âˆ«", "\\int");
_(O, K, Vt, "âˆ«", "\\intop");
_(O, K, Vt, "âˆ¬", "\\iint");
_(O, K, Vt, "âˆ­", "\\iiint");
_(O, K, Vt, "âˆ", "\\prod");
_(O, K, Vt, "âˆ‘", "\\sum");
_(O, K, Vt, "â¨‚", "\\bigotimes");
_(O, K, Vt, "â¨", "\\bigoplus");
_(O, K, Vt, "â¨€", "\\bigodot");
_(O, K, Vt, "âˆ®", "\\oint");
_(O, K, Vt, "âˆ¯", "\\oiint");
_(O, K, Vt, "âˆ°", "\\oiiint");
_(O, K, Vt, "â¨†", "\\bigsqcup");
_(O, K, Vt, "âˆ«", "\\smallint");
_(Se, K, Qn, "â€¦", "\\textellipsis");
_(O, K, Qn, "â€¦", "\\mathellipsis");
_(Se, K, Qn, "â€¦", "\\ldots", !0);
_(O, K, Qn, "â€¦", "\\ldots", !0);
_(O, K, Qn, "â‹¯", "\\@cdots", !0);
_(O, K, Qn, "â‹±", "\\ddots", !0);
_(O, K, se, "â‹®", "\\varvdots");
_(O, K, It, "ËŠ", "\\acute");
_(O, K, It, "Ë‹", "\\grave");
_(O, K, It, "Â¨", "\\ddot");
_(O, K, It, "~", "\\tilde");
_(O, K, It, "Ë‰", "\\bar");
_(O, K, It, "Ë˜", "\\breve");
_(O, K, It, "Ë‡", "\\check");
_(O, K, It, "^", "\\hat");
_(O, K, It, "âƒ—", "\\vec");
_(O, K, It, "Ë™", "\\dot");
_(O, K, It, "Ëš", "\\mathring");
_(O, K, Qe, "î„±", "\\@imath");
_(O, K, Qe, "îˆ·", "\\@jmath");
_(O, K, se, "Ä±", "Ä±");
_(O, K, se, "È·", "È·");
_(Se, K, se, "Ä±", "\\i", !0);
_(Se, K, se, "È·", "\\j", !0);
_(Se, K, se, "ÃŸ", "\\ss", !0);
_(Se, K, se, "Ã¦", "\\ae", !0);
_(Se, K, se, "Å“", "\\oe", !0);
_(Se, K, se, "Ã¸", "\\o", !0);
_(Se, K, se, "Ã†", "\\AE", !0);
_(Se, K, se, "Å’", "\\OE", !0);
_(Se, K, se, "Ã˜", "\\O", !0);
_(Se, K, It, "ËŠ", "\\'");
_(Se, K, It, "Ë‹", "\\`");
_(Se, K, It, "Ë†", "\\^");
_(Se, K, It, "Ëœ", "\\~");
_(Se, K, It, "Ë‰", "\\=");
_(Se, K, It, "Ë˜", "\\u");
_(Se, K, It, "Ë™", "\\.");
_(Se, K, It, "Â¸", "\\c");
_(Se, K, It, "Ëš", "\\r");
_(Se, K, It, "Ë‡", "\\v");
_(Se, K, It, "Â¨", '\\"');
_(Se, K, It, "Ë", "\\H");
_(Se, K, It, "â—¯", "\\textcircled");
var id = {
  "--": !0,
  "---": !0,
  "``": !0,
  "''": !0
};
_(Se, K, se, "â€“", "--", !0);
_(Se, K, se, "â€“", "\\textendash");
_(Se, K, se, "â€”", "---", !0);
_(Se, K, se, "â€”", "\\textemdash");
_(Se, K, se, "â€˜", "`", !0);
_(Se, K, se, "â€˜", "\\textquoteleft");
_(Se, K, se, "â€™", "'", !0);
_(Se, K, se, "â€™", "\\textquoteright");
_(Se, K, se, "â€œ", "``", !0);
_(Se, K, se, "â€œ", "\\textquotedblleft");
_(Se, K, se, "â€", "''", !0);
_(Se, K, se, "â€", "\\textquotedblright");
_(O, K, se, "Â°", "\\degree", !0);
_(Se, K, se, "Â°", "\\degree");
_(Se, K, se, "Â°", "\\textdegree", !0);
_(O, K, se, "Â£", "\\pounds");
_(O, K, se, "Â£", "\\mathsterling", !0);
_(Se, K, se, "Â£", "\\pounds");
_(Se, K, se, "Â£", "\\textsterling", !0);
_(O, ie, se, "âœ ", "\\maltese");
_(Se, ie, se, "âœ ", "\\maltese");
var R0 = '0123456789/@."';
for (var Xo = 0; Xo < R0.length; Xo++) {
  var A0 = R0.charAt(Xo);
  _(O, K, se, A0, A0);
}
var L0 = '0123456789!@*()-=+";:?/.,';
for (var Jo = 0; Jo < L0.length; Jo++) {
  var k0 = L0.charAt(Jo);
  _(Se, K, se, k0, k0);
}
var No = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var Zo = 0; Zo < No.length; Zo++) {
  var Wi = No.charAt(Zo);
  _(O, K, Qe, Wi, Wi), _(Se, K, se, Wi, Wi);
}
_(O, ie, se, "C", "â„‚");
_(Se, ie, se, "C", "â„‚");
_(O, ie, se, "H", "â„");
_(Se, ie, se, "H", "â„");
_(O, ie, se, "N", "â„•");
_(Se, ie, se, "N", "â„•");
_(O, ie, se, "P", "â„™");
_(Se, ie, se, "P", "â„™");
_(O, ie, se, "Q", "â„š");
_(Se, ie, se, "Q", "â„š");
_(O, ie, se, "R", "â„");
_(Se, ie, se, "R", "â„");
_(O, ie, se, "Z", "â„¤");
_(Se, ie, se, "Z", "â„¤");
_(O, K, Qe, "h", "â„Ž");
_(Se, K, Qe, "h", "â„Ž");
var ot = "";
for (var sr = 0; sr < No.length; sr++) {
  var jt = No.charAt(sr);
  ot = String.fromCharCode(55349, 56320 + sr), _(O, K, Qe, jt, ot), _(Se, K, se, jt, ot), ot = String.fromCharCode(55349, 56372 + sr), _(O, K, Qe, jt, ot), _(Se, K, se, jt, ot), ot = String.fromCharCode(55349, 56424 + sr), _(O, K, Qe, jt, ot), _(Se, K, se, jt, ot), ot = String.fromCharCode(55349, 56580 + sr), _(O, K, Qe, jt, ot), _(Se, K, se, jt, ot), ot = String.fromCharCode(55349, 56684 + sr), _(O, K, Qe, jt, ot), _(Se, K, se, jt, ot), ot = String.fromCharCode(55349, 56736 + sr), _(O, K, Qe, jt, ot), _(Se, K, se, jt, ot), ot = String.fromCharCode(55349, 56788 + sr), _(O, K, Qe, jt, ot), _(Se, K, se, jt, ot), ot = String.fromCharCode(55349, 56840 + sr), _(O, K, Qe, jt, ot), _(Se, K, se, jt, ot), ot = String.fromCharCode(55349, 56944 + sr), _(O, K, Qe, jt, ot), _(Se, K, se, jt, ot), sr < 26 && (ot = String.fromCharCode(55349, 56632 + sr), _(O, K, Qe, jt, ot), _(Se, K, se, jt, ot), ot = String.fromCharCode(55349, 56476 + sr), _(O, K, Qe, jt, ot), _(Se, K, se, jt, ot));
}
ot = "ð•œ";
_(O, K, Qe, "k", ot);
_(Se, K, se, "k", ot);
for (var pn = 0; pn < 10; pn++) {
  var an = pn.toString();
  ot = String.fromCharCode(55349, 57294 + pn), _(O, K, Qe, an, ot), _(Se, K, se, an, ot), ot = String.fromCharCode(55349, 57314 + pn), _(O, K, Qe, an, ot), _(Se, K, se, an, ot), ot = String.fromCharCode(55349, 57324 + pn), _(O, K, Qe, an, ot), _(Se, K, se, an, ot), ot = String.fromCharCode(55349, 57334 + pn), _(O, K, Qe, an, ot), _(Se, K, se, an, ot);
}
var Ja = "ÃÃžÃ¾";
for (var Qo = 0; Qo < Ja.length; Qo++) {
  var Gi = Ja.charAt(Qo);
  _(O, K, Qe, Gi, Gi), _(Se, K, se, Gi, Gi);
}
var Vi = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
], D0 = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
], Wm = function(e, t) {
  var n = e.charCodeAt(0), i = e.charCodeAt(1), o = (n - 55296) * 1024 + (i - 56320) + 65536, s = t === "math" ? 0 : 1;
  if (119808 <= o && o < 120484) {
    var a = Math.floor((o - 119808) / 26);
    return [Vi[a][2], Vi[a][s]];
  } else if (120782 <= o && o <= 120831) {
    var l = Math.floor((o - 120782) / 10);
    return [D0[l][2], D0[l][s]];
  } else {
    if (o === 120485 || o === 120486)
      return [Vi[0][2], Vi[0][s]];
    if (120486 < o && o < 120782)
      return ["", ""];
    throw new Re("Unsupported character: " + e);
  }
}, So = function(e, t, n) {
  return Lt[n][e] && Lt[n][e].replace && (e = Lt[n][e].replace), {
    value: e,
    metrics: Ss(e, t, n)
  };
}, Er = function(e, t, n, i, o) {
  var s = So(e, t, n), a = s.metrics;
  e = s.value;
  var l;
  if (a) {
    var u = a.italic;
    (n === "text" || i && i.font === "mathit") && (u = 0), l = new br(e, a.height, a.depth, u, a.skew, a.width, o);
  } else
    typeof console < "u" && console.warn("No character metrics " + ("for '" + e + "' in style '" + t + "' and mode '" + n + "'")), l = new br(e, 0, 0, 0, 0, 0, o);
  if (i) {
    l.maxFontSize = i.sizeMultiplier, i.style.isTight() && l.classes.push("mtight");
    var d = i.getColor();
    d && (l.style.color = d);
  }
  return l;
}, Gm = function(e, t, n, i) {
  return i === void 0 && (i = []), n.font === "boldsymbol" && So(e, "Main-Bold", t).metrics ? Er(e, "Main-Bold", t, n, i.concat(["mathbf"])) : e === "\\" || Lt[t][e].font === "main" ? Er(e, "Main-Regular", t, n, i) : Er(e, "AMS-Regular", t, n, i.concat(["amsrm"]));
}, Vm = function(e, t, n, i, o) {
  return o !== "textord" && So(e, "Math-BoldItalic", t).metrics ? {
    fontName: "Math-BoldItalic",
    fontClass: "boldsymbol"
  } : {
    fontName: "Main-Bold",
    fontClass: "mathbf"
  };
}, Xm = function(e, t, n) {
  var i = e.mode, o = e.text, s = ["mord"], a = i === "math" || i === "text" && t.font, l = a ? t.font : t.fontFamily, u = "", d = "";
  if (o.charCodeAt(0) === 55349 && ([u, d] = Wm(o, i)), u.length > 0)
    return Er(o, u, i, t, s.concat(d));
  if (l) {
    var p, m;
    if (l === "boldsymbol") {
      var c = Vm(o, i, t, s, n);
      p = c.fontName, m = [c.fontClass];
    } else a ? (p = sd[l].fontName, m = [l]) : (p = Xi(l, t.fontWeight, t.fontShape), m = [l, t.fontWeight, t.fontShape]);
    if (So(o, p, i).metrics)
      return Er(o, p, i, t, s.concat(m));
    if (id.hasOwnProperty(o) && p.slice(0, 10) === "Typewriter") {
      for (var h = [], f = 0; f < o.length; f++)
        h.push(Er(o[f], p, i, t, s.concat(m)));
      return ad(h);
    }
  }
  if (n === "mathord")
    return Er(o, "Math-Italic", i, t, s.concat(["mathnormal"]));
  if (n === "textord") {
    var N = Lt[i][o] && Lt[i][o].font;
    if (N === "ams") {
      var v = Xi("amsrm", t.fontWeight, t.fontShape);
      return Er(o, v, i, t, s.concat("amsrm", t.fontWeight, t.fontShape));
    } else if (N === "main" || !N) {
      var C = Xi("textrm", t.fontWeight, t.fontShape);
      return Er(o, C, i, t, s.concat(t.fontWeight, t.fontShape));
    } else {
      var g = Xi(N, t.fontWeight, t.fontShape);
      return Er(o, g, i, t, s.concat(g, t.fontWeight, t.fontShape));
    }
  } else
    throw new Error("unexpected type: " + n + " in makeOrd");
}, Jm = (r, e) => {
  if (un(r.classes) !== un(e.classes) || r.skew !== e.skew || r.maxFontSize !== e.maxFontSize)
    return !1;
  if (r.classes.length === 1) {
    var t = r.classes[0];
    if (t === "mbin" || t === "mord")
      return !1;
  }
  for (var n in r.style)
    if (r.style.hasOwnProperty(n) && r.style[n] !== e.style[n])
      return !1;
  for (var i in e.style)
    if (e.style.hasOwnProperty(i) && r.style[i] !== e.style[i])
      return !1;
  return !0;
}, Zm = (r) => {
  for (var e = 0; e < r.length - 1; e++) {
    var t = r[e], n = r[e + 1];
    t instanceof br && n instanceof br && Jm(t, n) && (t.text += n.text, t.height = Math.max(t.height, n.height), t.depth = Math.max(t.depth, n.depth), t.italic = n.italic, r.splice(e + 1, 1), e--);
  }
  return r;
}, Ms = function(e) {
  for (var t = 0, n = 0, i = 0, o = 0; o < e.children.length; o++) {
    var s = e.children[o];
    s.height > t && (t = s.height), s.depth > n && (n = s.depth), s.maxFontSize > i && (i = s.maxFontSize);
  }
  e.height = t, e.depth = n, e.maxFontSize = i;
}, ur = function(e, t, n, i) {
  var o = new Fi(e, t, n, i);
  return Ms(o), o;
}, od = (r, e, t, n) => new Fi(r, e, t, n), Qm = function(e, t, n) {
  var i = ur([e], [], t);
  return i.height = Math.max(n || t.fontMetrics().defaultRuleThickness, t.minRuleThickness), i.style.borderBottomWidth = $e(i.height), i.maxFontSize = 1, i;
}, eg = function(e, t, n, i) {
  var o = new Os(e, t, n, i);
  return Ms(o), o;
}, ad = function(e) {
  var t = new Pi(e);
  return Ms(t), t;
}, tg = function(e, t) {
  return e instanceof Pi ? ur([], [e], t) : e;
}, rg = function(e) {
  if (e.positionType === "individualShift") {
    for (var t = e.children, n = [t[0]], i = -t[0].shift - t[0].elem.depth, o = i, s = 1; s < t.length; s++) {
      var a = -t[s].shift - o - t[s].elem.depth, l = a - (t[s - 1].elem.height + t[s - 1].elem.depth);
      o = o + a, n.push({
        type: "kern",
        size: l
      }), n.push(t[s]);
    }
    return {
      children: n,
      depth: i
    };
  }
  var u;
  if (e.positionType === "top") {
    for (var d = e.positionData, p = 0; p < e.children.length; p++) {
      var m = e.children[p];
      d -= m.type === "kern" ? m.size : m.elem.height + m.elem.depth;
    }
    u = d;
  } else if (e.positionType === "bottom")
    u = -e.positionData;
  else {
    var c = e.children[0];
    if (c.type !== "elem")
      throw new Error('First child must have type "elem".');
    if (e.positionType === "shift")
      u = -c.elem.depth - e.positionData;
    else if (e.positionType === "firstBaseline")
      u = -c.elem.depth;
    else
      throw new Error("Invalid positionType " + e.positionType + ".");
  }
  return {
    children: e.children,
    depth: u
  };
}, ng = function(e, t) {
  for (var {
    children: n,
    depth: i
  } = rg(e), o = 0, s = 0; s < n.length; s++) {
    var a = n[s];
    if (a.type === "elem") {
      var l = a.elem;
      o = Math.max(o, l.maxFontSize, l.height);
    }
  }
  o += 2;
  var u = ur(["pstrut"], []);
  u.style.height = $e(o);
  for (var d = [], p = i, m = i, c = i, h = 0; h < n.length; h++) {
    var f = n[h];
    if (f.type === "kern")
      c += f.size;
    else {
      var N = f.elem, v = f.wrapperClasses || [], C = f.wrapperStyle || {}, g = ur(v, [u, N], void 0, C);
      g.style.top = $e(-o - c - N.depth), f.marginLeft && (g.style.marginLeft = f.marginLeft), f.marginRight && (g.style.marginRight = f.marginRight), d.push(g), c += N.height + N.depth;
    }
    p = Math.min(p, c), m = Math.max(m, c);
  }
  var x = ur(["vlist"], d);
  x.style.height = $e(m);
  var b;
  if (p < 0) {
    var A = ur([], []), w = ur(["vlist"], [A]);
    w.style.height = $e(-p);
    var M = ur(["vlist-s"], [new br("â€‹")]);
    b = [ur(["vlist-r"], [x, M]), ur(["vlist-r"], [w])];
  } else
    b = [ur(["vlist-r"], [x])];
  var y = ur(["vlist-t"], b);
  return b.length === 2 && y.classes.push("vlist-t2"), y.height = m, y.depth = -p, y;
}, ig = (r, e) => {
  var t = ur(["mspace"], [], e), n = Ht(r, e);
  return t.style.marginRight = $e(n), t;
}, Xi = function(e, t, n) {
  var i = "";
  switch (e) {
    case "amsrm":
      i = "AMS";
      break;
    case "textrm":
      i = "Main";
      break;
    case "textsf":
      i = "SansSerif";
      break;
    case "texttt":
      i = "Typewriter";
      break;
    default:
      i = e;
  }
  var o;
  return t === "textbf" && n === "textit" ? o = "BoldItalic" : t === "textbf" ? o = "Bold" : t === "textit" ? o = "Italic" : o = "Regular", i + "-" + o;
}, sd = {
  // styles
  mathbf: {
    variant: "bold",
    fontName: "Main-Bold"
  },
  mathrm: {
    variant: "normal",
    fontName: "Main-Regular"
  },
  textit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathnormal: {
    variant: "italic",
    fontName: "Math-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  mathbb: {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  mathcal: {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  mathfrak: {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  mathscr: {
    variant: "script",
    fontName: "Script-Regular"
  },
  mathsf: {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  mathtt: {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
}, ld = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
}, og = function(e, t) {
  var [n, i, o] = ld[e], s = new dn(n), a = new Vr([s], {
    width: $e(i),
    height: $e(o),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + $e(i),
    viewBox: "0 0 " + 1e3 * i + " " + 1e3 * o,
    preserveAspectRatio: "xMinYMin"
  }), l = od(["overlay"], [a], t);
  return l.height = o, l.style.height = $e(o), l.style.width = $e(i), l;
}, ge = {
  fontMap: sd,
  makeSymbol: Er,
  mathsym: Gm,
  makeSpan: ur,
  makeSvgSpan: od,
  makeLineSpan: Qm,
  makeAnchor: eg,
  makeFragment: ad,
  wrapFragment: tg,
  makeVList: ng,
  makeOrd: Xm,
  makeGlue: ig,
  staticSvg: og,
  svgData: ld,
  tryCombineChars: Zm
}, zt = {
  number: 3,
  unit: "mu"
}, vn = {
  number: 4,
  unit: "mu"
}, zr = {
  number: 5,
  unit: "mu"
}, ag = {
  mord: {
    mop: zt,
    mbin: vn,
    mrel: zr,
    minner: zt
  },
  mop: {
    mord: zt,
    mop: zt,
    mrel: zr,
    minner: zt
  },
  mbin: {
    mord: vn,
    mop: vn,
    mopen: vn,
    minner: vn
  },
  mrel: {
    mord: zr,
    mop: zr,
    mopen: zr,
    minner: zr
  },
  mopen: {},
  mclose: {
    mop: zt,
    mbin: vn,
    mrel: zr,
    minner: zt
  },
  mpunct: {
    mord: zt,
    mop: zt,
    mrel: zr,
    mopen: zt,
    mclose: zt,
    mpunct: zt,
    minner: zt
  },
  minner: {
    mord: zt,
    mop: zt,
    mbin: vn,
    mrel: zr,
    mopen: zt,
    mpunct: zt,
    minner: zt
  }
}, sg = {
  mord: {
    mop: zt
  },
  mop: {
    mord: zt,
    mop: zt
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: zt
  },
  mpunct: {},
  minner: {
    mop: zt
  }
}, cd = {}, _o = {}, Co = {};
function ze(r) {
  for (var {
    type: e,
    names: t,
    props: n,
    handler: i,
    htmlBuilder: o,
    mathmlBuilder: s
  } = r, a = {
    type: e,
    numArgs: n.numArgs,
    argTypes: n.argTypes,
    allowedInArgument: !!n.allowedInArgument,
    allowedInText: !!n.allowedInText,
    allowedInMath: n.allowedInMath === void 0 ? !0 : n.allowedInMath,
    numOptionalArgs: n.numOptionalArgs || 0,
    infix: !!n.infix,
    primitive: !!n.primitive,
    handler: i
  }, l = 0; l < t.length; ++l)
    cd[t[l]] = a;
  e && (o && (_o[e] = o), s && (Co[e] = s));
}
function Ln(r) {
  var {
    type: e,
    htmlBuilder: t,
    mathmlBuilder: n
  } = r;
  ze({
    type: e,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: t,
    mathmlBuilder: n
  });
}
var bo = function(e) {
  return e.type === "ordgroup" && e.body.length === 1 ? e.body[0] : e;
}, Yt = function(e) {
  return e.type === "ordgroup" ? e.body : [e];
}, Xr = ge.makeSpan, lg = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], cg = ["rightmost", "mrel", "mclose", "mpunct"], ug = {
  display: et.DISPLAY,
  text: et.TEXT,
  script: et.SCRIPT,
  scriptscript: et.SCRIPTSCRIPT
}, dg = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
}, Qt = function(e, t, n, i) {
  i === void 0 && (i = [null, null]);
  for (var o = [], s = 0; s < e.length; s++) {
    var a = yt(e[s], t);
    if (a instanceof Pi) {
      var l = a.children;
      o.push(...l);
    } else
      o.push(a);
  }
  if (ge.tryCombineChars(o), !n)
    return o;
  var u = t;
  if (e.length === 1) {
    var d = e[0];
    d.type === "sizing" ? u = t.havingSize(d.size) : d.type === "styling" && (u = t.havingStyle(ug[d.style]));
  }
  var p = Xr([i[0] || "leftmost"], [], t), m = Xr([i[1] || "rightmost"], [], t), c = n === "root";
  return $0(o, (h, f) => {
    var N = f.classes[0], v = h.classes[0];
    N === "mbin" && Xe.contains(cg, v) ? f.classes[0] = "mord" : v === "mbin" && Xe.contains(lg, N) && (h.classes[0] = "mord");
  }, {
    node: p
  }, m, c), $0(o, (h, f) => {
    var N = Za(f), v = Za(h), C = N && v ? h.hasClass("mtight") ? sg[N][v] : ag[N][v] : null;
    if (C)
      return ge.makeGlue(C, u);
  }, {
    node: p
  }, m, c), o;
}, $0 = function r(e, t, n, i, o) {
  i && e.push(i);
  for (var s = 0; s < e.length; s++) {
    var a = e[s], l = ud(a);
    if (l) {
      r(l.children, t, n, null, o);
      continue;
    }
    var u = !a.hasClass("mspace");
    if (u) {
      var d = t(a, n.node);
      d && (n.insertAfter ? n.insertAfter(d) : (e.unshift(d), s++));
    }
    u ? n.node = a : o && a.hasClass("newline") && (n.node = Xr(["leftmost"])), n.insertAfter = /* @__PURE__ */ ((p) => (m) => {
      e.splice(p + 1, 0, m), s++;
    })(s);
  }
  i && e.pop();
}, ud = function(e) {
  return e instanceof Pi || e instanceof Os || e instanceof Fi && e.hasClass("enclosing") ? e : null;
}, hg = function r(e, t) {
  var n = ud(e);
  if (n) {
    var i = n.children;
    if (i.length) {
      if (t === "right")
        return r(i[i.length - 1], "right");
      if (t === "left")
        return r(i[0], "left");
    }
  }
  return e;
}, Za = function(e, t) {
  return e ? (t && (e = hg(e, t)), dg[e.classes[0]] || null) : null;
}, Ei = function(e, t) {
  var n = ["nulldelimiter"].concat(e.baseSizingClasses());
  return Xr(t.concat(n));
}, yt = function(e, t, n) {
  if (!e)
    return Xr();
  if (_o[e.type]) {
    var i = _o[e.type](e, t);
    if (n && t.size !== n.size) {
      i = Xr(t.sizingClasses(n), [i], t);
      var o = t.sizeMultiplier / n.sizeMultiplier;
      i.height *= o, i.depth *= o;
    }
    return i;
  } else
    throw new Re("Got group of unknown type: '" + e.type + "'");
};
function Ji(r, e) {
  var t = Xr(["base"], r, e), n = Xr(["strut"]);
  return n.style.height = $e(t.height + t.depth), t.depth && (n.style.verticalAlign = $e(-t.depth)), t.children.unshift(n), t;
}
function Qa(r, e) {
  var t = null;
  r.length === 1 && r[0].type === "tag" && (t = r[0].tag, r = r[0].body);
  var n = Qt(r, e, "root"), i;
  n.length === 2 && n[1].hasClass("tag") && (i = n.pop());
  for (var o = [], s = [], a = 0; a < n.length; a++)
    if (s.push(n[a]), n[a].hasClass("mbin") || n[a].hasClass("mrel") || n[a].hasClass("allowbreak")) {
      for (var l = !1; a < n.length - 1 && n[a + 1].hasClass("mspace") && !n[a + 1].hasClass("newline"); )
        a++, s.push(n[a]), n[a].hasClass("nobreak") && (l = !0);
      l || (o.push(Ji(s, e)), s = []);
    } else n[a].hasClass("newline") && (s.pop(), s.length > 0 && (o.push(Ji(s, e)), s = []), o.push(n[a]));
  s.length > 0 && o.push(Ji(s, e));
  var u;
  t ? (u = Ji(Qt(t, e, !0)), u.classes = ["tag"], o.push(u)) : i && o.push(i);
  var d = Xr(["katex-html"], o);
  if (d.setAttribute("aria-hidden", "true"), u) {
    var p = u.children[0];
    p.style.height = $e(d.height + d.depth), d.depth && (p.style.verticalAlign = $e(-d.depth));
  }
  return d;
}
function dd(r) {
  return new Pi(r);
}
class Nr {
  constructor(e, t, n) {
    this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = e, this.attributes = {}, this.children = t || [], this.classes = n || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(e) {
    return this.attributes[e];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && e.setAttribute(t, this.attributes[t]);
    this.classes.length > 0 && (e.className = un(this.classes));
    for (var n = 0; n < this.children.length; n++)
      e.appendChild(this.children[n].toNode());
    return e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var e = "<" + this.type;
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="', e += Xe.escape(this.attributes[t]), e += '"');
    this.classes.length > 0 && (e += ' class ="' + Xe.escape(un(this.classes)) + '"'), e += ">";
    for (var n = 0; n < this.children.length; n++)
      e += this.children[n].toMarkup();
    return e += "</" + this.type + ">", e;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((e) => e.toText()).join("");
  }
}
class bi {
  constructor(e) {
    this.text = void 0, this.text = e;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return Xe.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}
class fg {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(e) {
    this.width = void 0, this.character = void 0, this.width = e, e >= 0.05555 && e <= 0.05556 ? this.character = "â€Š" : e >= 0.1666 && e <= 0.1667 ? this.character = "â€‰" : e >= 0.2222 && e <= 0.2223 ? this.character = "â€…" : e >= 0.2777 && e <= 0.2778 ? this.character = "â€…â€Š" : e >= -0.05556 && e <= -0.05555 ? this.character = "â€Šâ£" : e >= -0.1667 && e <= -0.1666 ? this.character = "â€‰â£" : e >= -0.2223 && e <= -0.2222 ? this.character = "âŸâ£" : e >= -0.2778 && e <= -0.2777 ? this.character = "â€…â£" : this.character = null;
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character)
      return document.createTextNode(this.character);
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
    return e.setAttribute("width", $e(this.width)), e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + $e(this.width) + '"/>';
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    return this.character ? this.character : " ";
  }
}
var Me = {
  MathNode: Nr,
  TextNode: bi,
  SpaceNode: fg,
  newDocumentFragment: dd
}, yr = function(e, t, n) {
  return Lt[t][e] && Lt[t][e].replace && e.charCodeAt(0) !== 55349 && !(id.hasOwnProperty(e) && n && (n.fontFamily && n.fontFamily.slice(4, 6) === "tt" || n.font && n.font.slice(4, 6) === "tt")) && (e = Lt[t][e].replace), new Me.TextNode(e);
}, Rs = function(e) {
  return e.length === 1 ? e[0] : new Me.MathNode("mrow", e);
}, As = function(e, t) {
  if (t.fontFamily === "texttt")
    return "monospace";
  if (t.fontFamily === "textsf")
    return t.fontShape === "textit" && t.fontWeight === "textbf" ? "sans-serif-bold-italic" : t.fontShape === "textit" ? "sans-serif-italic" : t.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
  if (t.fontShape === "textit" && t.fontWeight === "textbf")
    return "bold-italic";
  if (t.fontShape === "textit")
    return "italic";
  if (t.fontWeight === "textbf")
    return "bold";
  var n = t.font;
  if (!n || n === "mathnormal")
    return null;
  var i = e.mode;
  if (n === "mathit")
    return "italic";
  if (n === "boldsymbol")
    return e.type === "textord" ? "bold" : "bold-italic";
  if (n === "mathbf")
    return "bold";
  if (n === "mathbb")
    return "double-struck";
  if (n === "mathfrak")
    return "fraktur";
  if (n === "mathscr" || n === "mathcal")
    return "script";
  if (n === "mathsf")
    return "sans-serif";
  if (n === "mathtt")
    return "monospace";
  var o = e.text;
  if (Xe.contains(["\\imath", "\\jmath"], o))
    return null;
  Lt[i][o] && Lt[i][o].replace && (o = Lt[i][o].replace);
  var s = ge.fontMap[n].fontName;
  return Ss(o, s, i) ? ge.fontMap[n].variant : null;
}, gr = function(e, t, n) {
  if (e.length === 1) {
    var i = Mt(e[0], t);
    return n && i instanceof Nr && i.type === "mo" && (i.setAttribute("lspace", "0em"), i.setAttribute("rspace", "0em")), [i];
  }
  for (var o = [], s, a = 0; a < e.length; a++) {
    var l = Mt(e[a], t);
    if (l instanceof Nr && s instanceof Nr) {
      if (l.type === "mtext" && s.type === "mtext" && l.getAttribute("mathvariant") === s.getAttribute("mathvariant")) {
        s.children.push(...l.children);
        continue;
      } else if (l.type === "mn" && s.type === "mn") {
        s.children.push(...l.children);
        continue;
      } else if (l.type === "mi" && l.children.length === 1 && s.type === "mn") {
        var u = l.children[0];
        if (u instanceof bi && u.text === ".") {
          s.children.push(...l.children);
          continue;
        }
      } else if (s.type === "mi" && s.children.length === 1) {
        var d = s.children[0];
        if (d instanceof bi && d.text === "Ì¸" && (l.type === "mo" || l.type === "mi" || l.type === "mn")) {
          var p = l.children[0];
          p instanceof bi && p.text.length > 0 && (p.text = p.text.slice(0, 1) + "Ì¸" + p.text.slice(1), o.pop());
        }
      }
    }
    o.push(l), s = l;
  }
  return o;
}, hn = function(e, t, n) {
  return Rs(gr(e, t, n));
}, Mt = function(e, t) {
  if (!e)
    return new Me.MathNode("mrow");
  if (Co[e.type]) {
    var n = Co[e.type](e, t);
    return n;
  } else
    throw new Re("Got group of unknown type: '" + e.type + "'");
};
function I0(r, e, t, n, i) {
  var o = gr(r, t), s;
  o.length === 1 && o[0] instanceof Nr && Xe.contains(["mrow", "mtable"], o[0].type) ? s = o[0] : s = new Me.MathNode("mrow", o);
  var a = new Me.MathNode("annotation", [new Me.TextNode(e)]);
  a.setAttribute("encoding", "application/x-tex");
  var l = new Me.MathNode("semantics", [s, a]), u = new Me.MathNode("math", [l]);
  u.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), n && u.setAttribute("display", "block");
  var d = i ? "katex" : "katex-mathml";
  return ge.makeSpan([d], [u]);
}
var hd = function(e) {
  return new Yr({
    style: e.displayMode ? et.DISPLAY : et.TEXT,
    maxSize: e.maxSize,
    minRuleThickness: e.minRuleThickness
  });
}, fd = function(e, t) {
  if (t.displayMode) {
    var n = ["katex-display"];
    t.leqno && n.push("leqno"), t.fleqn && n.push("fleqn"), e = ge.makeSpan(n, [e]);
  }
  return e;
}, mg = function(e, t, n) {
  var i = hd(n), o;
  if (n.output === "mathml")
    return I0(e, t, i, n.displayMode, !0);
  if (n.output === "html") {
    var s = Qa(e, i);
    o = ge.makeSpan(["katex"], [s]);
  } else {
    var a = I0(e, t, i, n.displayMode, !1), l = Qa(e, i);
    o = ge.makeSpan(["katex"], [a, l]);
  }
  return fd(o, n);
}, gg = function(e, t, n) {
  var i = hd(n), o = Qa(e, i), s = ge.makeSpan(["katex"], [o]);
  return fd(s, n);
}, pg = {
  widehat: "^",
  widecheck: "Ë‡",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "â†",
  underleftarrow: "â†",
  xleftarrow: "â†",
  overrightarrow: "â†’",
  underrightarrow: "â†’",
  xrightarrow: "â†’",
  underbrace: "âŸ",
  overbrace: "âž",
  overgroup: "â ",
  undergroup: "â¡",
  overleftrightarrow: "â†”",
  underleftrightarrow: "â†”",
  xleftrightarrow: "â†”",
  Overrightarrow: "â‡’",
  xRightarrow: "â‡’",
  overleftharpoon: "â†¼",
  xleftharpoonup: "â†¼",
  overrightharpoon: "â‡€",
  xrightharpoonup: "â‡€",
  xLeftarrow: "â‡",
  xLeftrightarrow: "â‡”",
  xhookleftarrow: "â†©",
  xhookrightarrow: "â†ª",
  xmapsto: "â†¦",
  xrightharpoondown: "â‡",
  xleftharpoondown: "â†½",
  xrightleftharpoons: "â‡Œ",
  xleftrightharpoons: "â‡‹",
  xtwoheadleftarrow: "â†ž",
  xtwoheadrightarrow: "â† ",
  xlongequal: "=",
  xtofrom: "â‡„",
  xrightleftarrows: "â‡„",
  xrightequilibrium: "â‡Œ",
  // Not a perfect match.
  xleftequilibrium: "â‡‹",
  // None better available.
  "\\cdrightarrow": "â†’",
  "\\cdleftarrow": "â†",
  "\\cdlongequal": "="
}, vg = function(e) {
  var t = new Me.MathNode("mo", [new Me.TextNode(pg[e.replace(/^\\/, "")])]);
  return t.setAttribute("stretchy", "true"), t;
}, xg = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
}, Ng = function(e) {
  return e.type === "ordgroup" ? e.body.length : 1;
}, _g = function(e, t) {
  function n() {
    var a = 4e5, l = e.label.slice(1);
    if (Xe.contains(["widehat", "widecheck", "widetilde", "utilde"], l)) {
      var u = e, d = Ng(u.base), p, m, c;
      if (d > 5)
        l === "widehat" || l === "widecheck" ? (p = 420, a = 2364, c = 0.42, m = l + "4") : (p = 312, a = 2340, c = 0.34, m = "tilde4");
      else {
        var h = [1, 1, 2, 2, 3, 3][d];
        l === "widehat" || l === "widecheck" ? (a = [0, 1062, 2364, 2364, 2364][h], p = [0, 239, 300, 360, 420][h], c = [0, 0.24, 0.3, 0.3, 0.36, 0.42][h], m = l + h) : (a = [0, 600, 1033, 2339, 2340][h], p = [0, 260, 286, 306, 312][h], c = [0, 0.26, 0.286, 0.3, 0.306, 0.34][h], m = "tilde" + h);
      }
      var f = new dn(m), N = new Vr([f], {
        width: "100%",
        height: $e(c),
        viewBox: "0 0 " + a + " " + p,
        preserveAspectRatio: "none"
      });
      return {
        span: ge.makeSvgSpan([], [N], t),
        minWidth: 0,
        height: c
      };
    } else {
      var v = [], C = xg[l], [g, x, b] = C, A = b / 1e3, w = g.length, M, y;
      if (w === 1) {
        var E = C[3];
        M = ["hide-tail"], y = [E];
      } else if (w === 2)
        M = ["halfarrow-left", "halfarrow-right"], y = ["xMinYMin", "xMaxYMin"];
      else if (w === 3)
        M = ["brace-left", "brace-center", "brace-right"], y = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      else
        throw new Error(`Correct katexImagesData or update code here to support
                    ` + w + " children.");
      for (var S = 0; S < w; S++) {
        var P = new dn(g[S]), U = new Vr([P], {
          width: "400em",
          height: $e(A),
          viewBox: "0 0 " + a + " " + b,
          preserveAspectRatio: y[S] + " slice"
        }), j = ge.makeSvgSpan([M[S]], [U], t);
        if (w === 1)
          return {
            span: j,
            minWidth: x,
            height: A
          };
        j.style.height = $e(A), v.push(j);
      }
      return {
        span: ge.makeSpan(["stretchy"], v, t),
        minWidth: x,
        height: A
      };
    }
  }
  var {
    span: i,
    minWidth: o,
    height: s
  } = n();
  return i.height = s, i.style.height = $e(s), o > 0 && (i.style.minWidth = $e(o)), i;
}, Cg = function(e, t, n, i, o) {
  var s, a = e.height + e.depth + n + i;
  if (/fbox|color|angl/.test(t)) {
    if (s = ge.makeSpan(["stretchy", t], [], o), t === "fbox") {
      var l = o.color && o.getColor();
      l && (s.style.borderColor = l);
    }
  } else {
    var u = [];
    /^[bx]cancel$/.test(t) && u.push(new Xa({
      x1: "0",
      y1: "0",
      x2: "100%",
      y2: "100%",
      "stroke-width": "0.046em"
    })), /^x?cancel$/.test(t) && u.push(new Xa({
      x1: "0",
      y1: "100%",
      x2: "100%",
      y2: "0",
      "stroke-width": "0.046em"
    }));
    var d = new Vr(u, {
      width: "100%",
      height: $e(a)
    });
    s = ge.makeSvgSpan([], [d], o);
  }
  return s.height = a, s.style.height = $e(a), s;
}, Jr = {
  encloseSpan: Cg,
  mathMLnode: vg,
  svgSpan: _g
};
function dt(r, e) {
  if (!r || r.type !== e)
    throw new Error("Expected node of type " + e + ", but got " + (r ? "node of type " + r.type : String(r)));
  return r;
}
function Ls(r) {
  var e = Oo(r);
  if (!e)
    throw new Error("Expected node of symbol group type, but got " + (r ? "node of type " + r.type : String(r)));
  return e;
}
function Oo(r) {
  return r && (r.type === "atom" || Ym.hasOwnProperty(r.type)) ? r : null;
}
var ks = (r, e) => {
  var t, n, i;
  r && r.type === "supsub" ? (n = dt(r.base, "accent"), t = n.base, r.base = t, i = Km(yt(r, e)), r.base = n) : (n = dt(r, "accent"), t = n.base);
  var o = yt(t, e.havingCrampedStyle()), s = n.isShifty && Xe.isCharacterBox(t), a = 0;
  if (s) {
    var l = Xe.getBaseElem(t), u = yt(l, e.havingCrampedStyle());
    a = M0(u).skew;
  }
  var d = n.label === "\\c", p = d ? o.height + o.depth : Math.min(o.height, e.fontMetrics().xHeight), m;
  if (n.isStretchy)
    m = Jr.svgSpan(n, e), m = ge.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: o
      }, {
        type: "elem",
        elem: m,
        wrapperClasses: ["svg-align"],
        wrapperStyle: a > 0 ? {
          width: "calc(100% - " + $e(2 * a) + ")",
          marginLeft: $e(2 * a)
        } : void 0
      }]
    }, e);
  else {
    var c, h;
    n.label === "\\vec" ? (c = ge.staticSvg("vec", e), h = ge.svgData.vec[1]) : (c = ge.makeOrd({
      mode: n.mode,
      text: n.label
    }, e, "textord"), c = M0(c), c.italic = 0, h = c.width, d && (p += c.depth)), m = ge.makeSpan(["accent-body"], [c]);
    var f = n.label === "\\textcircled";
    f && (m.classes.push("accent-full"), p = o.height);
    var N = a;
    f || (N -= h / 2), m.style.left = $e(N), n.label === "\\textcircled" && (m.style.top = ".2em"), m = ge.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: o
      }, {
        type: "kern",
        size: -p
      }, {
        type: "elem",
        elem: m
      }]
    }, e);
  }
  var v = ge.makeSpan(["mord", "accent"], [m], e);
  return i ? (i.children[0] = v, i.height = Math.max(v.height, i.height), i.classes[0] = "mord", i) : v;
}, md = (r, e) => {
  var t = r.isStretchy ? Jr.mathMLnode(r.label) : new Me.MathNode("mo", [yr(r.label, r.mode)]), n = new Me.MathNode("mover", [Mt(r.base, e), t]);
  return n.setAttribute("accent", "true"), n;
}, bg = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((r) => "\\" + r).join("|"));
ze({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (r, e) => {
    var t = bo(e[0]), n = !bg.test(r.funcName), i = !n || r.funcName === "\\widehat" || r.funcName === "\\widetilde" || r.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: r.parser.mode,
      label: r.funcName,
      isStretchy: n,
      isShifty: i,
      base: t
    };
  },
  htmlBuilder: ks,
  mathmlBuilder: md
});
ze({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (r, e) => {
    var t = e[0], n = r.parser.mode;
    return n === "math" && (r.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + r.funcName + " works only in text mode"), n = "text"), {
      type: "accent",
      mode: n,
      label: r.funcName,
      isStretchy: !1,
      isShifty: !0,
      base: t
    };
  },
  htmlBuilder: ks,
  mathmlBuilder: md
});
ze({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (r, e) => {
    var {
      parser: t,
      funcName: n
    } = r, i = e[0];
    return {
      type: "accentUnder",
      mode: t.mode,
      label: n,
      base: i
    };
  },
  htmlBuilder: (r, e) => {
    var t = yt(r.base, e), n = Jr.svgSpan(r, e), i = r.label === "\\utilde" ? 0.12 : 0, o = ge.makeVList({
      positionType: "top",
      positionData: t.height,
      children: [{
        type: "elem",
        elem: n,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: t
      }]
    }, e);
    return ge.makeSpan(["mord", "accentunder"], [o], e);
  },
  mathmlBuilder: (r, e) => {
    var t = Jr.mathMLnode(r.label), n = new Me.MathNode("munder", [Mt(r.base, e), t]);
    return n.setAttribute("accentunder", "true"), n;
  }
});
var Zi = (r) => {
  var e = new Me.MathNode("mpadded", r ? [r] : []);
  return e.setAttribute("width", "+0.6em"), e.setAttribute("lspace", "0.3em"), e;
};
ze({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(r, e, t) {
    var {
      parser: n,
      funcName: i
    } = r;
    return {
      type: "xArrow",
      mode: n.mode,
      label: i,
      body: e[0],
      below: t[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(r, e) {
    var t = e.style, n = e.havingStyle(t.sup()), i = ge.wrapFragment(yt(r.body, n, e), e), o = r.label.slice(0, 2) === "\\x" ? "x" : "cd";
    i.classes.push(o + "-arrow-pad");
    var s;
    r.below && (n = e.havingStyle(t.sub()), s = ge.wrapFragment(yt(r.below, n, e), e), s.classes.push(o + "-arrow-pad"));
    var a = Jr.svgSpan(r, e), l = -e.fontMetrics().axisHeight + 0.5 * a.height, u = -e.fontMetrics().axisHeight - 0.5 * a.height - 0.111;
    (i.depth > 0.25 || r.label === "\\xleftequilibrium") && (u -= i.depth);
    var d;
    if (s) {
      var p = -e.fontMetrics().axisHeight + s.height + 0.5 * a.height + 0.111;
      d = ge.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: u
        }, {
          type: "elem",
          elem: a,
          shift: l
        }, {
          type: "elem",
          elem: s,
          shift: p
        }]
      }, e);
    } else
      d = ge.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: u
        }, {
          type: "elem",
          elem: a,
          shift: l
        }]
      }, e);
    return d.children[0].children[0].children[1].classes.push("svg-align"), ge.makeSpan(["mrel", "x-arrow"], [d], e);
  },
  mathmlBuilder(r, e) {
    var t = Jr.mathMLnode(r.label);
    t.setAttribute("minsize", r.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var n;
    if (r.body) {
      var i = Zi(Mt(r.body, e));
      if (r.below) {
        var o = Zi(Mt(r.below, e));
        n = new Me.MathNode("munderover", [t, o, i]);
      } else
        n = new Me.MathNode("mover", [t, i]);
    } else if (r.below) {
      var s = Zi(Mt(r.below, e));
      n = new Me.MathNode("munder", [t, s]);
    } else
      n = Zi(), n = new Me.MathNode("mover", [t, n]);
    return n;
  }
});
var yg = ge.makeSpan;
function gd(r, e) {
  var t = Qt(r.body, e, !0);
  return yg([r.mclass], t, e);
}
function pd(r, e) {
  var t, n = gr(r.body, e);
  return r.mclass === "minner" ? t = new Me.MathNode("mpadded", n) : r.mclass === "mord" ? r.isCharacterBox ? (t = n[0], t.type = "mi") : t = new Me.MathNode("mi", n) : (r.isCharacterBox ? (t = n[0], t.type = "mo") : t = new Me.MathNode("mo", n), r.mclass === "mbin" ? (t.attributes.lspace = "0.22em", t.attributes.rspace = "0.22em") : r.mclass === "mpunct" ? (t.attributes.lspace = "0em", t.attributes.rspace = "0.17em") : r.mclass === "mopen" || r.mclass === "mclose" ? (t.attributes.lspace = "0em", t.attributes.rspace = "0em") : r.mclass === "minner" && (t.attributes.lspace = "0.0556em", t.attributes.width = "+0.1111em")), t;
}
ze({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler(r, e) {
    var {
      parser: t,
      funcName: n
    } = r, i = e[0];
    return {
      type: "mclass",
      mode: t.mode,
      mclass: "m" + n.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: Yt(i),
      isCharacterBox: Xe.isCharacterBox(i)
    };
  },
  htmlBuilder: gd,
  mathmlBuilder: pd
});
var Mo = (r) => {
  var e = r.type === "ordgroup" && r.body.length ? r.body[0] : r;
  return e.type === "atom" && (e.family === "bin" || e.family === "rel") ? "m" + e.family : "mord";
};
ze({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(r, e) {
    var {
      parser: t
    } = r;
    return {
      type: "mclass",
      mode: t.mode,
      mclass: Mo(e[0]),
      body: Yt(e[1]),
      isCharacterBox: Xe.isCharacterBox(e[1])
    };
  }
});
ze({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(r, e) {
    var {
      parser: t,
      funcName: n
    } = r, i = e[1], o = e[0], s;
    n !== "\\stackrel" ? s = Mo(i) : s = "mrel";
    var a = {
      type: "op",
      mode: i.mode,
      limits: !0,
      alwaysHandleSupSub: !0,
      parentIsSupSub: !1,
      symbol: !1,
      suppressBaseShift: n !== "\\stackrel",
      body: Yt(i)
    }, l = {
      type: "supsub",
      mode: o.mode,
      base: a,
      sup: n === "\\underset" ? null : o,
      sub: n === "\\underset" ? o : null
    };
    return {
      type: "mclass",
      mode: t.mode,
      mclass: s,
      body: [l],
      isCharacterBox: Xe.isCharacterBox(l)
    };
  },
  htmlBuilder: gd,
  mathmlBuilder: pd
});
ze({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(r, e) {
    var {
      parser: t
    } = r;
    return {
      type: "pmb",
      mode: t.mode,
      mclass: Mo(e[0]),
      body: Yt(e[0])
    };
  },
  htmlBuilder(r, e) {
    var t = Qt(r.body, e, !0), n = ge.makeSpan([r.mclass], t, e);
    return n.style.textShadow = "0.02em 0.01em 0.04px", n;
  },
  mathmlBuilder(r, e) {
    var t = gr(r.body, e), n = new Me.MathNode("mstyle", t);
    return n.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), n;
  }
});
var wg = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
}, P0 = () => ({
  type: "styling",
  body: [],
  mode: "math",
  style: "display"
}), F0 = (r) => r.type === "textord" && r.text === "@", Tg = (r, e) => (r.type === "mathord" || r.type === "atom") && r.text === e;
function Eg(r, e, t) {
  var n = wg[r];
  switch (n) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return t.callFunction(n, [e[0]], [e[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var i = t.callFunction("\\\\cdleft", [e[0]], []), o = {
        type: "atom",
        text: n,
        mode: "math",
        family: "rel"
      }, s = t.callFunction("\\Big", [o], []), a = t.callFunction("\\\\cdright", [e[1]], []), l = {
        type: "ordgroup",
        mode: "math",
        body: [i, s, a]
      };
      return t.callFunction("\\\\cdparent", [l], []);
    }
    case "\\\\cdlongequal":
      return t.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var u = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return t.callFunction("\\Big", [u], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function Sg(r) {
  var e = [];
  for (r.gullet.beginGroup(), r.gullet.macros.set("\\cr", "\\\\\\relax"), r.gullet.beginGroup(); ; ) {
    e.push(r.parseExpression(!1, "\\\\")), r.gullet.endGroup(), r.gullet.beginGroup();
    var t = r.fetch().text;
    if (t === "&" || t === "\\\\")
      r.consume();
    else if (t === "\\end") {
      e[e.length - 1].length === 0 && e.pop();
      break;
    } else
      throw new Re("Expected \\\\ or \\cr or \\end", r.nextToken);
  }
  for (var n = [], i = [n], o = 0; o < e.length; o++) {
    for (var s = e[o], a = P0(), l = 0; l < s.length; l++)
      if (!F0(s[l]))
        a.body.push(s[l]);
      else {
        n.push(a), l += 1;
        var u = Ls(s[l]).text, d = new Array(2);
        if (d[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, d[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, !("=|.".indexOf(u) > -1)) if ("<>AV".indexOf(u) > -1)
          for (var p = 0; p < 2; p++) {
            for (var m = !0, c = l + 1; c < s.length; c++) {
              if (Tg(s[c], u)) {
                m = !1, l = c;
                break;
              }
              if (F0(s[c]))
                throw new Re("Missing a " + u + " character to complete a CD arrow.", s[c]);
              d[p].body.push(s[c]);
            }
            if (m)
              throw new Re("Missing a " + u + " character to complete a CD arrow.", s[l]);
          }
        else
          throw new Re('Expected one of "<>AV=|." after @', s[l]);
        var h = Eg(u, d, r), f = {
          type: "styling",
          body: [h],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        n.push(f), a = P0();
      }
    o % 2 === 0 ? n.push(a) : n.shift(), n = [], i.push(n);
  }
  r.gullet.endGroup(), r.gullet.endGroup();
  var N = new Array(i[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body: i,
    arraystretch: 1,
    addJot: !0,
    rowGaps: [null],
    cols: N,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(i.length + 1).fill([])
  };
}
ze({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(r, e) {
    var {
      parser: t,
      funcName: n
    } = r;
    return {
      type: "cdlabel",
      mode: t.mode,
      side: n.slice(4),
      label: e[0]
    };
  },
  htmlBuilder(r, e) {
    var t = e.havingStyle(e.style.sup()), n = ge.wrapFragment(yt(r.label, t, e), e);
    return n.classes.push("cd-label-" + r.side), n.style.bottom = $e(0.8 - n.depth), n.height = 0, n.depth = 0, n;
  },
  mathmlBuilder(r, e) {
    var t = new Me.MathNode("mrow", [Mt(r.label, e)]);
    return t = new Me.MathNode("mpadded", [t]), t.setAttribute("width", "0"), r.side === "left" && t.setAttribute("lspace", "-1width"), t.setAttribute("voffset", "0.7em"), t = new Me.MathNode("mstyle", [t]), t.setAttribute("displaystyle", "false"), t.setAttribute("scriptlevel", "1"), t;
  }
});
ze({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(r, e) {
    var {
      parser: t
    } = r;
    return {
      type: "cdlabelparent",
      mode: t.mode,
      fragment: e[0]
    };
  },
  htmlBuilder(r, e) {
    var t = ge.wrapFragment(yt(r.fragment, e), e);
    return t.classes.push("cd-vert-arrow"), t;
  },
  mathmlBuilder(r, e) {
    return new Me.MathNode("mrow", [Mt(r.fragment, e)]);
  }
});
ze({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(r, e) {
    for (var {
      parser: t
    } = r, n = dt(e[0], "ordgroup"), i = n.body, o = "", s = 0; s < i.length; s++) {
      var a = dt(i[s], "textord");
      o += a.text;
    }
    var l = parseInt(o), u;
    if (isNaN(l))
      throw new Re("\\@char has non-numeric argument " + o);
    if (l < 0 || l >= 1114111)
      throw new Re("\\@char with invalid code point " + o);
    return l <= 65535 ? u = String.fromCharCode(l) : (l -= 65536, u = String.fromCharCode((l >> 10) + 55296, (l & 1023) + 56320)), {
      type: "textord",
      mode: t.mode,
      text: u
    };
  }
});
var vd = (r, e) => {
  var t = Qt(r.body, e.withColor(r.color), !1);
  return ge.makeFragment(t);
}, xd = (r, e) => {
  var t = gr(r.body, e.withColor(r.color)), n = new Me.MathNode("mstyle", t);
  return n.setAttribute("mathcolor", r.color), n;
};
ze({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "original"]
  },
  handler(r, e) {
    var {
      parser: t
    } = r, n = dt(e[0], "color-token").color, i = e[1];
    return {
      type: "color",
      mode: t.mode,
      color: n,
      body: Yt(i)
    };
  },
  htmlBuilder: vd,
  mathmlBuilder: xd
});
ze({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    argTypes: ["color"]
  },
  handler(r, e) {
    var {
      parser: t,
      breakOnTokenText: n
    } = r, i = dt(e[0], "color-token").color;
    t.gullet.macros.set("\\current@color", i);
    var o = t.parseExpression(!0, n);
    return {
      type: "color",
      mode: t.mode,
      color: i,
      body: o
    };
  },
  htmlBuilder: vd,
  mathmlBuilder: xd
});
ze({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: !0
  },
  handler(r, e, t) {
    var {
      parser: n
    } = r, i = n.gullet.future().text === "[" ? n.parseSizeGroup(!0) : null, o = !n.settings.displayMode || !n.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: n.mode,
      newLine: o,
      size: i && dt(i, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(r, e) {
    var t = ge.makeSpan(["mspace"], [], e);
    return r.newLine && (t.classes.push("newline"), r.size && (t.style.marginTop = $e(Ht(r.size, e)))), t;
  },
  mathmlBuilder(r, e) {
    var t = new Me.MathNode("mspace");
    return r.newLine && (t.setAttribute("linebreak", "newline"), r.size && t.setAttribute("height", $e(Ht(r.size, e)))), t;
  }
});
var es = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
}, Nd = (r) => {
  var e = r.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(e))
    throw new Re("Expected a control sequence", r);
  return e;
}, Og = (r) => {
  var e = r.gullet.popToken();
  return e.text === "=" && (e = r.gullet.popToken(), e.text === " " && (e = r.gullet.popToken())), e;
}, _d = (r, e, t, n) => {
  var i = r.gullet.macros.get(t.text);
  i == null && (t.noexpand = !0, i = {
    tokens: [t],
    numArgs: 0,
    // reproduce the same behavior in expansion
    unexpandable: !r.gullet.isExpandable(t.text)
  }), r.gullet.macros.set(e, i, n);
};
ze({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // canâ€™t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(r) {
    var {
      parser: e,
      funcName: t
    } = r;
    e.consumeSpaces();
    var n = e.fetch();
    if (es[n.text])
      return (t === "\\global" || t === "\\\\globallong") && (n.text = es[n.text]), dt(e.parseFunction(), "internal");
    throw new Re("Invalid token after macro prefix", n);
  }
});
ze({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(r) {
    var {
      parser: e,
      funcName: t
    } = r, n = e.gullet.popToken(), i = n.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(i))
      throw new Re("Expected a control sequence", n);
    for (var o = 0, s, a = [[]]; e.gullet.future().text !== "{"; )
      if (n = e.gullet.popToken(), n.text === "#") {
        if (e.gullet.future().text === "{") {
          s = e.gullet.future(), a[o].push("{");
          break;
        }
        if (n = e.gullet.popToken(), !/^[1-9]$/.test(n.text))
          throw new Re('Invalid argument number "' + n.text + '"');
        if (parseInt(n.text) !== o + 1)
          throw new Re('Argument number "' + n.text + '" out of order');
        o++, a.push([]);
      } else {
        if (n.text === "EOF")
          throw new Re("Expected a macro definition");
        a[o].push(n.text);
      }
    var {
      tokens: l
    } = e.gullet.consumeArg();
    return s && l.unshift(s), (t === "\\edef" || t === "\\xdef") && (l = e.gullet.expandTokens(l), l.reverse()), e.gullet.macros.set(i, {
      tokens: l,
      numArgs: o,
      delimiters: a
    }, t === es[t]), {
      type: "internal",
      mode: e.mode
    };
  }
});
ze({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // canâ€™t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(r) {
    var {
      parser: e,
      funcName: t
    } = r, n = Nd(e.gullet.popToken());
    e.gullet.consumeSpaces();
    var i = Og(e);
    return _d(e, n, i, t === "\\\\globallet"), {
      type: "internal",
      mode: e.mode
    };
  }
});
ze({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // canâ€™t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(r) {
    var {
      parser: e,
      funcName: t
    } = r, n = Nd(e.gullet.popToken()), i = e.gullet.popToken(), o = e.gullet.popToken();
    return _d(e, n, o, t === "\\\\globalfuture"), e.gullet.pushToken(o), e.gullet.pushToken(i), {
      type: "internal",
      mode: e.mode
    };
  }
});
var Ni = function(e, t, n) {
  var i = Lt.math[e] && Lt.math[e].replace, o = Ss(i || e, t, n);
  if (!o)
    throw new Error("Unsupported symbol " + e + " and font size " + t + ".");
  return o;
}, Ds = function(e, t, n, i) {
  var o = n.havingBaseStyle(t), s = ge.makeSpan(i.concat(o.sizingClasses(n)), [e], n), a = o.sizeMultiplier / n.sizeMultiplier;
  return s.height *= a, s.depth *= a, s.maxFontSize = o.sizeMultiplier, s;
}, Cd = function(e, t, n) {
  var i = t.havingBaseStyle(n), o = (1 - t.sizeMultiplier / i.sizeMultiplier) * t.fontMetrics().axisHeight;
  e.classes.push("delimcenter"), e.style.top = $e(o), e.height -= o, e.depth += o;
}, Mg = function(e, t, n, i, o, s) {
  var a = ge.makeSymbol(e, "Main-Regular", o, i), l = Ds(a, t, i, s);
  return n && Cd(l, i, t), l;
}, Rg = function(e, t, n, i) {
  return ge.makeSymbol(e, "Size" + t + "-Regular", n, i);
}, bd = function(e, t, n, i, o, s) {
  var a = Rg(e, t, o, i), l = Ds(ge.makeSpan(["delimsizing", "size" + t], [a], i), et.TEXT, i, s);
  return n && Cd(l, i, et.TEXT), l;
}, ea = function(e, t, n) {
  var i;
  t === "Size1-Regular" ? i = "delim-size1" : i = "delim-size4";
  var o = ge.makeSpan(["delimsizinginner", i], [ge.makeSpan([], [ge.makeSymbol(e, t, n)])]);
  return {
    type: "elem",
    elem: o
  };
}, ta = function(e, t, n) {
  var i = $r["Size4-Regular"][e.charCodeAt(0)] ? $r["Size4-Regular"][e.charCodeAt(0)][4] : $r["Size1-Regular"][e.charCodeAt(0)][4], o = new dn("inner", Im(e, Math.round(1e3 * t))), s = new Vr([o], {
    width: $e(i),
    height: $e(t),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + $e(i),
    viewBox: "0 0 " + 1e3 * i + " " + Math.round(1e3 * t),
    preserveAspectRatio: "xMinYMin"
  }), a = ge.makeSvgSpan([], [s], n);
  return a.height = t, a.style.height = $e(t), a.style.width = $e(i), {
    type: "elem",
    elem: a
  };
}, ts = 8e-3, Qi = {
  type: "kern",
  size: -1 * ts
}, Ag = ["|", "\\lvert", "\\rvert", "\\vert"], Lg = ["\\|", "\\lVert", "\\rVert", "\\Vert"], yd = function(e, t, n, i, o, s) {
  var a, l, u, d, p = "", m = 0;
  a = u = d = e, l = null;
  var c = "Size1-Regular";
  e === "\\uparrow" ? u = d = "â" : e === "\\Uparrow" ? u = d = "â€–" : e === "\\downarrow" ? a = u = "â" : e === "\\Downarrow" ? a = u = "â€–" : e === "\\updownarrow" ? (a = "\\uparrow", u = "â", d = "\\downarrow") : e === "\\Updownarrow" ? (a = "\\Uparrow", u = "â€–", d = "\\Downarrow") : Xe.contains(Ag, e) ? (u = "âˆ£", p = "vert", m = 333) : Xe.contains(Lg, e) ? (u = "âˆ¥", p = "doublevert", m = 556) : e === "[" || e === "\\lbrack" ? (a = "âŽ¡", u = "âŽ¢", d = "âŽ£", c = "Size4-Regular", p = "lbrack", m = 667) : e === "]" || e === "\\rbrack" ? (a = "âŽ¤", u = "âŽ¥", d = "âŽ¦", c = "Size4-Regular", p = "rbrack", m = 667) : e === "\\lfloor" || e === "âŒŠ" ? (u = a = "âŽ¢", d = "âŽ£", c = "Size4-Regular", p = "lfloor", m = 667) : e === "\\lceil" || e === "âŒˆ" ? (a = "âŽ¡", u = d = "âŽ¢", c = "Size4-Regular", p = "lceil", m = 667) : e === "\\rfloor" || e === "âŒ‹" ? (u = a = "âŽ¥", d = "âŽ¦", c = "Size4-Regular", p = "rfloor", m = 667) : e === "\\rceil" || e === "âŒ‰" ? (a = "âŽ¤", u = d = "âŽ¥", c = "Size4-Regular", p = "rceil", m = 667) : e === "(" || e === "\\lparen" ? (a = "âŽ›", u = "âŽœ", d = "âŽ", c = "Size4-Regular", p = "lparen", m = 875) : e === ")" || e === "\\rparen" ? (a = "âŽž", u = "âŽŸ", d = "âŽ ", c = "Size4-Regular", p = "rparen", m = 875) : e === "\\{" || e === "\\lbrace" ? (a = "âŽ§", l = "âŽ¨", d = "âŽ©", u = "âŽª", c = "Size4-Regular") : e === "\\}" || e === "\\rbrace" ? (a = "âŽ«", l = "âŽ¬", d = "âŽ­", u = "âŽª", c = "Size4-Regular") : e === "\\lgroup" || e === "âŸ®" ? (a = "âŽ§", d = "âŽ©", u = "âŽª", c = "Size4-Regular") : e === "\\rgroup" || e === "âŸ¯" ? (a = "âŽ«", d = "âŽ­", u = "âŽª", c = "Size4-Regular") : e === "\\lmoustache" || e === "âŽ°" ? (a = "âŽ§", d = "âŽ­", u = "âŽª", c = "Size4-Regular") : (e === "\\rmoustache" || e === "âŽ±") && (a = "âŽ«", d = "âŽ©", u = "âŽª", c = "Size4-Regular");
  var h = Ni(a, c, o), f = h.height + h.depth, N = Ni(u, c, o), v = N.height + N.depth, C = Ni(d, c, o), g = C.height + C.depth, x = 0, b = 1;
  if (l !== null) {
    var A = Ni(l, c, o);
    x = A.height + A.depth, b = 2;
  }
  var w = f + g + x, M = Math.max(0, Math.ceil((t - w) / (b * v))), y = w + M * b * v, E = i.fontMetrics().axisHeight;
  n && (E *= i.sizeMultiplier);
  var S = y / 2 - E, P = [];
  if (p.length > 0) {
    var U = y - f - g, j = Math.round(y * 1e3), H = Pm(p, Math.round(U * 1e3)), R = new dn(p, H), T = (m / 1e3).toFixed(3) + "em", $ = (j / 1e3).toFixed(3) + "em", G = new Vr([R], {
      width: T,
      height: $,
      viewBox: "0 0 " + m + " " + j
    }), q = ge.makeSvgSpan([], [G], i);
    q.height = j / 1e3, q.style.width = T, q.style.height = $, P.push({
      type: "elem",
      elem: q
    });
  } else {
    if (P.push(ea(d, c, o)), P.push(Qi), l === null) {
      var I = y - f - g + 2 * ts;
      P.push(ta(u, I, i));
    } else {
      var Y = (y - f - g - x) / 2 + 2 * ts;
      P.push(ta(u, Y, i)), P.push(Qi), P.push(ea(l, c, o)), P.push(Qi), P.push(ta(u, Y, i));
    }
    P.push(Qi), P.push(ea(a, c, o));
  }
  var D = i.havingBaseStyle(et.TEXT), z = ge.makeVList({
    positionType: "bottom",
    positionData: S,
    children: P
  }, D);
  return Ds(ge.makeSpan(["delimsizing", "mult"], [z], D), et.TEXT, i, s);
}, ra = 80, na = 0.08, ia = function(e, t, n, i, o) {
  var s = $m(e, i, n), a = new dn(e, s), l = new Vr([a], {
    // Note: 1000:1 ratio of viewBox to document em width.
    width: "400em",
    height: $e(t),
    viewBox: "0 0 400000 " + n,
    preserveAspectRatio: "xMinYMin slice"
  });
  return ge.makeSvgSpan(["hide-tail"], [l], o);
}, kg = function(e, t) {
  var n = t.havingBaseSizing(), i = Sd("\\surd", e * n.sizeMultiplier, Ed, n), o = n.sizeMultiplier, s = Math.max(0, t.minRuleThickness - t.fontMetrics().sqrtRuleThickness), a, l = 0, u = 0, d = 0, p;
  return i.type === "small" ? (d = 1e3 + 1e3 * s + ra, e < 1 ? o = 1 : e < 1.4 && (o = 0.7), l = (1 + s + na) / o, u = (1 + s) / o, a = ia("sqrtMain", l, d, s, t), a.style.minWidth = "0.853em", p = 0.833 / o) : i.type === "large" ? (d = (1e3 + ra) * yi[i.size], u = (yi[i.size] + s) / o, l = (yi[i.size] + s + na) / o, a = ia("sqrtSize" + i.size, l, d, s, t), a.style.minWidth = "1.02em", p = 1 / o) : (l = e + s + na, u = e + s, d = Math.floor(1e3 * e + s) + ra, a = ia("sqrtTall", l, d, s, t), a.style.minWidth = "0.742em", p = 1.056), a.height = u, a.style.height = $e(l), {
    span: a,
    advanceWidth: p,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (t.fontMetrics().sqrtRuleThickness + s) * o
  };
}, wd = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "âŒŠ", "âŒ‹", "\\lceil", "\\rceil", "âŒˆ", "âŒ‰", "\\surd"], Dg = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "âŸ®", "âŸ¯", "\\lmoustache", "\\rmoustache", "âŽ°", "âŽ±"], Td = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], yi = [0, 1.2, 1.8, 2.4, 3], $g = function(e, t, n, i, o) {
  if (e === "<" || e === "\\lt" || e === "âŸ¨" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "âŸ©") && (e = "\\rangle"), Xe.contains(wd, e) || Xe.contains(Td, e))
    return bd(e, t, !1, n, i, o);
  if (Xe.contains(Dg, e))
    return yd(e, yi[t], !1, n, i, o);
  throw new Re("Illegal delimiter: '" + e + "'");
}, Ig = [{
  type: "small",
  style: et.SCRIPTSCRIPT
}, {
  type: "small",
  style: et.SCRIPT
}, {
  type: "small",
  style: et.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}], Pg = [{
  type: "small",
  style: et.SCRIPTSCRIPT
}, {
  type: "small",
  style: et.SCRIPT
}, {
  type: "small",
  style: et.TEXT
}, {
  type: "stack"
}], Ed = [{
  type: "small",
  style: et.SCRIPTSCRIPT
}, {
  type: "small",
  style: et.SCRIPT
}, {
  type: "small",
  style: et.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}], Fg = function(e) {
  if (e.type === "small")
    return "Main-Regular";
  if (e.type === "large")
    return "Size" + e.size + "-Regular";
  if (e.type === "stack")
    return "Size4-Regular";
  throw new Error("Add support for delim type '" + e.type + "' here.");
}, Sd = function(e, t, n, i) {
  for (var o = Math.min(2, 3 - i.style.size), s = o; s < n.length && n[s].type !== "stack"; s++) {
    var a = Ni(e, Fg(n[s]), "math"), l = a.height + a.depth;
    if (n[s].type === "small") {
      var u = i.havingBaseStyle(n[s].style);
      l *= u.sizeMultiplier;
    }
    if (l > t)
      return n[s];
  }
  return n[n.length - 1];
}, Od = function(e, t, n, i, o, s) {
  e === "<" || e === "\\lt" || e === "âŸ¨" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "âŸ©") && (e = "\\rangle");
  var a;
  Xe.contains(Td, e) ? a = Ig : Xe.contains(wd, e) ? a = Ed : a = Pg;
  var l = Sd(e, t, a, i);
  return l.type === "small" ? Mg(e, l.style, n, i, o, s) : l.type === "large" ? bd(e, l.size, n, i, o, s) : yd(e, t, n, i, o, s);
}, Bg = function(e, t, n, i, o, s) {
  var a = i.fontMetrics().axisHeight * i.sizeMultiplier, l = 901, u = 5 / i.fontMetrics().ptPerEm, d = Math.max(t - a, n + a), p = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    d / 500 * l,
    2 * d - u
  );
  return Od(e, p, !0, i, o, s);
}, Gr = {
  sqrtImage: kg,
  sizedDelim: $g,
  sizeToMaxHeight: yi,
  customSizedDelim: Od,
  leftRightDelim: Bg
}, B0 = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
}, zg = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "âŒŠ", "âŒ‹", "\\lceil", "\\rceil", "âŒˆ", "âŒ‰", "<", ">", "\\langle", "âŸ¨", "\\rangle", "âŸ©", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "âŸ®", "âŸ¯", "\\lmoustache", "\\rmoustache", "âŽ°", "âŽ±", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function Ro(r, e) {
  var t = Oo(r);
  if (t && Xe.contains(zg, t.text))
    return t;
  throw t ? new Re("Invalid delimiter '" + t.text + "' after '" + e.funcName + "'", r) : new Re("Invalid delimiter type '" + r.type + "'", r);
}
ze({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (r, e) => {
    var t = Ro(e[0], r);
    return {
      type: "delimsizing",
      mode: r.parser.mode,
      size: B0[r.funcName].size,
      mclass: B0[r.funcName].mclass,
      delim: t.text
    };
  },
  htmlBuilder: (r, e) => r.delim === "." ? ge.makeSpan([r.mclass]) : Gr.sizedDelim(r.delim, r.size, e, r.mode, [r.mclass]),
  mathmlBuilder: (r) => {
    var e = [];
    r.delim !== "." && e.push(yr(r.delim, r.mode));
    var t = new Me.MathNode("mo", e);
    r.mclass === "mopen" || r.mclass === "mclose" ? t.setAttribute("fence", "true") : t.setAttribute("fence", "false"), t.setAttribute("stretchy", "true");
    var n = $e(Gr.sizeToMaxHeight[r.size]);
    return t.setAttribute("minsize", n), t.setAttribute("maxsize", n), t;
  }
});
function z0(r) {
  if (!r.body)
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
}
ze({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (r, e) => {
    var t = r.parser.gullet.macros.get("\\current@color");
    if (t && typeof t != "string")
      throw new Re("\\current@color set to non-string in \\right");
    return {
      type: "leftright-right",
      mode: r.parser.mode,
      delim: Ro(e[0], r).text,
      color: t
      // undefined if not set via \color
    };
  }
});
ze({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (r, e) => {
    var t = Ro(e[0], r), n = r.parser;
    ++n.leftrightDepth;
    var i = n.parseExpression(!1);
    --n.leftrightDepth, n.expect("\\right", !1);
    var o = dt(n.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: n.mode,
      body: i,
      left: t.text,
      right: o.delim,
      rightColor: o.color
    };
  },
  htmlBuilder: (r, e) => {
    z0(r);
    for (var t = Qt(r.body, e, !0, ["mopen", "mclose"]), n = 0, i = 0, o = !1, s = 0; s < t.length; s++)
      t[s].isMiddle ? o = !0 : (n = Math.max(t[s].height, n), i = Math.max(t[s].depth, i));
    n *= e.sizeMultiplier, i *= e.sizeMultiplier;
    var a;
    if (r.left === "." ? a = Ei(e, ["mopen"]) : a = Gr.leftRightDelim(r.left, n, i, e, r.mode, ["mopen"]), t.unshift(a), o)
      for (var l = 1; l < t.length; l++) {
        var u = t[l], d = u.isMiddle;
        d && (t[l] = Gr.leftRightDelim(d.delim, n, i, d.options, r.mode, []));
      }
    var p;
    if (r.right === ".")
      p = Ei(e, ["mclose"]);
    else {
      var m = r.rightColor ? e.withColor(r.rightColor) : e;
      p = Gr.leftRightDelim(r.right, n, i, m, r.mode, ["mclose"]);
    }
    return t.push(p), ge.makeSpan(["minner"], t, e);
  },
  mathmlBuilder: (r, e) => {
    z0(r);
    var t = gr(r.body, e);
    if (r.left !== ".") {
      var n = new Me.MathNode("mo", [yr(r.left, r.mode)]);
      n.setAttribute("fence", "true"), t.unshift(n);
    }
    if (r.right !== ".") {
      var i = new Me.MathNode("mo", [yr(r.right, r.mode)]);
      i.setAttribute("fence", "true"), r.rightColor && i.setAttribute("mathcolor", r.rightColor), t.push(i);
    }
    return Rs(t);
  }
});
ze({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (r, e) => {
    var t = Ro(e[0], r);
    if (!r.parser.leftrightDepth)
      throw new Re("\\middle without preceding \\left", t);
    return {
      type: "middle",
      mode: r.parser.mode,
      delim: t.text
    };
  },
  htmlBuilder: (r, e) => {
    var t;
    if (r.delim === ".")
      t = Ei(e, []);
    else {
      t = Gr.sizedDelim(r.delim, 1, e, r.mode, []);
      var n = {
        delim: r.delim,
        options: e
      };
      t.isMiddle = n;
    }
    return t;
  },
  mathmlBuilder: (r, e) => {
    var t = r.delim === "\\vert" || r.delim === "|" ? yr("|", "text") : yr(r.delim, r.mode), n = new Me.MathNode("mo", [t]);
    return n.setAttribute("fence", "true"), n.setAttribute("lspace", "0.05em"), n.setAttribute("rspace", "0.05em"), n;
  }
});
var $s = (r, e) => {
  var t = ge.wrapFragment(yt(r.body, e), e), n = r.label.slice(1), i = e.sizeMultiplier, o, s = 0, a = Xe.isCharacterBox(r.body);
  if (n === "sout")
    o = ge.makeSpan(["stretchy", "sout"]), o.height = e.fontMetrics().defaultRuleThickness / i, s = -0.5 * e.fontMetrics().xHeight;
  else if (n === "phase") {
    var l = Ht({
      number: 0.6,
      unit: "pt"
    }, e), u = Ht({
      number: 0.35,
      unit: "ex"
    }, e), d = e.havingBaseSizing();
    i = i / d.sizeMultiplier;
    var p = t.height + t.depth + l + u;
    t.style.paddingLeft = $e(p / 2 + l);
    var m = Math.floor(1e3 * p * i), c = km(m), h = new Vr([new dn("phase", c)], {
      width: "400em",
      height: $e(m / 1e3),
      viewBox: "0 0 400000 " + m,
      preserveAspectRatio: "xMinYMin slice"
    });
    o = ge.makeSvgSpan(["hide-tail"], [h], e), o.style.height = $e(p), s = t.depth + l + u;
  } else {
    /cancel/.test(n) ? a || t.classes.push("cancel-pad") : n === "angl" ? t.classes.push("anglpad") : t.classes.push("boxpad");
    var f = 0, N = 0, v = 0;
    /box/.test(n) ? (v = Math.max(
      e.fontMetrics().fboxrule,
      // default
      e.minRuleThickness
      // User override.
    ), f = e.fontMetrics().fboxsep + (n === "colorbox" ? 0 : v), N = f) : n === "angl" ? (v = Math.max(e.fontMetrics().defaultRuleThickness, e.minRuleThickness), f = 4 * v, N = Math.max(0, 0.25 - t.depth)) : (f = a ? 0.2 : 0, N = f), o = Jr.encloseSpan(t, n, f, N, e), /fbox|boxed|fcolorbox/.test(n) ? (o.style.borderStyle = "solid", o.style.borderWidth = $e(v)) : n === "angl" && v !== 0.049 && (o.style.borderTopWidth = $e(v), o.style.borderRightWidth = $e(v)), s = t.depth + N, r.backgroundColor && (o.style.backgroundColor = r.backgroundColor, r.borderColor && (o.style.borderColor = r.borderColor));
  }
  var C;
  if (r.backgroundColor)
    C = ge.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: o,
          shift: s
        },
        {
          type: "elem",
          elem: t,
          shift: 0
        }
      ]
    }, e);
  else {
    var g = /cancel|phase/.test(n) ? ["svg-align"] : [];
    C = ge.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: t,
          shift: 0
        },
        {
          type: "elem",
          elem: o,
          shift: s,
          wrapperClasses: g
        }
      ]
    }, e);
  }
  return /cancel/.test(n) && (C.height = t.height, C.depth = t.depth), /cancel/.test(n) && !a ? ge.makeSpan(["mord", "cancel-lap"], [C], e) : ge.makeSpan(["mord"], [C], e);
}, Is = (r, e) => {
  var t = 0, n = new Me.MathNode(r.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [Mt(r.body, e)]);
  switch (r.label) {
    case "\\cancel":
      n.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      n.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      n.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      n.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      n.setAttribute("notation", "box");
      break;
    case "\\angl":
      n.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      if (t = e.fontMetrics().fboxsep * e.fontMetrics().ptPerEm, n.setAttribute("width", "+" + 2 * t + "pt"), n.setAttribute("height", "+" + 2 * t + "pt"), n.setAttribute("lspace", t + "pt"), n.setAttribute("voffset", t + "pt"), r.label === "\\fcolorbox") {
        var i = Math.max(
          e.fontMetrics().fboxrule,
          // default
          e.minRuleThickness
          // user override
        );
        n.setAttribute("style", "border: " + i + "em solid " + String(r.borderColor));
      }
      break;
    case "\\xcancel":
      n.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  return r.backgroundColor && n.setAttribute("mathbackground", r.backgroundColor), n;
};
ze({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "text"]
  },
  handler(r, e, t) {
    var {
      parser: n,
      funcName: i
    } = r, o = dt(e[0], "color-token").color, s = e[1];
    return {
      type: "enclose",
      mode: n.mode,
      label: i,
      backgroundColor: o,
      body: s
    };
  },
  htmlBuilder: $s,
  mathmlBuilder: Is
});
ze({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: !0,
    argTypes: ["color", "color", "text"]
  },
  handler(r, e, t) {
    var {
      parser: n,
      funcName: i
    } = r, o = dt(e[0], "color-token").color, s = dt(e[1], "color-token").color, a = e[2];
    return {
      type: "enclose",
      mode: n.mode,
      label: i,
      backgroundColor: s,
      borderColor: o,
      body: a
    };
  },
  htmlBuilder: $s,
  mathmlBuilder: Is
});
ze({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !0
  },
  handler(r, e) {
    var {
      parser: t
    } = r;
    return {
      type: "enclose",
      mode: t.mode,
      label: "\\fbox",
      body: e[0]
    };
  }
});
ze({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(r, e) {
    var {
      parser: t,
      funcName: n
    } = r, i = e[0];
    return {
      type: "enclose",
      mode: t.mode,
      label: n,
      body: i
    };
  },
  htmlBuilder: $s,
  mathmlBuilder: Is
});
ze({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !1
  },
  handler(r, e) {
    var {
      parser: t
    } = r;
    return {
      type: "enclose",
      mode: t.mode,
      label: "\\angl",
      body: e[0]
    };
  }
});
var Md = {};
function Pr(r) {
  for (var {
    type: e,
    names: t,
    props: n,
    handler: i,
    htmlBuilder: o,
    mathmlBuilder: s
  } = r, a = {
    type: e,
    numArgs: n.numArgs || 0,
    allowedInText: !1,
    numOptionalArgs: 0,
    handler: i
  }, l = 0; l < t.length; ++l)
    Md[t[l]] = a;
  o && (_o[e] = o), s && (Co[e] = s);
}
var Rd = {};
function J(r, e) {
  Rd[r] = e;
}
function H0(r) {
  var e = [];
  r.consumeSpaces();
  var t = r.fetch().text;
  for (t === "\\relax" && (r.consume(), r.consumeSpaces(), t = r.fetch().text); t === "\\hline" || t === "\\hdashline"; )
    r.consume(), e.push(t === "\\hdashline"), r.consumeSpaces(), t = r.fetch().text;
  return e;
}
var Ao = (r) => {
  var e = r.parser.settings;
  if (!e.displayMode)
    throw new Re("{" + r.envName + "} can be used only in display mode.");
};
function Ps(r) {
  if (r.indexOf("ed") === -1)
    return r.indexOf("*") === -1;
}
function gn(r, e, t) {
  var {
    hskipBeforeAndAfter: n,
    addJot: i,
    cols: o,
    arraystretch: s,
    colSeparationType: a,
    autoTag: l,
    singleRow: u,
    emptySingleRow: d,
    maxNumCols: p,
    leqno: m
  } = e;
  if (r.gullet.beginGroup(), u || r.gullet.macros.set("\\cr", "\\\\\\relax"), !s) {
    var c = r.gullet.expandMacroAsText("\\arraystretch");
    if (c == null)
      s = 1;
    else if (s = parseFloat(c), !s || s < 0)
      throw new Re("Invalid \\arraystretch: " + c);
  }
  r.gullet.beginGroup();
  var h = [], f = [h], N = [], v = [], C = l != null ? [] : void 0;
  function g() {
    l && r.gullet.macros.set("\\@eqnsw", "1", !0);
  }
  function x() {
    C && (r.gullet.macros.get("\\df@tag") ? (C.push(r.subparse([new Cr("\\df@tag")])), r.gullet.macros.set("\\df@tag", void 0, !0)) : C.push(!!l && r.gullet.macros.get("\\@eqnsw") === "1"));
  }
  for (g(), v.push(H0(r)); ; ) {
    var b = r.parseExpression(!1, u ? "\\end" : "\\\\");
    r.gullet.endGroup(), r.gullet.beginGroup(), b = {
      type: "ordgroup",
      mode: r.mode,
      body: b
    }, t && (b = {
      type: "styling",
      mode: r.mode,
      style: t,
      body: [b]
    }), h.push(b);
    var A = r.fetch().text;
    if (A === "&") {
      if (p && h.length === p) {
        if (u || a)
          throw new Re("Too many tab characters: &", r.nextToken);
        r.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
      }
      r.consume();
    } else if (A === "\\end") {
      x(), h.length === 1 && b.type === "styling" && b.body[0].body.length === 0 && (f.length > 1 || !d) && f.pop(), v.length < f.length + 1 && v.push([]);
      break;
    } else if (A === "\\\\") {
      r.consume();
      var w = void 0;
      r.gullet.future().text !== " " && (w = r.parseSizeGroup(!0)), N.push(w ? w.value : null), x(), v.push(H0(r)), h = [], f.push(h), g();
    } else
      throw new Re("Expected & or \\\\ or \\cr or \\end", r.nextToken);
  }
  return r.gullet.endGroup(), r.gullet.endGroup(), {
    type: "array",
    mode: r.mode,
    addJot: i,
    arraystretch: s,
    body: f,
    cols: o,
    rowGaps: N,
    hskipBeforeAndAfter: n,
    hLinesBeforeRow: v,
    colSeparationType: a,
    tags: C,
    leqno: m
  };
}
function Fs(r) {
  return r.slice(0, 1) === "d" ? "display" : "text";
}
var Fr = function(e, t) {
  var n, i, o = e.body.length, s = e.hLinesBeforeRow, a = 0, l = new Array(o), u = [], d = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    t.fontMetrics().arrayRuleWidth,
    t.minRuleThickness
    // User override.
  ), p = 1 / t.fontMetrics().ptPerEm, m = 5 * p;
  if (e.colSeparationType && e.colSeparationType === "small") {
    var c = t.havingStyle(et.SCRIPT).sizeMultiplier;
    m = 0.2778 * (c / t.sizeMultiplier);
  }
  var h = e.colSeparationType === "CD" ? Ht({
    number: 3,
    unit: "ex"
  }, t) : 12 * p, f = 3 * p, N = e.arraystretch * h, v = 0.7 * N, C = 0.3 * N, g = 0;
  function x(ee) {
    for (var ue = 0; ue < ee.length; ++ue)
      ue > 0 && (g += 0.25), u.push({
        pos: g,
        isDashed: ee[ue]
      });
  }
  for (x(s[0]), n = 0; n < e.body.length; ++n) {
    var b = e.body[n], A = v, w = C;
    a < b.length && (a = b.length);
    var M = new Array(b.length);
    for (i = 0; i < b.length; ++i) {
      var y = yt(b[i], t);
      w < y.depth && (w = y.depth), A < y.height && (A = y.height), M[i] = y;
    }
    var E = e.rowGaps[n], S = 0;
    E && (S = Ht(E, t), S > 0 && (S += C, w < S && (w = S), S = 0)), e.addJot && (w += f), M.height = A, M.depth = w, g += A, M.pos = g, g += w + S, l[n] = M, x(s[n + 1]);
  }
  var P = g / 2 + t.fontMetrics().axisHeight, U = e.cols || [], j = [], H, R, T = [];
  if (e.tags && e.tags.some((ee) => ee))
    for (n = 0; n < o; ++n) {
      var $ = l[n], G = $.pos - P, q = e.tags[n], I = void 0;
      q === !0 ? I = ge.makeSpan(["eqn-num"], [], t) : q === !1 ? I = ge.makeSpan([], [], t) : I = ge.makeSpan([], Qt(q, t, !0), t), I.depth = $.depth, I.height = $.height, T.push({
        type: "elem",
        elem: I,
        shift: G
      });
    }
  for (
    i = 0, R = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    i < a || R < U.length;
    ++i, ++R
  ) {
    for (var Y = U[R] || {}, D = !0; Y.type === "separator"; ) {
      if (D || (H = ge.makeSpan(["arraycolsep"], []), H.style.width = $e(t.fontMetrics().doubleRuleSep), j.push(H)), Y.separator === "|" || Y.separator === ":") {
        var z = Y.separator === "|" ? "solid" : "dashed", X = ge.makeSpan(["vertical-separator"], [], t);
        X.style.height = $e(g), X.style.borderRightWidth = $e(d), X.style.borderRightStyle = z, X.style.margin = "0 " + $e(-d / 2);
        var Q = g - P;
        Q && (X.style.verticalAlign = $e(-Q)), j.push(X);
      } else
        throw new Re("Invalid separator type: " + Y.separator);
      R++, Y = U[R] || {}, D = !1;
    }
    if (!(i >= a)) {
      var ne = void 0;
      (i > 0 || e.hskipBeforeAndAfter) && (ne = Xe.deflt(Y.pregap, m), ne !== 0 && (H = ge.makeSpan(["arraycolsep"], []), H.style.width = $e(ne), j.push(H)));
      var fe = [];
      for (n = 0; n < o; ++n) {
        var _e = l[n], pe = _e[i];
        if (pe) {
          var Ne = _e.pos - P;
          pe.depth = _e.depth, pe.height = _e.height, fe.push({
            type: "elem",
            elem: pe,
            shift: Ne
          });
        }
      }
      fe = ge.makeVList({
        positionType: "individualShift",
        children: fe
      }, t), fe = ge.makeSpan(["col-align-" + (Y.align || "c")], [fe]), j.push(fe), (i < a - 1 || e.hskipBeforeAndAfter) && (ne = Xe.deflt(Y.postgap, m), ne !== 0 && (H = ge.makeSpan(["arraycolsep"], []), H.style.width = $e(ne), j.push(H)));
    }
  }
  if (l = ge.makeSpan(["mtable"], j), u.length > 0) {
    for (var B = ge.makeLineSpan("hline", t, d), F = ge.makeLineSpan("hdashline", t, d), k = [{
      type: "elem",
      elem: l,
      shift: 0
    }]; u.length > 0; ) {
      var W = u.pop(), V = W.pos - P;
      W.isDashed ? k.push({
        type: "elem",
        elem: F,
        shift: V
      }) : k.push({
        type: "elem",
        elem: B,
        shift: V
      });
    }
    l = ge.makeVList({
      positionType: "individualShift",
      children: k
    }, t);
  }
  if (T.length === 0)
    return ge.makeSpan(["mord"], [l], t);
  var te = ge.makeVList({
    positionType: "individualShift",
    children: T
  }, t);
  return te = ge.makeSpan(["tag"], [te], t), ge.makeFragment([l, te]);
}, Hg = {
  c: "center ",
  l: "left ",
  r: "right "
}, Br = function(e, t) {
  for (var n = [], i = new Me.MathNode("mtd", [], ["mtr-glue"]), o = new Me.MathNode("mtd", [], ["mml-eqn-num"]), s = 0; s < e.body.length; s++) {
    for (var a = e.body[s], l = [], u = 0; u < a.length; u++)
      l.push(new Me.MathNode("mtd", [Mt(a[u], t)]));
    e.tags && e.tags[s] && (l.unshift(i), l.push(i), e.leqno ? l.unshift(o) : l.push(o)), n.push(new Me.MathNode("mtr", l));
  }
  var d = new Me.MathNode("mtable", n), p = e.arraystretch === 0.5 ? 0.1 : 0.16 + e.arraystretch - 1 + (e.addJot ? 0.09 : 0);
  d.setAttribute("rowspacing", $e(p));
  var m = "", c = "";
  if (e.cols && e.cols.length > 0) {
    var h = e.cols, f = "", N = !1, v = 0, C = h.length;
    h[0].type === "separator" && (m += "top ", v = 1), h[h.length - 1].type === "separator" && (m += "bottom ", C -= 1);
    for (var g = v; g < C; g++)
      h[g].type === "align" ? (c += Hg[h[g].align], N && (f += "none "), N = !0) : h[g].type === "separator" && N && (f += h[g].separator === "|" ? "solid " : "dashed ", N = !1);
    d.setAttribute("columnalign", c.trim()), /[sd]/.test(f) && d.setAttribute("columnlines", f.trim());
  }
  if (e.colSeparationType === "align") {
    for (var x = e.cols || [], b = "", A = 1; A < x.length; A++)
      b += A % 2 ? "0em " : "1em ";
    d.setAttribute("columnspacing", b.trim());
  } else e.colSeparationType === "alignat" || e.colSeparationType === "gather" ? d.setAttribute("columnspacing", "0em") : e.colSeparationType === "small" ? d.setAttribute("columnspacing", "0.2778em") : e.colSeparationType === "CD" ? d.setAttribute("columnspacing", "0.5em") : d.setAttribute("columnspacing", "1em");
  var w = "", M = e.hLinesBeforeRow;
  m += M[0].length > 0 ? "left " : "", m += M[M.length - 1].length > 0 ? "right " : "";
  for (var y = 1; y < M.length - 1; y++)
    w += M[y].length === 0 ? "none " : M[y][0] ? "dashed " : "solid ";
  return /[sd]/.test(w) && d.setAttribute("rowlines", w.trim()), m !== "" && (d = new Me.MathNode("menclose", [d]), d.setAttribute("notation", m.trim())), e.arraystretch && e.arraystretch < 1 && (d = new Me.MathNode("mstyle", [d]), d.setAttribute("scriptlevel", "1")), d;
}, Ad = function(e, t) {
  e.envName.indexOf("ed") === -1 && Ao(e);
  var n = [], i = e.envName.indexOf("at") > -1 ? "alignat" : "align", o = e.envName === "split", s = gn(e.parser, {
    cols: n,
    addJot: !0,
    autoTag: o ? void 0 : Ps(e.envName),
    emptySingleRow: !0,
    colSeparationType: i,
    maxNumCols: o ? 2 : void 0,
    leqno: e.parser.settings.leqno
  }, "display"), a, l = 0, u = {
    type: "ordgroup",
    mode: e.mode,
    body: []
  };
  if (t[0] && t[0].type === "ordgroup") {
    for (var d = "", p = 0; p < t[0].body.length; p++) {
      var m = dt(t[0].body[p], "textord");
      d += m.text;
    }
    a = Number(d), l = a * 2;
  }
  var c = !l;
  s.body.forEach(function(v) {
    for (var C = 1; C < v.length; C += 2) {
      var g = dt(v[C], "styling"), x = dt(g.body[0], "ordgroup");
      x.body.unshift(u);
    }
    if (c)
      l < v.length && (l = v.length);
    else {
      var b = v.length / 2;
      if (a < b)
        throw new Re("Too many math in a row: " + ("expected " + a + ", but got " + b), v[0]);
    }
  });
  for (var h = 0; h < l; ++h) {
    var f = "r", N = 0;
    h % 2 === 1 ? f = "l" : h > 0 && c && (N = 1), n[h] = {
      type: "align",
      align: f,
      pregap: N,
      postgap: 0
    };
  }
  return s.colSeparationType = c ? "align" : "alignat", s;
};
Pr({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(r, e) {
    var t = Oo(e[0]), n = t ? [e[0]] : dt(e[0], "ordgroup").body, i = n.map(function(s) {
      var a = Ls(s), l = a.text;
      if ("lcr".indexOf(l) !== -1)
        return {
          type: "align",
          align: l
        };
      if (l === "|")
        return {
          type: "separator",
          separator: "|"
        };
      if (l === ":")
        return {
          type: "separator",
          separator: ":"
        };
      throw new Re("Unknown column alignment: " + l, s);
    }), o = {
      cols: i,
      hskipBeforeAndAfter: !0,
      // \@preamble in lttab.dtx
      maxNumCols: i.length
    };
    return gn(r.parser, o, Fs(r.envName));
  },
  htmlBuilder: Fr,
  mathmlBuilder: Br
});
Pr({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(r) {
    var e = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[r.envName.replace("*", "")], t = "c", n = {
      hskipBeforeAndAfter: !1,
      cols: [{
        type: "align",
        align: t
      }]
    };
    if (r.envName.charAt(r.envName.length - 1) === "*") {
      var i = r.parser;
      if (i.consumeSpaces(), i.fetch().text === "[") {
        if (i.consume(), i.consumeSpaces(), t = i.fetch().text, "lcr".indexOf(t) === -1)
          throw new Re("Expected l or c or r", i.nextToken);
        i.consume(), i.consumeSpaces(), i.expect("]"), i.consume(), n.cols = [{
          type: "align",
          align: t
        }];
      }
    }
    var o = gn(r.parser, n, Fs(r.envName)), s = Math.max(0, ...o.body.map((a) => a.length));
    return o.cols = new Array(s).fill({
      type: "align",
      align: t
    }), e ? {
      type: "leftright",
      mode: r.mode,
      body: [o],
      left: e[0],
      right: e[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : o;
  },
  htmlBuilder: Fr,
  mathmlBuilder: Br
});
Pr({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(r) {
    var e = {
      arraystretch: 0.5
    }, t = gn(r.parser, e, "script");
    return t.colSeparationType = "small", t;
  },
  htmlBuilder: Fr,
  mathmlBuilder: Br
});
Pr({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(r, e) {
    var t = Oo(e[0]), n = t ? [e[0]] : dt(e[0], "ordgroup").body, i = n.map(function(s) {
      var a = Ls(s), l = a.text;
      if ("lc".indexOf(l) !== -1)
        return {
          type: "align",
          align: l
        };
      throw new Re("Unknown column alignment: " + l, s);
    });
    if (i.length > 1)
      throw new Re("{subarray} can contain only one column");
    var o = {
      cols: i,
      hskipBeforeAndAfter: !1,
      arraystretch: 0.5
    };
    if (o = gn(r.parser, o, "script"), o.body.length > 0 && o.body[0].length > 1)
      throw new Re("{subarray} can contain only one column");
    return o;
  },
  htmlBuilder: Fr,
  mathmlBuilder: Br
});
Pr({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(r) {
    var e = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    }, t = gn(r.parser, e, Fs(r.envName));
    return {
      type: "leftright",
      mode: r.mode,
      body: [t],
      left: r.envName.indexOf("r") > -1 ? "." : "\\{",
      right: r.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: Fr,
  mathmlBuilder: Br
});
Pr({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: Ad,
  htmlBuilder: Fr,
  mathmlBuilder: Br
});
Pr({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(r) {
    Xe.contains(["gather", "gather*"], r.envName) && Ao(r);
    var e = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: !0,
      colSeparationType: "gather",
      autoTag: Ps(r.envName),
      emptySingleRow: !0,
      leqno: r.parser.settings.leqno
    };
    return gn(r.parser, e, "display");
  },
  htmlBuilder: Fr,
  mathmlBuilder: Br
});
Pr({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: Ad,
  htmlBuilder: Fr,
  mathmlBuilder: Br
});
Pr({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(r) {
    Ao(r);
    var e = {
      autoTag: Ps(r.envName),
      emptySingleRow: !0,
      singleRow: !0,
      maxNumCols: 1,
      leqno: r.parser.settings.leqno
    };
    return gn(r.parser, e, "display");
  },
  htmlBuilder: Fr,
  mathmlBuilder: Br
});
Pr({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(r) {
    return Ao(r), Sg(r.parser);
  },
  htmlBuilder: Fr,
  mathmlBuilder: Br
});
J("\\nonumber", "\\gdef\\@eqnsw{0}");
J("\\notag", "\\nonumber");
ze({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !0
  },
  handler(r, e) {
    throw new Re(r.funcName + " valid only within array environment");
  }
});
var j0 = Md;
ze({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(r, e) {
    var {
      parser: t,
      funcName: n
    } = r, i = e[0];
    if (i.type !== "ordgroup")
      throw new Re("Invalid environment name", i);
    for (var o = "", s = 0; s < i.body.length; ++s)
      o += dt(i.body[s], "textord").text;
    if (n === "\\begin") {
      if (!j0.hasOwnProperty(o))
        throw new Re("No such environment: " + o, i);
      var a = j0[o], {
        args: l,
        optArgs: u
      } = t.parseArguments("\\begin{" + o + "}", a), d = {
        mode: t.mode,
        envName: o,
        parser: t
      }, p = a.handler(d, l, u);
      t.expect("\\end", !1);
      var m = t.nextToken, c = dt(t.parseFunction(), "environment");
      if (c.name !== o)
        throw new Re("Mismatch: \\begin{" + o + "} matched by \\end{" + c.name + "}", m);
      return p;
    }
    return {
      type: "environment",
      mode: t.mode,
      name: o,
      nameGroup: i
    };
  }
});
var Ld = (r, e) => {
  var t = r.font, n = e.withFont(t);
  return yt(r.body, n);
}, kd = (r, e) => {
  var t = r.font, n = e.withFont(t);
  return Mt(r.body, n);
}, q0 = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
ze({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: !0
  },
  handler: (r, e) => {
    var {
      parser: t,
      funcName: n
    } = r, i = bo(e[0]), o = n;
    return o in q0 && (o = q0[o]), {
      type: "font",
      mode: t.mode,
      font: o.slice(1),
      body: i
    };
  },
  htmlBuilder: Ld,
  mathmlBuilder: kd
});
ze({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (r, e) => {
    var {
      parser: t
    } = r, n = e[0], i = Xe.isCharacterBox(n);
    return {
      type: "mclass",
      mode: t.mode,
      mclass: Mo(n),
      body: [{
        type: "font",
        mode: t.mode,
        font: "boldsymbol",
        body: n
      }],
      isCharacterBox: i
    };
  }
});
ze({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (r, e) => {
    var {
      parser: t,
      funcName: n,
      breakOnTokenText: i
    } = r, {
      mode: o
    } = t, s = t.parseExpression(!0, i), a = "math" + n.slice(1);
    return {
      type: "font",
      mode: o,
      font: a,
      body: {
        type: "ordgroup",
        mode: t.mode,
        body: s
      }
    };
  },
  htmlBuilder: Ld,
  mathmlBuilder: kd
});
var Dd = (r, e) => {
  var t = e;
  return r === "display" ? t = t.id >= et.SCRIPT.id ? t.text() : et.DISPLAY : r === "text" && t.size === et.DISPLAY.size ? t = et.TEXT : r === "script" ? t = et.SCRIPT : r === "scriptscript" && (t = et.SCRIPTSCRIPT), t;
}, Bs = (r, e) => {
  var t = Dd(r.size, e.style), n = t.fracNum(), i = t.fracDen(), o;
  o = e.havingStyle(n);
  var s = yt(r.numer, o, e);
  if (r.continued) {
    var a = 8.5 / e.fontMetrics().ptPerEm, l = 3.5 / e.fontMetrics().ptPerEm;
    s.height = s.height < a ? a : s.height, s.depth = s.depth < l ? l : s.depth;
  }
  o = e.havingStyle(i);
  var u = yt(r.denom, o, e), d, p, m;
  r.hasBarLine ? (r.barSize ? (p = Ht(r.barSize, e), d = ge.makeLineSpan("frac-line", e, p)) : d = ge.makeLineSpan("frac-line", e), p = d.height, m = d.height) : (d = null, p = 0, m = e.fontMetrics().defaultRuleThickness);
  var c, h, f;
  t.size === et.DISPLAY.size || r.size === "display" ? (c = e.fontMetrics().num1, p > 0 ? h = 3 * m : h = 7 * m, f = e.fontMetrics().denom1) : (p > 0 ? (c = e.fontMetrics().num2, h = m) : (c = e.fontMetrics().num3, h = 3 * m), f = e.fontMetrics().denom2);
  var N;
  if (d) {
    var C = e.fontMetrics().axisHeight;
    c - s.depth - (C + 0.5 * p) < h && (c += h - (c - s.depth - (C + 0.5 * p))), C - 0.5 * p - (u.height - f) < h && (f += h - (C - 0.5 * p - (u.height - f)));
    var g = -(C - 0.5 * p);
    N = ge.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: u,
        shift: f
      }, {
        type: "elem",
        elem: d,
        shift: g
      }, {
        type: "elem",
        elem: s,
        shift: -c
      }]
    }, e);
  } else {
    var v = c - s.depth - (u.height - f);
    v < h && (c += 0.5 * (h - v), f += 0.5 * (h - v)), N = ge.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: u,
        shift: f
      }, {
        type: "elem",
        elem: s,
        shift: -c
      }]
    }, e);
  }
  o = e.havingStyle(t), N.height *= o.sizeMultiplier / e.sizeMultiplier, N.depth *= o.sizeMultiplier / e.sizeMultiplier;
  var x;
  t.size === et.DISPLAY.size ? x = e.fontMetrics().delim1 : t.size === et.SCRIPTSCRIPT.size ? x = e.havingStyle(et.SCRIPT).fontMetrics().delim2 : x = e.fontMetrics().delim2;
  var b, A;
  return r.leftDelim == null ? b = Ei(e, ["mopen"]) : b = Gr.customSizedDelim(r.leftDelim, x, !0, e.havingStyle(t), r.mode, ["mopen"]), r.continued ? A = ge.makeSpan([]) : r.rightDelim == null ? A = Ei(e, ["mclose"]) : A = Gr.customSizedDelim(r.rightDelim, x, !0, e.havingStyle(t), r.mode, ["mclose"]), ge.makeSpan(["mord"].concat(o.sizingClasses(e)), [b, ge.makeSpan(["mfrac"], [N]), A], e);
}, zs = (r, e) => {
  var t = new Me.MathNode("mfrac", [Mt(r.numer, e), Mt(r.denom, e)]);
  if (!r.hasBarLine)
    t.setAttribute("linethickness", "0px");
  else if (r.barSize) {
    var n = Ht(r.barSize, e);
    t.setAttribute("linethickness", $e(n));
  }
  var i = Dd(r.size, e.style);
  if (i.size !== e.style.size) {
    t = new Me.MathNode("mstyle", [t]);
    var o = i.size === et.DISPLAY.size ? "true" : "false";
    t.setAttribute("displaystyle", o), t.setAttribute("scriptlevel", "0");
  }
  if (r.leftDelim != null || r.rightDelim != null) {
    var s = [];
    if (r.leftDelim != null) {
      var a = new Me.MathNode("mo", [new Me.TextNode(r.leftDelim.replace("\\", ""))]);
      a.setAttribute("fence", "true"), s.push(a);
    }
    if (s.push(t), r.rightDelim != null) {
      var l = new Me.MathNode("mo", [new Me.TextNode(r.rightDelim.replace("\\", ""))]);
      l.setAttribute("fence", "true"), s.push(l);
    }
    return Rs(s);
  }
  return t;
};
ze({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // canâ€™t be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: !0
  },
  handler: (r, e) => {
    var {
      parser: t,
      funcName: n
    } = r, i = e[0], o = e[1], s, a = null, l = null, u = "auto";
    switch (n) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        s = !0;
        break;
      case "\\\\atopfrac":
        s = !1;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        s = !1, a = "(", l = ")";
        break;
      case "\\\\bracefrac":
        s = !1, a = "\\{", l = "\\}";
        break;
      case "\\\\brackfrac":
        s = !1, a = "[", l = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (n) {
      case "\\dfrac":
      case "\\dbinom":
        u = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        u = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: t.mode,
      continued: !1,
      numer: i,
      denom: o,
      hasBarLine: s,
      leftDelim: a,
      rightDelim: l,
      size: u,
      barSize: null
    };
  },
  htmlBuilder: Bs,
  mathmlBuilder: zs
});
ze({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (r, e) => {
    var {
      parser: t,
      funcName: n
    } = r, i = e[0], o = e[1];
    return {
      type: "genfrac",
      mode: t.mode,
      continued: !0,
      numer: i,
      denom: o,
      hasBarLine: !0,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
ze({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: !0
  },
  handler(r) {
    var {
      parser: e,
      funcName: t,
      token: n
    } = r, i;
    switch (t) {
      case "\\over":
        i = "\\frac";
        break;
      case "\\choose":
        i = "\\binom";
        break;
      case "\\atop":
        i = "\\\\atopfrac";
        break;
      case "\\brace":
        i = "\\\\bracefrac";
        break;
      case "\\brack":
        i = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: e.mode,
      replaceWith: i,
      token: n
    };
  }
});
var K0 = ["display", "text", "script", "scriptscript"], U0 = function(e) {
  var t = null;
  return e.length > 0 && (t = e, t = t === "." ? null : t), t;
};
ze({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: !0,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(r, e) {
    var {
      parser: t
    } = r, n = e[4], i = e[5], o = bo(e[0]), s = o.type === "atom" && o.family === "open" ? U0(o.text) : null, a = bo(e[1]), l = a.type === "atom" && a.family === "close" ? U0(a.text) : null, u = dt(e[2], "size"), d, p = null;
    u.isBlank ? d = !0 : (p = u.value, d = p.number > 0);
    var m = "auto", c = e[3];
    if (c.type === "ordgroup") {
      if (c.body.length > 0) {
        var h = dt(c.body[0], "textord");
        m = K0[Number(h.text)];
      }
    } else
      c = dt(c, "textord"), m = K0[Number(c.text)];
    return {
      type: "genfrac",
      mode: t.mode,
      numer: n,
      denom: i,
      continued: !1,
      hasBarLine: d,
      barSize: p,
      leftDelim: s,
      rightDelim: l,
      size: m
    };
  },
  htmlBuilder: Bs,
  mathmlBuilder: zs
});
ze({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: !0
  },
  handler(r, e) {
    var {
      parser: t,
      funcName: n,
      token: i
    } = r;
    return {
      type: "infix",
      mode: t.mode,
      replaceWith: "\\\\abovefrac",
      size: dt(e[0], "size").value,
      token: i
    };
  }
});
ze({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (r, e) => {
    var {
      parser: t,
      funcName: n
    } = r, i = e[0], o = xm(dt(e[1], "infix").size), s = e[2], a = o.number > 0;
    return {
      type: "genfrac",
      mode: t.mode,
      numer: i,
      denom: s,
      continued: !1,
      hasBarLine: a,
      barSize: o,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: Bs,
  mathmlBuilder: zs
});
var $d = (r, e) => {
  var t = e.style, n, i;
  r.type === "supsub" ? (n = r.sup ? yt(r.sup, e.havingStyle(t.sup()), e) : yt(r.sub, e.havingStyle(t.sub()), e), i = dt(r.base, "horizBrace")) : i = dt(r, "horizBrace");
  var o = yt(i.base, e.havingBaseStyle(et.DISPLAY)), s = Jr.svgSpan(i, e), a;
  if (i.isOver ? (a = ge.makeVList({
    positionType: "firstBaseline",
    children: [{
      type: "elem",
      elem: o
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: s
    }]
  }, e), a.children[0].children[0].children[1].classes.push("svg-align")) : (a = ge.makeVList({
    positionType: "bottom",
    positionData: o.depth + 0.1 + s.height,
    children: [{
      type: "elem",
      elem: s
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: o
    }]
  }, e), a.children[0].children[0].children[0].classes.push("svg-align")), n) {
    var l = ge.makeSpan(["mord", i.isOver ? "mover" : "munder"], [a], e);
    i.isOver ? a = ge.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: l
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: n
      }]
    }, e) : a = ge.makeVList({
      positionType: "bottom",
      positionData: l.depth + 0.2 + n.height + n.depth,
      children: [{
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: l
      }]
    }, e);
  }
  return ge.makeSpan(["mord", i.isOver ? "mover" : "munder"], [a], e);
}, jg = (r, e) => {
  var t = Jr.mathMLnode(r.label);
  return new Me.MathNode(r.isOver ? "mover" : "munder", [Mt(r.base, e), t]);
};
ze({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(r, e) {
    var {
      parser: t,
      funcName: n
    } = r;
    return {
      type: "horizBrace",
      mode: t.mode,
      label: n,
      isOver: /^\\over/.test(n),
      base: e[0]
    };
  },
  htmlBuilder: $d,
  mathmlBuilder: jg
});
ze({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: !0
  },
  handler: (r, e) => {
    var {
      parser: t
    } = r, n = e[1], i = dt(e[0], "url").url;
    return t.settings.isTrusted({
      command: "\\href",
      url: i
    }) ? {
      type: "href",
      mode: t.mode,
      href: i,
      body: Yt(n)
    } : t.formatUnsupportedCmd("\\href");
  },
  htmlBuilder: (r, e) => {
    var t = Qt(r.body, e, !1);
    return ge.makeAnchor(r.href, [], t, e);
  },
  mathmlBuilder: (r, e) => {
    var t = hn(r.body, e);
    return t instanceof Nr || (t = new Nr("mrow", [t])), t.setAttribute("href", r.href), t;
  }
});
ze({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: !0
  },
  handler: (r, e) => {
    var {
      parser: t
    } = r, n = dt(e[0], "url").url;
    if (!t.settings.isTrusted({
      command: "\\url",
      url: n
    }))
      return t.formatUnsupportedCmd("\\url");
    for (var i = [], o = 0; o < n.length; o++) {
      var s = n[o];
      s === "~" && (s = "\\textasciitilde"), i.push({
        type: "textord",
        mode: "text",
        text: s
      });
    }
    var a = {
      type: "text",
      mode: t.mode,
      font: "\\texttt",
      body: i
    };
    return {
      type: "href",
      mode: t.mode,
      href: n,
      body: Yt(a)
    };
  }
});
ze({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: !0,
    primitive: !0
  },
  handler(r, e) {
    var {
      parser: t
    } = r;
    return {
      type: "hbox",
      mode: t.mode,
      body: Yt(e[0])
    };
  },
  htmlBuilder(r, e) {
    var t = Qt(r.body, e, !1);
    return ge.makeFragment(t);
  },
  mathmlBuilder(r, e) {
    return new Me.MathNode("mrow", gr(r.body, e));
  }
});
ze({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: !0
  },
  handler: (r, e) => {
    var {
      parser: t,
      funcName: n,
      token: i
    } = r, o = dt(e[0], "raw").string, s = e[1];
    t.settings.strict && t.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    var a, l = {};
    switch (n) {
      case "\\htmlClass":
        l.class = o, a = {
          command: "\\htmlClass",
          class: o
        };
        break;
      case "\\htmlId":
        l.id = o, a = {
          command: "\\htmlId",
          id: o
        };
        break;
      case "\\htmlStyle":
        l.style = o, a = {
          command: "\\htmlStyle",
          style: o
        };
        break;
      case "\\htmlData": {
        for (var u = o.split(","), d = 0; d < u.length; d++) {
          var p = u[d].split("=");
          if (p.length !== 2)
            throw new Re("Error parsing key-value for \\htmlData");
          l["data-" + p[0].trim()] = p[1].trim();
        }
        a = {
          command: "\\htmlData",
          attributes: l
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    return t.settings.isTrusted(a) ? {
      type: "html",
      mode: t.mode,
      attributes: l,
      body: Yt(s)
    } : t.formatUnsupportedCmd(n);
  },
  htmlBuilder: (r, e) => {
    var t = Qt(r.body, e, !1), n = ["enclosing"];
    r.attributes.class && n.push(...r.attributes.class.trim().split(/\s+/));
    var i = ge.makeSpan(n, t, e);
    for (var o in r.attributes)
      o !== "class" && r.attributes.hasOwnProperty(o) && i.setAttribute(o, r.attributes[o]);
    return i;
  },
  mathmlBuilder: (r, e) => hn(r.body, e)
});
ze({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: !0
  },
  handler: (r, e) => {
    var {
      parser: t
    } = r;
    return {
      type: "htmlmathml",
      mode: t.mode,
      html: Yt(e[0]),
      mathml: Yt(e[1])
    };
  },
  htmlBuilder: (r, e) => {
    var t = Qt(r.html, e, !1);
    return ge.makeFragment(t);
  },
  mathmlBuilder: (r, e) => hn(r.mathml, e)
});
var oa = function(e) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(e))
    return {
      number: +e,
      unit: "bp"
    };
  var t = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(e);
  if (!t)
    throw new Re("Invalid size: '" + e + "' in \\includegraphics");
  var n = {
    number: +(t[1] + t[2]),
    // sign + magnitude, cast to number
    unit: t[3]
  };
  if (!ed(n))
    throw new Re("Invalid unit: '" + n.unit + "' in \\includegraphics.");
  return n;
};
ze({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: !1
  },
  handler: (r, e, t) => {
    var {
      parser: n
    } = r, i = {
      number: 0,
      unit: "em"
    }, o = {
      number: 0.9,
      unit: "em"
    }, s = {
      number: 0,
      unit: "em"
    }, a = "";
    if (t[0])
      for (var l = dt(t[0], "raw").string, u = l.split(","), d = 0; d < u.length; d++) {
        var p = u[d].split("=");
        if (p.length === 2) {
          var m = p[1].trim();
          switch (p[0].trim()) {
            case "alt":
              a = m;
              break;
            case "width":
              i = oa(m);
              break;
            case "height":
              o = oa(m);
              break;
            case "totalheight":
              s = oa(m);
              break;
            default:
              throw new Re("Invalid key: '" + p[0] + "' in \\includegraphics.");
          }
        }
      }
    var c = dt(e[0], "url").url;
    return a === "" && (a = c, a = a.replace(/^.*[\\/]/, ""), a = a.substring(0, a.lastIndexOf("."))), n.settings.isTrusted({
      command: "\\includegraphics",
      url: c
    }) ? {
      type: "includegraphics",
      mode: n.mode,
      alt: a,
      width: i,
      height: o,
      totalheight: s,
      src: c
    } : n.formatUnsupportedCmd("\\includegraphics");
  },
  htmlBuilder: (r, e) => {
    var t = Ht(r.height, e), n = 0;
    r.totalheight.number > 0 && (n = Ht(r.totalheight, e) - t);
    var i = 0;
    r.width.number > 0 && (i = Ht(r.width, e));
    var o = {
      height: $e(t + n)
    };
    i > 0 && (o.width = $e(i)), n > 0 && (o.verticalAlign = $e(-n));
    var s = new jm(r.src, r.alt, o);
    return s.height = t, s.depth = n, s;
  },
  mathmlBuilder: (r, e) => {
    var t = new Me.MathNode("mglyph", []);
    t.setAttribute("alt", r.alt);
    var n = Ht(r.height, e), i = 0;
    if (r.totalheight.number > 0 && (i = Ht(r.totalheight, e) - n, t.setAttribute("valign", $e(-i))), t.setAttribute("height", $e(n + i)), r.width.number > 0) {
      var o = Ht(r.width, e);
      t.setAttribute("width", $e(o));
    }
    return t.setAttribute("src", r.src), t;
  }
});
ze({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: !0,
    allowedInText: !0
  },
  handler(r, e) {
    var {
      parser: t,
      funcName: n
    } = r, i = dt(e[0], "size");
    if (t.settings.strict) {
      var o = n[1] === "m", s = i.value.unit === "mu";
      o ? (s || t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + n + " supports only mu units, " + ("not " + i.value.unit + " units")), t.mode !== "math" && t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + n + " works only in math mode")) : s && t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + n + " doesn't support mu units");
    }
    return {
      type: "kern",
      mode: t.mode,
      dimension: i.value
    };
  },
  htmlBuilder(r, e) {
    return ge.makeGlue(r.dimension, e);
  },
  mathmlBuilder(r, e) {
    var t = Ht(r.dimension, e);
    return new Me.SpaceNode(t);
  }
});
ze({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (r, e) => {
    var {
      parser: t,
      funcName: n
    } = r, i = e[0];
    return {
      type: "lap",
      mode: t.mode,
      alignment: n.slice(5),
      body: i
    };
  },
  htmlBuilder: (r, e) => {
    var t;
    r.alignment === "clap" ? (t = ge.makeSpan([], [yt(r.body, e)]), t = ge.makeSpan(["inner"], [t], e)) : t = ge.makeSpan(["inner"], [yt(r.body, e)]);
    var n = ge.makeSpan(["fix"], []), i = ge.makeSpan([r.alignment], [t, n], e), o = ge.makeSpan(["strut"]);
    return o.style.height = $e(i.height + i.depth), i.depth && (o.style.verticalAlign = $e(-i.depth)), i.children.unshift(o), i = ge.makeSpan(["thinbox"], [i], e), ge.makeSpan(["mord", "vbox"], [i], e);
  },
  mathmlBuilder: (r, e) => {
    var t = new Me.MathNode("mpadded", [Mt(r.body, e)]);
    if (r.alignment !== "rlap") {
      var n = r.alignment === "llap" ? "-1" : "-0.5";
      t.setAttribute("lspace", n + "width");
    }
    return t.setAttribute("width", "0px"), t;
  }
});
ze({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(r, e) {
    var {
      funcName: t,
      parser: n
    } = r, i = n.mode;
    n.switchMode("math");
    var o = t === "\\(" ? "\\)" : "$", s = n.parseExpression(!1, o);
    return n.expect(o), n.switchMode(i), {
      type: "styling",
      mode: n.mode,
      style: "text",
      body: s
    };
  }
});
ze({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(r, e) {
    throw new Re("Mismatched " + r.funcName);
  }
});
var Y0 = (r, e) => {
  switch (e.style.size) {
    case et.DISPLAY.size:
      return r.display;
    case et.TEXT.size:
      return r.text;
    case et.SCRIPT.size:
      return r.script;
    case et.SCRIPTSCRIPT.size:
      return r.scriptscript;
    default:
      return r.text;
  }
};
ze({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: !0
  },
  handler: (r, e) => {
    var {
      parser: t
    } = r;
    return {
      type: "mathchoice",
      mode: t.mode,
      display: Yt(e[0]),
      text: Yt(e[1]),
      script: Yt(e[2]),
      scriptscript: Yt(e[3])
    };
  },
  htmlBuilder: (r, e) => {
    var t = Y0(r, e), n = Qt(t, e, !1);
    return ge.makeFragment(n);
  },
  mathmlBuilder: (r, e) => {
    var t = Y0(r, e);
    return hn(t, e);
  }
});
var Id = (r, e, t, n, i, o, s) => {
  r = ge.makeSpan([], [r]);
  var a = t && Xe.isCharacterBox(t), l, u;
  if (e) {
    var d = yt(e, n.havingStyle(i.sup()), n);
    u = {
      elem: d,
      kern: Math.max(n.fontMetrics().bigOpSpacing1, n.fontMetrics().bigOpSpacing3 - d.depth)
    };
  }
  if (t) {
    var p = yt(t, n.havingStyle(i.sub()), n);
    l = {
      elem: p,
      kern: Math.max(n.fontMetrics().bigOpSpacing2, n.fontMetrics().bigOpSpacing4 - p.height)
    };
  }
  var m;
  if (u && l) {
    var c = n.fontMetrics().bigOpSpacing5 + l.elem.height + l.elem.depth + l.kern + r.depth + s;
    m = ge.makeVList({
      positionType: "bottom",
      positionData: c,
      children: [{
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: l.elem,
        marginLeft: $e(-o)
      }, {
        type: "kern",
        size: l.kern
      }, {
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: u.kern
      }, {
        type: "elem",
        elem: u.elem,
        marginLeft: $e(o)
      }, {
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }]
    }, n);
  } else if (l) {
    var h = r.height - s;
    m = ge.makeVList({
      positionType: "top",
      positionData: h,
      children: [{
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: l.elem,
        marginLeft: $e(-o)
      }, {
        type: "kern",
        size: l.kern
      }, {
        type: "elem",
        elem: r
      }]
    }, n);
  } else if (u) {
    var f = r.depth + s;
    m = ge.makeVList({
      positionType: "bottom",
      positionData: f,
      children: [{
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: u.kern
      }, {
        type: "elem",
        elem: u.elem,
        marginLeft: $e(o)
      }, {
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }]
    }, n);
  } else
    return r;
  var N = [m];
  if (l && o !== 0 && !a) {
    var v = ge.makeSpan(["mspace"], [], n);
    v.style.marginRight = $e(o), N.unshift(v);
  }
  return ge.makeSpan(["mop", "op-limits"], N, n);
}, Pd = ["\\smallint"], ei = (r, e) => {
  var t, n, i = !1, o;
  r.type === "supsub" ? (t = r.sup, n = r.sub, o = dt(r.base, "op"), i = !0) : o = dt(r, "op");
  var s = e.style, a = !1;
  s.size === et.DISPLAY.size && o.symbol && !Xe.contains(Pd, o.name) && (a = !0);
  var l;
  if (o.symbol) {
    var u = a ? "Size2-Regular" : "Size1-Regular", d = "";
    if ((o.name === "\\oiint" || o.name === "\\oiiint") && (d = o.name.slice(1), o.name = d === "oiint" ? "\\iint" : "\\iiint"), l = ge.makeSymbol(o.name, u, "math", e, ["mop", "op-symbol", a ? "large-op" : "small-op"]), d.length > 0) {
      var p = l.italic, m = ge.staticSvg(d + "Size" + (a ? "2" : "1"), e);
      l = ge.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: l,
          shift: 0
        }, {
          type: "elem",
          elem: m,
          shift: a ? 0.08 : 0
        }]
      }, e), o.name = "\\" + d, l.classes.unshift("mop"), l.italic = p;
    }
  } else if (o.body) {
    var c = Qt(o.body, e, !0);
    c.length === 1 && c[0] instanceof br ? (l = c[0], l.classes[0] = "mop") : l = ge.makeSpan(["mop"], c, e);
  } else {
    for (var h = [], f = 1; f < o.name.length; f++)
      h.push(ge.mathsym(o.name[f], o.mode, e));
    l = ge.makeSpan(["mop"], h, e);
  }
  var N = 0, v = 0;
  return (l instanceof br || o.name === "\\oiint" || o.name === "\\oiiint") && !o.suppressBaseShift && (N = (l.height - l.depth) / 2 - e.fontMetrics().axisHeight, v = l.italic), i ? Id(l, t, n, e, s, v, N) : (N && (l.style.position = "relative", l.style.top = $e(N)), l);
}, Bi = (r, e) => {
  var t;
  if (r.symbol)
    t = new Nr("mo", [yr(r.name, r.mode)]), Xe.contains(Pd, r.name) && t.setAttribute("largeop", "false");
  else if (r.body)
    t = new Nr("mo", gr(r.body, e));
  else {
    t = new Nr("mi", [new bi(r.name.slice(1))]);
    var n = new Nr("mo", [yr("â¡", "text")]);
    r.parentIsSupSub ? t = new Nr("mrow", [t, n]) : t = dd([t, n]);
  }
  return t;
}, qg = {
  "âˆ": "\\prod",
  "âˆ": "\\coprod",
  "âˆ‘": "\\sum",
  "â‹€": "\\bigwedge",
  "â‹": "\\bigvee",
  "â‹‚": "\\bigcap",
  "â‹ƒ": "\\bigcup",
  "â¨€": "\\bigodot",
  "â¨": "\\bigoplus",
  "â¨‚": "\\bigotimes",
  "â¨„": "\\biguplus",
  "â¨†": "\\bigsqcup"
};
ze({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "âˆ", "âˆ", "âˆ‘", "â‹€", "â‹", "â‹‚", "â‹ƒ", "â¨€", "â¨", "â¨‚", "â¨„", "â¨†"],
  props: {
    numArgs: 0
  },
  handler: (r, e) => {
    var {
      parser: t,
      funcName: n
    } = r, i = n;
    return i.length === 1 && (i = qg[i]), {
      type: "op",
      mode: t.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !0,
      name: i
    };
  },
  htmlBuilder: ei,
  mathmlBuilder: Bi
});
ze({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (r, e) => {
    var {
      parser: t
    } = r, n = e[0];
    return {
      type: "op",
      mode: t.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      body: Yt(n)
    };
  },
  htmlBuilder: ei,
  mathmlBuilder: Bi
});
var Kg = {
  "âˆ«": "\\int",
  "âˆ¬": "\\iint",
  "âˆ­": "\\iiint",
  "âˆ®": "\\oint",
  "âˆ¯": "\\oiint",
  "âˆ°": "\\oiiint"
};
ze({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(r) {
    var {
      parser: e,
      funcName: t
    } = r;
    return {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      name: t
    };
  },
  htmlBuilder: ei,
  mathmlBuilder: Bi
});
ze({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(r) {
    var {
      parser: e,
      funcName: t
    } = r;
    return {
      type: "op",
      mode: e.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !1,
      name: t
    };
  },
  htmlBuilder: ei,
  mathmlBuilder: Bi
});
ze({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "âˆ«", "âˆ¬", "âˆ­", "âˆ®", "âˆ¯", "âˆ°"],
  props: {
    numArgs: 0
  },
  handler(r) {
    var {
      parser: e,
      funcName: t
    } = r, n = t;
    return n.length === 1 && (n = Kg[n]), {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !0,
      name: n
    };
  },
  htmlBuilder: ei,
  mathmlBuilder: Bi
});
var Fd = (r, e) => {
  var t, n, i = !1, o;
  r.type === "supsub" ? (t = r.sup, n = r.sub, o = dt(r.base, "operatorname"), i = !0) : o = dt(r, "operatorname");
  var s;
  if (o.body.length > 0) {
    for (var a = o.body.map((p) => {
      var m = p.text;
      return typeof m == "string" ? {
        type: "textord",
        mode: p.mode,
        text: m
      } : p;
    }), l = Qt(a, e.withFont("mathrm"), !0), u = 0; u < l.length; u++) {
      var d = l[u];
      d instanceof br && (d.text = d.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
    }
    s = ge.makeSpan(["mop"], l, e);
  } else
    s = ge.makeSpan(["mop"], [], e);
  return i ? Id(s, t, n, e, e.style, 0, 0) : s;
}, Ug = (r, e) => {
  for (var t = gr(r.body, e.withFont("mathrm")), n = !0, i = 0; i < t.length; i++) {
    var o = t[i];
    if (!(o instanceof Me.SpaceNode)) if (o instanceof Me.MathNode)
      switch (o.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        case "mo": {
          var s = o.children[0];
          o.children.length === 1 && s instanceof Me.TextNode ? s.text = s.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : n = !1;
          break;
        }
        default:
          n = !1;
      }
    else
      n = !1;
  }
  if (n) {
    var a = t.map((d) => d.toText()).join("");
    t = [new Me.TextNode(a)];
  }
  var l = new Me.MathNode("mi", t);
  l.setAttribute("mathvariant", "normal");
  var u = new Me.MathNode("mo", [yr("â¡", "text")]);
  return r.parentIsSupSub ? new Me.MathNode("mrow", [l, u]) : Me.newDocumentFragment([l, u]);
};
ze({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (r, e) => {
    var {
      parser: t,
      funcName: n
    } = r, i = e[0];
    return {
      type: "operatorname",
      mode: t.mode,
      body: Yt(i),
      alwaysHandleSupSub: n === "\\operatornamewithlimits",
      limits: !1,
      parentIsSupSub: !1
    };
  },
  htmlBuilder: Fd,
  mathmlBuilder: Ug
});
J("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
Ln({
  type: "ordgroup",
  htmlBuilder(r, e) {
    return r.semisimple ? ge.makeFragment(Qt(r.body, e, !1)) : ge.makeSpan(["mord"], Qt(r.body, e, !0), e);
  },
  mathmlBuilder(r, e) {
    return hn(r.body, e, !0);
  }
});
ze({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(r, e) {
    var {
      parser: t
    } = r, n = e[0];
    return {
      type: "overline",
      mode: t.mode,
      body: n
    };
  },
  htmlBuilder(r, e) {
    var t = yt(r.body, e.havingCrampedStyle()), n = ge.makeLineSpan("overline-line", e), i = e.fontMetrics().defaultRuleThickness, o = ge.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: i
      }]
    }, e);
    return ge.makeSpan(["mord", "overline"], [o], e);
  },
  mathmlBuilder(r, e) {
    var t = new Me.MathNode("mo", [new Me.TextNode("â€¾")]);
    t.setAttribute("stretchy", "true");
    var n = new Me.MathNode("mover", [Mt(r.body, e), t]);
    return n.setAttribute("accent", "true"), n;
  }
});
ze({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (r, e) => {
    var {
      parser: t
    } = r, n = e[0];
    return {
      type: "phantom",
      mode: t.mode,
      body: Yt(n)
    };
  },
  htmlBuilder: (r, e) => {
    var t = Qt(r.body, e.withPhantom(), !1);
    return ge.makeFragment(t);
  },
  mathmlBuilder: (r, e) => {
    var t = gr(r.body, e);
    return new Me.MathNode("mphantom", t);
  }
});
ze({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (r, e) => {
    var {
      parser: t
    } = r, n = e[0];
    return {
      type: "hphantom",
      mode: t.mode,
      body: n
    };
  },
  htmlBuilder: (r, e) => {
    var t = ge.makeSpan([], [yt(r.body, e.withPhantom())]);
    if (t.height = 0, t.depth = 0, t.children)
      for (var n = 0; n < t.children.length; n++)
        t.children[n].height = 0, t.children[n].depth = 0;
    return t = ge.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }]
    }, e), ge.makeSpan(["mord"], [t], e);
  },
  mathmlBuilder: (r, e) => {
    var t = gr(Yt(r.body), e), n = new Me.MathNode("mphantom", t), i = new Me.MathNode("mpadded", [n]);
    return i.setAttribute("height", "0px"), i.setAttribute("depth", "0px"), i;
  }
});
ze({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (r, e) => {
    var {
      parser: t
    } = r, n = e[0];
    return {
      type: "vphantom",
      mode: t.mode,
      body: n
    };
  },
  htmlBuilder: (r, e) => {
    var t = ge.makeSpan(["inner"], [yt(r.body, e.withPhantom())]), n = ge.makeSpan(["fix"], []);
    return ge.makeSpan(["mord", "rlap"], [t, n], e);
  },
  mathmlBuilder: (r, e) => {
    var t = gr(Yt(r.body), e), n = new Me.MathNode("mphantom", t), i = new Me.MathNode("mpadded", [n]);
    return i.setAttribute("width", "0px"), i;
  }
});
ze({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: !0
  },
  handler(r, e) {
    var {
      parser: t
    } = r, n = dt(e[0], "size").value, i = e[1];
    return {
      type: "raisebox",
      mode: t.mode,
      dy: n,
      body: i
    };
  },
  htmlBuilder(r, e) {
    var t = yt(r.body, e), n = Ht(r.dy, e);
    return ge.makeVList({
      positionType: "shift",
      positionData: -n,
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
  },
  mathmlBuilder(r, e) {
    var t = new Me.MathNode("mpadded", [Mt(r.body, e)]), n = r.dy.number + r.dy.unit;
    return t.setAttribute("voffset", n), t;
  }
});
ze({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(r) {
    var {
      parser: e
    } = r;
    return {
      type: "internal",
      mode: e.mode
    };
  }
});
ze({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    argTypes: ["size", "size", "size"]
  },
  handler(r, e, t) {
    var {
      parser: n
    } = r, i = t[0], o = dt(e[0], "size"), s = dt(e[1], "size");
    return {
      type: "rule",
      mode: n.mode,
      shift: i && dt(i, "size").value,
      width: o.value,
      height: s.value
    };
  },
  htmlBuilder(r, e) {
    var t = ge.makeSpan(["mord", "rule"], [], e), n = Ht(r.width, e), i = Ht(r.height, e), o = r.shift ? Ht(r.shift, e) : 0;
    return t.style.borderRightWidth = $e(n), t.style.borderTopWidth = $e(i), t.style.bottom = $e(o), t.width = n, t.height = i + o, t.depth = -o, t.maxFontSize = i * 1.125 * e.sizeMultiplier, t;
  },
  mathmlBuilder(r, e) {
    var t = Ht(r.width, e), n = Ht(r.height, e), i = r.shift ? Ht(r.shift, e) : 0, o = e.color && e.getColor() || "black", s = new Me.MathNode("mspace");
    s.setAttribute("mathbackground", o), s.setAttribute("width", $e(t)), s.setAttribute("height", $e(n));
    var a = new Me.MathNode("mpadded", [s]);
    return i >= 0 ? a.setAttribute("height", $e(i)) : (a.setAttribute("height", $e(i)), a.setAttribute("depth", $e(-i))), a.setAttribute("voffset", $e(i)), a;
  }
});
function Bd(r, e, t) {
  for (var n = Qt(r, e, !1), i = e.sizeMultiplier / t.sizeMultiplier, o = 0; o < n.length; o++) {
    var s = n[o].classes.indexOf("sizing");
    s < 0 ? Array.prototype.push.apply(n[o].classes, e.sizingClasses(t)) : n[o].classes[s + 1] === "reset-size" + e.size && (n[o].classes[s + 1] = "reset-size" + t.size), n[o].height *= i, n[o].depth *= i;
  }
  return ge.makeFragment(n);
}
var W0 = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], Yg = (r, e) => {
  var t = e.havingSize(r.size);
  return Bd(r.body, t, e);
};
ze({
  type: "sizing",
  names: W0,
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (r, e) => {
    var {
      breakOnTokenText: t,
      funcName: n,
      parser: i
    } = r, o = i.parseExpression(!1, t);
    return {
      type: "sizing",
      mode: i.mode,
      // Figure out what size to use based on the list of functions above
      size: W0.indexOf(n) + 1,
      body: o
    };
  },
  htmlBuilder: Yg,
  mathmlBuilder: (r, e) => {
    var t = e.havingSize(r.size), n = gr(r.body, t), i = new Me.MathNode("mstyle", n);
    return i.setAttribute("mathsize", $e(t.sizeMultiplier)), i;
  }
});
ze({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: !0
  },
  handler: (r, e, t) => {
    var {
      parser: n
    } = r, i = !1, o = !1, s = t[0] && dt(t[0], "ordgroup");
    if (s)
      for (var a = "", l = 0; l < s.body.length; ++l) {
        var u = s.body[l];
        if (a = u.text, a === "t")
          i = !0;
        else if (a === "b")
          o = !0;
        else {
          i = !1, o = !1;
          break;
        }
      }
    else
      i = !0, o = !0;
    var d = e[0];
    return {
      type: "smash",
      mode: n.mode,
      body: d,
      smashHeight: i,
      smashDepth: o
    };
  },
  htmlBuilder: (r, e) => {
    var t = ge.makeSpan([], [yt(r.body, e)]);
    if (!r.smashHeight && !r.smashDepth)
      return t;
    if (r.smashHeight && (t.height = 0, t.children))
      for (var n = 0; n < t.children.length; n++)
        t.children[n].height = 0;
    if (r.smashDepth && (t.depth = 0, t.children))
      for (var i = 0; i < t.children.length; i++)
        t.children[i].depth = 0;
    var o = ge.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
    return ge.makeSpan(["mord"], [o], e);
  },
  mathmlBuilder: (r, e) => {
    var t = new Me.MathNode("mpadded", [Mt(r.body, e)]);
    return r.smashHeight && t.setAttribute("height", "0px"), r.smashDepth && t.setAttribute("depth", "0px"), t;
  }
});
ze({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(r, e, t) {
    var {
      parser: n
    } = r, i = t[0], o = e[0];
    return {
      type: "sqrt",
      mode: n.mode,
      body: o,
      index: i
    };
  },
  htmlBuilder(r, e) {
    var t = yt(r.body, e.havingCrampedStyle());
    t.height === 0 && (t.height = e.fontMetrics().xHeight), t = ge.wrapFragment(t, e);
    var n = e.fontMetrics(), i = n.defaultRuleThickness, o = i;
    e.style.id < et.TEXT.id && (o = e.fontMetrics().xHeight);
    var s = i + o / 4, a = t.height + t.depth + s + i, {
      span: l,
      ruleWidth: u,
      advanceWidth: d
    } = Gr.sqrtImage(a, e), p = l.height - u;
    p > t.height + t.depth + s && (s = (s + p - t.height - t.depth) / 2);
    var m = l.height - t.height - s - u;
    t.style.paddingLeft = $e(d);
    var c = ge.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(t.height + m)
      }, {
        type: "elem",
        elem: l
      }, {
        type: "kern",
        size: u
      }]
    }, e);
    if (r.index) {
      var h = e.havingStyle(et.SCRIPTSCRIPT), f = yt(r.index, h, e), N = 0.6 * (c.height - c.depth), v = ge.makeVList({
        positionType: "shift",
        positionData: -N,
        children: [{
          type: "elem",
          elem: f
        }]
      }, e), C = ge.makeSpan(["root"], [v]);
      return ge.makeSpan(["mord", "sqrt"], [C, c], e);
    } else
      return ge.makeSpan(["mord", "sqrt"], [c], e);
  },
  mathmlBuilder(r, e) {
    var {
      body: t,
      index: n
    } = r;
    return n ? new Me.MathNode("mroot", [Mt(t, e), Mt(n, e)]) : new Me.MathNode("msqrt", [Mt(t, e)]);
  }
});
var G0 = {
  display: et.DISPLAY,
  text: et.TEXT,
  script: et.SCRIPT,
  scriptscript: et.SCRIPTSCRIPT
};
ze({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(r, e) {
    var {
      breakOnTokenText: t,
      funcName: n,
      parser: i
    } = r, o = i.parseExpression(!0, t), s = n.slice(1, n.length - 5);
    return {
      type: "styling",
      mode: i.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style: s,
      body: o
    };
  },
  htmlBuilder(r, e) {
    var t = G0[r.style], n = e.havingStyle(t).withFont("");
    return Bd(r.body, n, e);
  },
  mathmlBuilder(r, e) {
    var t = G0[r.style], n = e.havingStyle(t), i = gr(r.body, n), o = new Me.MathNode("mstyle", i), s = {
      display: ["0", "true"],
      text: ["0", "false"],
      script: ["1", "false"],
      scriptscript: ["2", "false"]
    }, a = s[r.style];
    return o.setAttribute("scriptlevel", a[0]), o.setAttribute("displaystyle", a[1]), o;
  }
});
var Wg = function(e, t) {
  var n = e.base;
  if (n)
    if (n.type === "op") {
      var i = n.limits && (t.style.size === et.DISPLAY.size || n.alwaysHandleSupSub);
      return i ? ei : null;
    } else if (n.type === "operatorname") {
      var o = n.alwaysHandleSupSub && (t.style.size === et.DISPLAY.size || n.limits);
      return o ? Fd : null;
    } else {
      if (n.type === "accent")
        return Xe.isCharacterBox(n.base) ? ks : null;
      if (n.type === "horizBrace") {
        var s = !e.sub;
        return s === n.isOver ? $d : null;
      } else
        return null;
    }
  else return null;
};
Ln({
  type: "supsub",
  htmlBuilder(r, e) {
    var t = Wg(r, e);
    if (t)
      return t(r, e);
    var {
      base: n,
      sup: i,
      sub: o
    } = r, s = yt(n, e), a, l, u = e.fontMetrics(), d = 0, p = 0, m = n && Xe.isCharacterBox(n);
    if (i) {
      var c = e.havingStyle(e.style.sup());
      a = yt(i, c, e), m || (d = s.height - c.fontMetrics().supDrop * c.sizeMultiplier / e.sizeMultiplier);
    }
    if (o) {
      var h = e.havingStyle(e.style.sub());
      l = yt(o, h, e), m || (p = s.depth + h.fontMetrics().subDrop * h.sizeMultiplier / e.sizeMultiplier);
    }
    var f;
    e.style === et.DISPLAY ? f = u.sup1 : e.style.cramped ? f = u.sup3 : f = u.sup2;
    var N = e.sizeMultiplier, v = $e(0.5 / u.ptPerEm / N), C = null;
    if (l) {
      var g = r.base && r.base.type === "op" && r.base.name && (r.base.name === "\\oiint" || r.base.name === "\\oiiint");
      (s instanceof br || g) && (C = $e(-s.italic));
    }
    var x;
    if (a && l) {
      d = Math.max(d, f, a.depth + 0.25 * u.xHeight), p = Math.max(p, u.sub2);
      var b = u.defaultRuleThickness, A = 4 * b;
      if (d - a.depth - (l.height - p) < A) {
        p = A - (d - a.depth) + l.height;
        var w = 0.8 * u.xHeight - (d - a.depth);
        w > 0 && (d += w, p -= w);
      }
      var M = [{
        type: "elem",
        elem: l,
        shift: p,
        marginRight: v,
        marginLeft: C
      }, {
        type: "elem",
        elem: a,
        shift: -d,
        marginRight: v
      }];
      x = ge.makeVList({
        positionType: "individualShift",
        children: M
      }, e);
    } else if (l) {
      p = Math.max(p, u.sub1, l.height - 0.8 * u.xHeight);
      var y = [{
        type: "elem",
        elem: l,
        marginLeft: C,
        marginRight: v
      }];
      x = ge.makeVList({
        positionType: "shift",
        positionData: p,
        children: y
      }, e);
    } else if (a)
      d = Math.max(d, f, a.depth + 0.25 * u.xHeight), x = ge.makeVList({
        positionType: "shift",
        positionData: -d,
        children: [{
          type: "elem",
          elem: a,
          marginRight: v
        }]
      }, e);
    else
      throw new Error("supsub must have either sup or sub.");
    var E = Za(s, "right") || "mord";
    return ge.makeSpan([E], [s, ge.makeSpan(["msupsub"], [x])], e);
  },
  mathmlBuilder(r, e) {
    var t = !1, n, i;
    r.base && r.base.type === "horizBrace" && (i = !!r.sup, i === r.base.isOver && (t = !0, n = r.base.isOver)), r.base && (r.base.type === "op" || r.base.type === "operatorname") && (r.base.parentIsSupSub = !0);
    var o = [Mt(r.base, e)];
    r.sub && o.push(Mt(r.sub, e)), r.sup && o.push(Mt(r.sup, e));
    var s;
    if (t)
      s = n ? "mover" : "munder";
    else if (r.sub)
      if (r.sup) {
        var u = r.base;
        u && u.type === "op" && u.limits && e.style === et.DISPLAY || u && u.type === "operatorname" && u.alwaysHandleSupSub && (e.style === et.DISPLAY || u.limits) ? s = "munderover" : s = "msubsup";
      } else {
        var l = r.base;
        l && l.type === "op" && l.limits && (e.style === et.DISPLAY || l.alwaysHandleSupSub) || l && l.type === "operatorname" && l.alwaysHandleSupSub && (l.limits || e.style === et.DISPLAY) ? s = "munder" : s = "msub";
      }
    else {
      var a = r.base;
      a && a.type === "op" && a.limits && (e.style === et.DISPLAY || a.alwaysHandleSupSub) || a && a.type === "operatorname" && a.alwaysHandleSupSub && (a.limits || e.style === et.DISPLAY) ? s = "mover" : s = "msup";
    }
    return new Me.MathNode(s, o);
  }
});
Ln({
  type: "atom",
  htmlBuilder(r, e) {
    return ge.mathsym(r.text, r.mode, e, ["m" + r.family]);
  },
  mathmlBuilder(r, e) {
    var t = new Me.MathNode("mo", [yr(r.text, r.mode)]);
    if (r.family === "bin") {
      var n = As(r, e);
      n === "bold-italic" && t.setAttribute("mathvariant", n);
    } else r.family === "punct" ? t.setAttribute("separator", "true") : (r.family === "open" || r.family === "close") && t.setAttribute("stretchy", "false");
    return t;
  }
});
var zd = {
  mi: "italic",
  mn: "normal",
  mtext: "normal"
};
Ln({
  type: "mathord",
  htmlBuilder(r, e) {
    return ge.makeOrd(r, e, "mathord");
  },
  mathmlBuilder(r, e) {
    var t = new Me.MathNode("mi", [yr(r.text, r.mode, e)]), n = As(r, e) || "italic";
    return n !== zd[t.type] && t.setAttribute("mathvariant", n), t;
  }
});
Ln({
  type: "textord",
  htmlBuilder(r, e) {
    return ge.makeOrd(r, e, "textord");
  },
  mathmlBuilder(r, e) {
    var t = yr(r.text, r.mode, e), n = As(r, e) || "normal", i;
    return r.mode === "text" ? i = new Me.MathNode("mtext", [t]) : /[0-9]/.test(r.text) ? i = new Me.MathNode("mn", [t]) : r.text === "\\prime" ? i = new Me.MathNode("mo", [t]) : i = new Me.MathNode("mi", [t]), n !== zd[i.type] && i.setAttribute("mathvariant", n), i;
  }
});
var aa = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
}, sa = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
Ln({
  type: "spacing",
  htmlBuilder(r, e) {
    if (sa.hasOwnProperty(r.text)) {
      var t = sa[r.text].className || "";
      if (r.mode === "text") {
        var n = ge.makeOrd(r, e, "textord");
        return n.classes.push(t), n;
      } else
        return ge.makeSpan(["mspace", t], [ge.mathsym(r.text, r.mode, e)], e);
    } else {
      if (aa.hasOwnProperty(r.text))
        return ge.makeSpan(["mspace", aa[r.text]], [], e);
      throw new Re('Unknown type of space "' + r.text + '"');
    }
  },
  mathmlBuilder(r, e) {
    var t;
    if (sa.hasOwnProperty(r.text))
      t = new Me.MathNode("mtext", [new Me.TextNode("Â ")]);
    else {
      if (aa.hasOwnProperty(r.text))
        return new Me.MathNode("mspace");
      throw new Re('Unknown type of space "' + r.text + '"');
    }
    return t;
  }
});
var V0 = () => {
  var r = new Me.MathNode("mtd", []);
  return r.setAttribute("width", "50%"), r;
};
Ln({
  type: "tag",
  mathmlBuilder(r, e) {
    var t = new Me.MathNode("mtable", [new Me.MathNode("mtr", [V0(), new Me.MathNode("mtd", [hn(r.body, e)]), V0(), new Me.MathNode("mtd", [hn(r.tag, e)])])]);
    return t.setAttribute("width", "100%"), t;
  }
});
var X0 = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
}, J0 = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
}, Gg = {
  "\\textit": "textit",
  "\\textup": "textup"
}, Z0 = (r, e) => {
  var t = r.font;
  if (t) {
    if (X0[t])
      return e.withTextFontFamily(X0[t]);
    if (J0[t])
      return e.withTextFontWeight(J0[t]);
    if (t === "\\emph")
      return e.fontShape === "textit" ? e.withTextFontShape("textup") : e.withTextFontShape("textit");
  } else return e;
  return e.withTextFontShape(Gg[t]);
};
ze({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: !0,
    allowedInText: !0
  },
  handler(r, e) {
    var {
      parser: t,
      funcName: n
    } = r, i = e[0];
    return {
      type: "text",
      mode: t.mode,
      body: Yt(i),
      font: n
    };
  },
  htmlBuilder(r, e) {
    var t = Z0(r, e), n = Qt(r.body, t, !0);
    return ge.makeSpan(["mord", "text"], n, t);
  },
  mathmlBuilder(r, e) {
    var t = Z0(r, e);
    return hn(r.body, t);
  }
});
ze({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(r, e) {
    var {
      parser: t
    } = r;
    return {
      type: "underline",
      mode: t.mode,
      body: e[0]
    };
  },
  htmlBuilder(r, e) {
    var t = yt(r.body, e), n = ge.makeLineSpan("underline-line", e), i = e.fontMetrics().defaultRuleThickness, o = ge.makeVList({
      positionType: "top",
      positionData: t.height,
      children: [{
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: t
      }]
    }, e);
    return ge.makeSpan(["mord", "underline"], [o], e);
  },
  mathmlBuilder(r, e) {
    var t = new Me.MathNode("mo", [new Me.TextNode("â€¾")]);
    t.setAttribute("stretchy", "true");
    var n = new Me.MathNode("munder", [Mt(r.body, e), t]);
    return n.setAttribute("accentunder", "true"), n;
  }
});
ze({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: !1
  },
  handler(r, e) {
    var {
      parser: t
    } = r;
    return {
      type: "vcenter",
      mode: t.mode,
      body: e[0]
    };
  },
  htmlBuilder(r, e) {
    var t = yt(r.body, e), n = e.fontMetrics().axisHeight, i = 0.5 * (t.height - n - (t.depth + n));
    return ge.makeVList({
      positionType: "shift",
      positionData: i,
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
  },
  mathmlBuilder(r, e) {
    return new Me.MathNode("mpadded", [Mt(r.body, e)], ["vcenter"]);
  }
});
ze({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(r, e, t) {
    throw new Re("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(r, e) {
    for (var t = Q0(r), n = [], i = e.havingStyle(e.style.text()), o = 0; o < t.length; o++) {
      var s = t[o];
      s === "~" && (s = "\\textasciitilde"), n.push(ge.makeSymbol(s, "Typewriter-Regular", r.mode, i, ["mord", "texttt"]));
    }
    return ge.makeSpan(["mord", "text"].concat(i.sizingClasses(e)), ge.tryCombineChars(n), i);
  },
  mathmlBuilder(r, e) {
    var t = new Me.TextNode(Q0(r)), n = new Me.MathNode("mtext", [t]);
    return n.setAttribute("mathvariant", "monospace"), n;
  }
});
var Q0 = (r) => r.body.replace(/ /g, r.star ? "â£" : "Â "), ln = cd, Hd = `[ \r
	]`, Vg = "\\\\[a-zA-Z@]+", Xg = "\\\\[^\uD800-\uDFFF]", Jg = "(" + Vg + ")" + Hd + "*", Zg = `\\\\(
|[ \r	]+
?)[ \r	]*`, rs = "[Ì€-Í¯]", Qg = new RegExp(rs + "+$"), ep = "(" + Hd + "+)|" + // whitespace
(Zg + "|") + // \whitespace
"([!-\\[\\]-â€§â€ª-íŸ¿ï¤€-ï¿¿]" + // single codepoint
(rs + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(rs + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + Jg) + // \macroName + spaces
("|" + Xg + ")");
class ec {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(e, t) {
    this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = e, this.settings = t, this.tokenRegex = new RegExp(ep, "g"), this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(e, t) {
    this.catcodes[e] = t;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var e = this.input, t = this.tokenRegex.lastIndex;
    if (t === e.length)
      return new Cr("EOF", new pr(this, t, t));
    var n = this.tokenRegex.exec(e);
    if (n === null || n.index !== t)
      throw new Re("Unexpected character: '" + e[t] + "'", new Cr(e[t], new pr(this, t, t + 1)));
    var i = n[6] || n[3] || (n[2] ? "\\ " : " ");
    if (this.catcodes[i] === 14) {
      var o = e.indexOf(`
`, this.tokenRegex.lastIndex);
      return o === -1 ? (this.tokenRegex.lastIndex = e.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = o + 1, this.lex();
    }
    return new Cr(i, new pr(this, t, this.tokenRegex.lastIndex));
  }
}
class tp {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(e, t) {
    e === void 0 && (e = {}), t === void 0 && (t = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = t, this.builtins = e, this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0)
      throw new Re("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    var e = this.undefStack.pop();
    for (var t in e)
      e.hasOwnProperty(t) && (e[t] == null ? delete this.current[t] : this.current[t] = e[t]);
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    for (; this.undefStack.length > 0; )
      this.endGroup();
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(e) {
    return this.current.hasOwnProperty(e) || this.builtins.hasOwnProperty(e);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(e) {
    return this.current.hasOwnProperty(e) ? this.current[e] : this.builtins[e];
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(e, t, n) {
    if (n === void 0 && (n = !1), n) {
      for (var i = 0; i < this.undefStack.length; i++)
        delete this.undefStack[i][e];
      this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][e] = t);
    } else {
      var o = this.undefStack[this.undefStack.length - 1];
      o && !o.hasOwnProperty(e) && (o[e] = this.current[e]);
    }
    t == null ? delete this.current[e] : this.current[e] = t;
  }
}
var rp = Rd;
J("\\noexpand", function(r) {
  var e = r.popToken();
  return r.isExpandable(e.text) && (e.noexpand = !0, e.treatAsRelax = !0), {
    tokens: [e],
    numArgs: 0
  };
});
J("\\expandafter", function(r) {
  var e = r.popToken();
  return r.expandOnce(!0), {
    tokens: [e],
    numArgs: 0
  };
});
J("\\@firstoftwo", function(r) {
  var e = r.consumeArgs(2);
  return {
    tokens: e[0],
    numArgs: 0
  };
});
J("\\@secondoftwo", function(r) {
  var e = r.consumeArgs(2);
  return {
    tokens: e[1],
    numArgs: 0
  };
});
J("\\@ifnextchar", function(r) {
  var e = r.consumeArgs(3);
  r.consumeSpaces();
  var t = r.future();
  return e[0].length === 1 && e[0][0].text === t.text ? {
    tokens: e[1],
    numArgs: 0
  } : {
    tokens: e[2],
    numArgs: 0
  };
});
J("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
J("\\TextOrMath", function(r) {
  var e = r.consumeArgs(2);
  return r.mode === "text" ? {
    tokens: e[0],
    numArgs: 0
  } : {
    tokens: e[1],
    numArgs: 0
  };
});
var tc = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
J("\\char", function(r) {
  var e = r.popToken(), t, n = "";
  if (e.text === "'")
    t = 8, e = r.popToken();
  else if (e.text === '"')
    t = 16, e = r.popToken();
  else if (e.text === "`")
    if (e = r.popToken(), e.text[0] === "\\")
      n = e.text.charCodeAt(1);
    else {
      if (e.text === "EOF")
        throw new Re("\\char` missing argument");
      n = e.text.charCodeAt(0);
    }
  else
    t = 10;
  if (t) {
    if (n = tc[e.text], n == null || n >= t)
      throw new Re("Invalid base-" + t + " digit " + e.text);
    for (var i; (i = tc[r.future().text]) != null && i < t; )
      n *= t, n += i, r.popToken();
  }
  return "\\@char{" + n + "}";
});
var Hs = (r, e, t) => {
  var n = r.consumeArg().tokens;
  if (n.length !== 1)
    throw new Re("\\newcommand's first argument must be a macro name");
  var i = n[0].text, o = r.isDefined(i);
  if (o && !e)
    throw new Re("\\newcommand{" + i + "} attempting to redefine " + (i + "; use \\renewcommand"));
  if (!o && !t)
    throw new Re("\\renewcommand{" + i + "} when command " + i + " does not yet exist; use \\newcommand");
  var s = 0;
  if (n = r.consumeArg().tokens, n.length === 1 && n[0].text === "[") {
    for (var a = "", l = r.expandNextToken(); l.text !== "]" && l.text !== "EOF"; )
      a += l.text, l = r.expandNextToken();
    if (!a.match(/^\s*[0-9]+\s*$/))
      throw new Re("Invalid number of arguments: " + a);
    s = parseInt(a), n = r.consumeArg().tokens;
  }
  return r.macros.set(i, {
    tokens: n,
    numArgs: s
  }), "";
};
J("\\newcommand", (r) => Hs(r, !1, !0));
J("\\renewcommand", (r) => Hs(r, !0, !1));
J("\\providecommand", (r) => Hs(r, !0, !0));
J("\\message", (r) => {
  var e = r.consumeArgs(1)[0];
  return console.log(e.reverse().map((t) => t.text).join("")), "";
});
J("\\errmessage", (r) => {
  var e = r.consumeArgs(1)[0];
  return console.error(e.reverse().map((t) => t.text).join("")), "";
});
J("\\show", (r) => {
  var e = r.popToken(), t = e.text;
  return console.log(e, r.macros.get(t), ln[t], Lt.math[t], Lt.text[t]), "";
});
J("\\bgroup", "{");
J("\\egroup", "}");
J("~", "\\nobreakspace");
J("\\lq", "`");
J("\\rq", "'");
J("\\aa", "\\r a");
J("\\AA", "\\r A");
J("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`Â©}");
J("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
J("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`Â®}");
J("â„¬", "\\mathscr{B}");
J("â„°", "\\mathscr{E}");
J("â„±", "\\mathscr{F}");
J("â„‹", "\\mathscr{H}");
J("â„", "\\mathscr{I}");
J("â„’", "\\mathscr{L}");
J("â„³", "\\mathscr{M}");
J("â„›", "\\mathscr{R}");
J("â„­", "\\mathfrak{C}");
J("â„Œ", "\\mathfrak{H}");
J("â„¨", "\\mathfrak{Z}");
J("\\Bbbk", "\\Bbb{k}");
J("Â·", "\\cdotp");
J("\\llap", "\\mathllap{\\textrm{#1}}");
J("\\rlap", "\\mathrlap{\\textrm{#1}}");
J("\\clap", "\\mathclap{\\textrm{#1}}");
J("\\mathstrut", "\\vphantom{(}");
J("\\underbar", "\\underline{\\text{#1}}");
J("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
J("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`â‰ }}");
J("\\ne", "\\neq");
J("â‰ ", "\\neq");
J("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`âˆ‰}}");
J("âˆ‰", "\\notin");
J("â‰˜", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`â‰˜}}");
J("â‰™", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`â‰˜}}");
J("â‰š", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`â‰š}}");
J("â‰›", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`â‰›}}");
J("â‰", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`â‰}}");
J("â‰ž", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`â‰ž}}");
J("â‰Ÿ", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`â‰Ÿ}}");
J("âŸ‚", "\\perp");
J("â€¼", "\\mathclose{!\\mkern-0.8mu!}");
J("âˆŒ", "\\notni");
J("âŒœ", "\\ulcorner");
J("âŒ", "\\urcorner");
J("âŒž", "\\llcorner");
J("âŒŸ", "\\lrcorner");
J("Â©", "\\copyright");
J("Â®", "\\textregistered");
J("ï¸", "\\textregistered");
J("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
J("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
J("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
J("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
J("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
J("â‹®", "\\vdots");
J("\\varGamma", "\\mathit{\\Gamma}");
J("\\varDelta", "\\mathit{\\Delta}");
J("\\varTheta", "\\mathit{\\Theta}");
J("\\varLambda", "\\mathit{\\Lambda}");
J("\\varXi", "\\mathit{\\Xi}");
J("\\varPi", "\\mathit{\\Pi}");
J("\\varSigma", "\\mathit{\\Sigma}");
J("\\varUpsilon", "\\mathit{\\Upsilon}");
J("\\varPhi", "\\mathit{\\Phi}");
J("\\varPsi", "\\mathit{\\Psi}");
J("\\varOmega", "\\mathit{\\Omega}");
J("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
J("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
J("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
J("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
J("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
J("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
var rc = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
J("\\dots", function(r) {
  var e = "\\dotso", t = r.expandAfterFuture().text;
  return t in rc ? e = rc[t] : (t.slice(0, 4) === "\\not" || t in Lt.math && Xe.contains(["bin", "rel"], Lt.math[t].group)) && (e = "\\dotsb"), e;
});
var js = {
  // \rightdelim@ checks for the following:
  ")": !0,
  "]": !0,
  "\\rbrack": !0,
  "\\}": !0,
  "\\rbrace": !0,
  "\\rangle": !0,
  "\\rceil": !0,
  "\\rfloor": !0,
  "\\rgroup": !0,
  "\\rmoustache": !0,
  "\\right": !0,
  "\\bigr": !0,
  "\\biggr": !0,
  "\\Bigr": !0,
  "\\Biggr": !0,
  // \extra@ also tests for the following:
  $: !0,
  // \extrap@ checks for the following:
  ";": !0,
  ".": !0,
  ",": !0
};
J("\\dotso", function(r) {
  var e = r.future().text;
  return e in js ? "\\ldots\\," : "\\ldots";
});
J("\\dotsc", function(r) {
  var e = r.future().text;
  return e in js && e !== "," ? "\\ldots\\," : "\\ldots";
});
J("\\cdots", function(r) {
  var e = r.future().text;
  return e in js ? "\\@cdots\\," : "\\@cdots";
});
J("\\dotsb", "\\cdots");
J("\\dotsm", "\\cdots");
J("\\dotsi", "\\!\\cdots");
J("\\dotsx", "\\ldots\\,");
J("\\DOTSI", "\\relax");
J("\\DOTSB", "\\relax");
J("\\DOTSX", "\\relax");
J("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
J("\\,", "\\tmspace+{3mu}{.1667em}");
J("\\thinspace", "\\,");
J("\\>", "\\mskip{4mu}");
J("\\:", "\\tmspace+{4mu}{.2222em}");
J("\\medspace", "\\:");
J("\\;", "\\tmspace+{5mu}{.2777em}");
J("\\thickspace", "\\;");
J("\\!", "\\tmspace-{3mu}{.1667em}");
J("\\negthinspace", "\\!");
J("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
J("\\negthickspace", "\\tmspace-{5mu}{.277em}");
J("\\enspace", "\\kern.5em ");
J("\\enskip", "\\hskip.5em\\relax");
J("\\quad", "\\hskip1em\\relax");
J("\\qquad", "\\hskip2em\\relax");
J("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
J("\\tag@paren", "\\tag@literal{({#1})}");
J("\\tag@literal", (r) => {
  if (r.macros.get("\\df@tag"))
    throw new Re("Multiple \\tag");
  return "\\gdef\\df@tag{\\text{#1}}";
});
J("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
J("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
J("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
J("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
J("\\newline", "\\\\\\relax");
J("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var jd = $e($r["Main-Regular"][84][1] - 0.7 * $r["Main-Regular"][65][1]);
J("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + jd + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
J("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + jd + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
J("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
J("\\@hspace", "\\hskip #1\\relax");
J("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
J("\\ordinarycolon", ":");
J("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
J("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
J("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
J("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
J("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
J("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
J("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
J("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
J("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
J("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
J("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
J("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
J("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
J("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
J("âˆ·", "\\dblcolon");
J("âˆ¹", "\\eqcolon");
J("â‰”", "\\coloneqq");
J("â‰•", "\\eqqcolon");
J("â©´", "\\Coloneqq");
J("\\ratio", "\\vcentcolon");
J("\\coloncolon", "\\dblcolon");
J("\\colonequals", "\\coloneqq");
J("\\coloncolonequals", "\\Coloneqq");
J("\\equalscolon", "\\eqqcolon");
J("\\equalscoloncolon", "\\Eqqcolon");
J("\\colonminus", "\\coloneq");
J("\\coloncolonminus", "\\Coloneq");
J("\\minuscolon", "\\eqcolon");
J("\\minuscoloncolon", "\\Eqcolon");
J("\\coloncolonapprox", "\\Colonapprox");
J("\\coloncolonsim", "\\Colonsim");
J("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
J("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
J("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
J("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
J("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`âˆŒ}}");
J("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
J("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
J("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
J("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
J("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
J("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
J("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
J("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
J("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{â‰©}");
J("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{â‰¨}");
J("\\ngeqq", "\\html@mathml{\\@ngeqq}{â‰±}");
J("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{â‰±}");
J("\\nleqq", "\\html@mathml{\\@nleqq}{â‰°}");
J("\\nleqslant", "\\html@mathml{\\@nleqslant}{â‰°}");
J("\\nshortmid", "\\html@mathml{\\@nshortmid}{âˆ¤}");
J("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{âˆ¦}");
J("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{âŠˆ}");
J("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{âŠ‰}");
J("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{âŠŠ}");
J("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{â«‹}");
J("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{âŠ‹}");
J("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{â«Œ}");
J("\\imath", "\\html@mathml{\\@imath}{Ä±}");
J("\\jmath", "\\html@mathml{\\@jmath}{È·}");
J("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`âŸ¦}}");
J("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`âŸ§}}");
J("âŸ¦", "\\llbracket");
J("âŸ§", "\\rrbracket");
J("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`â¦ƒ}}");
J("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`â¦„}}");
J("â¦ƒ", "\\lBrace");
J("â¦„", "\\rBrace");
J("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`â¦µ}}");
J("â¦µ", "\\minuso");
J("\\darr", "\\downarrow");
J("\\dArr", "\\Downarrow");
J("\\Darr", "\\Downarrow");
J("\\lang", "\\langle");
J("\\rang", "\\rangle");
J("\\uarr", "\\uparrow");
J("\\uArr", "\\Uparrow");
J("\\Uarr", "\\Uparrow");
J("\\N", "\\mathbb{N}");
J("\\R", "\\mathbb{R}");
J("\\Z", "\\mathbb{Z}");
J("\\alef", "\\aleph");
J("\\alefsym", "\\aleph");
J("\\Alpha", "\\mathrm{A}");
J("\\Beta", "\\mathrm{B}");
J("\\bull", "\\bullet");
J("\\Chi", "\\mathrm{X}");
J("\\clubs", "\\clubsuit");
J("\\cnums", "\\mathbb{C}");
J("\\Complex", "\\mathbb{C}");
J("\\Dagger", "\\ddagger");
J("\\diamonds", "\\diamondsuit");
J("\\empty", "\\emptyset");
J("\\Epsilon", "\\mathrm{E}");
J("\\Eta", "\\mathrm{H}");
J("\\exist", "\\exists");
J("\\harr", "\\leftrightarrow");
J("\\hArr", "\\Leftrightarrow");
J("\\Harr", "\\Leftrightarrow");
J("\\hearts", "\\heartsuit");
J("\\image", "\\Im");
J("\\infin", "\\infty");
J("\\Iota", "\\mathrm{I}");
J("\\isin", "\\in");
J("\\Kappa", "\\mathrm{K}");
J("\\larr", "\\leftarrow");
J("\\lArr", "\\Leftarrow");
J("\\Larr", "\\Leftarrow");
J("\\lrarr", "\\leftrightarrow");
J("\\lrArr", "\\Leftrightarrow");
J("\\Lrarr", "\\Leftrightarrow");
J("\\Mu", "\\mathrm{M}");
J("\\natnums", "\\mathbb{N}");
J("\\Nu", "\\mathrm{N}");
J("\\Omicron", "\\mathrm{O}");
J("\\plusmn", "\\pm");
J("\\rarr", "\\rightarrow");
J("\\rArr", "\\Rightarrow");
J("\\Rarr", "\\Rightarrow");
J("\\real", "\\Re");
J("\\reals", "\\mathbb{R}");
J("\\Reals", "\\mathbb{R}");
J("\\Rho", "\\mathrm{P}");
J("\\sdot", "\\cdot");
J("\\sect", "\\S");
J("\\spades", "\\spadesuit");
J("\\sub", "\\subset");
J("\\sube", "\\subseteq");
J("\\supe", "\\supseteq");
J("\\Tau", "\\mathrm{T}");
J("\\thetasym", "\\vartheta");
J("\\weierp", "\\wp");
J("\\Zeta", "\\mathrm{Z}");
J("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
J("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
J("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
J("\\bra", "\\mathinner{\\langle{#1}|}");
J("\\ket", "\\mathinner{|{#1}\\rangle}");
J("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
J("\\Bra", "\\left\\langle#1\\right|");
J("\\Ket", "\\left|#1\\right\\rangle");
var qd = (r) => (e) => {
  var t = e.consumeArg().tokens, n = e.consumeArg().tokens, i = e.consumeArg().tokens, o = e.consumeArg().tokens, s = e.macros.get("|"), a = e.macros.get("\\|");
  e.macros.beginGroup();
  var l = (p) => (m) => {
    r && (m.macros.set("|", s), i.length && m.macros.set("\\|", a));
    var c = p;
    if (!p && i.length) {
      var h = m.future();
      h.text === "|" && (m.popToken(), c = !0);
    }
    return {
      tokens: c ? i : n,
      numArgs: 0
    };
  };
  e.macros.set("|", l(!1)), i.length && e.macros.set("\\|", l(!0));
  var u = e.consumeArg().tokens, d = e.expandTokens([
    ...o,
    ...u,
    ...t
    // reversed
  ]);
  return e.macros.endGroup(), {
    tokens: d.reverse(),
    numArgs: 0
  };
};
J("\\bra@ket", qd(!1));
J("\\bra@set", qd(!0));
J("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
J("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
J("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
J("\\angln", "{\\angl n}");
J("\\blue", "\\textcolor{##6495ed}{#1}");
J("\\orange", "\\textcolor{##ffa500}{#1}");
J("\\pink", "\\textcolor{##ff00af}{#1}");
J("\\red", "\\textcolor{##df0030}{#1}");
J("\\green", "\\textcolor{##28ae7b}{#1}");
J("\\gray", "\\textcolor{gray}{#1}");
J("\\purple", "\\textcolor{##9d38bd}{#1}");
J("\\blueA", "\\textcolor{##ccfaff}{#1}");
J("\\blueB", "\\textcolor{##80f6ff}{#1}");
J("\\blueC", "\\textcolor{##63d9ea}{#1}");
J("\\blueD", "\\textcolor{##11accd}{#1}");
J("\\blueE", "\\textcolor{##0c7f99}{#1}");
J("\\tealA", "\\textcolor{##94fff5}{#1}");
J("\\tealB", "\\textcolor{##26edd5}{#1}");
J("\\tealC", "\\textcolor{##01d1c1}{#1}");
J("\\tealD", "\\textcolor{##01a995}{#1}");
J("\\tealE", "\\textcolor{##208170}{#1}");
J("\\greenA", "\\textcolor{##b6ffb0}{#1}");
J("\\greenB", "\\textcolor{##8af281}{#1}");
J("\\greenC", "\\textcolor{##74cf70}{#1}");
J("\\greenD", "\\textcolor{##1fab54}{#1}");
J("\\greenE", "\\textcolor{##0d923f}{#1}");
J("\\goldA", "\\textcolor{##ffd0a9}{#1}");
J("\\goldB", "\\textcolor{##ffbb71}{#1}");
J("\\goldC", "\\textcolor{##ff9c39}{#1}");
J("\\goldD", "\\textcolor{##e07d10}{#1}");
J("\\goldE", "\\textcolor{##a75a05}{#1}");
J("\\redA", "\\textcolor{##fca9a9}{#1}");
J("\\redB", "\\textcolor{##ff8482}{#1}");
J("\\redC", "\\textcolor{##f9685d}{#1}");
J("\\redD", "\\textcolor{##e84d39}{#1}");
J("\\redE", "\\textcolor{##bc2612}{#1}");
J("\\maroonA", "\\textcolor{##ffbde0}{#1}");
J("\\maroonB", "\\textcolor{##ff92c6}{#1}");
J("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
J("\\maroonD", "\\textcolor{##ca337c}{#1}");
J("\\maroonE", "\\textcolor{##9e034e}{#1}");
J("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
J("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
J("\\purpleC", "\\textcolor{##aa87ff}{#1}");
J("\\purpleD", "\\textcolor{##7854ab}{#1}");
J("\\purpleE", "\\textcolor{##543b78}{#1}");
J("\\mintA", "\\textcolor{##f5f9e8}{#1}");
J("\\mintB", "\\textcolor{##edf2df}{#1}");
J("\\mintC", "\\textcolor{##e0e5cc}{#1}");
J("\\grayA", "\\textcolor{##f6f7f7}{#1}");
J("\\grayB", "\\textcolor{##f0f1f2}{#1}");
J("\\grayC", "\\textcolor{##e3e5e6}{#1}");
J("\\grayD", "\\textcolor{##d6d8da}{#1}");
J("\\grayE", "\\textcolor{##babec2}{#1}");
J("\\grayF", "\\textcolor{##888d93}{#1}");
J("\\grayG", "\\textcolor{##626569}{#1}");
J("\\grayH", "\\textcolor{##3b3e40}{#1}");
J("\\grayI", "\\textcolor{##21242c}{#1}");
J("\\kaBlue", "\\textcolor{##314453}{#1}");
J("\\kaGreen", "\\textcolor{##71B307}{#1}");
var Kd = {
  "^": !0,
  // Parser.js
  _: !0,
  // Parser.js
  "\\limits": !0,
  // Parser.js
  "\\nolimits": !0
  // Parser.js
};
class np {
  constructor(e, t, n) {
    this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = t, this.expansionCount = 0, this.feed(e), this.macros = new tp(rp, t.macros), this.mode = n, this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(e) {
    this.lexer = new ec(e, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    return this.future(), this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(e) {
    this.stack.push(e);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(e) {
    this.stack.push(...e);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(e) {
    var t, n, i;
    if (e) {
      if (this.consumeSpaces(), this.future().text !== "[")
        return null;
      t = this.popToken(), {
        tokens: i,
        end: n
      } = this.consumeArg(["]"]);
    } else
      ({
        tokens: i,
        start: t,
        end: n
      } = this.consumeArg());
    return this.pushToken(new Cr("EOF", n.loc)), this.pushTokens(i), t.range(n, "");
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var e = this.future();
      if (e.text === " ")
        this.stack.pop();
      else
        break;
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(e) {
    var t = [], n = e && e.length > 0;
    n || this.consumeSpaces();
    var i = this.future(), o, s = 0, a = 0;
    do {
      if (o = this.popToken(), t.push(o), o.text === "{")
        ++s;
      else if (o.text === "}") {
        if (--s, s === -1)
          throw new Re("Extra }", o);
      } else if (o.text === "EOF")
        throw new Re("Unexpected end of input in a macro argument, expected '" + (e && n ? e[a] : "}") + "'", o);
      if (e && n)
        if ((s === 0 || s === 1 && e[a] === "{") && o.text === e[a]) {
          if (++a, a === e.length) {
            t.splice(-a, a);
            break;
          }
        } else
          a = 0;
    } while (s !== 0 || n);
    return i.text === "{" && t[t.length - 1].text === "}" && (t.pop(), t.shift()), t.reverse(), {
      tokens: t,
      start: i,
      end: o
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(e, t) {
    if (t) {
      if (t.length !== e + 1)
        throw new Re("The length of delimiters doesn't match the number of args!");
      for (var n = t[0], i = 0; i < n.length; i++) {
        var o = this.popToken();
        if (n[i] !== o.text)
          throw new Re("Use of the macro doesn't match its definition", o);
      }
    }
    for (var s = [], a = 0; a < e; a++)
      s.push(this.consumeArg(t && t[a + 1]).tokens);
    return s;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(e) {
    if (this.expansionCount += e, this.expansionCount > this.settings.maxExpand)
      throw new Re("Too many expansions: infinite loop or need to increase maxExpand setting");
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(e) {
    var t = this.popToken(), n = t.text, i = t.noexpand ? null : this._getExpansion(n);
    if (i == null || e && i.unexpandable) {
      if (e && i == null && n[0] === "\\" && !this.isDefined(n))
        throw new Re("Undefined control sequence: " + n);
      return this.pushToken(t), !1;
    }
    this.countExpansion(1);
    var o = i.tokens, s = this.consumeArgs(i.numArgs, i.delimiters);
    if (i.numArgs) {
      o = o.slice();
      for (var a = o.length - 1; a >= 0; --a) {
        var l = o[a];
        if (l.text === "#") {
          if (a === 0)
            throw new Re("Incomplete placeholder at end of macro body", l);
          if (l = o[--a], l.text === "#")
            o.splice(a + 1, 1);
          else if (/^[1-9]$/.test(l.text))
            o.splice(a, 2, ...s[+l.text - 1]);
          else
            throw new Re("Not a valid argument number", l);
        }
      }
    }
    return this.pushTokens(o), o.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    return this.expandOnce(), this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; )
      if (this.expandOnce() === !1) {
        var e = this.stack.pop();
        return e.treatAsRelax && (e.text = "\\relax"), e;
      }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(e) {
    return this.macros.has(e) ? this.expandTokens([new Cr(e)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(e) {
    var t = [], n = this.stack.length;
    for (this.pushTokens(e); this.stack.length > n; )
      if (this.expandOnce(!0) === !1) {
        var i = this.stack.pop();
        i.treatAsRelax && (i.noexpand = !1, i.treatAsRelax = !1), t.push(i);
      }
    return this.countExpansion(t.length), t;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(e) {
    var t = this.expandMacro(e);
    return t && t.map((n) => n.text).join("");
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(e) {
    var t = this.macros.get(e);
    if (t == null)
      return t;
    if (e.length === 1) {
      var n = this.lexer.catcodes[e];
      if (n != null && n !== 13)
        return;
    }
    var i = typeof t == "function" ? t(this) : t;
    if (typeof i == "string") {
      var o = 0;
      if (i.indexOf("#") !== -1)
        for (var s = i.replace(/##/g, ""); s.indexOf("#" + (o + 1)) !== -1; )
          ++o;
      for (var a = new ec(i, this.settings), l = [], u = a.lex(); u.text !== "EOF"; )
        l.push(u), u = a.lex();
      l.reverse();
      var d = {
        tokens: l,
        numArgs: o
      };
      return d;
    }
    return i;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(e) {
    return this.macros.has(e) || ln.hasOwnProperty(e) || Lt.math.hasOwnProperty(e) || Lt.text.hasOwnProperty(e) || Kd.hasOwnProperty(e);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(e) {
    var t = this.macros.get(e);
    return t != null ? typeof t == "string" || typeof t == "function" || !t.unexpandable : ln.hasOwnProperty(e) && !ln[e].primitive;
  }
}
var nc = /^[â‚Šâ‚‹â‚Œâ‚â‚Žâ‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰â‚â‚‘â‚•áµ¢â±¼â‚–â‚—â‚˜â‚™â‚’â‚šáµ£â‚›â‚œáµ¤áµ¥â‚“áµ¦áµ§áµ¨áµ©áµª]/, eo = Object.freeze({
  "â‚Š": "+",
  "â‚‹": "-",
  "â‚Œ": "=",
  "â‚": "(",
  "â‚Ž": ")",
  "â‚€": "0",
  "â‚": "1",
  "â‚‚": "2",
  "â‚ƒ": "3",
  "â‚„": "4",
  "â‚…": "5",
  "â‚†": "6",
  "â‚‡": "7",
  "â‚ˆ": "8",
  "â‚‰": "9",
  "â‚": "a",
  "â‚‘": "e",
  "â‚•": "h",
  "áµ¢": "i",
  "â±¼": "j",
  "â‚–": "k",
  "â‚—": "l",
  "â‚˜": "m",
  "â‚™": "n",
  "â‚’": "o",
  "â‚š": "p",
  "áµ£": "r",
  "â‚›": "s",
  "â‚œ": "t",
  "áµ¤": "u",
  "áµ¥": "v",
  "â‚“": "x",
  "áµ¦": "Î²",
  "áµ§": "Î³",
  "áµ¨": "Ï",
  "áµ©": "Ï•",
  "áµª": "Ï‡",
  "âº": "+",
  "â»": "-",
  "â¼": "=",
  "â½": "(",
  "â¾": ")",
  "â°": "0",
  "Â¹": "1",
  "Â²": "2",
  "Â³": "3",
  "â´": "4",
  "âµ": "5",
  "â¶": "6",
  "â·": "7",
  "â¸": "8",
  "â¹": "9",
  "á´¬": "A",
  "á´®": "B",
  "á´°": "D",
  "á´±": "E",
  "á´³": "G",
  "á´´": "H",
  "á´µ": "I",
  "á´¶": "J",
  "á´·": "K",
  "á´¸": "L",
  "á´¹": "M",
  "á´º": "N",
  "á´¼": "O",
  "á´¾": "P",
  "á´¿": "R",
  "áµ€": "T",
  "áµ": "U",
  "â±½": "V",
  "áµ‚": "W",
  "áµƒ": "a",
  "áµ‡": "b",
  "á¶œ": "c",
  "áµˆ": "d",
  "áµ‰": "e",
  "á¶ ": "f",
  "áµ": "g",
  Ê°: "h",
  "â±": "i",
  Ê²: "j",
  "áµ": "k",
  Ë¡: "l",
  "áµ": "m",
  â¿: "n",
  "áµ’": "o",
  "áµ–": "p",
  Ê³: "r",
  Ë¢: "s",
  "áµ—": "t",
  "áµ˜": "u",
  "áµ›": "v",
  Ê·: "w",
  Ë£: "x",
  Ê¸: "y",
  "á¶»": "z",
  "áµ": "Î²",
  "áµž": "Î³",
  "áµŸ": "Î´",
  "áµ ": "Ï•",
  "áµ¡": "Ï‡",
  "á¶¿": "Î¸"
}), la = {
  "Ì": {
    text: "\\'",
    math: "\\acute"
  },
  "Ì€": {
    text: "\\`",
    math: "\\grave"
  },
  "Ìˆ": {
    text: '\\"',
    math: "\\ddot"
  },
  "Ìƒ": {
    text: "\\~",
    math: "\\tilde"
  },
  "Ì„": {
    text: "\\=",
    math: "\\bar"
  },
  "Ì†": {
    text: "\\u",
    math: "\\breve"
  },
  "ÌŒ": {
    text: "\\v",
    math: "\\check"
  },
  "Ì‚": {
    text: "\\^",
    math: "\\hat"
  },
  "Ì‡": {
    text: "\\.",
    math: "\\dot"
  },
  "ÌŠ": {
    text: "\\r",
    math: "\\mathring"
  },
  "Ì‹": {
    text: "\\H"
  },
  "Ì§": {
    text: "\\c"
  }
}, ic = {
  Ã¡: "aÌ",
  Ã : "aÌ€",
  Ã¤: "aÌˆ",
  ÇŸ: "aÌˆÌ„",
  Ã£: "aÌƒ",
  Ä: "aÌ„",
  Äƒ: "aÌ†",
  áº¯: "aÌ†Ì",
  áº±: "aÌ†Ì€",
  áºµ: "aÌ†Ìƒ",
  ÇŽ: "aÌŒ",
  Ã¢: "aÌ‚",
  áº¥: "aÌ‚Ì",
  áº§: "aÌ‚Ì€",
  áº«: "aÌ‚Ìƒ",
  È§: "aÌ‡",
  Ç¡: "aÌ‡Ì„",
  Ã¥: "aÌŠ",
  Ç»: "aÌŠÌ",
  á¸ƒ: "bÌ‡",
  Ä‡: "cÌ",
  á¸‰: "cÌ§Ì",
  Ä: "cÌŒ",
  Ä‰: "cÌ‚",
  Ä‹: "cÌ‡",
  Ã§: "cÌ§",
  Ä: "dÌŒ",
  á¸‹: "dÌ‡",
  á¸‘: "dÌ§",
  Ã©: "eÌ",
  Ã¨: "eÌ€",
  Ã«: "eÌˆ",
  áº½: "eÌƒ",
  Ä“: "eÌ„",
  á¸—: "eÌ„Ì",
  á¸•: "eÌ„Ì€",
  Ä•: "eÌ†",
  á¸: "eÌ§Ì†",
  Ä›: "eÌŒ",
  Ãª: "eÌ‚",
  áº¿: "eÌ‚Ì",
  á»: "eÌ‚Ì€",
  á»…: "eÌ‚Ìƒ",
  Ä—: "eÌ‡",
  È©: "eÌ§",
  á¸Ÿ: "fÌ‡",
  Çµ: "gÌ",
  á¸¡: "gÌ„",
  ÄŸ: "gÌ†",
  Ç§: "gÌŒ",
  Ä: "gÌ‚",
  Ä¡: "gÌ‡",
  Ä£: "gÌ§",
  á¸§: "hÌˆ",
  ÈŸ: "hÌŒ",
  Ä¥: "hÌ‚",
  á¸£: "hÌ‡",
  á¸©: "hÌ§",
  Ã­: "iÌ",
  Ã¬: "iÌ€",
  Ã¯: "iÌˆ",
  á¸¯: "iÌˆÌ",
  Ä©: "iÌƒ",
  Ä«: "iÌ„",
  Ä­: "iÌ†",
  Ç: "iÌŒ",
  Ã®: "iÌ‚",
  Ç°: "jÌŒ",
  Äµ: "jÌ‚",
  á¸±: "kÌ",
  Ç©: "kÌŒ",
  Ä·: "kÌ§",
  Äº: "lÌ",
  Ä¾: "lÌŒ",
  Ä¼: "lÌ§",
  á¸¿: "mÌ",
  á¹: "mÌ‡",
  Å„: "nÌ",
  Ç¹: "nÌ€",
  Ã±: "nÌƒ",
  Åˆ: "nÌŒ",
  á¹…: "nÌ‡",
  Å†: "nÌ§",
  Ã³: "oÌ",
  Ã²: "oÌ€",
  Ã¶: "oÌˆ",
  È«: "oÌˆÌ„",
  Ãµ: "oÌƒ",
  á¹: "oÌƒÌ",
  á¹: "oÌƒÌˆ",
  È­: "oÌƒÌ„",
  Å: "oÌ„",
  á¹“: "oÌ„Ì",
  á¹‘: "oÌ„Ì€",
  Å: "oÌ†",
  Ç’: "oÌŒ",
  Ã´: "oÌ‚",
  á»‘: "oÌ‚Ì",
  á»“: "oÌ‚Ì€",
  á»—: "oÌ‚Ìƒ",
  È¯: "oÌ‡",
  È±: "oÌ‡Ì„",
  Å‘: "oÌ‹",
  á¹•: "pÌ",
  á¹—: "pÌ‡",
  Å•: "rÌ",
  Å™: "rÌŒ",
  á¹™: "rÌ‡",
  Å—: "rÌ§",
  Å›: "sÌ",
  á¹¥: "sÌÌ‡",
  Å¡: "sÌŒ",
  á¹§: "sÌŒÌ‡",
  Å: "sÌ‚",
  á¹¡: "sÌ‡",
  ÅŸ: "sÌ§",
  áº—: "tÌˆ",
  Å¥: "tÌŒ",
  á¹«: "tÌ‡",
  Å£: "tÌ§",
  Ãº: "uÌ",
  Ã¹: "uÌ€",
  Ã¼: "uÌˆ",
  Ç˜: "uÌˆÌ",
  Çœ: "uÌˆÌ€",
  Ç–: "uÌˆÌ„",
  Çš: "uÌˆÌŒ",
  Å©: "uÌƒ",
  á¹¹: "uÌƒÌ",
  Å«: "uÌ„",
  á¹»: "uÌ„Ìˆ",
  Å­: "uÌ†",
  Ç”: "uÌŒ",
  Ã»: "uÌ‚",
  Å¯: "uÌŠ",
  Å±: "uÌ‹",
  á¹½: "vÌƒ",
  áºƒ: "wÌ",
  áº: "wÌ€",
  áº…: "wÌˆ",
  Åµ: "wÌ‚",
  áº‡: "wÌ‡",
  áº˜: "wÌŠ",
  áº: "xÌˆ",
  áº‹: "xÌ‡",
  Ã½: "yÌ",
  á»³: "yÌ€",
  Ã¿: "yÌˆ",
  á»¹: "yÌƒ",
  È³: "yÌ„",
  Å·: "yÌ‚",
  áº: "yÌ‡",
  áº™: "yÌŠ",
  Åº: "zÌ",
  Å¾: "zÌŒ",
  áº‘: "zÌ‚",
  Å¼: "zÌ‡",
  Ã: "AÌ",
  Ã€: "AÌ€",
  Ã„: "AÌˆ",
  Çž: "AÌˆÌ„",
  Ãƒ: "AÌƒ",
  Ä€: "AÌ„",
  Ä‚: "AÌ†",
  áº®: "AÌ†Ì",
  áº°: "AÌ†Ì€",
  áº´: "AÌ†Ìƒ",
  Ç: "AÌŒ",
  Ã‚: "AÌ‚",
  áº¤: "AÌ‚Ì",
  áº¦: "AÌ‚Ì€",
  áºª: "AÌ‚Ìƒ",
  È¦: "AÌ‡",
  Ç : "AÌ‡Ì„",
  Ã…: "AÌŠ",
  Çº: "AÌŠÌ",
  á¸‚: "BÌ‡",
  Ä†: "CÌ",
  á¸ˆ: "CÌ§Ì",
  ÄŒ: "CÌŒ",
  Äˆ: "CÌ‚",
  ÄŠ: "CÌ‡",
  Ã‡: "CÌ§",
  ÄŽ: "DÌŒ",
  á¸Š: "DÌ‡",
  á¸: "DÌ§",
  Ã‰: "EÌ",
  Ãˆ: "EÌ€",
  Ã‹: "EÌˆ",
  áº¼: "EÌƒ",
  Ä’: "EÌ„",
  á¸–: "EÌ„Ì",
  á¸”: "EÌ„Ì€",
  Ä”: "EÌ†",
  á¸œ: "EÌ§Ì†",
  Äš: "EÌŒ",
  ÃŠ: "EÌ‚",
  áº¾: "EÌ‚Ì",
  á»€: "EÌ‚Ì€",
  á»„: "EÌ‚Ìƒ",
  Ä–: "EÌ‡",
  È¨: "EÌ§",
  á¸ž: "FÌ‡",
  Ç´: "GÌ",
  á¸ : "GÌ„",
  Äž: "GÌ†",
  Ç¦: "GÌŒ",
  Äœ: "GÌ‚",
  Ä : "GÌ‡",
  Ä¢: "GÌ§",
  á¸¦: "HÌˆ",
  Èž: "HÌŒ",
  Ä¤: "HÌ‚",
  á¸¢: "HÌ‡",
  á¸¨: "HÌ§",
  Ã: "IÌ",
  ÃŒ: "IÌ€",
  Ã: "IÌˆ",
  á¸®: "IÌˆÌ",
  Ä¨: "IÌƒ",
  Äª: "IÌ„",
  Ä¬: "IÌ†",
  Ç: "IÌŒ",
  ÃŽ: "IÌ‚",
  Ä°: "IÌ‡",
  Ä´: "JÌ‚",
  á¸°: "KÌ",
  Ç¨: "KÌŒ",
  Ä¶: "KÌ§",
  Ä¹: "LÌ",
  Ä½: "LÌŒ",
  Ä»: "LÌ§",
  á¸¾: "MÌ",
  á¹€: "MÌ‡",
  Åƒ: "NÌ",
  Ç¸: "NÌ€",
  Ã‘: "NÌƒ",
  Å‡: "NÌŒ",
  á¹„: "NÌ‡",
  Å…: "NÌ§",
  Ã“: "OÌ",
  Ã’: "OÌ€",
  Ã–: "OÌˆ",
  Èª: "OÌˆÌ„",
  Ã•: "OÌƒ",
  á¹Œ: "OÌƒÌ",
  á¹Ž: "OÌƒÌˆ",
  È¬: "OÌƒÌ„",
  ÅŒ: "OÌ„",
  á¹’: "OÌ„Ì",
  á¹: "OÌ„Ì€",
  ÅŽ: "OÌ†",
  Ç‘: "OÌŒ",
  Ã”: "OÌ‚",
  á»: "OÌ‚Ì",
  á»’: "OÌ‚Ì€",
  á»–: "OÌ‚Ìƒ",
  È®: "OÌ‡",
  È°: "OÌ‡Ì„",
  Å: "OÌ‹",
  á¹”: "PÌ",
  á¹–: "PÌ‡",
  Å”: "RÌ",
  Å˜: "RÌŒ",
  á¹˜: "RÌ‡",
  Å–: "RÌ§",
  Åš: "SÌ",
  á¹¤: "SÌÌ‡",
  Å : "SÌŒ",
  á¹¦: "SÌŒÌ‡",
  Åœ: "SÌ‚",
  á¹ : "SÌ‡",
  Åž: "SÌ§",
  Å¤: "TÌŒ",
  á¹ª: "TÌ‡",
  Å¢: "TÌ§",
  Ãš: "UÌ",
  Ã™: "UÌ€",
  Ãœ: "UÌˆ",
  Ç—: "UÌˆÌ",
  Ç›: "UÌˆÌ€",
  Ç•: "UÌˆÌ„",
  Ç™: "UÌˆÌŒ",
  Å¨: "UÌƒ",
  á¹¸: "UÌƒÌ",
  Åª: "UÌ„",
  á¹º: "UÌ„Ìˆ",
  Å¬: "UÌ†",
  Ç“: "UÌŒ",
  Ã›: "UÌ‚",
  Å®: "UÌŠ",
  Å°: "UÌ‹",
  á¹¼: "VÌƒ",
  áº‚: "WÌ",
  áº€: "WÌ€",
  áº„: "WÌˆ",
  Å´: "WÌ‚",
  áº†: "WÌ‡",
  áºŒ: "XÌˆ",
  áºŠ: "XÌ‡",
  Ã: "YÌ",
  á»²: "YÌ€",
  Å¸: "YÌˆ",
  á»¸: "YÌƒ",
  È²: "YÌ„",
  Å¶: "YÌ‚",
  áºŽ: "YÌ‡",
  Å¹: "ZÌ",
  Å½: "ZÌŒ",
  áº: "ZÌ‚",
  Å»: "ZÌ‡",
  Î¬: "Î±Ì",
  á½°: "Î±Ì€",
  á¾±: "Î±Ì„",
  á¾°: "Î±Ì†",
  Î­: "ÎµÌ",
  á½²: "ÎµÌ€",
  Î®: "Î·Ì",
  á½´: "Î·Ì€",
  Î¯: "Î¹Ì",
  á½¶: "Î¹Ì€",
  ÏŠ: "Î¹Ìˆ",
  Î: "Î¹ÌˆÌ",
  á¿’: "Î¹ÌˆÌ€",
  á¿‘: "Î¹Ì„",
  á¿: "Î¹Ì†",
  ÏŒ: "Î¿Ì",
  á½¸: "Î¿Ì€",
  Ï: "Ï…Ì",
  á½º: "Ï…Ì€",
  Ï‹: "Ï…Ìˆ",
  Î°: "Ï…ÌˆÌ",
  á¿¢: "Ï…ÌˆÌ€",
  á¿¡: "Ï…Ì„",
  á¿ : "Ï…Ì†",
  ÏŽ: "Ï‰Ì",
  á½¼: "Ï‰Ì€",
  ÎŽ: "Î¥Ì",
  á¿ª: "Î¥Ì€",
  Î«: "Î¥Ìˆ",
  á¿©: "Î¥Ì„",
  á¿¨: "Î¥Ì†",
  Î: "Î©Ì",
  á¿º: "Î©Ì€"
};
class Lo {
  constructor(e, t) {
    this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new np(e, t, this.mode), this.settings = t, this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(e, t) {
    if (t === void 0 && (t = !0), this.fetch().text !== e)
      throw new Re("Expected '" + e + "', got '" + this.fetch().text + "'", this.fetch());
    t && this.consume();
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e, this.gullet.switchMode(e);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
    try {
      var e = this.parseExpression(!1);
      return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), e;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(e) {
    var t = this.nextToken;
    this.consume(), this.gullet.pushToken(new Cr("}")), this.gullet.pushTokens(e);
    var n = this.parseExpression(!1);
    return this.expect("}"), this.nextToken = t, n;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(e, t) {
    for (var n = []; ; ) {
      this.mode === "math" && this.consumeSpaces();
      var i = this.fetch();
      if (Lo.endOfExpression.indexOf(i.text) !== -1 || t && i.text === t || e && ln[i.text] && ln[i.text].infix)
        break;
      var o = this.parseAtom(t);
      if (o) {
        if (o.type === "internal")
          continue;
      } else break;
      n.push(o);
    }
    return this.mode === "text" && this.formLigatures(n), this.handleInfixNodes(n);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(e) {
    for (var t = -1, n, i = 0; i < e.length; i++)
      if (e[i].type === "infix") {
        if (t !== -1)
          throw new Re("only one infix operator per group", e[i].token);
        t = i, n = e[i].replaceWith;
      }
    if (t !== -1 && n) {
      var o, s, a = e.slice(0, t), l = e.slice(t + 1);
      a.length === 1 && a[0].type === "ordgroup" ? o = a[0] : o = {
        type: "ordgroup",
        mode: this.mode,
        body: a
      }, l.length === 1 && l[0].type === "ordgroup" ? s = l[0] : s = {
        type: "ordgroup",
        mode: this.mode,
        body: l
      };
      var u;
      return n === "\\\\abovefrac" ? u = this.callFunction(n, [o, e[t], s], []) : u = this.callFunction(n, [o, s], []), [u];
    } else
      return e;
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(e) {
    var t = this.fetch(), n = t.text;
    this.consume(), this.consumeSpaces();
    var i = this.parseGroup(e);
    if (!i)
      throw new Re("Expected group after '" + n + "'", t);
    return i;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(e) {
    for (var t = [], n = 0; n < e.length; n++)
      t.push({
        type: "textord",
        mode: "text",
        text: e[n]
      });
    var i = {
      type: "text",
      mode: this.mode,
      body: t
    }, o = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [i]
    };
    return o;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(e) {
    var t = this.parseGroup("atom", e);
    if (this.mode === "text")
      return t;
    for (var n, i; ; ) {
      this.consumeSpaces();
      var o = this.fetch();
      if (o.text === "\\limits" || o.text === "\\nolimits") {
        if (t && t.type === "op") {
          var s = o.text === "\\limits";
          t.limits = s, t.alwaysHandleSupSub = !0;
        } else if (t && t.type === "operatorname")
          t.alwaysHandleSupSub && (t.limits = o.text === "\\limits");
        else
          throw new Re("Limit controls must follow a math operator", o);
        this.consume();
      } else if (o.text === "^") {
        if (n)
          throw new Re("Double superscript", o);
        n = this.handleSupSubscript("superscript");
      } else if (o.text === "_") {
        if (i)
          throw new Re("Double subscript", o);
        i = this.handleSupSubscript("subscript");
      } else if (o.text === "'") {
        if (n)
          throw new Re("Double superscript", o);
        var a = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        }, l = [a];
        for (this.consume(); this.fetch().text === "'"; )
          l.push(a), this.consume();
        this.fetch().text === "^" && l.push(this.handleSupSubscript("superscript")), n = {
          type: "ordgroup",
          mode: this.mode,
          body: l
        };
      } else if (eo[o.text]) {
        var u = nc.test(o.text), d = [];
        for (d.push(new Cr(eo[o.text])), this.consume(); ; ) {
          var p = this.fetch().text;
          if (!eo[p] || nc.test(p) !== u)
            break;
          d.unshift(new Cr(eo[p])), this.consume();
        }
        var m = this.subparse(d);
        u ? i = {
          type: "ordgroup",
          mode: "math",
          body: m
        } : n = {
          type: "ordgroup",
          mode: "math",
          body: m
        };
      } else
        break;
    }
    return n || i ? {
      type: "supsub",
      mode: this.mode,
      base: t,
      sup: n,
      sub: i
    } : t;
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(e, t) {
    var n = this.fetch(), i = n.text, o = ln[i];
    if (!o)
      return null;
    if (this.consume(), t && t !== "atom" && !o.allowedInArgument)
      throw new Re("Got function '" + i + "' with no arguments" + (t ? " as " + t : ""), n);
    if (this.mode === "text" && !o.allowedInText)
      throw new Re("Can't use function '" + i + "' in text mode", n);
    if (this.mode === "math" && o.allowedInMath === !1)
      throw new Re("Can't use function '" + i + "' in math mode", n);
    var {
      args: s,
      optArgs: a
    } = this.parseArguments(i, o);
    return this.callFunction(i, s, a, n, e);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(e, t, n, i, o) {
    var s = {
      funcName: e,
      parser: this,
      token: i,
      breakOnTokenText: o
    }, a = ln[e];
    if (a && a.handler)
      return a.handler(s, t, n);
    throw new Re("No function handler for " + e);
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(e, t) {
    var n = t.numArgs + t.numOptionalArgs;
    if (n === 0)
      return {
        args: [],
        optArgs: []
      };
    for (var i = [], o = [], s = 0; s < n; s++) {
      var a = t.argTypes && t.argTypes[s], l = s < t.numOptionalArgs;
      (t.primitive && a == null || // \sqrt expands into primitive if optional argument doesn't exist
      t.type === "sqrt" && s === 1 && o[0] == null) && (a = "primitive");
      var u = this.parseGroupOfType("argument to '" + e + "'", a, l);
      if (l)
        o.push(u);
      else if (u != null)
        i.push(u);
      else
        throw new Re("Null argument, please report this as a bug");
    }
    return {
      args: i,
      optArgs: o
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(e, t, n) {
    switch (t) {
      case "color":
        return this.parseColorGroup(n);
      case "size":
        return this.parseSizeGroup(n);
      case "url":
        return this.parseUrlGroup(n);
      case "math":
      case "text":
        return this.parseArgumentGroup(n, t);
      case "hbox": {
        var i = this.parseArgumentGroup(n, "text");
        return i != null ? {
          type: "styling",
          mode: i.mode,
          body: [i],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var o = this.parseStringGroup("raw", n);
        return o != null ? {
          type: "raw",
          mode: "text",
          string: o.text
        } : null;
      }
      case "primitive": {
        if (n)
          throw new Re("A primitive argument cannot be optional");
        var s = this.parseGroup(e);
        if (s == null)
          throw new Re("Expected group as " + e, this.fetch());
        return s;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(n);
      default:
        throw new Re("Unknown group type as " + e, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    for (; this.fetch().text === " "; )
      this.consume();
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(e, t) {
    var n = this.gullet.scanArgument(t);
    if (n == null)
      return null;
    for (var i = "", o; (o = this.fetch()).text !== "EOF"; )
      i += o.text, this.consume();
    return this.consume(), n.text = i, n;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(e, t) {
    for (var n = this.fetch(), i = n, o = "", s; (s = this.fetch()).text !== "EOF" && e.test(o + s.text); )
      i = s, o += i.text, this.consume();
    if (o === "")
      throw new Re("Invalid " + t + ": '" + n.text + "'", n);
    return n.range(i, o);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(e) {
    var t = this.parseStringGroup("color", e);
    if (t == null)
      return null;
    var n = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(t.text);
    if (!n)
      throw new Re("Invalid color: '" + t.text + "'", t);
    var i = n[0];
    return /^[0-9a-f]{6}$/i.test(i) && (i = "#" + i), {
      type: "color-token",
      mode: this.mode,
      color: i
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(e) {
    var t, n = !1;
    if (this.gullet.consumeSpaces(), !e && this.gullet.future().text !== "{" ? t = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : t = this.parseStringGroup("size", e), !t)
      return null;
    !e && t.text.length === 0 && (t.text = "0pt", n = !0);
    var i = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(t.text);
    if (!i)
      throw new Re("Invalid size: '" + t.text + "'", t);
    var o = {
      number: +(i[1] + i[2]),
      // sign + magnitude, cast to number
      unit: i[3]
    };
    if (!ed(o))
      throw new Re("Invalid unit: '" + o.unit + "'", t);
    return {
      type: "size",
      mode: this.mode,
      value: o,
      isBlank: n
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(e) {
    this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
    var t = this.parseStringGroup("url", e);
    if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), t == null)
      return null;
    var n = t.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url: n
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(e, t) {
    var n = this.gullet.scanArgument(e);
    if (n == null)
      return null;
    var i = this.mode;
    t && this.switchMode(t), this.gullet.beginGroup();
    var o = this.parseExpression(!1, "EOF");
    this.expect("EOF"), this.gullet.endGroup();
    var s = {
      type: "ordgroup",
      mode: this.mode,
      loc: n.loc,
      body: o
    };
    return t && this.switchMode(i), s;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(e, t) {
    var n = this.fetch(), i = n.text, o;
    if (i === "{" || i === "\\begingroup") {
      this.consume();
      var s = i === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var a = this.parseExpression(!1, s), l = this.fetch();
      this.expect(s), this.gullet.endGroup(), o = {
        type: "ordgroup",
        mode: this.mode,
        loc: pr.range(n, l),
        body: a,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: i === "\\begingroup" || void 0
      };
    } else if (o = this.parseFunction(t, e) || this.parseSymbol(), o == null && i[0] === "\\" && !Kd.hasOwnProperty(i)) {
      if (this.settings.throwOnError)
        throw new Re("Undefined control sequence: " + i, n);
      o = this.formatUnsupportedCmd(i), this.consume();
    }
    return o;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(e) {
    for (var t = e.length - 1, n = 0; n < t; ++n) {
      var i = e[n], o = i.text;
      o === "-" && e[n + 1].text === "-" && (n + 1 < t && e[n + 2].text === "-" ? (e.splice(n, 3, {
        type: "textord",
        mode: "text",
        loc: pr.range(i, e[n + 2]),
        text: "---"
      }), t -= 2) : (e.splice(n, 2, {
        type: "textord",
        mode: "text",
        loc: pr.range(i, e[n + 1]),
        text: "--"
      }), t -= 1)), (o === "'" || o === "`") && e[n + 1].text === o && (e.splice(n, 2, {
        type: "textord",
        mode: "text",
        loc: pr.range(i, e[n + 1]),
        text: o + o
      }), t -= 1);
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var e = this.fetch(), t = e.text;
    if (/^\\verb[^a-zA-Z]/.test(t)) {
      this.consume();
      var n = t.slice(5), i = n.charAt(0) === "*";
      if (i && (n = n.slice(1)), n.length < 2 || n.charAt(0) !== n.slice(-1))
        throw new Re(`\\verb assertion failed --
                    please report what input caused this bug`);
      return n = n.slice(1, -1), {
        type: "verb",
        mode: "text",
        body: n,
        star: i
      };
    }
    ic.hasOwnProperty(t[0]) && !Lt[this.mode][t[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + t[0] + '" used in math mode', e), t = ic[t[0]] + t.slice(1));
    var o = Qg.exec(t);
    o && (t = t.substring(0, o.index), t === "i" ? t = "Ä±" : t === "j" && (t = "È·"));
    var s;
    if (Lt[this.mode][t]) {
      this.settings.strict && this.mode === "math" && Ja.indexOf(t) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + t[0] + '" used in math mode', e);
      var a = Lt[this.mode][t].group, l = pr.range(e), u;
      if (Um.hasOwnProperty(a)) {
        var d = a;
        u = {
          type: "atom",
          mode: this.mode,
          family: d,
          loc: l,
          text: t
        };
      } else
        u = {
          type: a,
          mode: this.mode,
          loc: l,
          text: t
        };
      s = u;
    } else if (t.charCodeAt(0) >= 128)
      this.settings.strict && (Qu(t.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + t[0] + '" used in math mode', e) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + t[0] + '"' + (" (" + t.charCodeAt(0) + ")"), e)), s = {
        type: "textord",
        mode: "text",
        loc: pr.range(e),
        text: t
      };
    else
      return null;
    if (this.consume(), o)
      for (var p = 0; p < o[0].length; p++) {
        var m = o[0][p];
        if (!la[m])
          throw new Re("Unknown accent ' " + m + "'", e);
        var c = la[m][this.mode] || la[m].text;
        if (!c)
          throw new Re("Accent " + m + " unsupported in " + this.mode + " mode", e);
        s = {
          type: "accent",
          mode: this.mode,
          loc: pr.range(e),
          label: c,
          isStretchy: !1,
          isShifty: !0,
          // $FlowFixMe
          base: s
        };
      }
    return s;
  }
}
Lo.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var qs = function(e, t) {
  if (!(typeof e == "string" || e instanceof String))
    throw new TypeError("KaTeX can only parse string typed expression");
  var n = new Lo(e, t);
  delete n.gullet.macros.current["\\df@tag"];
  var i = n.parse();
  if (delete n.gullet.macros.current["\\current@color"], delete n.gullet.macros.current["\\color"], n.gullet.macros.get("\\df@tag")) {
    if (!t.displayMode)
      throw new Re("\\tag works only in display equations");
    i = [{
      type: "tag",
      mode: "text",
      body: i,
      tag: n.subparse([new Cr("\\df@tag")])
    }];
  }
  return i;
}, Ud = function(e, t, n) {
  t.textContent = "";
  var i = Ks(e, n).toNode();
  t.appendChild(i);
};
typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), Ud = function() {
  throw new Re("KaTeX doesn't work in quirks mode.");
});
var ip = function(e, t) {
  var n = Ks(e, t).toMarkup();
  return n;
}, op = function(e, t) {
  var n = new Ts(t);
  return qs(e, n);
}, Yd = function(e, t, n) {
  if (n.throwOnError || !(e instanceof Re))
    throw e;
  var i = ge.makeSpan(["katex-error"], [new br(t)]);
  return i.setAttribute("title", e.toString()), i.setAttribute("style", "color:" + n.errorColor), i;
}, Ks = function(e, t) {
  var n = new Ts(t);
  try {
    var i = qs(e, n);
    return mg(i, e, n);
  } catch (o) {
    return Yd(o, e, n);
  }
}, ap = function(e, t) {
  var n = new Ts(t);
  try {
    var i = qs(e, n);
    return gg(i, e, n);
  } catch (o) {
    return Yd(o, e, n);
  }
}, Wd = {
  /**
   * Current KaTeX version
   */
  version: "0.16.11",
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render: Ud,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString: ip,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError: Re,
  /**
   * The shema of Settings
   */
  SETTINGS_SCHEMA: fo,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: op,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: Ks,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: ap,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: Fm,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: _,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: ze,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: J,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: {
    Span: Fi,
    Anchor: Os,
    SymbolNode: br,
    SvgNode: Vr,
    PathNode: dn,
    LineNode: Xa
  }
};
const sp = hr.lazy(() => import("./EquationComponent-wkZLJdJf.js"));
function oc(r) {
  let e = r.getAttribute("data-lexical-equation");
  const t = r.getAttribute("data-lexical-inline") === "true";
  return e = atob(e || ""), e ? { node: Us(e, t) } : null;
}
class ti extends mn {
  constructor(t, n, i) {
    super(i);
    Ye(this, "__equation");
    Ye(this, "__inline");
    this.__equation = t, this.__inline = n ?? !1;
  }
  static getType() {
    return "equation";
  }
  static clone(t) {
    return new ti(t.__equation, t.__inline, t.__key);
  }
  static importJSON(t) {
    return Us(
      t.equation,
      t.inline
    );
  }
  exportJSON() {
    return {
      equation: this.getEquation(),
      inline: this.__inline,
      type: "equation",
      version: 1
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createDOM(t) {
    const n = document.createElement(this.__inline ? "span" : "div");
    return n.className = "editor-equation", n;
  }
  exportDOM() {
    const t = document.createElement(this.__inline ? "span" : "div"), n = btoa(this.__equation);
    return t.setAttribute("data-lexical-equation", n), t.setAttribute("data-lexical-inline", `${this.__inline}`), Wd.render(this.__equation, t, {
      displayMode: !this.__inline,
      // true === block display //
      errorColor: "#cc0000",
      output: "html",
      strict: "warn",
      throwOnError: !1,
      trust: !1
    }), { element: t };
  }
  static importDOM() {
    return {
      div: (t) => t.hasAttribute("data-lexical-equation") ? {
        conversion: oc,
        priority: 2
      } : null,
      span: (t) => t.hasAttribute("data-lexical-equation") ? {
        conversion: oc,
        priority: 1
      } : null
    };
  }
  updateDOM(t) {
    return this.__inline !== t.__inline;
  }
  getTextContent() {
    return this.__equation;
  }
  getEquation() {
    return this.__equation;
  }
  setEquation(t) {
    const n = this.getWritable();
    n.__equation = t;
  }
  decorate() {
    return /* @__PURE__ */ L.jsx(An, { fallback: null, children: /* @__PURE__ */ L.jsx(
      sp,
      {
        equation: this.__equation,
        inline: this.__inline,
        nodeKey: this.__key
      }
    ) });
  }
}
function Us(r = "", e = !1) {
  const t = new ti(r, e);
  return Oi(t);
}
function A2(r) {
  return r instanceof ti;
}
const lp = hr.lazy(() => import("./ExcalidrawComponent-BoDgE8dX.js"));
function cp(r) {
  const e = r.getAttribute("data-lexical-excalidraw-json");
  if (e) {
    const t = Gd();
    return t.__data = e, {
      node: t
    };
  }
  return null;
}
class Sn extends mn {
  constructor(t = "[]", n = "inherit", i = "inherit", o) {
    super(o);
    Ye(this, "__data");
    Ye(this, "__width");
    Ye(this, "__height");
    this.__data = t, this.__width = n, this.__height = i;
  }
  static getType() {
    return "excalidraw";
  }
  static clone(t) {
    return new Sn(t.__data, t.__width, t.__height, t.__key);
  }
  static importJSON(t) {
    return new Sn(t.data, t.width, t.height);
  }
  exportJSON() {
    return {
      data: this.__data,
      height: this.__height,
      type: "excalidraw",
      version: 1,
      width: this.__width
    };
  }
  // View
  createDOM(t) {
    const n = document.createElement("span"), o = t.theme.image;
    return n.style.width = this.__width === "inherit" ? "inherit" : `${this.__width}px`, n.style.height = this.__height === "inherit" ? "inherit" : `${this.__height}px`, o !== void 0 && (n.className = o), n;
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return {
      span: (t) => t.hasAttribute("data-lexical-excalidraw-json") ? {
        conversion: cp,
        priority: 1
      } : null
    };
  }
  exportDOM(t) {
    const n = document.createElement("span");
    n.style.display = "inline-block";
    const i = t.getElementByKey(this.getKey());
    if (i !== null) {
      const o = i.querySelector("svg");
      o !== null && (n.innerHTML = o.outerHTML);
    }
    return n.style.width = this.__width === "inherit" ? "inherit" : `${this.__width}px`, n.style.height = this.__height === "inherit" ? "inherit" : `${this.__height}px`, n.setAttribute("data-lexical-excalidraw-json", this.__data), { element: n };
  }
  setData(t) {
    const n = this.getWritable();
    n.__data = t;
  }
  setWidth(t) {
    const n = this.getWritable();
    n.__width = t;
  }
  setHeight(t) {
    const n = this.getWritable();
    n.__height = t;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  decorate(t, n) {
    return /* @__PURE__ */ L.jsx(An, { fallback: null, children: /* @__PURE__ */ L.jsx(lp, { nodeKey: this.getKey(), data: this.__data }) });
  }
}
function Gd() {
  return new Sn();
}
function L2(r) {
  return r instanceof Sn;
}
class On extends Mi {
  constructor(t, n) {
    super(n);
    Ye(this, "__templateColumns");
    this.__templateColumns = t;
  }
  static getType() {
    return "layout-container";
  }
  static clone(t) {
    return new On(t.__templateColumns, t.__key);
  }
  createDOM(t) {
    const n = document.createElement("div");
    return n.style.gridTemplateColumns = this.__templateColumns, typeof t.theme.layoutContainer == "string" && ut.addClassNamesToElement(n, t.theme.layoutContainer), n;
  }
  updateDOM(t, n) {
    return t.__templateColumns !== this.__templateColumns && (n.style.gridTemplateColumns = this.__templateColumns), !1;
  }
  static importDOM() {
    return {};
  }
  static importJSON(t) {
    return Vd(t.templateColumns);
  }
  canBeEmpty() {
    return !1;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      templateColumns: this.__templateColumns,
      type: "layout-container",
      version: 1
    };
  }
  getTemplateColumns() {
    return this.getLatest().__templateColumns;
  }
  setTemplateColumns(t) {
    this.getWritable().__templateColumns = t;
  }
}
function Vd(r) {
  return new On(r);
}
function to(r) {
  return r instanceof On;
}
class Mn extends Mi {
  static getType() {
    return "layout-item";
  }
  static clone(e) {
    return new Mn(e.__key);
  }
  createDOM(e) {
    const t = document.createElement("div");
    return typeof e.theme.layoutItem == "string" && ut.addClassNamesToElement(t, e.theme.layoutItem), t;
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return {};
  }
  static importJSON() {
    return ns();
  }
  isShadowRoot() {
    return !0;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "layout-item",
      version: 1
    };
  }
}
function ns() {
  return new Mn();
}
function ac(r) {
  return r instanceof Mn;
}
const up = hr.lazy(() => import("./PollComponent-C1VMEsAC.js"));
function dp() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
}
function sc(r = "") {
  return {
    text: r,
    uid: dp(),
    votes: []
  };
}
function lc(r, e, t) {
  return {
    text: e,
    uid: r.uid,
    votes: t || Array.from(r.votes)
  };
}
function hp(r) {
  const e = r.getAttribute("data-lexical-poll-question"), t = r.getAttribute("data-lexical-poll-options");
  return e !== null && t !== null ? { node: Ys(e, JSON.parse(t)) } : null;
}
class ri extends mn {
  constructor(t, n, i) {
    super(i);
    Ye(this, "__question");
    Ye(this, "__options");
    this.__question = t, this.__options = n;
  }
  static getType() {
    return "poll";
  }
  static clone(t) {
    return new ri(t.__question, t.__options, t.__key);
  }
  static importJSON(t) {
    const n = Ys(
      t.question,
      t.options
    );
    return t.options.forEach(n.addOption), n;
  }
  exportJSON() {
    return {
      options: this.__options,
      question: this.__question,
      type: "poll",
      version: 1
    };
  }
  addOption(t) {
    const n = this.getWritable(), i = Array.from(n.__options);
    i.push(t), n.__options = i;
  }
  deleteOption(t) {
    const n = this.getWritable(), i = Array.from(n.__options), o = i.indexOf(t);
    i.splice(o, 1), n.__options = i;
  }
  setOptionText(t, n) {
    const i = this.getWritable(), o = lc(t, n), s = Array.from(i.__options), a = s.indexOf(t);
    s[a] = o, i.__options = s;
  }
  toggleVote(t, n) {
    const i = this.getWritable(), o = t.votes, s = Array.from(o), a = o.indexOf(n);
    a === -1 ? s.push(n) : s.splice(a, 1);
    const l = lc(t, t.text, s), u = Array.from(i.__options), d = u.indexOf(t);
    u[d] = l, i.__options = u;
  }
  static importDOM() {
    return {
      span: (t) => t.hasAttribute("data-lexical-poll-question") ? {
        conversion: hp,
        priority: 2
      } : null
    };
  }
  exportDOM() {
    const t = document.createElement("span");
    return t.setAttribute("data-lexical-poll-question", this.__question), t.setAttribute(
      "data-lexical-poll-options",
      JSON.stringify(this.__options)
    ), { element: t };
  }
  createDOM() {
    const t = document.createElement("span");
    return t.style.display = "inline-block", t;
  }
  updateDOM() {
    return !1;
  }
  decorate() {
    return /* @__PURE__ */ L.jsx(An, { fallback: null, children: /* @__PURE__ */ L.jsx(
      up,
      {
        question: this.__question,
        options: this.__options,
        nodeKey: this.__key
      }
    ) });
  }
}
function Ys(r, e) {
  return new ri(r, e);
}
function k2(r) {
  return r instanceof ri;
}
const fp = hr.lazy(() => import("./InlineImageComponent-BbfNWr4w.js"));
function mp(r) {
  if (r instanceof HTMLImageElement) {
    const { alt: e, src: t, width: n, height: i } = r;
    return { node: Ws({ altText: e, height: i, src: t, width: n }) };
  }
  return null;
}
class ni extends mn {
  constructor(t, n, i, o, s, a, l, u) {
    super(u);
    Ye(this, "__src");
    Ye(this, "__altText");
    Ye(this, "__width");
    Ye(this, "__height");
    Ye(this, "__showCaption");
    Ye(this, "__caption");
    Ye(this, "__position");
    this.__src = t, this.__altText = n, this.__width = o || "inherit", this.__height = s || "inherit", this.__showCaption = a || !1, this.__caption = l || To(), this.__position = i;
  }
  static getType() {
    return "inline-image";
  }
  static clone(t) {
    return new ni(
      t.__src,
      t.__altText,
      t.__position,
      t.__width,
      t.__height,
      t.__showCaption,
      t.__caption,
      t.__key
    );
  }
  static importJSON(t) {
    const { altText: n, height: i, width: o, caption: s, src: a, showCaption: l, position: u } = t, d = Ws({
      altText: n,
      height: i,
      position: u,
      showCaption: l,
      src: a,
      width: o
    }), p = d.__caption, m = p.parseEditorState(s.editorState);
    return m.isEmpty() || p.setEditorState(m), d;
  }
  static importDOM() {
    return {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      img: (t) => ({
        conversion: mp,
        priority: 0
      })
    };
  }
  exportDOM() {
    const t = document.createElement("span");
    t.className = `inline-editor-image position-${this.__position}`;
    const n = document.createElement("img");
    return n.setAttribute("src", this.__src), n.setAttribute("alt", this.__altText), n.setAttribute("width", this.__width.toString()), n.setAttribute("height", this.__height.toString()), t.appendChild(n), { element: t };
  }
  exportJSON() {
    return {
      altText: this.getAltText(),
      caption: this.__caption.toJSON(),
      height: this.__height === "inherit" ? 0 : this.__height,
      position: this.__position,
      showCaption: this.__showCaption,
      src: this.getSrc(),
      type: "inline-image",
      version: 1,
      width: this.__width === "inherit" ? 0 : this.__width
    };
  }
  getSrc() {
    return this.__src;
  }
  getAltText() {
    return this.__altText;
  }
  setAltText(t) {
    const n = this.getWritable();
    n.__altText = t;
  }
  setWidthAndHeight(t, n) {
    const i = this.getWritable();
    i.__width = t, i.__height = n;
  }
  getShowCaption() {
    return this.__showCaption;
  }
  setShowCaption(t) {
    const n = this.getWritable();
    n.__showCaption = t;
  }
  getPosition() {
    return this.__position;
  }
  setPosition(t) {
    const n = this.getWritable();
    n.__position = t;
  }
  update(t) {
    const n = this.getWritable(), { altText: i, showCaption: o, position: s } = t;
    i !== void 0 && (n.__altText = i), o !== void 0 && (n.__showCaption = o), s !== void 0 && (n.__position = s);
  }
  // View
  createDOM(t) {
    const n = document.createElement("span");
    return n.className = `${t.theme.inlineImage} position-${this.__position}`, n;
  }
  updateDOM(t, n, i) {
    const o = this.__position;
    return o !== t.__position && (n.className = `${i.theme.inlineImage} position-${o}`), !1;
  }
  decorate() {
    return /* @__PURE__ */ L.jsx(An, { fallback: null, children: /* @__PURE__ */ L.jsx(
      fp,
      {
        src: this.__src,
        altText: this.__altText,
        width: this.__width,
        height: this.__height,
        nodeKey: this.getKey(),
        showCaption: this.__showCaption,
        caption: this.__caption,
        position: this.__position
      }
    ) });
  }
}
function Ws({
  altText: r,
  position: e,
  height: t,
  src: n,
  width: i,
  showCaption: o,
  caption: s,
  key: a
}) {
  return Oi(
    new ni(
      n,
      r,
      e,
      i,
      t,
      o,
      s,
      a
    )
  );
}
function gp(r) {
  return r instanceof ni;
}
const pp = hr.lazy(() => import("./StickyComponent-pc2B8Ox7.js"));
class Un extends mn {
  constructor(t, n, i, o, s) {
    super(s);
    Ye(this, "__x");
    Ye(this, "__y");
    Ye(this, "__color");
    Ye(this, "__caption");
    this.__x = t, this.__y = n, this.__caption = o || To(), this.__color = i;
  }
  static getType() {
    return "sticky";
  }
  static clone(t) {
    return new Un(
      t.__x,
      t.__y,
      t.__color,
      t.__caption,
      t.__key
    );
  }
  static importJSON(t) {
    const n = new Un(
      t.xOffset,
      t.yOffset,
      t.color
    ), i = t.caption, o = n.__caption, s = o.parseEditorState(i.editorState);
    return s.isEmpty() || o.setEditorState(s), n;
  }
  exportJSON() {
    return {
      caption: this.__caption.toJSON(),
      color: this.__color,
      type: "sticky",
      version: 1,
      xOffset: this.__x,
      yOffset: this.__y
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createDOM(t) {
    const n = document.createElement("div");
    return n.style.display = "contents", n;
  }
  updateDOM() {
    return !1;
  }
  setPosition(t, n) {
    const i = this.getWritable();
    i.__x = t, i.__y = n, Wn(null);
  }
  toggleColor() {
    const t = this.getWritable();
    t.__color = t.__color === "pink" ? "yellow" : "pink";
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  decorate(t, n) {
    return Qr(
      /* @__PURE__ */ L.jsx(An, { fallback: null, children: /* @__PURE__ */ L.jsx(
        pp,
        {
          color: this.__color,
          x: this.__x,
          y: this.__y,
          nodeKey: this.getKey(),
          caption: this.__caption
        }
      ) }),
      document.body
    );
  }
  isIsolated() {
    return !0;
  }
}
function D2(r) {
  return r instanceof Un;
}
function vp(r, e) {
  return new Un(r, e, "yellow");
}
const xp = [
  vo.CodeNode,
  bf.MarkNode,
  fr.HeadingNode,
  fr.QuoteNode,
  Zt.ListNode,
  Zt.ListItemNode,
  St.AutoLinkNode,
  St.LinkNode,
  Li.HorizontalRuleNode,
  Xn,
  ki,
  Jn,
  qn,
  Di,
  $i,
  Ii,
  wn,
  Tn,
  En,
  ti,
  Sn,
  On,
  Mn,
  ri,
  hf.HashtagNode,
  ni,
  Ge.TableNode,
  Ge.TableRowNode,
  Ge.TableCellNode,
  Un,
  Ef.OverflowNode
];
var ro = {}, no = {}, cc;
function Np() {
  if (cc) return no;
  cc = 1;
  var r = it(), e = Ve;
  const t = 0, n = 1, i = 2, o = 0, s = 1, a = 2, l = 3, u = 4;
  function d(g, x, b) {
    const A = g._nodeMap, w = [];
    for (const M of x) {
      const y = A.get(M);
      y !== void 0 && w.push(y);
    }
    for (const [M, y] of b) {
      if (!y)
        continue;
      const E = A.get(M);
      E !== void 0 && !e.$isRootNode(E) && w.push(E);
    }
    return w;
  }
  function p(g, x, b, A, w) {
    if (g === null || b.size === 0 && A.size === 0 && !w)
      return o;
    const M = x._selection, y = g._selection;
    if (w)
      return s;
    if (!e.$isRangeSelection(M) || !e.$isRangeSelection(y) || !y.isCollapsed() || !M.isCollapsed())
      return o;
    const E = d(x, b, A);
    if (E.length === 0)
      return o;
    if (E.length > 1) {
      const q = x._nodeMap, I = q.get(M.anchor.key), Y = q.get(y.anchor.key);
      return I && Y && !g._nodeMap.has(I.__key) && e.$isTextNode(I) && I.__text.length === 1 && M.anchor.offset === 1 ? a : o;
    }
    const S = E[0], P = g._nodeMap.get(S.__key);
    if (!e.$isTextNode(P) || !e.$isTextNode(S) || P.__mode !== S.__mode)
      return o;
    const U = P.__text, j = S.__text;
    if (U === j)
      return o;
    const H = M.anchor, R = y.anchor;
    if (H.key !== R.key || H.type !== "text")
      return o;
    const T = H.offset, $ = R.offset, G = j.length - U.length;
    return G === 1 && $ === T - 1 ? a : G === -1 && $ === T + 1 ? l : G === -1 && $ === T ? u : o;
  }
  function m(g, x, b) {
    const A = x._nodeMap.get(g), w = b._nodeMap.get(g), M = x._selection, y = b._selection;
    let E = !1;
    return e.$isRangeSelection(M) && e.$isRangeSelection(y) && (E = M.anchor.type === "element" && M.focus.type === "element" && y.anchor.type === "text" && y.focus.type === "text"), !E && e.$isTextNode(A) && e.$isTextNode(w) ? A.__type === w.__type && A.__text === w.__text && A.__mode === w.__mode && A.__detail === w.__detail && A.__style === w.__style && A.__format === w.__format && A.__parent === w.__parent : !1;
  }
  function c(g, x) {
    let b = Date.now(), A = o;
    return (w, M, y, E, S, P) => {
      const U = Date.now();
      if (P.has("historic"))
        return A = o, b = U, i;
      const j = p(w, M, E, S, g.isComposing()), H = (() => {
        const R = y === null || y.editor === g, T = P.has("history-push");
        if (!T && R && P.has("history-merge"))
          return t;
        if (w === null)
          return n;
        const G = M._selection;
        if (!(E.size > 0 || S.size > 0))
          return G !== null ? t : i;
        if (T === !1 && j !== o && j === A && U < b + x && R)
          return t;
        if (E.size === 1) {
          const I = Array.from(E)[0];
          if (m(I, w, M))
            return t;
        }
        return n;
      })();
      return b = U, A = j, H;
    };
  }
  function h(g, x) {
    const b = x.redoStack, A = x.undoStack;
    if (b.length !== 0) {
      const w = x.current;
      w !== null && (A.push(w), g.dispatchCommand(e.CAN_UNDO_COMMAND, !0));
      const M = b.pop();
      b.length === 0 && g.dispatchCommand(e.CAN_REDO_COMMAND, !1), x.current = M || null, M && M.editor.setEditorState(M.editorState, {
        tag: "historic"
      });
    }
  }
  function f(g, x) {
    const b = x.redoStack, A = x.undoStack;
    if (A.length !== 0) {
      const M = x.current, y = A.pop();
      M !== null && (b.push(M), g.dispatchCommand(e.CAN_REDO_COMMAND, !0)), A.length === 0 && g.dispatchCommand(e.CAN_UNDO_COMMAND, !1), x.current = y || null, y && y.editor.setEditorState(y.editorState, {
        tag: "historic"
      });
    }
  }
  function N(g) {
    g.undoStack = [], g.redoStack = [], g.current = null;
  }
  function v(g, x, b) {
    const A = c(g, b), w = ({
      editorState: E,
      prevEditorState: S,
      dirtyLeaves: P,
      dirtyElements: U,
      tags: j
    }) => {
      const H = x.current, R = x.redoStack, T = x.undoStack, $ = H === null ? null : H.editorState;
      if (H !== null && E === $)
        return;
      const G = A(S, E, H, P, U, j);
      if (G === n)
        R.length !== 0 && (x.redoStack = [], g.dispatchCommand(e.CAN_REDO_COMMAND, !1)), H !== null && (T.push({
          ...H
        }), g.dispatchCommand(e.CAN_UNDO_COMMAND, !0));
      else if (G === i)
        return;
      x.current = {
        editor: g,
        editorState: E
      };
    }, M = r.mergeRegister(g.registerCommand(e.UNDO_COMMAND, () => (f(g, x), !0), e.COMMAND_PRIORITY_EDITOR), g.registerCommand(e.REDO_COMMAND, () => (h(g, x), !0), e.COMMAND_PRIORITY_EDITOR), g.registerCommand(e.CLEAR_EDITOR_COMMAND, () => (N(x), !1), e.COMMAND_PRIORITY_EDITOR), g.registerCommand(e.CLEAR_HISTORY_COMMAND, () => (N(x), g.dispatchCommand(e.CAN_REDO_COMMAND, !1), g.dispatchCommand(e.CAN_UNDO_COMMAND, !1), !0), e.COMMAND_PRIORITY_EDITOR), g.registerUpdateListener(w)), y = g.registerUpdateListener(w);
    return () => {
      M(), y();
    };
  }
  function C() {
    return {
      current: null,
      redoStack: [],
      undoStack: []
    };
  }
  return no.createEmptyHistoryState = C, no.registerHistory = v, no;
}
var io = {}, uc;
function _p() {
  if (uc) return io;
  uc = 1;
  var r = it(), e = Ve;
  function t(i, o, s, a, l) {
    if (i === null || s.size === 0 && a.size === 0 && !l) return 0;
    var u = o._selection, d = i._selection;
    if (l) return 1;
    if (!(e.$isRangeSelection(u) && e.$isRangeSelection(d) && d.isCollapsed() && u.isCollapsed())) return 0;
    l = o._nodeMap;
    let p = [];
    for (let m of s) s = l.get(m), s !== void 0 && p.push(s);
    for (let [m, c] of a) c && (a = l.get(m), a === void 0 || e.$isRootNode(a) || p.push(a));
    return p.length === 0 ? 0 : 1 < p.length ? (a = o._nodeMap, o = a.get(u.anchor.key), d = a.get(d.anchor.key), o && d && !i._nodeMap.has(o.__key) && e.$isTextNode(o) && o.__text.length === 1 && u.anchor.offset === 1 ? 2 : 0) : (o = p[0], i = i._nodeMap.get(o.__key), !e.$isTextNode(i) || !e.$isTextNode(o) || i.__mode !== o.__mode || (i = i.__text, o = o.__text, i === o) || (u = u.anchor, d = d.anchor, u.key !== d.key || u.type !== "text") ? 0 : (u = u.offset, d = d.offset, i = o.length - i.length, i === 1 && d === u - 1 ? 2 : i === -1 && d === u + 1 ? 3 : i === -1 && d === u ? 4 : 0));
  }
  function n(i, o) {
    let s = Date.now(), a = 0;
    return (l, u, d, p, m, c) => {
      let h = Date.now();
      if (c.has("historic")) return a = 0, s = h, 2;
      let f = t(l, u, p, m, i.isComposing()), N = (() => {
        var v = d === null || d.editor === i, C = c.has("history-push");
        if (!C && v && c.has("history-merge")) return 0;
        if (l === null) return 1;
        var g = u._selection;
        if (!(0 < p.size || 0 < m.size)) return g !== null ? 0 : 2;
        if (C === !1 && f !== 0 && f === a && h < s + o && v) return 0;
        if (p.size === 1) {
          {
            C = Array.from(p)[0], v = l._nodeMap.get(C), C = u._nodeMap.get(C), g = l._selection;
            let x = u._selection, b = !1;
            e.$isRangeSelection(g) && e.$isRangeSelection(x) && (b = g.anchor.type === "element" && g.focus.type === "element" && x.anchor.type === "text" && x.focus.type === "text"), v = !b && e.$isTextNode(v) && e.$isTextNode(C) ? v.__type === C.__type && v.__text === C.__text && v.__mode === C.__mode && v.__detail === C.__detail && v.__style === C.__style && v.__format === C.__format && v.__parent === C.__parent : !1;
          }
          if (v) return 0;
        }
        return 1;
      })();
      return s = h, a = f, N;
    };
  }
  return io.createEmptyHistoryState = function() {
    return { current: null, redoStack: [], undoStack: [] };
  }, io.registerHistory = function(i, o, s) {
    let a = n(i, s);
    s = ({ editorState: d, prevEditorState: p, dirtyLeaves: m, dirtyElements: c, tags: h }) => {
      const f = o.current, N = o.redoStack, v = o.undoStack, C = f === null ? null : f.editorState;
      if (f === null || d !== C) {
        if (p = a(p, d, f, m, c, h), p === 1) N.length !== 0 && (o.redoStack = [], i.dispatchCommand(e.CAN_REDO_COMMAND, !1)), f !== null && (v.push({ ...f }), i.dispatchCommand(e.CAN_UNDO_COMMAND, !0));
        else if (p === 2) return;
        o.current = { editor: i, editorState: d };
      }
    };
    let l = r.mergeRegister(i.registerCommand(
      e.UNDO_COMMAND,
      () => {
        let d = o.redoStack, p = o.undoStack;
        if (p.length !== 0) {
          let m = o.current, c = p.pop();
          m !== null && (d.push(m), i.dispatchCommand(e.CAN_REDO_COMMAND, !0)), p.length === 0 && i.dispatchCommand(e.CAN_UNDO_COMMAND, !1), o.current = c || null, c && c.editor.setEditorState(c.editorState, { tag: "historic" });
        }
        return !0;
      },
      e.COMMAND_PRIORITY_EDITOR
    ), i.registerCommand(e.REDO_COMMAND, () => {
      let d = o.redoStack;
      var p = o.undoStack;
      if (d.length !== 0) {
        let m = o.current;
        m !== null && (p.push(m), i.dispatchCommand(e.CAN_UNDO_COMMAND, !0)), p = d.pop(), d.length === 0 && i.dispatchCommand(e.CAN_REDO_COMMAND, !1), o.current = p || null, p && p.editor.setEditorState(p.editorState, { tag: "historic" });
      }
      return !0;
    }, e.COMMAND_PRIORITY_EDITOR), i.registerCommand(e.CLEAR_EDITOR_COMMAND, () => (o.undoStack = [], o.redoStack = [], o.current = null, !1), e.COMMAND_PRIORITY_EDITOR), i.registerCommand(e.CLEAR_HISTORY_COMMAND, () => (o.undoStack = [], o.redoStack = [], o.current = null, i.dispatchCommand(e.CAN_REDO_COMMAND, !1), i.dispatchCommand(e.CAN_UNDO_COMMAND, !1), !0), e.COMMAND_PRIORITY_EDITOR), i.registerUpdateListener(s)), u = i.registerUpdateListener(s);
    return () => {
      l(), u();
    };
  }, io;
}
var ca, dc;
function Xd() {
  return dc || (dc = 1, ca = process.env.NODE_ENV === "development" ? Np() : _p()), ca;
}
var hc;
function Cp() {
  if (hc) return ro;
  hc = 1;
  var r = lt(), e = Xd(), t = nt;
  function n(o, s, a = 1e3) {
    const l = t.useMemo(() => s || e.createEmptyHistoryState(), [s]);
    t.useEffect(() => e.registerHistory(o, l, a), [a, o, l]);
  }
  function i({
    externalHistoryState: o
  }) {
    const [s] = r.useLexicalComposerContext();
    return n(s, o), null;
  }
  return ro.createEmptyHistoryState = e.createEmptyHistoryState, ro.HistoryPlugin = i, ro;
}
var oo = {}, fc;
function bp() {
  if (fc) return oo;
  fc = 1;
  var r = lt(), e = Xd(), t = nt;
  function n(i, o, s = 1e3) {
    let a = t.useMemo(() => o || e.createEmptyHistoryState(), [o]);
    t.useEffect(() => e.registerHistory(i, a, s), [s, i, a]);
  }
  return oo.createEmptyHistoryState = e.createEmptyHistoryState, oo.HistoryPlugin = function({ externalHistoryState: i }) {
    let [o] = r.useLexicalComposerContext();
    return n(o, i), null;
  }, oo;
}
const yp = process.env.NODE_ENV === "development" ? Cp() : bp();
var Jd = yp;
const Zd = _u({}), wp = ({
  children: r,
  initHistoryState: e
}) => {
  const t = Sr(
    () => ({ historyState: e || Jd.createEmptyHistoryState() }),
    []
  );
  return /* @__PURE__ */ L.jsx(Zd.Provider, { value: t, children: r });
}, Tp = () => Mh(Zd);
var ua = {}, da, mc;
function Ep() {
  if (mc) return da;
  mc = 1;
  var r = lt(), e = nt, i = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? e.useLayoutEffect : e.useEffect;
  function o(l) {
    const [u] = r.useLexicalComposerContext(), d = e.useMemo(() => l(u), [u, l]), p = e.useRef(d.initialValueFn()), [m, c] = e.useState(p.current);
    return i(() => {
      const {
        initialValueFn: h,
        subscribe: f
      } = d, N = h();
      return p.current !== N && (p.current = N, c(N)), f((v) => {
        p.current = v, c(v);
      });
    }, [d, l]), m;
  }
  function s(l) {
    return {
      initialValueFn: () => l.isEditable(),
      subscribe: (u) => l.registerEditableListener(u)
    };
  }
  function a() {
    return o(s);
  }
  return da = a, da;
}
var ha, gc;
function Sp() {
  if (gc) return ha;
  gc = 1;
  var r = lt(), e = nt, t = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? e.useLayoutEffect : e.useEffect;
  function n(o) {
    let [s] = r.useLexicalComposerContext(), a = e.useMemo(() => o(s), [s, o]), l = e.useRef(a.initialValueFn()), [u, d] = e.useState(l.current);
    return t(() => {
      let { initialValueFn: p, subscribe: m } = a, c = p();
      return l.current !== c && (l.current = c, d(c)), m((h) => {
        l.current = h, d(h);
      });
    }, [a, o]), u;
  }
  function i(o) {
    return { initialValueFn: () => o.isEditable(), subscribe: (s) => o.registerEditableListener(s) };
  }
  return ha = function() {
    return n(i);
  }, ha;
}
var fa, pc;
function Gs() {
  return pc || (pc = 1, fa = process.env.NODE_ENV === "development" ? Ep() : Sp()), fa;
}
var Hr = {}, vc;
function Op() {
  if (vc) return Hr;
  vc = 1;
  var r = Ve;
  function e(l, u) {
    let d = l.getFirstChild(), p = 0;
    e: for (; d !== null; ) {
      if (r.$isElementNode(d)) {
        const h = d.getFirstChild();
        if (h !== null) {
          d = h;
          continue;
        }
      } else if (r.$isTextNode(d)) {
        const h = d.getTextContentSize();
        if (p + h > u)
          return {
            node: d,
            offset: u - p
          };
        p += h;
      }
      const m = d.getNextSibling();
      if (m !== null) {
        d = m;
        continue;
      }
      let c = d.getParent();
      for (; c !== null; ) {
        const h = c.getNextSibling();
        if (h !== null) {
          d = h;
          continue e;
        }
        c = c.getParent();
      }
      break;
    }
    return null;
  }
  function t(l, u = !0) {
    if (l)
      return !1;
    let d = i();
    return u && (d = d.trim()), d === "";
  }
  function n(l, u) {
    return () => t(l, u);
  }
  function i() {
    return r.$getRoot().getTextContent();
  }
  function o(l) {
    if (!t(l, !1))
      return !1;
    const d = r.$getRoot().getChildren(), p = d.length;
    if (p > 1)
      return !1;
    for (let m = 0; m < p; m++) {
      const c = d[m];
      if (r.$isDecoratorNode(c))
        return !1;
      if (r.$isElementNode(c)) {
        if (!r.$isParagraphNode(c) || c.__indent !== 0)
          return !1;
        const h = c.getChildren(), f = h.length;
        for (let N = 0; N < f; N++) {
          const v = h[m];
          if (!r.$isTextNode(v))
            return !1;
        }
      }
    }
    return !0;
  }
  function s(l) {
    return () => o(l);
  }
  function a(l, u, d, p) {
    const m = (g) => g instanceof d, c = (g) => {
      const x = r.$createTextNode(g.getTextContent());
      x.setFormat(g.getFormat()), g.replace(x);
    }, h = (g) => g.getLatest().__mode, f = (g) => {
      if (!g.isSimpleText())
        return;
      const x = g.getPreviousSibling();
      let b = g.getTextContent(), A = g, w;
      if (r.$isTextNode(x)) {
        const M = x.getTextContent(), y = M + b, E = u(y);
        if (m(x))
          if (E === null || h(x) !== 0) {
            c(x);
            return;
          } else {
            const S = E.end - M.length;
            if (S > 0) {
              const P = b.slice(0, S), U = M + P;
              if (x.select(), x.setTextContent(U), S === b.length)
                g.remove();
              else {
                const j = b.slice(S);
                g.setTextContent(j);
              }
              return;
            }
          }
        else if (E === null || E.start < M.length)
          return;
      }
      for (; ; ) {
        w = u(b);
        let M = w === null ? "" : b.slice(w.end);
        if (b = M, M === "") {
          const S = A.getNextSibling();
          if (r.$isTextNode(S)) {
            M = A.getTextContent() + S.getTextContent();
            const P = u(M);
            if (P === null) {
              m(S) ? c(S) : S.markDirty();
              return;
            } else if (P.start !== 0)
              return;
          }
        } else {
          const S = u(M);
          if (S !== null && S.start === 0)
            return;
        }
        if (w === null)
          return;
        if (w.start === 0 && r.$isTextNode(x) && x.isTextEntity())
          continue;
        let y;
        w.start === 0 ? [y, A] = A.splitText(w.end) : [, y, A] = A.splitText(w.start, w.end);
        const E = p(y);
        if (E.setFormat(y.getFormat()), y.replace(E), A == null)
          return;
      }
    }, N = (g) => {
      const x = g.getTextContent(), b = u(x);
      if (b === null || b.start !== 0) {
        c(g);
        return;
      }
      if (x.length > b.end) {
        g.splitText(b.end);
        return;
      }
      const A = g.getPreviousSibling();
      r.$isTextNode(A) && A.isTextEntity() && (c(A), c(g));
      const w = g.getNextSibling();
      r.$isTextNode(w) && w.isTextEntity() && (c(w), m(g) && c(g));
    }, v = l.registerNodeTransform(r.TextNode, f), C = l.registerNodeTransform(d, N);
    return [v, C];
  }
  return Hr.$canShowPlaceholder = o, Hr.$canShowPlaceholderCurry = s, Hr.$findTextIntersectionFromCharacters = e, Hr.$isRootTextContentEmpty = t, Hr.$isRootTextContentEmptyCurry = n, Hr.$rootTextContent = i, Hr.registerLexicalTextEntity = a, Hr;
}
var jr = {}, xc;
function Mp() {
  if (xc) return jr;
  xc = 1;
  var r = Ve;
  function e(i, o = !0) {
    return i ? !1 : (i = t(), o && (i = i.trim()), i === "");
  }
  function t() {
    return r.$getRoot().getTextContent();
  }
  function n(i) {
    if (!e(i, !1)) return !1;
    i = r.$getRoot().getChildren();
    let o = i.length;
    if (1 < o) return !1;
    for (let a = 0; a < o; a++) {
      var s = i[a];
      if (r.$isDecoratorNode(s)) return !1;
      if (r.$isElementNode(s)) {
        if (!r.$isParagraphNode(s) || s.__indent !== 0) return !1;
        s = s.getChildren();
        let l = s.length;
        for (let u = 0; u < l; u++) if (!r.$isTextNode(s[a])) return !1;
      }
    }
    return !0;
  }
  return jr.$canShowPlaceholder = n, jr.$canShowPlaceholderCurry = function(i) {
    return () => n(i);
  }, jr.$findTextIntersectionFromCharacters = function(i, o) {
    var s = i.getFirstChild();
    i = 0;
    e: for (; s !== null; ) {
      if (r.$isElementNode(s)) {
        var a = s.getFirstChild();
        if (a !== null) {
          s = a;
          continue;
        }
      } else if (r.$isTextNode(s)) {
        if (a = s.getTextContentSize(), i + a > o) return { node: s, offset: o - i };
        i += a;
      }
      if (a = s.getNextSibling(), a !== null) s = a;
      else {
        for (s = s.getParent(); s !== null; ) {
          if (a = s.getNextSibling(), a !== null) {
            s = a;
            continue e;
          }
          s = s.getParent();
        }
        break;
      }
    }
    return null;
  }, jr.$isRootTextContentEmpty = e, jr.$isRootTextContentEmptyCurry = function(i, o) {
    return () => e(i, o);
  }, jr.$rootTextContent = t, jr.registerLexicalTextEntity = function(i, o, s, a) {
    let l = (d) => {
      const p = r.$createTextNode(d.getTextContent());
      p.setFormat(d.getFormat()), d.replace(p);
    }, u = i.registerNodeTransform(r.TextNode, (d) => {
      if (d.isSimpleText()) {
        var p = d.getPreviousSibling(), m = d.getTextContent(), c = d;
        if (r.$isTextNode(p)) {
          var h = p.getTextContent(), f = o(h + m);
          if (p instanceof s) {
            if (f === null || p.getLatest().__mode !== 0) {
              l(p);
              return;
            }
            if (f = f.end - h.length, 0 < f) {
              c = m.slice(0, f), c = h + c, p.select(), p.setTextContent(c), f === m.length ? d.remove() : (p = m.slice(f), d.setTextContent(p));
              return;
            }
          } else if (f === null || f.start < h.length) return;
        }
        for (; ; ) {
          if (d = o(m), m = f = d === null ? "" : m.slice(d.end), f === "") {
            if (h = c.getNextSibling(), r.$isTextNode(h)) {
              if (f = c.getTextContent() + h.getTextContent(), f = o(f), f === null) {
                h instanceof s ? l(h) : h.markDirty();
                break;
              } else if (f.start !== 0) break;
            }
          } else if (h = o(f), h !== null && h.start === 0) break;
          if (d === null) break;
          if (d.start === 0 && r.$isTextNode(p) && p.isTextEntity()) continue;
          let N;
          if (d.start === 0 ? [N, c] = c.splitText(d.end) : [, N, c] = c.splitText(d.start, d.end), d = a(N), d.setFormat(N.getFormat()), N.replace(d), c == null) break;
        }
      }
    });
    return i = i.registerNodeTransform(s, (d) => {
      var p = d.getTextContent();
      const m = o(p);
      m === null || m.start !== 0 ? l(d) : p.length > m.end ? d.splitText(m.end) : (p = d.getPreviousSibling(), r.$isTextNode(p) && p.isTextEntity() && (l(p), l(d)), p = d.getNextSibling(), r.$isTextNode(p) && p.isTextEntity() && (l(p), d instanceof s && l(d)));
    }), [u, i];
  }, jr;
}
var ma, Nc;
function ko() {
  return Nc || (Nc = 1, ma = process.env.NODE_ENV === "development" ? Op() : Mp()), ma;
}
var ga = {}, _c;
function Rp() {
  if (_c) return ga;
  _c = 1;
  var r = Ve;
  function e(t) {
    const n = window.location.origin, i = (o) => {
      if (o.origin !== n)
        return;
      const s = t.getRootElement();
      if (document.activeElement !== s)
        return;
      const a = o.data;
      if (typeof a == "string") {
        let l;
        try {
          l = JSON.parse(a);
        } catch {
          return;
        }
        if (l && l.protocol === "nuanria_messaging" && l.type === "request") {
          const u = l.payload;
          if (u && u.functionId === "makeChanges") {
            const d = u.args;
            if (d) {
              const [p, m, c, h, f, N] = d;
              t.update(() => {
                const v = r.$getSelection();
                if (r.$isRangeSelection(v)) {
                  const C = v.anchor;
                  let g = C.getNode(), x = 0, b = 0;
                  if (r.$isTextNode(g) && p >= 0 && m >= 0 && (x = p, b = p + m, v.setTextNodeRange(g, x, g, b)), (x !== b || c !== "") && (v.insertRawText(c), g = C.getNode()), r.$isTextNode(g)) {
                    x = h, b = h + f;
                    const A = g.getTextContentSize();
                    x = x > A ? A : x, b = b > A ? A : b, v.setTextNodeRange(g, x, g, b);
                  }
                  o.stopImmediatePropagation();
                }
              });
            }
          }
        }
      }
    };
    return window.addEventListener("message", i, !0), () => {
      window.removeEventListener("message", i, !0);
    };
  }
  return ga.registerDragonSupport = e, ga;
}
var pa = {}, Cc;
function Ap() {
  if (Cc) return pa;
  Cc = 1;
  var r = Ve;
  return pa.registerDragonSupport = function(e) {
    let t = window.location.origin, n = (i) => {
      if (i.origin === t) {
        var o = e.getRootElement();
        if (document.activeElement === o && (o = i.data, typeof o == "string")) {
          try {
            var s = JSON.parse(o);
          } catch {
            return;
          }
          if (s && s.protocol === "nuanria_messaging" && s.type === "request" && (s = s.payload) && s.functionId === "makeChanges" && (s = s.args)) {
            const [a, l, u, d, p] = s;
            e.update(() => {
              const m = r.$getSelection();
              if (r.$isRangeSelection(m)) {
                var c = m.anchor;
                let h = c.getNode(), f = 0, N = 0;
                r.$isTextNode(h) && 0 <= a && 0 <= l && (f = a, N = a + l, m.setTextNodeRange(h, f, h, N)), (f !== N || u !== "") && (m.insertRawText(u), h = c.getNode()), r.$isTextNode(h) && (f = d, N = d + p, c = h.getTextContentSize(), f = f > c ? c : f, N = N > c ? c : N, m.setTextNodeRange(h, f, h, N)), i.stopImmediatePropagation();
              }
            });
          }
        }
      }
    };
    return window.addEventListener("message", n, !0), () => {
      window.removeEventListener("message", n, !0);
    };
  }, pa;
}
var va, bc;
function Qd() {
  return bc || (bc = 1, va = process.env.NODE_ENV === "development" ? Rp() : Ap()), va;
}
var yc;
function Lp() {
  if (yc) return ua;
  yc = 1;
  var r = lt(), e = Gs(), t = nt, n = ko(), i = it(), o = Mu, s = Qd(), a = fr, d = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  function p(v) {
    return v.getEditorState().read(n.$canShowPlaceholderCurry(v.isComposing()));
  }
  function m(v) {
    const [C, g] = t.useState(() => p(v));
    return d(() => {
      function x() {
        const b = p(v);
        g(b);
      }
      return x(), i.mergeRegister(v.registerUpdateListener(() => {
        x();
      }), v.registerEditableListener(() => {
        x();
      }));
    }, [v]), C;
  }
  function c(v, C) {
    const [g, x] = t.useState(() => v.getDecorators());
    return d(() => v.registerDecoratorListener((b) => {
      o.flushSync(() => {
        x(b);
      });
    }), [v]), t.useEffect(() => {
      x(v.getDecorators());
    }, [v]), t.useMemo(() => {
      const b = [], A = Object.keys(g);
      for (let w = 0; w < A.length; w++) {
        const M = A[w], y = /* @__PURE__ */ t.createElement(C, {
          onError: (S) => v._onError(S)
        }, /* @__PURE__ */ t.createElement(t.Suspense, {
          fallback: null
        }, g[M])), E = v.getElementByKey(M);
        E !== null && b.push(/* @__PURE__ */ o.createPortal(y, E, M));
      }
      return b;
    }, [C, g, v]);
  }
  function h(v) {
    d(() => i.mergeRegister(a.registerRichText(v), s.registerDragonSupport(v)), [v]);
  }
  function f({
    contentEditable: v,
    placeholder: C,
    ErrorBoundary: g
  }) {
    const [x] = r.useLexicalComposerContext(), b = c(x, g);
    return h(x), /* @__PURE__ */ t.createElement(t.Fragment, null, v, /* @__PURE__ */ t.createElement(N, {
      content: C
    }), b);
  }
  function N({
    content: v
  }) {
    const [C] = r.useLexicalComposerContext(), g = m(C), x = e();
    return g ? typeof v == "function" ? v(x) : v : null;
  }
  return ua.RichTextPlugin = f, ua;
}
var xa = {}, wc;
function kp() {
  if (wc) return xa;
  wc = 1;
  var r = lt(), e = Gs(), t = nt, n = ko(), i = it(), o = Mu, s = Qd(), a = fr, l = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  function u(h) {
    return h.getEditorState().read(n.$canShowPlaceholderCurry(h.isComposing()));
  }
  function d(h) {
    let [f, N] = t.useState(() => u(h));
    return l(() => {
      function v() {
        let C = u(h);
        N(C);
      }
      return v(), i.mergeRegister(h.registerUpdateListener(() => {
        v();
      }), h.registerEditableListener(() => {
        v();
      }));
    }, [h]), f;
  }
  function p(h, f) {
    let [N, v] = t.useState(() => h.getDecorators());
    return l(() => h.registerDecoratorListener((C) => {
      o.flushSync(() => {
        v(C);
      });
    }), [h]), t.useEffect(() => {
      v(h.getDecorators());
    }, [h]), t.useMemo(() => {
      let C = [], g = Object.keys(N);
      for (let x = 0; x < g.length; x++) {
        let b = g[x], A = t.createElement(f, { onError: (M) => h._onError(M) }, t.createElement(t.Suspense, { fallback: null }, N[b])), w = h.getElementByKey(b);
        w !== null && C.push(o.createPortal(A, w, b));
      }
      return C;
    }, [f, N, h]);
  }
  function m(h) {
    l(() => i.mergeRegister(a.registerRichText(h), s.registerDragonSupport(h)), [h]);
  }
  function c({ content: h }) {
    var [f] = r.useLexicalComposerContext();
    f = d(f);
    let N = e();
    return f ? typeof h == "function" ? h(N) : h : null;
  }
  return xa.RichTextPlugin = function({ contentEditable: h, placeholder: f, ErrorBoundary: N }) {
    let [v] = r.useLexicalComposerContext();
    return N = p(v, N), m(v), t.createElement(t.Fragment, null, h, t.createElement(c, { content: f }), N);
  }, xa;
}
const Dp = process.env.NODE_ENV === "development" ? Lp() : kp();
var $p = Dp, Na, Tc;
function Ip() {
  if (Tc) return Na;
  Tc = 1;
  var r = nt;
  function e(a, l) {
    return e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, p) {
      return d.__proto__ = p, d;
    }, e(a, l);
  }
  function t(a, l) {
    a.prototype = Object.create(l.prototype), a.prototype.constructor = a, e(a, l);
  }
  var n = function(l, u) {
    return l === void 0 && (l = []), u === void 0 && (u = []), l.length !== u.length || l.some(function(d, p) {
      return !Object.is(d, u[p]);
    });
  }, i = {
    error: null
  }, o = /* @__PURE__ */ function(a) {
    t(l, a);
    function l() {
      for (var d, p = arguments.length, m = new Array(p), c = 0; c < p; c++)
        m[c] = arguments[c];
      return d = a.call.apply(a, [this].concat(m)) || this, d.state = i, d.resetErrorBoundary = function() {
        for (var h, f = arguments.length, N = new Array(f), v = 0; v < f; v++)
          N[v] = arguments[v];
        d.props.onReset == null || (h = d.props).onReset.apply(h, N), d.reset();
      }, d;
    }
    l.getDerivedStateFromError = function(p) {
      return {
        error: p
      };
    };
    var u = l.prototype;
    return u.reset = function() {
      this.setState(i);
    }, u.componentDidCatch = function(p, m) {
      var c, h;
      (c = (h = this.props).onError) == null || c.call(h, p, m);
    }, u.componentDidUpdate = function(p, m) {
      var c = this.state.error, h = this.props.resetKeys;
      if (c !== null && m.error !== null && n(p.resetKeys, h)) {
        var f, N;
        (f = (N = this.props).onResetKeysChange) == null || f.call(N, p.resetKeys, h), this.reset();
      }
    }, u.render = function() {
      var p = this.state.error, m = this.props, c = m.fallbackRender, h = m.FallbackComponent, f = m.fallback;
      if (p !== null) {
        var N = {
          error: p,
          resetErrorBoundary: this.resetErrorBoundary
        };
        if (/* @__PURE__ */ r.isValidElement(f))
          return f;
        if (typeof c == "function")
          return c(N);
        if (h)
          return /* @__PURE__ */ r.createElement(h, N);
        throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
      }
      return this.props.children;
    }, l;
  }(r.Component);
  function s({
    children: a,
    onError: l
  }) {
    return /* @__PURE__ */ r.createElement(o, {
      fallback: /* @__PURE__ */ r.createElement("div", {
        style: {
          border: "1px solid #f00",
          color: "#f00",
          padding: "8px"
        }
      }, "An error was thrown."),
      onError: l
    }, a);
  }
  return Na = s, Na;
}
var _a, Ec;
function Pp() {
  if (Ec) return _a;
  Ec = 1;
  var r = nt;
  function e(s, a) {
    return e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(l, u) {
      return l.__proto__ = u, l;
    }, e(s, a);
  }
  function t(s, a) {
    s.prototype = Object.create(a.prototype), s.prototype.constructor = s, e(s, a);
  }
  function n(s, a) {
    return s === void 0 && (s = []), a === void 0 && (a = []), s.length !== a.length || s.some(function(l, u) {
      return !Object.is(l, a[u]);
    });
  }
  var i = { error: null }, o = function(s) {
    function a() {
      for (var u, d = arguments.length, p = Array(d), m = 0; m < d; m++) p[m] = arguments[m];
      return u = s.call.apply(s, [this].concat(p)) || this, u.state = i, u.resetErrorBoundary = function() {
        for (var c, h = arguments.length, f = Array(h), N = 0; N < h; N++) f[N] = arguments[N];
        u.props.onReset == null || (c = u.props).onReset.apply(c, f), u.reset();
      }, u;
    }
    t(a, s), a.getDerivedStateFromError = function(u) {
      return { error: u };
    };
    var l = a.prototype;
    return l.reset = function() {
      this.setState(i);
    }, l.componentDidCatch = function(u, d) {
      var p, m;
      (p = (m = this.props).onError) == null || p.call(m, u, d);
    }, l.componentDidUpdate = function(u, d) {
      var p = this.props.resetKeys;
      if (this.state.error !== null && d.error !== null && n(u.resetKeys, p)) {
        var m, c;
        (m = (c = this.props).onResetKeysChange) == null || m.call(c, u.resetKeys, p), this.reset();
      }
    }, l.render = function() {
      var u = this.state.error, d = this.props, p = d.fallbackRender, m = d.FallbackComponent;
      if (d = d.fallback, u !== null) {
        if (u = { error: u, resetErrorBoundary: this.resetErrorBoundary }, r.isValidElement(d)) return d;
        if (typeof p == "function") return p(u);
        if (m) return r.createElement(m, u);
        throw Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
      }
      return this.props.children;
    }, a;
  }(r.Component);
  return _a = function({ children: s, onError: a }) {
    return r.createElement(o, { fallback: r.createElement("div", { style: { border: "1px solid #f00", color: "#f00", padding: "8px" } }, "An error was thrown."), onError: a }, s);
  }, _a;
}
const Fp = process.env.NODE_ENV === "development" ? Ip() : Pp();
var Bp = Fp;
const zp = /* @__PURE__ */ Ru(Bp);
var Ca = {}, Sc;
function Hp() {
  if (Sc) return Ca;
  Sc = 1;
  var r = lt(), e = nt;
  function t({
    defaultSelection: n
  }) {
    const [i] = r.useLexicalComposerContext();
    return e.useEffect(() => {
      i.focus(() => {
        const o = document.activeElement, s = i.getRootElement();
        s !== null && (o === null || !s.contains(o)) && s.focus({
          preventScroll: !0
        });
      }, {
        defaultSelection: n
      });
    }, [n, i]), null;
  }
  return Ca.AutoFocusPlugin = t, Ca;
}
var ba = {}, Oc;
function jp() {
  if (Oc) return ba;
  Oc = 1;
  var r = lt(), e = nt;
  return ba.AutoFocusPlugin = function({ defaultSelection: t }) {
    let [n] = r.useLexicalComposerContext();
    return e.useEffect(() => {
      n.focus(() => {
        let i = document.activeElement, o = n.getRootElement();
        o === null || i !== null && o.contains(i) || o.focus({ preventScroll: !0 });
      }, { defaultSelection: t });
    }, [t, n]), null;
  }, ba;
}
const qp = process.env.NODE_ENV === "development" ? Hp() : jp();
var Kp = qp, ao = {}, Mc;
function Up() {
  if (Mc) return ao;
  Mc = 1;
  var r = lt(), e = it(), t = Ve, n = nt;
  function i(a) {
    const l = a.getNodes();
    if (e.$filter(l, (f) => t.$isBlockElementNode(f) && f.canIndent() ? f : null).length > 0)
      return !0;
    const d = a.anchor, p = a.focus, m = p.isBefore(d) ? p : d, c = m.getNode(), h = e.$getNearestBlockElementAncestorOrThrow(c);
    if (h.canIndent()) {
      const f = h.getKey();
      let N = t.$createRangeSelection();
      if (N.anchor.set(f, 0, "element"), N.focus.set(f, 0, "element"), N = t.$normalizeSelection__EXPERIMENTAL(N), N.anchor.is(m))
        return !0;
    }
    return !1;
  }
  function o(a) {
    return a.registerCommand(t.KEY_TAB_COMMAND, (l) => {
      const u = t.$getSelection();
      if (!t.$isRangeSelection(u))
        return !1;
      l.preventDefault();
      const d = i(u) ? l.shiftKey ? t.OUTDENT_CONTENT_COMMAND : t.INDENT_CONTENT_COMMAND : t.INSERT_TAB_COMMAND;
      return a.dispatchCommand(d, void 0);
    }, t.COMMAND_PRIORITY_EDITOR);
  }
  function s() {
    const [a] = r.useLexicalComposerContext();
    return n.useEffect(() => o(a)), null;
  }
  return ao.TabIndentationPlugin = s, ao.registerTabIndentation = o, ao;
}
var so = {}, Rc;
function Yp() {
  if (Rc) return so;
  Rc = 1;
  var r = lt(), e = it(), t = Ve, n = nt;
  function i(s) {
    var a = s.getNodes();
    if (0 < e.$filter(a, (l) => t.$isBlockElementNode(l) && l.canIndent() ? l : null).length) return !0;
    if (a = s.anchor, s = s.focus, s = s.isBefore(a) ? s : a, a = s.getNode(), a = e.$getNearestBlockElementAncestorOrThrow(a), a.canIndent()) {
      a = a.getKey();
      let l = t.$createRangeSelection();
      if (l.anchor.set(a, 0, "element"), l.focus.set(a, 0, "element"), l = t.$normalizeSelection__EXPERIMENTAL(l), l.anchor.is(s)) return !0;
    }
    return !1;
  }
  function o(s) {
    return s.registerCommand(t.KEY_TAB_COMMAND, (a) => {
      let l = t.$getSelection();
      return t.$isRangeSelection(l) ? (a.preventDefault(), a = i(l) ? a.shiftKey ? t.OUTDENT_CONTENT_COMMAND : t.INDENT_CONTENT_COMMAND : t.INSERT_TAB_COMMAND, s.dispatchCommand(a, void 0)) : !1;
    }, t.COMMAND_PRIORITY_EDITOR);
  }
  return so.TabIndentationPlugin = function() {
    let [s] = r.useLexicalComposerContext();
    return n.useEffect(() => o(s)), null;
  }, so.registerTabIndentation = o, so;
}
const Wp = process.env.NODE_ENV === "development" ? Up() : Yp();
var Gp = Wp, ya = {}, Ac;
function Vp() {
  if (Ac) return ya;
  Ac = 1;
  var r = lt(), e = Li, t = it(), n = Ve, i = nt;
  function o() {
    const [s] = r.useLexicalComposerContext();
    return i.useEffect(() => s.registerCommand(e.INSERT_HORIZONTAL_RULE_COMMAND, (a) => {
      const l = n.$getSelection();
      if (!n.$isRangeSelection(l))
        return !1;
      if (l.focus.getNode() !== null) {
        const d = e.$createHorizontalRuleNode();
        t.$insertNodeToNearestRoot(d);
      }
      return !0;
    }, n.COMMAND_PRIORITY_EDITOR), [s]), null;
  }
  return ya.HorizontalRulePlugin = o, ya;
}
var wa = {}, Lc;
function Xp() {
  if (Lc) return wa;
  Lc = 1;
  var r = lt(), e = Li, t = it(), n = Ve, i = nt;
  return wa.HorizontalRulePlugin = function() {
    let [o] = r.useLexicalComposerContext();
    return i.useEffect(() => o.registerCommand(e.INSERT_HORIZONTAL_RULE_COMMAND, () => {
      var s = n.$getSelection();
      return n.$isRangeSelection(s) ? (s.focus.getNode() !== null && (s = e.$createHorizontalRuleNode(), t.$insertNodeToNearestRoot(s)), !0) : !1;
    }, n.COMMAND_PRIORITY_EDITOR), [o]), null;
  }, wa;
}
const Jp = process.env.NODE_ENV === "development" ? Vp() : Xp();
var Zp = Jp;
function Qp({
  children: r,
  className: e
}) {
  return /* @__PURE__ */ L.jsx("div", { className: e || "placeholder__root", children: r });
}
var Ta = {}, kc;
function e1() {
  if (kc) return Ta;
  kc = 1;
  var r = lt(), e = nt;
  function t() {
    return t = Object.assign ? Object.assign.bind() : function(a) {
      for (var l = 1; l < arguments.length; l++) {
        var u = arguments[l];
        for (var d in u)
          Object.prototype.hasOwnProperty.call(u, d) && (a[d] = u[d]);
      }
      return a;
    }, t.apply(this, arguments);
  }
  var o = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? e.useLayoutEffect : e.useEffect;
  function s({
    ariaActiveDescendant: a,
    ariaAutoComplete: l,
    ariaControls: u,
    ariaDescribedBy: d,
    ariaExpanded: p,
    ariaLabel: m,
    ariaLabelledBy: c,
    ariaMultiline: h,
    ariaOwns: f,
    ariaRequired: N,
    autoCapitalize: v,
    className: C,
    id: g,
    role: x = "textbox",
    spellCheck: b = !0,
    style: A,
    tabIndex: w,
    "data-testid": M,
    ...y
  }) {
    const [E] = r.useLexicalComposerContext(), [S, P] = e.useState(!1), U = e.useCallback((j) => {
      E.setRootElement(j);
    }, [E]);
    return o(() => (P(E.isEditable()), E.registerEditableListener((j) => {
      P(j);
    })), [E]), /* @__PURE__ */ e.createElement("div", t({}, y, {
      "aria-activedescendant": S ? a : void 0,
      "aria-autocomplete": S ? l : "none",
      "aria-controls": S ? u : void 0,
      "aria-describedby": d,
      "aria-expanded": S && x === "combobox" ? !!p : void 0,
      "aria-label": m,
      "aria-labelledby": c,
      "aria-multiline": h,
      "aria-owns": S ? f : void 0,
      "aria-readonly": S ? void 0 : !0,
      "aria-required": N,
      autoCapitalize: v,
      className: C,
      contentEditable: S,
      "data-testid": M,
      id: g,
      ref: U,
      role: x,
      spellCheck: b,
      style: A,
      tabIndex: w
    }));
  }
  return Ta.ContentEditable = s, Ta;
}
var Ea = {}, Dc;
function t1() {
  if (Dc) return Ea;
  Dc = 1;
  var r = lt(), e = nt;
  function t() {
    return t = Object.assign ? Object.assign.bind() : function(i) {
      for (var o = 1; o < arguments.length; o++) {
        var s = arguments[o], a;
        for (a in s) Object.prototype.hasOwnProperty.call(s, a) && (i[a] = s[a]);
      }
      return i;
    }, t.apply(this, arguments);
  }
  var n = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? e.useLayoutEffect : e.useEffect;
  return Ea.ContentEditable = function({ ariaActiveDescendant: i, ariaAutoComplete: o, ariaControls: s, ariaDescribedBy: a, ariaExpanded: l, ariaLabel: u, ariaLabelledBy: d, ariaMultiline: p, ariaOwns: m, ariaRequired: c, autoCapitalize: h, className: f, id: N, role: v = "textbox", spellCheck: C = !0, style: g, tabIndex: x, "data-testid": b, ...A }) {
    let [w] = r.useLexicalComposerContext(), [M, y] = e.useState(!1), E = e.useCallback((S) => {
      w.setRootElement(S);
    }, [w]);
    return n(() => (y(w.isEditable()), w.registerEditableListener((S) => {
      y(S);
    })), [w]), e.createElement(
      "div",
      t({}, A, { "aria-activedescendant": M ? i : void 0, "aria-autocomplete": M ? o : "none", "aria-controls": M ? s : void 0, "aria-describedby": a, "aria-expanded": M && v === "combobox" ? !!l : void 0, "aria-label": u, "aria-labelledby": d, "aria-multiline": p, "aria-owns": M ? m : void 0, "aria-readonly": M ? void 0 : !0, "aria-required": c, autoCapitalize: h, className: f, contentEditable: M, "data-testid": b, id: N, ref: E, role: v, spellCheck: C, style: g, tabIndex: x })
    );
  }, Ea;
}
const r1 = process.env.NODE_ENV === "development" ? e1() : t1();
var n1 = r1;
function i1({
  className: r
}) {
  return /* @__PURE__ */ L.jsx(n1.ContentEditable, { className: r || "content-editable__root" });
}
var nr = en();
const ii = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", o1 = ii && "documentMode" in document ? document.documentMode : null, sn = ii && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
ii && "InputEvent" in window && !o1 && "getTargetRanges" in new window.InputEvent("input");
const eh = hr.createContext(null), $c = 4;
function _t({
  children: r,
  className: e,
  onClick: t,
  title: n
}) {
  const i = Rt(null), o = hr.useContext(eh);
  if (o === null)
    throw new Error("DropDownItem must be used within a DropDown");
  const { registerItem: s } = o;
  return We(() => {
    i && i.current && s(i);
  }, [i, s]), /* @__PURE__ */ L.jsx(
    "button",
    {
      className: e,
      onClick: t,
      ref: i,
      title: n,
      type: "button",
      children: r
    }
  );
}
function a1({
  children: r,
  dropDownRef: e,
  onClose: t
}) {
  const [n, i] = Ie(), [o, s] = Ie(), a = ct(
    (d) => {
      i((p) => p ? [...p, d] : [d]);
    },
    [i]
  ), l = (d) => {
    if (!n)
      return;
    const p = d.key;
    ["Escape", "ArrowUp", "ArrowDown", "Tab"].includes(p) && d.preventDefault(), p === "Escape" || p === "Tab" ? t() : p === "ArrowUp" ? s((m) => {
      if (!m)
        return n[0];
      const c = n.indexOf(m) - 1;
      return n[c === -1 ? n.length - 1 : c];
    }) : p === "ArrowDown" && s((m) => m ? n[n.indexOf(m) + 1] : n[0]);
  }, u = Sr(
    () => ({
      registerItem: a
    }),
    [a]
  );
  return We(() => {
    n && !o && s(n[0]), o && o.current && o.current.focus();
  }, [n, o]), /* @__PURE__ */ L.jsx(eh.Provider, { value: u, children: /* @__PURE__ */ L.jsx("div", { className: "dropdown", ref: e, onKeyDown: l, children: r }) });
}
function Rn({
  disabled: r = !1,
  buttonLabel: e,
  buttonAriaLabel: t,
  buttonClassName: n,
  buttonIconClassName: i,
  children: o,
  stopCloseOnClickSelf: s
}) {
  const a = Rt(null), l = Rt(null), [u, d] = Ie(!1), p = () => {
    d(!1), l && l.current && l.current.focus();
  };
  return We(() => {
    const m = l.current, c = a.current;
    if (u && m !== null && c !== null) {
      const { top: h, left: f } = m.getBoundingClientRect();
      c.style.top = `${h + m.offsetHeight + $c}px`, c.style.left = `${Math.min(
        f,
        window.innerWidth - c.offsetWidth - 20
      )}px`;
    }
  }, [a, l, u]), We(() => {
    const m = l.current;
    if (m !== null && u) {
      const c = (h) => {
        const f = h.target;
        s && a.current && a.current.contains(f) || m.contains(f) || d(!1);
      };
      return document.addEventListener("click", c), () => {
        document.removeEventListener("click", c);
      };
    }
  }, [a, l, u, s]), We(() => {
    const m = () => {
      if (u) {
        const c = l.current, h = a.current;
        if (c !== null && h !== null) {
          const { top: f } = c.getBoundingClientRect(), N = f + c.offsetHeight + $c;
          N !== h.getBoundingClientRect().top && (h.style.top = `${N}px`);
        }
      }
    };
    return document.addEventListener("scroll", m), () => {
      document.removeEventListener("scroll", m);
    };
  }, [l, a, u]), /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsxs(
      "button",
      {
        type: "button",
        disabled: r,
        "aria-label": t || e,
        className: n,
        onClick: () => d(!u),
        ref: l,
        children: [
          i && /* @__PURE__ */ L.jsx("span", { className: i }),
          e && /* @__PURE__ */ L.jsx("span", { className: "text dropdown-button-text", children: e }),
          /* @__PURE__ */ L.jsx("i", { className: "chevron-down" })
        ]
      }
    ),
    u && Qr(
      /* @__PURE__ */ L.jsx(a1, { dropDownRef: a, onClose: p, children: o }),
      document.body
    )
  ] });
}
const xn = 8, Nn = 72, s1 = 15;
function l1({
  selectionFontSize: r,
  disabled: e = !1,
  editor: t
}) {
  const [n, i] = hr.useState(r), o = (u, d) => {
    if (!d)
      return u;
    let p = u;
    switch (d) {
      case 2:
        switch (!0) {
          case u > Nn:
            p = Nn;
            break;
          case u >= 48:
            p -= 12;
            break;
          case u >= 24:
            p -= 4;
            break;
          case u >= 14:
            p -= 2;
            break;
          case u >= 9:
            p -= 1;
            break;
          default:
            p = xn;
            break;
        }
        break;
      case 1:
        switch (!0) {
          case u < xn:
            p = xn;
            break;
          case u < 12:
            p += 1;
            break;
          case u < 20:
            p += 2;
            break;
          case u < 36:
            p += 4;
            break;
          case u <= 60:
            p += 12;
            break;
          default:
            p = Nn;
            break;
        }
        break;
    }
    return p;
  }, s = hr.useCallback(
    (u, d) => {
      const p = (m) => (m || (m = `${s1}px`), m = m.slice(0, -2), `${o(
        Number(m),
        d
      )}px`);
      t.update(() => {
        if (t.isEditable()) {
          const m = Nt();
          m !== null && nr.$patchStyleText(m, {
            "font-size": u || p
          });
        }
      });
    },
    [t]
  ), a = (u) => {
    const d = Number(n);
    if (["e", "E", "+", "-"].includes(u.key) || isNaN(d)) {
      u.preventDefault(), i("");
      return;
    }
    if (u.key === "Enter") {
      u.preventDefault();
      let p = d;
      d > Nn ? p = Nn : d < xn && (p = xn), i(String(p)), s(String(p) + "px", null);
    }
  }, l = (u) => {
    if (n !== "") {
      const d = o(
        Number(n),
        u
      );
      s(String(d) + "px", null);
    } else
      s(null, u);
  };
  return hr.useEffect(() => {
    i(r);
  }, [r]), /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx(
      "button",
      {
        type: "button",
        disabled: e || r !== "" && Number(n) <= xn,
        onClick: () => l(
          2
          /* decrement */
        ),
        className: "toolbar-item font-decrement",
        children: /* @__PURE__ */ L.jsx("i", { className: "format minus-icon" })
      }
    ),
    /* @__PURE__ */ L.jsx(
      "input",
      {
        type: "number",
        value: n,
        disabled: e,
        className: "toolbar-item font-size-input",
        min: xn,
        max: Nn,
        onChange: (u) => i(u.target.value),
        onKeyDown: a
      }
    ),
    /* @__PURE__ */ L.jsx(
      "button",
      {
        type: "button",
        disabled: e || r !== "" && Number(n) >= Nn,
        onClick: () => l(
          1
          /* increment */
        ),
        className: "toolbar-item font-increment",
        children: /* @__PURE__ */ L.jsx("i", { className: "format add-icon" })
      }
    )
  ] });
}
const c1 = /* @__PURE__ */ new Set([
  "http:",
  "https:",
  "mailto:",
  "sms:",
  "tel:"
]);
function yo(r) {
  try {
    const e = new URL(r);
    if (!c1.has(e.protocol))
      return "about:blank";
  } catch {
    return r;
  }
  return r;
}
const u1 = new RegExp(
  /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=+$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=+$,\w]+@)[A-Za-z0-9.-]+)((?:\/[+~%/.\w-_]*)?\??(?:[-+=&;%@.\w_]*)#?(?:[\w]*))?)/
);
function d1(r) {
  return r === "https://" || u1.test(r);
}
function Yn(r) {
  const e = r.anchor, t = r.focus, n = r.anchor.getNode(), i = r.focus.getNode();
  return n === i ? n : r.isBackward() ? nr.$isAtNodeEnd(t) ? n : i : nr.$isAtNodeEnd(e) ? n : i;
}
function fn({
  label: r,
  value: e,
  onChange: t,
  placeholder: n = "",
  "data-test-id": i,
  type: o = "text"
}) {
  return /* @__PURE__ */ L.jsxs("div", { className: "Input__wrapper", children: [
    /* @__PURE__ */ L.jsx("label", { className: "Input__label", children: r }),
    /* @__PURE__ */ L.jsx(
      "input",
      {
        type: o,
        className: "Input__input",
        placeholder: n,
        value: e,
        onChange: (s) => {
          t(s.target.value);
        },
        "data-test-id": i
      }
    )
  ] });
}
let is = !1;
const h1 = [
  "#d0021b",
  "#f5a623",
  "#f8e71c",
  "#8b572a",
  "#7ed321",
  "#417505",
  "#bd10e0",
  "#9013fe",
  "#4a90e2",
  "#50e3c2",
  "#b8e986",
  "#000000",
  "#4a4a4a",
  "#9b9b9b",
  "#ffffff"
], pi = 214, Ic = 150;
function th({
  color: r,
  onChange: e
}) {
  const [t, n] = Ie(Fn("hex", r)), [i, o] = Ie(r), s = Rt(null), a = Sr(
    () => ({
      x: t.hsv.s / 100 * pi,
      y: (100 - t.hsv.v) / 100 * Ic
    }),
    [t.hsv.s, t.hsv.v]
  ), l = Sr(
    () => ({
      x: t.hsv.h / 360 * pi
    }),
    [t.hsv]
  ), u = (m) => {
    if (o(m), /^#[0-9A-Fa-f]{6}$/i.test(m)) {
      const c = Fn("hex", m);
      n(c);
    }
  }, d = ({ x: m, y: c }) => {
    const h = {
      ...t.hsv,
      s: m / pi * 100,
      v: 100 - c / Ic * 100
    }, f = Fn("hsv", h);
    n(f), o(f.hex);
  }, p = ({ x: m }) => {
    const c = { ...t.hsv, h: m / pi * 360 }, h = Fn("hsv", c);
    n(h), o(h.hex);
  };
  return We(() => {
    s.current !== null && e && (e(t.hex, is), o(t.hex));
  }, [t, e]), We(() => {
    if (r === void 0)
      return;
    const m = Fn("hex", r);
    n(m), o(m.hex);
  }, [r]), /* @__PURE__ */ L.jsxs(
    "div",
    {
      className: "color-picker-wrapper",
      style: { width: pi },
      ref: s,
      children: [
        /* @__PURE__ */ L.jsx(fn, { label: "Hex", onChange: u, value: i }),
        /* @__PURE__ */ L.jsx("div", { className: "color-picker-basic-color", children: h1.map((m) => /* @__PURE__ */ L.jsx(
          "button",
          {
            className: m === t.hex ? " active" : "",
            style: { backgroundColor: m },
            onClick: () => {
              o(m), n(Fn("hex", m));
            }
          },
          m
        )) }),
        /* @__PURE__ */ L.jsx(
          Pc,
          {
            className: "color-picker-saturation",
            style: { backgroundColor: `hsl(${t.hsv.h}, 100%, 50%)` },
            onChange: d,
            children: /* @__PURE__ */ L.jsx(
              "div",
              {
                className: "color-picker-saturation_cursor",
                style: {
                  backgroundColor: t.hex,
                  left: a.x,
                  top: a.y
                }
              }
            )
          }
        ),
        /* @__PURE__ */ L.jsx(Pc, { className: "color-picker-hue", onChange: p, children: /* @__PURE__ */ L.jsx(
          "div",
          {
            className: "color-picker-hue_cursor",
            style: {
              backgroundColor: `hsl(${t.hsv.h}, 100%, 50%)`,
              left: l.x
            }
          }
        ) }),
        /* @__PURE__ */ L.jsx(
          "div",
          {
            className: "color-picker-color",
            style: { backgroundColor: t.hex }
          }
        )
      ]
    }
  );
}
function Pc({ className: r, style: e, onChange: t, children: n }) {
  const i = Rt(null), o = Rt(!1), s = (l) => {
    if (i.current) {
      const { current: u } = i, { width: d, height: p, left: m, top: c } = u.getBoundingClientRect(), h = Fc(l.clientX - m, d, 0), f = Fc(l.clientY - c, p, 0);
      t({ x: h, y: f });
    }
  }, a = (l) => {
    if (l.button !== 0)
      return;
    s(l);
    const u = (p) => {
      o.current = !0, is = !0, s(p);
    }, d = (p) => {
      o.current && (is = !1), document.removeEventListener("mousemove", u, !1), document.removeEventListener("mouseup", d, !1), s(p), o.current = !1;
    };
    document.addEventListener("mousemove", u, !1), document.addEventListener("mouseup", d, !1);
  };
  return /* @__PURE__ */ L.jsx(
    "div",
    {
      ref: i,
      className: r,
      style: e,
      onMouseDown: a,
      children: n
    }
  );
}
function Fc(r, e, t) {
  return r > e ? e : r < t ? t : r;
}
function Bc(r) {
  if (r.startsWith("#")) {
    if (r.length === 4 || r.length === 5)
      return r = r.split("").map((e, t) => t ? e + e : "#").join(""), r;
    if (r.length === 7 || r.length === 9)
      return r;
  } else {
    const e = document.createElement("canvas").getContext("2d");
    if (!e)
      throw new Error("2d context not supported or canvas already initialized");
    return e.fillStyle = r, e.fillStyle;
  }
  return "#000000";
}
function zc(r) {
  const e = (r.replace(
    /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
    (t, n, i, o) => "#" + n + n + i + i + o + o
  ).substring(1).match(/.{2}/g) || []).map((t) => parseInt(t, 16));
  return {
    b: e[2],
    g: e[1],
    r: e[0]
  };
}
function Sa({ r, g: e, b: t }) {
  r /= 255, e /= 255, t /= 255;
  const n = Math.max(r, e, t), i = n - Math.min(r, e, t), o = i ? (n === r ? (e - t) / i + (e < t ? 6 : 0) : n === e ? 2 + (t - r) / i : 4 + (r - e) / i) * 60 : 0, s = n ? i / n * 100 : 0, a = n * 100;
  return { h: o, s, v: a };
}
function f1({ h: r, s: e, v: t }) {
  e /= 100, t /= 100;
  const n = ~~(r / 60), i = r / 60 - n, o = t * (1 - e), s = t * (1 - e * i), a = t * (1 - e * (1 - i)), l = n % 6, u = Math.round([t, s, o, o, a, t][l] * 255), d = Math.round([a, t, t, s, o, o][l] * 255);
  return { b: Math.round([o, o, a, t, t, s][l] * 255), g: d, r: u };
}
function Hc({ b: r, g: e, r: t }) {
  return "#" + [t, e, r].map((n) => n.toString(16).padStart(2, "0")).join("");
}
function Fn(r, e) {
  let t = Bc("#121212"), n = zc(t), i = Sa(n);
  return r === "hex" ? (t = Bc(e), n = zc(t), i = Sa(n)) : r === "rgb" ? (n = e, t = Hc(n), i = Sa(n)) : r === "hsv" && (i = e, n = f1(i), t = Hc(n)), { hex: t, hsv: i, rgb: n };
}
function jc({
  disabled: r = !1,
  stopCloseOnClickSelf: e = !0,
  color: t,
  onChange: n,
  ...i
}) {
  return /* @__PURE__ */ L.jsx(
    Rn,
    {
      ...i,
      disabled: r,
      stopCloseOnClickSelf: e,
      children: /* @__PURE__ */ L.jsx(th, { color: t, onChange: n })
    }
  );
}
const Vs = mr();
function m1() {
  const [r] = Ot.useLexicalComposerContext();
  return We(() => {
    if (!r.hasNodes([Xn]))
      throw new Error(
        "PageBreakPlugin: PageBreakNode is not registered on editor"
      );
    return ut.mergeRegister(
      r.registerCommand(
        Vs,
        () => {
          const e = Nt();
          if (!At(e))
            return !1;
          if (e.focus.getNode() !== null) {
            const n = vs();
            ut.$insertNodeToNearestRoot(n);
          }
          return !0;
        },
        Or
      )
    );
  }, [r]), null;
}
function g1({ children: r }) {
  return /* @__PURE__ */ L.jsx("div", { className: "DialogButtonsList", children: r });
}
function oi({
  "data-test-id": r,
  children: e
}) {
  return /* @__PURE__ */ L.jsx("div", { className: "DialogActions", "data-test-id": r, children: e });
}
function p1(...r) {
  return r.filter(Boolean).join(" ");
}
function Ir({
  "data-test-id": r,
  children: e,
  className: t,
  onClick: n,
  disabled: i,
  small: o,
  title: s
}) {
  return /* @__PURE__ */ L.jsx(
    "button",
    {
      disabled: i,
      className: p1(
        "Button__root",
        i && "Button__disabled",
        o && "Button__small",
        t
      ),
      onClick: n,
      title: s,
      "aria-label": s,
      ...r && { "data-test-id": r },
      children: e
    }
  );
}
function rh({
  accept: r,
  label: e,
  onChange: t,
  "data-test-id": n
}) {
  return /* @__PURE__ */ L.jsxs("div", { className: "Input__wrapper", children: [
    /* @__PURE__ */ L.jsx("label", { className: "Input__label", children: e }),
    /* @__PURE__ */ L.jsx(
      "input",
      {
        type: "file",
        accept: r,
        className: "Input__input",
        onChange: (i) => t(i.target.files),
        "data-test-id": n
      }
    )
  ] });
}
const v1 = (r) => ii ? (r || window).getSelection() : null, zi = mr("INSERT_IMAGE_COMMAND");
function x1({
  onClick: r
}) {
  const [e, t] = Ie(""), [n, i] = Ie(""), o = e === "";
  return /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx(
      fn,
      {
        label: "Image URL",
        placeholder: "i.e. https://source.unsplash.com/random",
        onChange: t,
        value: e,
        "data-test-id": "image-modal-url-input"
      }
    ),
    /* @__PURE__ */ L.jsx(
      fn,
      {
        label: "Alt Text",
        placeholder: "Random unsplash image",
        onChange: i,
        value: n,
        "data-test-id": "image-modal-alt-text-input"
      }
    ),
    /* @__PURE__ */ L.jsx(oi, { children: /* @__PURE__ */ L.jsx(
      Ir,
      {
        "data-test-id": "image-modal-confirm-btn",
        disabled: o,
        onClick: () => r({ altText: n, src: e }),
        children: "Confirm"
      }
    ) })
  ] });
}
function N1({
  onClick: r
}) {
  const [e, t] = Ie(""), [n, i] = Ie(""), o = e === "", s = (a) => {
    const l = new FileReader();
    l.onload = function() {
      return typeof l.result == "string" && t(l.result), "";
    }, a !== null && l.readAsDataURL(a[0]);
  };
  return /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx(
      rh,
      {
        label: "Image Upload",
        onChange: s,
        accept: "image/*",
        "data-test-id": "image-modal-file-upload"
      }
    ),
    /* @__PURE__ */ L.jsx(
      fn,
      {
        label: "Alt Text",
        placeholder: "Descriptive alternative text",
        onChange: i,
        value: n,
        "data-test-id": "image-modal-alt-text-input"
      }
    ),
    /* @__PURE__ */ L.jsx(oi, { children: /* @__PURE__ */ L.jsx(
      Ir,
      {
        "data-test-id": "image-modal-file-upload-btn",
        disabled: o,
        onClick: () => r({ altText: n, src: e }),
        children: "Confirm"
      }
    ) })
  ] });
}
function nh({
  activeEditor: r,
  onClose: e
}) {
  const [t, n] = Ie(null), i = Rt(!1);
  We(() => {
    i.current = !1;
    const s = (a) => {
      i.current = a.altKey;
    };
    return document.addEventListener("keydown", s), () => {
      document.removeEventListener("keydown", s);
    };
  }, [r]);
  const o = (s) => {
    r.dispatchCommand(zi, s), e();
  };
  return /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    !t && /* @__PURE__ */ L.jsxs(g1, { children: [
      /* @__PURE__ */ L.jsx(
        Ir,
        {
          "data-test-id": "image-modal-option-url",
          onClick: () => n("url"),
          children: "URL"
        }
      ),
      /* @__PURE__ */ L.jsx(
        Ir,
        {
          "data-test-id": "image-modal-option-file",
          onClick: () => n("file"),
          children: "File"
        }
      )
    ] }),
    t === "url" && /* @__PURE__ */ L.jsx(x1, { onClick: o }),
    t === "file" && /* @__PURE__ */ L.jsx(N1, { onClick: o })
  ] });
}
function _1({
  captionsEnabled: r
}) {
  const [e] = Ot.useLexicalComposerContext();
  return We(() => {
    if (!e.hasNodes([Jn]))
      throw new Error("ImagesPlugin: ImageNode not registered on editor");
    return ut.mergeRegister(
      e.registerCommand(
        zi,
        (t) => {
          const n = xs(t);
          return Ri([n]), Gn(n.getParentOrThrow()) && ut.$wrapNodeInElement(n, Gt).selectEnd(), !0;
        },
        Or
      ),
      e.registerCommand(
        bu,
        (t) => b1(t),
        cn
      ),
      e.registerCommand(
        hs,
        (t) => y1(t),
        qt
      ),
      e.registerCommand(
        fs,
        (t) => w1(t, e),
        cn
      )
    );
  }, [r, e]), null;
}
const C1 = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", ih = document.createElement("img");
ih.src = C1;
function b1(r) {
  const e = Xs();
  if (!e)
    return !1;
  const t = r.dataTransfer;
  return t ? (t.setData("text/plain", "_"), t.setDragImage(ih, 0, 0), t.setData(
    "application/x-lexical-drag",
    JSON.stringify({
      data: {
        altText: e.__altText,
        caption: e.__caption,
        height: e.__height,
        key: e.getKey(),
        maxWidth: e.__maxWidth,
        showCaption: e.__showCaption,
        src: e.__src,
        width: e.__width
      },
      type: "image"
    })
  ), !0) : !1;
}
function y1(r) {
  return Xs() ? (oh(r) || r.preventDefault(), !0) : !1;
}
function w1(r, e) {
  const t = Xs();
  if (!t)
    return !1;
  const n = T1(r);
  if (!n)
    return !1;
  if (r.preventDefault(), oh(r)) {
    const i = E1(r);
    t.remove();
    const o = yu();
    i != null && o.applyDOMRange(i), Wn(o), e.dispatchCommand(zi, n);
  }
  return !0;
}
function Xs() {
  const r = Nt();
  if (!cs(r))
    return null;
  const t = r.getNodes()[0];
  return Gf(t) ? t : null;
}
function T1(r) {
  var i;
  const e = (i = r.dataTransfer) == null ? void 0 : i.getData("application/x-lexical-drag");
  if (!e)
    return null;
  const { type: t, data: n } = JSON.parse(e);
  return t !== "image" ? null : n;
}
function oh(r) {
  const e = r.target;
  return !!(e && e instanceof HTMLElement && !e.closest("code, span.editor-image") && e.parentElement && e.parentElement.closest("div.content-editable__root"));
}
function E1(r) {
  let e;
  const t = r.target, n = t == null ? null : t.nodeType === 9 ? t.defaultView : t.ownerDocument.defaultView, i = v1(n);
  if (document.caretRangeFromPoint)
    e = document.caretRangeFromPoint(r.clientX, r.clientY);
  else if (r.rangeParent && i !== null)
    i.collapse(r.rangeParent, r.rangeOffset || 0), e = i.getRangeAt(0);
  else
    throw Error("Cannot get the selection when dragging");
  return e;
}
function S1({
  onClose: r,
  children: e,
  title: t,
  closeOnClickOutside: n
}) {
  const i = Rt(null);
  return We(() => {
    i.current !== null && i.current.focus();
  }, []), We(() => {
    let o = null;
    const s = (u) => {
      u.key === "Escape" && r();
    }, a = (u) => {
      const d = u.target;
      i.current !== null && !i.current.contains(d) && n && r();
    }, l = i.current;
    return l !== null && (o = l.parentElement, o !== null && o.addEventListener("click", a)), window.addEventListener("keydown", s), () => {
      window.removeEventListener("keydown", s), o !== null && (o == null || o.removeEventListener("click", a));
    };
  }, [n, r]), /* @__PURE__ */ L.jsx("div", { className: "Modal__overlay", role: "dialog", children: /* @__PURE__ */ L.jsxs("div", { className: "Modal__modal", tabIndex: -1, ref: i, children: [
    /* @__PURE__ */ L.jsx("h2", { className: "Modal__title", children: t }),
    /* @__PURE__ */ L.jsx(
      "button",
      {
        className: "Modal__closeButton",
        "aria-label": "Close modal",
        type: "button",
        onClick: r,
        children: "X"
      }
    ),
    /* @__PURE__ */ L.jsx("div", { className: "Modal__content", children: e })
  ] }) });
}
function O1({
  onClose: r,
  children: e,
  title: t,
  closeOnClickOutside: n = !1
}) {
  return Qr(
    /* @__PURE__ */ L.jsx(
      S1,
      {
        onClose: r,
        title: t,
        closeOnClickOutside: n,
        children: e
      }
    ),
    document.body
  );
}
function Do() {
  const [r, e] = Ie(null), t = ct(() => {
    e(null);
  }, []), n = Sr(() => {
    if (r === null)
      return null;
    const { title: o, content: s, closeOnClickOutside: a } = r;
    return /* @__PURE__ */ L.jsx(
      O1,
      {
        onClose: t,
        title: o,
        closeOnClickOutside: a,
        children: s
      }
    );
  }, [r, t]), i = ct(
    (o, s, a = !1) => {
      e({
        closeOnClickOutside: a,
        content: s(t),
        title: o
      });
    },
    [t]
  );
  return [n, i];
}
function M1({
  children: r,
  label: e,
  className: t,
  ...n
}) {
  return /* @__PURE__ */ L.jsxs("div", { className: "Input__wrapper", children: [
    /* @__PURE__ */ L.jsx("label", { style: { marginTop: "-1em" }, className: "Input__label", children: e }),
    /* @__PURE__ */ L.jsx("select", { ...n, className: t || "select", children: r })
  ] });
}
const R1 = (r) => ii ? (r || window).getSelection() : null, Js = mr("INSERT_INLINE_IMAGE_COMMAND");
function A1({
  activeEditor: r,
  onClose: e
}) {
  const t = Rt(!1), [n, i] = Ie(""), [o, s] = Ie(""), [a, l] = Ie(!1), [u, d] = Ie("left"), p = n === "", m = (N) => {
    l(N.target.checked);
  }, c = (N) => {
    d(N.target.value);
  }, h = (N) => {
    const v = new FileReader();
    v.onload = function() {
      return typeof v.result == "string" && i(v.result), "";
    }, N !== null && v.readAsDataURL(N[0]);
  };
  We(() => {
    t.current = !1;
    const N = (v) => {
      t.current = v.altKey;
    };
    return document.addEventListener("keydown", N), () => {
      document.removeEventListener("keydown", N);
    };
  }, [r]);
  const f = () => {
    const N = { altText: o, position: u, showCaption: a, src: n };
    r.dispatchCommand(Js, N), e();
  };
  return /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx("div", { style: { marginBottom: "1em" }, children: /* @__PURE__ */ L.jsx(
      rh,
      {
        label: "Image Upload",
        onChange: h,
        accept: "image/*",
        "data-test-id": "image-modal-file-upload"
      }
    ) }),
    /* @__PURE__ */ L.jsx("div", { style: { marginBottom: "1em" }, children: /* @__PURE__ */ L.jsx(
      fn,
      {
        label: "Alt Text",
        placeholder: "Descriptive alternative text",
        onChange: s,
        value: o,
        "data-test-id": "image-modal-alt-text-input"
      }
    ) }),
    /* @__PURE__ */ L.jsxs(
      M1,
      {
        style: { marginBottom: "1em", width: "290px" },
        label: "Position",
        name: "position",
        id: "position-select",
        onChange: c,
        children: [
          /* @__PURE__ */ L.jsx("option", { value: "left", children: "Left" }),
          /* @__PURE__ */ L.jsx("option", { value: "right", children: "Right" }),
          /* @__PURE__ */ L.jsx("option", { value: "full", children: "Full Width" })
        ]
      }
    ),
    /* @__PURE__ */ L.jsxs("div", { className: "Input__wrapper", children: [
      /* @__PURE__ */ L.jsx(
        "input",
        {
          id: "caption",
          className: "InlineImageNode_Checkbox",
          type: "checkbox",
          checked: a,
          onChange: m
        }
      ),
      /* @__PURE__ */ L.jsx("label", { htmlFor: "caption", children: "Show Caption" })
    ] }),
    /* @__PURE__ */ L.jsx(oi, { children: /* @__PURE__ */ L.jsx(
      Ir,
      {
        "data-test-id": "image-modal-file-upload-btn",
        disabled: p,
        onClick: () => f(),
        children: "Confirm"
      }
    ) })
  ] });
}
function L1() {
  const [r] = Ot.useLexicalComposerContext();
  return We(() => {
    if (!r.hasNodes([ni]))
      throw new Error("ImagesPlugin: ImageNode not registered on editor");
    return ut.mergeRegister(
      r.registerCommand(
        Js,
        (e) => {
          const t = Ws(e);
          return Ri([t]), Gn(t.getParentOrThrow()) && ut.$wrapNodeInElement(t, Gt).selectEnd(), !0;
        },
        Or
      ),
      r.registerCommand(
        bu,
        (e) => D1(e),
        cn
      ),
      r.registerCommand(
        hs,
        (e) => $1(e),
        qt
      ),
      r.registerCommand(
        fs,
        (e) => I1(e, r),
        cn
      )
    );
  }, [r]), null;
}
const k1 = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", ah = document.createElement("img");
ah.src = k1;
function D1(r) {
  const e = Zs();
  if (!e)
    return !1;
  const t = r.dataTransfer;
  return t ? (t.setData("text/plain", "_"), t.setDragImage(ah, 0, 0), t.setData(
    "application/x-lexical-drag",
    JSON.stringify({
      data: {
        altText: e.__altText,
        caption: e.__caption,
        height: e.__height,
        key: e.getKey(),
        showCaption: e.__showCaption,
        src: e.__src,
        width: e.__width
      },
      type: "image"
    })
  ), !0) : !1;
}
function $1(r) {
  return Zs() ? (sh(r) || r.preventDefault(), !0) : !1;
}
function I1(r, e) {
  const t = Zs();
  if (!t)
    return !1;
  const n = P1(r);
  if (!n)
    return !1;
  if (r.preventDefault(), sh(r)) {
    const i = F1(r);
    t.remove();
    const o = yu();
    i != null && o.applyDOMRange(i), Wn(o), e.dispatchCommand(Js, n);
  }
  return !0;
}
function Zs() {
  const r = Nt();
  if (!cs(r))
    return null;
  const t = r.getNodes()[0];
  return gp(t) ? t : null;
}
function P1(r) {
  var i;
  const e = (i = r.dataTransfer) == null ? void 0 : i.getData("application/x-lexical-drag");
  if (!e)
    return null;
  const { type: t, data: n } = JSON.parse(e);
  return t !== "image" ? null : n;
}
function sh(r) {
  const e = r.target;
  return !!(e && e instanceof HTMLElement && !e.closest("code, span.editor-image") && e.parentElement && e.parentElement.closest("div.content-editable__root"));
}
function F1(r) {
  let e;
  const t = r.target, n = t == null ? null : t.nodeType === 9 ? t.defaultView : t.ownerDocument.defaultView, i = R1(n);
  if (document.caretRangeFromPoint)
    e = document.caretRangeFromPoint(r.clientX, r.clientY);
  else if (r.rangeParent && i !== null)
    i.collapse(r.rangeParent, r.rangeOffset || 0), e = i.getRangeAt(0);
  else
    throw Error("Cannot get the selection when dragging");
  return e;
}
const Qs = mr(
  "INSERT_EXCALIDRAW_COMMAND"
);
function B1() {
  const [r] = Ot.useLexicalComposerContext();
  return We(() => {
    if (!r.hasNodes([Sn]))
      throw new Error(
        "ExcalidrawPlugin: ExcalidrawNode not registered on editor"
      );
    return r.registerCommand(
      Qs,
      () => {
        const e = Gd();
        return Ri([e]), Gn(e.getParentOrThrow()) && ut.$wrapNodeInElement(e, Gt).selectEnd(), !0;
      },
      Or
    );
  }, [r]), null;
}
function z1(r, e, ...t) {
  if (!r)
    throw new Error(
      "Internal Lexical error: invariant() is meant to be replaced at compile time. There is no runtime version. Error: " + e
    );
}
mr("INSERT_NEW_TABLE_COMMAND");
_u({
  cellEditorConfig: null,
  cellEditorPlugins: null,
  set: () => {
  }
});
function lh({
  activeEditor: r,
  onClose: e
}) {
  const [t, n] = Ie("5"), [i, o] = Ie("5"), [s, a] = Ie(!0);
  We(() => {
    const u = Number(t), d = Number(i);
    u && u > 0 && u <= 500 && d && d > 0 && d <= 50 ? a(!1) : a(!0);
  }, [t, i]);
  const l = () => {
    r.dispatchCommand(Ge.INSERT_TABLE_COMMAND, {
      columns: i,
      rows: t
    }), e();
  };
  return /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx(
      fn,
      {
        placeholder: "# of rows (1-500)",
        label: "Rows",
        onChange: n,
        value: t,
        "data-test-id": "table-modal-rows",
        type: "number"
      }
    ),
    /* @__PURE__ */ L.jsx(
      fn,
      {
        placeholder: "# of columns (1-50)",
        label: "Columns",
        onChange: o,
        value: i,
        "data-test-id": "table-modal-columns",
        type: "number"
      }
    ),
    /* @__PURE__ */ L.jsx(oi, { "data-test-id": "table-model-confirm-insert", children: /* @__PURE__ */ L.jsx(Ir, { disabled: s, onClick: l, children: "Confirm" }) })
  ] });
}
const ch = mr(
  "INSERT_POLL_COMMAND"
);
function uh({
  activeEditor: r,
  onClose: e
}) {
  const [t, n] = Ie(""), i = () => {
    r.dispatchCommand(ch, t), e();
  };
  return /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx(fn, { label: "Question", onChange: n, value: t }),
    /* @__PURE__ */ L.jsx(oi, { children: /* @__PURE__ */ L.jsx(Ir, { disabled: t.trim() === "", onClick: i, children: "Confirm" }) })
  ] });
}
function H1() {
  const [r] = Ot.useLexicalComposerContext();
  return We(() => {
    if (!r.hasNodes([ri]))
      throw new Error("PollPlugin: PollNode not registered on editor");
    return r.registerCommand(
      ch,
      (e) => {
        const t = Ys(e, [
          sc(),
          sc()
        ]);
        return Ri([t]), Gn(t.getParentOrThrow()) && ut.$wrapNodeInElement(t, Gt).selectEnd(), !0;
      },
      Or
    );
  }, [r]), null;
}
const dh = mr(), j1 = mr();
function q1() {
  const [r] = Ot.useLexicalComposerContext();
  return We(() => {
    if (!r.hasNodes([On, Mn]))
      throw new Error(
        "LayoutPlugin: LayoutContainerNode, or LayoutItemNode not registered on editor"
      );
    const e = (t) => {
      var i, o;
      const n = Nt();
      if (At(n) && n.isCollapsed() && n.anchor.offset === 0) {
        const s = ut.$findMatchingParent(
          n.anchor.getNode(),
          to
        );
        if (to(s)) {
          const a = s.getParent(), l = a && (t ? a.getFirstChild() : a == null ? void 0 : a.getLastChild()), u = t ? (i = s.getFirstDescendant()) == null ? void 0 : i.getKey() : (o = s.getLastDescendant()) == null ? void 0 : o.getKey();
          a !== null && l === s && n.anchor.key === u && (t ? s.insertBefore(Gt()) : s.insertAfter(Gt()));
        }
      }
      return !1;
    };
    return ut.mergeRegister(
      // When layout is the last child pressing down/right arrow will insert paragraph
      // below it to allow adding more content. It's similar what $insertBlockNode
      // (mainly for decorators), except it'll always be possible to continue adding
      // new content even if trailing paragraph is accidentally deleted
      r.registerCommand(
        wu,
        () => e(!1),
        qt
      ),
      r.registerCommand(
        Tu,
        () => e(!1),
        qt
      ),
      // When layout is the first child pressing up/left arrow will insert paragraph
      // above it to allow adding more content. It's similar what $insertBlockNode
      // (mainly for decorators), except it'll always be possible to continue adding
      // new content even if leading paragraph is accidentally deleted
      r.registerCommand(
        Eu,
        () => e(!0),
        qt
      ),
      r.registerCommand(
        Su,
        () => e(!0),
        qt
      ),
      r.registerCommand(
        dh,
        (t) => (r.update(() => {
          const n = Vd(t), i = Oa(t);
          for (let o = 0; o < i; o++)
            n.append(
              ns().append(Gt())
            );
          ut.$insertNodeToNearestRoot(n), n.selectStart();
        }), !0),
        Or
      ),
      r.registerCommand(
        j1,
        ({ template: t, nodeKey: n }) => (r.update(() => {
          const i = us(n);
          if (!to(i))
            return;
          const o = Oa(t), s = Oa(
            i.getTemplateColumns()
          );
          if (o > s)
            for (let a = s; a < o; a++)
              i.append(
                ns().append(Gt())
              );
          else if (o < s)
            for (let a = s - 1; a >= o; a--) {
              const l = i.getChildAtIndex(a);
              ac(l) && l.remove();
            }
          i.setTemplateColumns(t);
        }), !0),
        Or
      ),
      // Structure enforcing transformers for each node type. In case nesting structure is not
      // "Container > Item" it'll unwrap nodes and convert it back
      // to regular content.
      r.registerNodeTransform(Mn, (t) => {
        const n = t.getParent();
        if (!to(n)) {
          const i = t.getChildren();
          for (const o of i)
            t.insertBefore(o);
          t.remove();
        }
      }),
      r.registerNodeTransform(On, (t) => {
        const n = t.getChildren();
        if (!n.every(ac)) {
          for (const i of n)
            t.insertBefore(i);
          t.remove();
        }
      })
    );
  }, [r]), null;
}
function Oa(r) {
  return r.trim().split(/\s+/).length;
}
const Ma = [
  { label: "2 columns (equal width)", value: "1fr 1fr" },
  { label: "2 columns (25% - 75%)", value: "1fr 3fr" },
  { label: "3 columns (equal width)", value: "1fr 1fr 1fr" },
  { label: "3 columns (25% - 50% - 25%)", value: "1fr 2fr 1fr" },
  { label: "4 columns (equal width)", value: "1fr 1fr 1fr 1fr" }
];
function hh({
  activeEditor: r,
  onClose: e
}) {
  var s;
  const [t, n] = Ie(Ma[0].value), i = (s = Ma.find((a) => a.value === t)) == null ? void 0 : s.label, o = () => {
    r.dispatchCommand(dh, t), e();
  };
  return /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx(
      Rn,
      {
        buttonClassName: "toolbar-item dialog-dropdown",
        buttonLabel: i,
        children: Ma.map(({ label: a, value: l }) => /* @__PURE__ */ L.jsx(
          _t,
          {
            className: "item",
            onClick: () => n(l),
            children: /* @__PURE__ */ L.jsx("span", { className: "text", children: a })
          },
          l
        ))
      }
    ),
    /* @__PURE__ */ L.jsx(Ir, { onClick: o, children: "Insert" })
  ] });
}
function os(r, e) {
  return os = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, n) {
    return t.__proto__ = n, t;
  }, os(r, e);
}
function K1(r, e) {
  r.prototype = Object.create(e.prototype), r.prototype.constructor = r, os(r, e);
}
var U1 = function(e, t) {
  return e === void 0 && (e = []), t === void 0 && (t = []), e.length !== t.length || e.some(function(n, i) {
    return !Object.is(n, t[i]);
  });
}, qc = {
  error: null
}, Y1 = /* @__PURE__ */ function(r) {
  K1(e, r);
  function e() {
    for (var n, i = arguments.length, o = new Array(i), s = 0; s < i; s++)
      o[s] = arguments[s];
    return n = r.call.apply(r, [this].concat(o)) || this, n.state = qc, n.resetErrorBoundary = function() {
      for (var a, l = arguments.length, u = new Array(l), d = 0; d < l; d++)
        u[d] = arguments[d];
      n.props.onReset == null || (a = n.props).onReset.apply(a, u), n.reset();
    }, n;
  }
  e.getDerivedStateFromError = function(i) {
    return {
      error: i
    };
  };
  var t = e.prototype;
  return t.reset = function() {
    this.setState(qc);
  }, t.componentDidCatch = function(i, o) {
    var s, a;
    (s = (a = this.props).onError) == null || s.call(a, i, o);
  }, t.componentDidUpdate = function(i, o) {
    var s = this.state.error, a = this.props.resetKeys;
    if (s !== null && o.error !== null && U1(i.resetKeys, a)) {
      var l, u;
      (l = (u = this.props).onResetKeysChange) == null || l.call(u, i.resetKeys, a), this.reset();
    }
  }, t.render = function() {
    var i = this.state.error, o = this.props, s = o.fallbackRender, a = o.FallbackComponent, l = o.fallback;
    if (i !== null) {
      var u = {
        error: i,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (/* @__PURE__ */ hr.isValidElement(l))
        return l;
      if (typeof s == "function")
        return s(u);
      if (a)
        return /* @__PURE__ */ hr.createElement(a, u);
      throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
    }
    return this.props.children;
  }, e;
}(hr.Component);
function W1({
  equation: r,
  inline: e,
  onDoubleClick: t
}) {
  const n = Rt(null);
  return We(() => {
    const i = n.current;
    i !== null && Wd.render(r, i, {
      displayMode: !e,
      // true === block display //
      errorColor: "#cc0000",
      output: "html",
      strict: "warn",
      throwOnError: !1,
      trust: !1
    });
  }, [r, e]), // We use an empty image tag either side to ensure Android doesn't try and compose from the
  // inner text from Katex. There didn't seem to be any other way of making this work,
  // without having a physical space.
  /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx("img", { src: "#", alt: "" }),
    /* @__PURE__ */ L.jsx(
      "span",
      {
        role: "button",
        tabIndex: -1,
        onDoubleClick: t,
        ref: n
      }
    ),
    /* @__PURE__ */ L.jsx("img", { src: "#", alt: "" })
  ] });
}
function G1({
  onConfirm: r,
  initialEquation: e = ""
}) {
  const [t] = Ot.useLexicalComposerContext(), [n, i] = Ie(e), [o, s] = Ie(!0), a = ct(() => {
    r(n, o);
  }, [r, n, o]), l = ct(() => {
    s(!o);
  }, [s, o]);
  return /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsxs("div", { className: "KatexEquationAlterer_defaultRow", children: [
      "Inline",
      /* @__PURE__ */ L.jsx("input", { type: "checkbox", checked: o, onChange: l })
    ] }),
    /* @__PURE__ */ L.jsx("div", { className: "KatexEquationAlterer_defaultRow", children: "Equation " }),
    /* @__PURE__ */ L.jsx("div", { className: "KatexEquationAlterer_centerRow", children: o ? /* @__PURE__ */ L.jsx(
      "input",
      {
        onChange: (u) => {
          i(u.target.value);
        },
        value: n,
        className: "KatexEquationAlterer_textArea"
      }
    ) : /* @__PURE__ */ L.jsx(
      "textarea",
      {
        onChange: (u) => {
          i(u.target.value);
        },
        value: n,
        className: "KatexEquationAlterer_textArea"
      }
    ) }),
    /* @__PURE__ */ L.jsx("div", { className: "KatexEquationAlterer_defaultRow", children: "Visualization " }),
    /* @__PURE__ */ L.jsx("div", { className: "KatexEquationAlterer_centerRow", children: /* @__PURE__ */ L.jsx(Y1, { onError: (u) => t._onError(u), fallback: null, children: /* @__PURE__ */ L.jsx(
      W1,
      {
        equation: n,
        inline: !1,
        onDoubleClick: () => null
      }
    ) }) }),
    /* @__PURE__ */ L.jsx("div", { className: "KatexEquationAlterer_dialogActions", children: /* @__PURE__ */ L.jsx(Ir, { onClick: a, children: "Confirm" }) })
  ] });
}
const fh = mr("INSERT_EQUATION_COMMAND");
function mh({
  activeEditor: r,
  onClose: e
}) {
  const t = ct(
    (n, i) => {
      r.dispatchCommand(fh, { equation: n, inline: i }), e();
    },
    [r, e]
  );
  return /* @__PURE__ */ L.jsx(G1, { onConfirm: t });
}
function V1() {
  const [r] = Ot.useLexicalComposerContext();
  return We(() => {
    if (!r.hasNodes([ti]))
      throw new Error(
        "EquationsPlugins: EquationsNode not registered on editor"
      );
    return r.registerCommand(
      fh,
      (e) => {
        const { equation: t, inline: n } = e, i = Us(t, n);
        return Ri([i]), Gn(i.getParentOrThrow()) && ut.$wrapNodeInElement(i, Gt).selectEnd(), !0;
      },
      Or
    );
  }, [r]), null;
}
const el = mr();
mr();
function X1() {
  const [r] = Ot.useLexicalComposerContext();
  return We(() => {
    if (!r.hasNodes([
      wn,
      En,
      Tn
    ]))
      throw new Error(
        "CollapsiblePlugin: CollapsibleContainerNode, CollapsibleTitleNode, or CollapsibleContentNode not registered on editor"
      );
    const e = () => {
      var i;
      const n = Nt();
      if (At(n) && n.isCollapsed() && n.anchor.offset === 0) {
        const o = ut.$findMatchingParent(
          n.anchor.getNode(),
          Ur
        );
        if (Ur(o)) {
          const s = o.getParent();
          s !== null && s.getFirstChild() === o && n.anchor.key === ((i = o.getFirstDescendant()) == null ? void 0 : i.getKey()) && o.insertBefore(Gt());
        }
      }
      return !1;
    }, t = () => {
      const n = Nt();
      if (At(n) && n.isCollapsed()) {
        const i = ut.$findMatchingParent(
          n.anchor.getNode(),
          Ur
        );
        if (Ur(i)) {
          const o = i.getParent();
          if (o !== null && o.getLastChild() === i) {
            const s = i.getFirstDescendant(), a = i.getLastDescendant();
            (a !== null && n.anchor.key === a.getKey() && n.anchor.offset === a.getTextContentSize() || s !== null && n.anchor.key === s.getKey() && n.anchor.offset === s.getTextContentSize()) && i.insertAfter(Gt());
          }
        }
      }
      return !1;
    };
    return ut.mergeRegister(
      // Structure enforcing transformers for each node type. In case nesting structure is not
      // "Container > Title + Content" it'll unwrap nodes and convert it back
      // to regular content.
      r.registerNodeTransform(Tn, (n) => {
        const i = n.getParent();
        if (!Ur(i)) {
          const o = n.getChildren();
          for (const s of o)
            n.insertBefore(s);
          n.remove();
        }
      }),
      r.registerNodeTransform(En, (n) => {
        const i = n.getParent();
        if (!Ur(i)) {
          n.replace(
            Gt().append(...n.getChildren())
          );
          return;
        }
      }),
      r.registerNodeTransform(wn, (n) => {
        const i = n.getChildren();
        if (i.length !== 2 || !w0(i[0]) || !Ju(i[1])) {
          for (const o of i)
            n.insertBefore(o);
          n.remove();
        }
      }),
      // This handles the case when container is collapsed and we delete its previous sibling
      // into it, it would cause collapsed content deleted (since it's display: none, and selection
      // swallows it when deletes single char). Instead we expand container, which is although
      // not perfect, but avoids bigger problem
      r.registerCommand(
        Lh,
        () => {
          const n = Nt();
          if (!At(n) || !n.isCollapsed() || n.anchor.offset !== 0)
            return !1;
          const o = n.anchor.getNode().getTopLevelElement();
          if (o === null)
            return !1;
          const s = o.getPreviousSibling();
          return !Ur(s) || s.getOpen() ? !1 : (s.setOpen(!0), !0);
        },
        qt
      ),
      // When collapsible is the last child pressing down/right arrow will insert paragraph
      // below it to allow adding more content. It's similar what $insertBlockNode
      // (mainly for decorators), except it'll always be possible to continue adding
      // new content even if trailing paragraph is accidentally deleted
      r.registerCommand(
        wu,
        t,
        qt
      ),
      r.registerCommand(
        Tu,
        t,
        qt
      ),
      // When collapsible is the first child pressing up/left arrow will insert paragraph
      // above it to allow adding more content. It's similar what $insertBlockNode
      // (mainly for decorators), except it'll always be possible to continue adding
      // new content even if leading paragraph is accidentally deleted
      r.registerCommand(
        Eu,
        e,
        qt
      ),
      r.registerCommand(
        Su,
        e,
        qt
      ),
      // Handling CMD+Enter to toggle collapsible element collapsed state
      r.registerCommand(
        kh,
        () => {
          var i;
          const n = (i = r._window) == null ? void 0 : i.event;
          if (n && (n.ctrlKey || n.metaKey) && n.key === "Enter") {
            const o = Dh();
            if (At(o) && o.isCollapsed()) {
              const s = ut.$findMatchingParent(
                o.anchor.getNode(),
                (a) => yn(a) && !a.isInline()
              );
              if (w0(s)) {
                const a = s.getParent();
                if (Ur(a))
                  return a.toggleOpen(), Wn(o.clone()), !0;
              }
            }
          }
          return !1;
        },
        qt
      ),
      r.registerCommand(
        el,
        () => (r.update(() => {
          const n = ws(), i = Gt();
          ut.$insertNodeToNearestRoot(
            bs(!0).append(
              n.append(i),
              ys().append(Gt())
            )
          ), i.select();
        }), !0),
        qt
      )
    );
  }, [r]), null;
}
var Bn = {}, lo = {}, Kc;
function J1() {
  if (Kc) return lo;
  Kc = 1;
  var r = lt(), e = Ve, t = nt, n = it(), s = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  class a {
    constructor(x) {
      this.key = x, this.ref = {
        current: null
      }, this.setRefElement = this.setRefElement.bind(this);
    }
    setRefElement(x) {
      this.ref = {
        current: x
      };
    }
  }
  const l = (g) => {
    const x = document.getElementById("typeahead-menu");
    if (!x) return;
    const b = x.getBoundingClientRect();
    b.top + b.height > window.innerHeight && x.scrollIntoView({
      block: "center"
    }), b.top < 0 && x.scrollIntoView({
      block: "center"
    }), g.scrollIntoView({
      block: "nearest"
    });
  };
  function u(g, x, b) {
    let A = b;
    for (let w = A; w <= x.length; w++)
      g.substr(-w) === x.substr(0, w) && (A = w);
    return A;
  }
  function d(g) {
    const x = e.$getSelection();
    if (!e.$isRangeSelection(x) || !x.isCollapsed())
      return null;
    const b = x.anchor;
    if (b.type !== "text")
      return null;
    const A = b.getNode();
    if (!A.isSimpleText())
      return null;
    const w = b.offset, M = A.getTextContent().slice(0, w), y = g.replaceableString.length, E = u(M, g.matchingString, y), S = w - E;
    if (S < 0)
      return null;
    let P;
    return S === 0 ? [P] = A.splitText(w) : [, P] = A.splitText(S, w), P;
  }
  function p(g, x) {
    let b = getComputedStyle(g);
    const A = b.position === "absolute", w = /(auto|scroll)/;
    if (b.position === "fixed")
      return document.body;
    for (let M = g; M = M.parentElement; )
      if (b = getComputedStyle(M), !(A && b.position === "static") && w.test(b.overflow + b.overflowY + b.overflowX))
        return M;
    return document.body;
  }
  function m(g, x) {
    const b = g.getBoundingClientRect(), A = x.getBoundingClientRect();
    return b.top > A.top && b.top < A.bottom;
  }
  function c(g, x, b, A) {
    const [w] = r.useLexicalComposerContext();
    t.useEffect(() => {
      if (x != null && g != null) {
        const M = w.getRootElement(), y = M != null ? p(M) : document.body;
        let E = !1, S = m(x, y);
        const P = function() {
          E || (window.requestAnimationFrame(function() {
            b(), E = !1;
          }), E = !0);
          const j = m(x, y);
          j !== S && (S = j, A != null && A(j));
        }, U = new ResizeObserver(b);
        return window.addEventListener("resize", b), document.addEventListener("scroll", P, {
          capture: !0,
          passive: !0
        }), U.observe(x), () => {
          U.unobserve(x), window.removeEventListener("resize", b), document.removeEventListener("scroll", P, !0);
        };
      }
    }, [x, w, A, b, g]);
  }
  const h = e.createCommand("SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND");
  function f({
    close: g,
    editor: x,
    anchorElementRef: b,
    resolution: A,
    options: w,
    menuRenderFn: M,
    onSelectOption: y,
    shouldSplitNodeWithQuery: E = !1,
    commandPriority: S = e.COMMAND_PRIORITY_LOW
  }) {
    const [P, U] = t.useState(null), j = A.match && A.match.matchingString;
    t.useEffect(() => {
      U(0);
    }, [j]);
    const H = t.useCallback(($) => {
      x.update(() => {
        const G = A.match != null && E ? d(A.match) : null;
        y($, G, g, A.match ? A.match.matchingString : "");
      });
    }, [x, E, A.match, y, g]), R = t.useCallback(($) => {
      const G = x.getRootElement();
      G !== null && (G.setAttribute("aria-activedescendant", "typeahead-item-" + $), U($));
    }, [x]);
    t.useEffect(() => () => {
      const $ = x.getRootElement();
      $ !== null && $.removeAttribute("aria-activedescendant");
    }, [x]), s(() => {
      w === null ? U(null) : P === null && R(0);
    }, [w, P, R]), t.useEffect(() => n.mergeRegister(x.registerCommand(h, ({
      option: $
    }) => $.ref && $.ref.current != null ? (l($.ref.current), !0) : !1, S)), [x, R, S]), t.useEffect(() => n.mergeRegister(x.registerCommand(e.KEY_ARROW_DOWN_COMMAND, ($) => {
      const G = $;
      if (w !== null && w.length && P !== null) {
        const q = P !== w.length - 1 ? P + 1 : 0;
        R(q);
        const I = w[q];
        I.ref != null && I.ref.current && x.dispatchCommand(h, {
          index: q,
          option: I
        }), G.preventDefault(), G.stopImmediatePropagation();
      }
      return !0;
    }, S), x.registerCommand(e.KEY_ARROW_UP_COMMAND, ($) => {
      const G = $;
      if (w !== null && w.length && P !== null) {
        const q = P !== 0 ? P - 1 : w.length - 1;
        R(q);
        const I = w[q];
        I.ref != null && I.ref.current && l(I.ref.current), G.preventDefault(), G.stopImmediatePropagation();
      }
      return !0;
    }, S), x.registerCommand(e.KEY_ESCAPE_COMMAND, ($) => {
      const G = $;
      return G.preventDefault(), G.stopImmediatePropagation(), g(), !0;
    }, S), x.registerCommand(e.KEY_TAB_COMMAND, ($) => {
      const G = $;
      return w === null || P === null || w[P] == null ? !1 : (G.preventDefault(), G.stopImmediatePropagation(), H(w[P]), !0);
    }, S), x.registerCommand(e.KEY_ENTER_COMMAND, ($) => w === null || P === null || w[P] == null ? !1 : ($ !== null && ($.preventDefault(), $.stopImmediatePropagation()), H(w[P]), !0), S)), [H, g, x, w, P, R, S]);
    const T = t.useMemo(() => ({
      options: w,
      selectOptionAndCleanUp: H,
      selectedIndex: P,
      setHighlightedIndex: U
    }), [H, P, w]);
    return M(b, T, A.match ? A.match.matchingString : "");
  }
  function N(g, x, b, A = document.body) {
    const [w] = r.useLexicalComposerContext(), M = t.useRef(document.createElement("div")), y = t.useCallback(() => {
      M.current.style.top = M.current.style.bottom;
      const S = w.getRootElement(), P = M.current, U = P.firstChild;
      if (S !== null && g !== null) {
        const {
          left: j,
          top: H,
          width: R,
          height: T
        } = g.getRect(), $ = M.current.offsetHeight;
        if (P.style.top = `${H + window.pageYOffset + $ + 3}px`, P.style.left = `${j + window.pageXOffset}px`, P.style.height = `${T}px`, P.style.width = `${R}px`, U !== null) {
          U.style.top = `${H}`;
          const G = U.getBoundingClientRect(), q = G.height, I = G.width, Y = S.getBoundingClientRect();
          j + I > Y.right && (P.style.left = `${Y.right - I + window.pageXOffset}px`), (H + q > window.innerHeight || H + q > Y.bottom) && H - Y.top > q && (P.style.top = `${H - q + window.pageYOffset - T}px`);
        }
        P.isConnected || (b != null && (P.className = b), P.setAttribute("aria-label", "Typeahead menu"), P.setAttribute("id", "typeahead-menu"), P.setAttribute("role", "listbox"), P.style.display = "block", P.style.position = "absolute", A.append(P)), M.current = P, S.setAttribute("aria-controls", "typeahead-menu");
      }
    }, [w, g, b, A]);
    t.useEffect(() => {
      const S = w.getRootElement();
      if (g !== null)
        return y(), () => {
          S !== null && S.removeAttribute("aria-controls");
          const P = M.current;
          P !== null && P.isConnected && P.remove();
        };
    }, [w, y, g]);
    const E = t.useCallback((S) => {
      g !== null && (S || x(null));
    }, [g, x]);
    return c(g, M.current, y, E), M;
  }
  function v(g) {
    t.startTransition ? t.startTransition(g) : g();
  }
  function C({
    options: g,
    nodeKey: x,
    onClose: b,
    onOpen: A,
    onSelectOption: w,
    menuRenderFn: M,
    anchorClassName: y,
    commandPriority: E = e.COMMAND_PRIORITY_LOW,
    parent: S
  }) {
    const [P] = r.useLexicalComposerContext(), [U, j] = t.useState(null), H = N(U, j, y, S), R = t.useCallback(() => {
      j(null), b != null && U !== null && b();
    }, [b, U]), T = t.useCallback((G) => {
      j(G), A != null && U === null && A(G);
    }, [A, U]), $ = t.useCallback(() => {
      x ? P.update(() => {
        const G = e.$getNodeByKey(x), q = P.getElementByKey(x);
        G != null && q != null && U == null && v(() => T({
          getRect: () => q.getBoundingClientRect()
        }));
      }) : x == null && U != null && R();
    }, [R, P, x, T, U]);
    return t.useEffect(() => {
      $();
    }, [$, x]), t.useEffect(() => {
      if (x != null)
        return P.registerUpdateListener(({
          dirtyElements: G
        }) => {
          G.get(x) && $();
        });
    }, [P, $, x]), U === null || P === null ? null : /* @__PURE__ */ t.createElement(f, {
      close: R,
      resolution: U,
      editor: P,
      anchorElementRef: H,
      options: g,
      menuRenderFn: M,
      onSelectOption: w,
      commandPriority: E
    });
  }
  return lo.LexicalNodeMenuPlugin = C, lo.MenuOption = a, lo;
}
var co = {}, Uc;
function Z1() {
  if (Uc) return co;
  Uc = 1;
  var r = lt(), e = Ve, t = nt, n = it(), i = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  class o {
    constructor(N) {
      this.key = N, this.ref = { current: null }, this.setRefElement = this.setRefElement.bind(this);
    }
    setRefElement(N) {
      this.ref = { current: N };
    }
  }
  let s = (f) => {
    const N = document.getElementById("typeahead-menu");
    if (N) {
      var v = N.getBoundingClientRect();
      v.top + v.height > window.innerHeight && N.scrollIntoView({ block: "center" }), 0 > v.top && N.scrollIntoView({ block: "center" }), f.scrollIntoView({ block: "nearest" });
    }
  };
  function a(f) {
    var N = e.$getSelection();
    if (!e.$isRangeSelection(N) || !N.isCollapsed()) return null;
    var v = N.anchor;
    if (v.type !== "text" || (N = v.getNode(), !N.isSimpleText())) return null;
    v = v.offset;
    let C = N.getTextContent().slice(0, v);
    var g = f.matchingString;
    f = f.replaceableString.length;
    for (let b = f; b <= g.length; b++) C.substr(-b) === g.substr(0, b) && (f = b);
    if (f = v - f, 0 > f) return null;
    let x;
    return f === 0 ? [x] = N.splitText(v) : [, x] = N.splitText(f, v), x;
  }
  function l(f, N) {
    let v = getComputedStyle(f), C = v.position === "absolute";
    if (N = N ? /(auto|scroll|hidden)/ : /(auto|scroll)/, v.position === "fixed") return document.body;
    for (; f = f.parentElement; ) if (v = getComputedStyle(f), (!C || v.position !== "static") && N.test(v.overflow + v.overflowY + v.overflowX)) return f;
    return document.body;
  }
  function u(f, N) {
    return f = f.getBoundingClientRect(), N = N.getBoundingClientRect(), f.top > N.top && f.top < N.bottom;
  }
  function d(f, N, v, C) {
    let [g] = r.useLexicalComposerContext();
    t.useEffect(() => {
      if (N != null && f != null) {
        let x = g.getRootElement(), b = x != null ? l(x, !1) : document.body, A = !1, w = u(N, b), M = function() {
          A || (window.requestAnimationFrame(function() {
            v(), A = !1;
          }), A = !0);
          const E = u(N, b);
          E !== w && (w = E, C != null && C(E));
        }, y = new ResizeObserver(v);
        return window.addEventListener("resize", v), document.addEventListener("scroll", M, { capture: !0, passive: !0 }), y.observe(N), () => {
          y.unobserve(N), window.removeEventListener("resize", v), document.removeEventListener(
            "scroll",
            M,
            !0
          );
        };
      }
    }, [N, g, C, v, f]);
  }
  let p = e.createCommand("SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND");
  function m({ close: f, editor: N, anchorElementRef: v, resolution: C, options: g, menuRenderFn: x, onSelectOption: b, shouldSplitNodeWithQuery: A = !1, commandPriority: w = e.COMMAND_PRIORITY_LOW }) {
    let [M, y] = t.useState(null);
    t.useEffect(() => {
      y(0);
    }, [C.match && C.match.matchingString]);
    let E = t.useCallback((U) => {
      N.update(() => {
        const j = C.match != null && A ? a(C.match) : null;
        b(U, j, f, C.match ? C.match.matchingString : "");
      });
    }, [N, A, C.match, b, f]), S = t.useCallback((U) => {
      const j = N.getRootElement();
      j !== null && (j.setAttribute(
        "aria-activedescendant",
        "typeahead-item-" + U
      ), y(U));
    }, [N]);
    t.useEffect(() => () => {
      let U = N.getRootElement();
      U !== null && U.removeAttribute("aria-activedescendant");
    }, [N]), i(() => {
      g === null ? y(null) : M === null && S(0);
    }, [g, M, S]), t.useEffect(() => n.mergeRegister(N.registerCommand(p, ({ option: U }) => U.ref && U.ref.current != null ? (s(U.ref.current), !0) : !1, w)), [N, S, w]), t.useEffect(() => n.mergeRegister(N.registerCommand(e.KEY_ARROW_DOWN_COMMAND, (U) => {
      if (g !== null && g.length && M !== null) {
        let j = M !== g.length - 1 ? M + 1 : 0;
        S(j);
        let H = g[j];
        H.ref != null && H.ref.current && N.dispatchCommand(p, { index: j, option: H }), U.preventDefault(), U.stopImmediatePropagation();
      }
      return !0;
    }, w), N.registerCommand(e.KEY_ARROW_UP_COMMAND, (U) => {
      if (g !== null && g.length && M !== null) {
        var j = M !== 0 ? M - 1 : g.length - 1;
        S(j), j = g[j], j.ref != null && j.ref.current && s(j.ref.current), U.preventDefault(), U.stopImmediatePropagation();
      }
      return !0;
    }, w), N.registerCommand(e.KEY_ESCAPE_COMMAND, (U) => (U.preventDefault(), U.stopImmediatePropagation(), f(), !0), w), N.registerCommand(e.KEY_TAB_COMMAND, (U) => g === null || M === null || g[M] == null ? !1 : (U.preventDefault(), U.stopImmediatePropagation(), E(g[M]), !0), w), N.registerCommand(e.KEY_ENTER_COMMAND, (U) => g === null || M === null || g[M] == null ? !1 : (U !== null && (U.preventDefault(), U.stopImmediatePropagation()), E(g[M]), !0), w)), [E, f, N, g, M, S, w]);
    let P = t.useMemo(() => ({ options: g, selectOptionAndCleanUp: E, selectedIndex: M, setHighlightedIndex: y }), [E, M, g]);
    return x(v, P, C.match ? C.match.matchingString : "");
  }
  function c(f, N, v, C = document.body) {
    let [g] = r.useLexicalComposerContext(), x = t.useRef(document.createElement("div")), b = t.useCallback(
      () => {
        x.current.style.top = x.current.style.bottom;
        const w = g.getRootElement(), M = x.current;
        var y = M.firstChild;
        if (w !== null && f !== null) {
          const { left: S, top: P, width: U, height: j } = f.getRect();
          if (M.style.top = `${P + window.pageYOffset + x.current.offsetHeight + 3}px`, M.style.left = `${S + window.pageXOffset}px`, M.style.height = `${j}px`, M.style.width = `${U}px`, y !== null) {
            y.style.top = `${P}`;
            var E = y.getBoundingClientRect();
            y = E.height, E = E.width;
            const H = w.getBoundingClientRect();
            S + E > H.right && (M.style.left = `${H.right - E + window.pageXOffset}px`), (P + y > window.innerHeight || P + y > H.bottom) && P - H.top > y && (M.style.top = `${P - y + window.pageYOffset - j}px`);
          }
          M.isConnected || (v != null && (M.className = v), M.setAttribute("aria-label", "Typeahead menu"), M.setAttribute("id", "typeahead-menu"), M.setAttribute("role", "listbox"), M.style.display = "block", M.style.position = "absolute", C.append(M)), x.current = M, w.setAttribute("aria-controls", "typeahead-menu");
        }
      },
      [g, f, v, C]
    );
    t.useEffect(() => {
      let w = g.getRootElement();
      if (f !== null) return b(), () => {
        w !== null && w.removeAttribute("aria-controls");
        let M = x.current;
        M !== null && M.isConnected && M.remove();
      };
    }, [g, b, f]);
    let A = t.useCallback((w) => {
      f !== null && (w || N(null));
    }, [f, N]);
    return d(f, x.current, b, A), x;
  }
  function h(f) {
    t.startTransition ? t.startTransition(f) : f();
  }
  return co.LexicalNodeMenuPlugin = function({ options: f, nodeKey: N, onClose: v, onOpen: C, onSelectOption: g, menuRenderFn: x, anchorClassName: b, commandPriority: A = e.COMMAND_PRIORITY_LOW, parent: w }) {
    let [M] = r.useLexicalComposerContext(), [y, E] = t.useState(null);
    b = c(y, E, b, w);
    let S = t.useCallback(() => {
      E(null), v != null && y !== null && v();
    }, [v, y]), P = t.useCallback((j) => {
      E(j), C != null && y === null && C(j);
    }, [C, y]), U = t.useCallback(() => {
      N ? M.update(() => {
        const j = e.$getNodeByKey(N), H = M.getElementByKey(N);
        j != null && H != null && y == null && h(() => P({ getRect: () => H.getBoundingClientRect() }));
      }) : N == null && y != null && S();
    }, [S, M, N, P, y]);
    return t.useEffect(() => {
      U();
    }, [U, N]), t.useEffect(() => {
      if (N != null) return M.registerUpdateListener(({ dirtyElements: j }) => {
        j.get(N) && U();
      });
    }, [M, U, N]), y === null || M === null ? null : t.createElement(m, { close: S, resolution: y, editor: M, anchorElementRef: b, options: f, menuRenderFn: x, onSelectOption: g, commandPriority: A });
  }, co.MenuOption = o, co;
}
var Ra, Yc;
function gh() {
  return Yc || (Yc = 1, Ra = process.env.NODE_ENV === "development" ? J1() : Z1()), Ra;
}
var Wc;
function Q1() {
  if (Wc) return Bn;
  Wc = 1;
  var r = St, e = lt(), t = gh(), n = it(), i = Ve, o = nt;
  const s = /((https?:\/\/(www\.)?)|(www\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/, a = i.createCommand("INSERT_EMBED_COMMAND");
  class l extends t.MenuOption {
    constructor(p, m) {
      super(p), this.title = p, this.onSelect = m.onSelect.bind(this);
    }
  }
  function u({
    embedConfigs: d,
    onOpenEmbedModalForConfig: p,
    getMenuOptions: m,
    menuRenderFn: c,
    menuCommandPriority: h = i.COMMAND_PRIORITY_LOW
  }) {
    const [f] = e.useLexicalComposerContext(), [N, v] = o.useState(null), [C, g] = o.useState(null), x = o.useCallback(() => {
      v(null), g(null);
    }, []), b = o.useCallback((y) => {
      f.getEditorState().read(async () => {
        const E = i.$getNodeByKey(y);
        if (r.$isLinkNode(E))
          for (let S = 0; S < d.length; S++) {
            const P = d[S];
            await Promise.resolve(P.parseUrl(E.__url)) != null && (g(P), v(E.getKey()));
          }
      });
    }, [f, d]);
    o.useEffect(() => {
      const y = (E, {
        updateTags: S,
        dirtyLeaves: P
      }) => {
        for (const [U, j] of E)
          j === "created" && S.has("paste") && P.size <= 3 ? b(U) : U === N && x();
      };
      return n.mergeRegister(...[r.LinkNode, r.AutoLinkNode].map((E) => f.registerMutationListener(E, (...S) => y(...S))));
    }, [b, f, d, N, x]), o.useEffect(() => f.registerCommand(a, (y) => {
      const E = d.find(({
        type: S
      }) => S === y);
      return E ? (p(E), !0) : !1;
    }, i.COMMAND_PRIORITY_EDITOR), [f, d, p]);
    const A = o.useCallback(async () => {
      if (C != null && N != null) {
        const y = f.getEditorState().read(() => {
          const E = i.$getNodeByKey(N);
          return r.$isLinkNode(E) ? E : null;
        });
        if (r.$isLinkNode(y)) {
          const E = await Promise.resolve(C.parseUrl(y.__url));
          E != null && f.update(() => {
            i.$getSelection() || y.selectEnd(), C.insertNode(f, E), y.isAttached() && y.remove();
          });
        }
      }
    }, [C, f, N]), w = o.useMemo(() => C != null && N != null ? m(C, A, x) : [], [C, A, m, N, x]), M = o.useCallback((y, E, S) => {
      f.update(() => {
        y.onSelect(E), S();
      });
    }, [f]);
    return N != null ? /* @__PURE__ */ o.createElement(t.LexicalNodeMenuPlugin, {
      nodeKey: N,
      onClose: x,
      onSelectOption: M,
      options: w,
      menuRenderFn: c,
      commandPriority: h
    }) : null;
  }
  return Bn.AutoEmbedOption = l, Bn.INSERT_EMBED_COMMAND = a, Bn.LexicalAutoEmbedPlugin = u, Bn.URL_MATCHER = s, Bn;
}
var zn = {}, Gc;
function e4() {
  if (Gc) return zn;
  Gc = 1;
  var r = St, e = lt(), t = gh(), n = it(), i = Ve, o = nt;
  let s = i.createCommand("INSERT_EMBED_COMMAND");
  class a extends t.MenuOption {
    constructor(u, d) {
      super(u), this.title = u, this.onSelect = d.onSelect.bind(this);
    }
  }
  return zn.AutoEmbedOption = a, zn.INSERT_EMBED_COMMAND = s, zn.LexicalAutoEmbedPlugin = function({ embedConfigs: l, onOpenEmbedModalForConfig: u, getMenuOptions: d, menuRenderFn: p, menuCommandPriority: m = i.COMMAND_PRIORITY_LOW }) {
    let [c] = e.useLexicalComposerContext(), [h, f] = o.useState(null), [N, v] = o.useState(null), C = o.useCallback(() => {
      f(null), v(null);
    }, []), g = o.useCallback(
      (w) => {
        c.getEditorState().read(async () => {
          const M = i.$getNodeByKey(w);
          if (r.$isLinkNode(M)) for (let y = 0; y < l.length; y++) {
            const E = l[y];
            await Promise.resolve(E.parseUrl(M.__url)) != null && (v(E), f(M.getKey()));
          }
        });
      },
      [c, l]
    );
    o.useEffect(() => {
      let w = (M, { updateTags: y, dirtyLeaves: E }) => {
        for (const [S, P] of M) P === "created" && y.has("paste") && 3 >= E.size ? g(S) : S === h && C();
      };
      return n.mergeRegister(...[r.LinkNode, r.AutoLinkNode].map((M) => c.registerMutationListener(M, (...y) => w(...y))));
    }, [g, c, l, h, C]), o.useEffect(() => c.registerCommand(s, (w) => {
      let M = l.find(({ type: y }) => y === w);
      return M ? (u(M), !0) : !1;
    }, i.COMMAND_PRIORITY_EDITOR), [c, l, u]);
    let x = o.useCallback(async () => {
      if (N != null && h != null) {
        const w = c.getEditorState().read(() => {
          const M = i.$getNodeByKey(h);
          return r.$isLinkNode(M) ? M : null;
        });
        if (r.$isLinkNode(w)) {
          const M = await Promise.resolve(N.parseUrl(w.__url));
          M != null && c.update(() => {
            i.$getSelection() || w.selectEnd(), N.insertNode(c, M), w.isAttached() && w.remove();
          });
        }
      }
    }, [N, c, h]), b = o.useMemo(() => N != null && h != null ? d(N, x, C) : [], [N, x, d, h, C]), A = o.useCallback((w, M, y) => {
      c.update(() => {
        w.onSelect(M), y();
      });
    }, [c]);
    return h != null ? o.createElement(t.LexicalNodeMenuPlugin, { nodeKey: h, onClose: C, onSelectOption: A, options: b, menuRenderFn: p, commandPriority: m }) : null;
  }, zn.URL_MATCHER = /((https?:\/\/(www\.)?)|(www\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/, zn;
}
const t4 = process.env.NODE_ENV === "development" ? Q1() : e4();
var jn = t4;
const ph = mr(
  "INSERT_FIGMA_COMMAND"
);
function r4() {
  const [r] = Ot.useLexicalComposerContext();
  return We(() => {
    if (!r.hasNodes([Di]))
      throw new Error("FigmaPlugin: FigmaNode not registered on editor");
    return r.registerCommand(
      ph,
      (e) => {
        const t = Xu(e);
        return ut.$insertNodeToNearestRoot(t), !0;
      },
      Or
    );
  }, [r]), null;
}
const vh = mr(
  "INSERT_TWEET_COMMAND"
);
function n4() {
  const [r] = Ot.useLexicalComposerContext();
  return We(() => {
    if (!r.hasNodes([$i]))
      throw new Error("TwitterPlugin: TweetNode not registered on editor");
    return r.registerCommand(
      vh,
      (e) => {
        const t = _s(e);
        return ut.$insertNodeToNearestRoot(t), !0;
      },
      Or
    );
  }, [r]), null;
}
const xh = mr(
  "INSERT_YOUTUBE_COMMAND"
);
function i4() {
  const [r] = Ot.useLexicalComposerContext();
  return We(() => {
    if (!r.hasNodes([Ii]))
      throw new Error("YouTubePlugin: YouTubeNode not registered on editor");
    return r.registerCommand(
      xh,
      (e) => {
        const t = Cs(e);
        return ut.$insertNodeToNearestRoot(t), !0;
      },
      Or
    );
  }, [r]), null;
}
const o4 = {
  contentName: "Youtube Video",
  exampleUrl: "https://www.youtube.com/watch?v=jNQXAC9IVRw",
  // Icon for display.
  icon: /* @__PURE__ */ L.jsx("i", { className: "icon youtube" }),
  insertNode: (r, e) => {
    r.dispatchCommand(xh, e.id);
  },
  keywords: ["youtube", "video"],
  // Determine if a given URL is a match and return url data.
  parseUrl: async (r) => {
    const e = /^.*(youtu\.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/.exec(r), t = e && (e == null ? void 0 : e[2].length) === 11 ? e[2] : null;
    return t != null ? {
      id: t,
      url: r
    } : null;
  },
  type: "youtube-video"
}, a4 = {
  // e.g. Tweet or Google Map.
  contentName: "Tweet",
  exampleUrl: "https://twitter.com/jack/status/20",
  // Icon for display.
  icon: /* @__PURE__ */ L.jsx("i", { className: "icon tweet" }),
  // Create the Lexical embed node from the url data.
  insertNode: (r, e) => {
    r.dispatchCommand(vh, e.id);
  },
  // For extra searching.
  keywords: ["tweet", "twitter"],
  // Determine if a given URL is a match and return url data.
  parseUrl: (r) => {
    const e = /^https:\/\/(twitter|x)\.com\/(#!\/)?(\w+)\/status(es)*\/(\d+)/.exec(
      r
    );
    return e != null ? {
      id: e[5],
      url: e[1]
    } : null;
  },
  type: "tweet"
}, s4 = {
  contentName: "Figma Document",
  exampleUrl: "https://www.figma.com/file/LKQ4FJ4bTnCSjedbRpk931/Sample-File",
  icon: /* @__PURE__ */ L.jsx("i", { className: "icon figma" }),
  insertNode: (r, e) => {
    r.dispatchCommand(ph, e.id);
  },
  keywords: ["figma", "figma.com", "mock-up"],
  // Determine if a given URL is a match and return url data.
  parseUrl: (r) => {
    const e = /https:\/\/([\w.-]+\.)?figma.com\/(file|proto)\/([0-9a-zA-Z]{22,128})(?:\/.*)?$/.exec(
      r
    );
    return e != null ? {
      id: e[3],
      url: e[0]
    } : null;
  },
  type: "figma"
}, tl = [
  a4,
  o4,
  s4
];
function l4({
  index: r,
  isSelected: e,
  onClick: t,
  onMouseEnter: n,
  option: i
}) {
  let o = "item";
  return e && (o += " selected"), /* @__PURE__ */ L.jsx(
    "li",
    {
      tabIndex: -1,
      className: o,
      ref: i.setRefElement,
      role: "option",
      "aria-selected": e,
      id: "typeahead-item-" + r,
      onMouseEnter: n,
      onClick: t,
      children: /* @__PURE__ */ L.jsx("span", { className: "text", children: i.title })
    },
    i.key
  );
}
function c4({
  options: r,
  selectedItemIndex: e,
  onOptionClick: t,
  onOptionMouseEnter: n
}) {
  return /* @__PURE__ */ L.jsx("div", { className: "typeahead-popover", children: /* @__PURE__ */ L.jsx("ul", { children: r.map((i, o) => /* @__PURE__ */ L.jsx(
    l4,
    {
      index: o,
      isSelected: e === o,
      onClick: () => t(i, o),
      onMouseEnter: () => n(o),
      option: i
    },
    i.key
  )) }) });
}
const u4 = (r, e) => {
  let t;
  return (n) => {
    window.clearTimeout(t), t = window.setTimeout(() => {
      r(n);
    }, e);
  };
};
function d4({
  embedConfig: r,
  onClose: e
}) {
  const [t, n] = Ie(""), [i] = Ot.useLexicalComposerContext(), [o, s] = Ie(null), a = Sr(
    () => u4((u) => {
      const d = jn.URL_MATCHER.exec(u);
      r != null && u != null && d != null ? Promise.resolve(r.parseUrl(u)).then(
        (p) => {
          s(p);
        }
      ) : o != null && s(null);
    }, 200),
    [r, o]
  ), l = () => {
    o != null && (r.insertNode(i, o), e());
  };
  return /* @__PURE__ */ L.jsxs("div", { style: { width: "600px" }, children: [
    /* @__PURE__ */ L.jsx("div", { className: "Input__wrapper", children: /* @__PURE__ */ L.jsx(
      "input",
      {
        type: "text",
        className: "Input__input",
        placeholder: r.exampleUrl,
        value: t,
        "data-test-id": `${r.type}-embed-modal-url`,
        onChange: (u) => {
          const { value: d } = u.target;
          n(d), a(d);
        }
      }
    ) }),
    /* @__PURE__ */ L.jsx(oi, { children: /* @__PURE__ */ L.jsx(
      Ir,
      {
        disabled: !o,
        onClick: l,
        "data-test-id": `${r.type}-embed-modal-submit-btn`,
        children: "Embed"
      }
    ) })
  ] });
}
function h4() {
  const [r, e] = Do(), t = (i) => {
    e(`Embed ${i.contentName}`, (o) => /* @__PURE__ */ L.jsx(d4, { embedConfig: i, onClose: o }));
  }, n = (i, o, s) => [
    new jn.AutoEmbedOption("Dismiss", {
      onSelect: s
    }),
    new jn.AutoEmbedOption(`Embed ${i.contentName}`, {
      onSelect: o
    })
  ];
  return /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    r,
    /* @__PURE__ */ L.jsx(
      jn.LexicalAutoEmbedPlugin,
      {
        embedConfigs: tl,
        onOpenEmbedModalForConfig: t,
        getMenuOptions: n,
        menuRenderFn: (i, { selectedIndex: o, options: s, selectOptionAndCleanUp: a, setHighlightedIndex: l }) => i.current ? wi.createPortal(
          /* @__PURE__ */ L.jsx(
            "div",
            {
              className: "typeahead-popover auto-embed-menu",
              style: {
                marginLeft: i.current.style.width,
                width: 200
              },
              children: /* @__PURE__ */ L.jsx(
                c4,
                {
                  options: s,
                  selectedItemIndex: o,
                  onOptionClick: (u, d) => {
                    l(d), a(u);
                  },
                  onOptionMouseEnter: (u) => {
                    l(u);
                  }
                }
              )
            }
          ),
          i.current
        ) : null
      }
    )
  ] });
}
const as = {
  bullet: "Bulleted List",
  check: "Check List",
  code: "Code Block",
  h1: "Heading 1",
  h2: "Heading 2",
  h3: "Heading 3",
  h4: "Heading 4",
  h5: "Heading 5",
  h6: "Heading 6",
  number: "Numbered List",
  paragraph: "Normal",
  quote: "Quote"
}, f4 = [
  ["Arial", "Arial"],
  ["Courier New", "Courier New"],
  ["Georgia", "Georgia"],
  ["Times New Roman", "Times New Roman"],
  ["Trebuchet MS", "Trebuchet MS"],
  ["Verdana", "Verdana"]
], m4 = [
  ["10px", "10px"],
  ["11px", "11px"],
  ["12px", "12px"],
  ["13px", "13px"],
  ["14px", "14px"],
  ["15px", "15px"],
  ["16px", "16px"],
  ["17px", "17px"],
  ["18px", "18px"],
  ["19px", "19px"],
  ["20px", "20px"]
], vi = {
  center: {
    icon: "center-align",
    iconRTL: "center-align",
    name: "Center Align"
  },
  end: {
    icon: "right-align",
    iconRTL: "left-align",
    name: "End Align"
  },
  justify: {
    icon: "justify-align",
    iconRTL: "justify-align",
    name: "Justify Align"
  },
  left: {
    icon: "left-align",
    iconRTL: "left-align",
    name: "Left Align"
  },
  right: {
    icon: "right-align",
    iconRTL: "right-align",
    name: "Right Align"
  },
  start: {
    icon: "left-align",
    iconRTL: "right-align",
    name: "Start Align"
  }
};
function xr(r) {
  return r ? "active dropdown-item-active" : "";
}
function g4({
  editor: r,
  blockType: e,
  disabled: t = !1
}) {
  const n = () => {
    r.update(() => {
      const u = Nt();
      nr.$setBlocksType(u, () => Gt());
    });
  }, i = (u) => {
    e !== u && r.update(() => {
      const d = Nt();
      nr.$setBlocksType(d, () => fr.$createHeadingNode(u));
    });
  }, o = () => {
    e !== "bullet" ? r.dispatchCommand(Zt.INSERT_UNORDERED_LIST_COMMAND, void 0) : n();
  }, s = () => {
    e !== "check" ? r.dispatchCommand(Zt.INSERT_CHECK_LIST_COMMAND, void 0) : n();
  }, a = () => {
    e !== "number" ? r.dispatchCommand(Zt.INSERT_ORDERED_LIST_COMMAND, void 0) : n();
  }, l = () => {
    e !== "quote" && r.update(() => {
      const u = Nt();
      nr.$setBlocksType(u, () => fr.$createQuoteNode());
    });
  };
  return /* @__PURE__ */ L.jsxs(
    Rn,
    {
      disabled: t,
      buttonClassName: "toolbar-item block-controls",
      buttonIconClassName: "icon block-type " + e,
      buttonLabel: as[e],
      buttonAriaLabel: "Formatting options for text style",
      children: [
        /* @__PURE__ */ L.jsxs(
          _t,
          {
            className: "item " + xr(e === "paragraph"),
            onClick: n,
            children: [
              /* @__PURE__ */ L.jsx("i", { className: "icon paragraph" }),
              /* @__PURE__ */ L.jsx("span", { className: "text", children: "Normal" })
            ]
          }
        ),
        /* @__PURE__ */ L.jsxs(
          _t,
          {
            className: "item " + xr(e === "h1"),
            onClick: () => i("h1"),
            children: [
              /* @__PURE__ */ L.jsx("i", { className: "icon h1" }),
              /* @__PURE__ */ L.jsx("span", { className: "text", children: "Heading 1" })
            ]
          }
        ),
        /* @__PURE__ */ L.jsxs(
          _t,
          {
            className: "item " + xr(e === "h2"),
            onClick: () => i("h2"),
            children: [
              /* @__PURE__ */ L.jsx("i", { className: "icon h2" }),
              /* @__PURE__ */ L.jsx("span", { className: "text", children: "Heading 2" })
            ]
          }
        ),
        /* @__PURE__ */ L.jsxs(
          _t,
          {
            className: "item " + xr(e === "h3"),
            onClick: () => i("h3"),
            children: [
              /* @__PURE__ */ L.jsx("i", { className: "icon h3" }),
              /* @__PURE__ */ L.jsx("span", { className: "text", children: "Heading 3" })
            ]
          }
        ),
        /* @__PURE__ */ L.jsxs(
          _t,
          {
            className: "item " + xr(e === "bullet"),
            onClick: o,
            children: [
              /* @__PURE__ */ L.jsx("i", { className: "icon bullet-list" }),
              /* @__PURE__ */ L.jsx("span", { className: "text", children: "Bullet List" })
            ]
          }
        ),
        /* @__PURE__ */ L.jsxs(
          _t,
          {
            className: "item " + xr(e === "number"),
            onClick: a,
            children: [
              /* @__PURE__ */ L.jsx("i", { className: "icon numbered-list" }),
              /* @__PURE__ */ L.jsx("span", { className: "text", children: "Numbered List" })
            ]
          }
        ),
        /* @__PURE__ */ L.jsxs(
          _t,
          {
            className: "item " + xr(e === "check"),
            onClick: s,
            children: [
              /* @__PURE__ */ L.jsx("i", { className: "icon check-list" }),
              /* @__PURE__ */ L.jsx("span", { className: "text", children: "Check List" })
            ]
          }
        ),
        /* @__PURE__ */ L.jsxs(
          _t,
          {
            className: "item " + xr(e === "quote"),
            onClick: l,
            children: [
              /* @__PURE__ */ L.jsx("i", { className: "icon quote" }),
              /* @__PURE__ */ L.jsx("span", { className: "text", children: "Quote" })
            ]
          }
        )
      ]
    }
  );
}
function p4({
  editor: r,
  value: e,
  style: t,
  disabled: n = !1
}) {
  const i = ct(
    (s) => {
      r.update(() => {
        const a = Nt();
        a !== null && nr.$patchStyleText(a, {
          [t]: s
        });
      });
    },
    [r, t]
  ), o = t === "font-family" ? "Formatting options for font family" : "Formatting options for font size";
  return /* @__PURE__ */ L.jsx(
    Rn,
    {
      disabled: n,
      buttonClassName: "toolbar-item " + t,
      buttonLabel: e,
      buttonIconClassName: t === "font-family" ? "icon block-type font-family" : "",
      buttonAriaLabel: o,
      children: (t === "font-family" ? f4 : m4).map(
        ([s, a]) => /* @__PURE__ */ L.jsx(
          _t,
          {
            className: `item ${xr(e === s)} ${t === "font-size" ? "fontsize-item" : ""}`,
            onClick: () => i(s),
            children: /* @__PURE__ */ L.jsx("span", { className: "text", children: a })
          },
          s
        )
      )
    }
  );
}
function Cn() {
  return /* @__PURE__ */ L.jsx("div", { className: "divider" });
}
function v4({
  editor: r,
  value: e,
  isRTL: t,
  disabled: n = !1
}) {
  const i = vi[e || "left"];
  return /* @__PURE__ */ L.jsxs(
    Rn,
    {
      disabled: n,
      buttonLabel: i.name,
      buttonIconClassName: `icon ${t ? i.iconRTL : i.icon}`,
      buttonClassName: "toolbar-item spaced alignment",
      buttonAriaLabel: "Formatting options for text alignment",
      children: [
        /* @__PURE__ */ L.jsxs(
          _t,
          {
            onClick: () => {
              r.dispatchCommand(_n, "left");
            },
            className: "item",
            children: [
              /* @__PURE__ */ L.jsx("i", { className: "icon left-align" }),
              /* @__PURE__ */ L.jsx("span", { className: "text", children: "Left Align" })
            ]
          }
        ),
        /* @__PURE__ */ L.jsxs(
          _t,
          {
            onClick: () => {
              r.dispatchCommand(_n, "center");
            },
            className: "item",
            children: [
              /* @__PURE__ */ L.jsx("i", { className: "icon center-align" }),
              /* @__PURE__ */ L.jsx("span", { className: "text", children: "Center Align" })
            ]
          }
        ),
        /* @__PURE__ */ L.jsxs(
          _t,
          {
            onClick: () => {
              r.dispatchCommand(_n, "right");
            },
            className: "item",
            children: [
              /* @__PURE__ */ L.jsx("i", { className: "icon right-align" }),
              /* @__PURE__ */ L.jsx("span", { className: "text", children: "Right Align" })
            ]
          }
        ),
        /* @__PURE__ */ L.jsxs(
          _t,
          {
            onClick: () => {
              r.dispatchCommand(_n, "justify");
            },
            className: "item",
            children: [
              /* @__PURE__ */ L.jsx("i", { className: "icon justify-align" }),
              /* @__PURE__ */ L.jsx("span", { className: "text", children: "Justify Align" })
            ]
          }
        ),
        /* @__PURE__ */ L.jsxs(
          _t,
          {
            onClick: () => {
              r.dispatchCommand(_n, "start");
            },
            className: "item",
            children: [
              /* @__PURE__ */ L.jsx(
                "i",
                {
                  className: `icon ${t ? vi.start.iconRTL : vi.start.icon}`
                }
              ),
              /* @__PURE__ */ L.jsx("span", { className: "text", children: "Start Align" })
            ]
          }
        ),
        /* @__PURE__ */ L.jsxs(
          _t,
          {
            onClick: () => {
              r.dispatchCommand(_n, "end");
            },
            className: "item",
            children: [
              /* @__PURE__ */ L.jsx(
                "i",
                {
                  className: `icon ${t ? vi.end.iconRTL : vi.end.icon}`
                }
              ),
              /* @__PURE__ */ L.jsx("span", { className: "text", children: "End Align" })
            ]
          }
        ),
        /* @__PURE__ */ L.jsx(Cn, {}),
        /* @__PURE__ */ L.jsxs(
          _t,
          {
            onClick: () => {
              r.dispatchCommand(Hh, void 0);
            },
            className: "item",
            children: [
              /* @__PURE__ */ L.jsx("i", { className: "icon " + (t ? "indent" : "outdent") }),
              /* @__PURE__ */ L.jsx("span", { className: "text", children: "Outdent" })
            ]
          }
        ),
        /* @__PURE__ */ L.jsxs(
          _t,
          {
            onClick: () => {
              r.dispatchCommand(Ou, void 0);
            },
            className: "item",
            children: [
              /* @__PURE__ */ L.jsx("i", { className: "icon " + (t ? "outdent" : "indent") }),
              /* @__PURE__ */ L.jsx("span", { className: "text", children: "Indent" })
            ]
          }
        )
      ]
    }
  );
}
function x4({ setIsLinkEditMode: r }) {
  const [e] = Ot.useLexicalComposerContext(), [t, n] = Ie("paragraph"), [i, o] = Ie(e), [s, a] = Ie("15px"), [l, u] = Ie("#000"), [d, p] = Ie("#fff"), [m, c] = Ie("Arial"), [h, f] = Ie("left"), [N, v] = Ie(!1), [C, g] = Ie(!1), [x, b] = Ie(!1), [A, w] = Ie(!1), [M, y] = Ie(!1), [E, S] = Ie(!1), [P, U] = Ie(!1), [j, H] = Ie(!1), [R, T] = Ie(!1), [$, G] = Ie(!1), [q, I] = Ie(!1), [Y, D] = Ie(() => e.isEditable()), [z, X] = Do(), Q = ct(() => {
    const B = Nt();
    if (At(B)) {
      const F = B.anchor.getNode();
      let k = F.getKey() === "root" ? F : ut.$findMatchingParent(F, (xe) => {
        const ye = xe.getParent();
        return ye !== null && Gn(ye);
      });
      k === null && (k = F.getTopLevelElementOrThrow());
      const W = k.getKey(), V = i.getElementByKey(W);
      g(B.hasFormat("bold")), b(B.hasFormat("italic")), w(B.hasFormat("underline")), y(B.hasFormat("strikethrough")), S(B.hasFormat("subscript")), U(B.hasFormat("superscript")), H(B.hasFormat("code")), T(nr.$isParentElementRTL(B));
      const te = Yn(B), ee = te.getParent();
      if (St.$isLinkNode(ee) || St.$isLinkNode(te) ? v(!0) : v(!1), V !== null)
        if (Zt.$isListNode(k)) {
          const xe = ut.$getNearestNodeOfType(
            F,
            Zt.ListNode
          ), ye = xe ? xe.getListType() : k.getListType();
          n(ye);
        } else {
          const xe = fr.$isHeadingNode(k) ? k.getTag() : k.getType();
          xe in as && n(xe);
        }
      a(
        nr.$getSelectionStyleValueForProperty(B, "font-size", "15px")
      ), u(
        nr.$getSelectionStyleValueForProperty(B, "color", "#000")
      ), p(
        nr.$getSelectionStyleValueForProperty(
          B,
          "background-color",
          "#fff"
        )
      ), c(
        nr.$getSelectionStyleValueForProperty(B, "font-family", "Arial")
      );
      let ue;
      St.$isLinkNode(ee) && (ue = ut.$findMatchingParent(
        te,
        (xe) => yn(xe) && !xe.isInline()
      )), f(
        yn(ue) ? ue.getFormatType() : yn(te) ? te.getFormatType() : (ee == null ? void 0 : ee.getFormatType()) || "left"
      );
    }
  }, [i]);
  We(() => e.registerCommand(
    Vn,
    (B, F) => (Q(), o(F), !1),
    _i
  ), [e, Q]), We(() => ut.mergeRegister(
    e.registerEditableListener((B) => {
      D(B);
    }),
    i.registerUpdateListener(({ editorState: B }) => {
      B.read(() => {
        Q();
      });
    }),
    i.registerCommand(
      $h,
      (B) => (G(B), !1),
      _i
    ),
    i.registerCommand(
      Ih,
      (B) => (I(B), !1),
      _i
    )
  ), [Q, i, e]), We(() => i.registerCommand(
    Ph,
    (B) => {
      const F = B, { code: k, ctrlKey: W, metaKey: V } = F;
      if (k === "KeyK" && (W || V)) {
        F.preventDefault();
        let te;
        return N ? (r(!1), te = null) : (r(!0), te = yo("https://")), i.dispatchCommand(St.TOGGLE_LINK_COMMAND, te);
      }
      return !1;
    },
    Fh
  ), [i, N, r]);
  const ne = ct(
    (B, F) => {
      i.update(
        () => {
          const k = Nt();
          k !== null && nr.$patchStyleText(k, B);
        },
        F ? { tag: "historic" } : {}
      );
    },
    [i]
  ), fe = ct(() => {
    i.update(() => {
      const B = Nt();
      if (At(B)) {
        const F = B.anchor, k = B.focus, W = B.getNodes();
        if (F.key === k.key && F.offset === k.offset)
          return;
        W.forEach((V, te) => {
          if (ms(V)) {
            let ee = V;
            te === 0 && F.offset !== 0 && (ee = ee.splitText(F.offset)[1] || ee), te === W.length - 1 && (ee = ee.splitText(k.offset)[0] || ee), ee.__style !== "" && ee.setStyle(""), ee.__format !== 0 && (ee.setFormat(0), ut.$getNearestBlockElementAncestorOrThrow(ee).setFormat("")), V = ee;
          } else fr.$isHeadingNode(V) || fr.$isQuoteNode(V) ? V.replace(Gt(), !0) : Zn.$isDecoratorBlockNode(V) && V.setFormat("");
        });
      }
    });
  }, [i]), _e = ct(
    (B, F) => {
      ne({ color: B }, F);
    },
    [ne]
  ), pe = ct(
    (B, F) => {
      ne({ "background-color": B }, F);
    },
    [ne]
  ), Ne = ct(() => {
    N ? (r(!1), e.dispatchCommand(St.TOGGLE_LINK_COMMAND, null)) : (r(!0), e.dispatchCommand(St.TOGGLE_LINK_COMMAND, yo("https://")));
  }, [e, N, r]);
  return /* @__PURE__ */ L.jsxs("div", { className: "toolbar", children: [
    /* @__PURE__ */ L.jsx(
      "button",
      {
        disabled: !$ || !Y,
        onClick: () => {
          i.dispatchCommand(Bh, void 0);
        },
        title: sn ? "Undo (âŒ˜Z)" : "Undo (Ctrl+Z)",
        type: "button",
        className: "toolbar-item spaced",
        "aria-label": "Undo",
        children: /* @__PURE__ */ L.jsx("i", { className: "format undo" })
      }
    ),
    /* @__PURE__ */ L.jsx(
      "button",
      {
        disabled: !q || !Y,
        onClick: () => {
          i.dispatchCommand(zh, void 0);
        },
        title: sn ? "Redo (âŒ˜Y)" : "Redo (Ctrl+Y)",
        type: "button",
        className: "toolbar-item spaced",
        "aria-label": "Redo",
        children: /* @__PURE__ */ L.jsx("i", { className: "format redo" })
      }
    ),
    /* @__PURE__ */ L.jsx(Cn, {}),
    t in as && i === e && /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
      /* @__PURE__ */ L.jsx(
        g4,
        {
          disabled: !Y,
          blockType: t,
          editor: e
        }
      ),
      /* @__PURE__ */ L.jsx(Cn, {})
    ] }),
    /* @__PURE__ */ L.jsx(
      p4,
      {
        disabled: !Y,
        editor: e,
        value: m,
        style: "font-family"
      }
    ),
    /* @__PURE__ */ L.jsx(Cn, {}),
    /* @__PURE__ */ L.jsx(l1, { selectionFontSize: s.slice(0, -2), editor: e, disabled: !Y }),
    /* @__PURE__ */ L.jsx(Cn, {}),
    /* @__PURE__ */ L.jsx(
      "button",
      {
        disabled: !Y,
        onClick: () => {
          i.dispatchCommand(dr, "bold");
        },
        className: "toolbar-item spaced " + (C ? "active" : ""),
        title: sn ? "Bold (âŒ˜B)" : "Bold (Ctrl+B)",
        type: "button",
        "aria-label": `Format text as bold. Shortcut: ${sn ? "âŒ˜B" : "Ctrl+B"}`,
        children: /* @__PURE__ */ L.jsx("i", { className: "format bold" })
      }
    ),
    /* @__PURE__ */ L.jsx(
      "button",
      {
        disabled: !Y,
        onClick: () => {
          i.dispatchCommand(dr, "italic");
        },
        className: "toolbar-item spaced " + (x ? "active" : ""),
        title: sn ? "Italic (âŒ˜I)" : "Italic (Ctrl+I)",
        type: "button",
        "aria-label": `Format text as italics. Shortcut: ${sn ? "âŒ˜I" : "Ctrl+I"}`,
        children: /* @__PURE__ */ L.jsx("i", { className: "format italic" })
      }
    ),
    /* @__PURE__ */ L.jsx(
      "button",
      {
        disabled: !Y,
        onClick: () => {
          i.dispatchCommand(dr, "underline");
        },
        className: "toolbar-item spaced " + (A ? "active" : ""),
        title: sn ? "Underline (âŒ˜U)" : "Underline (Ctrl+U)",
        type: "button",
        "aria-label": `Format text to underlined. Shortcut: ${sn ? "âŒ˜U" : "Ctrl+U"}`,
        children: /* @__PURE__ */ L.jsx("i", { className: "format underline" })
      }
    ),
    /* @__PURE__ */ L.jsx(
      "button",
      {
        disabled: !Y,
        onClick: () => {
          i.dispatchCommand(dr, "code");
        },
        className: "toolbar-item spaced " + (j ? "active" : ""),
        title: "Insert code block",
        type: "button",
        "aria-label": "Insert code block",
        children: /* @__PURE__ */ L.jsx("i", { className: "format code" })
      }
    ),
    /* @__PURE__ */ L.jsx(
      "button",
      {
        disabled: !Y,
        onClick: Ne,
        className: "toolbar-item spaced " + (N ? "active" : ""),
        "aria-label": "Insert link",
        title: "Insert link",
        type: "button",
        children: /* @__PURE__ */ L.jsx("i", { className: "format link" })
      }
    ),
    /* @__PURE__ */ L.jsx(
      jc,
      {
        disabled: !Y,
        buttonClassName: "toolbar-item color-picker",
        buttonAriaLabel: "Formatting text color",
        buttonIconClassName: "icon font-color",
        color: l,
        onChange: _e,
        title: "text color"
      }
    ),
    /* @__PURE__ */ L.jsx(
      jc,
      {
        disabled: !Y,
        buttonClassName: "toolbar-item color-picker",
        buttonAriaLabel: "Formatting background color",
        buttonIconClassName: "icon bg-color",
        color: d,
        onChange: pe,
        title: "bg color"
      }
    ),
    /* @__PURE__ */ L.jsxs(
      Rn,
      {
        disabled: !Y,
        buttonClassName: "toolbar-item spaced",
        buttonLabel: "",
        buttonAriaLabel: "Formatting options for additional text styles",
        buttonIconClassName: "icon dropdown-more",
        children: [
          /* @__PURE__ */ L.jsxs(
            _t,
            {
              onClick: () => {
                i.dispatchCommand(
                  dr,
                  "strikethrough"
                );
              },
              className: "item " + xr(M),
              title: "Strikethrough",
              "aria-label": "Format text with a strikethrough",
              children: [
                /* @__PURE__ */ L.jsx("i", { className: "icon strikethrough" }),
                /* @__PURE__ */ L.jsx("span", { className: "text", children: "Strikethrough" })
              ]
            }
          ),
          /* @__PURE__ */ L.jsxs(
            _t,
            {
              onClick: () => {
                i.dispatchCommand(dr, "subscript");
              },
              className: "item " + xr(E),
              title: "Subscript",
              "aria-label": "Format text with a subscript",
              children: [
                /* @__PURE__ */ L.jsx("i", { className: "icon subscript" }),
                /* @__PURE__ */ L.jsx("span", { className: "text", children: "Subscript" })
              ]
            }
          ),
          /* @__PURE__ */ L.jsxs(
            _t,
            {
              onClick: () => {
                i.dispatchCommand(
                  dr,
                  "superscript"
                );
              },
              className: "item " + xr(P),
              title: "Superscript",
              "aria-label": "Format text with a superscript",
              children: [
                /* @__PURE__ */ L.jsx("i", { className: "icon superscript" }),
                /* @__PURE__ */ L.jsx("span", { className: "text", children: "Superscript" })
              ]
            }
          ),
          /* @__PURE__ */ L.jsxs(
            _t,
            {
              onClick: fe,
              className: "item",
              title: "Clear text formatting",
              "aria-label": "Clear all text formatting",
              children: [
                /* @__PURE__ */ L.jsx("i", { className: "icon clear" }),
                /* @__PURE__ */ L.jsx("span", { className: "text", children: "Clear Formatting" })
              ]
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ L.jsx(Cn, {}),
    /* @__PURE__ */ L.jsxs(
      Rn,
      {
        disabled: !Y,
        buttonClassName: "toolbar-item spaced",
        buttonLabel: "Insert",
        buttonAriaLabel: "Insert specialized editor node",
        buttonIconClassName: "icon plus",
        children: [
          /* @__PURE__ */ L.jsxs(
            _t,
            {
              onClick: () => {
                i.dispatchCommand(
                  Li.INSERT_HORIZONTAL_RULE_COMMAND,
                  void 0
                );
              },
              className: "item",
              children: [
                /* @__PURE__ */ L.jsx("i", { className: "icon horizontal-rule" }),
                /* @__PURE__ */ L.jsx("span", { className: "text", children: "Horizontal Rule" })
              ]
            }
          ),
          /* @__PURE__ */ L.jsxs(
            _t,
            {
              onClick: () => {
                i.dispatchCommand(Vs, void 0);
              },
              className: "item",
              children: [
                /* @__PURE__ */ L.jsx("i", { className: "icon page-break" }),
                /* @__PURE__ */ L.jsx("span", { className: "text", children: "Page Break" })
              ]
            }
          ),
          /* @__PURE__ */ L.jsxs(
            _t,
            {
              onClick: () => {
                X("Insert Image", (B) => /* @__PURE__ */ L.jsx(
                  nh,
                  {
                    activeEditor: i,
                    onClose: B
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ L.jsx("i", { className: "icon image" }),
                /* @__PURE__ */ L.jsx("span", { className: "text", children: "Image" })
              ]
            }
          ),
          /* @__PURE__ */ L.jsxs(
            _t,
            {
              onClick: () => {
                X("Insert Inline Image", (B) => /* @__PURE__ */ L.jsx(
                  A1,
                  {
                    activeEditor: i,
                    onClose: B
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ L.jsx("i", { className: "icon image" }),
                /* @__PURE__ */ L.jsx("span", { className: "text", children: "Inline Image" })
              ]
            }
          ),
          /* @__PURE__ */ L.jsxs(
            _t,
            {
              onClick: () => {
                i.dispatchCommand(
                  Qs,
                  void 0
                );
              },
              className: "item",
              children: [
                /* @__PURE__ */ L.jsx("i", { className: "icon diagram-2" }),
                /* @__PURE__ */ L.jsx("span", { className: "text", children: "Excalidraw" })
              ]
            }
          ),
          /* @__PURE__ */ L.jsxs(
            _t,
            {
              onClick: () => {
                X("Insert Table", (B) => /* @__PURE__ */ L.jsx(
                  lh,
                  {
                    activeEditor: i,
                    onClose: B
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ L.jsx("i", { className: "icon table" }),
                /* @__PURE__ */ L.jsx("span", { className: "text", children: "Table" })
              ]
            }
          ),
          /* @__PURE__ */ L.jsxs(
            _t,
            {
              onClick: () => {
                X("Insert Poll", (B) => /* @__PURE__ */ L.jsx(
                  uh,
                  {
                    activeEditor: i,
                    onClose: B
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ L.jsx("i", { className: "icon poll" }),
                /* @__PURE__ */ L.jsx("span", { className: "text", children: "Poll" })
              ]
            }
          ),
          /* @__PURE__ */ L.jsxs(
            _t,
            {
              onClick: () => {
                X("Insert Columns Layout", (B) => /* @__PURE__ */ L.jsx(
                  hh,
                  {
                    activeEditor: i,
                    onClose: B
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ L.jsx("i", { className: "icon columns" }),
                /* @__PURE__ */ L.jsx("span", { className: "text", children: "Columns Layout" })
              ]
            }
          ),
          /* @__PURE__ */ L.jsxs(
            _t,
            {
              onClick: () => {
                X("Insert Equation", (B) => /* @__PURE__ */ L.jsx(
                  mh,
                  {
                    activeEditor: i,
                    onClose: B
                  }
                ));
              },
              className: "item",
              children: [
                /* @__PURE__ */ L.jsx("i", { className: "icon equation" }),
                /* @__PURE__ */ L.jsx("span", { className: "text", children: "Equation" })
              ]
            }
          ),
          /* @__PURE__ */ L.jsxs(
            _t,
            {
              onClick: () => {
                e.update(() => {
                  const B = gs(), F = vp(0, 0);
                  B.append(F);
                });
              },
              className: "item",
              children: [
                /* @__PURE__ */ L.jsx("i", { className: "icon sticky" }),
                /* @__PURE__ */ L.jsx("span", { className: "text", children: "Sticky Note" })
              ]
            }
          ),
          /* @__PURE__ */ L.jsxs(
            _t,
            {
              onClick: () => {
                e.dispatchCommand(el, void 0);
              },
              className: "item",
              children: [
                /* @__PURE__ */ L.jsx("i", { className: "icon caret-right" }),
                /* @__PURE__ */ L.jsx("span", { className: "text", children: "Collapsible container" })
              ]
            }
          ),
          tl.map((B) => /* @__PURE__ */ L.jsxs(
            _t,
            {
              onClick: () => {
                i.dispatchCommand(
                  jn.INSERT_EMBED_COMMAND,
                  B.type
                );
              },
              className: "item",
              children: [
                B.icon,
                /* @__PURE__ */ L.jsx("span", { className: "text", children: B.contentName })
              ]
            },
            B.type
          ))
        ]
      }
    ),
    /* @__PURE__ */ L.jsx(Cn, {}),
    /* @__PURE__ */ L.jsx(
      v4,
      {
        disabled: !Y,
        value: h,
        editor: e,
        isRTL: R
      }
    ),
    z
  ] });
}
var Aa = {}, Vc;
function N4() {
  if (Vc) return Aa;
  Vc = 1;
  var r = Zt, e = lt(), t = nt, n = it(), i = Ve;
  function o(a) {
    t.useEffect(() => n.mergeRegister(a.registerCommand(r.INSERT_ORDERED_LIST_COMMAND, () => (r.insertList(a, "number"), !0), i.COMMAND_PRIORITY_LOW), a.registerCommand(r.INSERT_UNORDERED_LIST_COMMAND, () => (r.insertList(a, "bullet"), !0), i.COMMAND_PRIORITY_LOW), a.registerCommand(r.REMOVE_LIST_COMMAND, () => (r.removeList(a), !0), i.COMMAND_PRIORITY_LOW), a.registerCommand(i.INSERT_PARAGRAPH_COMMAND, () => !!r.$handleListInsertParagraph(), i.COMMAND_PRIORITY_LOW)), [a]);
  }
  function s() {
    const [a] = e.useLexicalComposerContext();
    return t.useEffect(() => {
      if (!a.hasNodes([r.ListNode, r.ListItemNode]))
        throw new Error("ListPlugin: ListNode and/or ListItemNode not registered on editor");
    }, [a]), o(a), null;
  }
  return Aa.ListPlugin = s, Aa;
}
var La = {}, Xc;
function _4() {
  if (Xc) return La;
  Xc = 1;
  var r = Zt, e = lt(), t = nt, n = it(), i = Ve;
  function o(s) {
    t.useEffect(() => n.mergeRegister(s.registerCommand(r.INSERT_ORDERED_LIST_COMMAND, () => (r.insertList(s, "number"), !0), i.COMMAND_PRIORITY_LOW), s.registerCommand(r.INSERT_UNORDERED_LIST_COMMAND, () => (r.insertList(s, "bullet"), !0), i.COMMAND_PRIORITY_LOW), s.registerCommand(r.REMOVE_LIST_COMMAND, () => (r.removeList(s), !0), i.COMMAND_PRIORITY_LOW), s.registerCommand(i.INSERT_PARAGRAPH_COMMAND, () => !!r.$handleListInsertParagraph(), i.COMMAND_PRIORITY_LOW)), [s]);
  }
  return La.ListPlugin = function() {
    let [s] = e.useLexicalComposerContext();
    return t.useEffect(() => {
      if (!s.hasNodes([r.ListNode, r.ListItemNode])) throw Error("ListPlugin: ListNode and/or ListItemNode not registered on editor");
    }, [s]), o(s), null;
  }, La;
}
const C4 = process.env.NODE_ENV === "development" ? N4() : _4();
var b4 = C4, ka = {}, Jc;
function y4() {
  if (Jc) return ka;
  Jc = 1;
  var r = Zt, e = lt(), t = it(), n = Ve, i = nt;
  function o() {
    const [c] = e.useLexicalComposerContext();
    return i.useEffect(() => t.mergeRegister(c.registerCommand(r.INSERT_CHECK_LIST_COMMAND, () => (r.insertList(c, "check"), !0), n.COMMAND_PRIORITY_LOW), c.registerCommand(n.KEY_ARROW_DOWN_COMMAND, (h) => m(h, c, !1), n.COMMAND_PRIORITY_LOW), c.registerCommand(n.KEY_ARROW_UP_COMMAND, (h) => m(h, c, !0), n.COMMAND_PRIORITY_LOW), c.registerCommand(n.KEY_ESCAPE_COMMAND, (h) => {
      if (d() != null) {
        const N = c.getRootElement();
        return N != null && N.focus(), !0;
      }
      return !1;
    }, n.COMMAND_PRIORITY_LOW), c.registerCommand(n.KEY_SPACE_COMMAND, (h) => {
      const f = d();
      return f != null && c.isEditable() ? (c.update(() => {
        const N = n.$getNearestNodeFromDOMNode(f);
        r.$isListItemNode(N) && (h.preventDefault(), N.toggleChecked());
      }), !0) : !1;
    }, n.COMMAND_PRIORITY_LOW), c.registerCommand(n.KEY_ARROW_LEFT_COMMAND, (h) => c.getEditorState().read(() => {
      const f = n.$getSelection();
      if (n.$isRangeSelection(f) && f.isCollapsed()) {
        const {
          anchor: N
        } = f, v = N.type === "element";
        if (v || N.offset === 0) {
          const C = N.getNode(), g = t.$findMatchingParent(C, (x) => n.$isElementNode(x) && !x.isInline());
          if (r.$isListItemNode(g)) {
            const x = g.getParent();
            if (r.$isListNode(x) && x.getListType() === "check" && (v || g.getFirstDescendant() === C)) {
              const b = c.getElementByKey(g.__key);
              if (b != null && document.activeElement !== b)
                return b.focus(), h.preventDefault(), !0;
            }
          }
        }
      }
      return !1;
    }), n.COMMAND_PRIORITY_LOW), c.registerRootListener((h, f) => {
      h !== null && (h.addEventListener("click", a), h.addEventListener("pointerdown", l)), f !== null && (f.removeEventListener("click", a), f.removeEventListener("pointerdown", l));
    }))), null;
  }
  function s(c, h) {
    const f = c.target;
    if (f === null || !t.isHTMLElement(f))
      return;
    const N = f.firstChild;
    if (N != null && t.isHTMLElement(N) && (N.tagName === "UL" || N.tagName === "OL"))
      return;
    const v = f.parentNode;
    if (!v || v.__lexicalListType !== "check")
      return;
    const C = c.pageX, g = f.getBoundingClientRect();
    (f.dir === "rtl" ? C < g.right && C > g.right - 20 : C > g.left && C < g.left + 20) && h();
  }
  function a(c) {
    s(c, () => {
      const h = c.target, f = u(h);
      f != null && f.isEditable() && f.update(() => {
        if (c.target) {
          const N = n.$getNearestNodeFromDOMNode(h);
          r.$isListItemNode(N) && (h.focus(), N.toggleChecked());
        }
      });
    });
  }
  function l(c) {
    s(c, () => {
      c.preventDefault();
    });
  }
  function u(c) {
    let h = c;
    for (; h; ) {
      if (h.__lexicalEditor)
        return h.__lexicalEditor;
      h = h.parentNode;
    }
    return null;
  }
  function d() {
    const c = document.activeElement;
    return c != null && c.tagName === "LI" && c.parentNode != null && // @ts-ignore internal field
    c.parentNode.__lexicalListType === "check" ? c : null;
  }
  function p(c, h) {
    let f = h ? c.getPreviousSibling() : c.getNextSibling(), N = c;
    for (; f == null && r.$isListItemNode(N); )
      N = N.getParentOrThrow().getParent(), N != null && (f = h ? N.getPreviousSibling() : N.getNextSibling());
    for (; r.$isListItemNode(f); ) {
      const v = h ? f.getLastChild() : f.getFirstChild();
      if (!r.$isListNode(v))
        return f;
      f = h ? v.getLastChild() : v.getFirstChild();
    }
    return null;
  }
  function m(c, h, f) {
    const N = d();
    return N != null && h.update(() => {
      const v = n.$getNearestNodeFromDOMNode(N);
      if (!r.$isListItemNode(v))
        return;
      const C = p(v, f);
      if (C != null) {
        C.selectStart();
        const g = h.getElementByKey(C.__key);
        g != null && (c.preventDefault(), setTimeout(() => {
          g.focus();
        }, 0));
      }
    }), !1;
  }
  return ka.CheckListPlugin = o, ka;
}
var Da = {}, Zc;
function w4() {
  if (Zc) return Da;
  Zc = 1;
  var r = Zt, e = lt(), t = it(), n = Ve, i = nt;
  function o(m, c) {
    let h = m.target;
    if (h !== null && t.isHTMLElement(h)) {
      var f = h.firstChild;
      (f == null || !t.isHTMLElement(f) || f.tagName !== "UL" && f.tagName !== "OL") && (f = h.parentNode) && f.__lexicalListType === "check" && (m = m.pageX, f = h.getBoundingClientRect(), (h.dir === "rtl" ? m < f.right && m > f.right - 20 : m > f.left && m < f.left + 20) && c());
    }
  }
  function s(m) {
    o(m, () => {
      let c = m.target, h = l(c);
      h != null && h.isEditable() && h.update(() => {
        if (m.target) {
          let f = n.$getNearestNodeFromDOMNode(c);
          r.$isListItemNode(f) && (c.focus(), f.toggleChecked());
        }
      });
    });
  }
  function a(m) {
    o(m, () => {
      m.preventDefault();
    });
  }
  function l(m) {
    for (; m; ) {
      if (m.__lexicalEditor) return m.__lexicalEditor;
      m = m.parentNode;
    }
    return null;
  }
  function u() {
    let m = document.activeElement;
    return m != null && m.tagName === "LI" && m.parentNode != null && m.parentNode.__lexicalListType === "check" ? m : null;
  }
  function d(m, c) {
    let h = c ? m.getPreviousSibling() : m.getNextSibling();
    for (; h == null && r.$isListItemNode(m); ) m = m.getParentOrThrow().getParent(), m != null && (h = c ? m.getPreviousSibling() : m.getNextSibling());
    for (; r.$isListItemNode(h); ) {
      if (m = c ? h.getLastChild() : h.getFirstChild(), !r.$isListNode(m)) return h;
      h = c ? m.getLastChild() : m.getFirstChild();
    }
    return null;
  }
  function p(m, c, h) {
    let f = u();
    return f != null && c.update(() => {
      var N = n.$getNearestNodeFromDOMNode(f);
      if (r.$isListItemNode(N) && (N = d(N, h), N != null)) {
        N.selectStart();
        let v = c.getElementByKey(N.__key);
        v != null && (m.preventDefault(), setTimeout(() => {
          v.focus();
        }, 0));
      }
    }), !1;
  }
  return Da.CheckListPlugin = function() {
    let [m] = e.useLexicalComposerContext();
    return i.useEffect(() => t.mergeRegister(
      m.registerCommand(r.INSERT_CHECK_LIST_COMMAND, () => (r.insertList(m, "check"), !0), n.COMMAND_PRIORITY_LOW),
      m.registerCommand(n.KEY_ARROW_DOWN_COMMAND, (c) => p(c, m, !1), n.COMMAND_PRIORITY_LOW),
      m.registerCommand(n.KEY_ARROW_UP_COMMAND, (c) => p(c, m, !0), n.COMMAND_PRIORITY_LOW),
      m.registerCommand(n.KEY_ESCAPE_COMMAND, () => {
        if (u() != null) {
          let c = m.getRootElement();
          return c != null && c.focus(), !0;
        }
        return !1;
      }, n.COMMAND_PRIORITY_LOW),
      m.registerCommand(n.KEY_SPACE_COMMAND, (c) => {
        let h = u();
        return h != null && m.isEditable() ? (m.update(() => {
          let f = n.$getNearestNodeFromDOMNode(h);
          r.$isListItemNode(f) && (c.preventDefault(), f.toggleChecked());
        }), !0) : !1;
      }, n.COMMAND_PRIORITY_LOW),
      m.registerCommand(n.KEY_ARROW_LEFT_COMMAND, (c) => m.getEditorState().read(() => {
        var h = n.$getSelection();
        if (n.$isRangeSelection(h) && h.isCollapsed()) {
          var { anchor: f } = h;
          if ((h = f.type === "element") || f.offset === 0) {
            f = f.getNode();
            let N = t.$findMatchingParent(f, (v) => n.$isElementNode(v) && !v.isInline());
            if (r.$isListItemNode(N)) {
              let v = N.getParent();
              if (r.$isListNode(v) && v.getListType() === "check" && (h || N.getFirstDescendant() === f) && (h = m.getElementByKey(N.__key), h != null && document.activeElement !== h)) return h.focus(), c.preventDefault(), !0;
            }
          }
        }
        return !1;
      }), n.COMMAND_PRIORITY_LOW),
      m.registerRootListener((c, h) => {
        c !== null && (c.addEventListener("click", s), c.addEventListener("pointerdown", a)), h !== null && (h.removeEventListener("click", s), h.removeEventListener("pointerdown", a));
      })
    )), null;
  }, Da;
}
const T4 = process.env.NODE_ENV === "development" ? y4() : w4();
var E4 = T4;
function S4(r) {
  const e = r.getNodes();
  return e.length === 0 ? /* @__PURE__ */ new Set([
    r.anchor.getNode().getParentOrThrow(),
    r.focus.getNode().getParentOrThrow()
  ]) : new Set(
    e.map((t) => yn(t) ? t : t.getParentOrThrow())
  );
}
function O4(r) {
  const e = Nt();
  if (!At(e))
    return !1;
  const t = S4(e);
  let n = 0;
  for (const i of t)
    if (Zt.$isListNode(i))
      n = Math.max(Zt.$getListDepth(i) + 1, n);
    else if (Zt.$isListItemNode(i)) {
      const o = i.getParent();
      if (!Zt.$isListNode(o))
        throw new Error(
          "ListMaxIndentLevelPlugin: A ListItemNode must have a ListNode for a parent."
        );
      n = Math.max(Zt.$getListDepth(o) + 1, n);
    }
  return n <= r;
}
function M4({ maxDepth: r }) {
  const [e] = Ot.useLexicalComposerContext();
  return We(() => e.registerCommand(
    Ou,
    () => !O4(r ?? 7),
    _i
  ), [e, r]), null;
}
const R4 = 1, A4 = 100;
let Nh = 0, Qc = !1;
function L4() {
  window.addEventListener(
    "keydown",
    (r) => {
      r.key === "Tab" && (Nh = r.timeStamp);
    },
    !0
  );
}
function k4() {
  const [r] = Ot.useLexicalComposerContext();
  return We(() => (Qc || (L4(), Qc = !0), r.registerCommand(
    jh,
    (e) => {
      const t = Nt();
      return At(t) && Nh + A4 > e.timeStamp && Wn(t.clone()), !1;
    },
    R4
  )), [r]), null;
}
const D4 = 10, $4 = 5;
function eu(r, e, t, n = D4, i = $4) {
  const o = t.parentElement;
  if (r === null || !o) {
    e.style.opacity = "0", e.style.transform = "translate(-10000px, -10000px)";
    return;
  }
  const s = e.getBoundingClientRect(), a = t.getBoundingClientRect(), l = o.getBoundingClientRect();
  let u = r.top - n, d = r.left - i;
  u < l.top && (u += s.height + r.height + n * 2), d + s.width > l.right && (d = l.right - s.width - i), u -= a.top, d -= a.left, e.style.opacity = "1", e.style.transform = `translate(${d}px, ${u}px)`;
}
function I4({
  editor: r,
  isLink: e,
  setIsLink: t,
  anchorElem: n,
  isLinkEditMode: i,
  setIsLinkEditMode: o
}) {
  const s = Rt(null), a = Rt(null), [l, u] = Ie(""), [d, p] = Ie("https://"), [m, c] = Ie(
    null
  ), h = ct(() => {
    var A, w;
    const v = Nt();
    if (At(v)) {
      const M = Yn(v), y = ut.$findMatchingParent(M, St.$isLinkNode);
      y ? u(y.getURL()) : St.$isLinkNode(M) ? u(M.getURL()) : u(""), i && p(l);
    }
    const C = s.current, g = window.getSelection(), x = document.activeElement;
    if (C === null)
      return;
    const b = r.getRootElement();
    if (v !== null && g !== null && b !== null && b.contains(g.anchorNode) && r.isEditable()) {
      const M = (w = (A = g.focusNode) == null ? void 0 : A.parentElement) == null ? void 0 : w.getBoundingClientRect();
      M && (M.y += 40, eu(M, C, n)), c(v);
    } else (!x || x.className !== "link-input") && (b !== null && eu(null, C, n), c(null), o(!1), u(""));
    return !0;
  }, [n, r, o, i, l]);
  We(() => {
    const v = n.parentElement, C = () => {
      r.getEditorState().read(() => {
        h();
      });
    };
    return window.addEventListener("resize", C), v && v.addEventListener("scroll", C), () => {
      window.removeEventListener("resize", C), v && v.removeEventListener("scroll", C);
    };
  }, [n.parentElement, r, h]), We(() => ut.mergeRegister(
    r.registerUpdateListener(({ editorState: v }) => {
      v.read(() => {
        h();
      });
    }),
    r.registerCommand(
      Vn,
      () => (h(), !0),
      qt
    ),
    r.registerCommand(
      qh,
      () => e ? (t(!1), !0) : !1,
      cn
    )
  ), [r, h, t, e]), We(() => {
    r.getEditorState().read(() => {
      h();
    });
  }, [r, h]), We(() => {
    i && a.current && a.current.focus();
  }, [i, e]);
  const f = (v) => {
    v.key === "Enter" ? (v.preventDefault(), N()) : v.key === "Escape" && (v.preventDefault(), o(!1));
  }, N = () => {
    m !== null && (l !== "" && (r.dispatchCommand(St.TOGGLE_LINK_COMMAND, yo(d)), r.update(() => {
      const v = Nt();
      if (At(v)) {
        const C = Yn(v).getParent();
        if (St.$isAutoLinkNode(C)) {
          const g = St.$createLinkNode(C.getURL(), {
            rel: C.__rel,
            target: C.__target,
            title: C.__title
          });
          C.replace(g, !0);
        }
      }
    })), p("https://"), o(!1));
  };
  return /* @__PURE__ */ L.jsx("div", { ref: s, className: "link-editor", children: e ? i ? /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx(
      "input",
      {
        ref: a,
        className: "link-input",
        value: d,
        onChange: (v) => {
          p(v.target.value);
        },
        onKeyDown: (v) => {
          f(v);
        }
      }
    ),
    /* @__PURE__ */ L.jsxs("div", { children: [
      /* @__PURE__ */ L.jsx(
        "div",
        {
          className: "link-cancel",
          role: "button",
          tabIndex: 0,
          onMouseDown: (v) => v.preventDefault(),
          onClick: () => {
            o(!1);
          }
        }
      ),
      /* @__PURE__ */ L.jsx(
        "div",
        {
          className: "link-confirm",
          role: "button",
          tabIndex: 0,
          onMouseDown: (v) => v.preventDefault(),
          onClick: N
        }
      )
    ] })
  ] }) : /* @__PURE__ */ L.jsxs("div", { className: "link-view", children: [
    /* @__PURE__ */ L.jsx(
      "a",
      {
        href: yo(l),
        target: "_blank",
        rel: "noopener noreferrer",
        children: l
      }
    ),
    /* @__PURE__ */ L.jsx(
      "div",
      {
        className: "link-edit",
        role: "button",
        tabIndex: 0,
        onMouseDown: (v) => v.preventDefault(),
        onClick: () => {
          p(l), o(!0);
        }
      }
    ),
    /* @__PURE__ */ L.jsx(
      "div",
      {
        className: "link-trash",
        role: "button",
        tabIndex: 0,
        onMouseDown: (v) => v.preventDefault(),
        onClick: () => {
          r.dispatchCommand(St.TOGGLE_LINK_COMMAND, null);
        }
      }
    )
  ] }) : null });
}
function P4(r, e, t, n) {
  const [i, o] = Ie(r), [s, a] = Ie(!1);
  return We(() => {
    function l() {
      const u = Nt();
      if (At(u)) {
        const d = Yn(u), p = ut.$findMatchingParent(d, St.$isLinkNode), m = ut.$findMatchingParent(
          d,
          St.$isAutoLinkNode
        );
        if (!(p || m)) {
          a(!1);
          return;
        }
        const c = u.getNodes().find((h) => {
          const f = ut.$findMatchingParent(h, St.$isLinkNode), N = ut.$findMatchingParent(h, St.$isAutoLinkNode);
          if (!(f != null && f.is(p)) && !(N != null && N.is(m)) && !f && !N && !Kh(h))
            return h;
        });
        a(!c);
      }
    }
    return ut.mergeRegister(
      r.registerUpdateListener(({ editorState: u }) => {
        u.read(() => {
          l();
        });
      }),
      r.registerCommand(
        Vn,
        (u, d) => (l(), o(d), !1),
        _i
      ),
      r.registerCommand(
        Cu,
        (u) => {
          const d = Nt();
          if (At(d)) {
            const p = Yn(d), m = ut.$findMatchingParent(p, St.$isLinkNode);
            if (St.$isLinkNode(m) && (u.metaKey || u.ctrlKey))
              return window.open(m.getURL(), "_blank"), !0;
          }
          return !1;
        },
        qt
      )
    );
  }, [r]), Qr(
    /* @__PURE__ */ L.jsx(
      I4,
      {
        editor: i,
        isLink: s,
        anchorElem: e,
        setIsLink: a,
        isLinkEditMode: t,
        setIsLinkEditMode: n
      }
    ),
    e
  );
}
function F4({
  anchorElem: r = document.body,
  isLinkEditMode: e,
  setIsLinkEditMode: t
}) {
  const [n] = Ot.useLexicalComposerContext();
  return P4(
    n,
    r,
    e,
    t
  );
}
var uo = {}, tu;
function B4() {
  if (tu) return uo;
  tu = 1;
  var r = St, e = lt(), t = it(), n = Ve, i = nt;
  function o(w, M = (y) => y) {
    return (y) => {
      const E = w.exec(y);
      return E === null ? null : {
        index: E.index,
        length: E[0].length,
        text: E[0],
        url: M(E[0])
      };
    };
  }
  function s(w, M) {
    for (let y = 0; y < M.length; y++) {
      const E = M[y](w);
      if (E)
        return E;
    }
    return null;
  }
  const a = /[.,;\s]/;
  function l(w) {
    return a.test(w);
  }
  function u(w) {
    return l(w[w.length - 1]);
  }
  function d(w) {
    return l(w[0]);
  }
  function p(w) {
    let M = w.getPreviousSibling();
    return n.$isElementNode(M) && (M = M.getLastDescendant()), M === null || n.$isLineBreakNode(M) || n.$isTextNode(M) && u(M.getTextContent());
  }
  function m(w) {
    let M = w.getNextSibling();
    return n.$isElementNode(M) && (M = M.getFirstDescendant()), M === null || n.$isLineBreakNode(M) || n.$isTextNode(M) && d(M.getTextContent());
  }
  function c(w, M, y, E) {
    return (w > 0 ? l(y[w - 1]) : p(E[0])) ? M < y.length ? l(y[M]) : m(E[E.length - 1]) : !1;
  }
  function h(w, M, y) {
    const E = [], S = [], P = [];
    let U = 0, j = 0;
    const H = [...w];
    for (; H.length > 0; ) {
      const R = H[0], $ = R.getTextContent().length, G = j;
      j + $ <= M ? (E.push(R), U += $) : G >= y ? P.push(R) : S.push(R), j += $, H.shift();
    }
    return [U, E, S, P];
  }
  function f(w, M, y, E) {
    const S = r.$createAutoLinkNode(E.url, E.attributes);
    if (w.length === 1) {
      let P = w[0], U;
      M === 0 ? [U, P] = P.splitText(y) : [, U, P] = P.splitText(M, y);
      const j = n.$createTextNode(E.text);
      return j.setFormat(U.getFormat()), j.setDetail(U.getDetail()), S.append(j), U.replace(S), P;
    } else if (w.length > 1) {
      const P = w[0];
      let U = P.getTextContent().length, j;
      M === 0 ? j = P : [, j] = P.splitText(M);
      const H = [];
      let R;
      for (let q = 1; q < w.length; q++) {
        const I = w[q], D = I.getTextContent().length, z = U, X = U + D;
        if (z < y)
          if (X <= y)
            H.push(I);
          else {
            const [Q, ne] = I.splitText(y - z);
            H.push(Q), R = ne;
          }
        U += D;
      }
      const T = n.$getSelection(), $ = T ? T.getNodes().find(n.$isTextNode) : void 0, G = n.$createTextNode(j.getTextContent());
      return G.setFormat(j.getFormat()), G.setDetail(j.getDetail()), S.append(G, ...H), $ && $ === j && (n.$isRangeSelection(T) ? G.select(T.anchor.offset, T.focus.offset) : n.$isNodeSelection(T) && G.select(0, G.getTextContent().length)), j.replace(S), R;
    }
  }
  function N(w, M, y) {
    let E = [...w];
    const S = E.map((H) => H.getTextContent()).join("");
    let P = S, U, j = 0;
    for (; (U = s(P, M)) && U !== null; ) {
      const H = U.index, R = U.length, T = H + R;
      if (c(j + H, j + T, S, E)) {
        const [G, , q, I] = h(E, j + H, j + T), Y = j + H - G, D = j + T - G, z = f(q, Y, D, U);
        E = z ? [z, ...I] : I, y(U.url, null), j = 0;
      } else
        j += T;
      P = P.substring(T);
    }
  }
  function v(w, M, y) {
    const E = w.getChildren(), S = E.length;
    for (let H = 0; H < S; H++) {
      const R = E[H];
      if (!n.$isTextNode(R) || !R.isSimpleText()) {
        g(w), y(null, w.getURL());
        return;
      }
    }
    const P = w.getTextContent(), U = s(P, M);
    if (U === null || U.text !== P) {
      g(w), y(null, w.getURL());
      return;
    }
    if (!p(w) || !m(w)) {
      g(w), y(null, w.getURL());
      return;
    }
    const j = w.getURL();
    if (j !== U.url && (w.setURL(U.url), y(U.url, j)), U.attributes) {
      const H = w.getRel();
      H !== U.attributes.rel && (w.setRel(U.attributes.rel || null), y(U.attributes.rel || null, H));
      const R = w.getTarget();
      R !== U.attributes.target && (w.setTarget(U.attributes.target || null), y(U.attributes.target || null, R));
    }
  }
  function C(w, M, y) {
    const E = w.getPreviousSibling(), S = w.getNextSibling(), P = w.getTextContent();
    r.$isAutoLinkNode(E) && !d(P) && (E.append(w), v(E, M, y), y(null, E.getURL())), r.$isAutoLinkNode(S) && !u(P) && (g(S), v(S, M, y), y(null, S.getURL()));
  }
  function g(w) {
    const M = w.getChildren(), y = M.length;
    for (let E = y - 1; E >= 0; E--)
      w.insertAfter(M[E]);
    return w.remove(), M.map((E) => E.getLatest());
  }
  function x(w) {
    const M = [w];
    let y = w.getNextSibling();
    for (; y !== null && n.$isTextNode(y) && y.isSimpleText() && (M.push(y), !/[\s]/.test(y.getTextContent())); )
      y = y.getNextSibling();
    return M;
  }
  function b(w, M, y) {
    i.useEffect(() => {
      if (!w.hasNodes([r.AutoLinkNode]))
        throw Error("LexicalAutoLinkPlugin: AutoLinkNode not registered on editor");
      const E = (S, P) => {
        y && y(S, P);
      };
      return t.mergeRegister(w.registerNodeTransform(n.TextNode, (S) => {
        const P = S.getParentOrThrow(), U = S.getPreviousSibling();
        if (r.$isAutoLinkNode(P))
          v(P, M, E);
        else if (!r.$isLinkNode(P)) {
          if (S.isSimpleText() && (d(S.getTextContent()) || !r.$isAutoLinkNode(U))) {
            const j = x(S);
            N(j, M, E);
          }
          C(S, M, E);
        }
      }));
    }, [w, M, y]);
  }
  function A({
    matchers: w,
    onChange: M
  }) {
    const [y] = e.useLexicalComposerContext();
    return b(y, w, M), null;
  }
  return uo.AutoLinkPlugin = A, uo.createLinkMatcherWithRegExp = o, uo;
}
var ho = {}, ru;
function z4() {
  if (ru) return ho;
  ru = 1;
  var r = St, e = lt(), t = it(), n = Ve, i = nt;
  function o(v) {
    let C = new URLSearchParams();
    C.append("code", v);
    for (let g = 1; g < arguments.length; g++) C.append("v", arguments[g]);
    throw Error(`Minified Lexical error #${v}; visit https://lexical.dev/docs/error?${C} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  function s(v, C) {
    for (let g = 0; g < C.length; g++) {
      let x = C[g](v);
      if (x) return x;
    }
    return null;
  }
  let a = /[.,;\s]/;
  function l(v) {
    v = v.getPreviousSibling(), n.$isElementNode(v) && (v = v.getLastDescendant());
    var C;
    return !(C = v === null || n.$isLineBreakNode(v)) && (C = n.$isTextNode(v)) && (v = v.getTextContent(), C = a.test(v[v.length - 1])), C;
  }
  function u(v) {
    return v = v.getNextSibling(), n.$isElementNode(v) && (v = v.getFirstDescendant()), v === null || n.$isLineBreakNode(v) || n.$isTextNode(v) && a.test(v.getTextContent()[0]);
  }
  function d(v, C, g, x) {
    return (0 < v ? a.test(g[v - 1]) : l(x[0])) ? C < g.length ? a.test(g[C]) : u(x[x.length - 1]) : !1;
  }
  function p(v, C, g) {
    let x = [], b = [], A = [], w = 0, M = 0;
    for (v = [...v]; 0 < v.length; ) {
      let y = v[0], E = y.getTextContent().length, S = M;
      M + E <= C ? (x.push(y), w += E) : S >= g ? A.push(y) : b.push(y), M += E, v.shift();
    }
    return [w, x, b, A];
  }
  function m(v, C, g, x) {
    let b = r.$createAutoLinkNode(x.url, x.attributes);
    if (v.length === 1) {
      var A = v[0];
      C === 0 ? [M, A] = A.splitText(g) : [, M, A] = A.splitText(C, g);
      var w = n.$createTextNode(x.text);
      return w.setFormat(M.getFormat()), w.setDetail(M.getDetail()), b.append(w), M.replace(b), A;
    }
    if (1 < v.length) {
      x = v[0];
      var M = x.getTextContent().length;
      for (C === 0 ? A = x : [, A] = x.splitText(C), C = [], x = 1; x < v.length; x++) {
        let y = v[x], E = y.getTextContent().length, S = M, P = M + E;
        if (S < g) if (P <= g) C.push(y);
        else {
          let [U, j] = y.splitText(g - S);
          C.push(U), w = j;
        }
        M += E;
      }
      return v = (g = n.$getSelection()) ? g.getNodes().find(n.$isTextNode) : void 0, M = n.$createTextNode(A.getTextContent()), M.setFormat(A.getFormat()), M.setDetail(A.getDetail()), b.append(M, ...C), v && v === A && (n.$isRangeSelection(g) ? M.select(g.anchor.offset, g.focus.offset) : n.$isNodeSelection(g) && M.select(0, M.getTextContent().length)), A.replace(b), w;
    }
  }
  function c(v, C, g) {
    var x = [...v];
    let b = v = x.map((M) => M.getTextContent()).join(""), A, w = 0;
    for (; (A = s(b, C)) && A !== null; ) {
      let M = A.index, y = M + A.length;
      if (d(w + M, w + y, v, x)) {
        let [E, , S, P] = p(x, w + M, w + y);
        x = (x = m(S, w + M - E, w + y - E, A)) ? [x, ...P] : P, g(A.url, null), w = 0;
      } else w += y;
      b = b.substring(y);
    }
  }
  function h(v, C, g) {
    var x = v.getChildren();
    let b = x.length;
    for (let A = 0; A < b; A++) {
      let w = x[A];
      if (!n.$isTextNode(w) || !w.isSimpleText()) {
        f(v), g(null, v.getURL());
        return;
      }
    }
    x = v.getTextContent(), C = s(x, C), C === null || C.text !== x ? (f(v), g(null, v.getURL())) : l(v) && u(v) ? (x = v.getURL(), x !== C.url && (v.setURL(C.url), g(C.url, x)), C.attributes && (x = v.getRel(), x !== C.attributes.rel && (v.setRel(C.attributes.rel || null), g(C.attributes.rel || null, x)), x = v.getTarget(), x !== C.attributes.target && (v.setTarget(C.attributes.target || null), g(C.attributes.target || null, x)))) : (f(v), g(null, v.getURL()));
  }
  function f(v) {
    let C = v.getChildren();
    var g = C.length;
    for (--g; 0 <= g; g--) v.insertAfter(C[g]);
    return v.remove(), C.map((x) => x.getLatest());
  }
  function N(v, C, g) {
    i.useEffect(() => {
      v.hasNodes([r.AutoLinkNode]) || o(77);
      let x = (b, A) => {
        g && g(b, A);
      };
      return t.mergeRegister(v.registerNodeTransform(n.TextNode, (b) => {
        var A = b.getParentOrThrow(), w = b.getPreviousSibling();
        if (r.$isAutoLinkNode(A)) h(A, C, x);
        else if (!r.$isLinkNode(A)) {
          if (b.isSimpleText() && (a.test(b.getTextContent()[0]) || !r.$isAutoLinkNode(w))) {
            for (A = [b], w = b.getNextSibling(); w !== null && n.$isTextNode(w) && w.isSimpleText() && (A.push(w), !/[\s]/.test(w.getTextContent())); )
              w = w.getNextSibling();
            c(
              A,
              C,
              x
            );
          }
          let M = b.getPreviousSibling();
          A = b.getNextSibling(), w = b.getTextContent(), r.$isAutoLinkNode(M) && !a.test(w[0]) && (M.append(b), h(M, C, x), b = M.getURL(), g && g(null, b)), r.$isAutoLinkNode(A) && !a.test(w[w.length - 1]) && (f(A), h(A, C, x), b = A.getURL(), g && g(null, b));
        }
      }));
    }, [v, C, g]);
  }
  return ho.AutoLinkPlugin = function({ matchers: v, onChange: C }) {
    let [g] = e.useLexicalComposerContext();
    return N(g, v, C), null;
  }, ho.createLinkMatcherWithRegExp = function(v, C = (g) => g) {
    return (g) => (g = v.exec(g), g === null ? null : { index: g.index, length: g[0].length, text: g[0], url: C(g[0]) });
  }, ho;
}
const H4 = process.env.NODE_ENV === "development" ? B4() : z4();
var ss = H4;
const j4 = /((https?:\/\/(www\.)?)|(www\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/, q4 = /(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/, K4 = [
  ss.createLinkMatcherWithRegExp(j4, (r) => r.startsWith("http") ? r : `https://${r}`),
  ss.createLinkMatcherWithRegExp(q4, (r) => `mailto:${r}`)
];
function U4() {
  return /* @__PURE__ */ L.jsx(ss.AutoLinkPlugin, { matchers: K4 });
}
var $a = {}, nu;
function Y4() {
  if (nu) return $a;
  nu = 1;
  var r = St, e = lt(), t = it(), n = Ve, i = nt;
  function o({
    validateUrl: s
  }) {
    const [a] = e.useLexicalComposerContext();
    return i.useEffect(() => {
      if (!a.hasNodes([r.LinkNode]))
        throw new Error("LinkPlugin: LinkNode not registered on editor");
      return t.mergeRegister(a.registerCommand(r.TOGGLE_LINK_COMMAND, (l) => {
        if (l === null)
          return r.toggleLink(l), !0;
        if (typeof l == "string")
          return s === void 0 || s(l) ? (r.toggleLink(l), !0) : !1;
        {
          const {
            url: u,
            target: d,
            rel: p,
            title: m
          } = l;
          return r.toggleLink(u, {
            rel: p,
            target: d,
            title: m
          }), !0;
        }
      }, n.COMMAND_PRIORITY_LOW), s !== void 0 ? a.registerCommand(n.PASTE_COMMAND, (l) => {
        const u = n.$getSelection();
        if (!n.$isRangeSelection(u) || u.isCollapsed() || !(l instanceof ClipboardEvent) || l.clipboardData == null)
          return !1;
        const d = l.clipboardData.getData("text");
        return s(d) ? u.getNodes().some((p) => n.$isElementNode(p)) ? !1 : (a.dispatchCommand(r.TOGGLE_LINK_COMMAND, d), l.preventDefault(), !0) : !1;
      }, n.COMMAND_PRIORITY_LOW) : () => {
      });
    }, [a, s]), null;
  }
  return $a.LinkPlugin = o, $a;
}
var Ia = {}, iu;
function W4() {
  if (iu) return Ia;
  iu = 1;
  var r = St, e = lt(), t = it(), n = Ve, i = nt;
  return Ia.LinkPlugin = function({ validateUrl: o }) {
    let [s] = e.useLexicalComposerContext();
    return i.useEffect(() => {
      if (!s.hasNodes([r.LinkNode])) throw Error("LinkPlugin: LinkNode not registered on editor");
      return t.mergeRegister(s.registerCommand(r.TOGGLE_LINK_COMMAND, (a) => {
        if (a === null) return r.toggleLink(a), !0;
        if (typeof a == "string") return o === void 0 || o(a) ? (r.toggleLink(a), !0) : !1;
        let { url: l, target: u, rel: d, title: p } = a;
        return r.toggleLink(l, { rel: d, target: u, title: p }), !0;
      }, n.COMMAND_PRIORITY_LOW), o !== void 0 ? s.registerCommand(
        n.PASTE_COMMAND,
        (a) => {
          let l = n.$getSelection();
          if (!n.$isRangeSelection(l) || l.isCollapsed() || !(a instanceof ClipboardEvent) || a.clipboardData == null) return !1;
          let u = a.clipboardData.getData("text");
          return o(u) ? l.getNodes().some((d) => n.$isElementNode(d)) ? !1 : (s.dispatchCommand(r.TOGGLE_LINK_COMMAND, u), a.preventDefault(), !0) : !1;
        },
        n.COMMAND_PRIORITY_LOW
      ) : () => {
      });
    }, [s, o]), null;
  }, Ia;
}
const G4 = process.env.NODE_ENV === "development" ? Y4() : W4();
var V4 = G4;
function X4() {
  return /* @__PURE__ */ L.jsx(V4.LinkPlugin, { validateUrl: d1 });
}
var Pa = {}, ou;
function J4() {
  if (ou) return Pa;
  ou = 1;
  var r = lt(), e = ko(), t = it(), n = nt;
  function i(o, s, a) {
    const [l] = r.useLexicalComposerContext();
    n.useEffect(() => t.mergeRegister(...e.registerLexicalTextEntity(l, o, s, a)), [a, l, o, s]);
  }
  return Pa.useLexicalTextEntity = i, Pa;
}
var Fa = {}, au;
function Z4() {
  if (au) return Fa;
  au = 1;
  var r = lt(), e = ko(), t = it(), n = nt;
  return Fa.useLexicalTextEntity = function(i, o, s) {
    let [a] = r.useLexicalComposerContext();
    n.useEffect(() => t.mergeRegister(...e.registerLexicalTextEntity(a, i, o, s)), [s, a, i, o]);
  }, Fa;
}
const Q4 = process.env.NODE_ENV === "development" ? J4() : Z4();
var ev = Q4;
const tv = /(^|$|[^A-Za-zÂªÂµÂºÃ€-Ã–Ã˜-Ã¶Ã¸-ËË†-Ë‘Ë -Ë¤Ë¬Ë®Í°-Í´Í¶Í·Íº-Í½Î†Îˆ-ÎŠÎŒÎŽ-Î¡Î£-ÏµÏ·-ÒÒŠ-Ô§Ô±-Õ–Õ™Õ¡-Ö‡×-×ª×°-×²Ø -ÙŠÙ®Ù¯Ù±-Û“Û•Û¥Û¦Û®Û¯Ûº-Û¼Û¿ÜÜ’-Ü¯Ý-Þ¥Þ±ßŠ-ßªß´ßµßºà €-à •à šà ¤à ¨à¡€-à¡˜à¢ à¢¢-à¢¬à¤„-à¤¹à¤½à¥à¥˜-à¥¡à¥±-à¥·à¥¹-à¥¿à¦…-à¦Œà¦à¦à¦“-à¦¨à¦ª-à¦°à¦²à¦¶-à¦¹à¦½à§Žà§œà§à§Ÿ-à§¡à§°à§±à¨…-à¨Šà¨à¨à¨“-à¨¨à¨ª-à¨°à¨²à¨³à¨µà¨¶à¨¸à¨¹à©™-à©œà©žà©²-à©´àª…-àªàª-àª‘àª“-àª¨àªª-àª°àª²àª³àªµ-àª¹àª½à«à« à«¡à¬…-à¬Œà¬à¬à¬“-à¬¨à¬ª-à¬°à¬²à¬³à¬µ-à¬¹à¬½à­œà­à­Ÿ-à­¡à­±à®ƒà®…-à®Šà®Ž-à®à®’-à®•à®™à®šà®œà®žà®Ÿà®£à®¤à®¨-à®ªà®®-à®¹à¯à°…-à°Œà°Ž-à°à°’-à°¨à°ª-à°³à°µ-à°¹à°½à±˜à±™à± à±¡à²…-à²Œà²Ž-à²à²’-à²¨à²ª-à²³à²µ-à²¹à²½à³žà³ à³¡à³±à³²à´…-à´Œà´Ž-à´à´’-à´ºà´½àµŽàµ àµ¡àµº-àµ¿à¶…-à¶–à¶š-à¶±à¶³-à¶»à¶½à·€-à·†à¸-à¸°à¸²à¸³à¹€-à¹†àºàº‚àº„àº‡àºˆàºŠàºàº”-àº—àº™-àºŸàº¡-àº£àº¥àº§àºªàº«àº­-àº°àº²àº³àº½à»€-à»„à»†à»œ-à»Ÿà¼€à½€-à½‡à½‰-à½¬à¾ˆ-à¾Œá€€-á€ªá€¿á-á•áš-áá¡á¥á¦á®-á°áµ-á‚á‚Žá‚ -áƒ…áƒ‡áƒáƒ-áƒºáƒ¼-á‰ˆá‰Š-á‰á‰-á‰–á‰˜á‰š-á‰á‰ -áŠˆáŠŠ-áŠáŠ-áŠ°áŠ²-áŠµáŠ¸-áŠ¾á‹€á‹‚-á‹…á‹ˆ-á‹–á‹˜-áŒáŒ’-áŒ•áŒ˜-ášáŽ€-áŽáŽ -á´á-á™¬á™¯-á™¿áš-áššáš -á›ªáœ€-áœŒáœŽ-áœ‘áœ -áœ±á€-á‘á -á¬á®-á°áž€-áž³áŸ—áŸœá  -á¡·á¢€-á¢¨á¢ªá¢°-á£µá¤€-á¤œá¥-á¥­á¥°-á¥´á¦€-á¦«á§-á§‡á¨€-á¨–á¨ -á©”áª§á¬…-á¬³á­…-á­‹á®ƒ-á® á®®á®¯á®º-á¯¥á°€-á°£á±-á±á±š-á±½á³©-á³¬á³®-á³±á³µá³¶á´€-á¶¿á¸€-á¼•á¼˜-á¼á¼ -á½…á½ˆ-á½á½-á½—á½™á½›á½á½Ÿ-á½½á¾€-á¾´á¾¶-á¾¼á¾¾á¿‚-á¿„á¿†-á¿Œá¿-á¿“á¿–-á¿›á¿ -á¿¬á¿²-á¿´á¿¶-á¿¼â±â¿â‚-â‚œâ„‚â„‡â„Š-â„“â„•â„™-â„â„¤â„¦â„¨â„ª-â„­â„¯-â„¹â„¼-â„¿â……-â…‰â…Žâ†ƒâ†„â°€-â°®â°°-â±žâ± -â³¤â³«-â³®â³²â³³â´€-â´¥â´§â´­â´°-âµ§âµ¯â¶€-â¶–â¶ -â¶¦â¶¨-â¶®â¶°-â¶¶â¶¸-â¶¾â·€-â·†â·ˆ-â·Žâ·-â·–â·˜-â·žâ¸¯ã€…ã€†ã€±-ã€µã€»ã€¼ã-ã‚–ã‚-ã‚Ÿã‚¡-ãƒºãƒ¼-ãƒ¿ã„…-ã„­ã„±-ã†Žã† -ã†ºã‡°-ã‡¿ã€-ä¶µä¸€-é¿Œê€€-ê’Œê“-ê“½ê”€-ê˜Œê˜-ê˜Ÿê˜ªê˜«ê™€-ê™®ê™¿-êš—êš -ê›¥êœ—-êœŸêœ¢-êžˆêž‹-êžŽêž-êž“êž -êžªêŸ¸-ê ê ƒ-ê …ê ‡-ê Šê Œ-ê ¢ê¡€-ê¡³ê¢‚-ê¢³ê£²-ê£·ê£»ê¤Š-ê¤¥ê¤°-ê¥†ê¥ -ê¥¼ê¦„-ê¦²ê§ê¨€-ê¨¨ê©€-ê©‚ê©„-ê©‹ê© -ê©¶ê©ºêª€-êª¯êª±êªµêª¶êª¹-êª½ê«€ê«‚ê«›-ê«ê« -ê«ªê«²-ê«´ê¬-ê¬†ê¬‰-ê¬Žê¬‘-ê¬–ê¬ -ê¬¦ê¬¨-ê¬®ê¯€-ê¯¢ê°€-íž£íž°-íŸ†íŸ‹-íŸ»ï¤€-ï©­ï©°-ï«™ï¬€-ï¬†ï¬“-ï¬—ï¬ï¬Ÿ-ï¬¨ï¬ª-ï¬¶ï¬¸-ï¬¼ï¬¾ï­€ï­ï­ƒï­„ï­†-ï®±ï¯“-ï´½ïµ-ï¶ï¶’-ï·‡ï·°-ï·»ï¹°-ï¹´ï¹¶-ï»¼ï¼¡-ï¼ºï½-ï½šï½¦-ï¾¾ï¿‚-ï¿‡ï¿Š-ï¿ï¿’-ï¿—ï¿š-ï¿œ])(congrats|congratulations|gratuluju|gratuluji|gratulujeme|blahopÅ™eju|blahopÅ™eji|blahopÅ™ejeme|Til lykke|Tillykke|GlÃ¼ckwunsch|Gratuliere|felicitaciones|enhorabuena|paljon onnea|onnittelut|FÃ©licitations|gratula|gratulÃ¡lok|gratulÃ¡lunk|congratulazioni|complimenti|ãŠã‚ã§ã¨ã†|ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™|ì¶•í•˜í•´|ì¶•í•˜í•´ìš”|gratulerer|Gefeliciteerd|gratulacje|ParabÃ©ns|parabÃ©ns|felicitaÃ§Ãµes|felicitÄƒri|Ð¼Ð¾Ð¸ Ð¿Ð¾Ð·Ð´Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ñ|Ð¿Ð¾Ð·Ð´Ñ€Ð°Ð²Ð»ÑÐµÐ¼|Ð¿Ð¾Ð·Ð´Ñ€Ð°Ð²Ð»ÑÑŽ|gratulujem|blahoÅ¾elÃ¡m|à¸¢à¸´à¸™à¸”à¸µà¸”à¹‰à¸§à¸¢|à¸‚à¸­à¹à¸ªà¸”à¸‡à¸„à¸§à¸²à¸¡à¸¢à¸´à¸™à¸”à¸µ|tebrikler|tebrik ederim|æ­å–œ|ç¥è´ºä½ |æ­å–œä½ |æ­å–œ|æ­å–œ|baie geluk|veels geluk|à¦…à¦­à¦¿à¦¨à¦¨à§à¦¦à¦¨|ÄŒestitam|ÄŒestitke|ÄŒestitamo|Î£Ï…Î³Ï‡Î±ÏÎ·Ï„Î®ÏÎ¹Î±|ÎœÏ€ÏÎ¬Î²Î¿|àª…àª­àª¿àª¨àª‚àª¦àª¨|badhai|à¤¬à¤§à¤¾à¤ˆ|à¤…à¤­à¤¿à¤¨à¤‚à¤¦à¤¨|Ð§ÐµÑÑ‚Ð¸Ñ‚Ð°Ð¼|Ð¡Ð²Ð°ÐºÐ° Ñ‡Ð°ÑÑ‚|hongera|à®µà®¾à®´à¯à®¤à¯à®¤à¯à®•à®³à¯|à®µà®¾à®´à¯à®¤à¯à®¤à¯à®•à¯à®•à®³à¯|à°…à°­à°¿à°¨à°‚à°¦à°¨à°²à±|à´…à´­à´¿à´¨à´¨àµà´¦à´¨à´™àµà´™àµ¾|ChÃºc má»«ng|×ž×–×œ ×˜×•×‘|mazel tov|mazal tov)(^|$|[^A-Za-zÂªÂµÂºÃ€-Ã–Ã˜-Ã¶Ã¸-ËË†-Ë‘Ë -Ë¤Ë¬Ë®Í°-Í´Í¶Í·Íº-Í½Î†Îˆ-ÎŠÎŒÎŽ-Î¡Î£-ÏµÏ·-ÒÒŠ-Ô§Ô±-Õ–Õ™Õ¡-Ö‡×-×ª×°-×²Ø -ÙŠÙ®Ù¯Ù±-Û“Û•Û¥Û¦Û®Û¯Ûº-Û¼Û¿ÜÜ’-Ü¯Ý-Þ¥Þ±ßŠ-ßªß´ßµßºà €-à •à šà ¤à ¨à¡€-à¡˜à¢ à¢¢-à¢¬à¤„-à¤¹à¤½à¥à¥˜-à¥¡à¥±-à¥·à¥¹-à¥¿à¦…-à¦Œà¦à¦à¦“-à¦¨à¦ª-à¦°à¦²à¦¶-à¦¹à¦½à§Žà§œà§à§Ÿ-à§¡à§°à§±à¨…-à¨Šà¨à¨à¨“-à¨¨à¨ª-à¨°à¨²à¨³à¨µà¨¶à¨¸à¨¹à©™-à©œà©žà©²-à©´àª…-àªàª-àª‘àª“-àª¨àªª-àª°àª²àª³àªµ-àª¹àª½à«à« à«¡à¬…-à¬Œà¬à¬à¬“-à¬¨à¬ª-à¬°à¬²à¬³à¬µ-à¬¹à¬½à­œà­à­Ÿ-à­¡à­±à®ƒà®…-à®Šà®Ž-à®à®’-à®•à®™à®šà®œà®žà®Ÿà®£à®¤à®¨-à®ªà®®-à®¹à¯à°…-à°Œà°Ž-à°à°’-à°¨à°ª-à°³à°µ-à°¹à°½à±˜à±™à± à±¡à²…-à²Œà²Ž-à²à²’-à²¨à²ª-à²³à²µ-à²¹à²½à³žà³ à³¡à³±à³²à´…-à´Œà´Ž-à´à´’-à´ºà´½àµŽàµ àµ¡àµº-àµ¿à¶…-à¶–à¶š-à¶±à¶³-à¶»à¶½à·€-à·†à¸-à¸°à¸²à¸³à¹€-à¹†àºàº‚àº„àº‡àºˆàºŠàºàº”-àº—àº™-àºŸàº¡-àº£àº¥àº§àºªàº«àº­-àº°àº²àº³àº½à»€-à»„à»†à»œ-à»Ÿà¼€à½€-à½‡à½‰-à½¬à¾ˆ-à¾Œá€€-á€ªá€¿á-á•áš-áá¡á¥á¦á®-á°áµ-á‚á‚Žá‚ -áƒ…áƒ‡áƒáƒ-áƒºáƒ¼-á‰ˆá‰Š-á‰á‰-á‰–á‰˜á‰š-á‰á‰ -áŠˆáŠŠ-áŠáŠ-áŠ°áŠ²-áŠµáŠ¸-áŠ¾á‹€á‹‚-á‹…á‹ˆ-á‹–á‹˜-áŒáŒ’-áŒ•áŒ˜-ášáŽ€-áŽáŽ -á´á-á™¬á™¯-á™¿áš-áššáš -á›ªáœ€-áœŒáœŽ-áœ‘áœ -áœ±á€-á‘á -á¬á®-á°áž€-áž³áŸ—áŸœá  -á¡·á¢€-á¢¨á¢ªá¢°-á£µá¤€-á¤œá¥-á¥­á¥°-á¥´á¦€-á¦«á§-á§‡á¨€-á¨–á¨ -á©”áª§á¬…-á¬³á­…-á­‹á®ƒ-á® á®®á®¯á®º-á¯¥á°€-á°£á±-á±á±š-á±½á³©-á³¬á³®-á³±á³µá³¶á´€-á¶¿á¸€-á¼•á¼˜-á¼á¼ -á½…á½ˆ-á½á½-á½—á½™á½›á½á½Ÿ-á½½á¾€-á¾´á¾¶-á¾¼á¾¾á¿‚-á¿„á¿†-á¿Œá¿-á¿“á¿–-á¿›á¿ -á¿¬á¿²-á¿´á¿¶-á¿¼â±â¿â‚-â‚œâ„‚â„‡â„Š-â„“â„•â„™-â„â„¤â„¦â„¨â„ª-â„­â„¯-â„¹â„¼-â„¿â……-â…‰â…Žâ†ƒâ†„â°€-â°®â°°-â±žâ± -â³¤â³«-â³®â³²â³³â´€-â´¥â´§â´­â´°-âµ§âµ¯â¶€-â¶–â¶ -â¶¦â¶¨-â¶®â¶°-â¶¶â¶¸-â¶¾â·€-â·†â·ˆ-â·Žâ·-â·–â·˜-â·žâ¸¯ã€…ã€†ã€±-ã€µã€»ã€¼ã-ã‚–ã‚-ã‚Ÿã‚¡-ãƒºãƒ¼-ãƒ¿ã„…-ã„­ã„±-ã†Žã† -ã†ºã‡°-ã‡¿ã€-ä¶µä¸€-é¿Œê€€-ê’Œê“-ê“½ê”€-ê˜Œê˜-ê˜Ÿê˜ªê˜«ê™€-ê™®ê™¿-êš—êš -ê›¥êœ—-êœŸêœ¢-êžˆêž‹-êžŽêž-êž“êž -êžªêŸ¸-ê ê ƒ-ê …ê ‡-ê Šê Œ-ê ¢ê¡€-ê¡³ê¢‚-ê¢³ê£²-ê£·ê£»ê¤Š-ê¤¥ê¤°-ê¥†ê¥ -ê¥¼ê¦„-ê¦²ê§ê¨€-ê¨¨ê©€-ê©‚ê©„-ê©‹ê© -ê©¶ê©ºêª€-êª¯êª±êªµêª¶êª¹-êª½ê«€ê«‚ê«›-ê«ê« -ê«ªê«²-ê«´ê¬-ê¬†ê¬‰-ê¬Žê¬‘-ê¬–ê¬ -ê¬¦ê¬¨-ê¬®ê¯€-ê¯¢ê°€-íž£íž°-íŸ†íŸ‹-íŸ»ï¤€-ï©­ï©°-ï«™ï¬€-ï¬†ï¬“-ï¬—ï¬ï¬Ÿ-ï¬¨ï¬ª-ï¬¶ï¬¸-ï¬¼ï¬¾ï­€ï­ï­ƒï­„ï­†-ï®±ï¯“-ï´½ïµ-ï¶ï¶’-ï·‡ï·°-ï·»ï¹°-ï¹´ï¹¶-ï»¼ï¼¡-ï¼ºï½-ï½šï½¦-ï¾¾ï¿‚-ï¿‡ï¿Š-ï¿ï¿’-ï¿—ï¿š-ï¿œ])/i;
function rv() {
  const [r] = Ot.useLexicalComposerContext();
  We(() => {
    if (!r.hasNodes([qn]))
      throw new Error("KeywordsPlugin: KeywordNode not registered on editor");
  }, [r]);
  const e = ct((n) => Vu(n.getTextContent()), []), t = ct((n) => {
    const i = tv.exec(n);
    if (i === null)
      return null;
    const o = i[2].length, s = i.index + i[1].length;
    return {
      end: s + o,
      start: s
    };
  }, []);
  return ev.useLexicalTextEntity(
    t,
    qn,
    e
  ), null;
}
const su = /* @__PURE__ */ new Map([
  [":)", ["emoji happysmile", "ðŸ™‚"]],
  [":D", ["emoji veryhappysmile", "ðŸ˜€"]],
  [":(", ["emoji unhappysmile", "ðŸ™"]],
  ["<3", ["emoji heart", "â¤"]],
  ["ðŸ™‚", ["emoji happysmile", "ðŸ™‚"]],
  ["ðŸ˜€", ["emoji veryhappysmile", "ðŸ˜€"]],
  ["ðŸ™", ["emoji unhappysmile", "ðŸ™"]],
  ["â¤", ["emoji heart", "â¤"]]
]);
function nv(r) {
  const e = r.getTextContent();
  for (let t = 0; t < e.length; t++) {
    const n = su.get(e[t]) || su.get(e.slice(t, t + 2));
    if (n !== void 0) {
      const [i, o] = n;
      let s;
      t === 0 ? [s] = r.splitText(t + 2) : [, s] = r.splitText(t, t + 2);
      const a = Gu(i, o);
      return s.replace(a), a;
    }
  }
  return null;
}
function iv(r) {
  let e = r;
  for (; e !== null; ) {
    if (!e.isSimpleText())
      return;
    e = nv(e);
  }
}
function ov(r) {
  We(() => {
    if (!r.hasNodes([ki]))
      throw new Error("EmojisPlugin: EmojiNode not registered on editor");
    return r.registerNodeTransform(ds, iv);
  }, [r]);
}
function av() {
  const [r] = Ot.useLexicalComposerContext();
  return ov(r), null;
}
var qr = {}, lu;
function sv() {
  if (lu) return qr;
  lu = 1;
  var r = lt(), e = Ve, t = nt, n = it(), s = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  class a {
    constructor(P) {
      this.key = P, this.ref = {
        current: null
      }, this.setRefElement = this.setRefElement.bind(this);
    }
    setRefElement(P) {
      this.ref = {
        current: P
      };
    }
  }
  const l = (S) => {
    const P = document.getElementById("typeahead-menu");
    if (!P) return;
    const U = P.getBoundingClientRect();
    U.top + U.height > window.innerHeight && P.scrollIntoView({
      block: "center"
    }), U.top < 0 && P.scrollIntoView({
      block: "center"
    }), S.scrollIntoView({
      block: "nearest"
    });
  };
  function u(S, P, U) {
    let j = U;
    for (let H = j; H <= P.length; H++)
      S.substr(-H) === P.substr(0, H) && (j = H);
    return j;
  }
  function d(S) {
    const P = e.$getSelection();
    if (!e.$isRangeSelection(P) || !P.isCollapsed())
      return null;
    const U = P.anchor;
    if (U.type !== "text")
      return null;
    const j = U.getNode();
    if (!j.isSimpleText())
      return null;
    const H = U.offset, R = j.getTextContent().slice(0, H), T = S.replaceableString.length, $ = u(R, S.matchingString, T), G = H - $;
    if (G < 0)
      return null;
    let q;
    return G === 0 ? [q] = j.splitText(H) : [, q] = j.splitText(G, H), q;
  }
  function p(S, P) {
    let U = getComputedStyle(S);
    const j = U.position === "absolute", H = /(auto|scroll)/;
    if (U.position === "fixed")
      return document.body;
    for (let R = S; R = R.parentElement; )
      if (U = getComputedStyle(R), !(j && U.position === "static") && H.test(U.overflow + U.overflowY + U.overflowX))
        return R;
    return document.body;
  }
  function m(S, P) {
    const U = S.getBoundingClientRect(), j = P.getBoundingClientRect();
    return U.top > j.top && U.top < j.bottom;
  }
  function c(S, P, U, j) {
    const [H] = r.useLexicalComposerContext();
    t.useEffect(() => {
      if (P != null && S != null) {
        const R = H.getRootElement(), T = R != null ? p(R) : document.body;
        let $ = !1, G = m(P, T);
        const q = function() {
          $ || (window.requestAnimationFrame(function() {
            U(), $ = !1;
          }), $ = !0);
          const Y = m(P, T);
          Y !== G && (G = Y, j != null && j(Y));
        }, I = new ResizeObserver(U);
        return window.addEventListener("resize", U), document.addEventListener("scroll", q, {
          capture: !0,
          passive: !0
        }), I.observe(P), () => {
          I.unobserve(P), window.removeEventListener("resize", U), document.removeEventListener("scroll", q, !0);
        };
      }
    }, [P, H, j, U, S]);
  }
  const h = e.createCommand("SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND");
  function f({
    close: S,
    editor: P,
    anchorElementRef: U,
    resolution: j,
    options: H,
    menuRenderFn: R,
    onSelectOption: T,
    shouldSplitNodeWithQuery: $ = !1,
    commandPriority: G = e.COMMAND_PRIORITY_LOW
  }) {
    const [q, I] = t.useState(null), Y = j.match && j.match.matchingString;
    t.useEffect(() => {
      I(0);
    }, [Y]);
    const D = t.useCallback((Q) => {
      P.update(() => {
        const ne = j.match != null && $ ? d(j.match) : null;
        T(Q, ne, S, j.match ? j.match.matchingString : "");
      });
    }, [P, $, j.match, T, S]), z = t.useCallback((Q) => {
      const ne = P.getRootElement();
      ne !== null && (ne.setAttribute("aria-activedescendant", "typeahead-item-" + Q), I(Q));
    }, [P]);
    t.useEffect(() => () => {
      const Q = P.getRootElement();
      Q !== null && Q.removeAttribute("aria-activedescendant");
    }, [P]), s(() => {
      H === null ? I(null) : q === null && z(0);
    }, [H, q, z]), t.useEffect(() => n.mergeRegister(P.registerCommand(h, ({
      option: Q
    }) => Q.ref && Q.ref.current != null ? (l(Q.ref.current), !0) : !1, G)), [P, z, G]), t.useEffect(() => n.mergeRegister(P.registerCommand(e.KEY_ARROW_DOWN_COMMAND, (Q) => {
      const ne = Q;
      if (H !== null && H.length && q !== null) {
        const fe = q !== H.length - 1 ? q + 1 : 0;
        z(fe);
        const _e = H[fe];
        _e.ref != null && _e.ref.current && P.dispatchCommand(h, {
          index: fe,
          option: _e
        }), ne.preventDefault(), ne.stopImmediatePropagation();
      }
      return !0;
    }, G), P.registerCommand(e.KEY_ARROW_UP_COMMAND, (Q) => {
      const ne = Q;
      if (H !== null && H.length && q !== null) {
        const fe = q !== 0 ? q - 1 : H.length - 1;
        z(fe);
        const _e = H[fe];
        _e.ref != null && _e.ref.current && l(_e.ref.current), ne.preventDefault(), ne.stopImmediatePropagation();
      }
      return !0;
    }, G), P.registerCommand(e.KEY_ESCAPE_COMMAND, (Q) => {
      const ne = Q;
      return ne.preventDefault(), ne.stopImmediatePropagation(), S(), !0;
    }, G), P.registerCommand(e.KEY_TAB_COMMAND, (Q) => {
      const ne = Q;
      return H === null || q === null || H[q] == null ? !1 : (ne.preventDefault(), ne.stopImmediatePropagation(), D(H[q]), !0);
    }, G), P.registerCommand(e.KEY_ENTER_COMMAND, (Q) => H === null || q === null || H[q] == null ? !1 : (Q !== null && (Q.preventDefault(), Q.stopImmediatePropagation()), D(H[q]), !0), G)), [D, S, P, H, q, z, G]);
    const X = t.useMemo(() => ({
      options: H,
      selectOptionAndCleanUp: D,
      selectedIndex: q,
      setHighlightedIndex: I
    }), [D, q, H]);
    return R(U, X, j.match ? j.match.matchingString : "");
  }
  function N(S, P, U, j = document.body) {
    const [H] = r.useLexicalComposerContext(), R = t.useRef(document.createElement("div")), T = t.useCallback(() => {
      R.current.style.top = R.current.style.bottom;
      const G = H.getRootElement(), q = R.current, I = q.firstChild;
      if (G !== null && S !== null) {
        const {
          left: Y,
          top: D,
          width: z,
          height: X
        } = S.getRect(), Q = R.current.offsetHeight;
        if (q.style.top = `${D + window.pageYOffset + Q + 3}px`, q.style.left = `${Y + window.pageXOffset}px`, q.style.height = `${X}px`, q.style.width = `${z}px`, I !== null) {
          I.style.top = `${D}`;
          const ne = I.getBoundingClientRect(), fe = ne.height, _e = ne.width, pe = G.getBoundingClientRect();
          Y + _e > pe.right && (q.style.left = `${pe.right - _e + window.pageXOffset}px`), (D + fe > window.innerHeight || D + fe > pe.bottom) && D - pe.top > fe && (q.style.top = `${D - fe + window.pageYOffset - X}px`);
        }
        q.isConnected || (U != null && (q.className = U), q.setAttribute("aria-label", "Typeahead menu"), q.setAttribute("id", "typeahead-menu"), q.setAttribute("role", "listbox"), q.style.display = "block", q.style.position = "absolute", j.append(q)), R.current = q, G.setAttribute("aria-controls", "typeahead-menu");
      }
    }, [H, S, U, j]);
    t.useEffect(() => {
      const G = H.getRootElement();
      if (S !== null)
        return T(), () => {
          G !== null && G.removeAttribute("aria-controls");
          const q = R.current;
          q !== null && q.isConnected && q.remove();
        };
    }, [H, T, S]);
    const $ = t.useCallback((G) => {
      S !== null && (G || P(null));
    }, [S, P]);
    return c(S, R.current, T, $), R;
  }
  const v = `\\.,\\+\\*\\?\\$\\@\\|#{}\\(\\)\\^\\-\\[\\]\\\\/!%'"~=<>_:;`;
  function C(S) {
    const P = S.anchor;
    if (P.type !== "text")
      return null;
    const U = P.getNode();
    if (!U.isSimpleText())
      return null;
    const j = P.offset;
    return U.getTextContent().slice(0, j);
  }
  function g(S, P, U) {
    const j = U.getSelection();
    if (j === null || !j.isCollapsed)
      return !1;
    const H = j.anchorNode, R = S, T = j.anchorOffset;
    if (H == null || T == null)
      return !1;
    try {
      P.setStart(H, R), P.setEnd(H, T);
    } catch {
      return !1;
    }
    return !0;
  }
  function x(S) {
    let P = null;
    return S.getEditorState().read(() => {
      const U = e.$getSelection();
      e.$isRangeSelection(U) && (P = C(U));
    }), P;
  }
  function b(S, P) {
    return P !== 0 ? !1 : S.getEditorState().read(() => {
      const U = e.$getSelection();
      if (e.$isRangeSelection(U)) {
        const R = U.anchor.getNode().getPreviousSibling();
        return e.$isTextNode(R) && R.isTextEntity();
      }
      return !1;
    });
  }
  function A(S) {
    t.startTransition ? t.startTransition(S) : S();
  }
  function w(S, P) {
    let U = getComputedStyle(S);
    const j = U.position === "absolute", H = P ? /(auto|scroll|hidden)/ : /(auto|scroll)/;
    if (U.position === "fixed")
      return document.body;
    for (let R = S; R = R.parentElement; )
      if (U = getComputedStyle(R), !(j && U.position === "static") && H.test(U.overflow + U.overflowY + U.overflowX))
        return R;
    return document.body;
  }
  const M = e.createCommand("SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND");
  function y(S, {
    minLength: P = 1,
    maxLength: U = 75
  }) {
    return t.useCallback((j) => {
      const H = "[^" + S + v + "\\s]", T = new RegExp("(^|\\s|\\()([" + S + "]((?:" + H + "){0," + U + "}))$").exec(j);
      if (T !== null) {
        const $ = T[1], G = T[3];
        if (G.length >= P)
          return {
            leadOffset: T.index + $.length,
            matchingString: G,
            replaceableString: T[2]
          };
      }
      return null;
    }, [U, P, S]);
  }
  function E({
    options: S,
    onQueryChange: P,
    onSelectOption: U,
    onOpen: j,
    onClose: H,
    menuRenderFn: R,
    triggerFn: T,
    anchorClassName: $,
    commandPriority: G = e.COMMAND_PRIORITY_LOW,
    parent: q
  }) {
    const [I] = r.useLexicalComposerContext(), [Y, D] = t.useState(null), z = N(Y, D, $, q), X = t.useCallback(() => {
      D(null), H != null && Y !== null && H();
    }, [H, Y]), Q = t.useCallback((ne) => {
      D(ne), j != null && Y === null && j(ne);
    }, [j, Y]);
    return t.useEffect(() => {
      const ne = () => {
        I.getEditorState().read(() => {
          const _e = I._window || window, pe = _e.document.createRange(), Ne = e.$getSelection(), B = x(I);
          if (!e.$isRangeSelection(Ne) || !Ne.isCollapsed() || B === null || pe === null) {
            X();
            return;
          }
          const F = T(B, I);
          if (P(F ? F.matchingString : null), F !== null && !b(I, F.leadOffset) && g(F.leadOffset, pe, _e) !== null) {
            A(() => Q({
              getRect: () => pe.getBoundingClientRect(),
              match: F
            }));
            return;
          }
          X();
        });
      }, fe = I.registerUpdateListener(ne);
      return () => {
        fe();
      };
    }, [I, T, P, Y, X, Q]), Y === null || I === null ? null : /* @__PURE__ */ t.createElement(f, {
      close: X,
      resolution: Y,
      editor: I,
      anchorElementRef: z,
      options: S,
      menuRenderFn: R,
      shouldSplitNodeWithQuery: !0,
      onSelectOption: U,
      commandPriority: G
    });
  }
  return qr.LexicalTypeaheadMenuPlugin = E, qr.MenuOption = a, qr.PUNCTUATION = v, qr.SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND = M, qr.getScrollParent = w, qr.useBasicTypeaheadTriggerMatch = y, qr.useDynamicPositioning = c, qr;
}
var Kr = {}, cu;
function lv() {
  if (cu) return Kr;
  cu = 1;
  var r = lt(), e = Ve, t = nt, n = it(), i = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  class o {
    constructor(x) {
      this.key = x, this.ref = { current: null }, this.setRefElement = this.setRefElement.bind(this);
    }
    setRefElement(x) {
      this.ref = { current: x };
    }
  }
  let s = (g) => {
    const x = document.getElementById("typeahead-menu");
    if (x) {
      var b = x.getBoundingClientRect();
      b.top + b.height > window.innerHeight && x.scrollIntoView({ block: "center" }), 0 > b.top && x.scrollIntoView({ block: "center" }), g.scrollIntoView({ block: "nearest" });
    }
  };
  function a(g) {
    var x = e.$getSelection();
    if (!e.$isRangeSelection(x) || !x.isCollapsed()) return null;
    var b = x.anchor;
    if (b.type !== "text" || (x = b.getNode(), !x.isSimpleText())) return null;
    b = b.offset;
    let A = x.getTextContent().slice(0, b);
    var w = g.matchingString;
    g = g.replaceableString.length;
    for (let y = g; y <= w.length; y++) A.substr(-y) === w.substr(0, y) && (g = y);
    if (g = b - g, 0 > g) return null;
    let M;
    return g === 0 ? [M] = x.splitText(b) : [, M] = x.splitText(g, b), M;
  }
  function l(g, x) {
    let b = getComputedStyle(g), A = b.position === "absolute";
    if (x = x ? /(auto|scroll|hidden)/ : /(auto|scroll)/, b.position === "fixed") return document.body;
    for (; g = g.parentElement; ) if (b = getComputedStyle(g), (!A || b.position !== "static") && x.test(b.overflow + b.overflowY + b.overflowX)) return g;
    return document.body;
  }
  function u(g, x) {
    return g = g.getBoundingClientRect(), x = x.getBoundingClientRect(), g.top > x.top && g.top < x.bottom;
  }
  function d(g, x, b, A) {
    let [w] = r.useLexicalComposerContext();
    t.useEffect(() => {
      if (x != null && g != null) {
        let M = w.getRootElement(), y = M != null ? l(M, !1) : document.body, E = !1, S = u(x, y), P = function() {
          E || (window.requestAnimationFrame(function() {
            b(), E = !1;
          }), E = !0);
          const j = u(x, y);
          j !== S && (S = j, A != null && A(j));
        }, U = new ResizeObserver(b);
        return window.addEventListener("resize", b), document.addEventListener("scroll", P, { capture: !0, passive: !0 }), U.observe(x), () => {
          U.unobserve(x), window.removeEventListener("resize", b), document.removeEventListener(
            "scroll",
            P,
            !0
          );
        };
      }
    }, [x, w, A, b, g]);
  }
  let p = e.createCommand("SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND");
  function m({ close: g, editor: x, anchorElementRef: b, resolution: A, options: w, menuRenderFn: M, onSelectOption: y, shouldSplitNodeWithQuery: E = !1, commandPriority: S = e.COMMAND_PRIORITY_LOW }) {
    let [P, U] = t.useState(null);
    t.useEffect(() => {
      U(0);
    }, [A.match && A.match.matchingString]);
    let j = t.useCallback((T) => {
      x.update(() => {
        const $ = A.match != null && E ? a(A.match) : null;
        y(T, $, g, A.match ? A.match.matchingString : "");
      });
    }, [x, E, A.match, y, g]), H = t.useCallback((T) => {
      const $ = x.getRootElement();
      $ !== null && ($.setAttribute(
        "aria-activedescendant",
        "typeahead-item-" + T
      ), U(T));
    }, [x]);
    t.useEffect(() => () => {
      let T = x.getRootElement();
      T !== null && T.removeAttribute("aria-activedescendant");
    }, [x]), i(() => {
      w === null ? U(null) : P === null && H(0);
    }, [w, P, H]), t.useEffect(() => n.mergeRegister(x.registerCommand(p, ({ option: T }) => T.ref && T.ref.current != null ? (s(T.ref.current), !0) : !1, S)), [x, H, S]), t.useEffect(() => n.mergeRegister(x.registerCommand(e.KEY_ARROW_DOWN_COMMAND, (T) => {
      if (w !== null && w.length && P !== null) {
        let $ = P !== w.length - 1 ? P + 1 : 0;
        H($);
        let G = w[$];
        G.ref != null && G.ref.current && x.dispatchCommand(p, { index: $, option: G }), T.preventDefault(), T.stopImmediatePropagation();
      }
      return !0;
    }, S), x.registerCommand(e.KEY_ARROW_UP_COMMAND, (T) => {
      if (w !== null && w.length && P !== null) {
        var $ = P !== 0 ? P - 1 : w.length - 1;
        H($), $ = w[$], $.ref != null && $.ref.current && s($.ref.current), T.preventDefault(), T.stopImmediatePropagation();
      }
      return !0;
    }, S), x.registerCommand(e.KEY_ESCAPE_COMMAND, (T) => (T.preventDefault(), T.stopImmediatePropagation(), g(), !0), S), x.registerCommand(e.KEY_TAB_COMMAND, (T) => w === null || P === null || w[P] == null ? !1 : (T.preventDefault(), T.stopImmediatePropagation(), j(w[P]), !0), S), x.registerCommand(e.KEY_ENTER_COMMAND, (T) => w === null || P === null || w[P] == null ? !1 : (T !== null && (T.preventDefault(), T.stopImmediatePropagation()), j(w[P]), !0), S)), [j, g, x, w, P, H, S]);
    let R = t.useMemo(() => ({ options: w, selectOptionAndCleanUp: j, selectedIndex: P, setHighlightedIndex: U }), [j, P, w]);
    return M(b, R, A.match ? A.match.matchingString : "");
  }
  function c(g, x, b, A = document.body) {
    let [w] = r.useLexicalComposerContext(), M = t.useRef(document.createElement("div")), y = t.useCallback(
      () => {
        M.current.style.top = M.current.style.bottom;
        const S = w.getRootElement(), P = M.current;
        var U = P.firstChild;
        if (S !== null && g !== null) {
          const { left: H, top: R, width: T, height: $ } = g.getRect();
          if (P.style.top = `${R + window.pageYOffset + M.current.offsetHeight + 3}px`, P.style.left = `${H + window.pageXOffset}px`, P.style.height = `${$}px`, P.style.width = `${T}px`, U !== null) {
            U.style.top = `${R}`;
            var j = U.getBoundingClientRect();
            U = j.height, j = j.width;
            const G = S.getBoundingClientRect();
            H + j > G.right && (P.style.left = `${G.right - j + window.pageXOffset}px`), (R + U > window.innerHeight || R + U > G.bottom) && R - G.top > U && (P.style.top = `${R - U + window.pageYOffset - $}px`);
          }
          P.isConnected || (b != null && (P.className = b), P.setAttribute("aria-label", "Typeahead menu"), P.setAttribute("id", "typeahead-menu"), P.setAttribute("role", "listbox"), P.style.display = "block", P.style.position = "absolute", A.append(P)), M.current = P, S.setAttribute("aria-controls", "typeahead-menu");
        }
      },
      [w, g, b, A]
    );
    t.useEffect(() => {
      let S = w.getRootElement();
      if (g !== null) return y(), () => {
        S !== null && S.removeAttribute("aria-controls");
        let P = M.current;
        P !== null && P.isConnected && P.remove();
      };
    }, [w, y, g]);
    let E = t.useCallback((S) => {
      g !== null && (S || x(null));
    }, [g, x]);
    return d(g, M.current, y, E), M;
  }
  function h(g, x, b) {
    var A = b.getSelection();
    if (A === null || !A.isCollapsed || (b = A.anchorNode, A = A.anchorOffset, b == null || A == null)) return !1;
    try {
      x.setStart(b, g), x.setEnd(b, A);
    } catch {
      return !1;
    }
    return !0;
  }
  function f(g) {
    let x = null;
    return g.getEditorState().read(() => {
      var b = e.$getSelection();
      if (e.$isRangeSelection(b)) {
        var A = b.anchor;
        A.type !== "text" ? x = null : (b = A.getNode(), b.isSimpleText() ? (A = A.offset, x = b.getTextContent().slice(0, A)) : x = null);
      }
    }), x;
  }
  function N(g, x) {
    return x !== 0 ? !1 : g.getEditorState().read(() => {
      var b = e.$getSelection();
      return e.$isRangeSelection(b) ? (b = b.anchor.getNode().getPreviousSibling(), e.$isTextNode(b) && b.isTextEntity()) : !1;
    });
  }
  function v(g) {
    t.startTransition ? t.startTransition(g) : g();
  }
  let C = e.createCommand("SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND");
  return Kr.LexicalTypeaheadMenuPlugin = function({ options: g, onQueryChange: x, onSelectOption: b, onOpen: A, onClose: w, menuRenderFn: M, triggerFn: y, anchorClassName: E, commandPriority: S = e.COMMAND_PRIORITY_LOW, parent: P }) {
    let [U] = r.useLexicalComposerContext(), [j, H] = t.useState(null);
    E = c(j, H, E, P);
    let R = t.useCallback(() => {
      H(null), w != null && j !== null && w();
    }, [w, j]), T = t.useCallback(($) => {
      H($), A != null && j === null && A($);
    }, [A, j]);
    return t.useEffect(() => {
      let $ = U.registerUpdateListener(() => {
        U.getEditorState().read(() => {
          const G = U._window || window, q = G.document.createRange(), I = e.$getSelection(), Y = f(U);
          if (e.$isRangeSelection(I) && I.isCollapsed() && Y !== null && q !== null) {
            var D = y(Y, U);
            x(D ? D.matchingString : null), D === null || N(U, D.leadOffset) || h(D.leadOffset, q, G) === null ? R() : v(() => T({ getRect: () => q.getBoundingClientRect(), match: D }));
          } else R();
        });
      });
      return () => {
        $();
      };
    }, [U, y, x, j, R, T]), j === null || U === null ? null : t.createElement(m, { close: R, resolution: j, editor: U, anchorElementRef: E, options: g, menuRenderFn: M, shouldSplitNodeWithQuery: !0, onSelectOption: b, commandPriority: S });
  }, Kr.MenuOption = o, Kr.PUNCTUATION = `\\.,\\+\\*\\?\\$\\@\\|#{}\\(\\)\\^\\-\\[\\]\\\\/!%'"~=<>_:;`, Kr.SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND = C, Kr.getScrollParent = function(g, x) {
    let b = getComputedStyle(g), A = b.position === "absolute";
    if (x = x ? /(auto|scroll|hidden)/ : /(auto|scroll)/, b.position === "fixed") return document.body;
    for (; g = g.parentElement; ) if (b = getComputedStyle(g), (!A || b.position !== "static") && x.test(b.overflow + b.overflowY + b.overflowX)) return g;
    return document.body;
  }, Kr.useBasicTypeaheadTriggerMatch = function(g, { minLength: x = 1, maxLength: b = 75 }) {
    return t.useCallback((A) => {
      if (A = new RegExp("(^|\\s|\\()([" + g + "]((?:[^" + (g + `\\.,\\+\\*\\?\\$\\@\\|#{}\\(\\)\\^\\-\\[\\]\\\\/!%'"~=<>_:;\\s]){0,`) + b + "}))$").exec(A), A !== null) {
        let w = A[1], M = A[3];
        if (M.length >= x) return { leadOffset: A.index + w.length, matchingString: M, replaceableString: A[2] };
      }
      return null;
    }, [b, x, g]);
  }, Kr.useDynamicPositioning = d, Kr;
}
const cv = process.env.NODE_ENV === "development" ? sv() : lv();
var Zr = cv;
class Wt extends Zr.MenuOption {
  constructor(t, n) {
    super(t);
    // What shows up in the editor
    Ye(this, "title");
    // Icon for display
    Ye(this, "icon");
    // For extra searching.
    Ye(this, "keywords");
    // TBD
    Ye(this, "keyboardShortcut");
    // What happens when you select this option?
    Ye(this, "onSelect");
    this.title = t, this.keywords = n.keywords || [], this.icon = n.icon, this.keyboardShortcut = n.keyboardShortcut, this.onSelect = n.onSelect.bind(this);
  }
}
function uv({
  index: r,
  isSelected: e,
  onClick: t,
  onMouseEnter: n,
  option: i
}) {
  let o = "item";
  return e && (o += " selected"), /* @__PURE__ */ L.jsxs(
    "li",
    {
      tabIndex: -1,
      className: o,
      ref: i.setRefElement,
      role: "option",
      "aria-selected": e,
      id: "typeahead-item-" + r,
      onMouseEnter: n,
      onClick: t,
      children: [
        i.icon,
        /* @__PURE__ */ L.jsx("span", { className: "text", children: i.title })
      ]
    },
    i.key
  );
}
function dv(r, e) {
  const t = [];
  if (e == null)
    return t;
  const n = e.match(/^([1-9]\d?)(?:x([1-9]\d?)?)?$/);
  if (n !== null) {
    const i = n[1], o = n[2] ? [n[2]] : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(String);
    t.push(
      ...o.map(
        (s) => new Wt(`${i}x${s} Table`, {
          icon: /* @__PURE__ */ L.jsx("i", { className: "icon table" }),
          keywords: ["table"],
          onSelect: () => r.dispatchCommand(Ge.INSERT_TABLE_COMMAND, { columns: s, rows: i })
        })
      )
    );
  }
  return t;
}
function hv(r, e) {
  return [
    new Wt("Paragraph", {
      icon: /* @__PURE__ */ L.jsx("i", { className: "icon paragraph" }),
      keywords: ["normal", "paragraph", "p", "text"],
      onSelect: () => r.update(() => {
        const t = Nt();
        At(t) && nr.$setBlocksType(t, () => Gt());
      })
    }),
    ...[1, 2, 3].map(
      (t) => new Wt(`Heading ${t}`, {
        icon: /* @__PURE__ */ L.jsx("i", { className: `icon h${t}` }),
        keywords: ["heading", "header", `h${t}`],
        onSelect: () => r.update(() => {
          const n = Nt();
          At(n) && nr.$setBlocksType(n, () => fr.$createHeadingNode(`h${t}`));
        })
      })
    ),
    new Wt("Table", {
      icon: /* @__PURE__ */ L.jsx("i", { className: "icon table" }),
      keywords: ["table", "grid", "spreadsheet", "rows", "columns"],
      onSelect: () => e("Insert Table", (t) => /* @__PURE__ */ L.jsx(lh, { activeEditor: r, onClose: t }))
    }),
    new Wt("Numbered List", {
      icon: /* @__PURE__ */ L.jsx("i", { className: "icon number" }),
      keywords: ["numbered list", "ordered list", "ol"],
      onSelect: () => r.dispatchCommand(Zt.INSERT_ORDERED_LIST_COMMAND, void 0)
    }),
    new Wt("Bulleted List", {
      icon: /* @__PURE__ */ L.jsx("i", { className: "icon bullet" }),
      keywords: ["bulleted list", "unordered list", "ul"],
      onSelect: () => r.dispatchCommand(Zt.INSERT_UNORDERED_LIST_COMMAND, void 0)
    }),
    new Wt("Check List", {
      icon: /* @__PURE__ */ L.jsx("i", { className: "icon check" }),
      keywords: ["check list", "todo list"],
      onSelect: () => r.dispatchCommand(Zt.INSERT_CHECK_LIST_COMMAND, void 0)
    }),
    new Wt("Quote", {
      icon: /* @__PURE__ */ L.jsx("i", { className: "icon quote" }),
      keywords: ["block quote"],
      onSelect: () => r.update(() => {
        const t = Nt();
        At(t) && nr.$setBlocksType(t, () => fr.$createQuoteNode());
      })
    }),
    new Wt("Code", {
      icon: /* @__PURE__ */ L.jsx("i", { className: "icon code" }),
      keywords: ["javascript", "python", "js", "codeblock"],
      onSelect: () => r.update(() => {
        const t = Nt();
        if (At(t))
          if (t.isCollapsed())
            nr.$setBlocksType(t, () => vo.$createCodeNode());
          else {
            const n = t.getTextContent(), i = vo.$createCodeNode();
            t.insertNodes([i]), t.insertRawText(n);
          }
      })
    }),
    new Wt("Divider", {
      icon: /* @__PURE__ */ L.jsx("i", { className: "icon horizontal-rule" }),
      keywords: ["horizontal rule", "divider", "hr"],
      onSelect: () => r.dispatchCommand(Li.INSERT_HORIZONTAL_RULE_COMMAND, void 0)
    }),
    new Wt("Page Break", {
      icon: /* @__PURE__ */ L.jsx("i", { className: "icon page-break" }),
      keywords: ["page break", "divider"],
      onSelect: () => r.dispatchCommand(Vs, void 0)
    }),
    new Wt("Excalidraw", {
      icon: /* @__PURE__ */ L.jsx("i", { className: "icon diagram-2" }),
      keywords: ["excalidraw", "diagram", "drawing"],
      onSelect: () => r.dispatchCommand(Qs, void 0)
    }),
    new Wt("Poll", {
      icon: /* @__PURE__ */ L.jsx("i", { className: "icon poll" }),
      keywords: ["poll", "vote"],
      onSelect: () => e("Insert Poll", (t) => /* @__PURE__ */ L.jsx(uh, { activeEditor: r, onClose: t }))
    }),
    ...tl.map(
      (t) => new Wt(`Embed ${t.contentName}`, {
        icon: t.icon,
        keywords: [...t.keywords, "embed"],
        onSelect: () => r.dispatchCommand(jn.INSERT_EMBED_COMMAND, t.type)
      })
    ),
    new Wt("Equation", {
      icon: /* @__PURE__ */ L.jsx("i", { className: "icon equation" }),
      keywords: ["equation", "latex", "math"],
      onSelect: () => e("Insert Equation", (t) => /* @__PURE__ */ L.jsx(mh, { activeEditor: r, onClose: t }))
    }),
    new Wt("GIF", {
      icon: /* @__PURE__ */ L.jsx("i", { className: "icon gif" }),
      keywords: ["gif", "animate", "image", "file"],
      onSelect: () => r.dispatchCommand(zi, {
        altText: "Cat typing on a laptop",
        src: "https://media.giphy.com/media/3o7TKz5R0Lkzg7g9gI/giphy.gif"
      })
    }),
    new Wt("Image", {
      icon: /* @__PURE__ */ L.jsx("i", { className: "icon image" }),
      keywords: ["image", "photo", "picture", "file"],
      onSelect: () => e("Insert Image", (t) => /* @__PURE__ */ L.jsx(nh, { activeEditor: r, onClose: t }))
    }),
    new Wt("Collapsible", {
      icon: /* @__PURE__ */ L.jsx("i", { className: "icon caret-right" }),
      keywords: ["collapse", "collapsible", "toggle"],
      onSelect: () => r.dispatchCommand(el, void 0)
    }),
    new Wt("Columns Layout", {
      icon: /* @__PURE__ */ L.jsx("i", { className: "icon columns" }),
      keywords: ["columns", "layout", "grid"],
      onSelect: () => e("Insert Columns Layout", (t) => /* @__PURE__ */ L.jsx(hh, { activeEditor: r, onClose: t }))
    }),
    ...["left", "center", "right", "justify"].map(
      (t) => new Wt(`Align ${t}`, {
        icon: /* @__PURE__ */ L.jsx("i", { className: `icon ${t}-align` }),
        keywords: ["align", "justify", t],
        onSelect: () => r.dispatchCommand(_n, t)
      })
    )
  ];
}
function fv() {
  const [r] = Ot.useLexicalComposerContext(), [e, t] = Do(), [n, i] = Ie(null), o = Zr.useBasicTypeaheadTriggerMatch("/", {
    minLength: 0
  }), s = Sr(() => {
    const l = hv(r, t);
    if (!n)
      return l;
    const u = new RegExp(n, "i");
    return [
      ...dv(r, n),
      ...l.filter(
        (d) => u.test(d.title) || d.keywords.some((p) => u.test(p))
      )
    ];
  }, [r, n, t]), a = ct(
    (l, u, d, p) => {
      r.update(() => {
        u == null || u.remove(), l.onSelect(p), d();
      });
    },
    [r]
  );
  return /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    e,
    /* @__PURE__ */ L.jsx(
      Zr.LexicalTypeaheadMenuPlugin,
      {
        onQueryChange: i,
        onSelectOption: a,
        triggerFn: o,
        options: s,
        menuRenderFn: (l, { selectedIndex: u, selectOptionAndCleanUp: d, setHighlightedIndex: p }) => l.current && s.length ? wi.createPortal(
          /* @__PURE__ */ L.jsx("div", { className: "typeahead-popover component-picker-menu", children: /* @__PURE__ */ L.jsx("ul", { children: s.map((m, c) => /* @__PURE__ */ L.jsx(
            uv,
            {
              index: c,
              isSelected: u === c,
              onClick: () => {
                p(c), d(m);
              },
              onMouseEnter: () => {
                p(c);
              },
              option: m
            },
            m.key
          )) }) }),
          l.current
        ) : null
      }
    )
  ] });
}
function mv(r, e) {
  const t = r.getRangeAt(0);
  let n;
  if (r.anchorNode === e) {
    let i = e;
    for (; i.firstElementChild != null; )
      i = i.firstElementChild;
    n = i.getBoundingClientRect();
  } else
    n = t.getBoundingClientRect();
  return n;
}
const gv = 10, pv = 5;
function vv(r, e, t, n = !1, i = gv, o = pv) {
  const s = t.parentElement;
  if (r === null || !s) {
    e.style.opacity = "0", e.style.transform = "translate(-10000px, -10000px)";
    return;
  }
  const a = e.getBoundingClientRect(), l = t.getBoundingClientRect(), u = s.getBoundingClientRect();
  let d = r.top - a.height - i, p = r.left - o;
  d < u.top && (d += a.height + r.height + i * (n ? 9 : 2)), p + a.width > u.right && (p = u.right - a.width - o), d -= l.top, p -= l.left, e.style.opacity = "1", e.style.transform = `translate(${p}px, ${d}px)`;
}
function xv({
  editor: r,
  anchorElem: e,
  isLink: t,
  isBold: n,
  isItalic: i,
  isUnderline: o,
  isCode: s,
  isStrikethrough: a,
  isSubscript: l,
  isSuperscript: u
}) {
  const d = Rt(null), p = ct(() => {
    t ? r.dispatchCommand(St.TOGGLE_LINK_COMMAND, null) : r.dispatchCommand(St.TOGGLE_LINK_COMMAND, "https://");
  }, [r, t]);
  function m(f) {
    if (d != null && d.current && (f.buttons === 1 || f.buttons === 3) && d.current.style.pointerEvents !== "none") {
      const N = f.clientX, v = f.clientY, C = document.elementFromPoint(N, v);
      d.current.contains(C) || (d.current.style.pointerEvents = "none");
    }
  }
  function c(f) {
    d != null && d.current && d.current.style.pointerEvents !== "auto" && (d.current.style.pointerEvents = "auto");
  }
  We(() => {
    if (d != null && d.current)
      return document.addEventListener("mousemove", m), document.addEventListener("mouseup", c), () => {
        document.removeEventListener("mousemove", m), document.removeEventListener("mouseup", c);
      };
  }, [d]);
  const h = ct(() => {
    const f = Nt(), N = d.current, v = window.getSelection();
    if (N === null)
      return;
    const C = r.getRootElement();
    if (f !== null && v !== null && !v.isCollapsed && C !== null && C.contains(v.anchorNode)) {
      const g = mv(v, C);
      vv(
        g,
        N,
        e,
        t
      );
    }
  }, [r, e, t]);
  return We(() => {
    const f = e.parentElement, N = () => {
      r.getEditorState().read(() => {
        h();
      });
    };
    return window.addEventListener("resize", N), f && f.addEventListener("scroll", N), () => {
      window.removeEventListener("resize", N), f && f.removeEventListener("scroll", N);
    };
  }, [r, h, e]), We(() => (r.getEditorState().read(() => {
    h();
  }), ut.mergeRegister(
    r.registerUpdateListener(({ editorState: f }) => {
      f.read(() => {
        h();
      });
    }),
    r.registerCommand(
      Vn,
      () => (h(), !1),
      qt
    )
  )), [r, h]), /* @__PURE__ */ L.jsx("div", { ref: d, className: "floating-text-format-popup", children: r.isEditable() && /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx(
      "button",
      {
        type: "button",
        onClick: () => {
          r.dispatchCommand(dr, "bold");
        },
        className: "popup-item spaced " + (n ? "active" : ""),
        "aria-label": "Format text as bold",
        children: /* @__PURE__ */ L.jsx("i", { className: "format bold" })
      }
    ),
    /* @__PURE__ */ L.jsx(
      "button",
      {
        type: "button",
        onClick: () => {
          r.dispatchCommand(dr, "italic");
        },
        className: "popup-item spaced " + (i ? "active" : ""),
        "aria-label": "Format text as italics",
        children: /* @__PURE__ */ L.jsx("i", { className: "format italic" })
      }
    ),
    /* @__PURE__ */ L.jsx(
      "button",
      {
        type: "button",
        onClick: () => {
          r.dispatchCommand(dr, "underline");
        },
        className: "popup-item spaced " + (o ? "active" : ""),
        "aria-label": "Format text to underlined",
        children: /* @__PURE__ */ L.jsx("i", { className: "format underline" })
      }
    ),
    /* @__PURE__ */ L.jsx(
      "button",
      {
        type: "button",
        onClick: () => {
          r.dispatchCommand(dr, "strikethrough");
        },
        className: "popup-item spaced " + (a ? "active" : ""),
        "aria-label": "Format text with a strikethrough",
        children: /* @__PURE__ */ L.jsx("i", { className: "format strikethrough" })
      }
    ),
    /* @__PURE__ */ L.jsx(
      "button",
      {
        type: "button",
        onClick: () => {
          r.dispatchCommand(dr, "subscript");
        },
        className: "popup-item spaced " + (l ? "active" : ""),
        title: "Subscript",
        "aria-label": "Format Subscript",
        children: /* @__PURE__ */ L.jsx("i", { className: "format subscript" })
      }
    ),
    /* @__PURE__ */ L.jsx(
      "button",
      {
        type: "button",
        onClick: () => {
          r.dispatchCommand(dr, "superscript");
        },
        className: "popup-item spaced " + (u ? "active" : ""),
        title: "Superscript",
        "aria-label": "Format Superscript",
        children: /* @__PURE__ */ L.jsx("i", { className: "format superscript" })
      }
    ),
    /* @__PURE__ */ L.jsx(
      "button",
      {
        type: "button",
        onClick: () => {
          r.dispatchCommand(dr, "code");
        },
        className: "popup-item spaced " + (s ? "active" : ""),
        "aria-label": "Insert code block",
        children: /* @__PURE__ */ L.jsx("i", { className: "format code" })
      }
    ),
    /* @__PURE__ */ L.jsx(
      "button",
      {
        type: "button",
        onClick: p,
        className: "popup-item spaced " + (t ? "active" : ""),
        "aria-label": "Insert link",
        children: /* @__PURE__ */ L.jsx("i", { className: "format link" })
      }
    )
  ] }) });
}
function Nv(r, e) {
  const [t, n] = Ie(!1), [i, o] = Ie(!1), [s, a] = Ie(!1), [l, u] = Ie(!1), [d, p] = Ie(!1), [m, c] = Ie(!1), [h, f] = Ie(!1), [N, v] = Ie(!1), [C, g] = Ie(!1), x = ct(() => {
    r.getEditorState().read(() => {
      if (r.isComposing())
        return;
      const b = Nt(), A = window.getSelection(), w = r.getRootElement();
      if (A !== null && (!At(b) || w === null || !w.contains(A.anchorNode))) {
        n(!1);
        return;
      }
      if (!At(b))
        return;
      const M = Yn(b);
      a(b.hasFormat("bold")), u(b.hasFormat("italic")), p(b.hasFormat("underline")), c(b.hasFormat("strikethrough")), f(b.hasFormat("subscript")), v(b.hasFormat("superscript")), g(b.hasFormat("code"));
      const y = M.getParent();
      St.$isLinkNode(y) || St.$isLinkNode(M) ? o(!0) : o(!1), !vo.$isCodeHighlightNode(b.anchor.getNode()) && b.getTextContent() !== "" ? n(ms(M) || ps(M)) : n(!1);
      const E = b.getTextContent().replace(/\n/g, "");
      if (!b.isCollapsed() && E === "") {
        n(!1);
        return;
      }
    });
  }, [r]);
  return We(() => (document.addEventListener("selectionchange", x), () => {
    document.removeEventListener("selectionchange", x);
  }), [x]), We(() => ut.mergeRegister(
    r.registerUpdateListener(() => {
      x();
    }),
    r.registerRootListener(() => {
      r.getRootElement() === null && n(!1);
    })
  ), [r, x]), t ? Qr(
    /* @__PURE__ */ L.jsx(
      xv,
      {
        editor: r,
        anchorElem: e,
        isLink: i,
        isBold: s,
        isItalic: l,
        isStrikethrough: m,
        isSubscript: h,
        isSuperscript: N,
        isUnderline: d,
        isCode: C
      }
    ),
    e
  ) : null;
}
function _v({
  anchorElem: r = document.body
}) {
  const [e] = Ot.useLexicalComposerContext();
  return Nv(e, r);
}
var Ba = {}, uu;
function Cv() {
  if (uu) return Ba;
  uu = 1;
  var r = lt(), e = Ge, t = it(), n = Ve, i = nt;
  function o({
    hasCellMerge: s = !0,
    hasCellBackgroundColor: a = !0,
    hasTabHandler: l = !0
  }) {
    const [u] = r.useLexicalComposerContext();
    return i.useEffect(() => {
      if (!u.hasNodes([e.TableNode, e.TableCellNode, e.TableRowNode]))
        throw Error("TablePlugin: TableNode, TableCellNode or TableRowNode not registered on editor");
      return u.registerCommand(e.INSERT_TABLE_COMMAND, ({
        columns: d,
        rows: p,
        includeHeaders: m
      }) => {
        const c = e.$createTableNodeWithDimensions(Number(p), Number(d), m);
        t.$insertNodeToNearestRoot(c);
        const h = c.getFirstDescendant();
        return n.$isTextNode(h) && h.select(), !0;
      }, n.COMMAND_PRIORITY_EDITOR);
    }, [u]), i.useEffect(() => {
      const d = /* @__PURE__ */ new Map(), p = (c) => {
        const h = c.getKey(), f = u.getElementByKey(h);
        if (f && !d.has(h)) {
          const N = e.applyTableHandlers(c, f, u, l);
          d.set(h, N);
        }
      };
      u.getEditorState().read(() => {
        const c = n.$nodesOfType(e.TableNode);
        for (const h of c)
          e.$isTableNode(h) && p(h);
      });
      const m = u.registerMutationListener(e.TableNode, (c) => {
        for (const [h, f] of c)
          if (f === "created")
            u.getEditorState().read(() => {
              const N = n.$getNodeByKey(h);
              e.$isTableNode(N) && p(N);
            });
          else if (f === "destroyed") {
            const N = d.get(h);
            N !== void 0 && (N.removeListeners(), d.delete(h));
          }
      });
      return () => {
        m();
        for (const [, c] of d)
          c.removeListeners();
      };
    }, [u, l]), i.useEffect(() => {
      if (!s)
        return u.registerNodeTransform(e.TableCellNode, (d) => {
          if (d.getColSpan() > 1 || d.getRowSpan() > 1) {
            const [, , p] = e.$getNodeTriplet(d), [m] = e.$computeTableMap(p, d, d), c = m.length, h = m[0].length;
            let f = p.getFirstChild();
            if (!e.$isTableRowNode(f))
              throw Error("Expected TableNode first child to be a RowNode");
            const N = [];
            for (let v = 0; v < c; v++) {
              if (v !== 0 && (f = f.getNextSibling(), !e.$isTableRowNode(f)))
                throw Error("Expected TableNode first child to be a RowNode");
              let C = null;
              for (let g = 0; g < h; g++) {
                const x = m[v][g], b = x.cell;
                if (x.startRow === v && x.startColumn === g)
                  C = b, N.push(b);
                else if (b.getColSpan() > 1 || b.getRowSpan() > 1) {
                  if (!e.$isTableCellNode(b))
                    throw Error("Expected TableNode cell to be a TableCellNode");
                  const A = e.$createTableCellNode(b.__headerState);
                  C !== null ? C.insertAfter(A) : t.$insertFirst(f, A);
                }
              }
            }
            for (const v of N)
              v.setColSpan(1), v.setRowSpan(1);
          }
        });
    }, [u, s]), i.useEffect(() => {
      if (!a)
        return u.registerNodeTransform(e.TableCellNode, (d) => {
          d.getBackgroundColor() !== null && d.setBackgroundColor(null);
        });
    }, [u, a, s]), null;
  }
  return Ba.TablePlugin = o, Ba;
}
var za = {}, du;
function bv() {
  if (du) return za;
  du = 1;
  var r = lt(), e = Ge, t = it(), n = Ve, i = nt;
  function o(s) {
    let a = new URLSearchParams();
    a.append("code", s);
    for (let l = 1; l < arguments.length; l++) a.append("v", arguments[l]);
    throw Error(`Minified Lexical error #${s}; visit https://lexical.dev/docs/error?${a} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  return za.TablePlugin = function({ hasCellMerge: s = !0, hasCellBackgroundColor: a = !0, hasTabHandler: l = !0 }) {
    let [u] = r.useLexicalComposerContext();
    return i.useEffect(() => (u.hasNodes([e.TableNode, e.TableCellNode, e.TableRowNode]) || o(10), u.registerCommand(e.INSERT_TABLE_COMMAND, ({ columns: d, rows: p, includeHeaders: m }) => (d = e.$createTableNodeWithDimensions(Number(p), Number(d), m), t.$insertNodeToNearestRoot(d), d = d.getFirstDescendant(), n.$isTextNode(d) && d.select(), !0), n.COMMAND_PRIORITY_EDITOR)), [u]), i.useEffect(
      () => {
        let d = /* @__PURE__ */ new Map(), p = (c) => {
          const h = c.getKey(), f = u.getElementByKey(h);
          f && !d.has(h) && (c = e.applyTableHandlers(c, f, u, l), d.set(h, c));
        };
        u.getEditorState().read(() => {
          let c = n.$nodesOfType(e.TableNode);
          for (let h of c) e.$isTableNode(h) && p(h);
        });
        let m = u.registerMutationListener(e.TableNode, (c) => {
          for (const [h, f] of c) f === "created" ? u.getEditorState().read(() => {
            const N = n.$getNodeByKey(h);
            e.$isTableNode(N) && p(N);
          }) : f === "destroyed" && (c = d.get(h), c !== void 0 && (c.removeListeners(), d.delete(h)));
        });
        return () => {
          m();
          for (let [, c] of d) c.removeListeners();
        };
      },
      [u, l]
    ), i.useEffect(() => {
      if (!s) return u.registerNodeTransform(e.TableCellNode, (d) => {
        if (1 < d.getColSpan() || 1 < d.getRowSpan()) {
          var [, , p] = e.$getNodeTriplet(d);
          [d] = e.$computeTableMap(p, d, d);
          let c = d.length, h = d[0].length;
          if (p = p.getFirstChild(), !e.$isTableRowNode(p)) throw Error("Expected TableNode first child to be a RowNode");
          let f = [];
          for (let N = 0; N < c; N++) {
            if (N !== 0 && (p = p.getNextSibling(), !e.$isTableRowNode(p))) throw Error("Expected TableNode first child to be a RowNode");
            let v = null;
            for (let C = 0; C < h; C++) {
              var m = d[N][C];
              let g = m.cell;
              if (m.startRow === N && m.startColumn === C) v = g, f.push(g);
              else if (1 < g.getColSpan() || 1 < g.getRowSpan()) {
                if (!e.$isTableCellNode(g)) throw Error("Expected TableNode cell to be a TableCellNode");
                m = e.$createTableCellNode(g.__headerState), v !== null ? v.insertAfter(m) : t.$insertFirst(p, m);
              }
            }
          }
          for (let N of f) N.setColSpan(1), N.setRowSpan(1);
        }
      });
    }, [u, s]), i.useEffect(() => {
      if (!a) return u.registerNodeTransform(e.TableCellNode, (d) => {
        d.getBackgroundColor() !== null && d.setBackgroundColor(null);
      });
    }, [u, a, s]), null;
  }, za;
}
const yv = process.env.NODE_ENV === "development" ? Cv() : bv();
var wv = yv, Tv = Gs();
const _h = /* @__PURE__ */ Ru(Tv), Ev = 33, Sv = 50;
function Ov({ editor: r }) {
  const e = Rt(null), t = Rt(null), n = Rt(null), i = Rt(null), [o, s] = Ie(null), [a, l] = Ie(null), [u, d] = Ie(!1), [p, m] = Ie(null);
  We(() => r.registerCommand(
    Vn,
    () => {
      const b = Nt(), A = Ge.$isTableSelection(b);
      return u !== A && d(A), !1;
    },
    cn
  ));
  const c = ct(() => {
    l(null), e.current = null, m(null), i.current = null, n.current = null;
  }, []);
  We(() => {
    const b = (A) => {
      setTimeout(() => {
        const w = A.target;
        if (p) {
          s({
            x: A.clientX,
            y: A.clientY
          });
          return;
        }
        if (!(t.current && t.current.contains(w)) && e.current !== w) {
          e.current = w;
          const M = Ge.getDOMCellFromTarget(w);
          M && a !== M ? r.update(() => {
            const y = Ci(M.elem);
            if (!y)
              throw new Error("TableCellResizer: Table cell node not found.");
            const E = Ge.$getTableNodeFromLexicalNodeOrThrow(y), S = r.getElementByKey(E.getKey());
            if (!S)
              throw new Error("TableCellResizer: Table element not found.");
            e.current = w, n.current = S.getBoundingClientRect(), l(M);
          }) : M == null && c();
        }
      }, 0);
    };
    return document.addEventListener("mousemove", b), () => {
      document.removeEventListener("mousemove", b);
    };
  }, [a, p, r, c]);
  const h = (b) => b === "bottom", f = ct(
    (b) => {
      if (!a)
        throw new Error("TableCellResizer: Expected active cell.");
      r.update(() => {
        const A = Ci(a.elem);
        if (!Ge.$isTableCellNode(A))
          throw new Error("TableCellResizer: Table cell node not found.");
        const w = Ge.$getTableNodeFromLexicalNodeOrThrow(A), M = Ge.$getTableRowIndexFromTableCellNode(A), y = w.getChildren();
        if (M >= y.length || M < 0)
          throw new Error("Expected table cell to be inside of table row.");
        const E = y[M];
        if (!Ge.$isTableRowNode(E))
          throw new Error("Expected table row");
        E.setHeight(b);
      });
    },
    [a, r]
  ), N = ct(
    (b) => {
      if (!a)
        throw new Error("TableCellResizer: Expected active cell.");
      r.update(() => {
        const A = Ci(a.elem);
        if (!Ge.$isTableCellNode(A))
          throw new Error("TableCellResizer: Table cell node not found.");
        const w = Ge.$getTableNodeFromLexicalNodeOrThrow(A), M = Ge.$getTableColumnIndexFromTableCellNode(A), y = w.getChildren();
        for (let E = 0; E < y.length; E++) {
          const S = y[E];
          if (!Ge.$isTableRowNode(S))
            throw new Error("Expected table row");
          const P = S.getChildren(), H = P.map((T) => T.getColSpan()).reduce(
            (T, $) => {
              const G = T[T.length - 1] ?? 0;
              return T.push(G + $), T;
            },
            []
          ).findIndex(
            (T) => T > M
          );
          if (H >= P.length || H < 0)
            throw new Error("Expected table cell to be inside of table row.");
          const R = P[H];
          if (!Ge.$isTableCellNode(R))
            throw new Error("Expected table cell");
          R.setWidth(b);
        }
      });
    },
    [a, r]
  ), v = ct(
    (b) => {
      const A = (w) => {
        if (w.preventDefault(), w.stopPropagation(), !a)
          throw new Error("TableCellResizer: Expected active cell.");
        if (i.current) {
          const { x: M, y } = i.current;
          if (a === null)
            return;
          if (h(b)) {
            const E = a.elem.getBoundingClientRect().height, S = Math.abs(w.clientY - y), P = b === "bottom" && y > w.clientY;
            f(
              Math.max(
                P ? E - S : S + E,
                Ev
              )
            );
          } else {
            const E = getComputedStyle(a.elem);
            let S = a.elem.clientWidth;
            S -= parseFloat(E.paddingLeft) + parseFloat(E.paddingRight);
            const P = Math.abs(w.clientX - M), U = b === "right" && M > w.clientX;
            N(
              Math.max(
                U ? S - P : P + S,
                Sv
              )
            );
          }
          c(), document.removeEventListener("mouseup", A);
        }
      };
      return A;
    },
    [a, c, N, f]
  ), C = ct(
    (b) => (A) => {
      if (A.preventDefault(), A.stopPropagation(), !a)
        throw new Error("TableCellResizer: Expected active cell.");
      i.current = {
        x: A.clientX,
        y: A.clientY
      }, s(i.current), m(b), document.addEventListener("mouseup", v(b));
    },
    [a, v]
  ), x = ct(() => {
    if (a) {
      const { height: b, width: A, top: w, left: M } = a.elem.getBoundingClientRect(), y = {
        bottom: {
          backgroundColor: "none",
          cursor: "row-resize",
          height: "10px",
          left: `${window.pageXOffset + M}px`,
          top: `${window.pageYOffset + w + b}px`,
          width: `${A}px`
        },
        right: {
          backgroundColor: "none",
          cursor: "col-resize",
          height: `${b}px`,
          left: `${window.pageXOffset + M + A}px`,
          top: `${window.pageYOffset + w}px`,
          width: "10px"
        }
      }, E = n.current;
      return p && o && E && (h(p) ? (y[p].left = `${window.pageXOffset + E.left}px`, y[p].top = `${window.pageYOffset + o.y}px`, y[p].height = "3px", y[p].width = `${E.width}px`) : (y[p].top = `${window.pageYOffset + E.top}px`, y[p].left = `${window.pageXOffset + o.x}px`, y[p].width = "3px", y[p].height = `${E.height}px`), y[p].backgroundColor = "#adf"), y;
    }
    return {
      bottom: null,
      left: null,
      right: null,
      top: null
    };
  }, [a, p, o])();
  return /* @__PURE__ */ L.jsx("div", { ref: t, children: a != null && !u && /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx(
      "div",
      {
        className: "TableCellResizer__resizer TableCellResizer__ui",
        style: x.right || void 0,
        onMouseDown: C("right")
      }
    ),
    /* @__PURE__ */ L.jsx(
      "div",
      {
        className: "TableCellResizer__resizer TableCellResizer__ui",
        style: x.bottom || void 0,
        onMouseDown: C("bottom")
      }
    )
  ] }) });
}
function Mv() {
  const [r] = Ot.useLexicalComposerContext(), e = _h();
  return Sr(
    () => e ? Qr(/* @__PURE__ */ L.jsx(Ov, { editor: r }), document.body) : null,
    [r, e]
  );
}
function Ha(r) {
  const e = r.getShape();
  return {
    columns: e.toX - e.fromX + 1,
    rows: e.toY - e.fromY + 1
  };
}
function Rv(r) {
  const e = r.getNodes(), t = [];
  let n = null, i = null, o = 0;
  for (let s = 0; s < e.length; s++) {
    const a = e[s];
    if (Ge.$isTableCellNode(a)) {
      const l = a.getParentOrThrow();
      if (z1(
        Ge.$isTableRowNode(l),
        "Expected CellNode to have a RowNode parent"
      ), n !== l) {
        if (i !== null && o !== i)
          return !1;
        n !== null && (i = o), n = l, o = 0;
      }
      const u = a.__colSpan;
      for (let d = 0; d < u; d++)
        t[o + d] === void 0 && (t[o + d] = 0), t[o + d] += a.__rowSpan;
      o += u;
    }
  }
  return (i === null || o === i) && t.every((s) => s === t[0]);
}
function Av() {
  const r = Nt();
  if (At(r) && !r.isCollapsed() || Ge.$isTableSelection(r) && !r.anchor.is(r.focus) || !At(r) && !Ge.$isTableSelection(r))
    return !1;
  const [e] = Ge.$getNodeTriplet(r.anchor);
  return e.__colSpan > 1 || e.__rowSpan > 1;
}
function hu(r) {
  if (r.getChildrenSize() !== 1)
    return !1;
  const e = r.getFirstChildOrThrow();
  return !(!ps(e) || !e.isEmpty());
}
function Lv(r) {
  const e = r.getLastDescendant();
  ms(e) ? e.select() : yn(e) ? e.selectEnd() : e !== null && e.selectNext();
}
function fu(r) {
  return r.getEditorState().read(() => {
    const e = Nt();
    if (At(e) || Ge.$isTableSelection(e)) {
      const [t] = Ge.$getNodeTriplet(e.anchor);
      if (Ge.$isTableCellNode(t))
        return t.getBackgroundColor();
    }
    return null;
  });
}
function kv({
  onClose: r,
  tableCellNode: e,
  setIsMenuOpen: t,
  contextRef: n,
  cellMerge: i,
  showColorPickerModal: o
}) {
  const [s] = Ot.useLexicalComposerContext(), a = Rt(null), [l, u] = Ie(e), [d, p] = Ie({
    columns: 1,
    rows: 1
  }), [m, c] = Ie(!1), [h, f] = Ie(!1), [N, v] = Ie(
    () => fu(s) || ""
  );
  We(() => s.registerMutationListener(Ge.TableCellNode, (j) => {
    j.get(l.getKey()) === "updated" && (s.getEditorState().read(() => {
      u(l.getLatest());
    }), v(fu(s) || ""));
  }), [s, l]), We(() => {
    s.getEditorState().read(() => {
      const j = Nt();
      if (Ge.$isTableSelection(j)) {
        const H = Ha(j);
        p(Ha(j)), c(
          Rv(j) && (H.columns > 1 || H.rows > 1)
        );
      }
      f(Av());
    });
  }, [s]), We(() => {
    const j = n.current, H = a.current, R = s.getRootElement();
    if (j != null && H != null && R != null) {
      const T = R.getBoundingClientRect(), $ = j.getBoundingClientRect();
      H.style.opacity = "1";
      const G = H.getBoundingClientRect(), q = 5;
      let I = $.right + q;
      if (I + G.width > window.innerWidth || I + G.width > T.right) {
        const D = $.left - G.width - q;
        I = (D < 0 ? q : D) + window.pageXOffset;
      }
      H.style.left = `${I + window.pageXOffset}px`;
      let Y = $.top;
      if (Y + G.height > window.innerHeight) {
        const D = $.bottom - G.height;
        Y = (D < 0 ? q : D) + window.pageYOffset;
      }
      H.style.top = `${Y + +window.pageYOffset}px`;
    }
  }, [n, a, s]), We(() => {
    function j(H) {
      a.current != null && n.current != null && !a.current.contains(H.target) && !n.current.contains(H.target) && t(!1);
    }
    return window.addEventListener("click", j), () => window.removeEventListener("click", j);
  }, [t, n]);
  const C = ct(() => {
    s.update(() => {
      if (l.isAttached()) {
        const H = Ge.$getTableNodeFromLexicalNodeOrThrow(l), R = s.getElementByKey(
          H.getKey()
        );
        if (!R)
          throw new Error("Expected to find tableElement in DOM");
        const T = Ge.getTableObserverFromTableElement(R);
        T !== null && T.clearHighlight(), H.markDirty(), u(l.getLatest());
      }
      gs().selectStart();
    });
  }, [s, l]), g = () => {
    s.update(() => {
      const j = Nt();
      if (Ge.$isTableSelection(j)) {
        const { columns: H, rows: R } = Ha(j), T = j.getNodes();
        let $ = null;
        for (let G = 0; G < T.length; G++) {
          const q = T[G];
          if (Ge.$isTableCellNode(q))
            if ($ === null) {
              q.setColSpan(H).setRowSpan(R), $ = q;
              const I = hu(q);
              let Y;
              I && ps(Y = q.getFirstChild()) && Y.remove();
            } else Ge.$isTableCellNode($) && (hu(q) || $.append(...q.getChildren()), q.remove());
        }
        $ !== null && ($.getChildrenSize() === 0 && $.append(Gt()), Lv($)), r();
      }
    });
  }, x = () => {
    s.update(() => {
      Ge.$unmergeCell();
    });
  }, b = ct(
    (j) => {
      s.update(() => {
        Ge.$insertTableRow__EXPERIMENTAL(j), r();
      });
    },
    [s, r]
  ), A = ct(
    (j) => {
      s.update(() => {
        for (let H = 0; H < d.columns; H++)
          Ge.$insertTableColumn__EXPERIMENTAL(j);
        r();
      });
    },
    [s, r, d.columns]
  ), w = ct(() => {
    s.update(() => {
      Ge.$deleteTableRow__EXPERIMENTAL(), r();
    });
  }, [s, r]), M = ct(() => {
    s.update(() => {
      Ge.$getTableNodeFromLexicalNodeOrThrow(l).remove(), C(), r();
    });
  }, [s, l, C, r]), y = ct(() => {
    s.update(() => {
      Ge.$deleteTableColumn__EXPERIMENTAL(), r();
    });
  }, [s, r]), E = ct(() => {
    s.update(() => {
      const j = Ge.$getTableNodeFromLexicalNodeOrThrow(l), H = Ge.$getTableRowIndexFromTableCellNode(l), R = j.getChildren();
      if (H >= R.length || H < 0)
        throw new Error("Expected table cell to be inside of table row.");
      const T = R[H];
      if (!Ge.$isTableRowNode(T))
        throw new Error("Expected table row");
      T.getChildren().forEach(($) => {
        if (!Ge.$isTableCellNode($))
          throw new Error("Expected table cell");
        $.toggleHeaderStyle(Ge.TableCellHeaderStates.ROW);
      }), C(), r();
    });
  }, [s, l, C, r]), S = ct(() => {
    s.update(() => {
      const j = Ge.$getTableNodeFromLexicalNodeOrThrow(l), H = Ge.$getTableColumnIndexFromTableCellNode(l), R = j.getChildren(), T = Math.max(
        ...R.map(($) => $.getChildren().length)
      );
      if (H >= T || H < 0)
        throw new Error("Expected table cell to be inside of table row.");
      for (let $ = 0; $ < R.length; $++) {
        const G = R[$];
        if (!Ge.$isTableRowNode(G))
          throw new Error("Expected table row");
        const q = G.getChildren();
        if (H >= q.length)
          continue;
        const I = q[H];
        if (!Ge.$isTableCellNode(I))
          throw new Error("Expected table cell");
        I.toggleHeaderStyle(Ge.TableCellHeaderStates.COLUMN);
      }
      C(), r();
    });
  }, [s, l, C, r]), P = ct(
    (j) => {
      s.update(() => {
        const H = Nt();
        if (At(H) || Ge.$isTableSelection(H)) {
          const [R] = Ge.$getNodeTriplet(H.anchor);
          if (Ge.$isTableCellNode(R) && R.setBackgroundColor(j), Ge.$isTableSelection(H)) {
            const T = H.getNodes();
            for (let $ = 0; $ < T.length; $++) {
              const G = T[$];
              Ge.$isTableCellNode(G) && G.setBackgroundColor(j);
            }
          }
        }
      });
    },
    [s]
  );
  let U = null;
  return i && (m ? U = /* @__PURE__ */ L.jsx(
    "button",
    {
      type: "button",
      className: "item",
      onClick: () => g(),
      "data-test-id": "table-merge-cells",
      children: "Merge cells"
    }
  ) : h && (U = /* @__PURE__ */ L.jsx(
    "button",
    {
      type: "button",
      className: "item",
      onClick: () => x(),
      "data-test-id": "table-unmerge-cells",
      children: "Unmerge cells"
    }
  ))), Qr(
    /* @__PURE__ */ L.jsxs(
      "div",
      {
        className: "dropdown",
        ref: a,
        onClick: (j) => {
          j.stopPropagation();
        },
        children: [
          U,
          /* @__PURE__ */ L.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => o("Cell background color", () => /* @__PURE__ */ L.jsx(
                th,
                {
                  color: N,
                  onChange: P
                }
              )),
              "data-test-id": "table-background-color",
              children: /* @__PURE__ */ L.jsx("span", { className: "text", children: "Background color" })
            }
          ),
          /* @__PURE__ */ L.jsx("hr", {}),
          /* @__PURE__ */ L.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => b(!1),
              "data-test-id": "table-insert-row-above",
              children: /* @__PURE__ */ L.jsxs("span", { className: "text", children: [
                "Insert",
                " ",
                d.rows === 1 ? "row" : `${d.rows} rows`,
                " ",
                "above"
              ] })
            }
          ),
          /* @__PURE__ */ L.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => b(!0),
              "data-test-id": "table-insert-row-below",
              children: /* @__PURE__ */ L.jsxs("span", { className: "text", children: [
                "Insert",
                " ",
                d.rows === 1 ? "row" : `${d.rows} rows`,
                " ",
                "below"
              ] })
            }
          ),
          /* @__PURE__ */ L.jsx("hr", {}),
          /* @__PURE__ */ L.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => A(!1),
              "data-test-id": "table-insert-column-before",
              children: /* @__PURE__ */ L.jsxs("span", { className: "text", children: [
                "Insert",
                " ",
                d.columns === 1 ? "column" : `${d.columns} columns`,
                " ",
                "left"
              ] })
            }
          ),
          /* @__PURE__ */ L.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => A(!0),
              "data-test-id": "table-insert-column-after",
              children: /* @__PURE__ */ L.jsxs("span", { className: "text", children: [
                "Insert",
                " ",
                d.columns === 1 ? "column" : `${d.columns} columns`,
                " ",
                "right"
              ] })
            }
          ),
          /* @__PURE__ */ L.jsx("hr", {}),
          /* @__PURE__ */ L.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => y(),
              "data-test-id": "table-delete-columns",
              children: /* @__PURE__ */ L.jsx("span", { className: "text", children: "Delete column" })
            }
          ),
          /* @__PURE__ */ L.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => w(),
              "data-test-id": "table-delete-rows",
              children: /* @__PURE__ */ L.jsx("span", { className: "text", children: "Delete row" })
            }
          ),
          /* @__PURE__ */ L.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => M(),
              "data-test-id": "table-delete",
              children: /* @__PURE__ */ L.jsx("span", { className: "text", children: "Delete table" })
            }
          ),
          /* @__PURE__ */ L.jsx("hr", {}),
          /* @__PURE__ */ L.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => E(),
              children: /* @__PURE__ */ L.jsxs("span", { className: "text", children: [
                (l.__headerState & Ge.TableCellHeaderStates.ROW) === Ge.TableCellHeaderStates.ROW ? "Remove" : "Add",
                " ",
                "row header"
              ] })
            }
          ),
          /* @__PURE__ */ L.jsx(
            "button",
            {
              type: "button",
              className: "item",
              onClick: () => S(),
              "data-test-id": "table-column-header",
              children: /* @__PURE__ */ L.jsxs("span", { className: "text", children: [
                (l.__headerState & Ge.TableCellHeaderStates.COLUMN) === Ge.TableCellHeaderStates.COLUMN ? "Remove" : "Add",
                " ",
                "column header"
              ] })
            }
          )
        ]
      }
    ),
    document.body
  );
}
function Dv({
  anchorElem: r,
  cellMerge: e
}) {
  const [t] = Ot.useLexicalComposerContext(), n = Rt(null), i = Rt(null), [o, s] = Ie(!1), [a, l] = Ie(
    null
  ), [u, d] = Do(), p = ct(() => {
    const c = n.current, h = Nt(), f = window.getSelection(), N = document.activeElement;
    if (h == null || c == null) {
      l(null);
      return;
    }
    const v = t.getRootElement();
    if (At(h) && v !== null && f !== null && v.contains(f.anchorNode)) {
      const C = Ge.$getTableCellNodeFromLexicalNode(
        h.anchor.getNode()
      );
      if (C == null) {
        l(null);
        return;
      }
      if (t.getElementByKey(
        C.getKey()
      ) == null) {
        l(null);
        return;
      }
      l(C);
    } else N || l(null);
  }, [t]);
  We(() => t.registerUpdateListener(() => {
    t.getEditorState().read(() => {
      p();
    });
  })), We(() => {
    const c = n.current;
    if (c != null && a != null) {
      const h = t.getElementByKey(a.getKey());
      if (h != null) {
        const f = h.getBoundingClientRect(), N = c.getBoundingClientRect(), v = r.getBoundingClientRect(), C = f.top - v.top + 4, g = f.right - N.width - 10 - v.left;
        c.style.opacity = "1", c.style.transform = `translate(${g}px, ${C}px)`;
      } else
        c.style.opacity = "0", c.style.transform = "translate(-10000px, -10000px)";
    }
  }, [n, a, t, r]);
  const m = Rt(a);
  return We(() => {
    m.current !== a && s(!1), m.current = a;
  }, [m, a]), /* @__PURE__ */ L.jsx("div", { className: "table-cell-action-button-container", ref: n, children: a != null && /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx(
      "button",
      {
        type: "button",
        className: "table-cell-action-button chevron-down",
        onClick: (c) => {
          c.stopPropagation(), s(!o);
        },
        ref: i,
        children: /* @__PURE__ */ L.jsx("i", { className: "chevron-down" })
      }
    ),
    u,
    o && /* @__PURE__ */ L.jsx(
      kv,
      {
        contextRef: i,
        setIsMenuOpen: s,
        onClose: () => s(!1),
        tableCellNode: a,
        cellMerge: e,
        showColorPickerModal: d
      }
    )
  ] }) });
}
function $v({
  anchorElem: r = document.body,
  cellMerge: e = !1
}) {
  const t = _h();
  return Qr(
    t ? /* @__PURE__ */ L.jsx(
      Dv,
      {
        anchorElem: r,
        cellMerge: e
      }
    ) : null,
    r
  );
}
const mu = [
  "image/",
  "image/heic",
  "image/heif",
  "image/gif",
  "image/webp"
];
function Iv() {
  const [r] = Ot.useLexicalComposerContext();
  return We(() => r.registerCommand(
    fr.DRAG_DROP_PASTE,
    (e) => ((async () => {
      const t = await ut.mediaFileReader(
        e,
        [mu].flatMap((n) => n)
      );
      for (const { file: n, result: i } of t)
        ut.isMimeType(n, mu) && r.dispatchCommand(zi, {
          altText: n.name,
          src: i
        });
    })(), !0),
    qt
  ), [r]), null;
}
class Pv extends Zr.MenuOption {
  constructor(t, n, i) {
    super(t);
    Ye(this, "title");
    Ye(this, "emoji");
    Ye(this, "keywords");
    this.title = t, this.emoji = n, this.keywords = i.keywords || [];
  }
}
function Fv({
  index: r,
  isSelected: e,
  onClick: t,
  onMouseEnter: n,
  option: i
}) {
  let o = "item";
  return e && (o += " selected"), /* @__PURE__ */ L.jsx(
    "li",
    {
      tabIndex: -1,
      className: o,
      ref: i.setRefElement,
      role: "option",
      "aria-selected": e,
      id: "typeahead-item-" + r,
      onMouseEnter: n,
      onClick: t,
      children: /* @__PURE__ */ L.jsxs("span", { className: "text", children: [
        i.emoji,
        " ",
        i.title
      ] })
    },
    i.key
  );
}
const Bv = 10;
function zv() {
  const [r] = Ot.useLexicalComposerContext(), [e, t] = Ie(null), [n, i] = Ie([]);
  We(() => {
    import("./emoji-list-CKk-PE96.js").then((u) => i(u.default));
  }, []);
  const o = Sr(
    () => n != null ? n.map(
      ({ emoji: u, aliases: d, tags: p }) => new Pv(d[0], u, {
        keywords: [...d, ...p]
      })
    ) : [],
    [n]
  ), s = Zr.useBasicTypeaheadTriggerMatch(":", {
    minLength: 0
  }), a = Sr(() => o.filter((u) => e != null ? new RegExp(e, "gi").exec(u.title) || u.keywords != null ? u.keywords.some(
    (d) => new RegExp(e, "gi").exec(d)
  ) : !1 : o).slice(0, Bv), [o, e]), l = ct(
    (u, d, p) => {
      r.update(() => {
        const m = Nt();
        !At(m) || u == null || (d && d.remove(), m.insertNodes([Uh(u.emoji)]), p());
      });
    },
    [r]
  );
  return /* @__PURE__ */ L.jsx(
    Zr.LexicalTypeaheadMenuPlugin,
    {
      onQueryChange: t,
      onSelectOption: l,
      triggerFn: s,
      options: a,
      menuRenderFn: (u, { selectedIndex: d, selectOptionAndCleanUp: p, setHighlightedIndex: m }) => u.current == null || a.length === 0 ? null : u.current && a.length ? wi.createPortal(
        /* @__PURE__ */ L.jsx("div", { className: "typeahead-popover emoji-menu", children: /* @__PURE__ */ L.jsx("ul", { children: a.map((c, h) => /* @__PURE__ */ L.jsx("div", { children: /* @__PURE__ */ L.jsx(
          Fv,
          {
            index: h,
            isSelected: d === h,
            onClick: () => {
              m(h), p(c);
            },
            onMouseEnter: () => {
              m(h);
            },
            option: c
          }
        ) }, c.key)) }) }),
        u.current
      ) : null
    }
  );
}
function ja(r) {
  return r instanceof HTMLElement;
}
class Ch {
  constructor(e, t) {
    Ye(this, "_x");
    Ye(this, "_y");
    this._x = e, this._y = t;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  equals({ x: e, y: t }) {
    return this.x === e && this.y === t;
  }
  calcDeltaXTo({ x: e }) {
    return this.x - e;
  }
  calcDeltaYTo({ y: e }) {
    return this.y - e;
  }
  calcHorizontalDistanceTo(e) {
    return Math.abs(this.calcDeltaXTo(e));
  }
  calcVerticalDistance(e) {
    return Math.abs(this.calcDeltaYTo(e));
  }
  calcDistanceTo(e) {
    return Math.sqrt(
      Math.pow(this.calcDeltaXTo(e), 2) + Math.pow(this.calcDeltaYTo(e), 2)
    );
  }
}
function Hv(r) {
  return r instanceof Ch;
}
class bn {
  constructor(e, t, n, i) {
    Ye(this, "_left");
    Ye(this, "_top");
    Ye(this, "_right");
    Ye(this, "_bottom");
    const [o, s] = t <= i ? [t, i] : [i, t], [a, l] = e <= n ? [e, n] : [n, e];
    this._top = o, this._right = l, this._left = a, this._bottom = s;
  }
  get top() {
    return this._top;
  }
  get right() {
    return this._right;
  }
  get bottom() {
    return this._bottom;
  }
  get left() {
    return this._left;
  }
  get width() {
    return Math.abs(this._left - this._right);
  }
  get height() {
    return Math.abs(this._bottom - this._top);
  }
  equals({ top: e, left: t, bottom: n, right: i }) {
    return e === this._top && n === this._bottom && t === this._left && i === this._right;
  }
  contains(e) {
    if (Hv(e)) {
      const { x: t, y: n } = e, i = n < this._top, o = n > this._bottom, s = t < this._left, a = t > this._right;
      return {
        reason: {
          isOnBottomSide: o,
          isOnLeftSide: s,
          isOnRightSide: a,
          isOnTopSide: i
        },
        result: !i && !o && !s && !a
      };
    } else {
      const { top: t, left: n, bottom: i, right: o } = e;
      return t >= this._top && t <= this._bottom && i >= this._top && i <= this._bottom && n >= this._left && n <= this._right && o >= this._left && o <= this._right;
    }
  }
  intersectsWith(e) {
    const { left: t, top: n, width: i, height: o } = e, { left: s, top: a, width: l, height: u } = this, d = t + i >= s + l ? t + i : s + l, p = n + o >= a + u ? n + o : a + u, m = t <= s ? t : s, c = n <= a ? n : a;
    return d - m <= i + l && p - c <= o + u;
  }
  generateNewRect({
    left: e = this.left,
    top: t = this.top,
    right: n = this.right,
    bottom: i = this.bottom
  }) {
    return new bn(e, t, n, i);
  }
  static fromLTRB(e, t, n, i) {
    return new bn(e, t, n, i);
  }
  static fromLWTH(e, t, n, i) {
    return new bn(e, n, e + t, n + i);
  }
  static fromPoints(e, t) {
    const { y: n, x: i } = e, { y: o, x: s } = t;
    return bn.fromLTRB(i, n, s, o);
  }
  static fromDOM(e) {
    const { top: t, width: n, left: i, height: o } = e.getBoundingClientRect();
    return bn.fromLWTH(i, n, t, o);
  }
}
const ls = 4, jv = 2, qv = "draggable-block-menu", gu = "application/x-lexical-drag-block", pu = 28, Kv = 1, Uv = -1, vu = 0;
let go = 1 / 0;
function Yv(r) {
  return r === 0 ? 1 / 0 : go >= 0 && go < r ? go : Math.floor(r / 2);
}
function Wv(r) {
  return r.getEditorState().read(() => gs().getChildrenKeys());
}
function bh(r) {
  const e = (l, u) => l ? parseFloat(window.getComputedStyle(l)[u]) : 0, { marginTop: t, marginBottom: n } = window.getComputedStyle(r), i = e(
    r.previousElementSibling,
    "marginBottom"
  ), o = e(
    r.nextElementSibling,
    "marginTop"
  ), s = Math.max(
    parseFloat(t),
    i
  );
  return { marginBottom: Math.max(
    parseFloat(n),
    o
  ), marginTop: s };
}
function qa(r, e, t, n = !1) {
  const i = r.getBoundingClientRect(), o = Wv(e);
  let s = null;
  return e.getEditorState().read(() => {
    if (n) {
      const [u, d] = [
        e.getElementByKey(o[0]),
        e.getElementByKey(o[o.length - 1])
      ], [p, m] = [
        u == null ? void 0 : u.getBoundingClientRect(),
        d == null ? void 0 : d.getBoundingClientRect()
      ];
      if (p && m && (t.y < p.top ? s = u : t.y > m.bottom && (s = d), s))
        return;
    }
    let a = Yv(o.length), l = vu;
    for (; a >= 0 && a < o.length; ) {
      const u = o[a], d = e.getElementByKey(u);
      if (d === null)
        break;
      const p = new Ch(t.x, t.y), m = bn.fromDOM(d), { marginTop: c, marginBottom: h } = bh(d), f = m.generateNewRect({
        bottom: m.bottom + h,
        left: i.left,
        right: i.right,
        top: m.top - c
      }), {
        result: N,
        reason: { isOnTopSide: v, isOnBottomSide: C }
      } = f.contains(p);
      if (N) {
        s = d, go = a;
        break;
      }
      l === vu && (v ? l = Uv : C ? l = Kv : l = 1 / 0), a += l;
    }
  }), s;
}
function Gv(r) {
  return !!r.closest(`.${qv}`);
}
function Vv(r, e, t) {
  if (!r) {
    e.style.opacity = "0", e.style.transform = "translate(-10000px, -10000px)";
    return;
  }
  const n = r.getBoundingClientRect(), i = window.getComputedStyle(r), o = e.getBoundingClientRect(), s = t.getBoundingClientRect(), a = n.top + (parseInt(i.lineHeight, 10) - o.height) / 2 - s.top, l = ls;
  e.style.opacity = "1", e.style.transform = `translate(${l}px, ${a}px)`;
}
function Xv(r, e) {
  const { transform: t } = e.style;
  e.style.transform = "translateZ(0)", r.setDragImage(e, 0, 0), setTimeout(() => {
    e.style.transform = t;
  });
}
function Jv(r, e, t, n) {
  const { top: i, height: o } = e.getBoundingClientRect(), { top: s, width: a } = n.getBoundingClientRect(), { marginTop: l, marginBottom: u } = bh(e);
  let d = i;
  t >= i ? d += o + u / 2 : d -= l / 2;
  const p = d - s - jv, m = pu - ls;
  r.style.transform = `translate(${m}px, ${p}px)`, r.style.width = `${a - (pu - ls) * 2}px`, r.style.opacity = ".4";
}
function Zv(r) {
  r && (r.style.opacity = "0", r.style.transform = "translate(-10000px, -10000px)");
}
function Qv(r, e, t) {
  const n = e.parentElement, i = Rt(null), o = Rt(null), s = Rt(!1), [a, l] = Ie(null);
  We(() => {
    function p(c) {
      const h = c.target;
      if (!ja(h)) {
        l(null);
        return;
      }
      if (Gv(h))
        return;
      const f = qa(e, r, c);
      l(f);
    }
    function m() {
      l(null);
    }
    return n == null || n.addEventListener("mousemove", p), n == null || n.addEventListener("mouseleave", m), () => {
      n == null || n.removeEventListener("mousemove", p), n == null || n.removeEventListener("mouseleave", m);
    };
  }, [n, e, r]), We(() => {
    i.current && Vv(a, i.current, e);
  }, [e, a]), We(() => {
    function p(c) {
      if (!s.current)
        return !1;
      const [h] = fr.eventFiles(c);
      if (h)
        return !1;
      const { pageY: f, target: N } = c;
      if (!ja(N))
        return !1;
      const v = qa(e, r, c, !0), C = o.current;
      return v === null || C === null ? !1 : (Jv(C, v, f, e), c.preventDefault(), !0);
    }
    function m(c) {
      if (!s.current)
        return !1;
      const [h] = fr.eventFiles(c);
      if (h)
        return !1;
      const { target: f, dataTransfer: N, pageY: v } = c, C = (N == null ? void 0 : N.getData(gu)) || "", g = us(C);
      if (!g || !ja(f))
        return !1;
      const x = qa(e, r, c, !0);
      if (!x)
        return !1;
      const b = Ci(x);
      if (!b)
        return !1;
      if (b === g)
        return !0;
      const A = x.getBoundingClientRect().top;
      return v >= A ? b.insertAfter(g) : b.insertBefore(g), l(null), !0;
    }
    return ut.mergeRegister(
      r.registerCommand(
        hs,
        (c) => p(c),
        qt
      ),
      r.registerCommand(
        fs,
        (c) => m(c),
        cn
      )
    );
  }, [e, r]);
  function u(p) {
    const m = p.dataTransfer;
    if (!m || !a)
      return;
    Xv(m, a);
    let c = "";
    r.update(() => {
      const h = Ci(a);
      h && (c = h.getKey());
    }), s.current = !0, m.setData(gu, c);
  }
  function d() {
    s.current = !1, Zv(o.current);
  }
  return Qr(
    /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
      /* @__PURE__ */ L.jsx(
        "div",
        {
          className: "icon draggable-block-menu",
          ref: i,
          draggable: !0,
          onDragStart: u,
          onDragEnd: d,
          children: /* @__PURE__ */ L.jsx("div", { className: t ? "icon" : "" })
        }
      ),
      /* @__PURE__ */ L.jsx("div", { className: "draggable-block-target-line", ref: o })
    ] }),
    e
  );
}
function e2({
  anchorElem: r = document.body
}) {
  const [e] = Ot.useLexicalComposerContext();
  return Qv(e, r, e._editable);
}
const t2 = nt.lazy(() => import("./DataMentionComponent-CU51hfNB.js"));
function r2(r) {
  const e = r.getAttribute("data-mention-data"), t = r.getAttribute("data-mention-type"), n = r.getAttribute("data-mention-field"), i = r.getAttribute("data-mention-label"), o = r.getAttribute("data-mention-step");
  return t !== null && n !== null && i !== null && o !== null ? {
    node: wo({ dataMention: t, fieldName: n, label: i, data: e, step: parseInt(o) })
  } : null;
}
class Si extends mn {
  constructor(t, n, i, o, s, a, l) {
    super(l);
    Ye(this, "__dataMention");
    Ye(this, "__fieldName");
    Ye(this, "__label");
    Ye(this, "__value");
    Ye(this, "__data");
    Ye(this, "__step");
    Ye(this, "defaultStep", 1);
    this.__dataMention = t, this.__fieldName = n, this.__label = i, this.__value = s, this.__data = o, this.__step = a || this.defaultStep;
  }
  static getType() {
    return "data-mention";
  }
  static clone(t) {
    return new Si(
      t.__dataMention,
      t.__fieldName,
      t.__label,
      t.__data,
      t.__value,
      t.__step,
      t.__key
    );
  }
  static importJSON(t) {
    const {
      dataMention: n,
      fieldName: i,
      label: o,
      data: s,
      value: a
    } = t, l = wo({ dataMention: n, fieldName: i, label: o, data: s, step: this.prototype.defaultStep });
    if (n === "input" && l.__value) {
      const u = l.__value;
      if (a) {
        const d = u.parseEditorState(a.editorState);
        d.isEmpty() || u.setEditorState(d);
      }
    }
    return l;
  }
  exportDOM() {
    var n;
    const t = document.createElement("span");
    return t.setAttribute("data-mention-type", this.__dataMention), t.setAttribute("data-mention-step", this.__step.toString()), t.setAttribute("data-mention-field", this.__fieldName), t.setAttribute("data-mention-label", this.__label), t.setAttribute("data-lexical-data-mention", "true"), t.setAttribute("data-mention-data", ((n = this.__data) == null ? void 0 : n.toString()) || ""), { element: t };
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return {
      span: (t) => t.hasAttribute("data-lexical-data-mention") ? {
        conversion: r2,
        priority: 1
      } : null
    };
  }
  exportJSON() {
    return {
      dataMention: this.__dataMention,
      fieldName: this.__fieldName,
      label: this.__label,
      value: this.__value && this.__value.toJSON(),
      data: this.__data,
      version: 1,
      type: "data-mention"
    };
  }
  createDOM(t) {
    var s;
    const n = document.createElement("span");
    n.setAttribute("data-mention-type", this.__dataMention), n.setAttribute("data-mention-step", this.__step.toString()), n.setAttribute("data-mention-field", this.__fieldName), n.setAttribute("data-mention-label", this.__label), n.setAttribute("data-lexical-data-mention", "true"), n.setAttribute("data-mention-data", ((s = this.__data) == null ? void 0 : s.toString()) || "");
    const o = t.theme.dataMention;
    return o !== void 0 && (n.className = o), n;
  }
  setData(t) {
    const n = this.getWritable();
    n.__data = t;
  }
  decorate() {
    return /* @__PURE__ */ L.jsx(An, { fallback: null, children: /* @__PURE__ */ L.jsx(
      t2,
      {
        dataMention: this.__dataMention,
        label: this.__label,
        value: this.__value,
        data: this.__data,
        step: this.__step
      }
    ) });
  }
}
const wo = ({ dataMention: r, fieldName: e, label: t, data: n, value: i, step: o }) => {
  !i && r === "input" && (i = To());
  const s = new Si(r, e, t, n, i, o);
  return Oi(s);
}, yh = `\\.,\\+\\*\\?\\$\\@\\|#{}\\(\\)\\^\\-\\[\\]\\\\/!%'"~=<>_:;`, n2 = "\\b[A-Z][^\\s" + yh + "]", i2 = {
  NAME: n2,
  PUNCTUATION: yh
}, wh = i2.PUNCTUATION, rl = ["=\\$a", "=\\$i", "=\\$f"].join("|"), xi = "=$a", o2 = "=$i", a2 = "=$f", Th = "^(" + rl + ")\\s|[^" + wh + "\\s]", s2 = "(?:\\.[ |$]| |[" + wh + "]|)", l2 = 75, c2 = new RegExp(
  "(^|\\s|\\()((" + rl + ")((?:" + Th + s2 + "){0," + l2 + "}))$"
), u2 = 50, d2 = new RegExp(
  "(^|\\s|\\()((" + rl + ")((?:" + Th + "){0," + u2 + "}))$"
), h2 = 5, f2 = [
  {
    inputField: {
      label: "Create a new input",
      value: null
    }
  }
], Ka = /* @__PURE__ */ new Map(), m2 = {
  search(r, e, t) {
    setTimeout(() => {
      const n = e.filter(
        (i) => Object.keys(i).filter((o) => i[o].label.toLowerCase().includes(r.toLowerCase())).length > 0
      );
      t(n);
    }, 300);
  }
};
function g2(r, e, t = "") {
  const [n, i] = Ie([]);
  return We(() => {
    const o = Ka.get(t + r);
    if (r == null) {
      i([]);
      return;
    }
    if (o !== null) {
      if (o !== void 0) {
        i(o);
        return;
      }
      Ka.set(t + r, null), m2.search(r, e, (s) => {
        Ka.set(t + r, s), i(s);
      });
    }
  }, [r, e, t]), n;
}
function p2(r, e) {
  let t = c2.exec(r);
  if (t === null && (t = d2.exec(r)), t !== null) {
    const n = t[1], i = t[4];
    if (i.length >= e)
      return {
        leadOffset: t.index + n.length,
        matchingString: i,
        replaceableString: t[3]
      };
  }
  return null;
}
function v2(r) {
  return p2(r, 0);
}
class x2 extends Zr.MenuOption {
  constructor(t, n, i, o) {
    super(t + i);
    Ye(this, "dataMention");
    Ye(this, "fieldName");
    Ye(this, "label");
    Ye(this, "data");
    this.dataMention = t, this.fieldName = n, this.label = i, this.data = o;
  }
}
function N2({
  index: r,
  isSelected: e,
  onClick: t,
  onMouseEnter: n,
  option: i
}) {
  let o = "item";
  return e && (o += " selected"), /* @__PURE__ */ L.jsx(
    "li",
    {
      tabIndex: -1,
      className: o,
      ref: i.setRefElement,
      role: "option",
      "aria-selected": e,
      id: "typeahead-item-" + r,
      onMouseEnter: n,
      onClick: t,
      children: /* @__PURE__ */ L.jsx("span", { className: "text", children: i.label })
    },
    i.key
  );
}
function _2({
  step: r,
  autoData: e,
  afterAutoData: t
}) {
  const [n] = Ot.useLexicalComposerContext(), [i, o] = Ie(null), [s, a] = Ie(), [l, u] = Ie(), [d, p] = Ie(!1), [m, c] = Ie(null), f = g2(i, s === xi ? e : s === a2 ? t : f2, s), N = Zr.useBasicTypeaheadTriggerMatch("/", {
    minLength: 0
  }), v = Sr(
    () => f.map(
      (x) => {
        const b = Object.keys(x)[0];
        return new x2(s === xi ? "auto" : "after-auto", b, x[b].label, x[b].value);
      }
    ).slice(0, h2),
    [f]
  ), C = ct(
    (x, b, A) => {
      if (x.fieldName === "inputField") {
        p(!0), c({ nodeToReplace: b, selectedOption: x }), A();
        return;
      }
      n.update(() => {
        console.log(s, xi, s === xi);
        const w = wo(
          {
            dataMention: s === xi ? "auto" : s == o2 ? "input" : "after-auto",
            fieldName: x.fieldName,
            label: x.label,
            data: x.data
          }
        );
        b && b.replace(w), A();
      });
    },
    [n, s]
  ), g = ct(
    (x) => {
      if (N(x, n) !== null)
        return null;
      const A = v2(x);
      return A !== null && a(A.replaceableString), A;
    },
    [N, n]
  );
  return We(() => {
    r === 2 && n.registerCommand(
      Vn,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      (x, b) => {
        var A, w;
        return ((A = b.getRootElement()) == null ? void 0 : A.className) === "DataMention__contentEditable" && !n.isEditable() ? (n.setEditable(!0), b.focus()) : ((w = b.getRootElement()) == null ? void 0 : w.className) !== "DataMention__contentEditable" && n.isEditable() && n.setEditable(!1), !0;
      },
      qt
    );
  }, [r, n]), /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx(
      Zr.LexicalTypeaheadMenuPlugin,
      {
        onQueryChange: o,
        onSelectOption: C,
        triggerFn: g,
        options: v,
        menuRenderFn: (x, { selectedIndex: b, selectOptionAndCleanUp: A, setHighlightedIndex: w }) => x.current && f.length ? wi.createPortal(
          /* @__PURE__ */ L.jsx("div", { className: "typeahead-popover mentions-menu", children: /* @__PURE__ */ L.jsx("ul", { children: v.map((M, y) => /* @__PURE__ */ L.jsx(
            N2,
            {
              index: y,
              isSelected: b === y,
              onClick: () => {
                w(y), A(M);
              },
              onMouseEnter: () => {
                w(y);
              },
              option: M
            },
            M.key
          )) }) }),
          x.current
        ) : null
      }
    ),
    d && m && wi.createPortal(
      /* @__PURE__ */ L.jsxs("div", { className: "data-mention-input-modal", children: [
        /* @__PURE__ */ L.jsx(
          "input",
          {
            placeholder: "Enter label of input field",
            value: l || "",
            type: "text",
            onChange: (x) => {
              u(x.target.value);
            }
          }
        ),
        /* @__PURE__ */ L.jsx("button", { onClick: () => {
          n.update(() => {
            const x = wo(
              {
                dataMention: "input",
                fieldName: m.selectedOption.fieldName,
                label: l || "Empty",
                data: null
              }
            );
            m.nodeToReplace && m.nodeToReplace.replace(x), p(!1), c(null);
          });
        }, children: "Save" })
      ] }),
      document.body
    )
  ] });
}
var Ua = {}, xu;
function C2() {
  if (xu) return Ua;
  xu = 1;
  var r = lt(), e = nt, i = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? e.useLayoutEffect : e.useEffect;
  function o({
    ignoreHistoryMergeTagChange: s = !0,
    ignoreSelectionChange: a = !1,
    onChange: l
  }) {
    const [u] = r.useLexicalComposerContext();
    return i(() => {
      if (l)
        return u.registerUpdateListener(({
          editorState: d,
          dirtyElements: p,
          dirtyLeaves: m,
          prevEditorState: c,
          tags: h
        }) => {
          a && p.size === 0 && m.size === 0 || s && h.has("history-merge") || c.isEmpty() || l(d, u, h);
        });
    }, [u, s, a, l]), null;
  }
  return Ua.OnChangePlugin = o, Ua;
}
var Ya = {}, Nu;
function b2() {
  if (Nu) return Ya;
  Nu = 1;
  var r = lt(), e = nt, t = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? e.useLayoutEffect : e.useEffect;
  return Ya.OnChangePlugin = function({ ignoreHistoryMergeTagChange: n = !0, ignoreSelectionChange: i = !1, onChange: o }) {
    let [s] = r.useLexicalComposerContext();
    return t(() => {
      if (o) return s.registerUpdateListener(({ editorState: a, dirtyElements: l, dirtyLeaves: u, prevEditorState: d, tags: p }) => {
        i && l.size === 0 && u.size === 0 || n && p.has("history-merge") || d.isEmpty() || o(a, s, p);
      });
    }, [s, n, i, o]), null;
  }, Ya;
}
const y2 = process.env.NODE_ENV === "development" ? C2() : b2();
var w2 = y2;
function T2(r) {
  const { step: e, autoMentionData: t, autoAfterMentionData: n, onChange: i = () => {
  } } = r, { historyState: o } = Tp(), s = /* @__PURE__ */ L.jsx(Qp, { children: "Enter text..." }), [a, l] = Ie(null), [u, d] = Ie(!1), [p, m] = Ie(!1), c = (h) => {
    h !== null && l(h);
  };
  return We(() => {
    const h = () => {
      const f = ii && window.matchMedia("(max-width: 1025px)").matches;
      f !== u && d(f);
    };
    return h(), window.addEventListener("resize", h), () => {
      window.removeEventListener("resize", h);
    };
  }, [u]), /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx(x4, { setIsLinkEditMode: m }),
    /* @__PURE__ */ L.jsxs("div", { className: "editor-container", children: [
      /* @__PURE__ */ L.jsx(Iv, {}),
      /* @__PURE__ */ L.jsx(Kp.AutoFocusPlugin, {}),
      /* @__PURE__ */ L.jsx(fv, {}),
      /* @__PURE__ */ L.jsx(zv, {}),
      /* @__PURE__ */ L.jsx(h4, {}),
      /* @__PURE__ */ L.jsx(_2, { step: e, autoData: t, afterAutoData: n }),
      /* @__PURE__ */ L.jsx(av, {}),
      /* @__PURE__ */ L.jsx(rv, {}),
      /* @__PURE__ */ L.jsx(w2.OnChangePlugin, { ignoreSelectionChange: !0, onChange: i }),
      /* @__PURE__ */ L.jsx(Jd.HistoryPlugin, { externalHistoryState: o }),
      /* @__PURE__ */ L.jsx(U4, {}),
      /* @__PURE__ */ L.jsx(
        $p.RichTextPlugin,
        {
          contentEditable: /* @__PURE__ */ L.jsx("div", { className: "editor-scroller", children: /* @__PURE__ */ L.jsx("div", { className: "editor", ref: c, children: /* @__PURE__ */ L.jsx(i1, {}) }) }),
          placeholder: s,
          ErrorBoundary: zp
        }
      ),
      /* @__PURE__ */ L.jsx(b4.ListPlugin, {}),
      /* @__PURE__ */ L.jsx(E4.CheckListPlugin, {}),
      /* @__PURE__ */ L.jsx(M4, { maxDepth: 7 }),
      /* @__PURE__ */ L.jsx(
        wv.TablePlugin,
        {
          hasCellMerge: !0,
          hasCellBackgroundColor: !0
        }
      ),
      /* @__PURE__ */ L.jsx(Mv, {}),
      /* @__PURE__ */ L.jsx(_1, {}),
      /* @__PURE__ */ L.jsx(L1, {}),
      /* @__PURE__ */ L.jsx(X4, {}),
      /* @__PURE__ */ L.jsx(H1, {}),
      /* @__PURE__ */ L.jsx(n4, {}),
      /* @__PURE__ */ L.jsx(i4, {}),
      /* @__PURE__ */ L.jsx(r4, {}),
      /* @__PURE__ */ L.jsx(Zp.HorizontalRulePlugin, {}),
      /* @__PURE__ */ L.jsx(V1, {}),
      /* @__PURE__ */ L.jsx(B1, {}),
      /* @__PURE__ */ L.jsx(k4, {}),
      /* @__PURE__ */ L.jsx(Gp.TabIndentationPlugin, {}),
      /* @__PURE__ */ L.jsx(X1, {}),
      /* @__PURE__ */ L.jsx(m1, {}),
      /* @__PURE__ */ L.jsx(q1, {}),
      a && !u && /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
        /* @__PURE__ */ L.jsx(
          e2,
          {
            anchorElem: a
          }
        ),
        /* @__PURE__ */ L.jsx(
          F4,
          {
            anchorElem: a,
            isLinkEditMode: p,
            setIsLinkEditMode: m
          }
        ),
        /* @__PURE__ */ L.jsx(
          _v,
          {
            anchorElem: a
          }
        ),
        /* @__PURE__ */ L.jsx(
          $v,
          {
            anchorElem: a,
            cellMerge: !0
          }
        )
      ] })
    ] })
  ] });
}
function $2(r) {
  const {
    editorState: e,
    historyState: t,
    onChange: n,
    autoAfterMentionData: i = [],
    autoMentionData: o = [],
    step: s = 1
  } = r;
  Si.prototype.defaultStep = s;
  const a = {
    editorState: e,
    namespace: "Doc App",
    editable: s === 1,
    theme: ef,
    onError: (l) => {
      console.log("Error:", l.message);
    },
    nodes: [...xp, Si]
  };
  return /* @__PURE__ */ L.jsx(Qh.LexicalComposer, { initialConfig: a, children: /* @__PURE__ */ L.jsx(wp, { initHistoryState: t, children: /* @__PURE__ */ L.jsx("div", { className: "editor-shell", children: /* @__PURE__ */ L.jsx(T2, { step: s, autoAfterMentionData: i, autoMentionData: o, onChange: n }) }) }) });
}
export {
  Gf as $,
  ko as A,
  Ir as B,
  Qd as C,
  oi as D,
  av as E,
  _v as F,
  ii as G,
  ef as H,
  i1 as I,
  D2 as J,
  rv as K,
  Kp as L,
  O1 as M,
  $2 as N,
  Qp as P,
  M1 as S,
  fn as T,
  X4 as a,
  Jd as b,
  $p as c,
  n1 as d,
  zp as e,
  jf as f,
  Ot as g,
  ut as h,
  hf as i,
  L as j,
  ev as k,
  A2 as l,
  Y1 as m,
  W1 as n,
  L2 as o,
  k2 as p,
  p1 as q,
  lt as r,
  sc as s,
  Do as t,
  Tp as u,
  gp as v,
  Wu as w,
  en as x,
  it as y,
  Gs as z
};
